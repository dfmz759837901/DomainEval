{"method_name": "print_figure", "full_method_name": "print_figure", "method_path": "../srcdata/Computation/ipython/IPython/core/pylabtools.py", "method_code": "from io import BytesIO\nfrom binascii import b2a_base64\nfrom functools import partial\nimport warnings\nfrom IPython.core.display import _pngxy\nfrom IPython.utils.decorators import flag_calls\nfrom matplotlib._pylab_helpers import Gcf\nimport matplotlib\nfrom matplotlib.backend_bases import FigureCanvasBase\nimport matplotlib.pyplot as plt\nfrom matplotlib.figure import Figure\nfrom IPython.core.pylabtools import backends\nfrom IPython.core.pylabtools import backend2gui\nfrom matplotlib import pyplot as plt\nfrom IPython.display import display\nfrom matplotlib_inline.backend_inline import configure_inline_support as configure_inline_support_orig\nfrom IPython.core import pylabtools\ndef print_figure(fig, fmt='png', bbox_inches='tight', base64=False, **kwargs):\n    \"\"\"Print a figure to an image, and return the resulting file data\n\n    Returned data will be bytes unless ``fmt='svg'``,\n    in which case it will be unicode.\n\n    Any keyword args are passed to fig.canvas.print_figure,\n    such as ``quality`` or ``bbox_inches``.\n\n    If `base64` is True, return base64-encoded str instead of raw bytes\n    for binary-encoded image formats\n\n    .. versionadded:: 7.29\n        base64 argument\n    \"\"\"\n    if not fig.axes and not fig.lines:\n        return\n    dpi = fig.dpi\n    if fmt == 'retina':\n        dpi = dpi * 2\n        fmt = 'png'\n    kw = {'format': fmt, 'facecolor': fig.get_facecolor(), 'edgecolor': fig\n        .get_edgecolor(), 'dpi': dpi, 'bbox_inches': bbox_inches}\n    kw.update(kwargs)\n    bytes_io = BytesIO()\n    if fig.canvas is None:\n        from matplotlib.backend_bases import FigureCanvasBase\n        FigureCanvasBase(fig)\n    fig.canvas.print_figure(bytes_io, **kw)\n    data = bytes_io.getvalue()\n    if fmt == 'svg':\n        data = data.decode('utf-8')\n    elif base64:\n        data = b2a_base64(data, newline=False).decode('ascii')\n    return data", "test_code_list": [{"test_code": "from binascii import a2b_base64\nfrom io import BytesIO\nimport pytest\nfrom matplotlib.figure import Figure\nfrom matplotlib import pyplot as plt\nfrom matplotlib_inline import backend_inline\nimport numpy as np\nfrom IPython.core.getipython import get_ipython\nfrom IPython.core.interactiveshell import InteractiveShell\nfrom IPython.core.display import _PNG\nfrom IPython.core.display import _JPEG\nfrom IPython.testing import decorators as dec\nfrom PIL import Image\nimport matplotlib\ndef test_figure_to_svg():\n    fig = plt.figure()\n    assert print_figure(fig, 'svg') is None\n    plt.close('all')\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot([1, 2, 3])\n    plt.draw()\n    svg = print_figure(fig, 'svg')[:100].lower()\n    assert 'doctype svg' in svg\n\ntest_figure_to_svg()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_pylabtools.py"}], "instruction": "Functionality: The print_figure function is designed to print a matplotlib figure to an image format and return the resulting file data. It supports various image formats and allows for the customization of parameters such as the bounding box of the figure, image quality, and whether the output should be base64 encoded. This function is particularly useful for integrating figures into web applications or documents where the figure data needs to be encoded in a format that can be easily transmitted or displayed.\n\nInputs: \n- fig: A matplotlib figure object that you want to convert to an image format.\n- fmt: A string specifying the output format of the figure (default is 'png'). Supported formats include 'png', 'svg', 'retina' (which prints a PNG at twice the DPI).\n- bbox_inches: A string or Bbox object specifying what to include in the bounding box (default is 'tight'). 'tight' ensures that the entire figure, including labels and axes, is included.\n- base64: A boolean indicating whether to return the image data as a base64 encoded string (default is False).\n- **kwargs: Additional keyword arguments that can be passed to fig.canvas.print_figure, such as 'quality'.\n\nOutputs:\n- data: The output of this function is the image data of the figure in the specified format. The data will be bytes unless fmt='svg', in which case it will be a unicode string. If base64 is True, the data will be returned as a base64 encoded string, making it suitable for embedding in HTML or other text-based formats.", "method_code_mask": "from io import BytesIO\nfrom binascii import b2a_base64\nfrom functools import partial\nimport warnings\nfrom IPython.core.display import _pngxy\nfrom IPython.utils.decorators import flag_calls\nfrom matplotlib._pylab_helpers import Gcf\nimport matplotlib\nfrom matplotlib.backend_bases import FigureCanvasBase\nimport matplotlib.pyplot as plt\nfrom matplotlib.figure import Figure\nfrom IPython.core.pylabtools import backends\nfrom IPython.core.pylabtools import backend2gui\nfrom matplotlib import pyplot as plt\nfrom IPython.display import display\nfrom matplotlib_inline.backend_inline import configure_inline_support as configure_inline_support_orig\nfrom IPython.core import pylabtools\n\n\ndef print_figure(fig, fmt='png', bbox_inches='tight', base64=False, **kwargs\n    ): [MASK]\n"}
{"method_name": "make_tokens_by_line", "full_method_name": "make_tokens_by_line", "method_path": "../srcdata/Computation/ipython/IPython/core/inputtransformer2.py", "method_code": "import ast\nfrom codeop import CommandCompiler\nfrom codeop import Compile\nimport re\nimport sys\nimport tokenize\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import Any\nimport warnings\nfrom IPython.utils import tokenutil\ndef make_tokens_by_line(lines: List[str]):\n    \"\"\"Tokenize a series of lines and group tokens by line.\n\n    The tokens for a multiline Python string or expression are grouped as one\n    line. All lines except the last lines should keep their line ending ('\\\\n',\n    '\\\\r\\\\n') for this to properly work. Use `.splitlines(keeplineending=True)`\n    for example when passing block of text to this function.\n\n    \"\"\"\n    NEWLINE, NL = tokenize.NEWLINE, tokenize.NL\n    tokens_by_line: List[List[Any]] = [[]]\n    if len(lines) > 1 and not lines[0].endswith(('\\n', '\\r', '\\r\\n', '\\x0b',\n        '\\x0c')):\n        warnings.warn(\n            \"`make_tokens_by_line` received a list of lines which do not have lineending markers ('\\\\n', '\\\\r', '\\\\r\\\\n', '\\\\x0b', '\\\\x0c'), behavior will be unspecified\"\n            , stacklevel=2)\n    parenlev = 0\n    try:\n        for token in tokenutil.generate_tokens_catch_errors(iter(lines).\n            __next__, extra_errors_to_catch=['expected EOF']):\n            tokens_by_line[-1].append(token)\n            if token.type == NEWLINE or token.type == NL and parenlev <= 0:\n                tokens_by_line.append([])\n            elif token.string in {'(', '[', '{'}:\n                parenlev += 1\n            elif token.string in {')', ']', '}'}:\n                if parenlev > 0:\n                    parenlev -= 1\n    except tokenize.TokenError:\n        pass\n    if not tokens_by_line[-1]:\n        tokens_by_line.pop()\n    return tokens_by_line", "test_code_list": [{"test_code": "import platform\nimport string\nimport sys\nfrom textwrap import dedent\nimport pytest\nfrom IPython.core import inputtransformer2 as ipt2\nfrom IPython.core.inputtransformer2 import _find_assign_op\nfrom IPython.core.inputtransformer2 import make_tokens_by_line\nfrom string import printable\ndef test_check_make_token_by_line_never_ends_empty():\n    \"\"\"\n    Check that not sequence of single or double characters ends up leading to en empty list of tokens\n    \"\"\"\n    from string import printable\n    for c in printable:\n        assert make_tokens_by_line(c)[-1] != []\n        for k in printable:\n            assert make_tokens_by_line(c + k)[-1] != []\n\ntest_check_make_token_by_line_never_ends_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_inputtransformer2.py"}], "instruction": "Functionality: The make_tokens_by_line function tokenizes a series of lines and groups the resulting tokens by line. It is particularly useful for processing multiline Python strings or expressions where tokens are grouped as part of the same line. This ensures that all tokens within the same logical line are kept together, regardless of physical line breaks. The function correctly handles line endings by keeping them intact for all but the last line, assuming the input lines are split with keepends=True.\nInputs: lines: List[str] - A list of strings, where each string represents a line of code. It is important that these lines include their line ending markers ('\\\\n', '\\\\r\\\\n') to ensure the function works as expected. The function will issue a warning if the first line does not end with one of the specified line endings.\nOutputs: List[List[Any]] - A list of lists, where each inner list contains an array of tokens for each line of input. The tokens are objects with attributes that include the type of token, the string representation of the token, and additional metadata such as the line number and the starting and ending indices of the token in the input string. This structure allows for easy analysis and manipulation of the tokens on a per-line basis.", "method_code_mask": "import ast\nfrom codeop import CommandCompiler\nfrom codeop import Compile\nimport re\nimport sys\nimport tokenize\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import Any\nimport warnings\nfrom IPython.utils import tokenutil\n\n\ndef make_tokens_by_line(lines: List[str]): [MASK]\n"}
{"method_name": "_find_assign_op", "full_method_name": "_find_assign_op", "method_path": "../srcdata/Computation/ipython/IPython/core/inputtransformer2.py", "method_code": "import ast\nfrom codeop import CommandCompiler\nfrom codeop import Compile\nimport re\nimport sys\nimport tokenize\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import Any\nimport warnings\nfrom IPython.utils import tokenutil\ndef _find_assign_op(token_line) ->Optional[int]:\n    \"\"\"Get the index of the first assignment in the line ('=' not inside brackets)\n\n    Note: We don't try to support multiple special assignment (a = b = %foo)\n    \"\"\"\n    paren_level = 0\n    for i, ti in enumerate(token_line):\n        s = ti.string\n        if s == '=' and paren_level == 0:\n            return i\n        if s in {'(', '[', '{'}:\n            paren_level += 1\n        elif s in {')', ']', '}'}:\n            if paren_level > 0:\n                paren_level -= 1\n    return None", "test_code_list": [{"test_code": "import platform\nimport string\nimport sys\nfrom textwrap import dedent\nimport pytest\nfrom IPython.core import inputtransformer2 as ipt2\nfrom IPython.core.inputtransformer2 import _find_assign_op\nfrom IPython.core.inputtransformer2 import make_tokens_by_line\nfrom string import printable\ndef test_find_assign_op_dedent():\n    \"\"\"\n    be careful that empty token like dedent are not counted as parens\n    \"\"\"\n\n\n    class Tk:\n\n        def __init__(self, s):\n            self.string = s\n    assert _find_assign_op([Tk(s) for s in ('', 'a', '=', 'b')]) == 2\n    assert _find_assign_op([Tk(s) for s in ('', '(', 'a', '=', 'b', ')',\n        '=', '5')]) == 6\n\ntest_find_assign_op_dedent()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_inputtransformer2.py"}], "instruction": "Functionality: _find_assign_op is a function designed to parse a line of code and find the index of the first simple assignment operator ('=') that is not enclosed within parentheses, brackets, or braces. This is useful for parsing code lines to understand where variable assignments begin. The function does not handle multiple special assignments (like a = b = %foo) in a single line.\n\nInputs: \n- token_line: A list of token objects representing a line of code. Each token object contains information about a particular part of the source code, such as the string representation of the token.\n\nOutputs: \n- Optional[int]: The index of the first simple assignment operator ('=') in the line that is not inside brackets. If no such assignment is found, the function returns None.", "method_code_mask": "import ast\nfrom codeop import CommandCompiler\nfrom codeop import Compile\nimport re\nimport sys\nimport tokenize\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import Any\nimport warnings\nfrom IPython.utils import tokenutil\n\n\ndef _find_assign_op(token_line) ->Optional[int]: [MASK]\n"}
{"method_name": "code_name", "full_method_name": "code_name", "method_path": "../srcdata/Computation/ipython/IPython/core/compilerop.py", "method_code": "import __future__\nfrom ast import PyCF_ONLY_AST\nimport codeop\nimport functools\nimport hashlib\nimport linecache\nimport operator\nimport time\nfrom contextlib import contextmanager\nimport warnings\ndef code_name(code, number=0):\n    \"\"\" Compute a (probably) unique name for code for caching.\n\n    This now expects code to be unicode.\n    \"\"\"\n    hash_digest = hashlib.sha1(code.encode('utf-8')).hexdigest()\n    return '<ipython-input-{0}-{1}>'.format(number, hash_digest[:12])", "test_code_list": [{"test_code": "import linecache\nimport sys\nfrom IPython.core import compilerop\ndef test_code_name():\n    code = 'x=1'\n    name = code_name(code)\n    assert name.startswith('<ipython-input-0')\n\ntest_code_name()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_compilerop.py"}, {"test_code": "import linecache\nimport sys\nfrom IPython.core import compilerop\ndef test_code_name2():\n    code = 'x=1'\n    name = code_name(code, 9)\n    assert name.startswith('<ipython-input-9')\n\ntest_code_name2()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_compilerop.py"}], "instruction": "Functionality: The code_name function is designed to generate a unique name for a given code snippet, which can be used for caching purposes. This unique name is derived by hashing the code using the SHA-1 algorithm and combining it with a number.\n\nInputs: \n1. code (str): A string containing the code snippet for which a unique name is to be generated. It is expected to be in unicode format.\n2. number (int, optional): A number used in the generation of the unique name. It is an optional argument, and if not provided, defaults to 0.\n\nOutputs:\n1. A string representing the unique name for the code snippet, in the format '<ipython-input-{number}-{hash_digest}>', where {number} is the provided number argument, and {hash_digest} is the first 12 characters of the SHA-1 hash of the code snippet.", "method_code_mask": "import __future__\nfrom ast import PyCF_ONLY_AST\nimport codeop\nimport functools\nimport hashlib\nimport linecache\nimport operator\nimport time\nfrom contextlib import contextmanager\nimport warnings\n\n\ndef code_name(code, number=0): [MASK]\n"}
{"method_name": "_should_be_async", "full_method_name": "_should_be_async", "method_path": "../srcdata/Computation/ipython/IPython/core/async_helpers.py", "method_code": "import ast\nimport asyncio\nimport inspect\nfrom functools import wraps\nimport trio\ndef _should_be_async(cell: str) ->bool:\n    \"\"\"Detect if a block of code need to be wrapped in an `async def`\n\n    Attempt to parse the block of code, it it compile we're fine.\n    Otherwise we  wrap if and try to compile.\n\n    If it works, assume it should be async. Otherwise Return False.\n\n    Not handled yet: If the block of code has a return statement as the top\n    level, it will be seen as async. This is a know limitation.\n    \"\"\"\n    try:\n        code = compile(cell, '<>', 'exec', flags=getattr(ast,\n            'PyCF_ALLOW_TOP_LEVEL_AWAIT', 0))\n        return inspect.CO_COROUTINE & code.co_flags == inspect.CO_COROUTINE\n    except (SyntaxError, MemoryError):\n        return False", "test_code_list": [{"test_code": "from itertools import chain\nfrom itertools import repeat\nfrom textwrap import dedent\nfrom textwrap import indent\nfrom typing import TYPE_CHECKING\nfrom unittest import TestCase\nimport pytest\nfrom IPython.core.async_helpers import _should_be_async\nfrom IPython.testing.decorators import skip_without\nfrom IPython import get_ipython\n\nclass AsyncTest(TestCase):\n\tdef test_should_be_async(self):\n\t    self.assertFalse(_should_be_async('False'))\n\t    self.assertTrue(_should_be_async('await bar()'))\n\t    self.assertTrue(_should_be_async('x = await bar()'))\n\t    self.assertFalse(_should_be_async(dedent(\n\t        \"\"\"\n\t            async def awaitable():\n\t                pass\n\t        \"\"\"\n\t        )))\n\t\nAsyncTest().test_should_be_async()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_async_helpers.py"}], "instruction": "Functionality: The function \"_should_be_async\" is designed to determine whether a given block of Python code should be wrapped in an async function. It does this by attempting to compile the provided code. If the code compiles successfully and is detected to have coroutine flags (indicating asynchronous behavior), the function returns True, suggesting the code should be executed asynchronously. If the code does not compile or does not have coroutine flags, the function returns False.\n\nInputs: \n- cell: A string representing a block of Python code. This could be a function, a series of statements, or any valid Python code snippet.\n\nOutputs: \n- A boolean value indicating whether the provided code snippet should be executed asynchronously. True if the code should be wrapped in an async function, False otherwise.", "method_code_mask": "import ast\nimport asyncio\nimport inspect\nfrom functools import wraps\nimport trio\n\n\ndef _should_be_async(cell: str) ->bool: [MASK]\n"}
{"method_name": "_unbind_method", "full_method_name": "_unbind_method", "method_path": "../srcdata/Computation/ipython/IPython/core/guarded_eval.py", "method_code": "from inspect import isclass\nfrom inspect import signature\nfrom inspect import Signature\nfrom typing import Annotated\nfrom typing import AnyStr\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Literal\nfrom typing import NamedTuple\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Protocol\nfrom typing import Set\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom typing import get_args\nfrom typing import get_origin\nimport ast\nimport builtins\nimport collections\nimport operator\nimport sys\nfrom functools import cached_property\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom types import MethodDescriptorType\nfrom types import ModuleType\nfrom IPython.utils.decorators import undoc\nfrom typing_extensions import Self\nfrom typing_extensions import LiteralString\nfrom typing_extensions import TypeAliasType\ndef _unbind_method(func: Callable) ->Union[Callable, None]:\n    \"\"\"Get unbound method for given bound method.\n\n    Returns None if cannot get unbound method, or method is already unbound.\n    \"\"\"\n    owner = getattr(func, '__self__', None)\n    owner_class = type(owner)\n    name = getattr(func, '__name__', None)\n    instance_dict_overrides = getattr(owner, '__dict__', None)\n    if owner is not None and name and (not instance_dict_overrides or \n        instance_dict_overrides and name not in instance_dict_overrides):\n        return getattr(owner_class, name)\n    return None", "test_code_list": [{"test_code": "import sys\nfrom contextlib import contextmanager\nfrom typing import Annotated\nfrom typing import AnyStr\nfrom typing import NamedTuple\nfrom typing import Literal\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Protocol\nfrom typing import Union\nfrom typing import TypedDict\nfrom functools import partial\nfrom IPython.core.guarded_eval import EvaluationContext\nfrom IPython.core.guarded_eval import GuardRejection\nfrom IPython.core.guarded_eval import guarded_eval\nfrom IPython.core.guarded_eval import _unbind_method\nfrom IPython.testing import decorators as dec\nimport pytest\nfrom typing_extensions import Self\nfrom typing_extensions import LiteralString\nfrom typing_extensions import TypeAliasType\nimport pandas as pd\nfrom pandas.testing import assert_series_equal\nimport numpy\ndef test_unbind_method():\n\n\n    class X(list):\n\n        def index(self, k):\n            return 'CUSTOM'\n    x = X()\n    assert _unbind_method(x.index) is X.index\n    assert _unbind_method([].index) is list.index\n    assert _unbind_method(list.index) is None\n\ntest_unbind_method()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_guarded_eval.py"}], "instruction": "Functionality: The function _unbind_method aims to retrieve the unbound method for a given bound method. If the method is already unbound or cannot be unbound, it returns None. The function works by inspecting the given method's attributes to determine if it is bound to an object and then attempts to retrieve the unbound version from the object's class.\n\nInputs: \n- func: A Callable representing the method for which to find the unbound version. This input is mandatory.\n\nOutputs: \n- Union[Callable, None]: The function returns either the unbound method as a Callable if successful, or None if the method is already unbound or cannot be unbound.", "method_code_mask": "from inspect import isclass\nfrom inspect import signature\nfrom inspect import Signature\nfrom typing import Annotated\nfrom typing import AnyStr\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Literal\nfrom typing import NamedTuple\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Protocol\nfrom typing import Set\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom typing import get_args\nfrom typing import get_origin\nimport ast\nimport builtins\nimport collections\nimport operator\nimport sys\nfrom functools import cached_property\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom types import MethodDescriptorType\nfrom types import ModuleType\nfrom IPython.utils.decorators import undoc\nfrom typing_extensions import Self\nfrom typing_extensions import LiteralString\nfrom typing_extensions import TypeAliasType\n\n\ndef _unbind_method(func: Callable) ->Union[Callable, None]: [MASK]\n"}
{"method_name": "getdoc", "full_method_name": "getdoc", "method_path": "../srcdata/Computation/ipython/IPython/core/oinspect.py", "method_code": "from dataclasses import dataclass\nfrom inspect import signature\nfrom textwrap import dedent\nimport ast\nimport html\nimport inspect\nimport io as stdlib_io\nimport linecache\nimport os\nimport types\nimport warnings\nfrom typing import cast\nfrom typing import Any\nfrom typing import Optional\nfrom typing import Dict\nfrom typing import Union\nfrom typing import List\nfrom typing import TypedDict\nfrom typing import Tuple\nimport traitlets\nfrom IPython.core import page\nfrom IPython.lib.pretty import pretty\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import PyColorize\nfrom IPython.utils import openpy\nfrom IPython.utils.dir2 import safe_hasattr\nfrom IPython.utils.path import compress_user\nfrom IPython.utils.text import indent\nfrom IPython.utils.wildcard import list_namespace\nfrom IPython.utils.wildcard import typestr2type\nfrom IPython.utils.coloransi import TermColors\nfrom IPython.utils.colorable import Colorable\nfrom IPython.utils.decorators import undoc\nfrom pygments import highlight\nfrom pygments.lexers import PythonLexer\nfrom pygments.formatters import HtmlFormatter\ndef getdoc(obj) ->Union[str, None]:\n    \"\"\"Stable wrapper around inspect.getdoc.\n\n    This can't crash because of attribute problems.\n\n    It also attempts to call a getdoc() method on the given object.  This\n    allows objects which provide their docstrings via non-standard mechanisms\n    (like Pyro proxies) to still be inspected by ipython's ? system.\n    \"\"\"\n    try:\n        ds = obj.getdoc()\n    except Exception:\n        pass\n    else:\n        if isinstance(ds, str):\n            return inspect.cleandoc(ds)\n    docstr = inspect.getdoc(obj)\n    return docstr", "test_code_list": [{"test_code": "from contextlib import contextmanager\nfrom inspect import signature\nfrom inspect import Signature\nfrom inspect import Parameter\nimport inspect\nimport os\nimport pytest\nimport re\nimport sys\nfrom decorator import decorator\nfrom IPython.testing.tools import AssertPrints\nfrom IPython.testing.tools import AssertNotPrints\nfrom IPython.utils.path import compress_user\nfrom typing import Optional\ndef test_getdoc():\n\n\n    class A(object):\n        \"\"\"standard docstring\"\"\"\n        pass\n\n\n    class B(object):\n        \"\"\"standard docstring\"\"\"\n\n        def getdoc(self):\n            return 'custom docstring'\n\n\n    class C(object):\n        \"\"\"standard docstring\"\"\"\n\n        def getdoc(self):\n            return None\n    a = A()\n    b = B()\n    c = C()\n    assert getdoc(a) == 'standard docstring'\n    assert getdoc(b) == 'custom docstring'\n    assert getdoc(c) == 'standard docstring'\n\ntest_getdoc()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_oinspect.py"}], "instruction": "Functionality: The getdoc function is a robust wrapper around Python's inspect.getdoc method. Its primary purpose is to retrieve the documentation string (docstring) of a given object in a stable manner, ensuring that the operation does not fail due to attribute-related issues. Additionally, it checks if the object has a getdoc() method and attempts to call it, enabling support for objects that provide their documentation through non-standard means.\n\nInputs: \n- obj: The object for which the docstring needs to be retrieved. This object could be a function, class, method, or any other object that may contain a docstring.\n\nOutputs:\n- Union[str, None]: If a docstring is found for the object, the function returns the docstring as a string. If no docstring is found, or if the object does not have a docstring, the function returns None.", "method_code_mask": "from dataclasses import dataclass\nfrom inspect import signature\nfrom textwrap import dedent\nimport ast\nimport html\nimport inspect\nimport io as stdlib_io\nimport linecache\nimport os\nimport types\nimport warnings\nfrom typing import cast\nfrom typing import Any\nfrom typing import Optional\nfrom typing import Dict\nfrom typing import Union\nfrom typing import List\nfrom typing import TypedDict\nfrom typing import Tuple\nimport traitlets\nfrom IPython.core import page\nfrom IPython.lib.pretty import pretty\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import PyColorize\nfrom IPython.utils import openpy\nfrom IPython.utils.dir2 import safe_hasattr\nfrom IPython.utils.path import compress_user\nfrom IPython.utils.text import indent\nfrom IPython.utils.wildcard import list_namespace\nfrom IPython.utils.wildcard import typestr2type\nfrom IPython.utils.coloransi import TermColors\nfrom IPython.utils.colorable import Colorable\nfrom IPython.utils.decorators import undoc\nfrom pygments import highlight\nfrom pygments.lexers import PythonLexer\nfrom pygments.formatters import HtmlFormatter\n\n\ndef getdoc(obj) ->Union[str, None]: [MASK]\n"}
{"method_name": "_render_signature", "full_method_name": "_render_signature", "method_path": "../srcdata/Computation/ipython/IPython/core/oinspect.py", "method_code": "from dataclasses import dataclass\nfrom inspect import signature\nfrom textwrap import dedent\nimport ast\nimport html\nimport inspect\nimport io as stdlib_io\nimport linecache\nimport os\nimport types\nimport warnings\nfrom typing import cast\nfrom typing import Any\nfrom typing import Optional\nfrom typing import Dict\nfrom typing import Union\nfrom typing import List\nfrom typing import TypedDict\nfrom typing import Tuple\nimport traitlets\nfrom IPython.core import page\nfrom IPython.lib.pretty import pretty\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import PyColorize\nfrom IPython.utils import openpy\nfrom IPython.utils.dir2 import safe_hasattr\nfrom IPython.utils.path import compress_user\nfrom IPython.utils.text import indent\nfrom IPython.utils.wildcard import list_namespace\nfrom IPython.utils.wildcard import typestr2type\nfrom IPython.utils.coloransi import TermColors\nfrom IPython.utils.colorable import Colorable\nfrom IPython.utils.decorators import undoc\nfrom pygments import highlight\nfrom pygments.lexers import PythonLexer\nfrom pygments.formatters import HtmlFormatter\ndef _render_signature(obj_signature, obj_name) ->str:\n    \"\"\"\n    This was mostly taken from inspect.Signature.__str__.\n    Look there for the comments.\n    The only change is to add linebreaks when this gets too long.\n    \"\"\"\n    result = []\n    pos_only = False\n    kw_only = True\n    for param in obj_signature.parameters.values():\n        if param.kind == inspect.Parameter.POSITIONAL_ONLY:\n            pos_only = True\n        elif pos_only:\n            result.append('/')\n            pos_only = False\n        if param.kind == inspect.Parameter.VAR_POSITIONAL:\n            kw_only = False\n        elif param.kind == inspect.Parameter.KEYWORD_ONLY and kw_only:\n            result.append('*')\n            kw_only = False\n        result.append(str(param))\n    if pos_only:\n        result.append('/')\n    if len(obj_name) + sum(len(r) + 2 for r in result) > 75:\n        rendered = '{}(\\n{})'.format(obj_name, ''.join('    {},\\n'.format(r\n            ) for r in result))\n    else:\n        rendered = '{}({})'.format(obj_name, ', '.join(result))\n    if obj_signature.return_annotation is not inspect._empty:\n        anno = inspect.formatannotation(obj_signature.return_annotation)\n        rendered += ' -> {}'.format(anno)\n    return rendered", "test_code_list": [{"test_code": "from contextlib import contextmanager\nfrom inspect import signature\nfrom inspect import Signature\nfrom inspect import Parameter\nimport inspect\nimport os\nimport pytest\nimport re\nimport sys\nfrom decorator import decorator\nfrom IPython.testing.tools import AssertPrints\nfrom IPython.testing.tools import AssertNotPrints\nfrom IPython.utils.path import compress_user\nfrom typing import Optional\ndef test_render_signature_short():\n\n    def short_fun(a=1):\n        pass\n    sig = _render_signature(signature(short_fun), short_fun.__name__)\n    assert sig == 'short_fun(a=1)'\n\ntest_render_signature_short()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_oinspect.py"}, {"test_code": "from contextlib import contextmanager\nfrom inspect import signature\nfrom inspect import Signature\nfrom inspect import Parameter\nimport inspect\nimport os\nimport pytest\nimport re\nimport sys\nfrom decorator import decorator\nfrom IPython.testing.tools import AssertPrints\nfrom IPython.testing.tools import AssertNotPrints\nfrom IPython.utils.path import compress_user\nfrom typing import Optional\ndef test_render_signature_long():\n    from typing import Optional\n\n    def long_function(a_really_long_parameter: int, and_another_long_one:\n        bool=False, let_us_make_sure_this_is_looong: Optional[str]=None\n        ) ->bool:\n        pass\n    sig = _render_signature(signature(long_function),\n        long_function.__name__)\n    expected = \"\"\"long_function(\n    a_really_long_parameter: int,\n    and_another_long_one: bool = False,\n    let_us_make_sure_this_is_looong: Optional[str] = None,\n) -> bool\"\"\"\n    assert sig == expected\n\ntest_render_signature_long()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_oinspect.py"}], "instruction": "Functionality: The _render_signature function is designed to generate a human-readable signature for a given callable object (function, method, etc.). This is particularly useful for documenting and understanding the structure of complex callables, including their positional-only, keyword-only, and variable positional arguments. The function ensures that the output remains readable even when the signature is long by introducing line breaks when necessary.\n\nInputs: \n- obj_signature: This input is of type inspect.Signature, representing the signature of the callable object being inspected.\n- obj_name: This input is a string, representing the name of the object for which the signature is being generated.\n\nOutputs:\n- A string representing the formatted and potentially line-broken signature of the given object. This string includes the object's name, followed by its parameters and, if available, the return annotation.", "method_code_mask": "from dataclasses import dataclass\nfrom inspect import signature\nfrom textwrap import dedent\nimport ast\nimport html\nimport inspect\nimport io as stdlib_io\nimport linecache\nimport os\nimport types\nimport warnings\nfrom typing import cast\nfrom typing import Any\nfrom typing import Optional\nfrom typing import Dict\nfrom typing import Union\nfrom typing import List\nfrom typing import TypedDict\nfrom typing import Tuple\nimport traitlets\nfrom IPython.core import page\nfrom IPython.lib.pretty import pretty\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import PyColorize\nfrom IPython.utils import openpy\nfrom IPython.utils.dir2 import safe_hasattr\nfrom IPython.utils.path import compress_user\nfrom IPython.utils.text import indent\nfrom IPython.utils.wildcard import list_namespace\nfrom IPython.utils.wildcard import typestr2type\nfrom IPython.utils.coloransi import TermColors\nfrom IPython.utils.colorable import Colorable\nfrom IPython.utils.decorators import undoc\nfrom pygments import highlight\nfrom pygments.lexers import PythonLexer\nfrom pygments.formatters import HtmlFormatter\n\n\ndef _render_signature(obj_signature, obj_name) ->str: [MASK]\n"}
{"method_name": "recompute_unicode_ranges", "full_method_name": "recompute_unicode_ranges", "method_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py", "method_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\ndef recompute_unicode_ranges():\n    \"\"\"\n    utility to recompute the largest unicode range without any characters\n\n    use to recompute the gap in the global _UNICODE_RANGES of completer.py\n    \"\"\"\n    import itertools\n    import unicodedata\n    valid = []\n    for c in range(0, 1114111 + 1):\n        try:\n            unicodedata.name(chr(c))\n        except ValueError:\n            continue\n        valid.append(c)\n\n    def ranges(i):\n        for a, b in itertools.groupby(enumerate(i), lambda pair: pair[1] -\n            pair[0]):\n            b = list(b)\n            yield b[0][1], b[-1][1]\n    rg = list(ranges(valid))\n    lens = []\n    gap_lens = []\n    pstart, pstop = 0, 0\n    for start, stop in rg:\n        lens.append(stop - start)\n        gap_lens.append((start - pstop, hex(pstop + 1), hex(start),\n            f'{round((start - pstop) / 918000 * 100)}%'))\n        pstart, pstop = start, stop\n    return sorted(gap_lens)[-1]", "test_code_list": [{"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\ndef test_unicode_range():\n    \"\"\"\n    Test that the ranges we test for unicode names give the same number of\n    results than testing the full length.\n    \"\"\"\n    from IPython.core.completer import _unicode_name_compute, _UNICODE_RANGES\n    expected_list = _unicode_name_compute([(0, 1114112)])\n    test = _unicode_name_compute(_UNICODE_RANGES)\n    len_exp = len(expected_list)\n    len_test = len(test)\n    message = None\n    if len_exp != len_test or len_exp > 131808:\n        size, start, stop, prct = recompute_unicode_ranges()\n        message = f\"\"\"_UNICODE_RANGES likely wrong and need updating. This is\n        likely due to a new release of Python. We've find that the biggest gap\n        in unicode characters has reduces in size to be {size} characters\n        ({prct}), from {start}, to {stop}. In completer.py likely update to\n\n            _UNICODE_RANGES = [(32, {start}), ({stop}, 0xe01f0)]\n\n        And update the assertion below to use\n\n            len_exp <= {len_exp}\n        \"\"\"\n    assert len_exp == len_test, message\n    assert len_exp <= 143668, message\n\ntest_unicode_range()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}], "instruction": "Functionality: The function recompute_unicode_ranges is designed to identify the largest gap in the Unicode range where no characters are defined. It iterates through the entire Unicode range, checks each code point for a valid Unicode character name, and then calculates the largest gap without any characters. This information can be used to update the global _UNICODE_RANGES variable in the completer.py module.\n\nInputs: The function does not take any input arguments. It runs through a predefined range (0 to 1114111) to check for valid Unicode characters.\n\nOutputs: The function returns a tuple representing the largest gap without any characters in the Unicode range. The tuple contains the following elements:\n- The size of the gap.\n- The hexadecimal representation of the starting point of the gap.\n- The hexadecimal representation of the end point of the gap.\n- A percentage representing the size of the gap relative to a certain value (918000 in the provided code snippet).", "method_code_mask": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\n\ndef recompute_unicode_ranges(): [MASK]\n"}
{"method_name": "has_open_quotes", "full_method_name": "has_open_quotes", "method_path": "../srcdata/Computation/ipython/IPython/core/completer.py", "method_code": "from __future__ import annotations\nimport builtins as builtin_mod\nimport enum\nimport glob\nimport inspect\nimport itertools\nimport keyword\nimport os\nimport re\nimport string\nimport sys\nimport tokenize\nimport time\nimport unicodedata\nimport uuid\nimport warnings\nfrom ast import literal_eval\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom functools import cached_property\nfrom functools import partial\nfrom types import SimpleNamespace\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Any\nfrom typing import Sequence\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom typing import Set\nfrom typing import Sized\nfrom typing import TypeVar\nfrom typing import Literal\nfrom IPython.core.guarded_eval import guarded_eval\nfrom IPython.core.guarded_eval import EvaluationContext\nfrom IPython.core.error import TryNext\nfrom IPython.core.inputtransformer2 import ESC_MAGIC\nfrom IPython.core.latex_symbols import latex_symbols\nfrom IPython.core.latex_symbols import reverse_latex_symbol\nfrom IPython.core.oinspect import InspectColors\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import generics\nfrom IPython.utils.decorators import sphinx_options\nfrom IPython.utils.dir2 import dir2\nfrom IPython.utils.dir2 import get_real_method\nfrom IPython.utils.docs import GENERATING_DOCUMENTATION\nfrom IPython.utils.path import ensure_dir_exists\nfrom IPython.utils.process import arg_split\nfrom traitlets import Bool\nfrom traitlets import Enum\nfrom traitlets import Int\nfrom traitlets import List as ListTrait\nfrom traitlets import Unicode\nfrom traitlets import Dict as DictTrait\nfrom traitlets import Union as UnionTrait\nfrom traitlets import observe\nfrom traitlets.config.configurable import Configurable\nimport __main__\nimport jedi\nimport jedi.api.helpers\nimport jedi.api.classes\nfrom typing import cast\nfrom typing_extensions import TypedDict\nfrom typing_extensions import NotRequired\nfrom typing_extensions import Protocol\nfrom typing_extensions import TypeAlias\nfrom typing_extensions import TypeGuard\nfrom typing import Generic\nfrom typing import TypedDict\nimport cProfile\ndef has_open_quotes(s):\n    \"\"\"Return whether a string has open quotes.\n\n    This simply counts whether the number of quote characters of either type in\n    the string is odd.\n\n    Returns\n    -------\n    If there is an open quote, the quote character is returned.  Else, return\n    False.\n    \"\"\"\n    if s.count('\"') % 2:\n        return '\"'\n    elif s.count(\"'\") % 2:\n        return \"'\"\n    else:\n        return False", "test_code_list": [{"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_has_open_quotes1(self):\n\t    for s in [\"'\", \"'''\", \"'hi' '\"]:\n\t        self.assertEqual(has_open_quotes(s), \"'\")\n\t\nTestCompleter().test_has_open_quotes1()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}, {"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_has_open_quotes2(self):\n\t    for s in ['\"', '\"\"\"', '\"hi\" \"']:\n\t        self.assertEqual(has_open_quotes(s), '\"')\n\t\nTestCompleter().test_has_open_quotes2()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}, {"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_has_open_quotes3(self):\n\t    for s in [\"''\", \"''' '''\", \"'hi' 'ipython'\"]:\n\t        self.assertFalse(has_open_quotes(s))\n\t\nTestCompleter().test_has_open_quotes3()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}, {"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_has_open_quotes4(self):\n\t    for s in ['\"\"', '\"\"\" \"\"\"', '\"hi\" \"ipython\"']:\n\t        self.assertFalse(has_open_quotes(s))\n\t\nTestCompleter().test_has_open_quotes4()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}], "instruction": "Functionality: The function 'has_open_quotes' checks if a given string has an unbalanced number of single or double quotes, indicating that the string may have an open quote that isn't closed.\n\nInputs: \n- s: A string to be checked for open quotes. This string can contain any printable characters, including single quotes (') and double quotes (\"), as well as other types of characters.\n\nOutputs:\n- If the string 's' has an odd number of single quotes (') or double quotes (\") but not both, the function returns the quote character (either '\"' or \"'\") that is in odd number.\n- If both types of quote characters are present in an even count, or if one type of quote is not present at all, the function returns False, indicating that there are no open quotes.", "method_code_mask": "from __future__ import annotations\nimport builtins as builtin_mod\nimport enum\nimport glob\nimport inspect\nimport itertools\nimport keyword\nimport os\nimport re\nimport string\nimport sys\nimport tokenize\nimport time\nimport unicodedata\nimport uuid\nimport warnings\nfrom ast import literal_eval\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom functools import cached_property\nfrom functools import partial\nfrom types import SimpleNamespace\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Any\nfrom typing import Sequence\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom typing import Set\nfrom typing import Sized\nfrom typing import TypeVar\nfrom typing import Literal\nfrom IPython.core.guarded_eval import guarded_eval\nfrom IPython.core.guarded_eval import EvaluationContext\nfrom IPython.core.error import TryNext\nfrom IPython.core.inputtransformer2 import ESC_MAGIC\nfrom IPython.core.latex_symbols import latex_symbols\nfrom IPython.core.latex_symbols import reverse_latex_symbol\nfrom IPython.core.oinspect import InspectColors\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import generics\nfrom IPython.utils.decorators import sphinx_options\nfrom IPython.utils.dir2 import dir2\nfrom IPython.utils.dir2 import get_real_method\nfrom IPython.utils.docs import GENERATING_DOCUMENTATION\nfrom IPython.utils.path import ensure_dir_exists\nfrom IPython.utils.process import arg_split\nfrom traitlets import Bool\nfrom traitlets import Enum\nfrom traitlets import Int\nfrom traitlets import List as ListTrait\nfrom traitlets import Unicode\nfrom traitlets import Dict as DictTrait\nfrom traitlets import Union as UnionTrait\nfrom traitlets import observe\nfrom traitlets.config.configurable import Configurable\nimport __main__\nimport jedi\nimport jedi.api.helpers\nimport jedi.api.classes\nfrom typing import cast\nfrom typing_extensions import TypedDict\nfrom typing_extensions import NotRequired\nfrom typing_extensions import Protocol\nfrom typing_extensions import TypeAlias\nfrom typing_extensions import TypeGuard\nfrom typing import Generic\nfrom typing import TypedDict\nimport cProfile\n\n\ndef has_open_quotes(s): [MASK]\n"}
{"method_name": "get__all__entries", "full_method_name": "get__all__entries", "method_path": "../srcdata/Computation/ipython/IPython/core/completer.py", "method_code": "from __future__ import annotations\nimport builtins as builtin_mod\nimport enum\nimport glob\nimport inspect\nimport itertools\nimport keyword\nimport os\nimport re\nimport string\nimport sys\nimport tokenize\nimport time\nimport unicodedata\nimport uuid\nimport warnings\nfrom ast import literal_eval\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom functools import cached_property\nfrom functools import partial\nfrom types import SimpleNamespace\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Any\nfrom typing import Sequence\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom typing import Set\nfrom typing import Sized\nfrom typing import TypeVar\nfrom typing import Literal\nfrom IPython.core.guarded_eval import guarded_eval\nfrom IPython.core.guarded_eval import EvaluationContext\nfrom IPython.core.error import TryNext\nfrom IPython.core.inputtransformer2 import ESC_MAGIC\nfrom IPython.core.latex_symbols import latex_symbols\nfrom IPython.core.latex_symbols import reverse_latex_symbol\nfrom IPython.core.oinspect import InspectColors\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import generics\nfrom IPython.utils.decorators import sphinx_options\nfrom IPython.utils.dir2 import dir2\nfrom IPython.utils.dir2 import get_real_method\nfrom IPython.utils.docs import GENERATING_DOCUMENTATION\nfrom IPython.utils.path import ensure_dir_exists\nfrom IPython.utils.process import arg_split\nfrom traitlets import Bool\nfrom traitlets import Enum\nfrom traitlets import Int\nfrom traitlets import List as ListTrait\nfrom traitlets import Unicode\nfrom traitlets import Dict as DictTrait\nfrom traitlets import Union as UnionTrait\nfrom traitlets import observe\nfrom traitlets.config.configurable import Configurable\nimport __main__\nimport jedi\nimport jedi.api.helpers\nimport jedi.api.classes\nfrom typing import cast\nfrom typing_extensions import TypedDict\nfrom typing_extensions import NotRequired\nfrom typing_extensions import Protocol\nfrom typing_extensions import TypeAlias\nfrom typing_extensions import TypeGuard\nfrom typing import Generic\nfrom typing import TypedDict\nimport cProfile\ndef get__all__entries(obj):\n    \"\"\"returns the strings in the __all__ attribute\"\"\"\n    try:\n        words = getattr(obj, '__all__')\n    except:\n        return []\n    return [w for w in words if isinstance(w, str)]", "test_code_list": [{"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_get__all__entries_ok(self):\n\t\n\t\n\t    class A:\n\t        __all__ = ['x', 1]\n\t    words = get__all__entries(A())\n\t    self.assertEqual(words, ['x'])\n\t\nTestCompleter().test_get__all__entries_ok()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}, {"test_code": "import os\nimport pytest\nimport sys\nimport textwrap\nimport unittest\nfrom importlib.metadata import version\nfrom contextlib import contextmanager\nfrom traitlets.config.loader import Config\nfrom IPython import get_ipython\nfrom IPython.core import completer\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.generics import complete_object\nfrom IPython.testing import decorators as dec\nfrom IPython.core.completer import Completion\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import match_dict_keys\nfrom IPython.core.completer import _deduplicate_completions\nfrom IPython.core.completer import _match_number_in_dict_key_prefix\nfrom IPython.core.completer import completion_matcher\nfrom IPython.core.completer import SimpleCompletion\nfrom IPython.core.completer import CompletionContext\nfrom packaging.version import parse\nimport itertools\nimport unicodedata\nfrom IPython.core.completer import _unicode_name_compute\nfrom IPython.core.completer import _UNICODE_RANGES\nfrom IPython.core.latex_symbols import latex_symbols\nimport random\nimport jedi\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_cell_magic\nimport numpy\nimport pandas\nfrom IPython.core.completerlib import try_import\nfrom textwrap import dedent\n\nclass TestCompleter(unittest.TestCase):\n\tdef test_get__all__entries_no__all__ok(self):\n\t\n\t\n\t    class A:\n\t        pass\n\t    words = get__all__entries(A())\n\t    self.assertEqual(words, [])\n\t\nTestCompleter().test_get__all__entries_no__all__ok()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completer.py"}], "instruction": "Functionality: The function 'get__all__entries' is designed to extract and return the string elements from the '__all__' attribute of a given object. The '__all__' attribute is typically used in Python modules to define a list of public objects that should be imported when 'from module import *' is used. This function is particularly useful for introspection and dynamic module handling.\n\nInputs: \n    obj: Any\n        The input is any Python object. This could be a module, class, or any other object that might have a '__all__' attribute. The function will attempt to access this attribute from the object and process its contents.\n\nOutputs:\n    List[str]\n        The function returns a list of strings. Each string in the list represents an entry found in the '__all__' attribute of the given object. If the object does not have a '__all__' attribute or if the attribute is not a collection of strings, the function will return an empty list.", "method_code_mask": "from __future__ import annotations\nimport builtins as builtin_mod\nimport enum\nimport glob\nimport inspect\nimport itertools\nimport keyword\nimport os\nimport re\nimport string\nimport sys\nimport tokenize\nimport time\nimport unicodedata\nimport uuid\nimport warnings\nfrom ast import literal_eval\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom functools import cached_property\nfrom functools import partial\nfrom types import SimpleNamespace\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Any\nfrom typing import Sequence\nfrom typing import Dict\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom typing import Set\nfrom typing import Sized\nfrom typing import TypeVar\nfrom typing import Literal\nfrom IPython.core.guarded_eval import guarded_eval\nfrom IPython.core.guarded_eval import EvaluationContext\nfrom IPython.core.error import TryNext\nfrom IPython.core.inputtransformer2 import ESC_MAGIC\nfrom IPython.core.latex_symbols import latex_symbols\nfrom IPython.core.latex_symbols import reverse_latex_symbol\nfrom IPython.core.oinspect import InspectColors\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils import generics\nfrom IPython.utils.decorators import sphinx_options\nfrom IPython.utils.dir2 import dir2\nfrom IPython.utils.dir2 import get_real_method\nfrom IPython.utils.docs import GENERATING_DOCUMENTATION\nfrom IPython.utils.path import ensure_dir_exists\nfrom IPython.utils.process import arg_split\nfrom traitlets import Bool\nfrom traitlets import Enum\nfrom traitlets import Int\nfrom traitlets import List as ListTrait\nfrom traitlets import Unicode\nfrom traitlets import Dict as DictTrait\nfrom traitlets import Union as UnionTrait\nfrom traitlets import observe\nfrom traitlets.config.configurable import Configurable\nimport __main__\nimport jedi\nimport jedi.api.helpers\nimport jedi.api.classes\nfrom typing import cast\nfrom typing_extensions import TypedDict\nfrom typing_extensions import NotRequired\nfrom typing_extensions import Protocol\nfrom typing_extensions import TypeAlias\nfrom typing_extensions import TypeGuard\nfrom typing import Generic\nfrom typing import TypedDict\nimport cProfile\n\n\ndef get__all__entries(obj): [MASK]\n"}
{"method_name": "_get_inline_config", "full_method_name": "_get_inline_config", "method_path": "../srcdata/Computation/ipython/IPython/core/tests/test_display.py", "method_code": "import json\nimport os\nimport warnings\nfrom unittest import mock\nimport pytest\nfrom IPython import display\nfrom IPython.core.getipython import get_ipython\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.tempdir import NamedFileInTemporaryDirectory\nfrom IPython import paths as ipath\nfrom IPython.testing.tools import AssertNotPrints\nimport IPython.testing.decorators as dec\nimport gzip\nfrom io import BytesIO\nfrom matplotlib_inline.config import InlineBackend\nfrom matplotlib.figure import Figure\ndef _get_inline_config():\n    from matplotlib_inline.config import InlineBackend\n    return InlineBackend.instance()", "test_code_list": [{"test_code": "import json\nimport os\nimport warnings\nfrom unittest import mock\nimport pytest\nfrom IPython import display\nfrom IPython.core.getipython import get_ipython\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.tempdir import NamedFileInTemporaryDirectory\nfrom IPython import paths as ipath\nfrom IPython.testing.tools import AssertNotPrints\nimport IPython.testing.decorators as dec\nimport gzip\nfrom io import BytesIO\nfrom matplotlib_inline.config import InlineBackend\nfrom matplotlib.figure import Figure\n@dec.skip_without('matplotlib')\ndef test_set_matplotlib_close():\n    cfg = _get_inline_config()\n    cfg.close_figures = False\n    with pytest.deprecated_call():\n        display.set_matplotlib_close()\n    assert cfg.close_figures\n    with pytest.deprecated_call():\n        display.set_matplotlib_close(False)\n    assert not cfg.close_figures\n\ntest_set_matplotlib_close()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_display.py"}], "instruction": "Functionality: The function _get_inline_config is designed to retrieve the current configuration of the InlineBackend from the matplotlib_inline library. This function aims to return the configuration settings that are used to display graphics inline within the IPython or Jupyter Notebook environment.\n\nInputs: This function does not require any input arguments. It operates by accessing the current state of the InlineBackend instance.\n\nOutputs: The function returns the configuration object of the InlineBackend. This object contains settings that determine how graphics are displayed within the IPython or Jupyter Notebook environment. The configuration includes settings such as the backend used for rendering graphics, the format of the graphics, and other parameters that affect the display of figures.", "method_code_mask": "import json\nimport os\nimport warnings\nfrom unittest import mock\nimport pytest\nfrom IPython import display\nfrom IPython.core.getipython import get_ipython\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.tempdir import NamedFileInTemporaryDirectory\nfrom IPython import paths as ipath\nfrom IPython.testing.tools import AssertNotPrints\nimport IPython.testing.decorators as dec\nimport gzip\nfrom io import BytesIO\nfrom matplotlib_inline.config import InlineBackend\nfrom matplotlib.figure import Figure\n\n\ndef _get_inline_config(): [MASK]\n"}
{"method_name": "get_input_encoding", "full_method_name": "get_input_encoding", "method_path": "../srcdata/Computation/ipython/IPython/core/inputsplitter.py", "method_code": "from __future__ import annotations\nfrom warnings import warn\nimport ast\nimport codeop\nimport io\nimport re\nimport sys\nimport tokenize\nimport warnings\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom types import CodeType\nfrom IPython.core.inputtransformer import leading_indent\nfrom IPython.core.inputtransformer import classic_prompt\nfrom IPython.core.inputtransformer import ipy_prompt\nfrom IPython.core.inputtransformer import cellmagic\nfrom IPython.core.inputtransformer import assemble_logical_lines\nfrom IPython.core.inputtransformer import help_end\nfrom IPython.core.inputtransformer import escaped_commands\nfrom IPython.core.inputtransformer import assign_from_magic\nfrom IPython.core.inputtransformer import assign_from_system\nfrom IPython.core.inputtransformer import assemble_python_lines\nfrom IPython.utils import tokenutil\nfrom IPython.core.inputtransformer import ESC_SHELL\nfrom IPython.core.inputtransformer import ESC_SH_CAP\nfrom IPython.core.inputtransformer import ESC_HELP\nfrom IPython.core.inputtransformer import ESC_HELP2\nfrom IPython.core.inputtransformer import ESC_MAGIC\nfrom IPython.core.inputtransformer import ESC_MAGIC2\nfrom IPython.core.inputtransformer import ESC_QUOTE\nfrom IPython.core.inputtransformer import ESC_QUOTE2\nfrom IPython.core.inputtransformer import ESC_PAREN\nfrom IPython.core.inputtransformer import ESC_SEQUENCES\nfrom typing_extensions import Self\ndef get_input_encoding():\n    \"\"\"Return the default standard input encoding.\n\n    If sys.stdin has no encoding, 'ascii' is returned.\"\"\"\n    encoding = getattr(sys.stdin, 'encoding', None)\n    if encoding is None:\n        encoding = 'ascii'\n    return encoding", "test_code_list": [{"test_code": "import unittest\nimport pytest\nimport sys\nfrom IPython.core import inputsplitter as isp\nfrom IPython.core.inputtransformer import InputTransformer\nfrom IPython.core.tests.test_inputtransformer import syntax\nfrom IPython.core.tests.test_inputtransformer import syntax_ml\nfrom IPython.testing import tools as tt\nfrom IPython.core.inputsplitter import InputSplitter\nfrom IPython.core.inputsplitter import IPythonInputSplitter\ndef test_get_input_encoding():\n    encoding = get_input_encoding()\n    assert isinstance(encoding, str)\n    assert 'test'.encode(encoding) == b'test'\n\ntest_get_input_encoding()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_inputsplitter.py"}, {"test_code": "import unittest\nimport pytest\nimport sys\nfrom IPython.core import inputsplitter as isp\nfrom IPython.core.inputtransformer import InputTransformer\nfrom IPython.core.tests.test_inputtransformer import syntax\nfrom IPython.core.tests.test_inputtransformer import syntax_ml\nfrom IPython.testing import tools as tt\nfrom IPython.core.inputsplitter import InputSplitter\nfrom IPython.core.inputsplitter import IPythonInputSplitter\n\nclass NoInputEncodingTestCase(unittest.TestCase):\n\tdef test(self):\n\t    enc = get_input_encoding()\n\t    self.assertEqual(enc, 'ascii')\n\t\nNoInputEncodingTestCase().test()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_inputsplitter.py"}], "instruction": "Functionality: The get_input_encoding function is designed to determine and return the encoding used by the default standard input (stdin). If sys.stdin does not have an encoding attribute, it defaults to returning 'ascii'.\n\nInputs: This function does not require any input arguments. It relies on the system's stdin attribute for determining the input encoding.\n\nOutputs: The function returns a string representing the encoding used by the default standard input. If no encoding is defined for sys.stdin, it will return 'ascii'.", "method_code_mask": "from __future__ import annotations\nfrom warnings import warn\nimport ast\nimport codeop\nimport io\nimport re\nimport sys\nimport tokenize\nimport warnings\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom types import CodeType\nfrom IPython.core.inputtransformer import leading_indent\nfrom IPython.core.inputtransformer import classic_prompt\nfrom IPython.core.inputtransformer import ipy_prompt\nfrom IPython.core.inputtransformer import cellmagic\nfrom IPython.core.inputtransformer import assemble_logical_lines\nfrom IPython.core.inputtransformer import help_end\nfrom IPython.core.inputtransformer import escaped_commands\nfrom IPython.core.inputtransformer import assign_from_magic\nfrom IPython.core.inputtransformer import assign_from_system\nfrom IPython.core.inputtransformer import assemble_python_lines\nfrom IPython.utils import tokenutil\nfrom IPython.core.inputtransformer import ESC_SHELL\nfrom IPython.core.inputtransformer import ESC_SH_CAP\nfrom IPython.core.inputtransformer import ESC_HELP\nfrom IPython.core.inputtransformer import ESC_HELP2\nfrom IPython.core.inputtransformer import ESC_MAGIC\nfrom IPython.core.inputtransformer import ESC_MAGIC2\nfrom IPython.core.inputtransformer import ESC_QUOTE\nfrom IPython.core.inputtransformer import ESC_QUOTE2\nfrom IPython.core.inputtransformer import ESC_PAREN\nfrom IPython.core.inputtransformer import ESC_SEQUENCES\nfrom typing_extensions import Self\n\n\ndef get_input_encoding(): [MASK]\n"}
{"method_name": "last_blank", "full_method_name": "last_blank", "method_path": "../srcdata/Computation/ipython/IPython/core/inputsplitter.py", "method_code": "from __future__ import annotations\nfrom warnings import warn\nimport ast\nimport codeop\nimport io\nimport re\nimport sys\nimport tokenize\nimport warnings\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom types import CodeType\nfrom IPython.core.inputtransformer import leading_indent\nfrom IPython.core.inputtransformer import classic_prompt\nfrom IPython.core.inputtransformer import ipy_prompt\nfrom IPython.core.inputtransformer import cellmagic\nfrom IPython.core.inputtransformer import assemble_logical_lines\nfrom IPython.core.inputtransformer import help_end\nfrom IPython.core.inputtransformer import escaped_commands\nfrom IPython.core.inputtransformer import assign_from_magic\nfrom IPython.core.inputtransformer import assign_from_system\nfrom IPython.core.inputtransformer import assemble_python_lines\nfrom IPython.utils import tokenutil\nfrom IPython.core.inputtransformer import ESC_SHELL\nfrom IPython.core.inputtransformer import ESC_SH_CAP\nfrom IPython.core.inputtransformer import ESC_HELP\nfrom IPython.core.inputtransformer import ESC_HELP2\nfrom IPython.core.inputtransformer import ESC_MAGIC\nfrom IPython.core.inputtransformer import ESC_MAGIC2\nfrom IPython.core.inputtransformer import ESC_QUOTE\nfrom IPython.core.inputtransformer import ESC_QUOTE2\nfrom IPython.core.inputtransformer import ESC_PAREN\nfrom IPython.core.inputtransformer import ESC_SEQUENCES\nfrom typing_extensions import Self\ndef last_blank(src):\n    \"\"\"Determine if the input source ends in a blank.\n\n    A blank is either a newline or a line consisting of whitespace.\n\n    Parameters\n    ----------\n    src : string\n        A single or multiline string.\n    \"\"\"\n    if not src:\n        return False\n    ll = src.splitlines()[-1]\n    return ll == '' or ll.isspace()", "test_code_list": [{"test_code": "import unittest\nimport pytest\nimport sys\nfrom IPython.core import inputsplitter as isp\nfrom IPython.core.inputtransformer import InputTransformer\nfrom IPython.core.tests.test_inputtransformer import syntax\nfrom IPython.core.tests.test_inputtransformer import syntax_ml\nfrom IPython.testing import tools as tt\nfrom IPython.core.inputsplitter import InputSplitter\nfrom IPython.core.inputsplitter import IPythonInputSplitter\ndef test_last_blank():\n    assert last_blank('') is False\n    assert last_blank('abc') is False\n    assert last_blank('abc\\n') is False\n    assert last_blank('abc\\na') is False\n    assert last_blank('\\n') is True\n    assert last_blank('\\n ') is True\n    assert last_blank('abc\\n ') is True\n    assert last_blank('abc\\n\\n') is True\n    assert last_blank('abc\\nd\\n\\n') is True\n    assert last_blank('abc\\nd\\ne\\n\\n') is True\n    assert last_blank('abc \\n \\n \\n\\n') is True\n\ntest_last_blank()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_inputsplitter.py"}], "instruction": "Functionality: The last_blank function checks whether the provided string (src) ends with a blank line or not. A blank line can be an empty line or a line that only contains whitespace characters.\n\nInputs: \n- src : string\n    A string that can be single-line or multi-line.\n\nOutputs: \n- bool\n    Returns True if the string ends with a blank line, otherwise returns False.", "method_code_mask": "from __future__ import annotations\nfrom warnings import warn\nimport ast\nimport codeop\nimport io\nimport re\nimport sys\nimport tokenize\nimport warnings\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\nfrom typing import Optional\nfrom typing import TYPE_CHECKING\nfrom types import CodeType\nfrom IPython.core.inputtransformer import leading_indent\nfrom IPython.core.inputtransformer import classic_prompt\nfrom IPython.core.inputtransformer import ipy_prompt\nfrom IPython.core.inputtransformer import cellmagic\nfrom IPython.core.inputtransformer import assemble_logical_lines\nfrom IPython.core.inputtransformer import help_end\nfrom IPython.core.inputtransformer import escaped_commands\nfrom IPython.core.inputtransformer import assign_from_magic\nfrom IPython.core.inputtransformer import assign_from_system\nfrom IPython.core.inputtransformer import assemble_python_lines\nfrom IPython.utils import tokenutil\nfrom IPython.core.inputtransformer import ESC_SHELL\nfrom IPython.core.inputtransformer import ESC_SH_CAP\nfrom IPython.core.inputtransformer import ESC_HELP\nfrom IPython.core.inputtransformer import ESC_HELP2\nfrom IPython.core.inputtransformer import ESC_MAGIC\nfrom IPython.core.inputtransformer import ESC_MAGIC2\nfrom IPython.core.inputtransformer import ESC_QUOTE\nfrom IPython.core.inputtransformer import ESC_QUOTE2\nfrom IPython.core.inputtransformer import ESC_PAREN\nfrom IPython.core.inputtransformer import ESC_SEQUENCES\nfrom typing_extensions import Self\n\n\ndef last_blank(src): [MASK]\n"}
{"method_name": "module_completion", "full_method_name": "module_completion", "method_path": "../srcdata/Computation/ipython/IPython/core/completerlib.py", "method_code": "import glob\nimport inspect\nimport os\nimport re\nimport sys\nfrom importlib import import_module\nfrom importlib.machinery import all_suffixes\nfrom time import time\nfrom zipimport import zipimporter\nfrom IPython import get_ipython\nfrom typing import List\ndef module_completion(line):\n    \"\"\"\n    Returns a list containing the completion possibilities for an import line.\n\n    The line looks like this :\n    'import xml.d'\n    'from xml.dom import'\n    \"\"\"\n    words = line.split(' ')\n    nwords = len(words)\n    if nwords == 3 and words[0] == 'from':\n        return ['import ']\n    if nwords < 3 and words[0] in {'%aimport', 'import', 'from'}:\n        if nwords == 1:\n            return get_root_modules()\n        mod = words[1].split('.')\n        if len(mod) < 2:\n            return get_root_modules()\n        completion_list = try_import('.'.join(mod[:-1]), True)\n        return ['.'.join(mod[:-1] + [el]) for el in completion_list]\n    if nwords >= 3 and words[0] == 'from':\n        mod = words[1]\n        return try_import(mod)", "test_code_list": [{"test_code": "import os\nimport shutil\nimport sys\nimport tempfile\nimport unittest\nfrom os.path import join\nfrom tempfile import TemporaryDirectory\nfrom IPython.core.completerlib import magic_run_completer\nfrom IPython.core.completerlib import module_completion\nfrom IPython.core.completerlib import try_import\nfrom IPython.testing.decorators import onlyif_unicode_paths\ndef test_valid_exported_submodules():\n    \"\"\"\n    Test checking exported (__all__) objects are submodules\n    \"\"\"\n    results = module_completion('import os.pa')\n    assert 'os.path' in results\n    assert 'os.pathconf' not in results\n\ntest_valid_exported_submodules()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_completerlib.py"}], "instruction": "Functionality: The module_completion function is designed to assist in the completion of Python import statements by returning a list of possible modules or submodules that can be imported based on the given import line. This function supports both 'import' and 'from ... import' syntaxes.\n\nInputs: \n- line: A string representing the beginning of an import statement. The line can be in the format 'import xml.d', 'from xml.dom import', or any other incomplete import statement. The line should be a valid Python import syntax up to the point of completion.\n\nOutputs: \n- A list of strings, each representing a possible completion for the given import line. The completions will be module or submodule names that can be appended to the given import line to form a valid import statement. If the import line is not in a valid format or does not match any known modules, an empty list will be returned.", "method_code_mask": "import glob\nimport inspect\nimport os\nimport re\nimport sys\nfrom importlib import import_module\nfrom importlib.machinery import all_suffixes\nfrom time import time\nfrom zipimport import zipimporter\nfrom IPython import get_ipython\nfrom typing import List\n\n\ndef module_completion(line): [MASK]\n"}
{"method_name": "extract_symbols", "full_method_name": "extract_symbols", "method_path": "../srcdata/Computation/ipython/IPython/core/magics/code.py", "method_code": "import inspect\nimport io\nimport os\nimport re\nimport sys\nimport ast\nfrom itertools import chain\nfrom urllib.request import Request\nfrom urllib.request import urlopen\nfrom urllib.parse import urlencode\nfrom pathlib import Path\nfrom IPython.core.error import TryNext\nfrom IPython.core.error import StdinNotImplementedError\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import line_magic\nfrom IPython.core.oinspect import find_file\nfrom IPython.core.oinspect import find_source_lines\nfrom IPython.core.release import version\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.path import get_py_filename\nfrom warnings import warn\nfrom logging import error\nfrom IPython.utils.text import get_text_list\ndef extract_symbols(code, symbols):\n    \"\"\"\n    Return a tuple  (blocks, not_found)\n    where ``blocks`` is a list of code fragments\n    for each symbol parsed from code, and ``not_found`` are\n    symbols not found in the code.\n\n    For example::\n\n        In [1]: code = '''a = 10\n           ...: def b(): return 42\n           ...: class A: pass'''\n\n        In [2]: extract_symbols(code, 'A,b,z')\n        Out[2]: (['class A: pass\\\\n', 'def b(): return 42\\\\n'], ['z'])\n    \"\"\"\n    symbols = symbols.split(',')\n    py_code = ast.parse(code)\n    marks = [(getattr(s, 'name', None), s.lineno) for s in py_code.body]\n    code = code.split('\\n')\n    symbols_lines = {}\n    end = len(code)\n    for name, start in reversed(marks):\n        while not code[end - 1].strip():\n            end -= 1\n        if name:\n            symbols_lines[name] = start - 1, end\n        end = start - 1\n    blocks = []\n    not_found = []\n    for symbol in symbols:\n        if symbol in symbols_lines:\n            start, end = symbols_lines[symbol]\n            blocks.append('\\n'.join(code[start:end]) + '\\n')\n        else:\n            not_found.append(symbol)\n    return blocks, not_found", "test_code_list": [{"test_code": "import gc\nimport io\nimport os\nimport re\nimport shlex\nimport sys\nimport warnings\nfrom importlib import invalidate_caches\nfrom io import StringIO\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom unittest import TestCase\nfrom unittest import mock\nimport pytest\nfrom IPython import get_ipython\nfrom IPython.core import magic\nfrom IPython.core.error import UsageError\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import cell_magic\nfrom IPython.core.magic import line_magic\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_magic\nfrom IPython.core.magics import code\nfrom IPython.core.magics import execution\nfrom IPython.core.magics import logging\nfrom IPython.core.magics import osm\nfrom IPython.core.magics import script\nfrom IPython.testing import decorators as dec\nfrom IPython.testing import tools as tt\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.process import find_cmd\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.syspathcontext import prepended_to_syspath\nfrom tempfile import NamedTemporaryFile\nimport logging as log_mod\nimport importlib.abc\nimport importlib.util\ndef test_extract_symbols():\n    source = (\n        'import foo\\na = 10\\ndef b():\\n    return 42\\n\\n\\nclass A: pass\\n\\n\\n')\n    symbols_args = ['a', 'b', 'A', 'A,b', 'A,a', 'z']\n    expected = [([], ['a']), ([\"\"\"def b():\n    return 42\n\"\"\"], []), ([\n        'class A: pass\\n'], []), (['class A: pass\\n',\n        \"\"\"def b():\n    return 42\n\"\"\"], []), (['class A: pass\\n'], ['a']),\n        ([], ['z'])]\n    for symbols, exp in zip(symbols_args, expected):\n        assert extract_symbols(source, symbols) == exp\n\ntest_extract_symbols()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_magic.py"}], "instruction": "Functionality: The function 'extract_symbols' is designed to parse a given code string and extract code blocks for specified symbols (variables, functions, classes). It returns a tuple: the first element is a list of code fragments corresponding to each symbol found in the code, and the second element is a list of symbols that were not found in the code.\n\nInputs: \n- code (str): A string containing the Python code to be analyzed.\n- symbols (str): A comma-separated string of symbols (names of variables, functions, or classes) to be extracted from the code.\n\nOutputs:\n- A tuple containing two elements:\n  1. blocks (list): A list of strings, each representing the code block of a symbol that was found in the input code.\n  2. not_found (list): A list of strings, each representing a symbol that was not found in the input code.", "method_code_mask": "import inspect\nimport io\nimport os\nimport re\nimport sys\nimport ast\nfrom itertools import chain\nfrom urllib.request import Request\nfrom urllib.request import urlopen\nfrom urllib.parse import urlencode\nfrom pathlib import Path\nfrom IPython.core.error import TryNext\nfrom IPython.core.error import StdinNotImplementedError\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import line_magic\nfrom IPython.core.oinspect import find_file\nfrom IPython.core.oinspect import find_source_lines\nfrom IPython.core.release import version\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.path import get_py_filename\nfrom warnings import warn\nfrom logging import error\nfrom IPython.utils.text import get_text_list\n\n\ndef extract_symbols(code, symbols): [MASK]\n"}
{"method_name": "_format_time", "full_method_name": "_format_time", "method_path": "../srcdata/Computation/ipython/IPython/core/magics/execution.py", "method_code": "import ast\nimport bdb\nimport builtins as builtin_mod\nimport copy\nimport cProfile as profile\nimport gc\nimport itertools\nimport math\nimport os\nimport pstats\nimport re\nimport shlex\nimport sys\nimport time\nimport timeit\nfrom typing import Dict\nfrom typing import Any\nfrom ast import Assign\nfrom ast import Call\nfrom ast import Expr\nfrom ast import Load\nfrom ast import Module\nfrom ast import Name\nfrom ast import NodeTransformer\nfrom ast import Store\nfrom ast import parse\nfrom ast import unparse\nfrom io import StringIO\nfrom logging import error\nfrom pathlib import Path\nfrom pdb import Restart\nfrom textwrap import dedent\nfrom textwrap import indent\nfrom warnings import warn\nfrom IPython.core import magic_arguments\nfrom IPython.core import oinspect\nfrom IPython.core import page\nfrom IPython.core.displayhook import DisplayHook\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import cell_magic\nfrom IPython.core.magic import line_cell_magic\nfrom IPython.core.magic import line_magic\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import needs_local_scope\nfrom IPython.core.magic import no_var_expand\nfrom IPython.core.magic import on_off\nfrom IPython.core.magic import output_can_be_silenced\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.capture import capture_output\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.ipstruct import Struct\nfrom IPython.utils.module_paths import find_mod\nfrom IPython.utils.path import get_py_filename\nfrom IPython.utils.path import shellglob\nfrom IPython.utils.timing import clock\nfrom IPython.utils.timing import clock2\nfrom IPython.core.magics.ast_mod import ReplaceCodeTransformer\ndef _format_time(timespan, precision=3):\n    \"\"\"Formats the timespan in a human readable form\"\"\"\n    if timespan >= 60.0:\n        parts = [('d', 60 * 60 * 24), ('h', 60 * 60), ('min', 60), ('s', 1)]\n        time = []\n        leftover = timespan\n        for suffix, length in parts:\n            value = int(leftover / length)\n            if value > 0:\n                leftover = leftover % length\n                time.append(u'%s%s' % (str(value), suffix))\n            if leftover < 1:\n                break\n        return ' '.join(time)\n    units = ['s', 'ms', 'us', 'ns']\n    if hasattr(sys.stdout, 'encoding') and sys.stdout.encoding:\n        try:\n            \"\"\"\u03bc\"\"\".encode(sys.stdout.encoding)\n            units = ['s', 'ms', '\u03bcs', 'ns']\n        except:\n            pass\n    scaling = [1, 1000.0, 1000000.0, 1000000000.0]\n    if timespan > 0.0:\n        order = min(-int(math.floor(math.log10(timespan)) // 3), 3)\n    else:\n        order = 3\n    return '%.*g %s' % (precision, timespan * scaling[order], units[order])", "test_code_list": [{"test_code": "import gc\nimport io\nimport os\nimport re\nimport shlex\nimport sys\nimport warnings\nfrom importlib import invalidate_caches\nfrom io import StringIO\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom unittest import TestCase\nfrom unittest import mock\nimport pytest\nfrom IPython import get_ipython\nfrom IPython.core import magic\nfrom IPython.core.error import UsageError\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import cell_magic\nfrom IPython.core.magic import line_magic\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_magic\nfrom IPython.core.magics import code\nfrom IPython.core.magics import execution\nfrom IPython.core.magics import logging\nfrom IPython.core.magics import osm\nfrom IPython.core.magics import script\nfrom IPython.testing import decorators as dec\nfrom IPython.testing import tools as tt\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.process import find_cmd\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.syspathcontext import prepended_to_syspath\nfrom tempfile import NamedTemporaryFile\nimport logging as log_mod\nimport importlib.abc\nimport importlib.util\ndef test_time_microseconds_display():\n    \"\"\"Ensure ASCII is used when necessary\"\"\"\n    with mock.patch('sys.stdout', io.TextIOWrapper(StringIO(), encoding=\n        'utf-8')):\n        assert _format_time(1e-06) == '1 \u03bcs'\n    with mock.patch('sys.stdout', io.TextIOWrapper(StringIO(), encoding=\n        'ascii')):\n        assert _format_time(1e-06) == '1 us'\n\ntest_time_microseconds_display()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_magic.py"}], "instruction": "Functionality: The _format_time function formats a given timespan into a more human-readable format. It can convert timespans greater than or equal to 60 seconds into days, hours, minutes, and seconds, aiming for the largest unit that fits within the timespan. For timespans less than 60 seconds, it provides the measurement in seconds, milliseconds, microseconds, or nanoseconds, depending on the scale of the input. The function also supports a precision parameter that determines the number of decimal places in the output.\n\nInputs: \n- timespan: A floating-point number representing the duration in seconds that needs to be formatted.\n- precision: An optional integer parameter (default is 3) that specifies the number of significant digits in the formatted output. This parameter is only applicable when the timespan is less than 60 seconds.\n\nOutputs: \n- A string that represents the formatted time. The string will contain the numerical value of the duration followed by the appropriate unit of time (e.g., \"2.345 s\" for seconds or \"1h 30min 5s\" for an hour, minutes, and seconds).", "method_code_mask": "import ast\nimport bdb\nimport builtins as builtin_mod\nimport copy\nimport cProfile as profile\nimport gc\nimport itertools\nimport math\nimport os\nimport pstats\nimport re\nimport shlex\nimport sys\nimport time\nimport timeit\nfrom typing import Dict\nfrom typing import Any\nfrom ast import Assign\nfrom ast import Call\nfrom ast import Expr\nfrom ast import Load\nfrom ast import Module\nfrom ast import Name\nfrom ast import NodeTransformer\nfrom ast import Store\nfrom ast import parse\nfrom ast import unparse\nfrom io import StringIO\nfrom logging import error\nfrom pathlib import Path\nfrom pdb import Restart\nfrom textwrap import dedent\nfrom textwrap import indent\nfrom warnings import warn\nfrom IPython.core import magic_arguments\nfrom IPython.core import oinspect\nfrom IPython.core import page\nfrom IPython.core.displayhook import DisplayHook\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import cell_magic\nfrom IPython.core.magic import line_cell_magic\nfrom IPython.core.magic import line_magic\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import needs_local_scope\nfrom IPython.core.magic import no_var_expand\nfrom IPython.core.magic import on_off\nfrom IPython.core.magic import output_can_be_silenced\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.capture import capture_output\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.ipstruct import Struct\nfrom IPython.utils.module_paths import find_mod\nfrom IPython.utils.path import get_py_filename\nfrom IPython.utils.path import shellglob\nfrom IPython.utils.timing import clock\nfrom IPython.utils.timing import clock2\nfrom IPython.core.magics.ast_mod import ReplaceCodeTransformer\n\n\ndef _format_time(timespan, precision=3): [MASK]\n"}
{"method_name": "strip_initial_indent", "full_method_name": "strip_initial_indent", "method_path": "../srcdata/Computation/ipython/IPython/core/magics/code.py", "method_code": "import inspect\nimport io\nimport os\nimport re\nimport sys\nimport ast\nfrom itertools import chain\nfrom urllib.request import Request\nfrom urllib.request import urlopen\nfrom urllib.parse import urlencode\nfrom pathlib import Path\nfrom IPython.core.error import TryNext\nfrom IPython.core.error import StdinNotImplementedError\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import line_magic\nfrom IPython.core.oinspect import find_file\nfrom IPython.core.oinspect import find_source_lines\nfrom IPython.core.release import version\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.path import get_py_filename\nfrom warnings import warn\nfrom logging import error\nfrom IPython.utils.text import get_text_list\ndef strip_initial_indent(lines):\n    \"\"\"For %load, strip indent from lines until finding an unindented line.\n\n    https://github.com/ipython/ipython/issues/9775\n    \"\"\"\n    indent_re = re.compile('\\\\s+')\n    it = iter(lines)\n    first_line = next(it)\n    indent_match = indent_re.match(first_line)\n    if indent_match:\n        indent = indent_match.group()\n        yield first_line[len(indent):]\n        for line in it:\n            if line.startswith(indent):\n                yield line[len(indent):]\n            else:\n                yield line\n                break\n    else:\n        yield first_line\n    for line in it:\n        yield line", "test_code_list": [{"test_code": "import gc\nimport io\nimport os\nimport re\nimport shlex\nimport sys\nimport warnings\nfrom importlib import invalidate_caches\nfrom io import StringIO\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom unittest import TestCase\nfrom unittest import mock\nimport pytest\nfrom IPython import get_ipython\nfrom IPython.core import magic\nfrom IPython.core.error import UsageError\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import cell_magic\nfrom IPython.core.magic import line_magic\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import register_cell_magic\nfrom IPython.core.magic import register_line_magic\nfrom IPython.core.magics import code\nfrom IPython.core.magics import execution\nfrom IPython.core.magics import logging\nfrom IPython.core.magics import osm\nfrom IPython.core.magics import script\nfrom IPython.testing import decorators as dec\nfrom IPython.testing import tools as tt\nfrom IPython.utils.io import capture_output\nfrom IPython.utils.process import find_cmd\nfrom IPython.utils.tempdir import TemporaryDirectory\nfrom IPython.utils.tempdir import TemporaryWorkingDirectory\nfrom IPython.utils.syspathcontext import prepended_to_syspath\nfrom tempfile import NamedTemporaryFile\nimport logging as log_mod\nimport importlib.abc\nimport importlib.util\ndef test_strip_initial_indent():\n\n    def sii(s):\n        lines = s.splitlines()\n        return '\\n'.join(strip_initial_indent(lines))\n    assert sii('  a = 1\\nb = 2') == 'a = 1\\nb = 2'\n    assert sii('  a\\n    b\\nc') == 'a\\n  b\\nc'\n    assert sii('a\\n  b') == 'a\\n  b'\n\ntest_strip_initial_indent()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/core/tests/test_magic.py"}], "instruction": "Functionality: The function 'strip_initial_indent' is designed to remove the common initial indentation from a set of lines until it encounters a line that is not indented. It's particularly useful for processing code or text where the first lines might have a uniform indentation that needs to be stripped.\n\nInputs: \n- lines: A list or iterable of strings. Each string represents a line of text or code. The function will process each line, removing the common indentation from the beginning of the lines.\n\nOutputs:\n- The function yields the lines of text with the initial indentation removed from the start of each line, until it finds a line that is not indented. Once a non-indented line is found, the function stops removing indentation and outputs the rest of the lines as they are. The output is a generator, which means it can be converted to a list or iterated over to access the modified lines.", "method_code_mask": "import inspect\nimport io\nimport os\nimport re\nimport sys\nimport ast\nfrom itertools import chain\nfrom urllib.request import Request\nfrom urllib.request import urlopen\nfrom urllib.parse import urlencode\nfrom pathlib import Path\nfrom IPython.core.error import TryNext\nfrom IPython.core.error import StdinNotImplementedError\nfrom IPython.core.error import UsageError\nfrom IPython.core.macro import Macro\nfrom IPython.core.magic import Magics\nfrom IPython.core.magic import magics_class\nfrom IPython.core.magic import line_magic\nfrom IPython.core.oinspect import find_file\nfrom IPython.core.oinspect import find_source_lines\nfrom IPython.core.release import version\nfrom IPython.testing.skipdoctest import skip_doctest\nfrom IPython.utils.contexts import preserve_keys\nfrom IPython.utils.path import get_py_filename\nfrom warnings import warn\nfrom logging import error\nfrom IPython.utils.text import get_text_list\n\n\ndef strip_initial_indent(lines): [MASK]\n"}
{"method_name": "line_at_cursor", "full_method_name": "line_at_cursor", "method_path": "../srcdata/Computation/ipython/IPython/utils/tokenutil.py", "method_code": "from collections import namedtuple\nfrom io import StringIO\nfrom keyword import iskeyword\nimport tokenize\nfrom tokenize import TokenInfo\nfrom typing import List\nfrom typing import Optional\ndef line_at_cursor(cell, cursor_pos=0):\n    \"\"\"Return the line in a cell at a given cursor position\n\n    Used for calling line-based APIs that don't support multi-line input, yet.\n\n    Parameters\n    ----------\n    cell : str\n        multiline block of text\n    cursor_pos : integer\n        the cursor position\n\n    Returns\n    -------\n    (line, offset): (string, integer)\n        The line with the current cursor, and the character offset of the start of the line.\n    \"\"\"\n    offset = 0\n    lines = cell.splitlines(True)\n    for line in lines:\n        next_offset = offset + len(line)\n        if not line.endswith('\\n'):\n            next_offset += 1\n        if next_offset > cursor_pos:\n            break\n        offset = next_offset\n    else:\n        line = ''\n    return line, offset", "test_code_list": [{"test_code": "import pytest\nfrom IPython.utils.tokenutil import token_at_cursor\nfrom IPython.utils.tokenutil import line_at_cursor\ndef test_line_at_cursor():\n    cell = ''\n    line, offset = line_at_cursor(cell, cursor_pos=11)\n    assert line == ''\n    assert offset == 0\n    cell = 'One\\nTwo\\n'\n    line, offset = line_at_cursor(cell, cursor_pos=4)\n    assert line == 'Two\\n'\n    assert offset == 4\n    cell = 'pri\\npri'\n    line, offset = line_at_cursor(cell, cursor_pos=7)\n    assert line == 'pri'\n    assert offset == 4\n\ntest_line_at_cursor()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_tokenutil.py"}], "instruction": "Functionality: The function line_at_cursor is designed to return the line in a given text block (cell) at a specified cursor position, along with the character offset of the start of that line. This is particularly useful for line-based APIs that do not support multi-line input.\n\nInputs: \n- cell : str\n    A multiline block of text, which represents the code or text document.\n- cursor_pos : integer (default is 0)\n    The position of the cursor within the cell. This is the character index from the start of the cell.\n\nOutputs:\n- (line, offset): (string, integer)\n    A tuple where the first element, 'line', is the string containing the line at the cursor position, and the second element, 'offset', is the integer character offset of the start of the line from the start of the cell.\n\nExample Usage (not part of the instruction):\n>>> line_at_cursor(\"print('Hello')\\nprint('World')\", 15)\n('print(\\'World\\')', 15)", "method_code_mask": "from collections import namedtuple\nfrom io import StringIO\nfrom keyword import iskeyword\nimport tokenize\nfrom tokenize import TokenInfo\nfrom typing import List\nfrom typing import Optional\n\n\ndef line_at_cursor(cell, cursor_pos=0): [MASK]\n"}
{"method_name": "dir2", "full_method_name": "dir2", "method_path": "../srcdata/Computation/ipython/IPython/utils/dir2.py", "method_code": "import inspect\nimport types\ndef dir2(obj):\n    \"\"\"dir2(obj) -> list of strings\n\n    Extended version of the Python builtin dir(), which does a few extra\n    checks.\n\n    This version is guaranteed to return only a list of true strings, whereas\n    dir() returns anything that objects inject into themselves, even if they\n    are later not really valid for attribute access (many extension libraries\n    have such bugs).\n    \"\"\"\n    try:\n        words = set(dir(obj))\n    except Exception:\n        words = set()\n    if safe_hasattr(obj, '__class__'):\n        words |= set(dir(obj.__class__))\n    words = [w for w in words if isinstance(w, str)]\n    return sorted(words)", "test_code_list": [{"test_code": "from IPython.utils.dir2 import dir2\nimport pytest\ndef test_misbehaving_object_without_trait_names():\n\n\n    class MisbehavingGetattr:\n\n        def __getattr__(self, attr):\n            raise KeyError('I should be caught')\n\n        def some_method(self):\n            return True\n\n\n    class SillierWithDir(MisbehavingGetattr):\n\n        def __dir__(self):\n            return ['some_method']\n    for bad_klass in (MisbehavingGetattr, SillierWithDir):\n        obj = bad_klass()\n        assert obj.some_method()\n        with pytest.raises(KeyError):\n            obj.other_method()\n        res = dir2(obj)\n        assert 'some_method' in res\n\ntest_misbehaving_object_without_trait_names()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_dir2.py"}], "instruction": "Functionality: The dir2 function is an enhanced version of Python's built-in dir() function. It is designed to return a list of strings that are valid attribute names for the given object. This function ensures that only true strings are returned, avoiding potential issues where extension libraries might return invalid attributes for attribute access.\n\nInputs: \n- obj: The object for which to find the attribute names. This can be any Python object.\n\nOutputs:\n- A list of strings. This list contains the names of all attributes of the given object, sorted alphabetically. Attributes that are not strings or are not valid for attribute access are excluded from the list.", "method_code_mask": "import inspect\nimport types\n\n\ndef dir2(obj): [MASK]\n"}
{"method_name": "strip_email_quotes", "full_method_name": "strip_email_quotes", "method_path": "../srcdata/Computation/ipython/IPython/utils/text.py", "method_code": "import os\nimport re\nimport string\nimport sys\nimport textwrap\nimport warnings\nfrom string import Formatter\nfrom pathlib import Path\nfrom typing import List\nfrom typing import Dict\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import cast\nfrom typing import Sequence\nfrom typing import Mapping\nfrom typing import Any\nfrom typing_extensions import Self\ndef strip_email_quotes(text):\n    \"\"\"Strip leading email quotation characters ('>').\n\n    Removes any combination of leading '>' interspersed with whitespace that\n    appears *identically* in all lines of the input text.\n\n    Parameters\n    ----------\n    text : str\n\n    Examples\n    --------\n\n    Simple uses::\n\n        In [2]: strip_email_quotes('> > text')\n        Out[2]: 'text'\n\n        In [3]: strip_email_quotes('> > text\\\\n> > more')\n        Out[3]: 'text\\\\nmore'\n\n    Note how only the common prefix that appears in all lines is stripped::\n\n        In [4]: strip_email_quotes('> > text\\\\n> > more\\\\n> more...')\n        Out[4]: '> text\\\\n> more\\\\nmore...'\n\n    So if any line has no quote marks ('>'), then none are stripped from any\n    of them ::\n\n        In [5]: strip_email_quotes('> > text\\\\n> > more\\\\nlast different')\n        Out[5]: '> > text\\\\n> > more\\\\nlast different'\n    \"\"\"\n    lines = text.splitlines()\n    strip_len = 0\n    for characters in zip(*lines):\n        if len(set(characters)) > 1:\n            break\n        prefix_char = characters[0]\n        if prefix_char in string.whitespace or prefix_char == '>':\n            strip_len += 1\n        else:\n            break\n    text = '\\n'.join([ln[strip_len:] for ln in lines])\n    return text", "test_code_list": [{"test_code": "import os\nimport math\nimport random\nfrom pathlib import Path\nimport pytest\nfrom IPython.utils import text\ndef test_strip_email():\n    src = \"\"\"        >> >>> def f(x):\n        >> ...   return x+1\n        >> ... \n        >> >>> zz = f(2.5)\"\"\"\n    cln = '>>> def f(x):\\n...   return x+1\\n... \\n>>> zz = f(2.5)'\n    assert strip_email_quotes(src) == cln\n\ntest_strip_email()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_text.py"}, {"test_code": "import os\nimport math\nimport random\nfrom pathlib import Path\nimport pytest\nfrom IPython.utils import text\ndef test_strip_email2():\n    src = '> > > list()'\n    cln = 'list()'\n    assert strip_email_quotes(src) == cln\n\ntest_strip_email2()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_text.py"}], "instruction": "Functionality: The strip_email_quotes function is designed to remove leading email quotation characters ('>') from each line of the input text. It specifically targets any combination of leading '>' interspersed with whitespace that appears identically in all lines of the text. The function does not remove any characters beyond the common prefix.\n\nInputs: \n- text (str): A string representing the input text from which leading email quotation characters are to be stripped. The input can consist of multiple lines separated by newline characters ('\\n').\n\nOutputs:\n- str: The function returns a string that is the modified version of the input text with the common leading email quotation characters ('>') and their associated whitespace stripped. If there is no common prefix of quotation marks in all lines, the original text is returned unchanged.", "method_code_mask": "import os\nimport re\nimport string\nimport sys\nimport textwrap\nimport warnings\nfrom string import Formatter\nfrom pathlib import Path\nfrom typing import List\nfrom typing import Dict\nfrom typing import Tuple\nfrom typing import Optional\nfrom typing import cast\nfrom typing import Sequence\nfrom typing import Mapping\nfrom typing import Any\nfrom typing_extensions import Self\n\n\ndef strip_email_quotes(text): [MASK]\n"}
{"method_name": "import_item", "full_method_name": "import_item", "method_path": "../srcdata/Computation/ipython/IPython/utils/importstring.py", "method_code": "\ndef import_item(name):\n    \"\"\"Import and return ``bar`` given the string ``foo.bar``.\n\n    Calling ``bar = import_item(\"foo.bar\")`` is the functional equivalent of\n    executing the code ``from foo import bar``.\n\n    Parameters\n    ----------\n    name : string\n        The fully qualified name of the module/package being imported.\n\n    Returns\n    -------\n    mod : module object\n        The module that was imported.\n    \"\"\"\n    parts = name.rsplit('.', 1)\n    if len(parts) == 2:\n        package, obj = parts\n        module = __import__(package, fromlist=[obj])\n        try:\n            pak = getattr(module, obj)\n        except AttributeError as e:\n            raise ImportError('No module named %s' % obj) from e\n        return pak\n    else:\n        return __import__(parts[0])", "test_code_list": [{"test_code": "import pytest\nfrom IPython.utils.importstring import import_item\nimport os\nfrom os import path\ndef test_import_plain():\n    \"\"\"Test simple imports\"\"\"\n    import os\n    os2 = import_item('os')\n    assert os is os2\n\ntest_import_plain()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_importstring.py"}, {"test_code": "import pytest\nfrom IPython.utils.importstring import import_item\nimport os\nfrom os import path\ndef test_import_nested():\n    \"\"\"Test nested imports from the stdlib\"\"\"\n    from os import path\n    path2 = import_item('os.path')\n    assert path is path2\n\ntest_import_nested()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_importstring.py"}], "instruction": "Functionality: \nThe function 'import_item' is designed to import a specific object from a module given the fully qualified name as a string. This function simulates the behavior of executing 'from foo import bar' in a more dynamic way, allowing the import of modules and objects by name.\n\nInputs:\n- name : string\n    The fully qualified name of the object to be imported. This is a string that contains the path from the top-level package to the specific object, such as 'math.sqrt' or 'collections.Counter'.\n\nOutputs:\n- mod : module object or object\n    The function returns the module object or the specific object that has been imported. If the input string refers to a module, the module object will be returned. If the string refers to an object within a module, the specific object will be returned. If the provided name does not lead to a valid import, an ImportError will be raised.", "method_code_mask": "def import_item(name): [MASK]\n"}
{"method_name": "dict_dir", "full_method_name": "dict_dir", "method_path": "../srcdata/Computation/ipython/IPython/utils/wildcard.py", "method_code": "import re\nimport types\nfrom IPython.utils.dir2 import dir2\ndef dict_dir(obj):\n    \"\"\"Produce a dictionary of an object's attributes. Builds on dir2 by\n    checking that a getattr() call actually succeeds.\"\"\"\n    ns = {}\n    for key in dir2(obj):\n        try:\n            ns[key] = getattr(obj, key)\n        except AttributeError:\n            pass\n    return ns", "test_code_list": [{"test_code": "import unittest\nfrom IPython.utils import wildcard\n\nclass Tests(unittest.TestCase):\n\tdef test_dict_dir(self):\n\t\n\t\n\t    class A(object):\n\t\n\t        def __init__(self):\n\t            self.a = 1\n\t            self.b = 2\n\t\n\t        def __getattribute__(self, name):\n\t            if name == 'a':\n\t                raise AttributeError\n\t            return object.__getattribute__(self, name)\n\t    a = A()\n\t    adict = dict_dir(a)\n\t    assert 'a' not in adict\n\t    self.assertEqual(adict['b'], 2)\n\t\nTests().test_dict_dir()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/utils/tests/test_wildcard.py"}], "instruction": "Functionality: The dict_dir function is designed to return a dictionary that contains all the attributes of a given object. This function extends the functionality of the dir2 function by not only listing the attributes but also attempting to retrieve their values using the getattr() function. If an AttributeError is raised during the getattr() call, the attribute is not included in the dictionary.\n\nInputs: \n- obj: The object whose attributes are to be retrieved. This can be any Python object, such as a class, a module, or an instance of a class.\n\nOutputs:\n- A dictionary where the keys are the names of the attributes of the input object, and the values are the results of calling getattr() on the object with those attribute names. Attributes that raise an AttributeError when accessed are not included in the dictionary.", "method_code_mask": "import re\nimport types\nfrom IPython.utils.dir2 import dir2\n\n\ndef dict_dir(obj): [MASK]\n"}
{"method_name": "reload", "full_method_name": "reload", "method_path": "../srcdata/Computation/ipython/IPython/lib/deepreload.py", "method_code": "import builtins as builtin_mod\nfrom contextlib import contextmanager\nimport importlib\nimport sys\nfrom types import ModuleType\nfrom warnings import warn\nimport types\ndef reload(module, exclude=(*sys.builtin_module_names, 'sys', 'os.path',\n    'builtins', '__main__', 'numpy', 'numpy._globals')):\n    \"\"\"Recursively reload all modules used in the given module.  Optionally\n    takes a list of modules to exclude from reloading.  The default exclude\n    list contains modules listed in sys.builtin_module_names with additional\n    sys, os.path, builtins and __main__, to prevent, e.g., resetting\n    display, exception, and io hooks.\n    \"\"\"\n    global found_now\n    for i in exclude:\n        found_now[i] = 1\n    try:\n        with replace_import_hook(deep_import_hook):\n            return deep_reload_hook(module)\n    finally:\n        found_now = {}", "test_code_list": [{"test_code": "import types\nfrom pathlib import Path\nimport pytest\nfrom tempfile import TemporaryDirectory\nfrom IPython.lib.deepreload import modules_reloading\nfrom IPython.lib.deepreload import reload as reload\nfrom IPython.utils.syspathcontext import prepended_to_syspath\ndef test_deepreload():\n    \"\"\"Test that reload does deep reloads and skips excluded modules.\"\"\"\n    with TemporaryDirectory() as tmpdir:\n        with prepended_to_syspath(tmpdir):\n            tmpdirpath = Path(tmpdir)\n            with open(tmpdirpath / 'A.py', 'w', encoding='utf-8') as f:\n                f.write('class Object:\\n    pass\\nok = True\\n')\n            with open(tmpdirpath / 'B.py', 'w', encoding='utf-8') as f:\n                f.write(\"import A\\nassert A.ok, 'we are fine'\\n\")\n            import A\n            import B\n            obj = A.Object()\n            reload(B, exclude=['A'])\n            assert isinstance(obj, A.Object) is True\n            A.ok = False\n            with pytest.raises(AssertionError, match='we are fine'):\n                reload(B, exclude=['A'])\n            assert len(modules_reloading) == 0\n            assert not A.ok\n            obj = A.Object()\n            A.ok = False\n            reload(B)\n            assert A.ok\n            assert isinstance(obj, A.Object) is False\n\ntest_deepreload()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/lib/tests/test_deepreload.py"}], "instruction": "Functionality: The 'reload' function is designed to recursively reload all modules used in a given module. This ensures that any changes made to the dependent modules are reflected in the current module's state. An optional list of modules can be excluded from reloading, which by default includes some critical system and built-in modules to prevent unintended behavior.\n\nInputs: \n1. module: A module object (an instance of the types.ModuleType) that you want to reload. It is the main module whose dependent modules will be reloaded.\n2. exclude: An optional tuple or list of strings representing the names of modules to exclude from the reloading process. The default value is a predefined list of modules that should not be reloaded, including sys.builtin_module_names, sys, os.path, builtins, __main__, numpy, and numpy._globals.\n\nOutputs:\nThe function returns the reloaded module object, which is the same as the input module but now with its dependencies updated. This return value can be used to further interact with the module, knowing that it has been refreshed to reflect any external changes.", "method_code_mask": "import builtins as builtin_mod\nfrom contextlib import contextmanager\nimport importlib\nimport sys\nfrom types import ModuleType\nfrom warnings import warn\nimport types\n\n\ndef reload(module, exclude=(*sys.builtin_module_names, 'sys', 'os.path',\n    'builtins', '__main__', 'numpy', 'numpy._globals')): [MASK]\n"}
{"method_name": "make_event", "full_method_name": "make_event", "method_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_shortcuts.py", "method_code": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\ndef make_event(text, cursor, suggestion):\n    event = Mock()\n    event.current_buffer = Mock()\n    event.current_buffer.suggestion = Mock()\n    event.current_buffer.text = text\n    event.current_buffer.cursor_position = cursor\n    event.current_buffer.suggestion.text = suggestion\n    event.current_buffer.document = Document(text=text, cursor_position=cursor)\n    return event", "test_code_list": [{"test_code": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\ndef test_autosuggest_token_empty():\n    full = 'def out(tag: str, n=50):'\n    event = make_event(full, len(full), '')\n    event.current_buffer.insert_text = Mock()\n    with patch(\n        'prompt_toolkit.key_binding.bindings.named_commands.forward_word'\n        ) as forward_word:\n        accept_token(event)\n        assert not event.current_buffer.insert_text.called\n        assert forward_word.called\n\ntest_autosuggest_token_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_shortcuts.py"}], "instruction": "Functionality: The make_event function is designed to create a mock event for simulating the state of an interactive command-line interface, particularly focused on the behavior of text suggestion and cursor manipulation. This function is often utilized in testing environments to ensure that the text manipulation and suggestion functionalities of a command-line interface, such as IPython's, work as intended under various conditions.\n\nInputs: \n1. text (str): The text content of the buffer. This represents the current text that is displayed in the command-line interface.\n2. cursor (int): The position of the cursor within the text. This integer value indicates the index of the cursor's current position relative to the start of the text.\n3. suggestion (str): The suggested text that is currently being offered as a completion or suggestion for the user's input.\n\nOutputs:\nThe function outputs a mock event object that encapsulates the current state of the buffer, including the text content, the cursor position, and the suggested text. This event object can then be used to test functions that rely on or alter these aspects of the command-line interface. The event object includes a current_buffer attribute, which has a suggestion attribute and methods to access the text, cursor position, and the suggested text.", "method_code_mask": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\n\n\ndef make_event(text, cursor, suggestion): [MASK]\n"}
{"method_name": "create_session_mock", "full_method_name": "create_session_mock", "method_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_shortcuts.py", "method_code": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\ndef create_session_mock():\n    session = Mock()\n    session.default_buffer = Buffer()\n    return session", "test_code_list": [{"test_code": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\ndef test_navigable_provider_connection():\n    provider = NavigableAutoSuggestFromHistory()\n    provider.skip_lines = 1\n    session_1 = create_session_mock()\n    provider.connect(session_1)\n    assert provider.skip_lines == 1\n    session_1.default_buffer.on_text_insert.fire()\n    assert provider.skip_lines == 0\n    session_2 = create_session_mock()\n    provider.connect(session_2)\n    provider.skip_lines = 2\n    assert provider.skip_lines == 2\n    session_2.default_buffer.on_text_insert.fire()\n    assert provider.skip_lines == 0\n    provider.skip_lines = 3\n    provider.disconnect()\n    session_1.default_buffer.on_text_insert.fire()\n    session_2.default_buffer.on_text_insert.fire()\n    assert provider.skip_lines == 3\n\ntest_navigable_provider_connection()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_shortcuts.py"}], "instruction": "Functionality: \nThe create_session_mock function is designed to set up a mock session for testing purposes. It creates a mock session object, which is a mimic of an IPython session, containing a default buffer that can be used for various terminal operations and testing scenarios. This function is crucial for unit testing and mocking out parts of the terminal interface in order to isolate and test specific functionalities of the terminal shortcuts and auto-suggestion features.\n\nInputs: \nThere are no input arguments required for this function. It is designed to be called without any parameters.\n\nOutputs: \nThe function returns a mock session object. This object can be utilized in test cases to simulate an active IPython terminal session environment. The returned session includes a default buffer that can be interacted with, similar to how a real terminal session would behave.\n\nUsage Example:\nmock_session = create_session_mock()\n# Further operations can be performed on mock_session, such as setting the input buffer, invoking terminal shortcuts, or testing auto-suggestions.", "method_code_mask": "import pytest\nfrom IPython.terminal.shortcuts.auto_suggest import accept\nfrom IPython.terminal.shortcuts.auto_suggest import accept_or_jump_to_end\nfrom IPython.terminal.shortcuts.auto_suggest import accept_token\nfrom IPython.terminal.shortcuts.auto_suggest import accept_character\nfrom IPython.terminal.shortcuts.auto_suggest import accept_word\nfrom IPython.terminal.shortcuts.auto_suggest import accept_and_keep_cursor\nfrom IPython.terminal.shortcuts.auto_suggest import discard\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_up\nfrom IPython.terminal.shortcuts.auto_suggest import swap_autosuggestion_down\nfrom IPython.terminal.shortcuts.auto_match import skip_over\nfrom IPython.terminal.shortcuts import create_ipython_shortcuts\nfrom IPython.terminal.shortcuts import reset_search_buffer\nfrom prompt_toolkit.history import InMemoryHistory\nfrom prompt_toolkit.buffer import Buffer\nfrom prompt_toolkit.document import Document\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom prompt_toolkit.enums import DEFAULT_BUFFER\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nimport IPython.terminal.shortcuts.auto_suggest as iptsa\n\n\ndef create_session_mock(): [MASK]\n"}
{"method_name": "_elide", "full_method_name": "_elide", "method_path": "../srcdata/Computation/ipython/IPython/terminal/ptutils.py", "method_code": "import unicodedata\nfrom wcwidth import wcwidth\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import cursor_to_position\nfrom IPython.core.completer import _deduplicate_completions\nfrom prompt_toolkit.completion import Completer\nfrom prompt_toolkit.completion import Completion\nfrom prompt_toolkit.lexers import Lexer\nfrom prompt_toolkit.lexers import PygmentsLexer\nfrom prompt_toolkit.patch_stdout import patch_stdout\nimport pygments.lexers as pygments_lexers\nimport os\nimport sys\nimport traceback\ndef _elide(string: str, typed: str, min_elide=30) ->str:\n    return _elide_typed(_elide_point(string, min_elide=min_elide), typed,\n        min_elide=min_elide)", "test_code_list": [{"test_code": "import sys\nimport unittest\nimport os\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom IPython.testing import tools as tt\nfrom IPython.terminal.ptutils import _elide\nfrom IPython.terminal.ptutils import _adjust_completion_text_based_on_context\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nimport traceback\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nclass TestElide(unittest.TestCase):\n\tdef test_elide(self):\n\t    _elide('concatenate((a1, a2, ...), axis', '')\n\t    _elide('concatenate((a1, a2, ..), . axis', '')\n\t    self.assertEqual(_elide(\n\t        'aaaa.bbbb.ccccc.dddddd.eeeee.fffff.gggggg.hhhhhh', ''),\n\t        'aaaa.b\u2026g.hhhhhh')\n\t    test_string = os.sep.join(['', 10 * 'a', 10 * 'b', 10 * 'c', ''])\n\t    expect_string = os.sep + 'a' + '\u2026' + 'b' + os.sep + 10 * 'c'\n\t    self.assertEqual(_elide(test_string, ''), expect_string)\n\t\nTestElide().test_elide()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_interactivshell.py"}, {"test_code": "import sys\nimport unittest\nimport os\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom IPython.testing import tools as tt\nfrom IPython.terminal.ptutils import _elide\nfrom IPython.terminal.ptutils import _adjust_completion_text_based_on_context\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nimport traceback\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nclass TestElide(unittest.TestCase):\n\tdef test_elide_typed_normal(self):\n\t    self.assertEqual(_elide('the quick brown fox jumped over the lazy dog',\n\t        'the quick brown fox', min_elide=10),\n\t        'the\u2026fox jumped over the lazy dog')\n\t\nTestElide().test_elide_typed_normal()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_interactivshell.py"}, {"test_code": "import sys\nimport unittest\nimport os\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom IPython.testing import tools as tt\nfrom IPython.terminal.ptutils import _elide\nfrom IPython.terminal.ptutils import _adjust_completion_text_based_on_context\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nimport traceback\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nclass TestElide(unittest.TestCase):\n\tdef test_elide_typed_short_match(self):\n\t    \"\"\"\n\t        if the match is too short we don't elide.\n\t        avoid the \"the...the\"\n\t        \"\"\"\n\t    self.assertEqual(_elide('the quick brown fox jumped over the lazy dog',\n\t        'the', min_elide=10), 'the quick brown fox jumped over the lazy dog')\n\t\nTestElide().test_elide_typed_short_match()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_interactivshell.py"}, {"test_code": "import sys\nimport unittest\nimport os\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom IPython.testing import tools as tt\nfrom IPython.terminal.ptutils import _elide\nfrom IPython.terminal.ptutils import _adjust_completion_text_based_on_context\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nimport traceback\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nclass TestElide(unittest.TestCase):\n\tdef test_elide_typed_no_match(self):\n\t    \"\"\"\n\t        if the match is too short we don't elide.\n\t        avoid the \"the...the\"\n\t        \"\"\"\n\t    self.assertEqual(_elide('the quick brown fox jumped over the lazy dog',\n\t        'the quick red fox', min_elide=10),\n\t        'the quick brown fox jumped over the lazy dog')\n\t\nTestElide().test_elide_typed_no_match()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_interactivshell.py"}], "instruction": "Functionality: The _elide function is designed to condense the given string in a way that highlights the portion of the string that is being typed by the user. This function achieves this by eliding (shortening) the parts of the string that are not being typed, while keeping the typed portion and its immediate surroundings visible. The function ensures that the visible section includes the minimum number of characters specified by min_elide.\n\nInputs: \n- string: A str representing the original, complete string that needs to be elided.\n- typed: A str representing the portion of the string that has been typed by the user. This part will be kept visible in the output.\n- min_elide: An integer (default is 30) that specifies the minimum number of characters that should be visible in the output string, including the typed portion and its context.\n\nOutputs:\n- A str that is a condensed version of the input string, with the typed portion and its surroundings visible, and other parts possibly elided to meet the min_elide requirement.", "method_code_mask": "import unicodedata\nfrom wcwidth import wcwidth\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import cursor_to_position\nfrom IPython.core.completer import _deduplicate_completions\nfrom prompt_toolkit.completion import Completer\nfrom prompt_toolkit.completion import Completion\nfrom prompt_toolkit.lexers import Lexer\nfrom prompt_toolkit.lexers import PygmentsLexer\nfrom prompt_toolkit.patch_stdout import patch_stdout\nimport pygments.lexers as pygments_lexers\nimport os\nimport sys\nimport traceback\n\n\ndef _elide(string: str, typed: str, min_elide=30) ->str: [MASK]\n"}
{"method_name": "_adjust_completion_text_based_on_context", "full_method_name": "_adjust_completion_text_based_on_context", "method_path": "../srcdata/Computation/ipython/IPython/terminal/ptutils.py", "method_code": "import unicodedata\nfrom wcwidth import wcwidth\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import cursor_to_position\nfrom IPython.core.completer import _deduplicate_completions\nfrom prompt_toolkit.completion import Completer\nfrom prompt_toolkit.completion import Completion\nfrom prompt_toolkit.lexers import Lexer\nfrom prompt_toolkit.lexers import PygmentsLexer\nfrom prompt_toolkit.patch_stdout import patch_stdout\nimport pygments.lexers as pygments_lexers\nimport os\nimport sys\nimport traceback\ndef _adjust_completion_text_based_on_context(text, body, offset):\n    if text.endswith('=') and len(body) > offset and body[offset] == '=':\n        return text[:-1]\n    else:\n        return text", "test_code_list": [{"test_code": "import sys\nimport unittest\nimport os\nfrom prompt_toolkit.auto_suggest import AutoSuggestFromHistory\nfrom IPython.testing import tools as tt\nfrom IPython.terminal.ptutils import _elide\nfrom IPython.terminal.ptutils import _adjust_completion_text_based_on_context\nfrom IPython.terminal.shortcuts.auto_suggest import NavigableAutoSuggestFromHistory\nimport traceback\nfrom IPython.display import display\nfrom IPython.display import HTML\n\nclass TestContextAwareCompletion(unittest.TestCase):\n\tdef test_adjust_completion_text_based_on_context(self):\n\t    self.assertEqual(_adjust_completion_text_based_on_context('arg1=',\n\t        'func1(a=)', 7), 'arg1')\n\t    self.assertEqual(_adjust_completion_text_based_on_context('arg1=',\n\t        'func1(a)', 7), 'arg1=')\n\t    self.assertEqual(_adjust_completion_text_based_on_context('arg1=',\n\t        'func1(a', 7), 'arg1=')\n\t    self.assertEqual(_adjust_completion_text_based_on_context('%magic',\n\t        'func1(a=)', 7), '%magic')\n\t    self.assertEqual(_adjust_completion_text_based_on_context('func2',\n\t        'func1(a=)', 7), 'func2')\n\t\nTestContextAwareCompletion().test_adjust_completion_text_based_on_context()\n", "code_start": "", "test_path": "../srcdata/Computation/ipython/IPython/terminal/tests/test_interactivshell.py"}], "instruction": "Functionality: This function adjusts the completion text based on the context within the code. It checks if the given text ends with an equals sign (=) and if the next character in the body at the given offset is also an equals sign. If both conditions are met, it returns the text without the trailing equals sign. Otherwise, it returns the original text.\n\nInputs: \n- text: A string representing the completion text that might need to be adjusted.\n- body: A string representing the body of the code where the completion is taking place.\n- offset: An integer representing the position within the body where the completion text is to be inserted or considered.\n\nOutputs:\n- adjusted_text: A string representing the adjusted completion text according to the context. If the conditions for adjustment are met, the trailing equals sign will be removed; otherwise, the original text is returned.", "method_code_mask": "import unicodedata\nfrom wcwidth import wcwidth\nfrom IPython.core.completer import provisionalcompleter\nfrom IPython.core.completer import cursor_to_position\nfrom IPython.core.completer import _deduplicate_completions\nfrom prompt_toolkit.completion import Completer\nfrom prompt_toolkit.completion import Completion\nfrom prompt_toolkit.lexers import Lexer\nfrom prompt_toolkit.lexers import PygmentsLexer\nfrom prompt_toolkit.patch_stdout import patch_stdout\nimport pygments.lexers as pygments_lexers\nimport os\nimport sys\nimport traceback\n\n\ndef _adjust_completion_text_based_on_context(text, body, offset): [MASK]\n"}
