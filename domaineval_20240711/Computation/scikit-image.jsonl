{"method_name": "expected_warnings", "full_method_name": "expected_warnings", "method_path": "../srcdata/Computation/scikit-image/skimage/_shared/_warnings.py", "method_code": "from contextlib import contextmanager\nimport sys\nimport warnings\nimport re\nimport functools\nimport os\nimport inspect\n@contextmanager\ndef expected_warnings(matching):\n    \"\"\"Context for use in testing to catch known warnings matching regexes\n\n    Parameters\n    ----------\n    matching : None or a list of strings or compiled regexes\n        Regexes for the desired warning to catch\n        If matching is None, this behaves as a no-op.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> rng = np.random.default_rng()\n    >>> image = rng.integers(0, 2**16, size=(100, 100), dtype=np.uint16)\n    >>> # rank filters are slow when bit-depth exceeds 10 bits\n    >>> from skimage import filters\n    >>> with expected_warnings(['Bad rank filter performance']):\n    ...     median_filtered = filters.rank.median(image)\n\n    Notes\n    -----\n    Uses `all_warnings` to ensure all warnings are raised.\n    Upon exiting, it checks the recorded warnings for the desired matching\n    pattern(s).\n    Raises a ValueError if any match was not found or an unexpected\n    warning was raised.\n    Allows for three types of behaviors: `and`, `or`, and `optional` matches.\n    This is done to accommodate different build environments or loop conditions\n    that may produce different warnings.  The behaviors can be combined.\n    If you pass multiple patterns, you get an orderless `and`, where all of the\n    warnings must be raised.\n    If you use the `|` operator in a pattern, you can catch one of several\n    warnings.\n    Finally, you can use `|\\\\A\\\\Z` in a pattern to signify it as optional.\n\n    \"\"\"\n    if isinstance(matching, str):\n        raise ValueError(\n            '``matching`` should be a list of strings and not a string itself.'\n            )\n    if matching is None:\n        yield None\n        return\n    strict_warnings = os.environ.get('SKIMAGE_TEST_STRICT_WARNINGS', '1')\n    if strict_warnings.lower() == 'true':\n        strict_warnings = True\n    elif strict_warnings.lower() == 'false':\n        strict_warnings = False\n    else:\n        strict_warnings = bool(int(strict_warnings))\n    with all_warnings() as w:\n        yield w\n        while None in matching:\n            matching.remove(None)\n        remaining = [m for m in matching if '\\\\A\\\\Z' not in m.split('|')]\n        for warn in w:\n            found = False\n            for match in matching:\n                if re.search(match, str(warn.message)) is not None:\n                    found = True\n                    if match in remaining:\n                        remaining.remove(match)\n            if strict_warnings and not found:\n                raise ValueError(f'Unexpected warning: {str(warn.message)}')\n        if strict_warnings and len(remaining) > 0:\n            newline = '\\n'\n            msg = (\n                f'No warning raised matching:{newline}{newline.join(remaining)}'\n                )\n            raise ValueError(msg)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.draw import random_shapes\ndef test_returns_empty_labels_and_white_image_when_cannot_fit_shape():\n    with expected_warnings(['Could not fit']):\n        image, labels = random_shapes((10000, 10000), max_shapes=1,\n            min_size=10000, shape='circle')\n    assert len(labels) == 0\n    assert (image == 255).all()\n\ntest_returns_empty_labels_and_white_image_when_cannot_fit_shape()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/draw/tests/test_random_shapes.py"}, {"test_code": "import numpy as np\nimport itertools\nfrom skimage import img_as_float\nfrom skimage import img_as_float32\nfrom skimage import img_as_float64\nfrom skimage import img_as_int\nfrom skimage import img_as_uint\nfrom skimage import img_as_ubyte\nfrom skimage.util.dtype import _convert\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import parametrize\nfrom skimage.util.dtype import convert\ndef test_downcast():\n    x = np.arange(10).astype(np.uint64)\n    with expected_warnings(['Downcasting']):\n        y = img_as_int(x)\n    assert np.allclose(y, x.astype(np.int16))\n    assert y.dtype == np.int16, y.dtype\n\ntest_downcast()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_dtype.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_empty_image():\n    image = np.zeros((6, 6), dtype=bool)\n    with expected_warnings(['entirely zero']):\n        assert_array_equal(convex_hull_image(image), image)\n\ntest_empty_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=int)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=np.uint8)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom skimage import data\nfrom skimage import draw\nfrom skimage import img_as_float\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.feature import corner_fast\nfrom skimage.feature import corner_foerstner\nfrom skimage.feature import corner_harris\nfrom skimage.feature import corner_kitchen_rosenfeld\nfrom skimage.feature import corner_moravec\nfrom skimage.feature import corner_orientations\nfrom skimage.feature import corner_peaks\nfrom skimage.feature import corner_shi_tomasi\nfrom skimage.feature import corner_subpix\nfrom skimage.feature import hessian_matrix\nfrom skimage.feature import hessian_matrix_det\nfrom skimage.feature import hessian_matrix_eigvals\nfrom skimage.feature import peak_local_max\nfrom skimage.feature import shape_index\nfrom skimage.feature import structure_tensor\nfrom skimage.feature import structure_tensor_eigenvalues\nfrom skimage.morphology import cube\nfrom skimage.morphology import octagon\ndef test_shape_index():\n    square = np.zeros((5, 5))\n    square[2, 2] = 4\n    with expected_warnings(['divide by zero|\\\\A\\\\Z', 'invalid value|\\\\A\\\\Z']):\n        s = shape_index(square, sigma=0.1)\n    assert_almost_equal(s, np.array([[np.nan, np.nan, -0.5, np.nan, np.nan],\n        [np.nan, 0, np.nan, 0, np.nan], [-0.5, np.nan, -1, np.nan, -0.5], [\n        np.nan, 0, np.nan, 0, np.nan], [np.nan, np.nan, -0.5, np.nan, np.nan]])\n        )\n\ntest_shape_index()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_corner.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.feature import peak\n\nclass TestPeakLocalMax():\n\tdef test_threshold_rel_default(self):\n\t    image = np.ones((5, 5))\n\t    image[2, 2] = 1\n\t    assert len(peak.peak_local_max(image)) == 0\n\t    image[2, 2] = 2\n\t    assert_array_equal(peak.peak_local_max(image), [[2, 2]])\n\t    image[2, 2] = 0\n\t    with expected_warnings(['When min_distance < 1']):\n\t        assert len(peak.peak_local_max(image, min_distance=0)\n\t            ) == image.size - 1\n\t\nTestPeakLocalMax().test_threshold_rel_default()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_peak.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert 109 < threshold_otsu(img) < 111\n\ntest_otsu_astro_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert_almost_equal(threshold_multiotsu(img), [58, 149])\n\ntest_multiotsu_astro_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float(self):\n\t    image_uint = img_as_ubyte(data.camera()[:50, :50])\n\t    image_float = img_as_float(image_uint)\n\t    methods = ['autolevel', 'equalize', 'gradient', 'threshold',\n\t        'subtract_mean', 'enhance_contrast', 'pop']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_uint, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(image_float, disk(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float_3d(self):\n\t    np.random.seed(0)\n\t    volume_uint = np.random.randint(0, high=256, size=(10, 20, 30), dtype=\n\t        np.uint8)\n\t    volume_float = img_as_float(volume_uint)\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_uint, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(volume_float, ball(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed(self):\n\t    image = img_as_ubyte(data.camera())[::2, ::2]\n\t    image[image > 127] = 0\n\t    image_s = image.astype(np.int8)\n\t    image_u = img_as_ubyte(image_s)\n\t    assert_equal(image_u, img_as_ubyte(image_s))\n\t    methods = ['autolevel', 'equalize', 'gradient', 'maximum', 'mean',\n\t        'geometric_mean', 'subtract_mean', 'median', 'minimum', 'modal',\n\t        'enhance_contrast', 'pop', 'threshold']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_u, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(image_s, disk(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed_3d(self):\n\t    np.random.seed(0)\n\t    volume_s = np.random.randint(0, high=127, size=(10, 20, 30), dtype=np.int8)\n\t    volume_u = img_as_ubyte(volume_s)\n\t    assert_equal(volume_u, img_as_ubyte(volume_s))\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_u, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(volume_s, ball(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_entropy(self):\n\t    footprint = np.ones((16, 16), dtype=np.uint8)\n\t    data = np.tile(np.asarray([0, 1]), (100, 100)).astype(np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 1\n\t    data = np.tile(np.asarray([[0, 1], [2, 3]]), (10, 10)).astype(np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 2\n\t    data = np.tile(np.asarray([[0, 1, 2, 3], [4, 5, 6, 7]]), (10, 10)).astype(\n\t        np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 3\n\t    data = np.tile(np.reshape(np.arange(16), (4, 4)), (10, 10)).astype(np.uint8\n\t        )\n\t    assert np.max(rank.entropy(data, footprint)) == 4\n\t    data = np.tile(np.reshape(np.arange(64), (8, 8)), (10, 10)).astype(np.uint8\n\t        )\n\t    assert np.max(rank.entropy(data, footprint)) == 6\n\t    data = np.tile(np.reshape(np.arange(256), (16, 16)), (10, 10)).astype(np\n\t        .uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 8\n\t    footprint = np.ones((64, 64), dtype=np.uint8)\n\t    data = np.zeros((65, 65), dtype=np.uint16)\n\t    data[:64, :64] = np.reshape(np.arange(4096), (64, 64))\n\t    with expected_warnings(['Bad rank filter performance']):\n\t        assert np.max(rank.entropy(data, footprint)) == 12\n\t    with expected_warnings(['Bad rank filter performance']):\n\t        out = rank.entropy(data, np.ones((16, 16), dtype=np.uint8))\n\t    assert out.dtype == np.float64\n\t\nTestRank().test_entropy()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_16bit(self):\n\t    image = np.zeros((21, 21), dtype=np.uint16)\n\t    footprint = np.ones((3, 3), dtype=np.uint8)\n\t    for bitdepth in range(17):\n\t        value = 2 ** bitdepth - 1\n\t        image[10, 10] = value\n\t        if bitdepth >= 11:\n\t            expected = ['Bad rank filter performance']\n\t        else:\n\t            expected = []\n\t        with expected_warnings(expected):\n\t            assert rank.minimum(image, footprint)[10, 10] == 0\n\t            assert rank.maximum(image, footprint)[10, 10] == value\n\t            mean_val = rank.mean(image, footprint)[10, 10]\n\t            assert mean_val == int(value / footprint.size)\n\t\nTestRank().test_16bit()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_trivial_cases():\n    img = np.ones((10, 10))\n    labels = np.ones((10, 10))\n    with expected_warnings(['Returning provided labels']):\n        pass_through = random_walker(img, labels)\n    np.testing.assert_array_equal(pass_through, labels)\n    labels[:, :5] = 3\n    expected = np.concatenate(((labels == 1)[..., np.newaxis], (labels == 3\n        )[..., np.newaxis]), axis=2)\n    with expected_warnings(['Returning provided labels']):\n        test = random_walker(img, labels, return_full_prob=True)\n    np.testing.assert_array_equal(test, expected)\n    img = np.full((10, 10), False)\n    object_A = np.array([(6, 7), (6, 8), (7, 7), (7, 8)])\n    object_B = np.array([(3, 1), (4, 1), (2, 2), (3, 2), (4, 2), (2, 3), (3,\n        3)])\n    for x, y in np.vstack((object_A, object_B)):\n        img[y][x] = True\n    markers = np.zeros((10, 10), dtype=np.int8)\n    for x, y in object_B:\n        markers[y][x] = 1\n    markers[img == 0] = -1\n    with expected_warnings(['All unlabeled pixels are isolated']):\n        output_labels = random_walker(img, markers)\n    assert np.all(output_labels[markers == 1] == 1)\n    assert np.all(output_labels[markers == 0] == -1)\n    with expected_warnings(['All unlabeled pixels are isolated']):\n        test = random_walker(img, markers, return_full_prob=True)\n\ntest_trivial_cases()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_isolated_seeds():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 1\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask)\n    assert res[1, 1] == 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n\ntest_isolated_seeds()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_isolated_area():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 0\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask)\n    assert res[1, 1] == 0\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    assert res[0, 1, 1] == 0\n    assert res[1, 1, 1] == 0\n\ntest_isolated_area()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_prob_tol():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 1\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    res = random_walker(a, mask, return_full_prob=True, beta=10)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n    res = random_walker(a, mask, return_full_prob=True, prob_tol=0.1)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n    res = random_walker(a, mask, return_full_prob=True, tol=1e-09)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n\ntest_prob_tol()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import arch32\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_array_less\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import xfail\nfrom skimage.measure import CircleModel\nfrom skimage.measure import EllipseModel\nfrom skimage.measure import LineModelND\nfrom skimage.measure import ransac\nfrom skimage.measure.fit import _dynamic_max_trials\nfrom skimage.transform import AffineTransform\ndef test_ransac_sample_duplicates():\n\n\n    class DummyModel:\n        \"\"\"Dummy model to check for duplicates.\"\"\"\n\n        def estimate(self, data):\n            assert_equal(np.unique(data).size, data.size)\n            return True\n\n        def residuals(self, data):\n            return np.ones(len(data), dtype=np.float64)\n    data = np.arange(4)\n    with expected_warnings(['No inliers found']):\n        ransac(data, DummyModel, min_samples=3, residual_threshold=0.0,\n            max_trials=10)\n\ntest_ransac_sample_duplicates()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_fit.py"}, {"test_code": "import numpy as np\nfrom skimage.restoration import unwrap_phase\nimport sys\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_almost_equal_nulp\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import skipif\nfrom skimage._shared._warnings import expected_warnings\ndef test_mask():\n    length = 100\n    ramps = [np.linspace(0, 4 * np.pi, length), np.linspace(0, 8 * np.pi,\n        length), np.linspace(0, 6 * np.pi, length)]\n    image = np.vstack(ramps)\n    mask_1d = np.ones((length,), dtype=bool)\n    mask_1d[0] = mask_1d[-1] = False\n    for i in range(len(ramps)):\n        mask = np.zeros(image.shape, dtype=bool)\n        mask |= mask_1d.reshape(1, -1)\n        mask[i, :] = False\n        image_wrapped = np.ma.array(np.angle(np.exp(1.0j * image)), mask=mask)\n        image_unwrapped = unwrap_phase(image_wrapped)\n        image_unwrapped -= image_unwrapped[0, 0]\n        assert_array_almost_equal_nulp(image_unwrapped[:, -1], image[i, -1])\n        assert_(np.ma.isMaskedArray(image_unwrapped))\n        with expected_warnings(['length 1 dimension']):\n            shape = (1,) + image_wrapped.shape\n            image_wrapped_3d = image_wrapped.reshape(shape)\n            image_unwrapped_3d = unwrap_phase(image_wrapped_3d)\n            image_unwrapped_3d -= image_unwrapped_3d[0, 0, 0]\n        assert_array_almost_equal_nulp(image_unwrapped_3d[:, :, -1], image[\n            i, -1])\n\ntest_mask()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/restoration/tests/test_unwrap.py"}], "instruction": "Functionality: The expected_warnings function is a context manager designed to catch and verify warnings raised during the execution of a block of code. This function is useful for testing scenarios to ensure that the expected warnings are indeed raised and to prevent unexpected warnings from slipping through.\n\nInputs: \n- matching: A list of strings or compiled regular expressions. Each element in the list represents a pattern that the warning messages should match. If None, the function behaves as a no-op (no operation). It is crucial to note that 'matching' should not be a single string but a list of strings or regexes.\n\nOutputs:\n- Upon exiting the context, the function checks if all the warnings match the patterns specified in the 'matching' input. It raises a ValueError if any of the expected warnings are not found or if an unexpected warning is raised. The function supports different match behaviors: 'and' (all patterns must match), 'or' (one of several patterns can match), and 'optional' matches (indicated by '|\\\\A\\\\Z' in a pattern).\n\nUsage Example:\n- The function is used as a context manager, surrounding the code block that is expected to raise warnings. If the expected warnings are not raised or if unexpected warnings occur, a ValueError is raised.\n\nNotes:\n- The function uses the 'all_warnings' context manager to ensure all warnings are raised. It supports customizing the strictness of warnings checking through an environment variable 'SKIMAGE_TEST_STRICT_WARNINGS'. The function removes optional matches from the list of remaining patterns to be matched.", "method_code_mask": "from contextlib import contextmanager\nimport sys\nimport warnings\nimport re\nimport functools\nimport os\nimport inspect\n\n\n@contextmanager\ndef expected_warnings(matching): [MASK]\n"}
{"method_name": "regular_grid", "full_method_name": "regular_grid", "method_path": "../srcdata/Computation/scikit-image/skimage/util/_regular_grid.py", "method_code": "import numpy as np\ndef regular_grid(ar_shape, n_points):\n    \"\"\"Find `n_points` regularly spaced along `ar_shape`.\n\n    The returned points (as slices) should be as close to cubically-spaced as\n    possible. Essentially, the points are spaced by the Nth root of the input\n    array size, where N is the number of dimensions. However, if an array\n    dimension cannot fit a full step size, it is \"discarded\", and the\n    computation is done for only the remaining dimensions.\n\n    Parameters\n    ----------\n    ar_shape : array-like of ints\n        The shape of the space embedding the grid. ``len(ar_shape)`` is the\n        number of dimensions.\n    n_points : int\n        The (approximate) number of points to embed in the space.\n\n    Returns\n    -------\n    slices : tuple of slice objects\n        A slice along each dimension of `ar_shape`, such that the intersection\n        of all the slices give the coordinates of regularly spaced points.\n\n        .. versionchanged:: 0.14.1\n            In scikit-image 0.14.1 and 0.15, the return type was changed from a\n            list to a tuple to ensure `compatibility with Numpy 1.15`_ and\n            higher. If your code requires the returned result to be a list, you\n            may convert the output of this function to a list with:\n\n            >>> result = list(regular_grid(ar_shape=(3, 20, 40), n_points=8))\n\n            .. _compatibility with NumPy 1.15: https://github.com/numpy/numpy/blob/master/doc/release/1.15.0-notes.rst#deprecations\n\n    Examples\n    --------\n    >>> ar = np.zeros((20, 40))\n    >>> g = regular_grid(ar.shape, 8)\n    >>> g\n    (slice(5, None, 10), slice(5, None, 10))\n    >>> ar[g] = 1\n    >>> ar.sum()\n    8.0\n    >>> ar = np.zeros((20, 40))\n    >>> g = regular_grid(ar.shape, 32)\n    >>> g\n    (slice(2, None, 5), slice(2, None, 5))\n    >>> ar[g] = 1\n    >>> ar.sum()\n    32.0\n    >>> ar = np.zeros((3, 20, 40))\n    >>> g = regular_grid(ar.shape, 8)\n    >>> g\n    (slice(1, None, 3), slice(5, None, 10), slice(5, None, 10))\n    >>> ar[g] = 1\n    >>> ar.sum()\n    8.0\n    \"\"\"\n    ar_shape = np.asanyarray(ar_shape)\n    ndim = len(ar_shape)\n    unsort_dim_idxs = np.argsort(np.argsort(ar_shape))\n    sorted_dims = np.sort(ar_shape)\n    space_size = float(np.prod(ar_shape))\n    if space_size <= n_points:\n        return (slice(None),) * ndim\n    stepsizes = np.full(ndim, (space_size / n_points) ** (1.0 / ndim),\n        dtype='float64')\n    if (sorted_dims < stepsizes).any():\n        for dim in range(ndim):\n            stepsizes[dim] = sorted_dims[dim]\n            space_size = float(np.prod(sorted_dims[dim + 1:]))\n            stepsizes[dim + 1:] = (space_size / n_points) ** (1.0 / (ndim -\n                dim - 1))\n            if (sorted_dims >= stepsizes).all():\n                break\n    starts = (stepsizes // 2).astype(int)\n    stepsizes = np.round(stepsizes).astype(int)\n    slices = [slice(start, None, step) for start, step in zip(starts,\n        stepsizes)]\n    slices = tuple(slices[i] for i in unsort_dim_idxs)\n    return slices", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_full():\n    ar = np.zeros((2, 2))\n    g = regular_grid(ar, 25)\n    assert_equal(g, [slice(None, None, None), slice(None, None, None)])\n    ar[g] = 1\n    assert_equal(ar.size, ar.sum())\n\ntest_regular_grid_full()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_2d_8():\n    ar = np.zeros((20, 40))\n    g = regular_grid(ar.shape, 8)\n    assert_equal(g, [slice(5.0, None, 10.0), slice(5.0, None, 10.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 8)\n\ntest_regular_grid_2d_8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_2d_32():\n    ar = np.zeros((20, 40))\n    g = regular_grid(ar.shape, 32)\n    assert_equal(g, [slice(2.0, None, 5.0), slice(2.0, None, 5.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 32)\n\ntest_regular_grid_2d_32()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_3d_8():\n    ar = np.zeros((3, 20, 40))\n    g = regular_grid(ar.shape, 8)\n    assert_equal(g, [slice(1.0, None, 3.0), slice(5.0, None, 10.0), slice(\n        5.0, None, 10.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 8)\n\ntest_regular_grid_3d_8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}], "instruction": "Functionality: \nThe regular_grid function is designed to find a specified number of points that are regularly spaced within a given array shape. These points are identified as slices along each dimension of the input array shape, ensuring that the points are as evenly distributed as possible, considering the dimensions that can accommodate the step size derived from the input array size and the number of desired points.\n\nInputs: \n- ar_shape: An array-like object of integers that represents the shape of the space in which the grid is embedded. The length of ar_shape indicates the number of dimensions.\n- n_points: An integer representing the approximate number of points to be embedded in the space.\n\nOutputs: \n- slices: A tuple of slice objects, one for each dimension of ar_shape. The slices indicate the coordinates of regularly spaced points in the space. The intersection of these slices gives the coordinates of the points that are as evenly distributed as possible within the dimensions that can fit the determined step size. Note: If your code requires the output to be a list, convert the output of this function to a list as follows: `result = list(regular_grid(ar_shape=(3, 20, 40), n_points=8))`.", "method_code_mask": "import numpy as np\n\n\ndef regular_grid(ar_shape, n_points): [MASK]\n"}
{"method_name": "invert", "full_method_name": "invert", "method_path": "../srcdata/Computation/scikit-image/skimage/util/_invert.py", "method_code": "import numpy as np\ndef invert(image, signed_float=False):\n    \"\"\"Invert an image.\n\n    Invert the intensity range of the input image, so that the dtype maximum\n    is now the dtype minimum, and vice-versa. This operation is\n    slightly different depending on the input dtype:\n\n    - unsigned integers: subtract the image from the dtype maximum\n    - signed integers: subtract the image from -1 (see Notes)\n    - floats: subtract the image from 1 (if signed_float is False, so we\n      assume the image is unsigned), or from 0 (if signed_float is True).\n\n    See the examples for clarification.\n\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n    signed_float : bool, optional\n        If True and the image is of type float, the range is assumed to\n        be [-1, 1]. If False and the image is of type float, the range is\n        assumed to be [0, 1].\n\n    Returns\n    -------\n    inverted : ndarray\n        Inverted image.\n\n    Notes\n    -----\n    Ideally, for signed integers we would simply multiply by -1. However,\n    signed integer ranges are asymmetric. For example, for np.int8, the range\n    of possible values is [-128, 127], so that -128 * -1 equals -128! By\n    subtracting from -1, we correctly map the maximum dtype value to the\n    minimum.\n\n    Examples\n    --------\n    >>> img = np.array([[100,  0, 200],\n    ...                 [  0, 50,   0],\n    ...                 [ 30,  0, 255]], np.uint8)\n    >>> invert(img)\n    array([[155, 255,  55],\n           [255, 205, 255],\n           [225, 255,   0]], dtype=uint8)\n    >>> img2 = np.array([[ -2, 0, -128],\n    ...                  [127, 0,    5]], np.int8)\n    >>> invert(img2)\n    array([[   1,   -1,  127],\n           [-128,   -1,   -6]], dtype=int8)\n    >>> img3 = np.array([[ 0., 1., 0.5, 0.75]])\n    >>> invert(img3)\n    array([[1.  , 0.  , 0.5 , 0.25]])\n    >>> img4 = np.array([[ 0., 1., -1., -0.25]])\n    >>> invert(img4, signed_float=True)\n    array([[-0.  , -1.  ,  1.  ,  0.25]])\n    \"\"\"\n    if image.dtype == 'bool':\n        inverted = ~image\n    elif np.issubdtype(image.dtype, np.unsignedinteger):\n        max_val = dtype_limits(image, clip_negative=False)[1]\n        inverted = np.subtract(max_val, image, dtype=image.dtype)\n    elif np.issubdtype(image.dtype, np.signedinteger):\n        inverted = np.subtract(-1, image, dtype=image.dtype)\n    elif signed_float:\n        inverted = -image\n    else:\n        inverted = np.subtract(1, image, dtype=image.dtype)\n    return inverted", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_bool():\n    dtype = 'bool'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_bool()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_uint8():\n    dtype = 'uint8'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_uint8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_int8():\n    dtype = 'int8'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    expected[0, :] = -1\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_int8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_signed():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image, signed_float=True)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_signed()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_unsigned():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=True)\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[0, :] = upper_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_unsigned()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_roundtrip():\n    for t, limits in dtype_range.items():\n        image = np.array(limits, dtype=t)\n        expected = invert(invert(image))\n        assert_array_equal(image, expected)\n\ntest_invert_roundtrip()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_null_matrix():\n    a_black = np.zeros((3, 3)).astype(np.uint8)\n    a_white = invert(a_black)\n    zeros = np.zeros((3, 3))\n    ones = np.ones((3, 3))\n    assert_equal(meijering(a_black, black_ridges=True), zeros)\n    assert_equal(meijering(a_white, black_ridges=False), zeros)\n    assert_equal(sato(a_black, black_ridges=True, mode='reflect'), zeros)\n    assert_equal(sato(a_white, black_ridges=False, mode='reflect'), zeros)\n    assert_allclose(frangi(a_black, black_ridges=True), zeros, atol=0.001)\n    assert_allclose(frangi(a_white, black_ridges=False), zeros, atol=0.001)\n    assert_equal(hessian(a_black, black_ridges=False, mode='reflect'), ones)\n    assert_equal(hessian(a_white, black_ridges=True, mode='reflect'), ones)\n\ntest_2d_null_matrix()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_null_matrix():\n    a_black = np.zeros((3, 3, 5)).astype(np.uint8)\n    a_white = invert(a_black)\n    zeros = np.zeros((3, 3, 5))\n    ones = np.ones((3, 3, 5))\n    assert_allclose(meijering(a_black, black_ridges=True), zeros, atol=0.1)\n    assert_allclose(meijering(a_white, black_ridges=False), zeros, atol=0.1)\n    assert_equal(sato(a_black, black_ridges=True, mode='reflect'), zeros)\n    assert_equal(sato(a_white, black_ridges=False, mode='reflect'), zeros)\n    assert_allclose(frangi(a_black, black_ridges=True), zeros, atol=0.001)\n    assert_allclose(frangi(a_white, black_ridges=False), zeros, atol=0.001)\n    assert_equal(hessian(a_black, black_ridges=False, mode='reflect'), ones)\n    assert_equal(hessian(a_white, black_ridges=True, mode='reflect'), ones)\n\ntest_3d_null_matrix()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_energy_decrease():\n    a_black = np.zeros((5, 5)).astype(np.uint8)\n    a_black[2, 2] = 255\n    a_white = invert(a_black)\n    assert_array_less(meijering(a_black, black_ridges=True).std(), a_black.\n        std())\n    assert_array_less(meijering(a_white, black_ridges=False).std(), a_white\n        .std())\n    assert_array_less(sato(a_black, black_ridges=True, mode='reflect').std(\n        ), a_black.std())\n    assert_array_less(sato(a_white, black_ridges=False, mode='reflect').std\n        (), a_white.std())\n    assert_array_less(frangi(a_black, black_ridges=True).std(), a_black.std())\n    assert_array_less(frangi(a_white, black_ridges=False).std(), a_white.std())\n    assert_array_less(hessian(a_black, black_ridges=True, mode='reflect').\n        std(), a_black.std())\n    assert_array_less(hessian(a_white, black_ridges=False, mode='reflect').\n        std(), a_white.std())\n\ntest_2d_energy_decrease()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_energy_decrease():\n    a_black = np.zeros((5, 5, 5)).astype(np.uint8)\n    a_black[2, 2, 2] = 255\n    a_white = invert(a_black)\n    assert_array_less(meijering(a_black, black_ridges=True).std(), a_black.\n        std())\n    assert_array_less(meijering(a_white, black_ridges=False).std(), a_white\n        .std())\n    assert_array_less(sato(a_black, black_ridges=True, mode='reflect').std(\n        ), a_black.std())\n    assert_array_less(sato(a_white, black_ridges=False, mode='reflect').std\n        (), a_white.std())\n    assert_array_less(frangi(a_black, black_ridges=True).std(), a_black.std())\n    assert_array_less(frangi(a_white, black_ridges=False).std(), a_white.std())\n    assert_array_less(hessian(a_black, black_ridges=True, mode='reflect').\n        std(), a_black.std())\n    assert_array_less(hessian(a_white, black_ridges=False, mode='reflect').\n        std(), a_white.std())\n\ntest_3d_energy_decrease()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_linearity():\n    a_black = np.ones((3, 3)).astype(np.uint8)\n    a_white = invert(a_black)\n    assert_allclose(meijering(1 * a_black, black_ridges=True), meijering(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(meijering(1 * a_white, black_ridges=False), meijering(\n        10 * a_white, black_ridges=False), atol=0.001)\n    assert_allclose(sato(1 * a_black, black_ridges=True, mode='reflect'),\n        sato(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(sato(1 * a_white, black_ridges=False, mode='reflect'),\n        sato(10 * a_white, black_ridges=False, mode='reflect'), atol=0.001)\n    assert_allclose(frangi(1 * a_black, black_ridges=True), frangi(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(frangi(1 * a_white, black_ridges=False), frangi(10 *\n        a_white, black_ridges=False), atol=0.001)\n    assert_allclose(hessian(1 * a_black, black_ridges=True, mode='reflect'),\n        hessian(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(hessian(1 * a_white, black_ridges=False, mode='reflect'\n        ), hessian(10 * a_white, black_ridges=False, mode='reflect'), atol=\n        0.001)\n\ntest_2d_linearity()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_linearity():\n    a_black = np.ones((3, 3, 5)).astype(np.uint8)\n    a_white = invert(a_black)\n    assert_allclose(meijering(1 * a_black, black_ridges=True), meijering(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(meijering(1 * a_white, black_ridges=False), meijering(\n        10 * a_white, black_ridges=False), atol=0.001)\n    assert_allclose(sato(1 * a_black, black_ridges=True, mode='reflect'),\n        sato(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(sato(1 * a_white, black_ridges=False, mode='reflect'),\n        sato(10 * a_white, black_ridges=False, mode='reflect'), atol=0.001)\n    assert_allclose(frangi(1 * a_black, black_ridges=True), frangi(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(frangi(1 * a_white, black_ridges=False), frangi(10 *\n        a_white, black_ridges=False), atol=0.001)\n    assert_allclose(hessian(1 * a_black, black_ridges=True, mode='reflect'),\n        hessian(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(hessian(1 * a_white, black_ridges=False, mode='reflect'\n        ), hessian(10 * a_white, black_ridges=False, mode='reflect'), atol=\n        0.001)\n\ntest_3d_linearity()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_white = invert(a_black)\n    np.zeros((100, 100))\n    ones = np.ones((100, 100))\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_2d_cropped_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_black = np.stack([a_black] * 5, axis=-1)\n    a_white = invert(a_black)\n    np.zeros(a_black.shape)\n    ones = np.ones(a_black.shape)\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_3d_cropped_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}], "instruction": "Functionality: The invert function inverts the intensity range of the input image. For unsigned integers, it subtracts the image from the dtype maximum. For signed integers, it subtracts the image from -1. For floats, it subtracts the image from 1 if signed_float is False (image is considered unsigned), or from 0 if signed_float is True (image is considered signed).\n\nInputs: \n1. image - An ndarray representing the input image.\n2. signed_float (optional) - A boolean that determines the inversion method for float inputs. If True, the image is assumed to have a range of [-1, 1]. If False, the range is assumed to be [0, 1].\n\nOutputs:\n1. inverted - An ndarray representing the inverted image.", "method_code_mask": "import numpy as np\n\n\ndef invert(image, signed_float=False): [MASK]\n"}
{"method_name": "dtype_limits", "full_method_name": "dtype_limits", "method_path": "../srcdata/Computation/scikit-image/skimage/util/dtype.py", "method_code": "import warnings\nfrom warnings import warn\nimport numpy as np\ndef dtype_limits(image, clip_negative=False):\n    \"\"\"Return intensity limits, i.e. (min, max) tuple, of the image's dtype.\n\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n    clip_negative : bool, optional\n        If True, clip the negative range (i.e. return 0 for min intensity)\n        even if the image dtype allows negative values.\n\n    Returns\n    -------\n    imin, imax : tuple\n        Lower and upper intensity limits.\n    \"\"\"\n    imin, imax = dtype_range[image.dtype.type]\n    if clip_negative:\n        imin = 0\n    return imin, imax", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_bool():\n    dtype = 'bool'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_bool()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_uint8():\n    dtype = 'uint8'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_uint8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_int8():\n    dtype = 'int8'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    expected[0, :] = -1\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_int8()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_signed():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image, signed_float=True)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_signed()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_unsigned():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=True)\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[0, :] = upper_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_unsigned()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}], "instruction": "Functionality: The function dtype_limits is designed to return the intensity limits, which are represented as a tuple of minimum and maximum values, for the data type of the given image. This function will prove useful in understanding the range of values that can be represented by the image's data type, which is essential for operations that involve manipulating pixel values.\n\nInputs: \n- image: An ndarray representing the image for which the intensity limits are to be determined.\n- clip_negative: A boolean flag that, when set to True, modifies the function's behavior to clip the negative range. This means that if the image's data type allows negative values, setting clip_negative to True will force the minimum intensity limit to 0.\n\nOutputs:\n- imin, imax: A tuple containing the lower and upper intensity limits for the image's dtype. The value of imin will be 0 if clip_negative is set to True and the dtype allows for negative values; otherwise, it will be the minimum representable value for the dtype. imax will always be the maximum representable value for the dtype.", "method_code_mask": "import warnings\nfrom warnings import warn\nimport numpy as np\n\n\ndef dtype_limits(image, clip_negative=False): [MASK]\n"}
{"method_name": "slice_along_axes", "full_method_name": "slice_along_axes", "method_path": "../srcdata/Computation/scikit-image/skimage/util/_slice_along_axes.py", "method_code": "\ndef slice_along_axes(image, slices, axes=None, copy=False):\n    \"\"\"Slice an image along given axes.\n\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n    slices : list of 2-tuple (a, b) where a < b.\n        For each axis in `axes`, a corresponding 2-tuple\n        ``(min_val, max_val)`` to slice with (as with Python slices,\n        ``max_val`` is non-inclusive).\n    axes : int or tuple, optional\n        Axes corresponding to the limits given in `slices`. If None,\n        axes are in ascending order, up to the length of `slices`.\n    copy : bool, optional\n        If True, ensure that the output is not a view of `image`.\n\n    Returns\n    -------\n    out : ndarray\n        The region of `image` corresponding to the given slices and axes.\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> img = data.camera()\n    >>> img.shape\n    (512, 512)\n    >>> cropped_img = slice_along_axes(img, [(0, 100)])\n    >>> cropped_img.shape\n    (100, 512)\n    >>> cropped_img = slice_along_axes(img, [(0, 100), (0, 100)])\n    >>> cropped_img.shape\n    (100, 100)\n    >>> cropped_img = slice_along_axes(img, [(0, 100), (0, 75)], axes=[1, 0])\n    >>> cropped_img.shape\n    (75, 100)\n    \"\"\"\n    if not slices:\n        return image\n    if axes is None:\n        axes = list(range(image.ndim))\n        if len(axes) < len(slices):\n            raise ValueError('More `slices` than available axes')\n    elif len(axes) != len(slices):\n        raise ValueError('`axes` and `slices` must have equal length')\n    if len(axes) != len(set(axes)):\n        raise ValueError('`axes` must be unique')\n    if not all(a >= 0 and a < image.ndim for a in axes):\n        raise ValueError(\n            f'axes {axes} out of range; image has only {image.ndim} dimensions'\n            )\n    _slices = [slice(None)] * image.ndim\n    for (a, b), ax in zip(slices, axes):\n        if a < 0:\n            a %= image.shape[ax]\n        if b < 0:\n            b %= image.shape[ax]\n        if a > b:\n            raise ValueError(\n                f'Invalid slice ({a}, {b}): must be ordered `(min_val, max_val)`'\n                )\n        if a < 0 or b > image.shape[ax]:\n            raise ValueError(\n                f'Invalid slice ({a}, {b}) for image with dimensions {image.shape}'\n                )\n        _slices[ax] = slice(a, b)\n    image_slice = image[tuple(_slices)]\n    if copy and image_slice.base is not None:\n        image_slice = image_slice.copy()\n    return image_slice", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\ndef test_copy():\n    data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    out_without_copy = slice_along_axes(data, [(0, 3)], axes=[1], copy=False)\n    out_copy = slice_along_axes(data, [(0, 3)], axes=[0], copy=True)\n    assert out_without_copy.base is data\n    assert out_copy.base is not data\n\ntest_copy()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_slice_along_axes.py"}], "instruction": "Functionality: The slice_along_axes function slices an image along specified axes and slices, allowing for cropping or selecting specific sections of an image. It supports slicing along one or more axes with the option to return a copy of the sliced region, ensuring the output is not a view of the original image.\n\nInputs: \n- image: An n-dimensional array representing the input image.\n- slices: A list of 2-tuple (a, b) where a < b, specifying the minimum and non-inclusive maximum values for slicing on each axis corresponding to the axes parameter.\n- axes: An int or tuple indicating the axes along which slicing is applied. If None, axes are in ascending order up to the length of slices.\n- copy: A boolean flag. If True, the function returns a copy of the sliced region; otherwise, it returns a view.\n\nOutputs: \n- out: An n-dimensional array representing the region of the input image that corresponds to the given slices and axes.", "method_code_mask": "def slice_along_axes(image, slices, axes=None, copy=False): [MASK]\n"}
{"method_name": "apply_parallel", "full_method_name": "apply_parallel", "method_path": "../srcdata/Computation/scikit-image/skimage/util/apply_parallel.py", "method_code": "import numpy\nfrom math import ceil\nimport dask.array as da\nfrom multiprocessing import cpu_count\ndef apply_parallel(function, array, chunks=None, depth=0, mode=None,\n    extra_arguments=(), extra_keywords=None, *, dtype=None, compute=None,\n    channel_axis=None):\n    \"\"\"Map a function in parallel across an array.\n\n    Split an array into possibly overlapping chunks of a given depth and\n    boundary type, call the given function in parallel on the chunks, combine\n    the chunks and return the resulting array.\n\n    Parameters\n    ----------\n    function : function\n        Function to be mapped which takes an array as an argument.\n    array : numpy array or dask array\n        Array which the function will be applied to.\n    chunks : int, tuple, or tuple of tuples, optional\n        A single integer is interpreted as the length of one side of a square\n        chunk that should be tiled across the array.  One tuple of length\n        ``array.ndim`` represents the shape of a chunk, and it is tiled across\n        the array.  A list of tuples of length ``ndim``, where each sub-tuple\n        is a sequence of chunk sizes along the corresponding dimension. If\n        None, the array is broken up into chunks based on the number of\n        available cpus. More information about chunks is in the documentation\n        `here <https://dask.pydata.org/en/latest/array-design.html>`_. When\n        `channel_axis` is not None, the tuples can be length ``ndim - 1`` and\n        a single chunk will be used along the channel axis.\n    depth : int or sequence of int, optional\n        The depth of the added boundary cells. A tuple can be used to specify a\n        different depth per array axis. Defaults to zero. When `channel_axis`\n        is not None, and a tuple of length ``ndim - 1`` is provided, a depth of\n        0 will be used along the channel axis.\n    mode : {'reflect', 'symmetric', 'periodic', 'wrap', 'nearest', 'edge'}, optional\n        Type of external boundary padding.\n    extra_arguments : tuple, optional\n        Tuple of arguments to be passed to the function.\n    extra_keywords : dictionary, optional\n        Dictionary of keyword arguments to be passed to the function.\n    dtype : data-type or None, optional\n        The data-type of the `function` output. If None, Dask will attempt to\n        infer this by calling the function on data of shape ``(1,) * ndim``.\n        For functions expecting RGB or multichannel data this may be\n        problematic. In such cases, the user should manually specify this dtype\n        argument instead.\n\n        .. versionadded:: 0.18\n           ``dtype`` was added in 0.18.\n    compute : bool, optional\n        If ``True``, compute eagerly returning a NumPy Array.\n        If ``False``, compute lazily returning a Dask Array.\n        If ``None`` (default), compute based on array type provided\n        (eagerly for NumPy Arrays and lazily for Dask Arrays).\n    channel_axis : int or None, optional\n        If None, the image is assumed to be a grayscale (single channel) image.\n        Otherwise, this parameter indicates which axis of the array corresponds\n        to channels.\n\n    Returns\n    -------\n    out : ndarray or dask Array\n        Returns the result of the applying the operation.\n        Type is dependent on the ``compute`` argument.\n\n    Notes\n    -----\n    Numpy edge modes 'symmetric', 'wrap', and 'edge' are converted to the\n    equivalent ``dask`` boundary modes 'reflect', 'periodic' and 'nearest',\n    respectively.\n    Setting ``compute=False`` can be useful for chaining later operations.\n    For example region selection to preview a result or storing large data\n    to disk instead of loading in memory.\n\n    \"\"\"\n    try:\n        import dask.array as da\n    except ImportError:\n        raise RuntimeError(\n            \"Could not import 'dask'.  Please install using 'pip install dask'\"\n            )\n    if extra_keywords is None:\n        extra_keywords = {}\n    if compute is None:\n        compute = not isinstance(array, da.Array)\n    if channel_axis is not None:\n        channel_axis = channel_axis % array.ndim\n    if chunks is None:\n        shape = array.shape\n        try:\n            from multiprocessing import cpu_count\n            ncpu = cpu_count()\n        except NotImplementedError:\n            ncpu = 4\n        if channel_axis is not None:\n            spatial_shape = shape[:channel_axis] + shape[channel_axis + 1:]\n            chunks = list(_get_chunks(spatial_shape, ncpu))\n            chunks.insert(channel_axis, shape[channel_axis])\n            chunks = tuple(chunks)\n        else:\n            chunks = _get_chunks(shape, ncpu)\n    elif channel_axis is not None and len(chunks) == array.ndim - 1:\n        chunks = list(chunks)\n        chunks.insert(channel_axis, array.shape[channel_axis])\n        chunks = tuple(chunks)\n    if mode == 'wrap':\n        mode = 'periodic'\n    elif mode == 'symmetric':\n        mode = 'reflect'\n    elif mode == 'edge':\n        mode = 'nearest'\n    elif mode is None:\n        mode = 'reflect'\n    if channel_axis is not None:\n        if numpy.isscalar(depth):\n            depth = [depth] * (array.ndim - 1)\n        depth = list(depth)\n        if len(depth) == array.ndim - 1:\n            depth.insert(channel_axis, 0)\n        depth = tuple(depth)\n\n    def wrapped_func(arr):\n        return function(arr, *extra_arguments, **extra_keywords)\n    darr = _ensure_dask_array(array, chunks=chunks)\n    res = darr.map_overlap(wrapped_func, depth, boundary=mode, dtype=dtype)\n    if compute:\n        res = res.compute()\n    return res", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel():\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected1 = threshold_local(a, 3)\n    result1 = apply_parallel(threshold_local, a, chunks=(6, 6), depth=5,\n        extra_arguments=(3,), extra_keywords={'mode': 'reflect'})\n    assert_array_almost_equal(result1, expected1)\n\n    def wrapped_gauss(arr):\n        return gaussian(arr, sigma=1, mode='reflect')\n    expected2 = gaussian(a, sigma=1, mode='reflect')\n    result2 = apply_parallel(wrapped_gauss, a, chunks=(6, 6), depth=5)\n    assert_array_almost_equal(result2, expected2)\n    expected3 = gaussian(a, sigma=1, mode='reflect')\n    result3 = apply_parallel(wrapped_gauss, da.from_array(a, chunks=(6, 6)),\n        depth=5, compute=True)\n    assert isinstance(result3, np.ndarray)\n    assert_array_almost_equal(result3, expected3)\n\ntest_apply_parallel()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_lazy():\n    a = np.arange(144).reshape(12, 12).astype(float)\n    d = da.from_array(a, chunks=(6, 6))\n    expected1 = threshold_local(a, 3)\n    result1 = apply_parallel(threshold_local, a, chunks=(6, 6), depth=5,\n        extra_arguments=(3,), extra_keywords={'mode': 'reflect'}, compute=False\n        )\n    result2 = apply_parallel(threshold_local, d, depth=5, extra_arguments=(\n        3,), extra_keywords={'mode': 'reflect'})\n    assert isinstance(result1, da.Array)\n    assert_array_almost_equal(result1.compute(), expected1)\n    assert isinstance(result2, da.Array)\n    assert_array_almost_equal(result2.compute(), expected1)\n\ntest_apply_parallel_lazy()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_no_chunks():\n    a = np.ones(1 * 4 * 8 * 9).reshape(1, 4, 8, 9)\n\n    def add_42(arr):\n        return arr + 42\n    expected = add_42(a)\n    result = apply_parallel(add_42, a)\n    assert_array_almost_equal(result, expected)\n\ntest_no_chunks()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_wrap():\n\n    def wrapped(arr):\n        return gaussian(arr, sigma=1, mode='wrap')\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected = gaussian(a, sigma=1, mode='wrap')\n    result = apply_parallel(wrapped, a, chunks=(6, 6), depth=5, mode='wrap')\n    assert_array_almost_equal(result, expected)\n\ntest_apply_parallel_wrap()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_nearest():\n\n    def wrapped(arr):\n        return gaussian(arr, sigma=1, mode='nearest')\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected = gaussian(a, sigma=1, mode='nearest')\n    result = apply_parallel(wrapped, a, chunks=(6, 6), depth={(0): 5, (1): \n        5}, mode='nearest')\n    assert_array_almost_equal(result, expected)\n\ntest_apply_parallel_nearest()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}], "instruction": "Functionality: The apply_parallel function maps a given function across an array in parallel by splitting the array into chunks, applying the function to each chunk, and then combining the chunks to return the resulting array. This function is designed to efficiently process large arrays by utilizing parallel computation.\n\nInputs:\n- function: A function that takes an array as an argument and performs operations on it.\n- array: A numpy array or dask array on which the function will be applied.\n- chunks: Optional. Specifies how the array should be chunked. It can be an int, a tuple, or a tuple of tuples. If None, the array is broken up into chunks based on the number of available CPUs.\n- depth: Optional. The depth of the added boundary cells. Can be an int or a sequence of int to specify depth per array axis. Defaults to zero.\n- mode: Optional. Type of external boundary padding. Valid options are 'reflect', 'symmetric', 'periodic', 'wrap', 'nearest', and 'edge'.\n- extra_arguments: Optional. A tuple of arguments to be passed to the function.\n- extra_keywords: Optional. A dictionary of keyword arguments to be passed to the function.\n- dtype: Optional. The data-type of the function output. If None, Dask will attempt to infer it.\n- compute: Optional. If True, compute eagerly returning a NumPy array; if False, compute lazily returning a Dask array; if None, compute based on the array type provided.\n- channel_axis: Optional. Indicates which axis of the array corresponds to channels. If None, the image is assumed to be grayscale.\n\nOutputs:\n- out: Returns the result of applying the function to the array. The type of the output depends on the 'compute' argument.", "method_code_mask": "import numpy\nfrom math import ceil\nimport dask.array as da\nfrom multiprocessing import cpu_count\n\n\ndef apply_parallel(function, array, chunks=None, depth=0, mode=None,\n    extra_arguments=(), extra_keywords=None, *, dtype=None, compute=None,\n    channel_axis=None): [MASK]\n"}
{"method_name": "crop", "full_method_name": "crop", "method_path": "../srcdata/Computation/scikit-image/skimage/util/arraycrop.py", "method_code": "import numpy as np\nfrom numbers import Integral\ndef crop(ar, crop_width, copy=False, order='K'):\n    \"\"\"Crop array `ar` by `crop_width` along each dimension.\n\n    Parameters\n    ----------\n    ar : array-like of rank N\n        Input array.\n    crop_width : {sequence, int}\n        Number of values to remove from the edges of each axis.\n        ``((before_1, after_1),`` ... ``(before_N, after_N))`` specifies\n        unique crop widths at the start and end of each axis.\n        ``((before, after),) or (before, after)`` specifies\n        a fixed start and end crop for every axis.\n        ``(n,)`` or ``n`` for integer ``n`` is a shortcut for\n        before = after = ``n`` for all axes.\n    copy : bool, optional\n        If `True`, ensure the returned array is a contiguous copy. Normally,\n        a crop operation will return a discontiguous view of the underlying\n        input array.\n    order : {'C', 'F', 'A', 'K'}, optional\n        If ``copy==True``, control the memory layout of the copy. See\n        ``np.copy``.\n\n    Returns\n    -------\n    cropped : array\n        The cropped array. If ``copy=False`` (default), this is a sliced\n        view of the input array.\n    \"\"\"\n    ar = np.array(ar, copy=False)\n    if isinstance(crop_width, Integral):\n        crops = [[crop_width, crop_width]] * ar.ndim\n    elif isinstance(crop_width[0], Integral):\n        if len(crop_width) == 1:\n            crops = [[crop_width[0], crop_width[0]]] * ar.ndim\n        elif len(crop_width) == 2:\n            crops = [crop_width] * ar.ndim\n        else:\n            raise ValueError(\n                f\"\"\"crop_width has an invalid length: {len(crop_width)}\ncrop_width should be a sequence of N pairs, a single pair, or a single integer\"\"\"\n                )\n    elif len(crop_width) == 1:\n        crops = [crop_width[0]] * ar.ndim\n    elif len(crop_width) == ar.ndim:\n        crops = crop_width\n    else:\n        raise ValueError(\n            f\"\"\"crop_width has an invalid length: {len(crop_width)}\ncrop_width should be a sequence of N pairs, a single pair, or a single integer\"\"\"\n            )\n    slices = tuple(slice(a, ar.shape[i] - b) for i, (a, b) in enumerate(crops))\n    if copy:\n        cropped = np.array(ar[slices], order=order, copy=True)\n    else:\n        cropped = ar[slices]\n    return cropped", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_multi_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, ((1, 2), (2, 1)))\n    assert_array_equal(out[0], [7, 8])\n    assert_array_equal(out[-1], [32, 33])\n    assert_equal(out.shape, (6, 2))\n\ntest_multi_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_pair_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, (1, 2))\n    assert_array_equal(out[0], [6, 7])\n    assert_array_equal(out[-1], [31, 32])\n    assert_equal(out.shape, (6, 2))\n\ntest_pair_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_pair_tuple_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, ((1, 2),))\n    assert_array_equal(out[0], [6, 7])\n    assert_array_equal(out[-1], [31, 32])\n    assert_equal(out.shape, (6, 2))\n\ntest_pair_tuple_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_int_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, 1)\n    assert_array_equal(out[0], [6, 7, 8])\n    assert_array_equal(out[-1], [36, 37, 38])\n    assert_equal(out.shape, (7, 3))\n\ntest_int_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_int_tuple_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, (1,))\n    assert_array_equal(out[0], [6, 7, 8])\n    assert_array_equal(out[-1], [36, 37, 38])\n    assert_equal(out.shape, (7, 3))\n\ntest_int_tuple_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_copy_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out0 = crop(arr, 1, copy=True)\n    assert out0.flags.c_contiguous\n    out0[0, 0] = 100\n    assert not np.any(arr == 100)\n    assert not np.may_share_memory(arr, out0)\n    out1 = crop(arr, 1)\n    out1[0, 0] = 100\n    assert arr[1, 1] == 100\n    assert np.may_share_memory(arr, out1)\n\ntest_copy_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_zero_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, 0)\n    assert out.shape == (9, 5)\n\ntest_zero_crop()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_white = invert(a_black)\n    np.zeros((100, 100))\n    ones = np.ones((100, 100))\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_2d_cropped_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_black = np.stack([a_black] * 5, axis=-1)\n    a_white = invert(a_black)\n    np.zeros(a_black.shape)\n    ones = np.ones(a_black.shape)\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_3d_cropped_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}], "instruction": "Functionality: The crop function is designed to trim or crop an array by removing a specified number of elements from the edges of each dimension. It provides flexibility in specifying the number of elements to remove, either uniformly across all dimensions or uniquely for each dimension.\n\nInputs: \n1. `ar`: An array-like input of rank N. This is the array from which elements will be removed.\n2. `crop_width`: Determines the number of values to remove from the edges of each axis. It can be a sequence or an integer. For sequences, it can be a tuple of pairs for each dimension, a single pair, or a single number. For integers, it specifies the same crop width for all dimensions.\n3. `copy`: A boolean parameter that, if True, ensures the returned array is a contiguous copy of the cropped portion of the input array. By default, it is False, meaning the function returns a view of the input array.\n4. `order`: A string parameter that specifies the memory layout of the array if `copy` is True. It can be 'C' for C-style (row-major), 'F' for Fortran-style (column-major), 'A' for any (depends on input), or 'K' for match input as closely as possible.\n\nOutputs:\n1. `cropped`: The resulting array after cropping. If `copy` is False, it is a sliced view of the input array. If `copy` is True, it is a new array that is a contiguous copy of the cropped portion of the input array.", "method_code_mask": "import numpy as np\nfrom numbers import Integral\n\n\ndef crop(ar, crop_width, copy=False, order='K'): [MASK]\n"}
{"method_name": "view_as_blocks", "full_method_name": "view_as_blocks", "method_path": "../srcdata/Computation/scikit-image/skimage/util/shape.py", "method_code": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\ndef view_as_blocks(arr_in, block_shape):\n    \"\"\"Block view of the input n-dimensional array (using re-striding).\n\n    Blocks are non-overlapping views of the input array.\n\n    Parameters\n    ----------\n    arr_in : ndarray, shape (M[, ...])\n        Input array.\n    block_shape : tuple\n        The shape of the block. Each dimension must divide evenly into the\n        corresponding dimensions of `arr_in`.\n\n    Returns\n    -------\n    arr_out : ndarray\n        Block view of the input array.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.util.shape import view_as_blocks\n    >>> A = np.arange(4*4).reshape(4,4)\n    >>> A\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> B = view_as_blocks(A, block_shape=(2, 2))\n    >>> B[0, 0]\n    array([[0, 1],\n           [4, 5]])\n    >>> B[0, 1]\n    array([[2, 3],\n           [6, 7]])\n    >>> B[1, 0, 1, 1]\n    13\n\n    >>> A = np.arange(4*4*6).reshape(4,4,6)\n    >>> A  # doctest: +NORMALIZE_WHITESPACE\n    array([[[ 0,  1,  2,  3,  4,  5],\n            [ 6,  7,  8,  9, 10, 11],\n            [12, 13, 14, 15, 16, 17],\n            [18, 19, 20, 21, 22, 23]],\n           [[24, 25, 26, 27, 28, 29],\n            [30, 31, 32, 33, 34, 35],\n            [36, 37, 38, 39, 40, 41],\n            [42, 43, 44, 45, 46, 47]],\n           [[48, 49, 50, 51, 52, 53],\n            [54, 55, 56, 57, 58, 59],\n            [60, 61, 62, 63, 64, 65],\n            [66, 67, 68, 69, 70, 71]],\n           [[72, 73, 74, 75, 76, 77],\n            [78, 79, 80, 81, 82, 83],\n            [84, 85, 86, 87, 88, 89],\n            [90, 91, 92, 93, 94, 95]]])\n    >>> B = view_as_blocks(A, block_shape=(1, 2, 2))\n    >>> B.shape\n    (4, 2, 3, 1, 2, 2)\n    >>> B[2:, 0, 2]  # doctest: +NORMALIZE_WHITESPACE\n    array([[[[52, 53],\n             [58, 59]]],\n           [[[76, 77],\n             [82, 83]]]])\n    \"\"\"\n    if not isinstance(block_shape, tuple):\n        raise TypeError('block needs to be a tuple')\n    block_shape = np.array(block_shape)\n    if (block_shape <= 0).any():\n        raise ValueError(\"'block_shape' elements must be strictly positive\")\n    if block_shape.size != arr_in.ndim:\n        raise ValueError(\n            \"'block_shape' must have the same length as 'arr_in.shape'\")\n    arr_shape = np.array(arr_in.shape)\n    if (arr_shape % block_shape).sum() != 0:\n        raise ValueError(\"'block_shape' is not compatible with 'arr_in'\")\n    new_shape = tuple(arr_shape // block_shape) + tuple(block_shape)\n    new_strides = tuple(arr_in.strides * block_shape) + arr_in.strides\n    arr_out = as_strided(arr_in, shape=new_shape, strides=new_strides)\n    return arr_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_1D_array():\n    A = np.arange(10)\n    B = view_as_blocks(A, (5,))\n    assert_equal(B, np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]))\n\ntest_view_as_blocks_1D_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_2D_array():\n    A = np.arange(4 * 4).reshape(4, 4)\n    B = view_as_blocks(A, (2, 2))\n    assert_equal(B[0, 1], np.array([[2, 3], [6, 7]]))\n    assert_equal(B[1, 0, 1, 1], 13)\n\ntest_view_as_blocks_2D_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_3D_array():\n    A = np.arange(4 * 4 * 6).reshape(4, 4, 6)\n    B = view_as_blocks(A, (1, 2, 2))\n    assert_equal(B.shape, (4, 2, 3, 1, 2, 2))\n    assert_equal(B[2:, 0, 2], np.array([[[[52, 53], [58, 59]]], [[[76, 77],\n        [82, 83]]]]))\n\ntest_view_as_blocks_3D_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_views_non_contiguous():\n    A = np.arange(16).reshape((4, 4))\n    A = A[::2, :]\n    res_b = view_as_blocks(A, (2, 2))\n    res_w = view_as_windows(A, (2, 2))\n    print(res_b)\n    print(res_w)\n    expected_b = [[[[0, 1], [8, 9]], [[2, 3], [10, 11]]]]\n    expected_w = [[[[0, 1], [8, 9]], [[1, 2], [9, 10]], [[2, 3], [10, 11]]]]\n    assert_equal(res_b, expected_b)\n    assert_equal(res_w, expected_w)\n\ntest_views_non_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}], "instruction": "Functionality: The function view_as_blocks is designed to create a block view of an input n-dimensional array without overlapping. This is achieved by re-striding the input array, dividing it into blocks according to the specified block shape. Each dimension of the block shape must divide evenly into the corresponding dimensions of the input array.\n\nInputs:\n- arr_in: An n-dimensional Numpy array, which is the input array to be processed.\n- block_shape: A tuple that represents the shape of the blocks into which the input array will be divided. Each element of the tuple corresponds to the size of the block along that dimension.\n\nOutputs:\n- arr_out: A Numpy array representing the block view of the input array. The output array shape is determined by the division of the input array's shape by the block shape, concatenated with the block shape itself. The strides of the output array are adjusted to allow for efficient access to the blocks.", "method_code_mask": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_blocks(arr_in, block_shape): [MASK]\n"}
{"method_name": "view_as_windows", "full_method_name": "view_as_windows", "method_path": "../srcdata/Computation/scikit-image/skimage/util/shape.py", "method_code": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\ndef view_as_windows(arr_in, window_shape, step=1):\n    \"\"\"Rolling window view of the input n-dimensional array.\n\n    Windows are overlapping views of the input array, with adjacent windows\n    shifted by a single row or column (or an index of a higher dimension).\n\n    Parameters\n    ----------\n    arr_in : ndarray, shape (M[, ...])\n        Input array.\n    window_shape : integer or tuple of length arr_in.ndim\n        Defines the shape of the elementary n-dimensional orthotope\n        (better know as hyperrectangle [1]_) of the rolling window view.\n        If an integer is given, the shape will be a hypercube of\n        sidelength given by its value.\n    step : integer or tuple of length arr_in.ndim\n        Indicates step size at which extraction shall be performed.\n        If integer is given, then the step is uniform in all dimensions.\n\n    Returns\n    -------\n    arr_out : ndarray\n        (rolling) window view of the input array.\n\n    Notes\n    -----\n    One should be very careful with rolling views when it comes to\n    memory usage.  Indeed, although a 'view' has the same memory\n    footprint as its base array, the actual array that emerges when this\n    'view' is used in a computation is generally a (much) larger array\n    than the original, especially for 2-dimensional arrays and above.\n\n    For example, let us consider a 3 dimensional array of size (100,\n    100, 100) of ``float64``. This array takes about 8*100**3 Bytes for\n    storage which is just 8 MB. If one decides to build a rolling view\n    on this array with a window of (3, 3, 3) the hypothetical size of\n    the rolling view (if one was to reshape the view for example) would\n    be 8*(100-3+1)**3*3**3 which is about 203 MB! The scaling becomes\n    even worse as the dimension of the input array becomes larger.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Hyperrectangle\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.util.shape import view_as_windows\n    >>> A = np.arange(4*4).reshape(4,4)\n    >>> A\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15]])\n    >>> window_shape = (2, 2)\n    >>> B = view_as_windows(A, window_shape)\n    >>> B[0, 0]\n    array([[0, 1],\n           [4, 5]])\n    >>> B[0, 1]\n    array([[1, 2],\n           [5, 6]])\n\n    >>> A = np.arange(10)\n    >>> A\n    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    >>> window_shape = (3,)\n    >>> B = view_as_windows(A, window_shape)\n    >>> B.shape\n    (8, 3)\n    >>> B\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4],\n           [3, 4, 5],\n           [4, 5, 6],\n           [5, 6, 7],\n           [6, 7, 8],\n           [7, 8, 9]])\n\n    >>> A = np.arange(5*4).reshape(5, 4)\n    >>> A\n    array([[ 0,  1,  2,  3],\n           [ 4,  5,  6,  7],\n           [ 8,  9, 10, 11],\n           [12, 13, 14, 15],\n           [16, 17, 18, 19]])\n    >>> window_shape = (4, 3)\n    >>> B = view_as_windows(A, window_shape)\n    >>> B.shape\n    (2, 2, 4, 3)\n    >>> B  # doctest: +NORMALIZE_WHITESPACE\n    array([[[[ 0,  1,  2],\n             [ 4,  5,  6],\n             [ 8,  9, 10],\n             [12, 13, 14]],\n            [[ 1,  2,  3],\n             [ 5,  6,  7],\n             [ 9, 10, 11],\n             [13, 14, 15]]],\n           [[[ 4,  5,  6],\n             [ 8,  9, 10],\n             [12, 13, 14],\n             [16, 17, 18]],\n            [[ 5,  6,  7],\n             [ 9, 10, 11],\n             [13, 14, 15],\n             [17, 18, 19]]]])\n    \"\"\"\n    if not isinstance(arr_in, np.ndarray):\n        raise TypeError('`arr_in` must be a numpy ndarray')\n    ndim = arr_in.ndim\n    if isinstance(window_shape, numbers.Number):\n        window_shape = (window_shape,) * ndim\n    if not len(window_shape) == ndim:\n        raise ValueError('`window_shape` is incompatible with `arr_in.shape`')\n    if isinstance(step, numbers.Number):\n        if step < 1:\n            raise ValueError('`step` must be >= 1')\n        step = (step,) * ndim\n    if len(step) != ndim:\n        raise ValueError('`step` is incompatible with `arr_in.shape`')\n    arr_shape = np.array(arr_in.shape)\n    window_shape = np.array(window_shape, dtype=arr_shape.dtype)\n    if (arr_shape - window_shape < 0).any():\n        raise ValueError('`window_shape` is too large')\n    if (window_shape - 1 < 0).any():\n        raise ValueError('`window_shape` is too small')\n    slices = tuple(slice(None, None, st) for st in step)\n    window_strides = np.array(arr_in.strides)\n    indexing_strides = arr_in[slices].strides\n    win_indices_shape = (np.array(arr_in.shape) - np.array(window_shape)\n        ) // np.array(step) + 1\n    new_shape = tuple(list(win_indices_shape) + list(window_shape))\n    strides = tuple(list(indexing_strides) + list(window_strides))\n    arr_out = as_strided(arr_in, shape=new_shape, strides=strides)\n    return arr_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_1D():\n    A = np.arange(10)\n    window_shape = 3,\n    B = view_as_windows(A, window_shape)\n    assert_equal(B, np.array([[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [\n        4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]))\n\ntest_view_as_windows_1D()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_2D():\n    A = np.arange(5 * 4).reshape(5, 4)\n    window_shape = 4, 3\n    B = view_as_windows(A, window_shape)\n    assert_equal(B.shape, (2, 2, 4, 3))\n    assert_equal(B, np.array([[[[0, 1, 2], [4, 5, 6], [8, 9, 10], [12, 13, \n        14]], [[1, 2, 3], [5, 6, 7], [9, 10, 11], [13, 14, 15]]], [[[4, 5, \n        6], [8, 9, 10], [12, 13, 14], [16, 17, 18]], [[5, 6, 7], [9, 10, 11\n        ], [13, 14, 15], [17, 18, 19]]]]))\n\ntest_view_as_windows_2D()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_with_skip():\n    A = np.arange(20).reshape((5, 4))\n    B = view_as_windows(A, 2, step=2)\n    assert_equal(B, [[[[0, 1], [4, 5]], [[2, 3], [6, 7]]], [[[8, 9], [12, \n        13]], [[10, 11], [14, 15]]]])\n    C = view_as_windows(A, 2, step=4)\n    assert_equal(C.shape, (1, 1, 2, 2))\n\ntest_view_as_windows_with_skip()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_views_non_contiguous():\n    A = np.arange(16).reshape((4, 4))\n    A = A[::2, :]\n    res_b = view_as_blocks(A, (2, 2))\n    res_w = view_as_windows(A, (2, 2))\n    print(res_b)\n    print(res_w)\n    expected_b = [[[[0, 1], [8, 9]], [[2, 3], [10, 11]]]]\n    expected_w = [[[[0, 1], [8, 9]], [[1, 2], [9, 10]], [[2, 3], [10, 11]]]]\n    assert_equal(res_b, expected_b)\n    assert_equal(res_w, expected_w)\n\ntest_views_non_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_step_tuple():\n    A = np.arange(24).reshape((6, 4))\n    B = view_as_windows(A, (3, 2), step=3)\n    assert B.shape == (2, 1, 3, 2)\n    assert B.size != A.size\n    C = view_as_windows(A, (3, 2), step=(3, 2))\n    assert C.shape == (2, 2, 3, 2)\n    assert C.size == A.size\n    assert_equal(C, [[[[0, 1], [4, 5], [8, 9]], [[2, 3], [6, 7], [10, 11]]],\n        [[[12, 13], [16, 17], [20, 21]], [[14, 15], [18, 19], [22, 23]]]])\n\ntest_view_as_windows_step_tuple()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}], "instruction": "Functionality: The view_as_windows function creates a rolling window view of an input n-dimensional array, allowing for the inspection of subarrays of a given shape that slide over the original array with a specified step size. Adjacent windows are shifted by a single dimension (row, column, or higher) according to the step parameter.\n\nInputs: \n1. arr_in: A numpy array of arbitrary shape (M[, ...]) that serves as the input array.\n2. window_shape: An integer or a tuple of length equal to the number of dimensions of arr_in, defining the shape of the n-dimensional orthotope (hyperrectangle) of the rolling window view. If an integer is given, it implies a hypercube shape.\n3. step: An integer or tuple of length equal to the number of dimensions of arr_in, indicating the step size at which extraction of windows shall be performed. If an integer is given, the step is uniform across all dimensions.\n\nOutputs: \n1. arr_out: A rolling window view of the input array, where each window is a subarray of arr_in with the specified shape and step size, forming an n-dimensional array that covers the input array in a sliding window fashion.\n\nNotes: Implementing the view_as_windows function involves careful consideration of memory usage, especially when dealing with large multidimensional arrays. The size of the resulting view can be significantly larger than the original array, especially when dealing with arrays of 2 or more dimensions.", "method_code_mask": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_windows(arr_in, window_shape, step=1): [MASK]\n"}
{"method_name": "unique_rows", "full_method_name": "unique_rows", "method_path": "../srcdata/Computation/scikit-image/skimage/util/unique.py", "method_code": "import numpy as np\ndef unique_rows(ar):\n    \"\"\"Remove repeated rows from a 2D array.\n\n    In particular, if given an array of coordinates of shape\n    (Npoints, Ndim), it will remove repeated points.\n\n    Parameters\n    ----------\n    ar : ndarray, shape (M, N)\n        The input array.\n\n    Returns\n    -------\n    ar_out : ndarray, shape (P, N)\n        A copy of the input array with repeated rows removed.\n\n    Raises\n    ------\n    ValueError : if `ar` is not two-dimensional.\n\n    Notes\n    -----\n    The function will generate a copy of `ar` if it is not\n    C-contiguous, which will negatively affect performance for large\n    input arrays.\n\n    Examples\n    --------\n    >>> ar = np.array([[1, 0, 1],\n    ...                [0, 1, 0],\n    ...                [1, 0, 1]], np.uint8)\n    >>> unique_rows(ar)\n    array([[0, 1, 0],\n           [1, 0, 1]], dtype=uint8)\n    \"\"\"\n    if ar.ndim != 2:\n        raise ValueError(\n            f'unique_rows() only makes sense for 2D arrays, got {ar.ndim}')\n    ar = np.ascontiguousarray(ar)\n    ar_row_view = ar.view(f'|S{ar.itemsize * ar.shape[1]}')\n    _, unique_row_indices = np.unique(ar_row_view, return_index=True)\n    ar_out = ar[unique_row_indices]\n    return ar_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_discontiguous_array():\n    ar = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]], np.uint8)\n    ar = ar[::2]\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[1, 0, 1]], np.uint8)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_discontiguous_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}, {"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_uint8_array():\n    ar = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]], np.uint8)\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[0, 1, 0], [1, 0, 1]], np.uint8)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_uint8_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}, {"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_float_array():\n    ar = np.array([[1.1, 0.0, 1.1], [0.0, 1.1, 0.0], [1.1, 0.0, 1.1]], float)\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[0.0, 1.1, 0.0], [1.1, 0.0, 1.1]], float)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_float_array()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}], "instruction": "Functionality: The unique_rows function removes repeated rows from a 2D array. It is particularly useful for removing repeated points from an array of coordinates. The function achieves this by creating a view of the array where each row is treated as a single, flat object, enabling the use of np.unique to identify and remove duplicates.\n\nInputs: \nar : ndarray, shape (M, N)\n    The input array. It should be a 2D array, and it is assumed to contain data of any type that can be compared for uniqueness, such as integers or floating-point numbers.\n\nOutputs: \nar_out : ndarray, shape (P, N)\n    A copy of the input array with repeated rows removed. The returned array will only contain the unique rows from the input.\n\nRaises:\nValueError\n    If the input array `ar` is not two-dimensional.\n\nNotes:\nThe function will generate a copy of `ar` if it is not C-contiguous, which may negatively affect performance for large input arrays. This is done to ensure that the view created for np.unique is valid and does not lead to unexpected behavior.\n\nExamples:\nGiven the array [[1, 0, 1], [0, 1, 0], [1, 0, 1]], the function will return [[0, 1, 0], [1, 0, 1]], as the first and third rows are duplicates and only the unique rows are kept.", "method_code_mask": "import numpy as np\n\n\ndef unique_rows(ar): [MASK]\n"}
{"method_name": "label_points", "full_method_name": "label_points", "method_path": "../srcdata/Computation/scikit-image/skimage/util/_label.py", "method_code": "import numpy as np\ndef label_points(coords, output_shape):\n    \"\"\"Assign unique integer labels to coordinates on an image mask\n\n    Parameters\n    ----------\n    coords: ndarray\n        An array of N coordinates with dimension D\n    output_shape: tuple\n        The shape of the mask on which `coords` are labelled\n\n    Returns\n    -------\n    labels: ndarray\n        A mask of zeroes containing unique integer labels at the `coords`\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.util._label import label_points\n    >>> coords = np.array([[0, 1], [2, 2]])\n    >>> output_shape = (5, 5)\n    >>> mask = label_points(coords, output_shape)\n    >>> mask\n    array([[0, 1, 0, 0, 0],\n           [0, 0, 0, 0, 0],\n           [0, 0, 2, 0, 0],\n           [0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0]], dtype=uint64)\n\n    Notes\n    -----\n    - The labels are assigned to coordinates that are converted to\n      integer and considered to start from 0.\n    - Coordinates that are out of range of the mask raise an IndexError.\n    - Negative coordinates raise a ValueError\n    \"\"\"\n    if coords.shape[1] != len(output_shape):\n        raise ValueError(\n            'Dimensionality of points should match the output shape')\n    if np.any(coords < 0):\n        raise ValueError('Coordinates should be positive and start from 0')\n    np_indices = tuple(np.transpose(np.round(coords).astype(int, copy=False)))\n    labels = np.zeros(output_shape, dtype=np.uint64)\n    labels[np_indices] = np.arange(1, coords.shape[0] + 1)\n    return labels", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_label_points_two_dimensional_output():\n    coords, output_shape = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n        ), (5, 5)\n    mask = label_points(coords, output_shape)\n    assert_equal(mask, np.array([[1, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 3,\n        0, 0], [0, 0, 0, 4, 0], [0, 0, 0, 0, 5]]))\n\ntest_label_points_two_dimensional_output()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_labels.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_label_points_multi_dimensional_output():\n    coords, output_shape = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3,\n        0], [4, 4, 1]]), (5, 5, 3)\n    mask = label_points(coords, output_shape)\n    result = np.array([[[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, \n        0]], [[0, 0, 0], [0, 2, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, \n        0, 0], [0, 0, 0], [0, 0, 3], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0,\n        0, 0], [0, 0, 0], [4, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0,\n        0, 0], [0, 0, 0], [0, 5, 0]]])\n    assert_equal(mask, result)\n\ntest_label_points_multi_dimensional_output()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/util/tests/test_labels.py"}], "instruction": "Functionality: The label_points function assigns unique integer labels to coordinates on an image mask. It takes an array of coordinates and the shape of the mask, then generates a mask filled with zeroes where the coordinates are labeled with unique integers starting from 1.\n\nInputs: \n- coords: An ndarray representing N coordinates with dimension D. Each coordinate should be a positive number (starting from 0) and should not exceed the dimensions of the output shape.\n- output_shape: A tuple representing the shape of the mask on which the `coords` will be labeled. The dimensionality of the points must match the dimensionality of the output shape.\n\nOutputs: \n- labels: An ndarray representing a mask of zeroes where unique integer labels are assigned at the positions of `coords`.\n\nNotes:\n- The function raises a ValueError if the dimensionality of the points does not match the output shape, or if any of the coordinates are negative.\n- An IndexError is raised when any of the coordinates are out of range of the mask.", "method_code_mask": "import numpy as np\n\n\ndef label_points(coords, output_shape): [MASK]\n"}
{"method_name": "label2rgb", "full_method_name": "label2rgb", "method_path": "../srcdata/Computation/scikit-image/skimage/color/colorlabel.py", "method_code": "import itertools\nimport numpy as np\ndef label2rgb(label, image=None, colors=None, alpha=0.3, bg_label=0,\n    bg_color=(0, 0, 0), image_alpha=1, kind='overlay', *, saturation=0,\n    channel_axis=-1):\n    \"\"\"Return an RGB image where color-coded labels are painted over the image.\n\n    Parameters\n    ----------\n    label : ndarray\n        Integer array of labels with the same shape as `image`.\n    image : ndarray, optional\n        Image used as underlay for labels. It should have the same shape as\n        `labels`, optionally with an additional RGB (channels) axis. If `image`\n        is an RGB image, it is converted to grayscale before coloring.\n    colors : list, optional\n        List of colors. If the number of labels exceeds the number of colors,\n        then the colors are cycled.\n    alpha : float [0, 1], optional\n        Opacity of colorized labels. Ignored if image is `None`.\n    bg_label : int, optional\n        Label that's treated as the background. If `bg_label` is specified,\n        `bg_color` is `None`, and `kind` is `overlay`,\n        background is not painted by any colors.\n    bg_color : str or array, optional\n        Background color. Must be a name in ``skimage.color.color_dict`` or RGB float\n        values between [0, 1].\n    image_alpha : float [0, 1], optional\n        Opacity of the image.\n    kind : string, one of {'overlay', 'avg'}\n        The kind of color image desired. 'overlay' cycles over defined colors\n        and overlays the colored labels over the original image. 'avg' replaces\n        each labeled segment with its average color, for a stained-class or\n        pastel painting appearance.\n    saturation : float [0, 1], optional\n        Parameter to control the saturation applied to the original image\n        between fully saturated (original RGB, `saturation=1`) and fully\n        unsaturated (grayscale, `saturation=0`). Only applies when\n        `kind='overlay'`.\n    channel_axis : int, optional\n        This parameter indicates which axis of the output array will correspond\n        to channels. If `image` is provided, this must also match the axis of\n        `image` that corresponds to channels.\n\n        .. versionadded:: 0.19\n            ``channel_axis`` was added in 0.19.\n\n    Returns\n    -------\n    result : ndarray of float, same shape as `image`\n        The result of blending a cycling colormap (`colors`) for each distinct\n        value in `label` with the image, at a certain alpha value.\n    \"\"\"\n    if image is not None:\n        image = np.moveaxis(image, source=channel_axis, destination=-1)\n    if kind == 'overlay':\n        rgb = _label2rgb_overlay(label, image, colors, alpha, bg_label,\n            bg_color, image_alpha, saturation)\n    elif kind == 'avg':\n        rgb = _label2rgb_avg(label, image, bg_label, bg_color)\n    else:\n        raise ValueError(\"`kind` must be either 'overlay' or 'avg'.\")\n    return np.moveaxis(rgb, source=-1, destination=channel_axis)", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_rgb():\n    image = np.ones((1, 3))\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=colors, alpha=1, image_alpha\n        =1, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_rgb()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_alpha():\n    image = np.random.uniform(size=(3, 3))\n    label = np.random.randint(0, 9, size=(3, 3))\n    rgb = label2rgb(label, image=image, alpha=0, image_alpha=1, bg_label=-1)\n    assert_array_almost_equal(rgb[..., 0], image)\n    assert_array_almost_equal(rgb[..., 1], image)\n    assert_array_almost_equal(rgb[..., 2], image)\n\ntest_alpha()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_no_input_image():\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, colors=colors, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_no_input_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_image_alpha():\n    image = np.random.uniform(size=(1, 3))\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=colors, alpha=1, image_alpha\n        =0, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_image_alpha()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_color_names():\n    image = np.ones((1, 3))\n    label = np.arange(3).reshape(1, -1)\n    cnames = ['red', 'lime', 'blue']\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=cnames, alpha=1, image_alpha\n        =1, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_color_names()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_bg_and_color_cycle():\n    image = np.zeros((1, 10))\n    label = np.arange(10).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 0, 1)]\n    bg_color = 0, 0, 0\n    rgb = label2rgb(label, image=image, bg_label=0, bg_color=bg_color,\n        colors=colors, alpha=1)\n    assert_array_almost_equal(rgb[0, 0], bg_color)\n    for pixel, color in zip(rgb[0, 1:], itertools.cycle(colors)):\n        assert_array_almost_equal(pixel, color)\n\ntest_bg_and_color_cycle()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_negative_labels():\n    labels = np.array([0, -1, -2, 0])\n    rout = np.array([(0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (\n        0.0, 0.0, 0.0)])\n    assert_array_almost_equal(rout, label2rgb(labels, bg_label=0, alpha=1,\n        image_alpha=1))\n\ntest_negative_labels()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_nonconsecutive():\n    labels = np.array([0, 2, 4, 0])\n    colors = [(1, 0, 0), (0, 0, 1)]\n    rout = np.array([(1.0, 0.0, 0.0), (0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (\n        1.0, 0.0, 0.0)])\n    assert_array_almost_equal(rout, label2rgb(labels, colors=colors, alpha=\n        1, image_alpha=1, bg_label=-1))\n\ntest_nonconsecutive()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_label_consistency():\n    \"\"\"Assert that the same labels map to the same colors.\"\"\"\n    label_1 = np.arange(5).reshape(1, -1)\n    label_2 = np.array([0, 1])\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 0), (1, 0, 1)]\n    rgb_1 = label2rgb(label_1, colors=colors, bg_label=-1)\n    rgb_2 = label2rgb(label_2, colors=colors, bg_label=-1)\n    for label_id in label_2.flat:\n        assert_array_almost_equal(rgb_1[label_1 == label_id], rgb_2[label_2 ==\n            label_id])\n\ntest_label_consistency()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_leave_labels_alone():\n    labels = np.array([-1, 0, 1])\n    labels_saved = labels.copy()\n    label2rgb(labels, bg_label=-1)\n    label2rgb(labels, bg_label=1)\n    assert_array_equal(labels, labels_saved)\n\ntest_leave_labels_alone()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_bg_color_rgb_string():\n    img = np.random.randint(0, 255, (10, 10), dtype=np.uint8)\n    labels = np.zeros((10, 10), dtype=np.int64)\n    labels[1:3, 1:3] = 1\n    labels[6:9, 6:9] = 2\n    output = label2rgb(labels, image=img, alpha=0.9, bg_label=0, bg_color='red'\n        )\n    assert output[0, 0, 0] > 0.9\n\ntest_bg_color_rgb_string()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}], "instruction": "Functionality: The label2rgb function is designed to colorize labeled regions in an image. It creates an RGB image where color-coded labels are painted over a provided image or as a standalone color map if no image is given. The function supports different modes for visualizing the labels, such as overlaying the colors on top of the original image or averaging the colors within each label to create a pastel effect.\n\nInputs: \n- label: An integer array of the same shape as the image, where each value represents a different label.\n- image: An optional image that serves as the underlay for the labels. It may have an additional RGB axis if it is colorized.\n- colors: An optional list of colors to use for the labels. If the number of labels exceeds the number of colors, the colors are cycled.\n- alpha: A float between 0 and 1 representing the opacity of the colorized labels (relevant if an image is provided).\n- bg_label: An integer label that is treated as the background.\n- bg_color: The color of the background, which can be a name from the skimage.color dictionary or RGB values.\n- image_alpha: A float between 0 and 1 representing the opacity of the image.\n- kind: A string specifying the kind of color image desired ('overlay' or 'avg').\n- saturation: A float between 0 and 1 to control the saturation of the original image.\n- channel_axis: An integer indicating the channel axis of the output image.\n\nOutputs:\n- result: An ndarray of floats with the same shape as the input image, showing the result of blending the label colors with the image at the specified alpha value. The output array's channel_axis will correspond to the channels.", "method_code_mask": "import itertools\nimport numpy as np\n\n\ndef label2rgb(label, image=None, colors=None, alpha=0.3, bg_label=0,\n    bg_color=(0, 0, 0), image_alpha=1, kind='overlay', *, saturation=0,\n    channel_axis=-1): [MASK]\n"}
{"method_name": "fetch", "full_method_name": "fetch", "method_path": "../srcdata/Computation/scikit-image/skimage/_shared/testing.py", "method_code": "import os\nimport platform\nimport re\nimport struct\nimport sys\nimport functools\nimport inspect\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nfrom numpy import testing\nfrom numpy.testing import TestCase\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_less\nimport pytest\nimport threading\ndef fetch(data_filename):\n    \"\"\"Attempt to fetch data, but if unavailable, skip the tests.\"\"\"\n    try:\n        return _fetch(data_filename)\n    except (ConnectionError, ModuleNotFoundError):\n        pytest.skip(f'Unable to download {data_filename}',\n            allow_module_level=True)", "test_code_list": [{"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_cells3d():\n    \"\"\"Needs internet connection.\"\"\"\n    path = fetch('data/cells3d.tif')\n    image = io.imread(path)\n    assert image.shape == (60, 2, 256, 256)\n\ntest_cells3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_brain_3d():\n    \"\"\"Needs internet connection.\"\"\"\n    path = fetch('data/brain.tiff')\n    image = io.imread(path)\n    assert image.shape == (10, 256, 256)\n\ntest_brain_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\n@pytest.mark.xfail(Version(np.__version__) >= Version('2.0.0.dev0'), reason\n    ='tifffile uses deprecated attribute `ndarray.newbyteorder`')\ndef test_kidney_3d_multichannel():\n    \"\"\"Test that 3D multichannel image of kidney tissue can be loaded.\n\n    Needs internet connection.\n    \"\"\"\n    fetch('data/kidney.tif')\n    kidney = data.kidney()\n    assert kidney.shape == (16, 512, 512, 3)\n\ntest_kidney_3d_multichannel()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\n@pytest.mark.xfail(Version(np.__version__) >= Version('2.0.0.dev0'), reason\n    ='tifffile uses deprecated attribute `ndarray.newbyteorder`')\ndef test_lily_multichannel():\n    \"\"\"Test that microscopy image of lily of the valley can be loaded.\n\n    Needs internet connection.\n    \"\"\"\n    fetch('data/lily.tif')\n    lily = data.lily()\n    assert lily.shape == (922, 922, 4)\n\ntest_lily_multichannel()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_vortex():\n    fetch('data/pivchallenge-B-B001_1.tif')\n    fetch('data/pivchallenge-B-B001_2.tif')\n    image0, image1 = data.vortex()\n    for image in [image0, image1]:\n        assert image.shape == (512, 512)\n\ntest_vortex()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage import io\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import use_plugin\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import TestCase\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imread_as_gray():\n    img = imread(fetch('data/color.png'), as_gray=True)\n    assert img.ndim == 2\n    assert img.dtype == np.float64\n    img = imread(fetch('data/camera.png'), as_gray=True)\n    assert np.dtype(img.dtype).char in np.typecodes['AllInteger']\n\ntest_imread_as_gray()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_imread.py"}, {"test_code": "import pathlib\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import reset_plugins\nfrom skimage.io import use_plugin\ndef test_imread_multipage_rgb_tif():\n    img = imread(fetch('data/multipage_rgb.tif'))\n    assert img.shape == (2, 10, 10, 3), img.shape\n\ntest_imread_multipage_rgb_tif()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_tifffile.py"}, {"test_code": "import pathlib\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import reset_plugins\nfrom skimage.io import use_plugin\ndef test_tifffile_kwarg_passthrough():\n    img = imread(fetch('data/multipage.tif'), key=[1], is_ome=True)\n    assert img.shape == (15, 10), img.shape\n\ntest_tifffile_kwarg_passthrough()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_tifffile.py"}, {"test_code": "import os\nimport itertools\nimport numpy as np\nimport imageio.v3 as iio3\nfrom skimage import data_dir\nfrom skimage.io.collection import ImageCollection\nfrom skimage.io.collection import MultiImage\nfrom skimage.io.collection import alphanumeric_key\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imagecollection_input():\n    \"\"\"Test function for ImageCollection. The new behavior (implemented\n    in 0.16) allows the `pattern` argument to accept a list of strings\n    as the input.\n\n    Notes\n    -----\n        If correct, `images` will receive three images.\n    \"\"\"\n    pics = [fetch('data/coffee.png'), fetch('data/chessboard_GRAY.png'),\n        fetch('data/rocket.jpg')]\n    pattern = [os.path.join(data_dir, pic) for pic in pics]\n    images = ImageCollection(pattern)\n    assert len(images) == 3\n\ntest_imagecollection_input()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_collection.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import plugin_order\nfrom skimage._shared import testing\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imageio_as_gray():\n    img = imread(fetch('data/color.png'), as_gray=True)\n    assert img.ndim == 2\n    assert img.dtype == np.float64\n    img = imread(fetch('data/camera.png'), as_gray=True)\n    assert np.dtype(img.dtype).char in np.typecodes['AllInteger']\n\ntest_imageio_as_gray()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_imageio.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import plugin_order\nfrom skimage._shared import testing\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_return_class():\n    testing.assert_equal(type(imread(fetch('data/color.png'))), np.ndarray)\n\ntest_return_class()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_imageio.py"}, {"test_code": "import os\nimport pathlib\nimport tempfile\nimport numpy as np\nimport pytest\nfrom skimage import io\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.data import data_dir\ndef test_imread_file_url():\n    data_path = str(fetch('data/camera.png'))\n    data_path = data_path.replace(os.path.sep, '/')\n    image_url = f'file:///{data_path}'\n    image = io.imread(image_url)\n    assert image.shape == (512, 512)\n\ntest_imread_file_url()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_io.py"}, {"test_code": "import os\nimport pathlib\nimport tempfile\nimport numpy as np\nimport pytest\nfrom skimage import io\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.data import data_dir\ndef test_imread_pathlib_tiff():\n    \"\"\"Tests reading from Path object (issue gh-5545).\"\"\"\n    fname = fetch('data/multipage.tif')\n    expected = io.imread(fname)\n    path = pathlib.Path(fname)\n    img = io.imread(path)\n    assert img.shape == (2, 15, 10)\n    assert_array_equal(expected, img)\n\ntest_imread_pathlib_tiff()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_io.py"}], "instruction": "Functionality: The fetch function is designed to retrieve specific data files that are necessary for testing purposes. It attempts to fetch the data from a predefined location. If the data is unavailable\u2014either due to a connection error or if the required module is not found\u2014the function will trigger a test skip, ensuring that tests reliant on this data do not fail ungracefully but are skipped gracefully with a clear message.\n\nInputs: \n- data_filename: A string representing the name of the file to be fetched. This filename should be the exact name of the file that the function will attempt to retrieve from the source.\n\nOutputs: \n- The function returns the data fetched from the specified source. However, in the event of failure, due to a ConnectionError or a missing required module (ModuleNotFoundError), the function does not return any data; instead, it causes pytest to skip the tests that require this data, preventing test failures and providing a clear reason for skipping the test in the form of a message.", "method_code_mask": "import os\nimport platform\nimport re\nimport struct\nimport sys\nimport functools\nimport inspect\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nfrom numpy import testing\nfrom numpy.testing import TestCase\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_less\nimport pytest\nimport threading\n\n\ndef fetch(data_filename): [MASK]\n"}
{"method_name": "deltaE_cmc", "full_method_name": "deltaE_cmc", "method_path": "../srcdata/Computation/scikit-image/skimage/color/delta_e.py", "method_code": "import numpy as np\ndef deltaE_cmc(lab1, lab2, kL=1, kC=1, *, channel_axis=-1):\n    \"\"\"Color difference from the  CMC l:c standard.\n\n    This color difference was developed by the Colour Measurement Committee\n    (CMC) of the Society of Dyers and Colourists (United Kingdom). It is\n    intended for use in the textile industry.\n\n    The scale factors `kL`, `kC` set the weight given to differences in\n    lightness and chroma relative to differences in hue.  The usual values are\n    ``kL=2``, ``kC=1`` for \"acceptability\" and ``kL=1``, ``kC=1`` for\n    \"imperceptibility\".  Colors with ``dE > 1`` are \"different\" for the given\n    scale factors.\n\n    Parameters\n    ----------\n    lab1 : array_like\n        reference color (Lab colorspace)\n    lab2 : array_like\n        comparison color (Lab colorspace)\n    channel_axis : int, optional\n        This parameter indicates which axis of the arrays corresponds to\n        channels.\n\n        .. versionadded:: 0.19\n           ``channel_axis`` was added in 0.19.\n\n    Returns\n    -------\n    dE : array_like\n        distance between colors `lab1` and `lab2`\n\n    Notes\n    -----\n    deltaE_cmc the defines the scales for the lightness, hue, and chroma\n    in terms of the first color.  Consequently\n    ``deltaE_cmc(lab1, lab2) != deltaE_cmc(lab2, lab1)``\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Color_difference\n    .. [2] http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html\n    .. [3] F. J. J. Clarke, R. McDonald, and B. Rigg, \"Modification to the\n           JPC79 colour-difference formula,\" J. Soc. Dyers Colour. 100, 128-132\n           (1984).\n    \"\"\"\n    lab1, lab2 = _float_inputs(lab1, lab2, allow_float32=True)\n    lab1 = np.moveaxis(lab1, source=channel_axis, destination=0)\n    lab2 = np.moveaxis(lab2, source=channel_axis, destination=0)\n    L1, C1, h1 = lab2lch(lab1, channel_axis=0)[:3]\n    L2, C2, h2 = lab2lch(lab2, channel_axis=0)[:3]\n    dC = C1 - C2\n    dL = L1 - L2\n    dH2 = get_dH2(lab1, lab2, channel_axis=0)\n    T = np.where(np.logical_and(np.rad2deg(h1) >= 164, np.rad2deg(h1) <= \n        345), 0.56 + 0.2 * np.abs(np.cos(h1 + np.deg2rad(168))), 0.36 + 0.4 *\n        np.abs(np.cos(h1 + np.deg2rad(35))))\n    c1_4 = C1 ** 4\n    F = np.sqrt(c1_4 / (c1_4 + 1900))\n    SL = np.where(L1 < 16, 0.511, 0.040975 * L1 / (1.0 + 0.01765 * L1))\n    SC = 0.638 + 0.0638 * C1 / (1.0 + 0.0131 * C1)\n    SH = SC * (F * T + 1 - F)\n    dE2 = (dL / (kL * SL)) ** 2\n    dE2 += (dC / (kC * SC)) ** 2\n    dE2 += dH2 / SH ** 2\n    return np.sqrt(np.maximum(dE2, 0))", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.color.delta_e import deltaE_cie76\nfrom skimage.color.delta_e import deltaE_ciede94\nfrom skimage.color.delta_e import deltaE_ciede2000\nfrom skimage.color.delta_e import deltaE_cmc\ndef test_cmc_single_item():\n    lab1 = lab2 = np.array([0.0, 1.59607713, 0.87755709])\n    assert_equal(deltaE_cmc(lab1, lab2), 0)\n    lab2[0] += np.finfo(float).eps\n    assert_equal(deltaE_cmc(lab1, lab2), 0)\n\ntest_cmc_single_item()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/color/tests/test_delta_e.py"}], "instruction": "Functionality: The deltaE_cmc function calculates the color difference between two colors in the Lab color space based on the CMC (l:c) color difference formula. This formula was developed for use in the textile industry by the Colour Measurement Committee of the Society of Dyers and Colourists. It quantifies color differences considering lightness, chroma, and hue, with scale factors 'kL' and 'kC' to weight the relative importance of lightness and chroma differences.\n\nInputs:\n- lab1: array_like\n    reference color in the Lab colorspace.\n- lab2: array_like\n    comparison color in the Lab colorspace.\n- kL: float, optional (default: 1)\n    scale factor for lightness differences. Typical values are 1 or 2.\n- kC: float, optional (default: 1)\n    scale factor for chroma differences. Typical values are 1 or 2.\n- channel_axis: int, optional (default: -1)\n    The axis of the arrays representing color channels. This parameter was introduced in version 0.19.\n\nOutputs:\n- dE: array_like\n    distance between the two colors 'lab1' and 'lab2', indicating how different they are. A value greater than 1 typically signifies that the colors are perceptibly different for the given scale factors.", "method_code_mask": "import numpy as np\n\n\ndef deltaE_cmc(lab1, lab2, kL=1, kC=1, *, channel_axis=-1): [MASK]\n"}
{"method_name": "h_maxima", "full_method_name": "h_maxima", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "method_code": "import numpy as np\ndef h_maxima(image, h, footprint=None):\n    \"\"\"Determine all maxima of the image with height >= h.\n\n    The local maxima are defined as connected sets of pixels with equal\n    gray level strictly greater than the gray level of all pixels in direct\n    neighborhood of the set.\n\n    A local maximum M of height h is a local maximum for which\n    there is at least one path joining M with an equal or higher local maximum\n    on which the minimal value is f(M) - h (i.e. the values along the path\n    are not decreasing by more than h with respect to the maximum's value)\n    and no path to an equal or higher local maximum for which the minimal\n    value is greater.\n\n    The global maxima of the image are also found by this function.\n\n    Parameters\n    ----------\n    image : ndarray\n        The input image for which the maxima are to be calculated.\n    h : unsigned integer\n        The minimal height of all extracted maxima.\n    footprint : ndarray, optional\n        The neighborhood expressed as an n-D array of 1's and 0's.\n        Default is the ball of radius 1 according to the maximum norm\n        (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)\n\n    Returns\n    -------\n    h_max : ndarray\n        The local maxima of height >= h and the global maxima.\n        The resulting image is a binary image, where pixels belonging to\n        the determined maxima take value 1, the others take value 0.\n\n    See Also\n    --------\n    skimage.morphology.h_minima\n    skimage.morphology.local_maxima\n    skimage.morphology.local_minima\n\n    References\n    ----------\n    .. [1] Soille, P., \"Morphological Image Analysis: Principles and\n           Applications\" (Chapter 6), 2nd edition (2003), ISBN 3540429883.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.morphology import extrema\n\n    We create an image (quadratic function with a maximum in the center and\n    4 additional constant maxima.\n    The heights of the maxima are: 1, 21, 41, 61, 81\n\n    >>> w = 10\n    >>> x, y = np.mgrid[0:w,0:w]\n    >>> f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)\n    >>> f[2:4,2:4] = 40; f[2:4,7:9] = 60; f[7:9,2:4] = 80; f[7:9,7:9] = 100\n    >>> f = f.astype(int)\n\n    We can calculate all maxima with a height of at least 40:\n\n    >>> maxima = extrema.h_maxima(f, 40)\n\n    The resulting image will contain 3 local maxima.\n    \"\"\"\n    if h > np.ptp(image):\n        return np.zeros(image.shape, dtype=np.uint8)\n    if np.issubdtype(type(h), np.floating) and np.issubdtype(image.dtype,\n        np.integer):\n        if h % 1 != 0:\n            warn(\n                'possible precision loss converting image to floating point. To silence this warning, ensure image and h have same data type.'\n                , stacklevel=2)\n            image = image.astype(float)\n        else:\n            h = image.dtype.type(h)\n    if h == 0:\n        raise ValueError('h = 0 is ambiguous, use local_maxima() instead?')\n    if np.issubdtype(image.dtype, np.floating):\n        resolution = 2 * np.finfo(image.dtype).resolution * np.abs(image)\n        shifted_img = image - h - resolution\n    else:\n        shifted_img = _subtract_constant_clip(image, h)\n    rec_img = grayreconstruct.reconstruction(shifted_img, image, method=\n        'dilation', footprint=footprint)\n    residue_img = image - rec_img\n    return (residue_img >= h).astype(np.uint8)", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestExtrema():\n\tdef test_h_maxima_large_h(self):\n\t    \"\"\"test that h-maxima works correctly for large h\"\"\"\n\t    data = np.array([[10, 10, 10, 10, 10], [10, 13, 13, 13, 10], [10, 13, \n\t        14, 13, 10], [10, 13, 13, 13, 10], [10, 10, 10, 10, 10]], dtype=np.\n\t        uint8)\n\t    maxima = h_maxima(data, 5)\n\t    assert np.sum(maxima) == 0\n\t    data = np.array([[10, 10, 10, 10, 10], [10, 13, 13, 13, 10], [10, 13, \n\t        14, 13, 10], [10, 13, 13, 13, 10], [10, 10, 10, 10, 10]], dtype=np.\n\t        float32)\n\t    maxima = h_maxima(data, 5.0)\n\t    assert np.sum(maxima) == 0\n\t\nTestExtrema().test_h_maxima_large_h()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "instruction": "Functionality: The h_maxima function determines all maxima of the input image with a height greater than or equal to a specified threshold 'h'. The function identifies connected sets of pixels with equal gray levels that are strictly greater than the gray levels of all pixels in their direct neighborhood. A local maximum is one for which there is at least one path to an equal or higher maximum where the minimal value difference is 'h' or less. The global maxima are also identified by this function.\n\nInputs: \n1. image: An ndarray representing the input image for which the maxima are to be calculated.\n2. h: An unsigned integer representing the minimal height of all extracted maxima.\n3. footprint: An optional n-D array of 1's and 0's defining the neighborhood. Default is the ball of radius 1 according to the maximum norm.\n\nOutputs:\n1. h_max: An ndarray representing the binary image of local maxima with height >= h and global maxima. Pixels belonging to the determined maxima take value 1, and the others take value 0.", "method_code_mask": "import numpy as np\n\n\ndef h_maxima(image, h, footprint=None): [MASK]\n"}
{"method_name": "h_minima", "full_method_name": "h_minima", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "method_code": "import numpy as np\ndef h_minima(image, h, footprint=None):\n    \"\"\"Determine all minima of the image with depth >= h.\n\n    The local minima are defined as connected sets of pixels with equal\n    gray level strictly smaller than the gray levels of all pixels in direct\n    neighborhood of the set.\n\n    A local minimum M of depth h is a local minimum for which\n    there is at least one path joining M with an equal or lower local minimum\n    on which the maximal value is f(M) + h (i.e. the values along the path\n    are not increasing by more than h with respect to the minimum's value)\n    and no path to an equal or lower local minimum for which the maximal\n    value is smaller.\n\n    The global minima of the image are also found by this function.\n\n    Parameters\n    ----------\n    image : ndarray\n        The input image for which the minima are to be calculated.\n    h : unsigned integer\n        The minimal depth of all extracted minima.\n    footprint : ndarray, optional\n        The neighborhood expressed as an n-D array of 1's and 0's.\n        Default is the ball of radius 1 according to the maximum norm\n        (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)\n\n    Returns\n    -------\n    h_min : ndarray\n        The local minima of depth >= h and the global minima.\n        The resulting image is a binary image, where pixels belonging to\n        the determined minima take value 1, the others take value 0.\n\n    See Also\n    --------\n    skimage.morphology.h_maxima\n    skimage.morphology.local_maxima\n    skimage.morphology.local_minima\n\n    References\n    ----------\n    .. [1] Soille, P., \"Morphological Image Analysis: Principles and\n           Applications\" (Chapter 6), 2nd edition (2003), ISBN 3540429883.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.morphology import extrema\n\n    We create an image (quadratic function with a minimum in the center and\n    4 additional constant maxima.\n    The depth of the minima are: 1, 21, 41, 61, 81\n\n    >>> w = 10\n    >>> x, y = np.mgrid[0:w,0:w]\n    >>> f = 180 + 0.2*((x - w/2)**2 + (y-w/2)**2)\n    >>> f[2:4,2:4] = 160; f[2:4,7:9] = 140; f[7:9,2:4] = 120; f[7:9,7:9] = 100\n    >>> f = f.astype(int)\n\n    We can calculate all minima with a depth of at least 40:\n\n    >>> minima = extrema.h_minima(f, 40)\n\n    The resulting image will contain 3 local minima.\n    \"\"\"\n    if h > np.ptp(image):\n        return np.zeros(image.shape, dtype=np.uint8)\n    if np.issubdtype(type(h), np.floating) and np.issubdtype(image.dtype,\n        np.integer):\n        if h % 1 != 0:\n            warn(\n                'possible precision loss converting image to floating point. To silence this warning, ensure image and h have same data type.'\n                , stacklevel=2)\n            image = image.astype(float)\n        else:\n            h = image.dtype.type(h)\n    if h == 0:\n        raise ValueError('h = 0 is ambiguous, use local_minima() instead?')\n    if np.issubdtype(image.dtype, np.floating):\n        resolution = 2 * np.finfo(image.dtype).resolution * np.abs(image)\n        shifted_img = image + h + resolution\n    else:\n        shifted_img = _add_constant_clip(image, h)\n    rec_img = grayreconstruct.reconstruction(shifted_img, image, method=\n        'erosion', footprint=footprint)\n    residue_img = rec_img - image\n    return (residue_img >= h).astype(np.uint8)", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestExtrema():\n\tdef test_h_minima_large_h(self):\n\t    \"\"\"test that h-minima works correctly for large h\"\"\"\n\t    data = np.array([[14, 14, 14, 14, 14], [14, 11, 11, 11, 14], [14, 11, \n\t        10, 11, 14], [14, 11, 11, 11, 14], [14, 14, 14, 14, 14]], dtype=np.\n\t        uint8)\n\t    maxima = h_minima(data, 5)\n\t    assert np.sum(maxima) == 0\n\t    data = np.array([[14, 14, 14, 14, 14], [14, 11, 11, 11, 14], [14, 11, \n\t        10, 11, 14], [14, 11, 11, 11, 14], [14, 14, 14, 14, 14]], dtype=np.\n\t        float32)\n\t    maxima = h_minima(data, 5.0)\n\t    assert np.sum(maxima) == 0\n\t\nTestExtrema().test_h_minima_large_h()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "instruction": "Functionality: The h_minima function is designed to identify all minima within an image that have a depth greater than or equal to a specified value 'h'. It is particularly useful for extracting features in images where the contrast or depth of the minima is of interest.\n\nInputs:\n- image: An n-dimensional array representing the grayscale input image. Each pixel value signifies the intensity at that location.\n- h: An unsigned integer that represents the minimum depth of the minima to be detected. Minima shallower than 'h' will not be included in the result.\n- footprint: An optional n-dimensional array consisting of 1's and 0's that defines the neighborhood for determining the minima. If not provided, a default ball-shaped footprint with a radius of 1 is used, based on the maximum norm.\n\nOutputs:\n- h_min: A binary n-dimensional array where pixels corresponding to local minima with a depth greater than or equal to 'h', including global minima, are marked as 1. All other pixels are set to 0.\n\nThis function can be applied to various fields, such as image processing, to segment and analyze features that have a specific contrast or depth with respect to their surroundings.", "method_code_mask": "import numpy as np\n\n\ndef h_minima(image, h, footprint=None): [MASK]\n"}
{"method_name": "local_maxima", "full_method_name": "local_maxima", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "method_code": "import numpy as np\ndef local_maxima(image, footprint=None, connectivity=None, indices=False,\n    allow_borders=True):\n    \"\"\"Find local maxima of n-dimensional array.\n\n    The local maxima are defined as connected sets of pixels with equal gray\n    level (plateaus) strictly greater than the gray levels of all pixels in the\n    neighborhood.\n\n    Parameters\n    ----------\n    image : ndarray\n        An n-dimensional array.\n    footprint : ndarray, optional\n        The footprint (structuring element) used to determine the neighborhood\n        of each evaluated pixel (``True`` denotes a connected pixel). It must\n        be a boolean array and have the same number of dimensions as `image`.\n        If neither `footprint` nor `connectivity` are given, all adjacent\n        pixels are considered as part of the neighborhood.\n    connectivity : int, optional\n        A number used to determine the neighborhood of each evaluated pixel.\n        Adjacent pixels whose squared distance from the center is less than or\n        equal to `connectivity` are considered neighbors. Ignored if\n        `footprint` is not None.\n    indices : bool, optional\n        If True, the output will be a tuple of one-dimensional arrays\n        representing the indices of local maxima in each dimension. If False,\n        the output will be a boolean array with the same shape as `image`.\n    allow_borders : bool, optional\n        If true, plateaus that touch the image border are valid maxima.\n\n    Returns\n    -------\n    maxima : ndarray or tuple[ndarray]\n        If `indices` is false, a boolean array with the same shape as `image`\n        is returned with ``True`` indicating the position of local maxima\n        (``False`` otherwise). If `indices` is true, a tuple of one-dimensional\n        arrays containing the coordinates (indices) of all found maxima.\n\n    Warns\n    -----\n    UserWarning\n        If `allow_borders` is false and any dimension of the given `image` is\n        shorter than 3 samples, maxima can't exist and a warning is shown.\n\n    See Also\n    --------\n    skimage.morphology.local_minima\n    skimage.morphology.h_maxima\n    skimage.morphology.h_minima\n\n    Notes\n    -----\n    This function operates on the following ideas:\n\n    1. Make a first pass over the image's last dimension and flag candidates\n       for local maxima by comparing pixels in only one direction.\n       If the pixels aren't connected in the last dimension all pixels are\n       flagged as candidates instead.\n\n    For each candidate:\n\n    2. Perform a flood-fill to find all connected pixels that have the same\n       gray value and are part of the plateau.\n    3. Consider the connected neighborhood of a plateau: if no bordering sample\n       has a higher gray level, mark the plateau as a definite local maximum.\n\n    Examples\n    --------\n    >>> from skimage.morphology import local_maxima\n    >>> image = np.zeros((4, 7), dtype=int)\n    >>> image[1:3, 1:3] = 1\n    >>> image[3, 0] = 1\n    >>> image[1:3, 4:6] = 2\n    >>> image[3, 6] = 3\n    >>> image\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [1, 0, 0, 0, 0, 0, 3]])\n\n    Find local maxima by comparing to all neighboring pixels (maximal\n    connectivity):\n\n    >>> local_maxima(image)\n    array([[False, False, False, False, False, False, False],\n           [False,  True,  True, False, False, False, False],\n           [False,  True,  True, False, False, False, False],\n           [ True, False, False, False, False, False,  True]])\n    >>> local_maxima(image, indices=True)\n    (array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))\n\n    Find local maxima without comparing to diagonal pixels (connectivity 1):\n\n    >>> local_maxima(image, connectivity=1)\n    array([[False, False, False, False, False, False, False],\n           [False,  True,  True, False,  True,  True, False],\n           [False,  True,  True, False,  True,  True, False],\n           [ True, False, False, False, False, False,  True]])\n\n    and exclude maxima that border the image edge:\n\n    >>> local_maxima(image, connectivity=1, allow_borders=False)\n    array([[False, False, False, False, False, False, False],\n           [False,  True,  True, False,  True,  True, False],\n           [False,  True,  True, False,  True,  True, False],\n           [False, False, False, False, False, False, False]])\n    \"\"\"\n    image = np.asarray(image, order='C')\n    if image.size == 0:\n        if indices:\n            return np.nonzero(image)\n        else:\n            return np.zeros(image.shape, dtype=bool)\n    if allow_borders:\n        image = np.pad(image, 1, mode='constant', constant_values=image.min())\n    flags = np.zeros(image.shape, dtype=np.uint8)\n    _util._set_border_values(flags, value=3)\n    if any(s < 3 for s in image.shape):\n        warn(\n            \"maxima can't exist for an image with any dimension smaller 3 if borders aren't allowed\"\n            , stacklevel=3)\n    else:\n        footprint = _util._resolve_neighborhood(footprint, connectivity,\n            image.ndim)\n        neighbor_offsets = _util._offsets_to_raveled_neighbors(image.shape,\n            footprint, center=(1,) * image.ndim)\n        try:\n            _local_maxima(image.ravel(), flags.ravel(), neighbor_offsets)\n        except TypeError:\n            if image.dtype == np.float16:\n                raise TypeError(\n                    'dtype of `image` is float16 which is not supported, try upcasting to float32'\n                    )\n            else:\n                raise\n    if allow_borders:\n        flags = crop(flags, 1)\n    else:\n        _util._set_border_values(flags, value=0)\n    if indices:\n        return np.nonzero(flags)\n    else:\n        return flags.view(bool)", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestLocalMaxima(unittest.TestCase):\n\tdef test_empty(self):\n\t    \"\"\"Test result with empty image.\"\"\"\n\t    result = local_maxima(np.array([[]]), indices=False)\n\t    assert result.size == 0\n\t    assert result.dtype == bool\n\t    assert result.shape == (1, 0)\n\t    result = local_maxima(np.array([]), indices=True)\n\t    assert isinstance(result, tuple)\n\t    assert len(result) == 1\n\t    assert result[0].size == 0\n\t    assert result[0].dtype == np.intp\n\t    result = local_maxima(np.array([[]]), indices=True)\n\t    assert isinstance(result, tuple)\n\t    assert len(result) == 2\n\t    assert result[0].size == 0\n\t    assert result[0].dtype == np.intp\n\t    assert result[1].size == 0\n\t    assert result[1].dtype == np.intp\n\t\nTestLocalMaxima().test_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "instruction": "Functionality: Finds local maxima of an n-dimensional array. Local maxima are defined as connected sets of pixels with equal gray level (plateaus) strictly greater than the gray levels of all pixels in the neighborhood.\n\nInputs:\n- image: An n-dimensional array.\n- footprint: Optional, a boolean array and structuring element that determines the neighborhood of each evaluated pixel. Must have the same number of dimensions as `image`.\n- connectivity: Optional, an integer that determines the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is less than or equal to `connectivity` are considered neighbors.\n- indices: Optional, a boolean that determines the format of the output. If true, the output will be a tuple of one-dimensional arrays containing the coordinates of all found maxima. If false, the output will be a boolean array.\n- allow_borders: Optional, a boolean that determines if plateaus that touch the image border are considered valid maxima.\n\nOutputs:\n- maxima: If `indices` is false, returns a boolean array with the same shape as `image` where ``True`` indicates the position of local maxima. If `indices` is true, returns a tuple of one-dimensional arrays containing the coordinates (indices) of all found maxima.", "method_code_mask": "import numpy as np\n\n\ndef local_maxima(image, footprint=None, connectivity=None, indices=False,\n    allow_borders=True): [MASK]\n"}
{"method_name": "convex_hull_image", "full_method_name": "convex_hull_image", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/convex_hull.py", "method_code": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\ndef convex_hull_image(image, offset_coordinates=True, tolerance=1e-10,\n    include_borders=True):\n    \"\"\"Compute the convex hull image of a binary image.\n\n    The convex hull is the set of pixels included in the smallest convex\n    polygon that surround all white pixels in the input image.\n\n    Parameters\n    ----------\n    image : array\n        Binary input image. This array is cast to bool before processing.\n    offset_coordinates : bool, optional\n        If ``True``, a pixel at coordinate, e.g., (4, 7) will be represented\n        by coordinates (3.5, 7), (4.5, 7), (4, 6.5), and (4, 7.5). This adds\n        some \"extent\" to a pixel when computing the hull.\n    tolerance : float, optional\n        Tolerance when determining whether a point is inside the hull. Due\n        to numerical floating point errors, a tolerance of 0 can result in\n        some points erroneously being classified as being outside the hull.\n    include_borders: bool, optional\n        If ``False``, vertices/edges are excluded from the final hull mask.\n\n    Returns\n    -------\n    hull : (M, N) array of bool\n        Binary image with pixels in convex hull set to True.\n\n    References\n    ----------\n    .. [1] https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/\n\n    \"\"\"\n    ndim = image.ndim\n    if np.count_nonzero(image) == 0:\n        warn(\n            'Input image is entirely zero, no valid convex hull. Returning empty image'\n            , UserWarning)\n        return np.zeros(image.shape, dtype=bool)\n    if ndim == 2:\n        coords = possible_hull(np.ascontiguousarray(image, dtype=np.uint8))\n    else:\n        coords = np.transpose(np.nonzero(image))\n        if offset_coordinates:\n            try:\n                hull0 = ConvexHull(coords)\n            except QhullError as err:\n                warn(\n                    f\"\"\"Failed to get convex hull image. Returning empty image, see error message below:\n{err}\"\"\"\n                    )\n                return np.zeros(image.shape, dtype=bool)\n            coords = hull0.points[hull0.vertices]\n    if offset_coordinates:\n        offsets = _offsets_diamond(image.ndim)\n        coords = (coords[:, np.newaxis, :] + offsets).reshape(-1, ndim)\n    coords = unique_rows(coords)\n    try:\n        hull = ConvexHull(coords)\n    except QhullError as err:\n        warn(\n            f\"\"\"Failed to get convex hull image. Returning empty image, see error message below:\n{err}\"\"\"\n            )\n        return np.zeros(image.shape, dtype=bool)\n    vertices = hull.points[hull.vertices]\n    if ndim == 2:\n        labels = grid_points_in_poly(image.shape, vertices, binarize=False)\n        mask = labels >= 1 if include_borders else labels == 1\n    else:\n        gridcoords = np.reshape(np.mgrid[tuple(map(slice, image.shape))], (\n            ndim, -1))\n        coords_in_hull = _check_coords_in_hull(gridcoords, hull.equations,\n            tolerance)\n        mask = np.reshape(coords_in_hull, image.shape)\n    return mask", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_basic():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0,\n        0], [0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1,\n        0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0,\n        0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0], [0,\n        1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_empty_image():\n    image = np.zeros((6, 6), dtype=bool)\n    with expected_warnings(['entirely zero']):\n        assert_array_equal(convex_hull_image(image), image)\n\ntest_empty_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_qhull_offset_example():\n    nonzeros = [1367, 1368, 1368, 1368, 1369, 1369, 1369, 1369, 1369, 1370,\n        1370, 1370, 1370, 1370, 1370, 1370, 1371, 1371, 1371, 1371, 1371, \n        1371, 1371, 1371, 1371, 1372, 1372, 1372, 1372, 1372, 1372, 1372, \n        1372, 1372, 1373, 1373, 1373, 1373, 1373, 1373, 1373, 1373, 1373, \n        1374, 1374, 1374, 1374, 1374, 1374, 1374, 1375, 1375, 1375, 1375, \n        1375, 1376, 1376, 1376, 1377, 1372], [151, 150, 151, 152, 149, 150,\n        151, 152, 153, 148, 149, 150, 151, 152, 153, 154, 147, 148, 149, \n        150, 151, 152, 153, 154, 155, 146, 147, 148, 149, 150, 151, 152, \n        153, 154, 146, 147, 148, 149, 150, 151, 152, 153, 154, 147, 148, \n        149, 150, 151, 152, 153, 148, 149, 150, 151, 152, 149, 150, 151, \n        150, 155]\n    image = np.zeros((1392, 1040), dtype=bool)\n    image[nonzeros] = True\n    expected = image.copy()\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_qhull_offset_example()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_pathological_qhull_example():\n    image = np.array([[0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1], [1, 1, \n        1, 0, 0, 0, 0]], dtype=bool)\n    expected = np.array([[0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1], [1, \n        1, 1, 1, 1, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_pathological_qhull_example()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_non_c_contiguous():\n    image = np.ones((2, 2), order='F', dtype=bool)\n    assert_array_equal(convex_hull_image(image), image)\n    image = np.ones((2, 2, 2), order='F', dtype=bool)\n    assert_array_equal(convex_hull_image(image), image)\n    image = np.transpose(np.ones((2, 2, 2), dtype=bool), [0, 2, 1])\n    assert_array_equal(convex_hull_image(image), image)\n\ntest_non_c_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}], "instruction": "Functionality: Compute the convex hull image of a given binary image.\nInputs: \n    image: Binary input image. This array is cast to bool before processing.\n    offset_coordinates: Optional boolean indicating if the pixel coordinates should be offset.\n    tolerance: Optional float specifying the tolerance for determining if a point is inside the hull.\n    include_borders: Optional boolean indicating if the vertices/edges should be included in the final hull mask.\n\nOutputs: \n    hull: (M, N) array of bool representing the binary image with pixels in the convex hull set to True.", "method_code_mask": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\n\ndef convex_hull_image(image, offset_coordinates=True, tolerance=1e-10,\n    include_borders=True): [MASK]\n"}
{"method_name": "convex_hull_object", "full_method_name": "convex_hull_object", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/convex_hull.py", "method_code": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\ndef convex_hull_object(image, *, connectivity=2):\n    \"\"\"Compute the convex hull image of individual objects in a binary image.\n\n    The convex hull is the set of pixels included in the smallest convex\n    polygon that surround all white pixels in the input image.\n\n    Parameters\n    ----------\n    image : (M, N) ndarray\n        Binary input image.\n    connectivity : {1, 2}, int, optional\n        Determines the neighbors of each pixel. Adjacent elements\n        within a squared distance of ``connectivity`` from pixel center\n        are considered neighbors.::\n\n            1-connectivity      2-connectivity\n                  [ ]           [ ]  [ ]  [ ]\n                   |               \\\\  |  /\n             [ ]--[x]--[ ]      [ ]--[x]--[ ]\n                   |               /  |  \\\\\n                  [ ]           [ ]  [ ]  [ ]\n\n    Returns\n    -------\n    hull : ndarray of bool\n        Binary image with pixels inside convex hull set to ``True``.\n\n    Notes\n    -----\n    This function uses ``skimage.morphology.label`` to define unique objects,\n    finds the convex hull of each using ``convex_hull_image``, and combines\n    these regions with logical OR. Be aware the convex hulls of unconnected\n    objects may overlap in the result. If this is suspected, consider using\n    convex_hull_image separately on each object or adjust ``connectivity``.\n    \"\"\"\n    if image.ndim > 2:\n        raise ValueError('Input must be a 2D image')\n    if connectivity not in (1, 2):\n        raise ValueError('`connectivity` must be either 1 or 2.')\n    labeled_im = label(image, connectivity=connectivity, background=0)\n    convex_obj = np.zeros(image.shape, dtype=bool)\n    convex_img = np.zeros(image.shape, dtype=bool)\n    for i in range(1, labeled_im.max() + 1):\n        convex_obj = convex_hull_image(labeled_im == i)\n        convex_img = np.logical_or(convex_img, convex_obj)\n    return convex_img", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_object():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0,\n        0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1,\n        1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, \n        0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n        0]], dtype=bool)\n    expected_conn_1 = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0,\n        0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, \n        0], [1, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1,\n        0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, \n        0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_object(image, connectivity=1),\n        expected_conn_1)\n    expected_conn_2 = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0,\n        0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, \n        0], [1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1,\n        0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, \n        0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_object(image, connectivity=2),\n        expected_conn_2)\n    with testing.raises(ValueError):\n        convex_hull_object(image, connectivity=3)\n    out = convex_hull_object(image, connectivity=1)\n    assert_array_equal(out, expected_conn_1)\n\ntest_object()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}], "instruction": "Functionality: The convex_hull_object function computes the convex hull image of individual objects within a binary image. This involves determining the smallest convex polygon that surrounds all white pixels for each object in the input image. The function also allows for adjusting the connectivity parameter to define the neighbors of each pixel.\n\nInputs: \n- image: A 2D numpy array (M, N) representing a binary input image.\n- connectivity: An optional integer parameter with a value of either 1 or 2, which determines the neighbors of each pixel based on a squared distance. Default value is 2.\n\nOutputs:\n- hull: A 2D numpy array of boolean values (ndarray of bool) representing the binary image with pixels inside the convex hull set to True for each individual object in the input image.", "method_code_mask": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\n\ndef convex_hull_object(image, *, connectivity=2): [MASK]\n"}
{"method_name": "rectangle", "full_method_name": "rectangle", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "method_code": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\ndef rectangle(nrows, ncols, dtype=np.uint8, *, decomposition=None):\n    \"\"\"Generates a flat, rectangular-shaped footprint.\n\n    Every pixel in the rectangle generated for a given width and given height\n    belongs to the neighborhood.\n\n    Parameters\n    ----------\n    nrows : int\n        The number of rows of the rectangle.\n    ncols : int\n        The number of columns of the rectangle.\n\n    Other Parameters\n    ----------------\n    dtype : data-type, optional\n        The data type of the footprint.\n    decomposition : {None, 'separable', 'sequence'}, optional\n        If None, a single array is returned. For 'sequence', a tuple of smaller\n        footprints is returned. Applying this series of smaller footprints will\n        given an identical result to a single, larger footprint, but often with\n        better computational performance. See Notes for more details.\n        With 'separable', this function uses separable 1D footprints for each\n        axis. Whether 'sequence' or 'separable' is computationally faster may\n        be architecture-dependent.\n\n    Returns\n    -------\n    footprint : ndarray or tuple\n        A footprint consisting only of ones, i.e. every pixel belongs to the\n        neighborhood. When `decomposition` is None, this is just a\n        numpy.ndarray. Otherwise, this will be a tuple whose length is equal to\n        the number of unique structuring elements to apply (see Notes for more\n        detail)\n\n    Notes\n    -----\n    When `decomposition` is not None, each element of the `footprint`\n    tuple is a 2-tuple of the form ``(ndarray, num_iter)`` that specifies a\n    footprint array and the number of iterations it is to be applied.\n\n    For binary morphology, using ``decomposition='sequence'``\n    was observed to give better performance, with the magnitude of the\n    performance increase rapidly increasing with footprint size. For grayscale\n    morphology with rectangular footprints, it is recommended to use\n    ``decomposition=None`` since the internal SciPy functions that are called\n    already have a fast implementation based on separable 1D sliding windows.\n\n    The `sequence` decomposition mode only supports odd valued `nrows` and\n    `ncols`. If either `nrows` or `ncols` is even, the sequence used will be\n    identical to ``decomposition='separable'``.\n\n    - The use of ``width`` and ``height`` has been deprecated in\n      version 0.18.0. Use ``nrows`` and ``ncols`` instead.\n    \"\"\"\n    if decomposition is None:\n        return np.ones((nrows, ncols), dtype=dtype)\n    even_rows = nrows % 2 == 0\n    even_cols = ncols % 2 == 0\n    if decomposition == 'separable' or even_rows or even_cols:\n        sequence = [(np.ones((nrows, 1), dtype=dtype), 1), (np.ones((1,\n            ncols), dtype=dtype), 1)]\n    elif decomposition == 'sequence':\n        sq_size = 3\n        sq_reps = _decompose_size(min(nrows, ncols), sq_size)\n        sequence = [(np.ones((3, 3), dtype=dtype), sq_reps)]\n        if nrows > ncols:\n            nextra = nrows - ncols\n            sequence.append((np.ones((nextra + 1, 1), dtype=dtype), 1))\n        elif ncols > nrows:\n            nextra = ncols - nrows\n            sequence.append((np.ones((1, nextra + 1), dtype=dtype), 1))\n    else:\n        raise ValueError(f'Unrecognized decomposition: {decomposition}')\n    return tuple(sequence)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\n\nclass TestFootprints():\n\tdef test_rectangle_footprint(self):\n\t    \"\"\"Test rectangle footprints\"\"\"\n\t    for i in range(0, 5):\n\t        for j in range(0, 5):\n\t            actual_mask = rectangle(i, j)\n\t            expected_mask = np.ones((i, j), dtype='uint8')\n\t            assert_equal(expected_mask, actual_mask)\n\t\nTestFootprints().test_rectangle_footprint()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_footprints.py"}], "instruction": "Functionality: The function 'rectangle' generates a flat, rectangular-shaped footprint consisting of all ones, specified by the number of rows and columns, suitable for morphological operations.\n\nInputs: \n- nrows: An integer representing the number of rows in the rectangle.\n- ncols: An integer representing the number of columns in the rectangle.\n- dtype: Optional. Specifies the data type of the footprint. Default is np.uint8.\n- decomposition: Optional. Determines whether to return a single array or a tuple of smaller footprints. Can be 'separable', 'sequence', or None. Default is None.\n\nOutputs: \n- footprint: A numpy array or a tuple of arrays representing the footprint. When 'decomposition' is None, it is a single numpy array. When 'decomposition' is specified, it returns a tuple of smaller footprints for better computational performance.", "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef rectangle(nrows, ncols, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"method_name": "diamond", "full_method_name": "diamond", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "method_code": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\ndef diamond(radius, dtype=np.uint8, *, decomposition=None):\n    \"\"\"Generates a flat, diamond-shaped footprint.\n\n    A pixel is part of the neighborhood (i.e. labeled 1) if\n    the city block/Manhattan distance between it and the center of\n    the neighborhood is no greater than radius.\n\n    Parameters\n    ----------\n    radius : int\n        The radius of the diamond-shaped footprint.\n\n    Other Parameters\n    ----------------\n    dtype : data-type, optional\n        The data type of the footprint.\n    decomposition : {None, 'sequence'}, optional\n        If None, a single array is returned. For 'sequence', a tuple of smaller\n        footprints is returned. Applying this series of smaller footprints will\n        given an identical result to a single, larger footprint, but with\n        better computational performance. See Notes for more details.\n\n    Returns\n    -------\n    footprint : ndarray or tuple\n        The footprint where elements of the neighborhood are 1 and 0 otherwise.\n        When `decomposition` is None, this is just a numpy.ndarray. Otherwise,\n        this will be a tuple whose length is equal to the number of unique\n        structuring elements to apply (see Notes for more detail)\n\n    Notes\n    -----\n    When `decomposition` is not None, each element of the `footprint`\n    tuple is a 2-tuple of the form ``(ndarray, num_iter)`` that specifies a\n    footprint array and the number of iterations it is to be applied.\n\n    For either binary or grayscale morphology, using\n    ``decomposition='sequence'`` was observed to have a performance benefit,\n    with the magnitude of the benefit increasing with increasing footprint\n    size.\n\n    \"\"\"\n    if decomposition is None:\n        L = np.arange(0, radius * 2 + 1)\n        I, J = np.meshgrid(L, L)\n        footprint = np.array(np.abs(I - radius) + np.abs(J - radius) <=\n            radius, dtype=dtype)\n    elif decomposition == 'sequence':\n        fp = diamond(1, dtype=dtype, decomposition=None)\n        nreps = _decompose_size(2 * radius + 1, fp.shape[0])\n        footprint = (fp, nreps),\n    else:\n        raise ValueError(f'Unrecognized decomposition: {decomposition}')\n    return footprint", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.morphology import diamond\nfrom skimage.feature import match_template\nfrom skimage.feature import peak_local_max\nfrom skimage._shared import testing\ndef test_pad_input():\n    \"\"\"Test `match_template` when `pad_input=True`.\n\n    This test places two full templates (one with values lower than the image\n    mean, the other higher) and two half templates, which are on the edges of\n    the image. The two full templates should score the top (positive and\n    negative) matches and the centers of the half templates should score 2nd.\n    \"\"\"\n    template = 0.5 * diamond(2)\n    image = 0.5 * np.ones((9, 19))\n    mid = slice(2, 7)\n    image[mid, :3] -= template[:, -3:]\n    image[mid, 4:9] += template\n    image[mid, -9:-4] -= template\n    image[mid, -3:] += template[:, :3]\n    result = match_template(image, template, pad_input=True,\n        constant_values=image.mean())\n    sorted_result = np.argsort(result.flat)\n    i, j = np.unravel_index(sorted_result[:2], result.shape)\n    assert_equal(j, (12, 0))\n    i, j = np.unravel_index(sorted_result[-2:], result.shape)\n    assert_equal(j, (18, 6))\n\ntest_pad_input()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_template.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.morphology import diamond\nfrom skimage.feature import match_template\nfrom skimage.feature import peak_local_max\nfrom skimage._shared import testing\ndef test_padding_reflect():\n    template = diamond(2)\n    image = np.zeros((10, 10))\n    image[2:7, :3] = template[:, -3:]\n    result = match_template(image, template, pad_input=True, mode='reflect')\n    assert_equal(np.unravel_index(result.argmax(), result.shape), (4, 0))\n\ntest_padding_reflect()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_template.py"}], "instruction": "Functionality: The diamond function generates a flat, diamond-shaped footprint, which is often used in image processing for morphological operations. The function creates a neighborhood based on the city block/Manhattan distance, where a pixel is considered part of the neighborhood if it is no more than the specified radius away from the center.\n\nInputs: \n1. radius: An integer representing the radius of the diamond-shaped footprint.\n2. dtype: Optional. A data type for the elements of the footprint. Defaults to numpy's uint8.\n3. decomposition: Optional. A string that specifies if the function should return a sequence of smaller footprints for better computational performance ('sequence') or a single array (None). Default is None.\n\nOutputs: \n1. footprint: A numpy array or tuple based on the value of 'decomposition'. If 'decomposition' is None, the output is a numpy array where 1 represents elements of the neighborhood and 0 represents the rest. If 'decomposition' is 'sequence', the output is a tuple of smaller footprints, each represented as a 2-tuple of the form (ndarray, num_iter), where 'ndarray' is the footprint array and 'num_iter' is the number of iterations it is to be applied.", "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef diamond(radius, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"method_name": "cube", "full_method_name": "cube", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "method_code": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\ndef cube(width, dtype=np.uint8, *, decomposition=None):\n    \"\"\"Generates a cube-shaped footprint.\n\n    This is the 3D equivalent of a square.\n    Every pixel along the perimeter has a chessboard distance\n    no greater than radius (radius=floor(width/2)) pixels.\n\n    Parameters\n    ----------\n    width : int\n        The width, height and depth of the cube.\n\n    Other Parameters\n    ----------------\n    dtype : data-type, optional\n        The data type of the footprint.\n    decomposition : {None, 'separable', 'sequence'}, optional\n        If None, a single array is returned. For 'sequence', a tuple of smaller\n        footprints is returned. Applying this series of smaller footprints will\n        given an identical result to a single, larger footprint, but often with\n        better computational performance. See Notes for more details.\n\n    Returns\n    -------\n    footprint : ndarray or tuple\n        The footprint where elements of the neighborhood are 1 and 0 otherwise.\n        When `decomposition` is None, this is just a numpy.ndarray. Otherwise,\n        this will be a tuple whose length is equal to the number of unique\n        structuring elements to apply (see Notes for more detail)\n\n    Notes\n    -----\n    When `decomposition` is not None, each element of the `footprint`\n    tuple is a 2-tuple of the form ``(ndarray, num_iter)`` that specifies a\n    footprint array and the number of iterations it is to be applied.\n\n    For binary morphology, using ``decomposition='sequence'``\n    was observed to give better performance, with the magnitude of the\n    performance increase rapidly increasing with footprint size. For grayscale\n    morphology with square footprints, it is recommended to use\n    ``decomposition=None`` since the internal SciPy functions that are called\n    already have a fast implementation based on separable 1D sliding windows.\n\n    The 'sequence' decomposition mode only supports odd valued `width`. If\n    `width` is even, the sequence used will be identical to the 'separable'\n    mode.\n    \"\"\"\n    if decomposition is None:\n        return np.ones((width, width, width), dtype=dtype)\n    if decomposition == 'separable' or width % 2 == 0:\n        sequence = [(np.ones((width, 1, 1), dtype=dtype), 1), (np.ones((1,\n            width, 1), dtype=dtype), 1), (np.ones((1, 1, width), dtype=\n            dtype), 1)]\n    elif decomposition == 'sequence':\n        sequence = [(np.ones((3, 3, 3), dtype=dtype), _decompose_size(width,\n            3))]\n    else:\n        raise ValueError(f'Unrecognized decomposition: {decomposition}')\n    return tuple(sequence)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\n\nclass TestFootprints():\n\tdef test_cube_footprint(self):\n\t    \"\"\"Test cube footprints\"\"\"\n\t    for k in range(0, 5):\n\t        actual_mask = cube(k)\n\t        expected_mask = np.ones((k, k, k), dtype='uint8')\n\t        assert_equal(expected_mask, actual_mask)\n\t\nTestFootprints().test_cube_footprint()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_footprints.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom skimage import data\nfrom skimage import draw\nfrom skimage import img_as_float\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.feature import corner_fast\nfrom skimage.feature import corner_foerstner\nfrom skimage.feature import corner_harris\nfrom skimage.feature import corner_kitchen_rosenfeld\nfrom skimage.feature import corner_moravec\nfrom skimage.feature import corner_orientations\nfrom skimage.feature import corner_peaks\nfrom skimage.feature import corner_shi_tomasi\nfrom skimage.feature import corner_subpix\nfrom skimage.feature import hessian_matrix\nfrom skimage.feature import hessian_matrix_det\nfrom skimage.feature import hessian_matrix_eigvals\nfrom skimage.feature import peak_local_max\nfrom skimage.feature import shape_index\nfrom skimage.feature import structure_tensor\nfrom skimage.feature import structure_tensor_eigenvalues\nfrom skimage.morphology import cube\nfrom skimage.morphology import octagon\ndef test_structure_tensor_eigenvalues_3d():\n    image = np.pad(cube(9, dtype=np.int64), 5, mode='constant') * 1000\n    boundary = (np.pad(cube(9), 5, mode='constant') - np.pad(cube(7), 6,\n        mode='constant')).astype(bool)\n    A_elems = structure_tensor(image, sigma=0.1)\n    e0, e1, e2 = structure_tensor_eigenvalues(A_elems)\n    assert np.all(e0[boundary] != 0)\n\ntest_structure_tensor_eigenvalues_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_corner.py"}], "instruction": "Functionality: \nThe function \"cube\" is designed to generate a cube-shaped footprint, which is equivalent to a square in 3D space. This footprint is characterized by the property that every pixel along the perimeter has a chessboard distance no greater than radius (radius=floor(width/2)) pixels.\n\nInputs: \n1. width (int): Represents the width, height, and depth of the cube. This is the primary input that determines the shape and size of the generated footprint.\n2. dtype (data-type, optional): Specifies the data type of the footprint. The default data type is np.uint8.\n3. decomposition {None, 'separable', 'sequence'}, optional: This parameter controls the format in which the footprint is returned. If set to None (default), a single array is returned. If set to 'separable' or 'sequence', a tuple of smaller footprints is returned. Applying this series of smaller footprints will yield an identical result to a single, larger footprint, but with potentially better computational performance.\n\nOutputs: \nThe function returns a footprint, which is a numpy array where elements of the neighborhood are 1 and 0 otherwise. When decomposition is None, the return type is just a numpy.ndarray. However, when decomposition is not None, the function returns a tuple. The length of the tuple is equal to the number of unique structuring elements to apply, and each element of the tuple is a 2-tuple of the form (ndarray, num_iter) that specifies a footprint array and the number of iterations it is to be applied.", "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef cube(width, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"method_name": "remove_small_objects", "full_method_name": "remove_small_objects", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/misc.py", "method_code": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\ndef remove_small_objects(ar, min_size=64, connectivity=1, *, out=None):\n    \"\"\"Remove objects smaller than the specified size.\n\n    Expects ar to be an array with labeled objects, and removes objects\n    smaller than min_size. If `ar` is bool, the image is first labeled.\n    This leads to potentially different behavior for bool and 0-and-1\n    arrays.\n\n    Parameters\n    ----------\n    ar : ndarray (arbitrary shape, int or bool type)\n        The array containing the objects of interest. If the array type is\n        int, the ints must be non-negative.\n    min_size : int, optional (default: 64)\n        The smallest allowable object size.\n    connectivity : int, {1, 2, ..., ar.ndim}, optional (default: 1)\n        The connectivity defining the neighborhood of a pixel. Used during\n        labelling if `ar` is bool.\n    out : ndarray\n        Array of the same shape as `ar`, into which the output is\n        placed. By default, a new array is created.\n\n    Raises\n    ------\n    TypeError\n        If the input array is of an invalid type, such as float or string.\n    ValueError\n        If the input array contains negative values.\n\n    Returns\n    -------\n    out : ndarray, same shape and type as input `ar`\n        The input array with small connected components removed.\n\n    See Also\n    --------\n    skimage.morphology.remove_objects_by_distance\n\n    Examples\n    --------\n    >>> from skimage import morphology\n    >>> a = np.array([[0, 0, 0, 1, 0],\n    ...               [1, 1, 1, 0, 0],\n    ...               [1, 1, 1, 0, 1]], bool)\n    >>> b = morphology.remove_small_objects(a, 6)\n    >>> b\n    array([[False, False, False, False, False],\n           [ True,  True,  True, False, False],\n           [ True,  True,  True, False, False]])\n    >>> c = morphology.remove_small_objects(a, 7, connectivity=2)\n    >>> c\n    array([[False, False, False,  True, False],\n           [ True,  True,  True, False, False],\n           [ True,  True,  True, False, False]])\n    >>> d = morphology.remove_small_objects(a, 6, out=a)\n    >>> d is a\n    True\n\n    \"\"\"\n    _check_dtype_supported(ar)\n    if out is None:\n        out = ar.copy()\n    else:\n        out[:] = ar\n    if min_size == 0:\n        return out\n    if out.dtype == bool:\n        footprint = ndi.generate_binary_structure(ar.ndim, connectivity)\n        ccs = np.zeros_like(ar, dtype=np.int32)\n        ndi.label(ar, footprint, output=ccs)\n    else:\n        ccs = out\n    try:\n        component_sizes = np.bincount(ccs.ravel())\n    except ValueError:\n        raise ValueError(\n            'Negative value labels are not supported. Try relabeling the input with `scipy.ndimage.label` or `skimage.morphology.label`.'\n            )\n    if len(component_sizes) == 2 and out.dtype != bool:\n        warn(\n            'Only one label was provided to `remove_small_objects`. Did you mean to use a boolean array?'\n            )\n    too_small = component_sizes < min_size\n    too_small_mask = too_small[ccs]\n    out[too_small_mask] = 0\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image():\n    labeled_image = np.array([[2, 2, 2, 0, 1], [2, 2, 2, 0, 1], [2, 0, 0, 0,\n        0], [0, 0, 3, 3, 3]], dtype=int)\n    expected = np.array([[2, 2, 2, 0, 0], [2, 2, 2, 0, 0], [2, 0, 0, 0, 0],\n        [0, 0, 3, 3, 3]], dtype=int)\n    observed = remove_small_objects(labeled_image, min_size=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image():\n    labeled_image = np.array([[2, 2, 2, 0, 1], [2, 2, 2, 0, 1], [2, 0, 0, 0,\n        0], [0, 0, 3, 3, 3]], dtype=np.uint8)\n    expected = np.array([[2, 2, 2, 0, 0], [2, 2, 2, 0, 0], [2, 0, 0, 0, 0],\n        [0, 0, 3, 3, 3]], dtype=np.uint8)\n    observed = remove_small_objects(labeled_image, min_size=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}], "instruction": "Functionality: remove_small_objects is designed to eliminate objects within a labeled array that are smaller than a specified size. If the input array is boolean, it will first be labeled. The function raises errors for inappropriate input types or negative values and supports output placement into an existing array.\n\nInputs: \n- ar: An n-dimensional array (of any shape) with either integer or boolean type. The array should contain the objects of interest, and if integers are used, they must be non-negative.\n- min_size: An integer determining the smallest allowable object size, with a default value of 64.\n- connectivity: An integer ranging from 1 to the dimension of 'ar' that defines the connectivity of the neighborhood for pixel labeling. If 'ar' is boolean, this parameter is used during labeling. The default is 1.\n- out: An optional output array with the same shape as 'ar'. If not provided, a new array is created.\n\nOutputs:\n- out: An array of the same shape and type as the input 'ar', with small connected components removed.", "method_code_mask": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_objects(ar, min_size=64, connectivity=1, *, out=None): [MASK]\n"}
{"method_name": "remove_small_holes", "full_method_name": "remove_small_holes", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/misc.py", "method_code": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\ndef remove_small_holes(ar, area_threshold=64, connectivity=1, *, out=None):\n    \"\"\"Remove contiguous holes smaller than the specified size.\n\n    Parameters\n    ----------\n    ar : ndarray (arbitrary shape, int or bool type)\n        The array containing the connected components of interest.\n    area_threshold : int, optional (default: 64)\n        The maximum area, in pixels, of a contiguous hole that will be filled.\n        Replaces `min_size`.\n    connectivity : int, {1, 2, ..., ar.ndim}, optional (default: 1)\n        The connectivity defining the neighborhood of a pixel.\n    out : ndarray\n        Array of the same shape as `ar` and bool dtype, into which the\n        output is placed. By default, a new array is created.\n\n    Raises\n    ------\n    TypeError\n        If the input array is of an invalid type, such as float or string.\n    ValueError\n        If the input array contains negative values.\n\n    Returns\n    -------\n    out : ndarray, same shape and type as input `ar`\n        The input array with small holes within connected components removed.\n\n    Examples\n    --------\n    >>> from skimage import morphology\n    >>> a = np.array([[1, 1, 1, 1, 1, 0],\n    ...               [1, 1, 1, 0, 1, 0],\n    ...               [1, 0, 0, 1, 1, 0],\n    ...               [1, 1, 1, 1, 1, 0]], bool)\n    >>> b = morphology.remove_small_holes(a, 2)\n    >>> b\n    array([[ True,  True,  True,  True,  True, False],\n           [ True,  True,  True,  True,  True, False],\n           [ True, False, False,  True,  True, False],\n           [ True,  True,  True,  True,  True, False]])\n    >>> c = morphology.remove_small_holes(a, 2, connectivity=2)\n    >>> c\n    array([[ True,  True,  True,  True,  True, False],\n           [ True,  True,  True, False,  True, False],\n           [ True, False, False,  True,  True, False],\n           [ True,  True,  True,  True,  True, False]])\n    >>> d = morphology.remove_small_holes(a, 2, out=a)\n    >>> d is a\n    True\n\n    Notes\n    -----\n    If the array type is int, it is assumed that it contains already-labeled\n    objects. The labels are not kept in the output image (this function always\n    outputs a bool image). It is suggested that labeling is completed after\n    using this function.\n\n    \"\"\"\n    _check_dtype_supported(ar)\n    if ar.dtype != bool:\n        warn(\n            'Any labeled images will be returned as a boolean array. Did you mean to use a boolean array?'\n            , UserWarning)\n    if out is not None:\n        if out.dtype != bool:\n            raise TypeError('out dtype must be bool')\n    else:\n        out = ar.astype(bool, copy=True)\n    np.logical_not(ar, out=out)\n    out = remove_small_objects(out, area_threshold, connectivity, out=out)\n    np.logical_not(out, out=out)\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=int)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=np.uint8)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}], "instruction": "Functionality: The remove_small_holes function aims to eliminate contiguous holes within binary images or labeled images that have an area smaller than the specified threshold. This is particularly useful for post-processing binary images to remove small noise or unwanted isolated regions.\n\nInputs: \n1. ar: An input array (of arbitrary shape) with an int or bool type, representing the image containing the connected components of interest.\n2. area_threshold: An optional int parameter (default: 64) that specifies the maximum area, in pixels, of a contiguous hole that will be filled.\n3. connectivity: An optional int parameter (default: 1) that defines the connectivity defining the neighborhood of a pixel, ranging from 1 to the number of dimensions in the input array.\n4. out: An optional ndarray parameter where the output is placed. If not provided, a new array is created.\n\nOutputs: \n1. out: The output is an ndarray with the same shape and type as the input array 'ar'. It represents the input array with small holes within connected components removed.\n\nNotes:\n- The function supports int or bool types for the input array 'ar'. If the input array is of int type, it is assumed to contain already-labeled objects, and the labels are not kept in the output (the output is always a bool image).\n- The function raises errors for invalid input types (TypeError) or if the input array contains negative values (ValueError).\n- The connectivity parameter specifies how elements are connected. For example, in a 2D array, a connectivity of 1 means only the elements directly adjacent to a given element are considered neighbors, while a connectivity of 2 also includes the diagonally connected elements.", "method_code_mask": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_holes(ar, area_threshold=64, connectivity=1, *, out=None): [M\n    ASK]\n"}
{"method_name": "skeletonize", "full_method_name": "skeletonize", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef skeletonize(image, *, method=None):\n    \"\"\"Compute the skeleton of a binary image.\n\n    Thinning is used to reduce each connected component in a binary image\n    to a single-pixel wide skeleton.\n\n    Parameters\n    ----------\n    image : ndarray, 2D or 3D\n        An image containing the objects to be skeletonized. Zeros or ``False``\n        represent background, nonzero values or ``True`` are foreground.\n    method : {'zhang', 'lee'}, optional\n        Which algorithm to use. Zhang's algorithm [Zha84]_ only works for\n        2D images, and is the default for 2D. Lee's algorithm [Lee94]_\n        works for 2D or 3D images and is the default for 3D.\n\n    Returns\n    -------\n    skeleton : ndarray of bool\n        The thinned image.\n\n    See Also\n    --------\n    medial_axis\n\n    References\n    ----------\n    .. [Lee94] T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models\n           via 3-D medial surface/axis thinning algorithms.\n           Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.\n\n    .. [Zha84] A fast parallel algorithm for thinning digital patterns,\n           T. Y. Zhang and C. Y. Suen, Communications of the ACM,\n           March 1984, Volume 27, Number 3.\n\n    Examples\n    --------\n    >>> X, Y = np.ogrid[0:9, 0:9]\n    >>> ellipse = (1./3 * (X - 4)**2 + (Y - 4)**2 < 3**2).astype(bool)\n    >>> ellipse.view(np.uint8)\n    array([[0, 0, 0, 1, 1, 1, 0, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 1, 1, 0, 0],\n           [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)\n    >>> skel = skeletonize(ellipse)\n    >>> skel.view(np.uint8)\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n\n    \"\"\"\n    image = image.astype(bool, order='C', copy=False)\n    if method not in {'zhang', 'lee', None}:\n        raise ValueError(\n            f'skeletonize method should be either \"lee\" or \"zhang\", got {method}.'\n            )\n    if image.ndim == 2 and (method is None or method == 'zhang'):\n        skeleton = _skeletonize_2d(image)\n    elif image.ndim == 3 and method == 'zhang':\n        raise ValueError('skeletonize method \"zhang\" only works for 2D images.'\n            )\n    elif image.ndim == 3 or image.ndim == 2 and method == 'lee':\n        skeleton = _skeletonize_3d(image)\n    else:\n        raise ValueError(\n            f'skeletonize requires a 2D or 3D image as input, got {image.ndim}D.'\n            )\n    return skeleton", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy.ndimage as ndi\nfrom skimage import io\nfrom skimage import draw\nfrom skimage.data import binary_blobs\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import skeletonize_3d\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import parametrize\nfrom skimage._shared.testing import fetch\ndef test_skeletonize_1D_old_api():\n    im = np.ones((5, 1), dtype=bool)\n    res = skeletonize(im)\n    assert_equal(res, im)\n\ntest_skeletonize_1D_old_api()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize_3d.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy.ndimage as ndi\nfrom skimage import io\nfrom skimage import draw\nfrom skimage.data import binary_blobs\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import skeletonize_3d\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import parametrize\nfrom skimage._shared.testing import fetch\ndef test_skeletonize_no_foreground():\n    im = np.zeros((5, 5), dtype=bool)\n    result = skeletonize(im, method='lee')\n    assert_equal(result, im)\n\ntest_skeletonize_no_foreground()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize_3d.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_no_foreground(self):\n\t    im = np.zeros((5, 5))\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, np.zeros((5, 5)))\n\t\nTestSkeletonize().test_skeletonize_no_foreground()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_single_point(self):\n\t    im = np.zeros((5, 5), dtype=bool)\n\t    im[3, 3] = 1\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, im)\n\t\nTestSkeletonize().test_skeletonize_single_point()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_already_thinned(self):\n\t    im = np.zeros((5, 5), dtype=bool)\n\t    im[3, 1:-1] = 1\n\t    im[2, -1] = 1\n\t    im[4, 0] = 1\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, im)\n\t\nTestSkeletonize().test_skeletonize_already_thinned()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_output(self):\n\t    im = imread(fetch('data/bw_text.png'), as_gray=True)\n\t    im = im == 0\n\t    result = skeletonize(im)\n\t    expected = np.load(fetch('data/bw_text_skeleton.npy'))\n\t    assert_array_equal(result, expected)\n\t\nTestSkeletonize().test_skeletonize_output()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_lut_fix(self):\n\t    im = np.zeros((6, 6), dtype=bool)\n\t    im[1, 2] = 1\n\t    im[2, 2] = 1\n\t    im[2, 3] = 1\n\t    im[3, 3] = 1\n\t    im[3, 4] = 1\n\t    im[4, 4] = 1\n\t    im[4, 5] = 1\n\t    result = skeletonize(im)\n\t    expected = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, \n\t        1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0\n\t        ]], dtype=bool)\n\t    assert np.all(result == expected)\n\t\nTestSkeletonize().test_lut_fix()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "instruction": "Functionality: The function 'skeletonize' is designed to compute the skeleton of a binary image. It utilizes thinning algorithms to reduce each connected component within a binary image to a single-pixel wide structure, effectively preserving the topology and shape of the original objects.\n\nInputs: \n1. image: An array-like input representing a binary image in 2D or 3D. This array should contain objects to be skeletonized, where zeros or 'False' values represent the background, and non-zero values or 'True' indicate the foreground.\n2. method: An optional parameter specifying the thinning algorithm to be used. This can either be 'zhang' for Zhang's algorithm (recommended for 2D images) or 'lee' for Lee's algorithm (suitable for both 2D and 3D images).\n\nOutputs:\n1. skeleton: The output is an array of boolean values representing the skeletonized binary image. This array will have the same dimensions as the input 'image', but with the foreground objects reduced to a single-pixel wide structure based on the selected thinning algorithm.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef skeletonize(image, *, method=None): [MASK]\n"}
{"method_name": "max_tree_local_maxima", "full_method_name": "max_tree_local_maxima", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/max_tree.py", "method_code": "import numpy as np\ndef max_tree_local_maxima(image, connectivity=1, parent=None,\n    tree_traverser=None):\n    \"\"\"Determine all local maxima of the image.\n\n    The local maxima are defined as connected sets of pixels with equal\n    gray level strictly greater than the gray levels of all pixels in direct\n    neighborhood of the set. The function labels the local maxima.\n\n    Technically, the implementation is based on the max-tree representation\n    of an image. The function is very efficient if the max-tree representation\n    has already been computed. Otherwise, it is preferable to use\n    the function local_maxima.\n\n    Parameters\n    ----------\n    image : ndarray\n        The input image for which the maxima are to be calculated.\n    connectivity : unsigned int, optional\n        The neighborhood connectivity. The integer represents the maximum\n        number of orthogonal steps to reach a neighbor. In 2D, it is 1 for\n        a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.\n    parent : ndarray, int64, optional\n        The value of each pixel is the index of its parent in the ravelled\n        array.\n    tree_traverser : 1D array, int64, optional\n        The ordered pixel indices (referring to the ravelled array). The pixels\n        are ordered such that every pixel is preceded by its parent (except for\n        the root which has no parent).\n\n    Returns\n    -------\n    local_max : ndarray, uint64\n        Labeled local maxima of the image.\n\n    See Also\n    --------\n    skimage.morphology.local_maxima\n    skimage.morphology.max_tree\n\n    References\n    ----------\n    .. [1] Vincent L., Proc. \"Grayscale area openings and closings,\n           their efficient implementation and applications\",\n           EURASIP Workshop on Mathematical Morphology and its\n           Applications to Signal Processing, Barcelona, Spain, pp.22-27,\n           May 1993.\n    .. [2] Soille, P., \"Morphological Image Analysis: Principles and\n           Applications\" (Chapter 6), 2nd edition (2003), ISBN 3540429883.\n           :DOI:`10.1007/978-3-662-05088-0`\n    .. [3] Salembier, P., Oliveras, A., & Garrido, L. (1998). Antiextensive\n           Connected Operators for Image and Sequence Processing.\n           IEEE Transactions on Image Processing, 7(4), 555-570.\n           :DOI:`10.1109/83.663500`\n    .. [4] Najman, L., & Couprie, M. (2006). Building the component tree in\n           quasi-linear time. IEEE Transactions on Image Processing, 15(11),\n           3531-3539.\n           :DOI:`10.1109/TIP.2006.877518`\n    .. [5] Carlinet, E., & Geraud, T. (2014). A Comparative Review of\n           Component Tree Computation Algorithms. IEEE Transactions on Image\n           Processing, 23(9), 3885-3895.\n           :DOI:`10.1109/TIP.2014.2336551`\n\n    Examples\n    --------\n    We create an image (quadratic function with a maximum in the center and\n    4 additional constant maxima.\n\n    >>> w = 10\n    >>> x, y = np.mgrid[0:w,0:w]\n    >>> f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)\n    >>> f[2:4,2:4] = 40; f[2:4,7:9] = 60; f[7:9,2:4] = 80; f[7:9,7:9] = 100\n    >>> f = f.astype(int)\n\n    We can calculate all local maxima:\n\n    >>> maxima = max_tree_local_maxima(f)\n\n    The resulting image contains the labeled local maxima.\n    \"\"\"\n    output = np.ones(image.shape, dtype=np.uint64)\n    if parent is None or tree_traverser is None:\n        parent, tree_traverser = max_tree(image, connectivity)\n    _max_tree._max_tree_local_maxima(image.ravel(), output.ravel(), parent.\n        ravel(), tree_traverser)\n    return output", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_local_maxima(self):\n\t    \"\"\"local maxima for various data types\"\"\"\n\t    data = np.array([[10, 11, 13, 14, 14, 15, 14, 14, 13, 11], [11, 13, 15,\n\t        16, 16, 16, 16, 16, 15, 13], [13, 15, 40, 40, 18, 18, 18, 60, 60, \n\t        15], [14, 16, 40, 40, 19, 19, 19, 60, 60, 16], [14, 16, 18, 19, 19,\n\t        19, 19, 19, 18, 16], [15, 16, 18, 19, 19, 20, 19, 19, 18, 16], [14,\n\t        16, 18, 19, 19, 19, 19, 19, 18, 16], [14, 16, 80, 80, 19, 19, 19, \n\t        100, 100, 16], [13, 15, 80, 80, 18, 18, 18, 100, 100, 15], [11, 13,\n\t        15, 16, 16, 16, 16, 16, 15, 13]], dtype=np.uint8)\n\t    expected_result = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, \n\t        0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, \n\t        0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, \n\t        1, 1, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n\t        0, 0]], dtype=np.uint64)\n\t    for dtype in [np.uint8, np.uint64, np.int8, np.int64]:\n\t        test_data = data.astype(dtype)\n\t        out = max_tree_local_maxima(test_data, connectivity=1)\n\t        out_bin = out > 0\n\t        assert_array_equal(expected_result, out_bin)\n\t        assert out.dtype == expected_result.dtype\n\t        assert np.max(out) == 5\n\t        P, S = max_tree(test_data)\n\t        out = max_tree_local_maxima(test_data, parent=P, tree_traverser=S)\n\t        assert_array_equal(expected_result, out_bin)\n\t        assert out.dtype == expected_result.dtype\n\t        assert np.max(out) == 5\n\t\nTestMaxtree().test_local_maxima()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_extrema_float(self):\n\t    \"\"\"specific tests for float type\"\"\"\n\t    data = np.array([[0.1, 0.11, 0.13, 0.14, 0.14, 0.15, 0.14, 0.14, 0.13, \n\t        0.11], [0.11, 0.13, 0.15, 0.16, 0.16, 0.16, 0.16, 0.16, 0.15, 0.13],\n\t        [0.13, 0.15, 0.4, 0.4, 0.18, 0.18, 0.18, 0.6, 0.6, 0.15], [0.14, \n\t        0.16, 0.4, 0.4, 0.19, 0.19, 0.19, 0.6, 0.6, 0.16], [0.14, 0.16, \n\t        0.18, 0.19, 0.19, 0.19, 0.19, 0.19, 0.18, 0.16], [0.15, 0.182, 0.18,\n\t        0.19, 0.204, 0.2, 0.19, 0.19, 0.18, 0.16], [0.14, 0.16, 0.18, 0.19,\n\t        0.19, 0.19, 0.19, 0.19, 0.18, 0.16], [0.14, 0.16, 0.8, 0.8, 0.19, \n\t        0.19, 0.19, 4.0, 1.0, 0.16], [0.13, 0.15, 0.8, 0.8, 0.18, 0.18, \n\t        0.18, 1.0, 1.0, 0.15], [0.11, 0.13, 0.15, 0.16, 0.16, 0.16, 0.16, \n\t        0.16, 0.15, 0.13]], dtype=np.float32)\n\t    expected_result = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, \n\t        0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, \n\t        0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, \n\t        1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n\t        0, 0]], dtype=np.uint8)\n\t    out = max_tree_local_maxima(data, connectivity=1)\n\t    out_bin = out > 0\n\t    assert_array_equal(expected_result, out_bin)\n\t    assert np.max(out) == 6\n\t\nTestMaxtree().test_extrema_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_3d(self):\n\t    \"\"\"tests the detection of maxima in 3D.\"\"\"\n\t    img = np.zeros((8, 8, 8), dtype=np.uint8)\n\t    local_maxima = np.zeros((8, 8, 8), dtype=np.uint64)\n\t    img[1, 1:3, 1:3] = 100\n\t    img[2, 2, 2] = 200\n\t    img[3, 1:3, 1:3] = 100\n\t    local_maxima[2, 2, 2] = 1\n\t    img[5:8, 1, 1] = 200\n\t    local_maxima[5:8, 1, 1] = 1\n\t    img[0, 5:8, 5:8] = 200\n\t    img[1, 6, 6] = 100\n\t    img[2, 5:7, 5:7] = 200\n\t    img[0:3, 5:8, 5:8] += 50\n\t    local_maxima[0, 5:8, 5:8] = 1\n\t    local_maxima[2, 5:7, 5:7] = 1\n\t    img[6:8, 6:8, 6:8] = 200\n\t    img[7, 7, 7] = 255\n\t    local_maxima[7, 7, 7] = 1\n\t    out = max_tree_local_maxima(img)\n\t    out_bin = out > 0\n\t    assert_array_equal(local_maxima, out_bin)\n\t    assert np.max(out) == 5\n\t\nTestMaxtree().test_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}], "instruction": "Functionality: The function max_tree_local_maxima is designed to identify and label all local maxima in a given input image. Local maxima are defined as connected pixel sets with equal gray levels that are strictly greater than the gray levels of their immediate neighbors. The function leverages the concept of max-tree representation for efficient computation, especially when the max-tree has already been calculated for the image.\n\nInputs: \n1. image - An ndarray representing the input image for which local maxima are to be determined.\n2. connectivity (optional) - An unsigned integer that specifies the neighborhood connectivity, typically 1 for 4-neighborhood (default) or 2 for 8-neighborhood in 2D images.\n3. parent (optional) - An int64 ndarray where each pixel's value is the index of its parent in the flattened image array.\n4. tree_traverser (optional) - An int64 1D array containing ordered pixel indices (related to the ravelled array), ensuring each pixel is preceded by its parent, except for the root which has no parent.\n\nOutputs:\n1. local_max - An ndarray of type uint64 that labels the local maxima of the input image.\n\nNote: If the parent and tree_traverser arrays are not provided, they will be computed internally by constructing the max-tree of the image.", "method_code_mask": "import numpy as np\n\n\ndef max_tree_local_maxima(image, connectivity=1, parent=None,\n    tree_traverser=None): [MASK]\n"}
{"method_name": "disk", "full_method_name": "disk", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "method_code": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\ndef disk(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None):\n    \"\"\"Generates a flat, disk-shaped footprint.\n\n    A pixel is within the neighborhood if the Euclidean distance between\n    it and the origin is no greater than radius (This is only approximately\n    True, when `decomposition == 'sequence'`).\n\n    Parameters\n    ----------\n    radius : int\n        The radius of the disk-shaped footprint.\n\n    Other Parameters\n    ----------------\n    dtype : data-type, optional\n        The data type of the footprint.\n    strict_radius : bool, optional\n        If False, extend the radius by 0.5. This allows the circle to expand\n        further within a cube that remains of size ``2 * radius + 1`` along\n        each axis. This parameter is ignored if decomposition is not None.\n    decomposition : {None, 'sequence', 'crosses'}, optional\n        If None, a single array is returned. For 'sequence', a tuple of smaller\n        footprints is returned. Applying this series of smaller footprints will\n        given a result equivalent to a single, larger footprint, but with\n        better computational performance. For disk footprints, the 'sequence'\n        or 'crosses' decompositions are not always exactly equivalent to\n        ``decomposition=None``. See Notes for more details.\n\n    Returns\n    -------\n    footprint : ndarray\n        The footprint where elements of the neighborhood are 1 and 0 otherwise.\n\n    Notes\n    -----\n    When `decomposition` is not None, each element of the `footprint`\n    tuple is a 2-tuple of the form ``(ndarray, num_iter)`` that specifies a\n    footprint array and the number of iterations it is to be applied.\n\n    The disk produced by the ``decomposition='sequence'`` mode may not be\n    identical to that with ``decomposition=None``. A disk footprint can be\n    approximated by applying a series of smaller footprints of extent 3 along\n    each axis. Specific solutions for this are given in [1]_ for the case of\n    2D disks with radius 2 through 10. Here, we numerically computed the number\n    of repetitions of each element that gives the closest match to the disk\n    computed with kwargs ``strict_radius=False, decomposition=None``.\n\n    Empirically, the series decomposition at large radius approaches a\n    hexadecagon (a 16-sided polygon [2]_). In [3]_, the authors demonstrate\n    that a hexadecagon is the closest approximation to a disk that can be\n    achieved for decomposition with footprints of shape (3, 3).\n\n    The disk produced by the ``decomposition='crosses'`` is often but not\n    always  identical to that with ``decomposition=None``. It tends to give a\n    closer approximation than ``decomposition='sequence'``, at a performance\n    that is fairly comparable. The individual cross-shaped elements are not\n    limited to extent (3, 3) in size. Unlike the 'seqeuence' decomposition, the\n    'crosses' decomposition can also accurately approximate the shape of disks\n    with ``strict_radius=True``. The method is based on an adaption of\n    algorithm 1 given in [4]_.\n\n    References\n    ----------\n    .. [1] Park, H and Chin R.T. Decomposition of structuring elements for\n           optimal implementation of morphological operations. In Proceedings:\n           1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,\n           UK.\n           https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf\n    .. [2] https://en.wikipedia.org/wiki/Hexadecagon\n    .. [3] Vanrell, M and Vitri\u00e0, J. Optimal 3 \u00d7 3 decomposable disks for\n           morphological transformations. Image and Vision Computing, Vol. 15,\n           Issue 11, 1997.\n           :DOI:`10.1016/S0262-8856(97)00026-7`\n    .. [4] Li, D. and Ritter, G.X. Decomposition of Separable and Symmetric\n           Convex Templates. Proc. SPIE 1350, Image Algebra and Morphological\n           Image Processing, (1 November 1990).\n           :DOI:`10.1117/12.23608`\n    \"\"\"\n    if decomposition is None:\n        L = np.arange(-radius, radius + 1)\n        X, Y = np.meshgrid(L, L)\n        if not strict_radius:\n            radius += 0.5\n        return np.array(X ** 2 + Y ** 2 <= radius ** 2, dtype=dtype)\n    elif decomposition == 'sequence':\n        sequence = _nsphere_series_decomposition(radius, ndim=2, dtype=dtype)\n    elif decomposition == 'crosses':\n        fp = disk(radius, dtype, strict_radius=strict_radius, decomposition\n            =None)\n        sequence = _cross_decomposition(fp)\n    return sequence", "test_code_list": [{"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float(self):\n\t    image_uint = img_as_ubyte(data.camera()[:50, :50])\n\t    image_float = img_as_float(image_uint)\n\t    methods = ['autolevel', 'equalize', 'gradient', 'threshold',\n\t        'subtract_mean', 'enhance_contrast', 'pop']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_uint, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(image_float, disk(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed(self):\n\t    image = img_as_ubyte(data.camera())[::2, ::2]\n\t    image[image > 127] = 0\n\t    image_s = image.astype(np.int8)\n\t    image_u = img_as_ubyte(image_s)\n\t    assert_equal(image_u, img_as_ubyte(image_s))\n\t    methods = ['autolevel', 'equalize', 'gradient', 'maximum', 'mean',\n\t        'geometric_mean', 'subtract_mean', 'median', 'minimum', 'modal',\n\t        'enhance_contrast', 'pop', 'threshold']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_u, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(image_s, disk(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_median_default_value(self):\n\t    a = np.zeros((3, 3), dtype=np.uint8)\n\t    a[1] = 1\n\t    full_footprint = np.ones((3, 3), dtype=np.uint8)\n\t    assert_equal(rank.median(a), rank.median(a, full_footprint))\n\t    assert rank.median(a)[1, 1] == 0\n\t    assert rank.median(a, disk(1))[1, 1] == 1\n\t\nTestRank().test_median_default_value()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}], "instruction": "Functionality: This function generates a flat, disk-shaped footprint, which is a fundamental component in morphological image processing for tasks like erosion, dilation, opening, and closing. The footprint is equivalent to a circle with a given radius, where pixels within the circle are represented as 1 and those outside as 0.\n\nInputs: \n- radius (int): The radius of the disk-shaped footprint.\n- dtype (data-type, optional): The data type of the footprint, default is np.uint8.\n- strict_radius (bool, optional): If False, the radius is extended by 0.5. This parameter is ignored if decomposition is not None.\n- decomposition (str, optional): Specifies the method of generating the footprint. If None (default), a single array is returned. If 'sequence', returns a series of smaller footprints for better performance. If 'crosses', approximates the disk using a series of cross-shaped footprints.\n\nOutputs:\n- footprint (ndarray): A binary array representing the disk-shaped footprint, where elements of the neighborhood are 1 and 0 otherwise. If decomposition is not None, returns a tuple of smaller footprints and the number of iterations for each.", "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef disk(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None): [M\n    ASK]\n"}
{"method_name": "isotropic_erosion", "full_method_name": "isotropic_erosion", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/isotropic.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef isotropic_erosion(image, radius, out=None, spacing=None):\n    \"\"\"Return binary morphological erosion of an image.\n\n    This function returns the same result as :func:`skimage.morphology.binary_erosion`\n    but performs faster for large circular structuring elements.\n    This works by applying a threshold to the exact Euclidean distance map\n    of the image [1]_, [2]_.\n    The implementation is based on: func:`scipy.ndimage.distance_transform_edt`.\n\n    Parameters\n    ----------\n    image : ndarray\n        Binary input image.\n    radius : float\n        The radius by which regions should be eroded.\n    out : ndarray of bool, optional\n        The array to store the result of the morphology. If None,\n        a new array will be allocated.\n    spacing : float, or sequence of float, optional\n        Spacing of elements along each dimension.\n        If a sequence, must be of length equal to the input's dimension (number of axes).\n        If a single number, this value is used for all axes.\n        If not specified, a grid spacing of unity is implied.\n\n    Returns\n    -------\n    eroded : ndarray of bool\n        The result of the morphological erosion taking values in\n        ``[False, True]``.\n\n    References\n    ----------\n    .. [1] Cuisenaire, O. and Macq, B., \"Fast Euclidean morphological operators\n        using local distance transformation by propagation, and applications,\"\n        Image Processing And Its Applications, 1999. Seventh International\n        Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.\n        :DOI:`10.1049/cp:19990446`\n\n    .. [2] Ingemar Ragnemalm, Fast erosion and dilation by contour processing\n        and thresholding of distance maps, Pattern Recognition Letters,\n        Volume 13, Issue 3, 1992, Pages 161-166.\n        :DOI:`10.1016/0167-8655(92)90055-5`\n    \"\"\"\n    dist = ndi.distance_transform_edt(image, sampling=spacing)\n    return np.greater(dist, radius, out=out)", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage.morphology import binary\nfrom skimage.util import img_as_bool\ndef test_footprint_overflow():\n    img = np.zeros((20, 20), dtype=bool)\n    img[2:19, 2:19] = True\n    isotropic_res = isotropic_erosion(img, 9)\n    binary_res = img_as_bool(binary.binary_erosion(img, morphology.disk(9)))\n    assert_array_equal(isotropic_res, binary_res)\n\ntest_footprint_overflow()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_isotropic.py"}], "instruction": "Functionality: The isotropic_erosion function performs binary morphological erosion on an input image. It operates by applying a threshold to the exact Euclidean distance map of the image, which is computed using the scipy.ndimage.distance_transform_edt function. This method is particularly efficient for large circular structuring elements. The result is a binary image where regions have been eroded by the specified radius.\n\nInputs: \n- image: A 2D or 3D binary input image of type ndarray.\n- radius: A float that defines the radius by which regions in the image should be eroded.\n- out: An optional ndarray of bool to store the result of the erosion. If None, a new array will be allocated.\n- spacing: An optional float, or a sequence of float, that represents the spacing of elements along each dimension. If a single number, it is used for all axes. If not specified, a grid spacing of unity is implied.\n\nOutputs:\n- eroded: An ndarray of bool representing the result of the morphological erosion, where the values are in [False, True].", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef isotropic_erosion(image, radius, out=None, spacing=None): [MASK]\n"}
{"method_name": "thin", "full_method_name": "thin", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef thin(image, max_num_iter=None):\n    \"\"\"\n    Perform morphological thinning of a binary image.\n\n    Parameters\n    ----------\n    image : binary (M, N) ndarray\n        The image to thin. If this input isn't already a binary image,\n        it gets converted into one: In this case, zero values are considered\n        background (False), nonzero values are considered foreground (True).\n    max_num_iter : int, number of iterations, optional\n        Regardless of the value of this parameter, the thinned image\n        is returned immediately if an iteration produces no change.\n        If this parameter is specified it thus sets an upper bound on\n        the number of iterations performed.\n\n    Returns\n    -------\n    out : ndarray of bool\n        Thinned image.\n\n    See Also\n    --------\n    skeletonize, medial_axis\n\n    Notes\n    -----\n    This algorithm [1]_ works by making multiple passes over the image,\n    removing pixels matching a set of criteria designed to thin\n    connected regions while preserving eight-connected components and\n    2 x 2 squares [2]_. In each of the two sub-iterations the algorithm\n    correlates the intermediate skeleton image with a neighborhood mask,\n    then looks up each neighborhood in a lookup table indicating whether\n    the central pixel should be deleted in that sub-iteration.\n\n    References\n    ----------\n    .. [1] Z. Guo and R. W. Hall, \"Parallel thinning with\n           two-subiteration algorithms,\" Comm. ACM, vol. 32, no. 3,\n           pp. 359-373, 1989. :DOI:`10.1145/62065.62074`\n    .. [2] Lam, L., Seong-Whan Lee, and Ching Y. Suen, \"Thinning\n           Methodologies-A Comprehensive Survey,\" IEEE Transactions on\n           Pattern Analysis and Machine Intelligence, Vol 14, No. 9,\n           p. 879, 1992. :DOI:`10.1109/34.161346`\n\n    Examples\n    --------\n    >>> square = np.zeros((7, 7), dtype=bool)\n    >>> square[1:-1, 2:-2] = 1\n    >>> square[0, 1] =  1\n    >>> square.view(np.uint8)\n    array([[0, 1, 0, 0, 0, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n    >>> skel = thin(square)\n    >>> skel.view(np.uint8)\n    array([[0, 1, 0, 0, 0, 0, 0],\n           [0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n    \"\"\"\n    check_nD(image, 2)\n    skel = np.asanyarray(image, dtype=bool).view(np.uint8)\n    mask = np.array([[8, 4, 2], [16, 0, 1], [32, 64, 128]], dtype=np.uint8)\n    max_num_iter = max_num_iter or np.inf\n    num_iter = 0\n    n_pts_old, n_pts_new = np.inf, np.sum(skel)\n    while n_pts_old != n_pts_new and num_iter < max_num_iter:\n        n_pts_old = n_pts_new\n        for lut in [G123_LUT, G123P_LUT]:\n            N = ndi.correlate(skel, mask, mode='constant')\n            D = np.take(lut, N)\n            skel[D] = 0\n        n_pts_new = np.sum(skel)\n        num_iter += 1\n    return skel.astype(bool)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestThin():\n\tdef test_zeros(self):\n\t    image = np.zeros((10, 10), dtype=bool)\n\t    assert np.all(thin(image) == False)\n\t\nTestThin().test_zeros()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "instruction": "Functionality:\nThe function 'thin' performs morphological thinning on a binary image. It reduces the width of the foreground elements while preserving the essential structure and connectivity of the image.\n\nInputs:\n1. image: A binary 2D array (M, N) representing the image to be thinned. Nonzero values are considered foreground (True), and zero values are considered background (False).\n2. max_num_iter: An optional integer specifying the maximum number of iterations. The thinning process stops if an iteration produces no change, regardless of this parameter's value.\n\nOutputs:\n1. out: A 2D boolean array representing the thinned image, where True values correspond to the foreground pixels after thinning.\n\nThe function employs a two-subiteration algorithm to perform thinning, ensuring that 8-connected components and 2x2 squares are preserved. It assesses each pixel's neighborhood to determine whether it should be removed, iterating until no further changes occur or the maximum number of iterations is reached.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef thin(image, max_num_iter=None): [MASK]\n"}
{"method_name": "_generate_thin_luts", "full_method_name": "_generate_thin_luts", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef _generate_thin_luts():\n    \"\"\"generate LUTs for thinning algorithm (for reference)\"\"\"\n\n    def nabe(n):\n        return np.array([(n >> i & 1) for i in range(0, 9)]).astype(bool)\n\n    def G1(n):\n        s = 0\n        bits = nabe(n)\n        for i in (0, 2, 4, 6):\n            if not bits[i] and (bits[i + 1] or bits[(i + 2) % 8]):\n                s += 1\n        return s == 1\n    g1_lut = np.array([G1(n) for n in range(256)])\n\n    def G2(n):\n        n1, n2 = 0, 0\n        bits = nabe(n)\n        for k in (1, 3, 5, 7):\n            if bits[k] or bits[k - 1]:\n                n1 += 1\n            if bits[k] or bits[(k + 1) % 8]:\n                n2 += 1\n        return min(n1, n2) in [2, 3]\n    g2_lut = np.array([G2(n) for n in range(256)])\n    g12_lut = g1_lut & g2_lut\n\n    def G3(n):\n        bits = nabe(n)\n        return not ((bits[1] or bits[2] or not bits[7]) and bits[0])\n\n    def G3p(n):\n        bits = nabe(n)\n        return not ((bits[5] or bits[6] or not bits[3]) and bits[4])\n    g3_lut = np.array([G3(n) for n in range(256)])\n    g3p_lut = np.array([G3p(n) for n in range(256)])\n    g123_lut = g12_lut & g3_lut\n    g123p_lut = g12_lut & g3p_lut\n    return g123_lut, g123p_lut", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestThin():\n\tdef test_lut_generation(self):\n\t    g123, g123p = _generate_thin_luts()\n\t    assert_array_equal(g123, G123_LUT)\n\t    assert_array_equal(g123p, G123P_LUT)\n\t\nTestThin().test_lut_generation()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "instruction": "Functionality: \nThe function _generate_thin_luts is designed to generate Look-Up Tables (LUTs) for a thinning algorithm. Thinning algorithms are used to reduce the width of lines or object boundaries in binary images while maintaining their essential structure. The LUTs generated by this function are crucial for efficiently applying the thinning algorithm to images.\n\nInputs:\nThis function does not take any input arguments. It generates LUTs internally using predefined logic.\n\nOutputs:\nThe function returns two arrays, g123_lut and g123p_lut, which are boolean arrays of size 256 each. These arrays represent the Look-Up Tables that define whether a pixel should be retained or removed based on its eight neighbors' states during the thinning process. The g123_lut and g123p_lut are used in subsequent steps of the thinning algorithm for different orientations.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _generate_thin_luts(): [MASK]\n"}
{"method_name": "medial_axis", "full_method_name": "medial_axis", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef medial_axis(image, mask=None, return_distance=False, *, rng=None):\n    \"\"\"Compute the medial axis transform of a binary image.\n\n    Parameters\n    ----------\n    image : binary ndarray, shape (M, N)\n        The image of the shape to skeletonize. If this input isn't already a\n        binary image, it gets converted into one: In this case, zero values are\n        considered background (False), nonzero values are considered\n        foreground (True).\n    mask : binary ndarray, shape (M, N), optional\n        If a mask is given, only those elements in `image` with a true\n        value in `mask` are used for computing the medial axis.\n    return_distance : bool, optional\n        If true, the distance transform is returned as well as the skeleton.\n    rng : {`numpy.random.Generator`, int}, optional\n        Pseudo-random number generator.\n        By default, a PCG64 generator is used (see :func:`numpy.random.default_rng`).\n        If `rng` is an int, it is used to seed the generator.\n\n        The PRNG determines the order in which pixels are processed for\n        tiebreaking.\n\n        .. versionadded:: 0.19\n\n    Returns\n    -------\n    out : ndarray of bools\n        Medial axis transform of the image\n    dist : ndarray of ints, optional\n        Distance transform of the image (only returned if `return_distance`\n        is True)\n\n    See Also\n    --------\n    skeletonize, thin\n\n    Notes\n    -----\n    This algorithm computes the medial axis transform of an image\n    as the ridges of its distance transform.\n\n    The different steps of the algorithm are as follows\n     * A lookup table is used, that assigns 0 or 1 to each configuration of\n       the 3x3 binary square, whether the central pixel should be removed\n       or kept. We want a point to be removed if it has more than one neighbor\n       and if removing it does not change the number of connected components.\n\n     * The distance transform to the background is computed, as well as\n       the cornerness of the pixel.\n\n     * The foreground (value of 1) points are ordered by\n       the distance transform, then the cornerness.\n\n     * A cython function is called to reduce the image to its skeleton. It\n       processes pixels in the order determined at the previous step, and\n       removes or maintains a pixel according to the lookup table. Because\n       of the ordering, it is possible to process all pixels in only one\n       pass.\n\n    Examples\n    --------\n    >>> square = np.zeros((7, 7), dtype=bool)\n    >>> square[1:-1, 2:-2] = 1\n    >>> square.view(np.uint8)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n    >>> medial_axis(square).view(np.uint8)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 1, 0, 1, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 1, 0, 1, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n\n    \"\"\"\n    global _eight_connect\n    if mask is None:\n        masked_image = image.astype(bool)\n    else:\n        masked_image = image.astype(bool).copy()\n        masked_image[~mask] = False\n    center_is_foreground = (np.arange(512) & 2 ** 4).astype(bool)\n    table = center_is_foreground & (np.array([(ndi.label(_pattern_of(index),\n        _eight_connect)[1] != ndi.label(_pattern_of(index & ~2 ** 4),\n        _eight_connect)[1]) for index in range(512)]) | np.array([(np.sum(\n        _pattern_of(index)) < 3) for index in range(512)]))\n    distance = ndi.distance_transform_edt(masked_image)\n    if return_distance:\n        store_distance = distance.copy()\n    cornerness_table = np.array([(9 - np.sum(_pattern_of(index))) for index in\n        range(512)])\n    corner_score = _table_lookup(masked_image, cornerness_table)\n    i, j = np.mgrid[0:image.shape[0], 0:image.shape[1]]\n    result = masked_image.copy()\n    distance = distance[result]\n    i = np.ascontiguousarray(i[result], dtype=np.intp)\n    j = np.ascontiguousarray(j[result], dtype=np.intp)\n    result = np.ascontiguousarray(result, np.uint8)\n    generator = np.random.default_rng(rng)\n    tiebreaker = generator.permutation(np.arange(masked_image.sum()))\n    order = np.lexsort((tiebreaker, corner_score[masked_image], distance))\n    order = np.ascontiguousarray(order, dtype=np.int32)\n    table = np.ascontiguousarray(table, dtype=np.uint8)\n    _skeletonize_loop(result, i, j, order, table)\n    result = result.astype(bool)\n    if mask is not None:\n        result[~mask] = image[~mask]\n    if return_distance:\n        return result, store_distance\n    else:\n        return result", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_00_00_zeros(self):\n\t    \"\"\"Test skeletonize on an array of all zeros\"\"\"\n\t    result = medial_axis(np.zeros((10, 10), bool))\n\t    assert np.all(result == False)\n\t\nTestMedialAxis().test_00_00_zeros()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_00_01_zeros_masked(self):\n\t    \"\"\"Test skeletonize on an array that is completely masked\"\"\"\n\t    result = medial_axis(np.zeros((10, 10), bool), np.zeros((10, 10), bool))\n\t    assert np.all(result == False)\n\t\nTestMedialAxis().test_00_01_zeros_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_01_01_rectangle(self):\n\t    \"\"\"Test skeletonize on a rectangle\"\"\"\n\t    image = np.zeros((9, 15), bool)\n\t    image[1:-1, 1:-1] = True\n\t    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0,\n\t        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0,\n\t        0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n\t        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0,\n\t        0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n\t        0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, \n\t        0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n\t    result = medial_axis(image)\n\t    assert np.all(result == expected)\n\t    result, distance = medial_axis(image, return_distance=True)\n\t    assert distance.max() == 4\n\t\nTestMedialAxis().test_01_01_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_01_02_hole(self):\n\t    \"\"\"Test skeletonize on a rectangle with a hole in the middle\"\"\"\n\t    image = np.zeros((9, 15), bool)\n\t    image[1:-1, 1:-1] = True\n\t    image[4, 4:-4] = False\n\t    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0,\n\t        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1,\n\t        1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n\t        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n\t        0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, \n\t        0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n\t    result = medial_axis(image)\n\t    assert np.all(result == expected)\n\t\nTestMedialAxis().test_01_02_hole()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_narrow_image(self):\n\t    \"\"\"Test skeletonize on a 1-pixel thin strip\"\"\"\n\t    image = np.zeros((1, 5), bool)\n\t    image[:, 1:-1] = True\n\t    result = medial_axis(image)\n\t    assert np.all(result == image)\n\t\nTestMedialAxis().test_narrow_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "instruction": "Functionality: Compute the medial axis transform of a binary image, which is essentially the skeleton of the image, highlighting the central ridges of objects in the image. The function can also return the distance transform of the image if requested.\n\nInputs: \n1. image: A binary ndarray of shape (M, N). The image of the shape to skeletonize. Zero values are considered background (False), and nonzero values are considered foreground (True).\n2. mask: Optional - A binary ndarray of shape (M, N). If provided, only those elements in 'image' with a true value in 'mask' are used for computing the medial axis.\n3. return_distance: Optional - A boolean. If True, the function also returns the distance transform of the image along with the skeleton.\n4. rng: Optional - A pseudo-random number generator or an int to seed the generator. Determines the order in which pixels are processed for tiebreaking.\n\nOutputs:\n1. out: An ndarray of bools representing the medial axis transform of the image.\n2. dist: Optional - An ndarray of ints, representing the distance transform of the image. This is only returned if 'return_distance' is True.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef medial_axis(image, mask=None, return_distance=False, *, rng=None): [MASK]\n"}
{"method_name": "flood_fill", "full_method_name": "flood_fill", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_flood_fill.py", "method_code": "import numpy as np\ndef flood_fill(image, seed_point, new_value, *, footprint=None,\n    connectivity=None, tolerance=None, in_place=False):\n    \"\"\"Perform flood filling on an image.\n\n    Starting at a specific `seed_point`, connected points equal or within\n    `tolerance` of the seed value are found, then set to `new_value`.\n\n    Parameters\n    ----------\n    image : ndarray\n        An n-dimensional array.\n    seed_point : tuple or int\n        The point in `image` used as the starting point for the flood fill.  If\n        the image is 1D, this point may be given as an integer.\n    new_value : `image` type\n        New value to set the entire fill.  This must be chosen in agreement\n        with the dtype of `image`.\n    footprint : ndarray, optional\n        The footprint (structuring element) used to determine the neighborhood\n        of each evaluated pixel. It must contain only 1's and 0's, have the\n        same number of dimensions as `image`. If not given, all adjacent pixels\n        are considered as part of the neighborhood (fully connected).\n    connectivity : int, optional\n        A number used to determine the neighborhood of each evaluated pixel.\n        Adjacent pixels whose squared distance from the center is less than or\n        equal to `connectivity` are considered neighbors. Ignored if\n        `footprint` is not None.\n    tolerance : float or int, optional\n        If None (default), adjacent values must be strictly equal to the\n        value of `image` at `seed_point` to be filled.  This is fastest.\n        If a tolerance is provided, adjacent points with values within plus or\n        minus tolerance from the seed point are filled (inclusive).\n    in_place : bool, optional\n        If True, flood filling is applied to `image` in place.  If False, the\n        flood filled result is returned without modifying the input `image`\n        (default).\n\n    Returns\n    -------\n    filled : ndarray\n        An array with the same shape as `image` is returned, with values in\n        areas connected to and equal (or within tolerance of) the seed point\n        replaced with `new_value`.\n\n    Notes\n    -----\n    The conceptual analogy of this operation is the 'paint bucket' tool in many\n    raster graphics programs.\n\n    Examples\n    --------\n    >>> from skimage.morphology import flood_fill\n    >>> image = np.zeros((4, 7), dtype=int)\n    >>> image[1:3, 1:3] = 1\n    >>> image[3, 0] = 1\n    >>> image[1:3, 4:6] = 2\n    >>> image[3, 6] = 3\n    >>> image\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [1, 0, 0, 0, 0, 0, 3]])\n\n    Fill connected ones with 5, with full connectivity (diagonals included):\n\n    >>> flood_fill(image, (1, 1), 5)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [5, 0, 0, 0, 0, 0, 3]])\n\n    Fill connected ones with 5, excluding diagonal points (connectivity 1):\n\n    >>> flood_fill(image, (1, 1), 5, connectivity=1)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [1, 0, 0, 0, 0, 0, 3]])\n\n    Fill with a tolerance:\n\n    >>> flood_fill(image, (0, 0), 5, tolerance=1)\n    array([[5, 5, 5, 5, 5, 5, 5],\n           [5, 5, 5, 5, 2, 2, 5],\n           [5, 5, 5, 5, 2, 2, 5],\n           [5, 5, 5, 5, 5, 5, 3]])\n    \"\"\"\n    mask = flood(image, seed_point, footprint=footprint, connectivity=\n        connectivity, tolerance=tolerance)\n    if not in_place:\n        image = image.copy()\n    image[mask] = new_value\n    return image", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_empty_input():\n    output = flood_fill(np.empty(0), (), 2)\n    assert output.size == 0\n    assert flood(np.empty(0), ()).dtype == bool\n    assert flood(np.empty((20, 0, 4)), ()).shape == (20, 0, 4)\n\ntest_empty_input()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_overrange_tolerance_float():\n    max_value = np.finfo(np.float32).max\n    image = np.random.uniform(size=(64, 64), low=-1.0, high=1.0).astype(np.\n        float32)\n    image *= max_value\n    expected = np.ones_like(image)\n    output = flood_fill(image, (0, 1), 1.0, tolerance=max_value.item() * 10)\n    np.testing.assert_equal(output, expected)\n\ntest_overrange_tolerance_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_int():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]])\n    flood_fill(image, (0, 0), 5, in_place=True)\n    expected = np.array([[5, 5, 5, 5, 5, 5, 5], [5, 1, 1, 5, 2, 2, 5], [5, \n        1, 1, 5, 2, 2, 5], [1, 5, 5, 5, 5, 5, 3], [5, 1, 1, 1, 3, 3, 4]])\n    np.testing.assert_array_equal(image, expected)\n\ntest_inplace_int()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_float():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]],\n        dtype=np.float32)\n    flood_fill(image, (0, 0), 5, in_place=True)\n    expected = np.array([[5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [5.0, 1.0, \n        1.0, 5.0, 2.0, 2.0, 5.0], [5.0, 1.0, 1.0, 5.0, 2.0, 2.0, 5.0], [1.0,\n        5.0, 5.0, 5.0, 5.0, 5.0, 3.0], [5.0, 1.0, 1.0, 1.0, 3.0, 3.0, 4.0]],\n        dtype=np.float32)\n    np.testing.assert_allclose(image, expected)\n\ntest_inplace_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_noncontiguous():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]])\n    image2 = image[::2, ::2]\n    flood_fill(image2, (0, 0), 5, in_place=True)\n    expected2 = np.array([[5, 5, 5, 5], [5, 1, 2, 5], [5, 1, 3, 4]])\n    np.testing.assert_allclose(image2, expected2)\n    expected = np.array([[5, 0, 5, 0, 5, 0, 5], [0, 1, 1, 0, 2, 2, 0], [5, \n        1, 1, 0, 2, 2, 5], [1, 0, 0, 0, 0, 0, 3], [5, 1, 1, 1, 3, 3, 4]])\n    np.testing.assert_allclose(image, expected)\n\ntest_inplace_noncontiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_1d():\n    image = np.arange(11)\n    expected = np.array([0, 1, -20, -20, -20, -20, -20, -20, -20, 9, 10])\n    output = flood_fill(image, 5, -20, tolerance=3)\n    output2 = flood_fill(image, (5,), -20, tolerance=3)\n    np.testing.assert_equal(output, expected)\n    np.testing.assert_equal(output, output2)\n\ntest_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_wraparound():\n    test = np.zeros((5, 7), dtype=np.float64)\n    test[:, 3] = 100\n    expected = np.array([[-1.0, -1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -\n        1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -1.0, -1.0, 100.0, 0.0, \n        0.0, 0.0], [-1.0, -1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -1.0, -\n        1.0, 100.0, 0.0, 0.0, 0.0]])\n    np.testing.assert_equal(flood_fill(test, (0, 0), -1), expected)\n\ntest_wraparound()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_neighbors():\n    test = np.zeros((5, 7), dtype=np.float64)\n    test[:, 3] = 100\n    expected = np.array([[0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0, 0, 0],\n        [0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0,\n        0, 0]])\n    output = flood_fill(test, (0, 3), 255)\n    np.testing.assert_equal(output, expected)\n    test[2] = 100\n    expected[2] = 255\n    output2 = flood_fill(test, (2, 3), 255)\n    np.testing.assert_equal(output2, expected)\n\ntest_neighbors()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_basic_nd():\n    for dimension in (3, 4, 5):\n        shape = (5,) * dimension\n        hypercube = np.zeros(shape)\n        slice_mid = tuple(slice(1, -1, None) for dim in range(dimension))\n        hypercube[slice_mid] = 1\n        filled = flood_fill(hypercube, (2,) * dimension, 2)\n        assert filled.sum() == 3 ** dimension * 2\n        np.testing.assert_equal(filled, np.pad(np.ones((3,) * dimension) * \n            2, 1, 'constant'))\n\ntest_basic_nd()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_negative_indexing_seed_point():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]],\n        dtype=np.float32)\n    expected = np.array([[5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [5.0, 1.0, \n        1.0, 5.0, 2.0, 2.0, 5.0], [5.0, 1.0, 1.0, 5.0, 2.0, 2.0, 5.0], [1.0,\n        5.0, 5.0, 5.0, 5.0, 5.0, 3.0], [5.0, 1.0, 1.0, 1.0, 3.0, 3.0, 4.0]],\n        dtype=np.float32)\n    image = flood_fill(image, (0, -1), 5)\n    np.testing.assert_allclose(image, expected)\n\ntest_negative_indexing_seed_point()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}], "instruction": "Functionality: The flood_fill function performs a flood fill operation, similar to the 'paint bucket' tool in raster graphics programs. It starts at a specific seed point and fills all connected points that are equal to or within a specified tolerance of the seed value with a new value.\n\nInputs: \n1. image: An n-dimensional array representing the image.\n2. seed_point: A tuple or integer indicating the starting point for the flood fill operation. For 1D images, it can be an integer.\n3. new_value: The new value to set in the filled area, which must match the dtype of the image.\n4. footprint: An optional ndarray that defines the neighborhood for each evaluated pixel. It should contain only 1's and 0's and have the same number of dimensions as the image.\n5. connectivity: An optional integer that defines the neighborhood for each evaluated pixel based on squared distance. Ignored if footprint is provided.\n6. tolerance: An optional float or int that allows filling adjacent points if their values are within the specified tolerance from the seed point value.\n7. in_place: An optional boolean. If True, the flood fill is applied to the image in place. If False, the result is returned without modifying the input image.\n\nOutputs: \n1. filled: An ndarray with the same shape as the input image, where areas connected to and equal (or within tolerance of) the seed point are replaced with the new_value.", "method_code_mask": "import numpy as np\n\n\ndef flood_fill(image, seed_point, new_value, *, footprint=None,\n    connectivity=None, tolerance=None, in_place=False): [MASK]\n"}
{"method_name": "flood", "full_method_name": "flood", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/_flood_fill.py", "method_code": "import numpy as np\ndef flood(image, seed_point, *, footprint=None, connectivity=None,\n    tolerance=None):\n    \"\"\"Mask corresponding to a flood fill.\n\n    Starting at a specific `seed_point`, connected points equal or within\n    `tolerance` of the seed value are found.\n\n    Parameters\n    ----------\n    image : ndarray\n        An n-dimensional array.\n    seed_point : tuple or int\n        The point in `image` used as the starting point for the flood fill.  If\n        the image is 1D, this point may be given as an integer.\n    footprint : ndarray, optional\n        The footprint (structuring element) used to determine the neighborhood\n        of each evaluated pixel. It must contain only 1's and 0's, have the\n        same number of dimensions as `image`. If not given, all adjacent pixels\n        are considered as part of the neighborhood (fully connected).\n    connectivity : int, optional\n        A number used to determine the neighborhood of each evaluated pixel.\n        Adjacent pixels whose squared distance from the center is less than or\n        equal to `connectivity` are considered neighbors. Ignored if\n        `footprint` is not None.\n    tolerance : float or int, optional\n        If None (default), adjacent values must be strictly equal to the\n        initial value of `image` at `seed_point`.  This is fastest.  If a value\n        is given, a comparison will be done at every point and if within\n        tolerance of the initial value will also be filled (inclusive).\n\n    Returns\n    -------\n    mask : ndarray\n        A Boolean array with the same shape as `image` is returned, with True\n        values for areas connected to and equal (or within tolerance of) the\n        seed point.  All other values are False.\n\n    Notes\n    -----\n    The conceptual analogy of this operation is the 'paint bucket' tool in many\n    raster graphics programs.  This function returns just the mask\n    representing the fill.\n\n    If indices are desired rather than masks for memory reasons, the user can\n    simply run `numpy.nonzero` on the result, save the indices, and discard\n    this mask.\n\n    Examples\n    --------\n    >>> from skimage.morphology import flood\n    >>> image = np.zeros((4, 7), dtype=int)\n    >>> image[1:3, 1:3] = 1\n    >>> image[3, 0] = 1\n    >>> image[1:3, 4:6] = 2\n    >>> image[3, 6] = 3\n    >>> image\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [0, 1, 1, 0, 2, 2, 0],\n           [1, 0, 0, 0, 0, 0, 3]])\n\n    Fill connected ones with 5, with full connectivity (diagonals included):\n\n    >>> mask = flood(image, (1, 1))\n    >>> image_flooded = image.copy()\n    >>> image_flooded[mask] = 5\n    >>> image_flooded\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [5, 0, 0, 0, 0, 0, 3]])\n\n    Fill connected ones with 5, excluding diagonal points (connectivity 1):\n\n    >>> mask = flood(image, (1, 1), connectivity=1)\n    >>> image_flooded = image.copy()\n    >>> image_flooded[mask] = 5\n    >>> image_flooded\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [0, 5, 5, 0, 2, 2, 0],\n           [1, 0, 0, 0, 0, 0, 3]])\n\n    Fill with a tolerance:\n\n    >>> mask = flood(image, (0, 0), tolerance=1)\n    >>> image_flooded = image.copy()\n    >>> image_flooded[mask] = 5\n    >>> image_flooded\n    array([[5, 5, 5, 5, 5, 5, 5],\n           [5, 5, 5, 5, 2, 2, 5],\n           [5, 5, 5, 5, 2, 2, 5],\n           [5, 5, 5, 5, 5, 5, 3]])\n    \"\"\"\n    image = np.asarray(image)\n    if image.flags.f_contiguous is True:\n        order = 'F'\n    elif image.flags.c_contiguous is True:\n        order = 'C'\n    else:\n        image = np.ascontiguousarray(image)\n        order = 'C'\n    if 0 in image.shape:\n        return np.zeros(image.shape, dtype=bool)\n    try:\n        iter(seed_point)\n    except TypeError:\n        seed_point = seed_point,\n    seed_value = image[seed_point]\n    seed_point = tuple(np.asarray(seed_point) % image.shape)\n    footprint = _resolve_neighborhood(footprint, connectivity, image.ndim,\n        enforce_adjacency=False)\n    center = tuple(s // 2 for s in footprint.shape)\n    pad_width = [((np.max(np.abs(idx - c)),) * 2) for idx, c in zip(np.\n        nonzero(footprint), center)]\n    working_image = np.pad(image, pad_width, mode='constant',\n        constant_values=image.min())\n    ravelled_seed_idx = np.ravel_multi_index([(i + pad_start) for i, (\n        pad_start, pad_end) in zip(seed_point, pad_width)], working_image.\n        shape, order=order)\n    neighbor_offsets = _offsets_to_raveled_neighbors(working_image.shape,\n        footprint, center=center, order=order)\n    flags = np.zeros(working_image.shape, dtype=np.uint8, order=order)\n    _set_border_values(flags, value=2, border_width=pad_width)\n    try:\n        if tolerance is not None:\n            tolerance = abs(tolerance)\n            min_value, max_value = numeric_dtype_min_max(seed_value.dtype)\n            low_tol = max(min_value.item(), seed_value.item() - tolerance)\n            high_tol = min(max_value.item(), seed_value.item() + tolerance)\n            _flood_fill_tolerance(working_image.ravel(order), flags.ravel(\n                order), neighbor_offsets, ravelled_seed_idx, seed_value,\n                low_tol, high_tol)\n        else:\n            _flood_fill_equal(working_image.ravel(order), flags.ravel(order\n                ), neighbor_offsets, ravelled_seed_idx, seed_value)\n    except TypeError:\n        if working_image.dtype == np.float16:\n            raise TypeError(\n                'dtype of `image` is float16 which is not supported, try upcasting to float32'\n                )\n        else:\n            raise\n    return crop(flags, pad_width, copy=False).view(bool)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_empty_input():\n    output = flood_fill(np.empty(0), (), 2)\n    assert output.size == 0\n    assert flood(np.empty(0), ()).dtype == bool\n    assert flood(np.empty((20, 0, 4)), ()).shape == (20, 0, 4)\n\ntest_empty_input()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}], "instruction": "Functionality: The flood function performs a flood fill operation on an n-dimensional array (image), starting from a seed point. Adjacent points equal or within a specified tolerance of the seed value are filled, determined by a footprint or connectivity parameter.\n\nInputs:\n- image: An n-dimensional array representing the image to be processed.\n- seed_point: A tuple or int specifying the point in the image used as the starting point for the flood fill operation. If the image is 1D, this point may be given as an integer.\n- footprint: A 2D array of 1s and 0s that determines the neighborhood of each evaluated pixel. This parameter is optional, and if not provided, all adjacent pixels are considered part of the neighborhood.\n- connectivity: An integer that determines the neighborhood of each evaluated pixel. Adjacent pixels within a certain squared distance from the center are considered neighbors. This parameter is ignored if a footprint is provided.\n- tolerance: A float or int that specifies the tolerance for filling adjacent values. If None, adjacent values must be strictly equal to the initial value of the image at the seed point. If a value is given, a comparison is done at every point, and if within tolerance of the initial value, the pixel will also be filled.\n\nOutputs:\n- mask: A Boolean array with the same shape as the input image. True values indicate areas connected to and equal (or within tolerance of) the seed point. All other values are False.", "method_code_mask": "import numpy as np\n\n\ndef flood(image, seed_point, *, footprint=None, connectivity=None,\n    tolerance=None): [MASK]\n"}
{"method_name": "learn_gmm", "full_method_name": "learn_gmm", "method_path": "../srcdata/Computation/scikit-image/skimage/feature/_fisher_vector.py", "method_code": "import numpy as np\nfrom sklearn.mixture import GaussianMixture\ndef learn_gmm(descriptors, *, n_modes=32, gm_args=None):\n    \"\"\"Estimate a Gaussian mixture model (GMM) given a set of descriptors and\n    number of modes (i.e. Gaussians). This function is essentially a wrapper\n    around the scikit-learn implementation of GMM, namely the\n    :class:`sklearn.mixture.GaussianMixture` class.\n\n    Due to the nature of the Fisher vector, the only enforced parameter of the\n    underlying scikit-learn class is the covariance_type, which must be 'diag'.\n\n    There is no simple way to know what value to use for `n_modes` a-priori.\n    Typically, the value is usually one of ``{16, 32, 64, 128}``. One may train\n    a few GMMs and choose the one that maximises the log probability of the\n    GMM, or choose `n_modes` such that the downstream classifier trained on\n    the resultant Fisher vectors has maximal performance.\n\n    Parameters\n    ----------\n    descriptors : np.ndarray (N, M) or list [(N1, M), (N2, M), ...]\n        List of NumPy arrays, or a single NumPy array, of the descriptors\n        used to estimate the GMM. The reason a list of NumPy arrays is\n        permissible is because often when using a Fisher vector encoding,\n        descriptors/vectors are computed separately for each sample/image in\n        the dataset, such as SIFT vectors for each image. If a list if passed\n        in, then each element must be a NumPy array in which the number of\n        rows may differ (e.g. different number of SIFT vector for each image),\n        but the number of columns for each must be the same (i.e. the\n        dimensionality must be the same).\n    n_modes : int\n        The number of modes/Gaussians to estimate during the GMM estimate.\n    gm_args : dict\n        Keyword arguments that can be passed into the underlying scikit-learn\n        :class:`sklearn.mixture.GaussianMixture` class.\n\n    Returns\n    -------\n    gmm : :class:`sklearn.mixture.GaussianMixture`\n        The estimated GMM object, which contains the necessary parameters\n        needed to compute the Fisher vector.\n\n    References\n    ----------\n    .. [1] https://scikit-learn.org/stable/modules/generated/sklearn.mixture.GaussianMixture.html\n\n    Examples\n    --------\n    .. testsetup::\n        >>> import pytest; _ = pytest.importorskip('sklearn')\n\n    >>> from skimage.feature import fisher_vector\n    >>> rng = np.random.Generator(np.random.PCG64())\n    >>> sift_for_images = [rng.standard_normal((10, 128)) for _ in range(10)]\n    >>> num_modes = 16\n    >>> # Estimate 16-mode GMM with these synthetic SIFT vectors\n    >>> gmm = learn_gmm(sift_for_images, n_modes=num_modes)\n    \"\"\"\n    try:\n        from sklearn.mixture import GaussianMixture\n    except ImportError:\n        raise ImportError(\n            'scikit-learn is not installed. Please ensure it is installed in order to use the Fisher vector functionality.'\n            )\n    if not isinstance(descriptors, (list, np.ndarray)):\n        raise DescriptorException(\n            'Please ensure descriptors are either a NumPy array, or a list of NumPy arrays.'\n            )\n    d_mat_1 = descriptors[0]\n    if isinstance(descriptors, list) and not isinstance(d_mat_1, np.ndarray):\n        raise DescriptorException(\n            'Please ensure descriptors are a list of NumPy arrays.')\n    if isinstance(descriptors, list):\n        expected_shape = descriptors[0].shape\n        ranks = [(len(e.shape) == len(expected_shape)) for e in descriptors]\n        if not all(ranks):\n            raise DescriptorException(\n                'Please ensure all elements of your descriptor list are of rank 2.'\n                )\n        dims = [(e.shape[1] == descriptors[0].shape[1]) for e in descriptors]\n        if not all(dims):\n            raise DescriptorException(\n                'Please ensure all descriptors are of the same dimensionality.'\n                )\n    if not isinstance(n_modes, int) or n_modes <= 0:\n        raise FisherVectorException(\n            'Please ensure n_modes is a positive integer.')\n    if gm_args:\n        has_cov_type = 'covariance_type' in gm_args\n        cov_type_not_diag = gm_args['covariance_type'] != 'diag'\n        if has_cov_type and cov_type_not_diag:\n            raise FisherVectorException('Covariance type must be \"diag\".')\n    if isinstance(descriptors, list):\n        descriptors = np.vstack(descriptors)\n    if gm_args:\n        has_cov_type = 'covariance_type' in gm_args\n        if has_cov_type:\n            gmm = GaussianMixture(n_components=n_modes, **gm_args)\n        else:\n            gmm = GaussianMixture(n_components=n_modes, covariance_type=\n                'diag', **gm_args)\n    else:\n        gmm = GaussianMixture(n_components=n_modes, covariance_type='diag')\n    gmm.fit(descriptors)\n    return gmm", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom sklearn.mixture import GaussianMixture\ndef test_gmm_correct_covariance_type():\n    \"\"\"Test that GMM estimation is successful when the correct covariance type\n    is passed in as a keyword argument.\n    \"\"\"\n    gmm = learn_gmm(np.random.random((10, 10)), n_modes=2, gm_args={\n        'covariance_type': 'diag'})\n    assert gmm.means_ is not None\n    assert gmm.covariances_ is not None\n    assert gmm.weights_ is not None\n\ntest_gmm_correct_covariance_type()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_fisher_vector.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom sklearn.mixture import GaussianMixture\ndef test_gmm_e2e():\n    \"\"\"\n    Test the GMM estimation. Since this is essentially a wrapper for the\n    scikit-learn GaussianMixture class, the testing of the actual inner\n    workings of the GMM estimation is left to scikit-learn and its\n    dependencies.\n\n    We instead simply assert that the estimation was successful based on the\n    fact that the GMM object will have associated mixture weights, means, and\n    variances after estimation is successful/complete.\n    \"\"\"\n    gmm = learn_gmm(np.random.random((100, 64)), n_modes=5)\n    assert gmm.means_ is not None\n    assert gmm.covariances_ is not None\n    assert gmm.weights_ is not None\n\ntest_gmm_e2e()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_fisher_vector.py"}], "instruction": "Functionality: Estimate a Gaussian mixture model (GMM) given a set of descriptors and a number of modes (Gaussians). This function acts as a wrapper around the scikit-learn GMM implementation, ensuring the covariance_type is 'diag' as required for Fisher vector computation.\n\nInputs:\n    descriptors: np.ndarray (N, M) or list [(N1, M), (N2, M), ...]\n        A single NumPy array or a list of NumPy arrays representing the descriptors used to estimate the GMM. Each array can have a different number of rows but must have the same number of columns.\n    n_modes: int\n        The number of modes/Gaussians to be estimated in the GMM. Default is 32.\n    gm_args: dict\n        Additional keyword arguments that can be passed to the sklearn.mixture.GaussianMixture class. By default, this is None.\n\nOutputs:\n    gmm: sklearn.mixture.GaussianMixture\n        The estimated GMM object, containing parameters necessary for computing the Fisher vector.", "method_code_mask": "import numpy as np\nfrom sklearn.mixture import GaussianMixture\n\n\ndef learn_gmm(descriptors, *, n_modes=32, gm_args=None): [MASK]\n"}
{"method_name": "ellipsoid", "full_method_name": "ellipsoid", "method_path": "../srcdata/Computation/scikit-image/skimage/draw/draw3d.py", "method_code": "import numpy as np\nfrom scipy.special import ellipkinc as ellip_F\nfrom scipy.special import ellipeinc as ellip_E\ndef ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False):\n    \"\"\"\n    Generates ellipsoid with semimajor axes aligned with grid dimensions\n    on grid with specified `spacing`.\n\n    Parameters\n    ----------\n    a : float\n        Length of semimajor axis aligned with x-axis.\n    b : float\n        Length of semimajor axis aligned with y-axis.\n    c : float\n        Length of semimajor axis aligned with z-axis.\n    spacing : 3-tuple of floats\n        Spacing in three spatial dimensions.\n    levelset : bool\n        If True, returns the level set for this ellipsoid (signed level\n        set about zero, with positive denoting interior) as np.float64.\n        False returns a binarized version of said level set.\n\n    Returns\n    -------\n    ellipsoid : (M, N, P) array\n        Ellipsoid centered in a correctly sized array for given `spacing`.\n        Boolean dtype unless `levelset=True`, in which case a float array is\n        returned with the level set above 0.0 representing the ellipsoid.\n\n    \"\"\"\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError('Parameters a, b, and c must all be > 0')\n    offset = np.r_[1, 1, 1] * np.r_[spacing]\n    low = np.ceil(-np.r_[a, b, c] - offset)\n    high = np.floor(np.r_[a, b, c] + offset + 1)\n    for dim in range(3):\n        if (high[dim] - low[dim]) % 2 == 0:\n            low[dim] -= 1\n        num = np.arange(low[dim], high[dim], spacing[dim])\n        if 0 not in num:\n            low[dim] -= np.max(num[num < 0])\n    x, y, z = np.mgrid[low[0]:high[0]:spacing[0], low[1]:high[1]:spacing[1],\n        low[2]:high[2]:spacing[2]]\n    if not levelset:\n        arr = (x / float(a)) ** 2 + (y / float(b)) ** 2 + (z / float(c)\n            ) ** 2 <= 1\n    else:\n        arr = (x / float(a)) ** 2 + (y / float(b)) ** 2 + (z / float(c)\n            ) ** 2 - 1\n    return arr", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_3d():\n    r = 6\n    pad = 10\n    im3 = ellipsoid(r, r, r)\n    im3 = np.pad(im3, pad, mode='constant')\n    blobs = blob_log(im3, min_sigma=3, max_sigma=10)\n    b = blobs[0]\n    assert b.shape == (4,)\n    assert b[0] == r + pad + 1\n    assert b[1] == r + pad + 1\n    assert b[2] == r + pad + 1\n    assert abs(math.sqrt(3) * b[3] - r) < 1\n\ntest_blob_log_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_3d_anisotropic():\n    r = 6\n    pad = 10\n    im3 = ellipsoid(r / 2, r, r)\n    im3 = np.pad(im3, pad, mode='constant')\n    blobs = blob_log(im3, min_sigma=[1, 2, 2], max_sigma=[5, 10, 10])\n    b = blobs[0]\n    assert b.shape == (6,)\n    assert b[0] == r / 2 + pad + 1\n    assert b[1] == r + pad + 1\n    assert b[2] == r + pad + 1\n    assert abs(math.sqrt(3) * b[3] - r / 2) < 1\n    assert abs(math.sqrt(3) * b[4] - r) < 1\n    assert abs(math.sqrt(3) * b[5] - r) < 1\n\ntest_blob_log_3d_anisotropic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=2, max_sigma=10, overlap=0.1)\n    assert len(blobs) == 1\n\ntest_blob_log_overlap_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d_anisotropic():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=[2, 2.01, 2.005], max_sigma=10, overlap=0.1\n        )\n    assert len(blobs) == 1\n    overlap = _blob_overlap(np.array([0, 0, 10 / math.sqrt(2)]), np.array([\n        0, 10, 10 / math.sqrt(2)]))\n    assert_almost_equal(overlap, 1.0 / math.pi * (2 * math.acos(1.0 / 2) - \n        math.sqrt(3) / 2.0))\n\ntest_blob_log_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}], "instruction": "Functionality: Generates an ellipsoid with semimajor axes aligned with grid dimensions on a grid with specified spacing. The ellipsoid can be returned as a binary representation or as a level set representation.\n\nInputs:\n- a : float\n    Length of semimajor axis aligned with the x-axis.\n- b : float\n    Length of semimajor axis aligned with the y-axis.\n- c : float\n    Length of semimajor axis aligned with the z-axis.\n- spacing : 3-tuple of floats (optional, default=(1.0, 1.0, 1.0))\n    Spacing in three spatial dimensions.\n- levelset : bool (optional, default=False)\n    If True, returns the level set for the ellipsoid (signed level set about zero, with positive denoting interior) as np.float64. If False, returns a binarized version of said level set.\n\nOutputs:\n- ellipsoid : (M, N, P) array\n    Ellipsoid centered in a correctly sized array for the given `spacing`. The dtype of the array is boolean unless `levelset=True`, in which case a float array is returned with the level set above 0.0 representing the ellipsoid's interior.", "method_code_mask": "import numpy as np\nfrom scipy.special import ellipkinc as ellip_F\nfrom scipy.special import ellipeinc as ellip_E\n\n\ndef ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False): [MASK]\n"}
{"method_name": "_blob_overlap", "full_method_name": "_blob_overlap", "method_path": "../srcdata/Computation/scikit-image/skimage/feature/blob.py", "method_code": "import math\nimport numpy as np\nimport scipy.ndimage as ndi\nfrom scipy import spatial\ndef _blob_overlap(blob1, blob2, *, sigma_dim=1):\n    \"\"\"Finds the overlapping area fraction between two blobs.\n\n    Returns a float representing fraction of overlapped area. Note that 0.0\n    is *always* returned for dimension greater than 3.\n\n    Parameters\n    ----------\n    blob1 : sequence of arrays\n        A sequence of ``(row, col, sigma)`` or ``(pln, row, col, sigma)``,\n        where ``row, col`` (or ``(pln, row, col)``) are coordinates\n        of blob and ``sigma`` is the standard deviation of the Gaussian kernel\n        which detected the blob.\n    blob2 : sequence of arrays\n        A sequence of ``(row, col, sigma)`` or ``(pln, row, col, sigma)``,\n        where ``row, col`` (or ``(pln, row, col)``) are coordinates\n        of blob and ``sigma`` is the standard deviation of the Gaussian kernel\n        which detected the blob.\n    sigma_dim : int, optional\n        The dimensionality of the sigma value. Can be 1 or the same as the\n        dimensionality of the blob space (2 or 3).\n\n    Returns\n    -------\n    f : float\n        Fraction of overlapped area (or volume in 3D).\n    \"\"\"\n    ndim = len(blob1) - sigma_dim\n    if ndim > 3:\n        return 0.0\n    root_ndim = math.sqrt(ndim)\n    if blob1[-1] == blob2[-1] == 0:\n        return 0.0\n    elif blob1[-1] > blob2[-1]:\n        max_sigma = blob1[-sigma_dim:]\n        r1 = 1\n        r2 = blob2[-1] / blob1[-1]\n    else:\n        max_sigma = blob2[-sigma_dim:]\n        r2 = 1\n        r1 = blob1[-1] / blob2[-1]\n    pos1 = blob1[:ndim] / (max_sigma * root_ndim)\n    pos2 = blob2[:ndim] / (max_sigma * root_ndim)\n    d = np.sqrt(np.sum((pos2 - pos1) ** 2))\n    if d > r1 + r2:\n        return 0.0\n    if d <= abs(r1 - r2):\n        return 1.0\n    if ndim == 2:\n        return _compute_disk_overlap(d, r1, r2)\n    else:\n        return _compute_sphere_overlap(d, r1, r2)", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_overlap_3d_anisotropic():\n    s3 = math.sqrt(3)\n    overlap = _blob_overlap(np.array([0, 0, 0, 2 / s3, 10 / s3, 10 / s3]),\n        np.array([0, 0, 10, 0.2 / s3, 1 / s3, 1 / s3]), sigma_dim=3)\n    assert_almost_equal(overlap, 0.48125)\n    overlap = _blob_overlap(np.array([0, 0, 0, 2 / s3, 10 / s3, 10 / s3]),\n        np.array([2, 0, 0, 0.2 / s3, 1 / s3, 1 / s3]), sigma_dim=3)\n    assert_almost_equal(overlap, 0.48125)\n\ntest_blob_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d_anisotropic():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=[2, 2.01, 2.005], max_sigma=10, overlap=0.1\n        )\n    assert len(blobs) == 1\n    overlap = _blob_overlap(np.array([0, 0, 10 / math.sqrt(2)]), np.array([\n        0, 10, 10 / math.sqrt(2)]))\n    assert_almost_equal(overlap, 1.0 / math.pi * (2 * math.acos(1.0 / 2) - \n        math.sqrt(3) / 2.0))\n\ntest_blob_log_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}], "instruction": "Functionality: _blob_overlap calculates the fraction of overlapping area (or volume in 3D) between two blobs detected by Gaussian kernels. The function is designed to work with 2D and 3D coordinate systems and takes the standard deviation of the Gaussian kernels into account.\n\nInputs: \n- blob1: A sequence representing the coordinates (row, col) or (pln, row, col) of the first blob and its standard deviation sigma.\n- blob2: A sequence representing the coordinates (row, col) or (pln, row, col) of the second blob and its standard deviation sigma.\n- sigma_dim: An optional integer parameter (default=1), indicating the dimensionality of the sigma value. This should be either 1 or equal to the dimensionality of the blob space (2 or 3).\n\nOutputs:\n- f: A float representing the fraction of the overlapped area (or volume in 3D). The function returns 0.0 for dimensions greater than 3.", "method_code_mask": "import math\nimport numpy as np\nimport scipy.ndimage as ndi\nfrom scipy import spatial\n\n\ndef _blob_overlap(blob1, blob2, *, sigma_dim=1): [MASK]\n"}
{"method_name": "_mask_border_keypoints", "full_method_name": "_mask_border_keypoints", "method_path": "../srcdata/Computation/scikit-image/skimage/feature/util.py", "method_code": "import numpy as np\ndef _mask_border_keypoints(image_shape, keypoints, distance):\n    \"\"\"Mask coordinates that are within certain distance from the image border.\n\n    Parameters\n    ----------\n    image_shape : (2,) array_like\n        Shape of the image as ``(rows, cols)``.\n    keypoints : (N, 2) array\n        Keypoint coordinates as ``(rows, cols)``.\n    distance : int\n        Image border distance.\n\n    Returns\n    -------\n    mask : (N,) bool array\n        Mask indicating if pixels are within the image (``True``) or in the\n        border region of the image (``False``).\n\n    \"\"\"\n    rows = image_shape[0]\n    cols = image_shape[1]\n    mask = (distance - 1 < keypoints[:, 0]) & (keypoints[:, 0] < rows -\n        distance + 1) & (distance - 1 < keypoints[:, 1]) & (keypoints[:, 1] <\n        cols - distance + 1)\n    return mask", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.feature.util import FeatureDetector\nfrom skimage.feature.util import DescriptorExtractor\nfrom skimage.feature.util import _prepare_grayscale_input_2D\nfrom skimage.feature.util import _mask_border_keypoints\nfrom skimage.feature.util import plot_matches\nfrom matplotlib import pyplot as plt\nfrom matplotlib import use\ndef test_mask_border_keypoints():\n    keypoints = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 0),\n        [1, 1, 1, 1, 1])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 2),\n        [0, 0, 1, 1, 1])\n    np.testing.assert_equal(_mask_border_keypoints((4, 4), keypoints, 2), [\n        0, 0, 1, 0, 0])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 5),\n        [0, 0, 0, 0, 0])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 4),\n        [0, 0, 0, 0, 1])\n\ntest_mask_border_keypoints()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/feature/tests/test_util.py"}], "instruction": "Functionality: The _mask_border_keypoints function is designed to identify and mask out keypoints that are within a specified distance from the borders of an image. This is useful for filtering out keypoints that might be unreliable due to their proximity to the image boundaries.\n\nInputs: \n    image_shape : (2,) array_like\n        The shape of the image as a tuple (rows, cols).\n    keypoints : (N, 2) array\n        An array of N keypoints, each represented by a tuple (row, col).\n    distance : int\n        The distance from the image border within which keypoints should be masked out.\n\nOutputs: \n    mask : (N,) bool array\n        A boolean mask where True indicates the keypoint is within the image and not in the border region, and False indicates the keypoint is too close to the border.", "method_code_mask": "import numpy as np\n\n\ndef _mask_border_keypoints(image_shape, keypoints, distance): [MASK]\n"}
{"method_name": "_stackcopy", "full_method_name": "_stackcopy", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/_warps.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef _stackcopy(a, b):\n    \"\"\"Copy b into each color layer of a, such that::\n\n      a[:,:,0] = a[:,:,1] = ... = b\n\n    Parameters\n    ----------\n    a : (M, N) or (M, N, P) ndarray\n        Target array.\n    b : (M, N)\n        Source array.\n\n    Notes\n    -----\n    Color images are stored as an ``(M, N, 3)`` or ``(M, N, 4)`` arrays.\n\n    \"\"\"\n    if a.ndim == 3:\n        a[:] = b[:, :, np.newaxis]\n    else:\n        a[:] = b", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_stackcopy():\n    layers = 4\n    x = np.empty((3, 3, layers))\n    y = np.eye(3, 3)\n    _stackcopy(x, y)\n    for i in range(layers):\n        assert_array_almost_equal(x[..., i], y)\n\ntest_stackcopy()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "instruction": "Functionality: The function _stackcopy is designed to copy the content of one 2D array (b) into each color layer of another array (a). This is particularly useful for operations on images where (a) might represent an RGB or RGBA image, and (b) is a single channel (e.g., grayscale) image that needs to be replicated across all color channels of (a).\n\nInputs: \n- a : An input array of shape (M, N) or (M, N, P). For color images, (M, N, 3) represents RGB images, and (M, N, 4) represents RGBA images.\n- b : A source array of shape (M, N) that is to be copied into each layer of (a).\n\nOutputs: \n- The function modifies (a) in-place, copying (b) into each color layer of (a). There is no explicit return value.\n\nNote: The function checks the dimensionality of (a). If (a) is a 3D array, it performs the copy operation into each color channel. If (a) is a 2D array, it simply assigns (b) to (a).", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _stackcopy(a, b): [MASK]\n"}
{"method_name": "resize", "full_method_name": "resize", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/_warps.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef resize(image, output_shape, order=None, mode='reflect', cval=0, clip=\n    True, preserve_range=False, anti_aliasing=None, anti_aliasing_sigma=None):\n    \"\"\"Resize image to match a certain size.\n\n    Performs interpolation to up-size or down-size N-dimensional images. Note\n    that anti-aliasing should be enabled when down-sizing images to avoid\n    aliasing artifacts. For downsampling with an integer factor also see\n    `skimage.transform.downscale_local_mean`.\n\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n    output_shape : iterable\n        Size of the generated output image `(rows, cols[, ...][, dim])`. If\n        `dim` is not provided, the number of channels is preserved. In case the\n        number of input channels does not equal the number of output channels a\n        n-dimensional interpolation is applied.\n\n    Returns\n    -------\n    resized : ndarray\n        Resized version of the input.\n\n    Other parameters\n    ----------------\n    order : int, optional\n        The order of the spline interpolation, default is 0 if\n        image.dtype is bool and 1 otherwise. The order has to be in\n        the range 0-5. See `skimage.transform.warp` for detail.\n    mode : {'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional\n        Points outside the boundaries of the input are filled according\n        to the given mode.  Modes match the behaviour of `numpy.pad`.\n    cval : float, optional\n        Used in conjunction with mode 'constant', the value outside\n        the image boundaries.\n    clip : bool, optional\n        Whether to clip the output to the range of values of the input image.\n        This is enabled by default, since higher order interpolation may\n        produce values outside the given input range.\n    preserve_range : bool, optional\n        Whether to keep the original range of values. Otherwise, the input\n        image is converted according to the conventions of `img_as_float`.\n        Also see https://scikit-image.org/docs/dev/user_guide/data_types.html\n    anti_aliasing : bool, optional\n        Whether to apply a Gaussian filter to smooth the image prior\n        to downsampling. It is crucial to filter when downsampling\n        the image to avoid aliasing artifacts. If not specified, it is set to\n        True when downsampling an image whose data type is not bool.\n        It is also set to False when using nearest neighbor interpolation\n        (``order`` == 0) with integer input data type.\n    anti_aliasing_sigma : {float, tuple of floats}, optional\n        Standard deviation for Gaussian filtering used when anti-aliasing.\n        By default, this value is chosen as (s - 1) / 2 where s is the\n        downsampling factor, where s > 1. For the up-size case, s < 1, no\n        anti-aliasing is performed prior to rescaling.\n\n    Notes\n    -----\n    Modes 'reflect' and 'symmetric' are similar, but differ in whether the edge\n    pixels are duplicated during the reflection.  As an example, if an array\n    has values [0, 1, 2] and was padded to the right by four values using\n    symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it\n    would be [0, 1, 2, 1, 0, 1, 2].\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.transform import resize\n    >>> image = data.camera()\n    >>> resize(image, (100, 100)).shape\n    (100, 100)\n\n    \"\"\"\n    image, output_shape = _preprocess_resize_output_shape(image, output_shape)\n    input_shape = image.shape\n    input_type = image.dtype\n    if input_type == np.float16:\n        image = image.astype(np.float32)\n    if anti_aliasing is None:\n        anti_aliasing = not input_type == bool and not (np.issubdtype(\n            input_type, np.integer) and order == 0) and any(x < y for x, y in\n            zip(output_shape, input_shape))\n    if input_type == bool and anti_aliasing:\n        raise ValueError('anti_aliasing must be False for boolean images')\n    factors = np.divide(input_shape, output_shape)\n    order = _validate_interpolation_order(input_type, order)\n    if order > 0:\n        image = convert_to_float(image, preserve_range)\n    ndi_mode = _to_ndimage_mode(mode)\n    if anti_aliasing:\n        if anti_aliasing_sigma is None:\n            anti_aliasing_sigma = np.maximum(0, (factors - 1) / 2)\n        else:\n            anti_aliasing_sigma = np.atleast_1d(anti_aliasing_sigma\n                ) * np.ones_like(factors)\n            if np.any(anti_aliasing_sigma < 0):\n                raise ValueError(\n                    'Anti-aliasing standard deviation must be greater than or equal to zero'\n                    )\n            elif np.any((anti_aliasing_sigma > 0) & (factors <= 1)):\n                warn(\n                    'Anti-aliasing standard deviation greater than zero but not down-sampling along all axes'\n                    )\n        filtered = ndi.gaussian_filter(image, anti_aliasing_sigma, cval=\n            cval, mode=ndi_mode)\n    else:\n        filtered = image\n    zoom_factors = [(1 / f) for f in factors]\n    out = ndi.zoom(filtered, zoom_factors, order=order, mode=ndi_mode, cval\n        =cval, grid_mode=True)\n    _clip_warp_output(image, out, mode, cval, clip)\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize2d():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    resized = resize(x, (10, 10), order=0, anti_aliasing=False, mode='constant'\n        )\n    ref = np.zeros((10, 10))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize2d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_keep():\n    x = np.zeros((5, 5, 3), dtype=np.float64)\n    x[1, 1, :] = 1\n    resized = resize(x, (10, 10), order=0, anti_aliasing=False, mode='constant'\n        )\n    with pytest.raises(ValueError):\n        resize(x, (10,), order=0, anti_aliasing=False, mode='constant')\n    ref = np.zeros((10, 10, 3))\n    ref[2:4, 2:4, :] = 1\n    assert_array_almost_equal(resized, ref)\n    resized = resize(x, (10, 10, 3), order=0, anti_aliasing=False, mode=\n        'constant')\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_keep()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_resize():\n    x = np.zeros((5, 5, 3), dtype=np.float64)\n    x[1, 1, :] = 1\n    resized = resize(x, (10, 10, 1), order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros((10, 10, 1))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_resize()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_2din_3dout():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    resized = resize(x, (10, 10, 1), order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros((10, 10, 1))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_2din_3dout()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize2d_4d():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    out_shape = 10, 10, 1, 1\n    resized = resize(x, out_shape, order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros(out_shape)\n    ref[2:4, 2:4, ...] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize2d_4d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize_nd():\n    for dim in range(1, 6):\n        shape = 2 + np.arange(dim) * 2\n        x = np.ones(shape)\n        out_shape = np.asarray(shape) * 1.5\n        resized = resize(x, out_shape, order=0, mode='reflect',\n            anti_aliasing=False)\n        expected_shape = 1.5 * shape\n        assert_array_equal(resized.shape, expected_shape)\n        assert np.all(resized == 1)\n\ntest_resize_nd()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_bilinear():\n    x = np.zeros((5, 5, 2), dtype=np.float64)\n    x[1, 1, 0] = 0\n    x[1, 1, 1] = 1\n    resized = resize(x, (10, 10, 1), order=1, mode='constant',\n        anti_aliasing=False)\n    ref = np.zeros((10, 10, 1))\n    ref[1:5, 1:5, :] = 0.03125\n    ref[1:5, 2:4, :] = 0.09375\n    ref[2:4, 1:5, :] = 0.09375\n    ref[2:4, 2:4, :] = 0.28125\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_bilinear()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_downsize_anti_aliasing():\n    x = np.zeros((10, 10), dtype=np.float64)\n    x[2, 2] = 1\n    scaled = resize(x, (5, 5), order=1, anti_aliasing=True, mode='constant')\n    assert scaled.shape == (5, 5)\n    assert np.all(scaled[:3, :3] > 0)\n    assert scaled[3:, :].sum() == 0\n    assert scaled[:, 3:].sum() == 0\n    sigma = 0.125\n    out_size = 5, 5\n    resize(x, out_size, order=1, mode='constant', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='edge', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='symmetric', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='reflect', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='wrap', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    with pytest.raises(ValueError):\n        resize(x, out_size, order=1, mode='non-existent', anti_aliasing=\n            True, anti_aliasing_sigma=sigma)\n\ntest_downsize_anti_aliasing()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_bool_img_resize():\n    img = np.ones((12, 18), dtype=bool)\n    img[2:-2, 4:-4] = False\n    res = resize(img, (6, 9))\n    expected = np.ones((6, 9))\n    expected[1:-1, 2:-2] = False\n    assert_array_equal(res, expected)\n\ntest_bool_img_resize()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "instruction": "Functionality: Resize image to match a certain size. Performs interpolation to up-size or down-size N-dimensional images. For downsampling with an integer factor, skimage.transform.downscale_local_mean is recommended.\n\nInputs:\n- image: ndarray, Input image.\n- output_shape: iterable, Size of the generated output image (rows, cols[, ...][, dim]). If dim is not provided, the number of channels is preserved.\n- order: int, optional, The order of the spline interpolation (default is 0 if image.dtype is bool and 1 otherwise). Must be in the range 0-5.\n- mode: {'constant', 'edge', 'symmetric', 'reflect', 'wrap'}, optional, Points outside the boundaries of the input are filled according to the given mode.\n- cval: float, optional, Used in conjunction with mode 'constant', the value outside the image boundaries.\n- clip: bool, optional, Whether to clip the output to the range of values of the input image (default is True).\n- preserve_range: bool, optional, Whether to keep the original range of values (default is False).\n- anti_aliasing: bool, optional, Whether to apply a Gaussian filter to smooth the image prior to downsampling (default is determined based on the image type and downsampling).\n- anti_aliasing_sigma: {float, tuple of floats}, optional, Standard deviation for Gaussian filtering used when anti-aliasing (default is chosen based on the downsampling factor).\n\nOutputs:\n- resized: ndarray, Resized version of the input.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef resize(image, output_shape, order=None, mode='reflect', cval=0, clip=\n    True, preserve_range=False, anti_aliasing=None, anti_aliasing_sigma=None\n    ): [MASK]\n"}
{"method_name": "warp_coords", "full_method_name": "warp_coords", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/_warps.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef warp_coords(coord_map, shape, dtype=np.float64):\n    \"\"\"Build the source coordinates for the output of a 2-D image warp.\n\n    Parameters\n    ----------\n    coord_map : callable like GeometricTransform.inverse\n        Return input coordinates for given output coordinates.\n        Coordinates are in the shape (P, 2), where P is the number\n        of coordinates and each element is a ``(row, col)`` pair.\n    shape : tuple\n        Shape of output image ``(rows, cols[, bands])``.\n    dtype : np.dtype or string\n        dtype for return value (sane choices: float32 or float64).\n\n    Returns\n    -------\n    coords : (ndim, rows, cols[, bands]) array of dtype `dtype`\n            Coordinates for `scipy.ndimage.map_coordinates`, that will yield\n            an image of shape (orows, ocols, bands) by drawing from source\n            points according to the `coord_transform_fn`.\n\n    Notes\n    -----\n\n    This is a lower-level routine that produces the source coordinates for 2-D\n    images used by `warp()`.\n\n    It is provided separately from `warp` to give additional flexibility to\n    users who would like, for example, to re-use a particular coordinate\n    mapping, to use specific dtypes at various points along the the\n    image-warping process, or to implement different post-processing logic\n    than `warp` performs after the call to `ndi.map_coordinates`.\n\n\n    Examples\n    --------\n    Produce a coordinate map that shifts an image up and to the right:\n\n    >>> from skimage import data\n    >>> from scipy.ndimage import map_coordinates\n    >>>\n    >>> def shift_up10_left20(xy):\n    ...     return xy - np.array([-20, 10])[None, :]\n    >>>\n    >>> image = data.astronaut().astype(np.float32)\n    >>> coords = warp_coords(shift_up10_left20, image.shape)\n    >>> warped_image = map_coordinates(image, coords)\n\n    \"\"\"\n    shape = safe_as_int(shape)\n    rows, cols = shape[0], shape[1]\n    coords_shape = [len(shape), rows, cols]\n    if len(shape) == 3:\n        coords_shape.append(shape[2])\n    coords = np.empty(coords_shape, dtype=dtype)\n    tf_coords = np.indices((cols, rows), dtype=dtype).reshape(2, -1).T\n    tf_coords = coord_map(tf_coords)\n    tf_coords = tf_coords.T.reshape((-1, cols, rows)).swapaxes(1, 2)\n    _stackcopy(coords[1, ...], tf_coords[0, ...])\n    _stackcopy(coords[0, ...], tf_coords[1, ...])\n    if len(shape) == 3:\n        coords[2, ...] = range(shape[2])\n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_warp_coords_example():\n    image = astronaut().astype(np.float32)\n    assert 3 == image.shape[2]\n    tform = SimilarityTransform(translation=(0, -10))\n    coords = warp_coords(tform, (30, 30, 3))\n    map_coordinates(image[:, :, 0], coords[:2])\n\ntest_warp_coords_example()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "instruction": "Functionality: The warp_coords function is designed to generate source coordinates for the output of a 2-D image warp operation. It facilitates the creation of a coordinate map that can be used by `scipy.ndimage.map_coordinates` to produce a warped image by drawing from source points according to a specified coordinate transformation function.\n\nInputs:\n- coord_map: A callable function that returns input coordinates for given output coordinates. It should take a set of output coordinates in the shape (P, 2) and return corresponding input coordinates.\n- shape: A tuple representing the shape of the output image in the format (rows, cols[, bands]).\n- dtype: A numpy dtype or string specifying the dtype for the return value. Commonly used dtypes include float32 or float64.\n\nOutputs:\n- coords: A (ndim, rows, cols[, bands]) array of dtype `dtype`. This array represents the coordinates for `scipy.ndimage.map_coordinates`, enabling the creation of an image of the specified shape by drawing from source points according to the `coord_map`.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef warp_coords(coord_map, shape, dtype=np.float64): [MASK]\n"}
{"method_name": "_linear_polar_mapping", "full_method_name": "_linear_polar_mapping", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/_warps.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef _linear_polar_mapping(output_coords, k_angle, k_radius, center):\n    \"\"\"Inverse mapping function to convert from cartesian to polar coordinates\n\n    Parameters\n    ----------\n    output_coords : (M, 2) ndarray\n        Array of `(col, row)` coordinates in the output image.\n    k_angle : float\n        Scaling factor that relates the intended number of rows in the output\n        image to angle: ``k_angle = nrows / (2 * np.pi)``.\n    k_radius : float\n        Scaling factor that relates the radius of the circle bounding the\n        area to be transformed to the intended number of columns in the output\n        image: ``k_radius = ncols / radius``.\n    center : tuple (row, col)\n        Coordinates that represent the center of the circle that bounds the\n        area to be transformed in an input image.\n\n    Returns\n    -------\n    coords : (M, 2) ndarray\n        Array of `(col, row)` coordinates in the input image that\n        correspond to the `output_coords` given as input.\n    \"\"\"\n    angle = output_coords[:, 1] / k_angle\n    rr = output_coords[:, 0] / k_radius * np.sin(angle) + center[0]\n    cc = output_coords[:, 0] / k_radius * np.cos(angle) + center[1]\n    coords = np.column_stack((cc, rr))\n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_linear_polar_mapping():\n    output_coords = np.array([[0, 0], [0, 90], [0, 180], [0, 270], [99, 0],\n        [99, 180], [99, 270], [99, 45]])\n    ground_truth = np.array([[100, 100], [100, 100], [100, 100], [100, 100],\n        [199, 100], [1, 100], [100, 1], [170.00357134, 170.00357134]])\n    k_angle = 360 / (2 * np.pi)\n    k_radius = 1\n    center = 100, 100\n    coords = _linear_polar_mapping(output_coords, k_angle, k_radius, center)\n    assert np.allclose(coords, ground_truth)\n\ntest_linear_polar_mapping()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "instruction": "Functionality: The _linear_polar_mapping function is designed to perform an inverse mapping from cartesian to polar coordinates. It calculates the corresponding cartesian coordinates in the input image for a set of polar coordinates in the output image.\n\nInputs: \noutput_coords: An (M, 2) ndarray representing the coordinates in the output image, where each row is a pair of (col, row) coordinates.\nk_angle: A float that represents the scaling factor relating the number of rows in the output image to the angle in polar coordinates.\nk_radius: A float that is the scaling factor relating the radius of the circle bounding the area to be transformed to the number of columns in the output image.\ncenter: A tuple (row, col) indicating the center of the circle that bounds the area to be transformed in the input image.\n\nOutputs: \ncoords: An (M, 2) ndarray containing the cartesian `(col, row)` coordinates in the input image that correspond to the provided `output_coords`. This set of coordinates can be used for mapping pixels from the output polar space back to the input cartesian space.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _linear_polar_mapping(output_coords, k_angle, k_radius, center): [MASK]\n"}
{"method_name": "_log_polar_mapping", "full_method_name": "_log_polar_mapping", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/_warps.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\ndef _log_polar_mapping(output_coords, k_angle, k_radius, center):\n    \"\"\"Inverse mapping function to convert from cartesian to polar coordinates\n\n    Parameters\n    ----------\n    output_coords : (M, 2) ndarray\n        Array of `(col, row)` coordinates in the output image.\n    k_angle : float\n        Scaling factor that relates the intended number of rows in the output\n        image to angle: ``k_angle = nrows / (2 * np.pi)``.\n    k_radius : float\n        Scaling factor that relates the radius of the circle bounding the\n        area to be transformed to the intended number of columns in the output\n        image: ``k_radius = width / np.log(radius)``.\n    center : 2-tuple\n        `(row, col)` coordinates that represent the center of the circle that bounds the\n        area to be transformed in an input image.\n\n    Returns\n    -------\n    coords : ndarray, shape (M, 2)\n        Array of `(col, row)` coordinates in the input image that\n        correspond to the `output_coords` given as input.\n    \"\"\"\n    angle = output_coords[:, 1] / k_angle\n    rr = np.exp(output_coords[:, 0] / k_radius) * np.sin(angle) + center[0]\n    cc = np.exp(output_coords[:, 0] / k_radius) * np.cos(angle) + center[1]\n    coords = np.column_stack((cc, rr))\n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_log_polar_mapping():\n    output_coords = np.array([[0, 0], [0, 90], [0, 180], [0, 270], [99, 0],\n        [99, 180], [99, 270], [99, 45]])\n    ground_truth = np.array([[101, 100], [100, 101], [99, 100], [100, 99],\n        [195.4992586, 100], [4.5007414, 100], [100, 4.5007414], [\n        167.52817336, 167.52817336]])\n    k_angle = 360 / (2 * np.pi)\n    k_radius = 100 / np.log(100)\n    center = 100, 100\n    coords = _log_polar_mapping(output_coords, k_angle, k_radius, center)\n    assert np.allclose(coords, ground_truth)\n\ntest_log_polar_mapping()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "instruction": "Functionality: The _log_polar_mapping function performs an inverse mapping from Cartesian to polar coordinates, specifically tailored for transforming sections of images that are enclosed within a circle into a rectangular grid. This transformation is essential for tasks such as feature extraction and image analysis where radial and angular aspects of patterns are significant.\n\nInputs: \n- output_coords: A 2D array of shape (M, 2) representing the 'column', 'row' coordinates in the output image (grid). Each row represents a point whose coordinates are to be transformed.\n- k_angle: A floating point scaling factor that relates the intended number of rows in the output image to the angular component of the polar coordinates.\n- k_radius: A floating point scaling factor relating the radius of the bounding circle of the area to be transformed to the intended number of columns in the output image.\n- center: A 2-tuple containing the 'row', 'column' coordinates of the center of the circle that bounds the area to be transformed in the input image.\n\nOutputs: \n- coords: A 2D array of shape (M, 2) representing the 'column', 'row' coordinates in the input image that correspond to the 'output_coords' given as input. This array provides the locations in the original image that need to be sampled to create the polar grid.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _log_polar_mapping(output_coords, k_angle, k_radius, center): [MASK]\n"}
{"method_name": "_rescale_intensity", "full_method_name": "_rescale_intensity", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py", "method_code": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\ndef _rescale_intensity(x):\n    x = x.astype(float)\n    x -= x.min()\n    x /= x.max()\n    return x", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\ndef test_iradon_angles():\n    \"\"\"\n    Test with different number of projections\n    \"\"\"\n    size = 100\n    image = np.tri(size) + np.tri(size)[::-1]\n    nb_angles = 200\n    theta = np.linspace(0, 180, nb_angles, endpoint=False)\n    radon_image_200 = radon(image, theta=theta, circle=False)\n    reconstructed = iradon(radon_image_200, circle=False)\n    delta_200 = np.mean(abs(_rescale_intensity(image) - _rescale_intensity(\n        reconstructed)))\n    assert delta_200 < 0.03\n    nb_angles = 80\n    radon_image_80 = radon(image, theta=theta, circle=False)\n    s = radon_image_80.sum(axis=0)\n    assert np.allclose(s, s[0], rtol=0.01)\n    reconstructed = iradon(radon_image_80, circle=False)\n    delta_80 = np.mean(abs(image / np.max(image) - reconstructed / np.max(\n        reconstructed)))\n    assert delta_80 > delta_200\n\ntest_iradon_angles()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py"}], "instruction": "Functionality: The function _rescale_intensity is designed to rescale the intensity values of an input image to a range of [0, 1]. This is useful for preprocessing images for visualization or for preparing images for certain image processing algorithms that require normalized intensity values.\n\nInputs: \n- x: A 2D NumPy array representing the image. The intensity values in the array can be of any numeric type.\n\nOutputs: \n- A 2D NumPy array of the same shape as the input array, with intensity values rescaled to the range [0, 1]. The output array will be of type float.", "method_code_mask": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\n\n\ndef _rescale_intensity(x): [MASK]\n"}
{"method_name": "order_angles_golden_ratio", "full_method_name": "order_angles_golden_ratio", "method_path": "../srcdata/Computation/scikit-image/skimage/transform/radon_transform.py", "method_code": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy.constants import golden_ratio\nfrom scipy.fft import fft\nfrom scipy.fft import ifft\nfrom scipy.fft import fftfreq\nfrom scipy.fft import fftshift\nfrom warnings import warn\nfrom functools import partial\ndef order_angles_golden_ratio(theta):\n    \"\"\"Order angles to reduce the amount of correlated information in\n    subsequent projections.\n\n    Parameters\n    ----------\n    theta : array of floats, shape (M,)\n        Projection angles in degrees. Duplicate angles are not allowed.\n\n    Returns\n    -------\n    indices_generator : generator yielding unsigned integers\n        The returned generator yields indices into ``theta`` such that\n        ``theta[indices]`` gives the approximate golden ratio ordering\n        of the projections. In total, ``len(theta)`` indices are yielded.\n        All non-negative integers < ``len(theta)`` are yielded exactly once.\n\n    Notes\n    -----\n    The method used here is that of the golden ratio introduced\n    by T. Kohler.\n\n    References\n    ----------\n    .. [1] Kohler, T. \"A projection access scheme for iterative\n           reconstruction based on the golden section.\" Nuclear Science\n           Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.\n    .. [2] Winkelmann, Stefanie, et al. \"An optimal radial profile order\n           based on the Golden Ratio for time-resolved MRI.\"\n           Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.\n\n    \"\"\"\n    interval = 180\n    remaining_indices = list(np.argsort(theta))\n    angle = theta[remaining_indices[0]]\n    yield remaining_indices.pop(0)\n    angle_increment = interval / golden_ratio ** 2\n    while remaining_indices:\n        remaining_angles = theta[remaining_indices]\n        angle = (angle + angle_increment) % interval\n        index_above = np.searchsorted(remaining_angles, angle)\n        index_below = index_above - 1\n        index_above %= len(remaining_indices)\n        diff_below = abs(angle - remaining_angles[index_below])\n        distance_below = min(diff_below % interval, diff_below % -interval)\n        diff_above = abs(angle - remaining_angles[index_above])\n        distance_above = min(diff_above % interval, diff_above % -interval)\n        if distance_below < distance_above:\n            yield remaining_indices.pop(index_below)\n        else:\n            yield remaining_indices.pop(index_above)", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\ndef test_order_angles_golden_ratio():\n    from skimage.transform.radon_transform import order_angles_golden_ratio\n    np.random.seed(1231)\n    lengths = [1, 4, 10, 180]\n    for l in lengths:\n        theta_ordered = np.linspace(0, 180, l, endpoint=False)\n        theta_random = np.random.uniform(0, 180, l)\n        for theta in (theta_random, theta_ordered):\n            indices = [x for x in order_angles_golden_ratio(theta)]\n            assert len(indices) == len(set(indices))\n\ntest_order_angles_golden_ratio()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py"}], "instruction": "Functionality: The order_angles_golden_ratio function is designed to reorder projection angles in a way that reduces the amount of correlated information in subsequent projections, following the golden ratio method introduced by T. Kohler. This can be particularly useful in computed tomography and other imaging techniques where the order of projections affects the quality of the reconstructed image.\n\nInputs: \n- theta: An array of floats, representing projection angles in degrees. This input must not contain duplicate angles. The shape of the array is (M,), where M is the number of angles.\n\nOutputs:\n- indices_generator: A generator that yields indices into the input 'theta'. These indices are designed to reorder the angles in such a way that the reordered angles follow an approximate golden ratio ordering. The generator yields all non-negative integers less than the length of 'theta', ensuring that each angle is considered exactly once. The yielded indices can be used to reorder 'theta' for optimized projection sequencing.", "method_code_mask": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy.constants import golden_ratio\nfrom scipy.fft import fft\nfrom scipy.fft import ifft\nfrom scipy.fft import fftfreq\nfrom scipy.fft import fftshift\nfrom warnings import warn\nfrom functools import partial\n\n\ndef order_angles_golden_ratio(theta): [MASK]\n"}
{"method_name": "polygon_area", "full_method_name": "polygon_area", "method_path": "../srcdata/Computation/scikit-image/skimage/_shared/_geometry.py", "method_code": "import numpy as np\nfrom matplotlib import path\nfrom matplotlib import transforms\ndef polygon_area(pr, pc):\n    \"\"\"Compute the area of a polygon.\n\n    Parameters\n    ----------\n    pr, pc : (K,) array of float\n        Polygon row and column coordinates.\n\n    Returns\n    -------\n    a : float\n        Area of the polygon.\n    \"\"\"\n    pr = np.asarray(pr)\n    pc = np.asarray(pc)\n    return 0.5 * np.abs(np.sum(pc[:-1] * pr[1:] - pc[1:] * pr[:-1]))", "test_code_list": [{"test_code": "import pytest\nfrom skimage._shared._geometry import polygon_clip\nfrom skimage._shared._geometry import polygon_area\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\ndef test_polygon_area():\n    x = [0, 0, 1, 1]\n    y = [0, 1, 1, 0]\n    assert_almost_equal(polygon_area(y, x), 1)\n    x = [0, 0, 1]\n    y = [0, 1, 1]\n    assert_almost_equal(polygon_area(y, x), 0.5)\n    x = [0, 0, 0.5, 1, 1, 0.5]\n    y = [0, 1, 0.5, 1, 0, 0.5]\n    assert_almost_equal(polygon_area(y, x), 0.5)\n\ntest_polygon_area()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/_shared/tests/test_geometry.py"}, {"test_code": "import pytest\nfrom skimage._shared._geometry import polygon_clip\nfrom skimage._shared._geometry import polygon_area\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\ndef test_poly_clip():\n    x = [0, 1, 2, 1]\n    y = [0, -1, 0, 1]\n    yc, xc = polygon_clip(y, x, 0, 0, 1, 1)\n    assert_equal(polygon_area(yc, xc), 0.5)\n    x = [-1, 1.5, 1.5, -1]\n    y = [0.5, 0.5, 1.5, 1.5]\n    yc, xc = polygon_clip(y, x, 0, 0, 1, 1)\n    assert_equal(polygon_area(yc, xc), 0.5)\n\ntest_poly_clip()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/_shared/tests/test_geometry.py"}], "instruction": "Functionality: The function \"polygon_area\" is designed to calculate the area of a polygon. It achieves this by using the coordinates of the polygon's vertices. The polygon's vertices are provided as row and column coordinates, which are then used in a mathematical formula to compute the area.\n\nInputs: The input to this function is two 1-dimensional arrays, \"pr\" and \"pc\", which represent the row and column coordinates of the vertices of the polygon, respectively. These inputs should be arrays of float type and should have the same length, representing each vertex of the polygon.\n\nOutputs: The function returns a single float value, \"a\", which represents the area of the polygon. This is computed using the coordinates provided and applying a mathematical formula that calculates the absolute value of half the sum of the products of row coordinates of one vertex and column coordinates of the next vertex, minus the product of column coordinates of one vertex and row coordinates of the next vertex, for all vertices in the polygon.", "method_code_mask": "import numpy as np\nfrom matplotlib import path\nfrom matplotlib import transforms\n\n\ndef polygon_area(pr, pc): [MASK]\n"}
{"method_name": "get_module_version", "full_method_name": "get_module_version", "method_path": "../srcdata/Computation/scikit-image/skimage/_shared/version_requirements.py", "method_code": "import sys\nfrom packaging import version as _version\nimport re\nimport functools\ndef get_module_version(module_name):\n    \"\"\"Return module version or None if version can't be retrieved.\"\"\"\n    mod = __import__(module_name, fromlist=[module_name.rpartition('.')[-1]])\n    return getattr(mod, '__version__', getattr(mod, 'VERSION', None))", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_equal\nfrom skimage._shared import version_requirements as version_req\nfrom skimage._shared import testing\ndef test_get_module_version():\n    assert get_module_version('numpy')\n    assert get_module_version('scipy')\n    with testing.raises(ImportError):\n        get_module_version('fakenumpy')\n\ntest_get_module_version()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/_shared/tests/test_version_requirements.py"}], "instruction": "Functionality: The function 'get_module_version' is designed to retrieve the version of a given Python module. It attempts to import the specified module and then retrieves its version by checking for either '__version__' or 'VERSION' attributes.\n\nInputs: \n- module_name: str\n  The name of the Python module for which you want to retrieve the version. This should be a string representing a valid Python module name.\n\nOutputs:\n- str or None\n  The function returns the version of the module as a string if it can successfully find and import the module and retrieve its version. If the module does not have a version or cannot be imported, the function returns None.", "method_code_mask": "import sys\nfrom packaging import version as _version\nimport re\nimport functools\n\n\ndef get_module_version(module_name): [MASK]\n"}
{"method_name": "_masked_phase_cross_correlation", "full_method_name": "_masked_phase_cross_correlation", "method_path": "../srcdata/Computation/scikit-image/skimage/registration/_masked_phase_cross_correlation.py", "method_code": "from functools import partial\nimport numpy as np\nimport scipy.fft as fftmodule\nfrom scipy.fft import next_fast_len\ndef _masked_phase_cross_correlation(reference_image, moving_image,\n    reference_mask, moving_mask=None, overlap_ratio=0.3):\n    \"\"\"Masked image translation registration by masked normalized\n    cross-correlation.\n\n    Parameters\n    ----------\n    reference_image : ndarray\n        Reference image.\n    moving_image : ndarray\n        Image to register. Must be same dimensionality as ``reference_image``,\n        but not necessarily the same size.\n    reference_mask : ndarray\n        Boolean mask for ``reference_image``. The mask should evaluate\n        to ``True`` (or 1) on valid pixels. ``reference_mask`` should\n        have the same shape as ``reference_image``.\n    moving_mask : ndarray or None, optional\n        Boolean mask for ``moving_image``. The mask should evaluate to ``True``\n        (or 1) on valid pixels. ``moving_mask`` should have the same shape\n        as ``moving_image``. If ``None``, ``reference_mask`` will be used.\n    overlap_ratio : float, optional\n        Minimum allowed overlap ratio between images. The correlation for\n        translations corresponding with an overlap ratio lower than this\n        threshold will be ignored. A lower `overlap_ratio` leads to smaller\n        maximum translation, while a higher `overlap_ratio` leads to greater\n        robustness against spurious matches due to small overlap between\n        masked images.\n\n    Returns\n    -------\n    shifts : ndarray\n        Shift vector (in pixels) required to register ``moving_image``\n        with ``reference_image``. Axis ordering is consistent with numpy.\n\n    References\n    ----------\n    .. [1] Dirk Padfield. Masked Object Registration in the Fourier Domain.\n           IEEE Transactions on Image Processing, vol. 21(5),\n           pp. 2706-2718 (2012). :DOI:`10.1109/TIP.2011.2181402`\n    .. [2] D. Padfield. \"Masked FFT registration\". In Proc. Computer Vision and\n           Pattern Recognition, pp. 2918-2925 (2010).\n           :DOI:`10.1109/CVPR.2010.5540032`\n\n    \"\"\"\n    if moving_mask is None:\n        if reference_image.shape != moving_image.shape:\n            raise ValueError(\n                'Input images have different shapes, moving_mask must be explicitly set.'\n                )\n        moving_mask = reference_mask.astype(bool)\n    for im, mask in [(reference_image, reference_mask), (moving_image,\n        moving_mask)]:\n        if im.shape != mask.shape:\n            raise ValueError(\n                'Image sizes must match their respective mask sizes.')\n    xcorr = cross_correlate_masked(moving_image, reference_image,\n        moving_mask, reference_mask, axes=tuple(range(moving_image.ndim)),\n        mode='full', overlap_ratio=overlap_ratio)\n    maxima = np.stack(np.nonzero(xcorr == xcorr.max()), axis=1)\n    center = np.mean(maxima, axis=0)\n    shifts = center - np.array(reference_image.shape) + 1\n    size_mismatch = np.array(moving_image.shape) - np.array(reference_image\n        .shape)\n    return -shifts + size_mismatch / 2", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_vs_phase_cross_correlation():\n    \"\"\"_masked_phase_cross_correlation should give the same results as\n    phase_cross_correlation in the case of trivial masks.\"\"\"\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    trivial_mask = np.ones_like(reference_image)\n    nonmasked_result, *_ = phase_cross_correlation(reference_image, shifted)\n    masked_result = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=trivial_mask, overlap_ratio=1 / 10)\n    assert_equal(nonmasked_result, masked_result)\n\ntest_masked_registration_vs_phase_cross_correlation()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_random_masks():\n    \"\"\"_masked_phase_cross_correlation should be able to register translations\n    between images even with random masks.\"\"\"\n    np.random.seed(23)\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    ref_mask = np.random.choice([True, False], reference_image.shape, p=[3 /\n        4, 1 / 4])\n    shifted_mask = np.random.choice([True, False], shifted.shape, p=[3 / 4,\n        1 / 4])\n    measured_shift = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=ref_mask, moving_mask=shifted_mask)\n    assert_equal(measured_shift, -np.array(shift))\n\ntest_masked_registration_random_masks()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_random_masks_non_equal_sizes():\n    \"\"\"_masked_phase_cross_correlation should be able to register\n    translations between images that are not the same size even\n    with random masks.\"\"\"\n    np.random.seed(23)\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    shifted = shifted[64:-64, 64:-64]\n    ref_mask = np.random.choice([True, False], reference_image.shape, p=[3 /\n        4, 1 / 4])\n    shifted_mask = np.random.choice([True, False], shifted.shape, p=[3 / 4,\n        1 / 4])\n    measured_shift = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=np.ones_like(ref_mask), moving_mask=np.ones_like(\n        shifted_mask))\n    assert_equal(measured_shift, -np.array(shift))\n\ntest_masked_registration_random_masks_non_equal_sizes()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_padfield_data():\n    \"\"\"Masked translation registration should behave like in the original\n    publication\"\"\"\n    shifts = [(75, 75), (-130, 130), (130, 130)]\n    for xi, yi in shifts:\n        fixed_image = imread(fetch(\n            f'registration/tests/data/OriginalX{xi}Y{yi}.png'))\n        moving_image = imread(fetch(\n            f'registration/tests/data/TransformedX{xi}Y{yi}.png'))\n        fixed_mask = fixed_image != 0\n        moving_mask = moving_image != 0\n        shift_y, shift_x = _masked_phase_cross_correlation(fixed_image,\n            moving_image, reference_mask=fixed_mask, moving_mask=\n            moving_mask, overlap_ratio=0.1)\n        assert_equal((shift_x, shift_y), (-xi, yi))\n\ntest_masked_registration_padfield_data()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}], "instruction": "Functionality: The _masked_phase_cross_correlation function calculates the shift required to register a moving image with a reference image while taking into account provided masks. It performs masked normalized cross-correlation to find the optimal translation that best aligns the masked regions of the images.\n\nInputs:\n- reference_image: An ndarray representing the reference image.\n- moving_image: An ndarray representing the image to register. Must be the same dimensionality as the reference image.\n- reference_mask: A boolean ndarray mask for the reference image, with the same shape as the reference image.\n- moving_mask: An optional boolean ndarray mask for the moving image. If not provided, the reference mask will be used. Must have the same shape as the moving image if provided.\n- overlap_ratio: A float value specifying the minimum allowed overlap ratio between images. A lower value leads to smaller maximum translation, while a higher value increases robustness against spurious matches due to small overlap.\n\nOutputs:\n- shifts: An ndarray containing the shift vector (in pixels) required to register the moving_image with the reference_image, consistent with numpy axis ordering.", "method_code_mask": "from functools import partial\nimport numpy as np\nimport scipy.fft as fftmodule\nfrom scipy.fft import next_fast_len\n\n\ndef _masked_phase_cross_correlation(reference_image, moving_image,\n    reference_mask, moving_mask=None, overlap_ratio=0.3): [MASK]\n"}
{"method_name": "_sin_flow_gen", "full_method_name": "_sin_flow_gen", "method_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_tvl1.py", "method_code": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\ndef _sin_flow_gen(image0, max_motion=4.5, npics=5):\n    \"\"\"Generate a synthetic ground truth optical flow with a sinusoid as\n      first component.\n\n    Parameters\n    ----------\n    image0: ndarray\n        The base image to be warped.\n    max_motion: float\n        Maximum flow magnitude.\n    npics: int\n        Number of sinusoid pics.\n\n    Returns\n    -------\n    flow, image1 : ndarray\n        The synthetic ground truth optical flow with a sinusoid as\n        first component and the corresponding warped image.\n\n    \"\"\"\n    grid = np.meshgrid(*[np.arange(n) for n in image0.shape], indexing='ij')\n    grid = np.stack(grid)\n    gt_flow = np.zeros_like(grid, dtype=float)\n    gt_flow[0, ...] = max_motion * np.sin(grid[0] / grid[0].max() * npics *\n        np.pi)\n    image1 = warp(image0, grid - gt_flow, mode='edge')\n    return gt_flow, image1", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_ilk\ndef test_optical_flow_dtype():\n    rng = np.random.default_rng(0)\n    image0 = rng.normal(size=(256, 256))\n    gt_flow, image1 = _sin_flow_gen(image0)\n    flow_f64 = optical_flow_ilk(image0, image1, dtype='float64')\n    assert flow_f64.dtype == 'float64'\n    flow_f32 = optical_flow_ilk(image0, image1, dtype='float32')\n    assert flow_f32.dtype == 'float32'\n    assert abs(flow_f64 - flow_f32).mean() < 0.001\n\ntest_optical_flow_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_ilk.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\ndef test_optical_flow_dtype():\n    rng = np.random.default_rng(0)\n    image0 = rng.normal(size=(256, 256))\n    gt_flow, image1 = _sin_flow_gen(image0)\n    flow_f64 = optical_flow_tvl1(image0, image1, attachment=5, dtype=np.float64\n        )\n    assert flow_f64.dtype == np.float64\n    flow_f32 = optical_flow_tvl1(image0, image1, attachment=5, dtype=np.float32\n        )\n    assert flow_f32.dtype == np.float32\n    assert np.abs(flow_f64 - flow_f32).mean() < 0.001\n\ntest_optical_flow_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/registration/tests/test_tvl1.py"}], "instruction": "Functionality: Generate a synthetic ground truth optical flow with a sinusoid as the first component and the corresponding warped image.\n\nInputs: \n- image0: ndarray\n    The base image to be warped.\n- max_motion: float (default=4.5)\n    Maximum flow magnitude.\n- npics: int (default=5)\n    Number of sinusoid pics.\n\nOutputs: \n- flow: ndarray\n    The synthetic ground truth optical flow with a sinusoid as first component.\n- image1: ndarray\n    The corresponding warped image.", "method_code_mask": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\n\n\ndef _sin_flow_gen(image0, max_motion=4.5, npics=5): [MASK]\n"}
{"method_name": "_sigma_prefactor", "full_method_name": "_sigma_prefactor", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/_gabor.py", "method_code": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\ndef _sigma_prefactor(bandwidth):\n    b = bandwidth\n    return 1.0 / np.pi * math.sqrt(math.log(2) / 2.0) * (2.0 ** b + 1) / (\n        2.0 ** b - 1)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage.filters._gabor import _sigma_prefactor\nfrom skimage.filters._gabor import gabor\nfrom skimage.filters._gabor import gabor_kernel\ndef test_sigma_prefactor():\n    assert_almost_equal(_sigma_prefactor(1), 0.56, 2)\n    assert_almost_equal(_sigma_prefactor(0.5), 1.09, 2)\n\ntest_sigma_prefactor()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_gabor.py"}], "instruction": "Functionality: The _sigma_prefactor function computes a prefactor used in kernel calculations for various image processing operations. This prefactor is calculated based on the given bandwidth and facilitates the creation of kernels for tasks such as smoothing or sharpening images.\n\nInputs: \n- bandwidth (float): A positive floating-point number representing the bandwidth of the kernel. This parameter influences the size and shape of the kernel used in image processing operations.\n\nOutputs:\n- prefactor (float): The computed prefactor, which is a floating-point number used as a scaling factor in kernel calculations. This value is essential for normalizing kernels to ensure that the kernel integrates to a value close to 1 over its domain.", "method_code_mask": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _sigma_prefactor(bandwidth): [MASK]\n"}
{"method_name": "gabor", "full_method_name": "gabor", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/_gabor.py", "method_code": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\ndef gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=\n    None, n_stds=3, offset=0, mode='reflect', cval=0):\n    \"\"\"Return real and imaginary responses to Gabor filter.\n\n    The real and imaginary parts of the Gabor filter kernel are applied to the\n    image and the response is returned as a pair of arrays.\n\n    Gabor filter is a linear filter with a Gaussian kernel which is modulated\n    by a sinusoidal plane wave. Frequency and orientation representations of\n    the Gabor filter are similar to those of the human visual system.\n    Gabor filter banks are commonly used in computer vision and image\n    processing. They are especially suitable for edge detection and texture\n    classification.\n\n    Parameters\n    ----------\n    image : 2-D array\n        Input image.\n    frequency : float\n        Spatial frequency of the harmonic function. Specified in pixels.\n    theta : float, optional\n        Orientation in radians. If 0, the harmonic is in the x-direction.\n    bandwidth : float, optional\n        The bandwidth captured by the filter. For fixed bandwidth, ``sigma_x``\n        and ``sigma_y`` will decrease with increasing frequency. This value is\n        ignored if ``sigma_x`` and ``sigma_y`` are set by the user.\n    sigma_x, sigma_y : float, optional\n        Standard deviation in x- and y-directions. These directions apply to\n        the kernel *before* rotation. If `theta = pi/2`, then the kernel is\n        rotated 90 degrees so that ``sigma_x`` controls the *vertical*\n        direction.\n    n_stds : scalar, optional\n        The linear size of the kernel is n_stds (3 by default) standard\n        deviations.\n    offset : float, optional\n        Phase offset of harmonic function in radians.\n    mode : {'constant', 'nearest', 'reflect', 'mirror', 'wrap'}, optional\n        Mode used to convolve image with a kernel, passed to `ndi.convolve`\n    cval : scalar, optional\n        Value to fill past edges of input if ``mode`` of convolution is\n        'constant'. The parameter is passed to `ndi.convolve`.\n\n    Returns\n    -------\n    real, imag : arrays\n        Filtered images using the real and imaginary parts of the Gabor filter\n        kernel. Images are of the same dimensions as the input one.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Gabor_filter\n    .. [2] https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf\n\n    Examples\n    --------\n    >>> from skimage.filters import gabor\n    >>> from skimage import data, io\n    >>> from matplotlib import pyplot as plt  # doctest: +SKIP\n\n    >>> image = data.coins()\n    >>> # detecting edges in a coin image\n    >>> filt_real, filt_imag = gabor(image, frequency=0.6)\n    >>> plt.figure()            # doctest: +SKIP\n    >>> io.imshow(filt_real)    # doctest: +SKIP\n    >>> io.show()               # doctest: +SKIP\n\n    >>> # less sensitivity to finer details with the lower frequency kernel\n    >>> filt_real, filt_imag = gabor(image, frequency=0.1)\n    >>> plt.figure()            # doctest: +SKIP\n    >>> io.imshow(filt_real)    # doctest: +SKIP\n    >>> io.show()               # doctest: +SKIP\n    \"\"\"\n    check_nD(image, 2)\n    if image.dtype.kind == 'f':\n        float_dtype = _supported_float_type(image.dtype)\n        image = image.astype(float_dtype, copy=False)\n        kernel_dtype = np.promote_types(image.dtype, np.complex64)\n    else:\n        kernel_dtype = np.complex128\n    g = gabor_kernel(frequency, theta, bandwidth, sigma_x, sigma_y, n_stds,\n        offset, dtype=kernel_dtype)\n    filtered_real = ndi.convolve(image, np.real(g), mode=mode, cval=cval)\n    filtered_imag = ndi.convolve(image, np.imag(g), mode=mode, cval=cval)\n    return filtered_real, filtered_imag", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage.filters._gabor import _sigma_prefactor\nfrom skimage.filters._gabor import gabor\nfrom skimage.filters._gabor import gabor_kernel\ndef test_gabor():\n    Y, X = np.mgrid[:40, :40]\n    frequencies = 0.1, 0.3\n    wave_images = [np.sin(2 * np.pi * X * f) for f in frequencies]\n\n    def match_score(image, frequency):\n        gabor_responses = gabor(image, frequency)\n        return np.mean(np.hypot(*gabor_responses))\n    responses = np.array([[match_score(image, f) for f in frequencies] for\n        image in wave_images])\n    assert responses[0, 0] > responses[0, 1]\n    assert responses[1, 1] > responses[0, 1]\n    assert responses[0, 0] > responses[1, 0]\n    assert responses[1, 1] > responses[1, 0]\n\ntest_gabor()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_gabor.py"}], "instruction": "Functionality: The Gabor function implements a Gabor filter on a 2-D input image. This filter is characterized by a Gaussian kernel modulated by a sinusoidal plane wave, making it effective for tasks like edge detection and texture classification in computer vision and image processing.\n\nInputs: \n- image: A 2-D array representing the input image.\n- frequency: A float specifying the spatial frequency of the harmonic function in pixels.\n- theta: An optional float representing the orientation of the filter in radians (default is 0).\n- bandwidth: An optional float indicating the bandwidth captured by the filter (default is 1).\n- sigma_x, sigma_y: Optional floats for specifying the standard deviation in the x- and y-directions (default is None).\n- n_stds: An optional scalar determining the linear size of the kernel in terms of standard deviations (default is 3).\n- offset: An optional float for the phase offset of the harmonic function in radians (default is 0).\n- mode: An optional string specifying the mode used to convolve the image with the kernel (default is 'reflect').\n- cval: An optional scalar used to fill past edges of the input if the convolution mode is 'constant' (default is 0).\n\nOutputs:\n- real: A 2-D array representing the filtered image using the real part of the Gabor filter kernel.\n- imag: A 2-D array representing the filtered image using the imaginary part of the Gabor filter kernel.", "method_code_mask": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=\n    None, n_stds=3, offset=0, mode='reflect', cval=0): [MASK]\n"}
{"method_name": "_mask_filter_result", "full_method_name": "_mask_filter_result", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/edges.py", "method_code": "import numpy as np\nfrom scipy import ndimage as ndi\nfrom scipy.ndimage import binary_erosion\nfrom scipy.ndimage import convolve\ndef _mask_filter_result(result, mask):\n    \"\"\"Return result after masking.\n\n    Input masks are eroded so that mask areas in the original image don't\n    affect values in the result.\n    \"\"\"\n    if mask is not None:\n        erosion_footprint = ndi.generate_binary_structure(mask.ndim, mask.ndim)\n        mask = binary_erosion(mask, erosion_footprint, border_value=0)\n        result *= mask\n    return result", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom skimage import data\nfrom skimage import filters\nfrom skimage.filters.edges import _mask_filter_result\ndef test_roberts_diagonal2():\n    \"\"\"Roberts' filter on a diagonal edge should be a diagonal line.\"\"\"\n    image = np.rot90(np.tri(10, 10, 0), 3)\n    expected = ~np.rot90(np.tri(10, 10, -1).astype(bool) | np.tri(10, 10, -\n        2).astype(bool).transpose())\n    expected = _mask_filter_result(expected, None)\n    result = filters.roberts(image).astype(bool)\n    assert_array_almost_equal(result, expected)\n\ntest_roberts_diagonal2()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_edges.py"}], "instruction": "Functionality: This function modifies an input result array by applying a mask to it. The mask is first eroded using a square footprint of size equal to the dimension of the mask to ensure that mask edges do not affect the values at the edges of the result array. After erosion, the result array is element-wise multiplied by the eroded mask, effectively zeroing out any values in the result array that were in masked regions of the original image.\n\nInputs: \n- result: a multi-dimensional array representing the result to be modified. This is typically an array of image processing results like gradients or filters.\n- mask: a multi-dimensional boolean array of the same shape as the result array. True values in the mask indicate areas that should be masked out (set to 0) in the result array. If None, the function returns the result array as is, without any modification.\n\nOutputs: \n- A modified version of the input result array. The areas in the result corresponding to the True values in the input mask are set to 0, after the mask has been eroded.", "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\nfrom scipy.ndimage import binary_erosion\nfrom scipy.ndimage import convolve\n\n\ndef _mask_filter_result(result, mask): [MASK]\n"}
{"method_name": "threshold_otsu", "full_method_name": "threshold_otsu", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_otsu(image=None, nbins=256, *, hist=None):\n    \"\"\"Return threshold value based on Otsu's method.\n\n    Either image or hist must be provided. If hist is provided, the actual\n    histogram of the image is ignored.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray, optional\n        Grayscale input image.\n    nbins : int, optional\n        Number of bins used to calculate histogram. This value is ignored for\n        integer arrays.\n    hist : array, or 2-tuple of arrays, optional\n        Histogram from which to determine the threshold, and optionally a\n        corresponding array of bin center intensities. If no hist provided,\n        this function will compute it from the image.\n\n\n    Returns\n    -------\n    threshold : float\n        Upper threshold value. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    References\n    ----------\n    .. [1] Wikipedia, https://en.wikipedia.org/wiki/Otsu's_Method\n\n    Examples\n    --------\n    >>> from skimage.data import camera\n    >>> image = camera()\n    >>> thresh = threshold_otsu(image)\n    >>> binary = image <= thresh\n\n    Notes\n    -----\n    The input image must be grayscale.\n    \"\"\"\n    if image is not None and image.ndim > 2 and image.shape[-1] in (3, 4):\n        warn(\n            f'threshold_otsu is expected to work correctly only for grayscale images; image shape {image.shape} looks like that of an RGB image.'\n            )\n    if image is not None:\n        first_pixel = image.reshape(-1)[0]\n        if np.all(image == first_pixel):\n            return first_pixel\n    counts, bin_centers = _validate_image_histogram(image, hist, nbins)\n    weight1 = np.cumsum(counts)\n    weight2 = np.cumsum(counts[::-1])[::-1]\n    mean1 = np.cumsum(counts * bin_centers) / weight1\n    mean2 = (np.cumsum((counts * bin_centers)[::-1]) / weight2[::-1])[::-1]\n    variance12 = weight1[:-1] * weight2[1:] * (mean1[:-1] - mean2[1:]) ** 2\n    idx = np.argmax(variance12)\n    threshold = bin_centers[idx]\n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    assert 101 < threshold_otsu(camera) < 103\n\ntest_otsu_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    assert 101 < threshold_otsu(hist=hist) < 103\n\ntest_otsu_camera_image_histogram()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    assert 101 < threshold_otsu(hist=counts) < 103\n\ntest_otsu_camera_image_counts()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    assert 106 < threshold_otsu(coins) < 108\n\ntest_otsu_coins_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 0.41 < threshold_otsu(coins) < 0.42\n\ntest_otsu_coins_image_as_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert 109 < threshold_otsu(img) < 111\n\ntest_otsu_astro_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_one_color_image():\n    img = np.ones((10, 10), dtype=np.uint8)\n    assert threshold_otsu(img) == 1\n\ntest_otsu_one_color_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_one_color_image_3d():\n    img = np.ones((10, 10, 10), dtype=np.uint8)\n    assert threshold_otsu(img) == 1\n\ntest_otsu_one_color_image_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_bimodal_multiotsu_hist():\n    for name in ['camera', 'moon', 'coins', 'text', 'clock', 'page']:\n        img = getattr(data, name)()\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n    for name in ['chelsea', 'coffee', 'astronaut', 'rocket']:\n        img = rgb2gray(getattr(data, name)())\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n\ntest_bimodal_multiotsu_hist()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_otsu function implements Otsu's method to determine a global threshold value that can be used to separate the foreground from the background in a grayscale image. This method calculates the threshold that minimizes the intra-class variance, which is the weighted sum of variances of the two classes.\n\nInputs: \n- image: A (M, N[, ...]) ndarray representing a grayscale input image. It is optional, and if not provided, hist must be provided.\n- nbins: An int specifying the number of bins used to calculate the histogram. This value is ignored for integer arrays.\n- hist: An array or a 2-tuple of arrays representing the histogram from which the threshold is to be determined, and optionally a corresponding array of bin center intensities. If no hist is provided, the function will compute it from the image.\n\nOutputs: \n- threshold: A float representing the upper threshold value. All pixels with an intensity higher than this value are assumed to be part of the foreground.\n\nReferences:\n- Wikipedia: https://en.wikipedia.org/wiki/Otsu's_Method\n\nNotes:\n- The input image must be grayscale.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_otsu(image=None, nbins=256, *, hist=None): [MASK]\n"}
{"method_name": "threshold_li", "full_method_name": "threshold_li", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_li(image, *, tolerance=None, initial_guess=None,\n    iter_callback=None):\n    \"\"\"Compute threshold value by Li's iterative Minimum Cross Entropy method.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray\n        Grayscale input image.\n    tolerance : float, optional\n        Finish the computation when the change in the threshold in an iteration\n        is less than this value. By default, this is half the smallest\n        difference between intensity values in ``image``.\n    initial_guess : float or Callable[[array[float]], float], optional\n        Li's iterative method uses gradient descent to find the optimal\n        threshold. If the image intensity histogram contains more than two\n        modes (peaks), the gradient descent could get stuck in a local optimum.\n        An initial guess for the iteration can help the algorithm find the\n        globally-optimal threshold. A float value defines a specific start\n        point, while a callable should take in an array of image intensities\n        and return a float value. Example valid callables include\n        ``numpy.mean`` (default), ``lambda arr: numpy.quantile(arr, 0.95)``,\n        or even :func:`skimage.filters.threshold_otsu`.\n    iter_callback : Callable[[float], Any], optional\n        A function that will be called on the threshold at every iteration of\n        the algorithm.\n\n    Returns\n    -------\n    threshold : float\n        Upper threshold value. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    References\n    ----------\n    .. [1] Li C.H. and Lee C.K. (1993) \"Minimum Cross Entropy Thresholding\"\n           Pattern Recognition, 26(4): 617-625\n           :DOI:`10.1016/0031-3203(93)90115-D`\n    .. [2] Li C.H. and Tam P.K.S. (1998) \"An Iterative Algorithm for Minimum\n           Cross Entropy Thresholding\" Pattern Recognition Letters, 18(8): 771-776\n           :DOI:`10.1016/S0167-8655(98)00057-9`\n    .. [3] Sezgin M. and Sankur B. (2004) \"Survey over Image Thresholding\n           Techniques and Quantitative Performance Evaluation\" Journal of\n           Electronic Imaging, 13(1): 146-165\n           :DOI:`10.1117/1.1631315`\n    .. [4] ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold\n\n    Examples\n    --------\n    >>> from skimage.data import camera\n    >>> image = camera()\n    >>> thresh = threshold_li(image)\n    >>> binary = image > thresh\n    \"\"\"\n    image = image[~np.isnan(image)]\n    if image.size == 0:\n        return np.nan\n    if np.all(image == image.flat[0]):\n        return image.flat[0]\n    image = image[np.isfinite(image)]\n    if image.size == 0:\n        return 0.0\n    image_min = np.min(image)\n    image -= image_min\n    if image.dtype.kind in 'iu':\n        tolerance = tolerance or 0.5\n    else:\n        tolerance = tolerance or np.min(np.diff(np.unique(image))) / 2\n    if initial_guess is None:\n        t_next = np.mean(image)\n    elif callable(initial_guess):\n        t_next = initial_guess(image)\n    elif np.isscalar(initial_guess):\n        t_next = initial_guess - float(image_min)\n        image_max = np.max(image) + image_min\n        if not 0 < t_next < np.max(image):\n            msg = (\n                f'The initial guess for threshold_li must be within the range of the image. Got {initial_guess} for image min {image_min} and max {image_max}.'\n                )\n            raise ValueError(msg)\n        t_next = image.dtype.type(t_next)\n    else:\n        raise TypeError(\n            'Incorrect type for `initial_guess`; should be a floating point value, or a function mapping an array to a floating point value.'\n            )\n    t_curr = -2 * tolerance\n    if iter_callback is not None:\n        iter_callback(t_next + image_min)\n    if image.dtype.kind in 'iu':\n        hist, bin_centers = histogram(image.reshape(-1), source_range='image')\n        hist = hist.astype('float32', copy=False)\n        while abs(t_next - t_curr) > tolerance:\n            t_curr = t_next\n            foreground = bin_centers > t_curr\n            background = ~foreground\n            mean_fore = np.average(bin_centers[foreground], weights=hist[\n                foreground])\n            mean_back = np.average(bin_centers[background], weights=hist[\n                background])\n            if mean_back == 0:\n                break\n            t_next = (mean_back - mean_fore) / (np.log(mean_back) - np.log(\n                mean_fore))\n            if iter_callback is not None:\n                iter_callback(t_next + image_min)\n    else:\n        while abs(t_next - t_curr) > tolerance:\n            t_curr = t_next\n            foreground = image > t_curr\n            mean_fore = np.mean(image[foreground])\n            mean_back = np.mean(image[~foreground])\n            if mean_back == 0.0:\n                break\n            t_next = (mean_back - mean_fore) / (np.log(mean_back) - np.log(\n                mean_fore))\n            if iter_callback is not None:\n                iter_callback(t_next + image_min)\n    threshold = t_next + image_min\n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_camera_image():\n    image = util.img_as_ubyte(data.camera())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 78 < threshold_li(image) < 79\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 1)\n\ntest_li_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_coins_image():\n    image = util.img_as_ubyte(data.coins())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 94 < threshold_li(image) < 95\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 2)\n\ntest_li_coins_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 94 / 255 < threshold_li(coins) < 95 / 255\n\ntest_li_coins_image_as_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_astro_image():\n    image = util.img_as_ubyte(data.astronaut())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 64 < threshold < 65\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 1)\n\ntest_li_astro_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_nan_image():\n    image = np.full((5, 5), np.nan)\n    assert np.isnan(threshold_li(image))\n\ntest_li_nan_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_inf_image():\n    image = np.array([np.inf, np.nan])\n    assert threshold_li(image) == np.inf\n\ntest_li_inf_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_inf_minus_inf():\n    image = np.array([np.inf, -np.inf])\n    assert threshold_li(image) == 0\n\ntest_li_inf_minus_inf()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_constant_image_with_nan():\n    image = np.array([8, 8, 8, 8, np.nan])\n    assert threshold_li(image) == 8\n\ntest_li_constant_image_with_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_arbitrary_start_point():\n    cell = data.cell()\n    max_stationary_point = threshold_li(cell)\n    low_stationary_point = threshold_li(cell, initial_guess=np.percentile(\n        cell, 5))\n    optimum = threshold_li(cell, initial_guess=np.percentile(cell, 95))\n    assert 67 < max_stationary_point < 68\n    assert 48 < low_stationary_point < 49\n    assert 111 < optimum < 112\n\ntest_li_arbitrary_start_point()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_li_constant_image(self):\n\t    assert threshold_li(np.ones((10, 10))) == 1.0\n\t\nTestSimpleImage().test_li_constant_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: Implement Li's iterative Minimum Cross Entropy method to compute a threshold value for segmenting grayscale images into foreground and background components.\n\nInputs:\n1. image: (M, N[, ...]) ndarray - The input grayscale image.\n2. tolerance: float (optional) - The criterion for stopping the iteration when the change in threshold is less than this value. By default, it's half the smallest difference between intensity values in the image.\n3. initial_guess: float or Callable[[array[float]], float] (optional) - The starting point for the threshold calculation, which can be a specific float value or a callable function that takes in an array of image intensities and returns a float.\n4. iter_callback: Callable[[float], Any] (optional) - A function that will be called on the threshold at every iteration of the algorithm.\n\nOutputs:\n1. threshold: float - The calculated threshold value. All pixels with an intensity higher than this value are considered foreground.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_li(image, *, tolerance=None, initial_guess=None,\n    iter_callback=None): [MASK]\n"}
{"method_name": "threshold_yen", "full_method_name": "threshold_yen", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_yen(image=None, nbins=256, *, hist=None):\n    \"\"\"Return threshold value based on Yen's method.\n    Either image or hist must be provided. In case hist is given, the actual\n    histogram of the image is ignored.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray\n        Grayscale input image.\n    nbins : int, optional\n        Number of bins used to calculate histogram. This value is ignored for\n        integer arrays.\n    hist : array, or 2-tuple of arrays, optional\n        Histogram from which to determine the threshold, and optionally a\n        corresponding array of bin center intensities.\n        An alternative use of this function is to pass it only hist.\n\n    Returns\n    -------\n    threshold : float\n        Upper threshold value. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    References\n    ----------\n    .. [1] Yen J.C., Chang F.J., and Chang S. (1995) \"A New Criterion\n           for Automatic Multilevel Thresholding\" IEEE Trans. on Image\n           Processing, 4(3): 370-378. :DOI:`10.1109/83.366472`\n    .. [2] Sezgin M. and Sankur B. (2004) \"Survey over Image Thresholding\n           Techniques and Quantitative Performance Evaluation\" Journal of\n           Electronic Imaging, 13(1): 146-165, :DOI:`10.1117/1.1631315`\n           http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf\n    .. [3] ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold\n\n    Examples\n    --------\n    >>> from skimage.data import camera\n    >>> image = camera()\n    >>> thresh = threshold_yen(image)\n    >>> binary = image <= thresh\n    \"\"\"\n    counts, bin_centers = _validate_image_histogram(image, hist, nbins)\n    if bin_centers.size == 1:\n        return bin_centers[0]\n    pmf = counts.astype('float32', copy=False) / counts.sum()\n    P1 = np.cumsum(pmf)\n    P1_sq = np.cumsum(pmf ** 2)\n    P2_sq = np.cumsum(pmf[::-1] ** 2)[::-1]\n    crit = np.log((P1_sq[:-1] * P2_sq[1:]) ** -1 * (P1[:-1] * (1.0 - P1[:-1\n        ])) ** 2)\n    return bin_centers[crit.argmax()]", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    assert 145 < threshold_yen(camera) < 147\n\ntest_yen_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    assert 145 < threshold_yen(hist=hist) < 147\n\ntest_yen_camera_image_histogram()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    assert 145 < threshold_yen(hist=counts) < 147\n\ntest_yen_camera_image_counts()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    assert 109 < threshold_yen(coins) < 111\n\ntest_yen_coins_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 0.43 < threshold_yen(coins) < 0.44\n\ntest_yen_coins_image_as_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_arange(self):\n\t    image = np.arange(256)\n\t    assert threshold_yen(image) == 127\n\t\nTestSimpleImage().test_yen_arange()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_binary(self):\n\t    image = np.zeros([2, 256], dtype=np.uint8)\n\t    image[0] = 255\n\t    assert threshold_yen(image) < 1\n\t\nTestSimpleImage().test_yen_binary()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_blank_zero(self):\n\t    image = np.zeros((5, 5), dtype=np.uint8)\n\t    assert threshold_yen(image) == 0\n\t\nTestSimpleImage().test_yen_blank_zero()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_blank_max(self):\n\t    image = np.empty((5, 5), dtype=np.uint8)\n\t    image.fill(255)\n\t    assert threshold_yen(image) == 255\n\t\nTestSimpleImage().test_yen_blank_max()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_yen function computes a threshold value for binarizing grayscale images using Yen's method. The algorithm maximizes the evaluation function obtained by considering the weighted histograms of the foreground and background. This function can either calculate the histogram from the provided image or use a pre-calculated histogram.\n\nInputs: \n- image: A 2D array of pixel intensities representing a grayscale image. This argument is optional if hist is provided.\n- nbins: An integer indicating the number of bins to use in calculating the histogram. This parameter is ignored for integer arrays.\n- hist: An array or a 2-tuple of arrays representing the histogram and optionally the corresponding bin center intensities. If hist is provided, the actual histogram of the image is ignored.\n\nOutputs: \n- threshold: A floating-point number representing the upper threshold value. All pixels with an intensity higher than this value are considered to be part of the foreground.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_yen(image=None, nbins=256, *, hist=None): [MASK]\n"}
{"method_name": "threshold_isodata", "full_method_name": "threshold_isodata", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_isodata(image=None, nbins=256, return_all=False, *, hist=None):\n    \"\"\"Return threshold value(s) based on ISODATA method.\n\n    Histogram-based threshold, known as Ridler-Calvard method or inter-means.\n    Threshold values returned satisfy the following equality::\n\n        threshold = (image[image <= threshold].mean() +\n                     image[image > threshold].mean()) / 2.0\n\n    That is, returned thresholds are intensities that separate the image into\n    two groups of pixels, where the threshold intensity is midway between the\n    mean intensities of these groups.\n\n    For integer images, the above equality holds to within one; for floating-\n    point images, the equality holds to within the histogram bin-width.\n\n    Either image or hist must be provided. In case hist is given, the actual\n    histogram of the image is ignored.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray\n        Grayscale input image.\n    nbins : int, optional\n        Number of bins used to calculate histogram. This value is ignored for\n        integer arrays.\n    return_all : bool, optional\n        If False (default), return only the lowest threshold that satisfies\n        the above equality. If True, return all valid thresholds.\n    hist : array, or 2-tuple of arrays, optional\n        Histogram to determine the threshold from and a corresponding array\n        of bin center intensities. Alternatively, only the histogram can be\n        passed.\n\n    Returns\n    -------\n    threshold : float or int or array\n        Threshold value(s).\n\n    References\n    ----------\n    .. [1] Ridler, TW & Calvard, S (1978), \"Picture thresholding using an\n           iterative selection method\"\n           IEEE Transactions on Systems, Man and Cybernetics 8: 630-632,\n           :DOI:`10.1109/TSMC.1978.4310039`\n    .. [2] Sezgin M. and Sankur B. (2004) \"Survey over Image Thresholding\n           Techniques and Quantitative Performance Evaluation\" Journal of\n           Electronic Imaging, 13(1): 146-165,\n           http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf\n           :DOI:`10.1117/1.1631315`\n    .. [3] ImageJ AutoThresholder code,\n           http://fiji.sc/wiki/index.php/Auto_Threshold\n\n    Examples\n    --------\n    >>> from skimage.data import coins\n    >>> image = coins()\n    >>> thresh = threshold_isodata(image)\n    >>> binary = image > thresh\n    \"\"\"\n    counts, bin_centers = _validate_image_histogram(image, hist, nbins)\n    if len(bin_centers) == 1:\n        if return_all:\n            return bin_centers\n        else:\n            return bin_centers[0]\n    counts = counts.astype('float32', copy=False)\n    csuml = np.cumsum(counts)\n    csumh = csuml[-1] - csuml\n    intensity_sum = counts * bin_centers\n    csum_intensity = np.cumsum(intensity_sum)\n    lower = csum_intensity[:-1] / csuml[:-1]\n    higher = (csum_intensity[-1] - csum_intensity[:-1]) / csumh[:-1]\n    all_mean = (lower + higher) / 2.0\n    bin_width = bin_centers[1] - bin_centers[0]\n    distances = all_mean - bin_centers[:-1]\n    thresholds = bin_centers[:-1][(distances >= 0) & (distances < bin_width)]\n    if return_all:\n        return thresholds\n    else:\n        return thresholds[0]", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    threshold = threshold_isodata(camera)\n    assert np.floor((camera[camera <= threshold].mean() + camera[camera >\n        threshold].mean()) / 2.0) == threshold\n    assert threshold == 102\n    assert (threshold_isodata(camera, return_all=True) == [102, 103]).all()\n\ntest_isodata_camera_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_isodata(hist=hist)\n    assert threshold == 102\n\ntest_isodata_camera_image_histogram()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_isodata(hist=counts)\n    assert threshold == 102\n\ntest_isodata_camera_image_counts()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    threshold = threshold_isodata(coins)\n    assert np.floor((coins[coins <= threshold].mean() + coins[coins >\n        threshold].mean()) / 2.0) == threshold\n    assert threshold == 107\n    assert threshold_isodata(coins, return_all=True) == [107]\n\ntest_isodata_coins_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image():\n    moon = util.img_as_ubyte(data.moon())\n    threshold = threshold_isodata(moon)\n    assert np.floor((moon[moon <= threshold].mean() + moon[moon > threshold\n        ].mean()) / 2.0) == threshold\n    assert threshold == 86\n    thresholds = threshold_isodata(moon, return_all=True)\n    for threshold in thresholds:\n        assert np.floor((moon[moon <= threshold].mean() + moon[moon >\n            threshold].mean()) / 2.0) == threshold\n    assert_equal(thresholds, [86, 87, 88, 122, 123, 124, 139, 140])\n\ntest_isodata_moon_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image_negative_int():\n    moon = util.img_as_ubyte(data.moon()).astype(np.int32)\n    moon -= 100\n    threshold = threshold_isodata(moon)\n    assert np.floor((moon[moon <= threshold].mean() + moon[moon > threshold\n        ].mean()) / 2.0) == threshold\n    assert threshold == -14\n    thresholds = threshold_isodata(moon, return_all=True)\n    for threshold in thresholds:\n        assert np.floor((moon[moon <= threshold].mean() + moon[moon >\n            threshold].mean()) / 2.0) == threshold\n    assert_equal(thresholds, [-14, -13, -12, 22, 23, 24, 39, 40])\n\ntest_isodata_moon_image_negative_int()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image_negative_float():\n    moon = util.img_as_ubyte(data.moon()).astype(np.float64)\n    moon -= 100\n    assert -14 < threshold_isodata(moon) < -13\n    thresholds = threshold_isodata(moon, return_all=True)\n    assert_almost_equal(thresholds, [-13.83789062, -12.84179688, -\n        11.84570312, 22.02148438, 23.01757812, 24.01367188, 38.95507812, \n        39.95117188])\n\ntest_isodata_moon_image_negative_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_blank_zero(self):\n\t    image = np.zeros((5, 5), dtype=np.uint8)\n\t    assert threshold_isodata(image) == 0\n\t    assert threshold_isodata(image, return_all=True) == [0]\n\t\nTestSimpleImage().test_isodata_blank_zero()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_linspace(self):\n\t    image = np.linspace(-127, 0, 256)\n\t    assert -63.8 < threshold_isodata(image) < -63.6\n\t    assert_almost_equal(threshold_isodata(image, return_all=True), [-\n\t        63.74804688, -63.25195312])\n\t\nTestSimpleImage().test_isodata_linspace()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_16bit(self):\n\t    np.random.seed(0)\n\t    imfloat = np.random.rand(256, 256)\n\t    assert 0.49 < threshold_isodata(imfloat, nbins=1024) < 0.51\n\t    assert all(0.49 < threshold_isodata(imfloat, nbins=1024, return_all=True))\n\t\nTestSimpleImage().test_isodata_16bit()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_isodata function calculates and returns threshold value(s) for image binarization using the ISODATA method, which is also known as the Ridler-Calvard method or inter-means thresholding. This method finds an intensity that separates the image into two groups, where the threshold intensity is the mean of the mean intensities of these groups.\n\nInputs: \n- image: A 2D array representing a grayscale input image. This is optional, and either image or hist must be provided.\n- nbins: An integer specifying the number of bins used to calculate the histogram from the image. This parameter is ignored for integer arrays.\n- return_all: A boolean indicating whether to return only the lowest threshold satisfying the ISODATA condition (False, the default) or all valid thresholds (True).\n- hist: An optional array or 2-tuple of arrays representing the histogram to determine the threshold(s) from. If provided, hist can be a single array or a tuple consisting of the histogram and the corresponding array of bin center intensities. This parameter allows the function to use a pre-calculated histogram instead of calculating one from the image.\n\nOutputs:\n- threshold: A float, int, or array representing the threshold value(s) used for image binarization. The type and number of thresholds returned depend on the return_all parameter. If return_all is False, the function returns the lowest threshold satisfying the ISODATA condition. If return_all is True, it returns all valid thresholds.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_isodata(image=None, nbins=256, return_all=False, *, hist=None): [\n    MASK]\n"}
{"method_name": "threshold_minimum", "full_method_name": "threshold_minimum", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_minimum(image=None, nbins=256, max_num_iter=10000, *, hist=None):\n    \"\"\"Return threshold value based on minimum method.\n\n    The histogram of the input ``image`` is computed if not provided and\n    smoothed until there are only two maxima. Then the minimum in between is\n    the threshold value.\n\n    Either image or hist must be provided. In case hist is given, the actual\n    histogram of the image is ignored.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray, optional\n        Grayscale input image.\n    nbins : int, optional\n        Number of bins used to calculate histogram. This value is ignored for\n        integer arrays.\n    max_num_iter : int, optional\n        Maximum number of iterations to smooth the histogram.\n    hist : array, or 2-tuple of arrays, optional\n        Histogram to determine the threshold from and a corresponding array\n        of bin center intensities. Alternatively, only the histogram can be\n        passed.\n\n    Returns\n    -------\n    threshold : float\n        Upper threshold value. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    Raises\n    ------\n    RuntimeError\n        If unable to find two local maxima in the histogram or if the\n        smoothing takes more than 1e4 iterations.\n\n    References\n    ----------\n    .. [1] C. A. Glasbey, \"An analysis of histogram-based thresholding\n           algorithms,\" CVGIP: Graphical Models and Image Processing,\n           vol. 55, pp. 532-537, 1993.\n    .. [2] Prewitt, JMS & Mendelsohn, ML (1966), \"The analysis of cell\n           images\", Annals of the New York Academy of Sciences 128: 1035-1053\n           :DOI:`10.1111/j.1749-6632.1965.tb11715.x`\n\n    Examples\n    --------\n    >>> from skimage.data import camera\n    >>> image = camera()\n    >>> thresh = threshold_minimum(image)\n    >>> binary = image > thresh\n    \"\"\"\n\n    def find_local_maxima_idx(hist):\n        maximum_idxs = list()\n        direction = 1\n        for i in range(hist.shape[0] - 1):\n            if direction > 0:\n                if hist[i + 1] < hist[i]:\n                    direction = -1\n                    maximum_idxs.append(i)\n            elif hist[i + 1] > hist[i]:\n                direction = 1\n        return maximum_idxs\n    counts, bin_centers = _validate_image_histogram(image, hist, nbins)\n    smooth_hist = counts.astype('float32', copy=False)\n    for counter in range(max_num_iter):\n        smooth_hist = ndi.uniform_filter1d(smooth_hist, 3)\n        maximum_idxs = find_local_maxima_idx(smooth_hist)\n        if len(maximum_idxs) < 3:\n            break\n    if len(maximum_idxs) != 2:\n        raise RuntimeError('Unable to find two maxima in histogram')\n    elif counter == max_num_iter - 1:\n        raise RuntimeError('Maximum iteration reached for histogramsmoothing')\n    threshold_idx = np.argmin(smooth_hist[maximum_idxs[0]:maximum_idxs[1] + 1])\n    return bin_centers[maximum_idxs[0] + threshold_idx]", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum():\n    camera = util.img_as_ubyte(data.camera())\n    threshold = threshold_minimum(camera)\n    assert_equal(threshold, 85)\n    astronaut = util.img_as_ubyte(data.astronaut())\n    threshold = threshold_minimum(astronaut)\n    assert_equal(threshold, 114)\n\ntest_threshold_minimum()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_minimum(hist=hist)\n    assert_equal(threshold, 85)\n\ntest_threshold_minimum_histogram()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_minimum(hist=counts)\n    assert_equal(threshold, 85)\n\ntest_threshold_minimum_counts()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_synthetic():\n    img = np.arange(25 * 25, dtype=np.uint8).reshape((25, 25))\n    img[0:9, :] = 50\n    img[14:25, :] = 250\n    threshold = threshold_minimum(img)\n    assert_equal(threshold, 95)\n\ntest_threshold_minimum_synthetic()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_minimum function implements a method to determine a threshold value from an image's histogram, which is used to separate foreground from background. It smooths the histogram until only two maxima remain, then finds the minimum value between these maxima to set the threshold.\n\nInputs: \n- image: An (M, N[, ...]) ndarray representing a grayscale input image. This is optional if hist is provided.\n- nbins: An int value specifying the number of bins used to calculate the histogram. This is ignored for integer arrays.\n- max_num_iter: An int value specifying the maximum number of iterations allowed for smoothing the histogram.\n- hist: An array or 2-tuple of arrays representing the histogram from which to determine the threshold and a corresponding array of bin center intensities. Providing hist allows bypassing the computation of the histogram from the image.\n\nOutputs:\n- threshold: A float value representing the upper threshold. All pixels with an intensity higher than this value are considered foreground.\n\nThe function raises a RuntimeError if it is unable to find two local maxima in the histogram or if the smoothing process exceeds the specified maximum number of iterations.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_minimum(image=None, nbins=256, max_num_iter=10000, *, hist=None\n    ): [MASK]\n"}
{"method_name": "threshold_triangle", "full_method_name": "threshold_triangle", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_triangle(image, nbins=256):\n    \"\"\"Return threshold value based on the triangle algorithm.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray\n        Grayscale input image.\n    nbins : int, optional\n        Number of bins used to calculate histogram. This value is ignored for\n        integer arrays.\n\n    Returns\n    -------\n    threshold : float\n        Upper threshold value. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    References\n    ----------\n    .. [1] Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n       Automatic Measurement of Sister Chromatid Exchange Frequency,\n       Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n       :DOI:`10.1177/25.7.70454`\n    .. [2] ImageJ AutoThresholder code,\n       http://fiji.sc/wiki/index.php/Auto_Threshold\n\n    Examples\n    --------\n    >>> from skimage.data import camera\n    >>> image = camera()\n    >>> thresh = threshold_triangle(image)\n    >>> binary = image > thresh\n    \"\"\"\n    hist, bin_centers = histogram(image.reshape(-1), nbins, source_range=\n        'image')\n    nbins = len(hist)\n    arg_peak_height = np.argmax(hist)\n    peak_height = hist[arg_peak_height]\n    arg_low_level, arg_high_level = np.flatnonzero(hist)[[0, -1]]\n    if arg_low_level == arg_high_level:\n        return image.ravel()[0]\n    flip = arg_peak_height - arg_low_level < arg_high_level - arg_peak_height\n    if flip:\n        hist = hist[::-1]\n        arg_low_level = nbins - arg_high_level - 1\n        arg_peak_height = nbins - arg_peak_height - 1\n    del arg_high_level\n    width = arg_peak_height - arg_low_level\n    x1 = np.arange(width)\n    y1 = hist[x1 + arg_low_level]\n    norm = np.sqrt(peak_height ** 2 + width ** 2)\n    peak_height /= norm\n    width /= norm\n    length = peak_height * x1 - width * y1\n    arg_level = np.argmax(length) + arg_low_level\n    if flip:\n        arg_level = nbins - arg_level - 1\n    return bin_centers[arg_level]", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_uint_images():\n    assert threshold_triangle(np.invert(data.text())) == 151\n    assert threshold_triangle(data.text()) == 104\n    assert threshold_triangle(data.coins()) == 80\n    assert threshold_triangle(np.invert(data.coins())) == 175\n\ntest_triangle_uint_images()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_float_images():\n    text = data.text()\n    int_bins = text.max() - text.min() + 1\n    assert round(threshold_triangle(text.astype(float), nbins=int_bins)) == 104\n    assert round(threshold_triangle(text / 255.0, nbins=int_bins) * 255) == 104\n    assert round(threshold_triangle(np.invert(text).astype(float), nbins=\n        int_bins)) == 151\n    assert round(threshold_triangle(np.invert(text) / 255.0, nbins=int_bins\n        ) * 255) == 151\n\ntest_triangle_float_images()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_flip():\n    img = data.camera()\n    inv_img = np.invert(img)\n    t = threshold_triangle(inv_img)\n    t_inv_img = inv_img > t\n    t_inv_inv_img = np.invert(t_inv_img)\n    t = threshold_triangle(img)\n    t_img = img > t\n    unequal_pos = np.where(t_img.ravel() != t_inv_inv_img.ravel())\n    assert len(unequal_pos[0]) / t_img.size < 0.01\n\ntest_triangle_flip()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_triangle function determines a threshold value for segmenting a grayscale image into foreground and background based on the triangle algorithm. This threshold is calculated by analyzing the histogram of the image's intensity levels.\n\nInputs: \n1. image : (M, N[, ...]) ndarray\n   - Grayscale input image of any dimensionality.\n2. nbins : int, optional (default is 256)\n   - Number of bins to use for calculating the histogram. This parameter is ignored for integer arrays.\n\nOutputs: \n1. threshold : float\n   - The upper threshold value. All pixels with an intensity higher than this value are assumed to be part of the foreground.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_triangle(image, nbins=256): [MASK]\n"}
{"method_name": "threshold_niblack", "full_method_name": "threshold_niblack", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_niblack(image, window_size=15, k=0.2):\n    \"\"\"Applies Niblack local threshold to an array.\n\n    A threshold T is calculated for every pixel in the image using the\n    following formula::\n\n        T = m(x,y) - k * s(x,y)\n\n    where m(x,y) and s(x,y) are the mean and standard deviation of\n    pixel (x,y) neighborhood defined by a rectangular window with size w\n    times w centered around the pixel. k is a configurable parameter\n    that weights the effect of standard deviation.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray\n        Grayscale input image.\n    window_size : int, or iterable of int, optional\n        Window size specified as a single odd integer (3, 5, 7, \u2026),\n        or an iterable of length ``image.ndim`` containing only odd\n        integers (e.g. ``(1, 5, 5)``).\n    k : float, optional\n        Value of parameter k in threshold formula.\n\n    Returns\n    -------\n    threshold : (M, N[, ...]) ndarray\n        Threshold mask. All pixels with an intensity higher than\n        this value are assumed to be foreground.\n\n    Notes\n    -----\n    This algorithm is originally designed for text recognition.\n\n    The Bradley threshold is a particular case of the Niblack\n    one, being equivalent to\n\n    >>> from skimage import data\n    >>> image = data.page()\n    >>> q = 1\n    >>> threshold_image = threshold_niblack(image, k=0) * q\n\n    for some value ``q``. By default, Bradley and Roth use ``q=1``.\n\n\n    References\n    ----------\n    .. [1] W. Niblack, An introduction to Digital Image Processing,\n           Prentice-Hall, 1986.\n    .. [2] D. Bradley and G. Roth, \"Adaptive thresholding using Integral\n           Image\", Journal of Graphics Tools 12(2), pp. 13-21, 2007.\n           :DOI:`10.1080/2151237X.2007.10129236`\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> image = data.page()\n    >>> threshold_image = threshold_niblack(image, window_size=7, k=0.1)\n    \"\"\"\n    m, s = _mean_std(image, window_size)\n    return m - k * s", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_niblack_sauvola_pathological_image():\n    value = 0.03082192 + 2.19178082e-09\n    src_img = np.full((4, 4), value).astype(np.float64)\n    assert not np.any(np.isnan(threshold_niblack(src_img)))\n\ntest_niblack_sauvola_pathological_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: Applies Niblack local threshold to an input array, calculating a threshold for every pixel based on its mean and standard deviation in a specified window, and adjusting it by a constant factor k.\n\nInputs:\n- image: An (M, N[, ...]) ndarray representing a grayscale input image.\n- window_size: An int or an iterable of int (of length equal to the dimensions of the image) specifying the size of the window used to compute local means and standard deviations. The window size must be an odd integer.\n- k: A float representing the constant factor that weighs the effect of standard deviation in the threshold calculation formula.\n\nOutputs:\n- threshold: An (M, N[, ...]) ndarray representing the threshold mask. Pixels with an intensity higher than the corresponding threshold value are considered to be part of the foreground.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_niblack(image, window_size=15, k=0.2): [MASK]\n"}
{"method_name": "threshold_multiotsu", "full_method_name": "threshold_multiotsu", "method_path": "../srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "method_code": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\ndef threshold_multiotsu(image=None, classes=3, nbins=256, *, hist=None):\n    \"\"\"Generate `classes`-1 threshold values to divide gray levels in `image`,\n    following Otsu's method for multiple classes.\n\n    The threshold values are chosen to maximize the total sum of pairwise\n    variances between the thresholded graylevel classes. See Notes and [1]_\n    for more details.\n\n    Either image or hist must be provided. If hist is provided, the actual\n    histogram of the image is ignored.\n\n    Parameters\n    ----------\n    image : (M, N[, ...]) ndarray, optional\n        Grayscale input image.\n    classes : int, optional\n        Number of classes to be thresholded, i.e. the number of resulting\n        regions.\n    nbins : int, optional\n        Number of bins used to calculate the histogram. This value is ignored\n        for integer arrays.\n    hist : array, or 2-tuple of arrays, optional\n        Histogram from which to determine the threshold, and optionally a\n        corresponding array of bin center intensities. If no hist provided,\n        this function will compute it from the image (see notes).\n\n    Returns\n    -------\n    thresh : array\n        Array containing the threshold values for the desired classes.\n\n    Raises\n    ------\n    ValueError\n         If ``image`` contains less grayscale value then the desired\n         number of classes.\n\n    Notes\n    -----\n    This implementation relies on a Cython function whose complexity\n    is :math:`O\\\\left(\\\\frac{Ch^{C-1}}{(C-1)!}\\\\right)`, where :math:`h`\n    is the number of histogram bins and :math:`C` is the number of\n    classes desired.\n\n    If no hist is given, this function will make use of\n    `skimage.exposure.histogram`, which behaves differently than\n    `np.histogram`. While both allowed, use the former for consistent\n    behaviour.\n\n    The input image must be grayscale.\n\n    References\n    ----------\n    .. [1] Liao, P-S., Chen, T-S. and Chung, P-C., \"A fast algorithm for\n           multilevel thresholding\", Journal of Information Science and\n           Engineering 17 (5): 713-727, 2001. Available at:\n           <https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf>\n           :DOI:`10.6688/JISE.2001.17.5.1`\n    .. [2] Tosa, Y., \"Multi-Otsu Threshold\", a java plugin for ImageJ.\n           Available at:\n           <http://imagej.net/plugins/download/Multi_OtsuThreshold.java>\n\n    Examples\n    --------\n    >>> from skimage.color import label2rgb\n    >>> from skimage import data\n    >>> image = data.camera()\n    >>> thresholds = threshold_multiotsu(image)\n    >>> regions = np.digitize(image, bins=thresholds)\n    >>> regions_colorized = label2rgb(regions)\n    \"\"\"\n    if image is not None and image.ndim > 2 and image.shape[-1] in (3, 4):\n        warn(\n            f'threshold_multiotsu is expected to work correctly only for grayscale images; image shape {image.shape} looks like that of an RGB image.'\n            )\n    prob, bin_centers = _validate_image_histogram(image, hist, nbins,\n        normalize=True)\n    prob = prob.astype('float32', copy=False)\n    nvalues = np.count_nonzero(prob)\n    if nvalues < classes:\n        msg = (\n            f'After discretization into bins, the input image has only {nvalues} different values. It cannot be thresholded in {classes} classes. If there are more unique values before discretization, try increasing the number of bins (`nbins`).'\n            )\n        raise ValueError(msg)\n    elif nvalues == classes:\n        thresh_idx = np.flatnonzero(prob)[:-1]\n    else:\n        try:\n            thresh_idx = _get_multiotsu_thresh_indices_lut(prob, classes - 1)\n        except MemoryError:\n            thresh_idx = _get_multiotsu_thresh_indices(prob, classes - 1)\n    thresh = bin_centers[thresh_idx]\n    return thresh", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_bimodal_multiotsu_hist():\n    for name in ['camera', 'moon', 'coins', 'text', 'clock', 'page']:\n        img = getattr(data, name)()\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n    for name in ['chelsea', 'coffee', 'astronaut', 'rocket']:\n        img = rgb2gray(getattr(data, name)())\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n\ntest_bimodal_multiotsu_hist()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_check_multiotsu_results():\n    image = 0.25 * np.array([[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3,\n        4], [0, 1, 2, 3, 4]])\n    for idx in range(3, 6):\n        thr_multi = threshold_multiotsu(image, classes=idx)\n        assert len(thr_multi) == idx - 1\n\ntest_check_multiotsu_results()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_output():\n    image = np.zeros((100, 100), dtype='int')\n    coords = [(25, 25), (50, 50), (75, 75)]\n    values = [64, 128, 192]\n    for coor, val in zip(coords, values):\n        rr, cc = disk(coor, 20)\n        image[rr, cc] = val\n    thresholds = [0, 64, 128]\n    assert np.array_equal(thresholds, threshold_multiotsu(image, classes=4))\n\ntest_multiotsu_output()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert_almost_equal(threshold_multiotsu(img), [58, 149])\n\ntest_multiotsu_astro_image()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "instruction": "Functionality: The threshold_multiotsu function computes threshold values for an image to segment it into multiple regions, based on the Otsu's method for multiple classes. The function aims to maximize the total sum of pairwise variances between the thresholded gray-level classes.\n\nInputs: \n- image: A 2D grayscale input image. This is optional as the function can also work with provided histogram data.\n- classes: An integer specifying the number of classes to be thresholded, which corresponds to the number of resulting regions.\n- nbins: An integer specifying the number of bins used to calculate the histogram. This parameter is ignored for integer arrays.\n- hist: An array or a 2-tuple of arrays representing the histogram from which to determine the threshold, and optionally, a corresponding array of bin center intensities. Providing hist allows the function to operate without computing the histogram from the image.\n\nOutputs: \n- thresh: An array containing the threshold values for the desired number of classes. These values can be used to segment the input image into multiple regions based on grayscale values.", "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_multiotsu(image=None, classes=3, nbins=256, *, hist=None): [MASK]\n"}
{"method_name": "ball", "full_method_name": "ball", "method_path": "../srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "method_code": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\ndef ball(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None):\n    \"\"\"Generates a ball-shaped footprint.\n\n    This is the 3D equivalent of a disk.\n    A pixel is within the neighborhood if the Euclidean distance between\n    it and the origin is no greater than radius.\n\n    Parameters\n    ----------\n    radius : int\n        The radius of the ball-shaped footprint.\n\n    Other Parameters\n    ----------------\n    dtype : data-type, optional\n        The data type of the footprint.\n    strict_radius : bool, optional\n        If False, extend the radius by 0.5. This allows the circle to expand\n        further within a cube that remains of size ``2 * radius + 1`` along\n        each axis. This parameter is ignored if decomposition is not None.\n    decomposition : {None, 'sequence'}, optional\n        If None, a single array is returned. For 'sequence', a tuple of smaller\n        footprints is returned. Applying this series of smaller footprints will\n        given a result equivalent to a single, larger footprint, but with\n        better computational performance. For ball footprints, the sequence\n        decomposition is not exactly equivalent to decomposition=None.\n        See Notes for more details.\n\n    Returns\n    -------\n    footprint : ndarray or tuple\n        The footprint where elements of the neighborhood are 1 and 0 otherwise.\n\n    Notes\n    -----\n    The disk produced by the decomposition='sequence' mode is not identical\n    to that with decomposition=None. Here we extend the approach taken in [1]_\n    for disks to the 3D case, using 3-dimensional extensions of the \"square\",\n    \"diamond\" and \"t-shaped\" elements from that publication. All of these\n    elementary elements have size ``(3,) * ndim``. We numerically computed the\n    number of repetitions of each element that gives the closest match to the\n    ball computed with kwargs ``strict_radius=False, decomposition=None``.\n\n    Empirically, the equivalent composite footprint to the sequence\n    decomposition approaches a rhombicuboctahedron (26-faces [2]_).\n\n    References\n    ----------\n    .. [1] Park, H and Chin R.T. Decomposition of structuring elements for\n           optimal implementation of morphological operations. In Proceedings:\n           1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,\n           UK.\n           https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf\n    .. [2] https://en.wikipedia.org/wiki/Rhombicuboctahedron\n    \"\"\"\n    if decomposition is None:\n        n = 2 * radius + 1\n        Z, Y, X = np.mgrid[-radius:radius:n * 1.0j, -radius:radius:n * 1.0j,\n            -radius:radius:n * 1.0j]\n        s = X ** 2 + Y ** 2 + Z ** 2\n        if not strict_radius:\n            radius += 0.5\n        return np.array(s <= radius * radius, dtype=dtype)\n    elif decomposition == 'sequence':\n        sequence = _nsphere_series_decomposition(radius, ndim=3, dtype=dtype)\n    else:\n        raise ValueError(f'Unrecognized decomposition: {decomposition}')\n    return sequence", "test_code_list": [{"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float_3d(self):\n\t    np.random.seed(0)\n\t    volume_uint = np.random.randint(0, high=256, size=(10, 20, 30), dtype=\n\t        np.uint8)\n\t    volume_float = img_as_float(volume_uint)\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_uint, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(volume_float, ball(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed_3d(self):\n\t    np.random.seed(0)\n\t    volume_s = np.random.randint(0, high=127, size=(10, 20, 30), dtype=np.int8)\n\t    volume_u = img_as_ubyte(volume_s)\n\t    assert_equal(volume_u, img_as_ubyte(volume_s))\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_u, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(volume_s, ball(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}], "instruction": "Functionality: Generates a 3D ball-shaped footprint. Pixels are within the neighborhood if the Euclidean distance between them and the origin is no greater than the specified radius.\n\nInputs:\n    radius : int\n        The radius of the ball-shaped footprint.\n    dtype : data-type, optional (default is np.uint8)\n        The data type of the footprint.\n    strict_radius : bool, optional (default is True)\n        If False, extend the radius by 0.5, allowing the ball to expand further while maintaining size ``2 * radius + 1`` along each axis. Ignored if decomposition is not None.\n    decomposition : {None, 'sequence'}, optional (default is None)\n        If None, a single array is returned. For 'sequence', a tuple of smaller footprints is returned. Applying this series provides better computational performance, but for ball footprints, the sequence is not exactly equivalent to decomposition=None.\n\nOutputs:\n    footprint : ndarray or tuple\n        The footprint where elements of the neighborhood are 1 and 0 otherwise.", "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef ball(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None): [M\n    ASK]\n"}
{"method_name": "morphological_geodesic_active_contour", "full_method_name": "morphological_geodesic_active_contour", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/morphsnakes.py", "method_code": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\ndef morphological_geodesic_active_contour(gimage, num_iter, init_level_set=\n    'disk', smoothing=1, threshold='auto', balloon=0, iter_callback=lambda\n    x: None):\n    \"\"\"Morphological Geodesic Active Contours (MorphGAC).\n\n    Geodesic active contours implemented with morphological operators. It can\n    be used to segment objects with visible but noisy, cluttered, broken\n    borders.\n\n    Parameters\n    ----------\n    gimage : (M, N) or (L, M, N) array\n        Preprocessed image or volume to be segmented. This is very rarely the\n        original image. Instead, this is usually a preprocessed version of the\n        original image that enhances and highlights the borders (or other\n        structures) of the object to segment.\n        :func:`morphological_geodesic_active_contour` will try to stop the contour\n        evolution in areas where `gimage` is small. See\n        :func:`inverse_gaussian_gradient` as an example function to\n        perform this preprocessing. Note that the quality of\n        :func:`morphological_geodesic_active_contour` might greatly depend on this\n        preprocessing.\n    num_iter : uint\n        Number of num_iter to run.\n    init_level_set : str, (M, N) array, or (L, M, N) array\n        Initial level set. If an array is given, it will be binarized and used\n        as the initial level set. If a string is given, it defines the method\n        to generate a reasonable initial level set with the shape of the\n        `image`. Accepted values are 'checkerboard' and 'disk'. See the\n        documentation of `checkerboard_level_set` and `disk_level_set`\n        respectively for details about how these level sets are created.\n    smoothing : uint, optional\n        Number of times the smoothing operator is applied per iteration.\n        Reasonable values are around 1-4. Larger values lead to smoother\n        segmentations.\n    threshold : float, optional\n        Areas of the image with a value smaller than this threshold will be\n        considered borders. The evolution of the contour will stop in these\n        areas.\n    balloon : float, optional\n        Balloon force to guide the contour in non-informative areas of the\n        image, i.e., areas where the gradient of the image is too small to push\n        the contour towards a border. A negative value will shrink the contour,\n        while a positive value will expand the contour in these areas. Setting\n        this to zero will disable the balloon force.\n    iter_callback : function, optional\n        If given, this function is called once per iteration with the current\n        level set as the only argument. This is useful for debugging or for\n        plotting intermediate results during the evolution.\n\n    Returns\n    -------\n    out : (M, N) or (L, M, N) array\n        Final segmentation (i.e., the final level set)\n\n    See Also\n    --------\n    inverse_gaussian_gradient, disk_level_set, checkerboard_level_set\n\n    Notes\n    -----\n    This is a version of the Geodesic Active Contours (GAC) algorithm that uses\n    morphological operators instead of solving partial differential equations\n    (PDEs) for the evolution of the contour. The set of morphological operators\n    used in this algorithm are proved to be infinitesimally equivalent to the\n    GAC PDEs (see [1]_). However, morphological operators are do not suffer\n    from the numerical stability issues typically found in PDEs (e.g., it is\n    not necessary to find the right time step for the evolution), and are\n    computationally faster.\n\n    The algorithm and its theoretical derivation are described in [1]_.\n\n    References\n    ----------\n    .. [1] A Morphological Approach to Curvature-based Evolution of Curves and\n           Surfaces, Pablo M\u00e1rquez-Neila, Luis Baumela, Luis \u00c1lvarez. In IEEE\n           Transactions on Pattern Analysis and Machine Intelligence (PAMI),\n           2014, :DOI:`10.1109/TPAMI.2013.106`\n    \"\"\"\n    image = gimage\n    init_level_set = _init_level_set(init_level_set, image.shape)\n    _check_input(image, init_level_set)\n    if threshold == 'auto':\n        threshold = np.percentile(image, 40)\n    structure = np.ones((3,) * len(image.shape), dtype=np.int8)\n    dimage = np.gradient(image)\n    if balloon != 0:\n        threshold_mask_balloon = image > threshold / np.abs(balloon)\n    u = np.int8(init_level_set > 0)\n    iter_callback(u)\n    for _ in range(num_iter):\n        if balloon > 0:\n            aux = ndi.binary_dilation(u, structure)\n        elif balloon < 0:\n            aux = ndi.binary_erosion(u, structure)\n        if balloon != 0:\n            u[threshold_mask_balloon] = aux[threshold_mask_balloon]\n        aux = np.zeros_like(image)\n        du = np.gradient(u)\n        for el1, el2 in zip(dimage, du):\n            aux += el1 * el2\n        u[aux > 0] = 1\n        u[aux < 0] = 0\n        for _ in range(smoothing):\n            u = _curvop(u)\n        iter_callback(u)\n    return u", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_init_level_sets():\n    image = np.zeros((6, 6))\n    checkerboard_ls = morphological_chan_vese(image, 0, 'checkerboard')\n    checkerboard_ref = np.array([[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0,\n        0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1,\n        1, 0]], dtype=np.int8)\n    disk_ls = morphological_geodesic_active_contour(image, 0, 'disk')\n    disk_ref = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 1, \n        1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0\n        ]], dtype=np.int8)\n    assert_array_equal(checkerboard_ls, checkerboard_ref)\n    assert_array_equal(disk_ls, disk_ref)\n\ntest_init_level_sets()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}], "instruction": "Functionality: The morphological_geodesic_active_contour function implements the Morphological Geodesic Active Contours (MorphGAC) algorithm. This algorithm segments objects in images where borders are visible but may be noisy, cluttered, or broken. It uses morphological operators to evolve the contour, stopping in areas defined by the 'gimage' parameter, which is a preprocessed version of the image that highlights the features to be segmented.\n\nInputs: \n- gimage: A preprocessed (M, N) or (L, M, N) array image intended for segmentation. This image should emphasize borders or other structures of the object to segment.\n- num_iter: The number of iterations to run.\n- init_level_set: An initial level set given as a string ('checkerboard' or 'disk') or as an (M, N) or (L, M, N) array. The array will be binarized and used as the initial contour.\n- smoothing: Optional. The number of times the smoothing operator is applied per iteration, typically between 1-4.\n- threshold: Optional. Float value representing the threshold below which areas of the image will be considered borders, affecting contour evolution.\n- balloon: Optional. A float value that guides the contour in non-informative areas. Negative values shrink the contour, positive values expand it, and zero disables the balloon force.\n- iter_callback: Optional. A function that, if given, is called once per iteration with the current level set as its only argument.\n\nOutputs:\n- out: A final segmentation (M, N) or (L, M, N) array representing the final level set.", "method_code_mask": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_geodesic_active_contour(gimage, num_iter, init_level_set=\n    'disk', smoothing=1, threshold='auto', balloon=0, iter_callback=lambda\n    x: None): [MASK]\n"}
{"method_name": "morphological_chan_vese", "full_method_name": "morphological_chan_vese", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/morphsnakes.py", "method_code": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\ndef morphological_chan_vese(image, num_iter, init_level_set='checkerboard',\n    smoothing=1, lambda1=1, lambda2=1, iter_callback=lambda x: None):\n    \"\"\"Morphological Active Contours without Edges (MorphACWE)\n\n    Active contours without edges implemented with morphological operators. It\n    can be used to segment objects in images and volumes without well defined\n    borders. It is required that the inside of the object looks different on\n    average than the outside (i.e., the inner area of the object should be\n    darker or lighter than the outer area on average).\n\n    Parameters\n    ----------\n    image : (M, N) or (L, M, N) array\n        Grayscale image or volume to be segmented.\n    num_iter : uint\n        Number of num_iter to run\n    init_level_set : str, (M, N) array, or (L, M, N) array\n        Initial level set. If an array is given, it will be binarized and used\n        as the initial level set. If a string is given, it defines the method\n        to generate a reasonable initial level set with the shape of the\n        `image`. Accepted values are 'checkerboard' and 'disk'. See the\n        documentation of `checkerboard_level_set` and `disk_level_set`\n        respectively for details about how these level sets are created.\n    smoothing : uint, optional\n        Number of times the smoothing operator is applied per iteration.\n        Reasonable values are around 1-4. Larger values lead to smoother\n        segmentations.\n    lambda1 : float, optional\n        Weight parameter for the outer region. If `lambda1` is larger than\n        `lambda2`, the outer region will contain a larger range of values than\n        the inner region.\n    lambda2 : float, optional\n        Weight parameter for the inner region. If `lambda2` is larger than\n        `lambda1`, the inner region will contain a larger range of values than\n        the outer region.\n    iter_callback : function, optional\n        If given, this function is called once per iteration with the current\n        level set as the only argument. This is useful for debugging or for\n        plotting intermediate results during the evolution.\n\n    Returns\n    -------\n    out : (M, N) or (L, M, N) array\n        Final segmentation (i.e., the final level set)\n\n    See Also\n    --------\n    disk_level_set, checkerboard_level_set\n\n    Notes\n    -----\n    This is a version of the Chan-Vese algorithm that uses morphological\n    operators instead of solving a partial differential equation (PDE) for the\n    evolution of the contour. The set of morphological operators used in this\n    algorithm are proved to be infinitesimally equivalent to the Chan-Vese PDE\n    (see [1]_). However, morphological operators are do not suffer from the\n    numerical stability issues typically found in PDEs (it is not necessary to\n    find the right time step for the evolution), and are computationally\n    faster.\n\n    The algorithm and its theoretical derivation are described in [1]_.\n\n    References\n    ----------\n    .. [1] A Morphological Approach to Curvature-based Evolution of Curves and\n           Surfaces, Pablo M\u00e1rquez-Neila, Luis Baumela, Luis \u00c1lvarez. In IEEE\n           Transactions on Pattern Analysis and Machine Intelligence (PAMI),\n           2014, :DOI:`10.1109/TPAMI.2013.106`\n    \"\"\"\n    init_level_set = _init_level_set(init_level_set, image.shape)\n    _check_input(image, init_level_set)\n    u = np.int8(init_level_set > 0)\n    iter_callback(u)\n    for _ in range(num_iter):\n        c0 = (image * (1 - u)).sum() / float((1 - u).sum() + 1e-08)\n        c1 = (image * u).sum() / float(u.sum() + 1e-08)\n        du = np.gradient(u)\n        abs_du = np.abs(du).sum(0)\n        aux = abs_du * (lambda1 * (image - c1) ** 2 - lambda2 * (image - c0\n            ) ** 2)\n        u[aux < 0] = 1\n        u[aux > 0] = 0\n        for _ in range(smoothing):\n            u = _curvop(u)\n        iter_callback(u)\n    return u", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_init_level_sets():\n    image = np.zeros((6, 6))\n    checkerboard_ls = morphological_chan_vese(image, 0, 'checkerboard')\n    checkerboard_ref = np.array([[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0,\n        0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1,\n        1, 0]], dtype=np.int8)\n    disk_ls = morphological_geodesic_active_contour(image, 0, 'disk')\n    disk_ref = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 1, \n        1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0\n        ]], dtype=np.int8)\n    assert_array_equal(checkerboard_ls, checkerboard_ref)\n    assert_array_equal(disk_ls, disk_ref)\n\ntest_init_level_sets()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_morphsnakes_3d():\n    image = np.zeros((7, 7, 7))\n    evolution = []\n\n    def callback(x):\n        evolution.append(x.sum())\n    ls = morphological_chan_vese(image, 5, 'disk', iter_callback=callback)\n    assert evolution[0] == 81\n    assert ls.sum() == 0\n    for v1, v2 in zip(evolution[:-1], evolution[1:]):\n        assert v1 >= v2\n\ntest_morphsnakes_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}], "instruction": "Functionality: The morphological_chan_vese function implements the Morphological Active Contours without Edges (MorphACWE) algorithm to segment objects in grayscale images or volumes. It is particularly useful for segmenting objects without well-defined borders, requiring that the object's inner area appears different on average from its outer area.\n\nInputs: \n- image: A 2D array (M, N) or 3D array (L, M, N) representing the grayscale image or volume to be segmented.\n- num_iter: An unsigned integer specifying the number of iterations to run.\n- init_level_set: A string ('checkerboard' or 'disk') or a 2D/3D array representing the initial level set for segmentation. If an array is provided, it is binarized and used as the initial level set. If a string is provided, a level set is generated using the specified initial method.\n- smoothing: An unsigned integer that determines the number of smoothing operations applied per iteration. A reasonable value is typically between 1-4.\n- lambda1: A float representing the weight parameter for the outer region, affecting the range of values the outer region can contain relative to the inner region.\n- lambda2: A float representing the weight parameter for the inner region, affecting the range of values the inner region can contain relative to the outer region.\n- iter_callback: A function that, if given, is called once per iteration with the current level set as the only argument. This is useful for debugging or monitoring intermediate results.\n\nOutputs: \n- out: A 2D (M, N) or 3D (L, M, N) array representing the final segmentation, i.e., the final level set.", "method_code_mask": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_chan_vese(image, num_iter, init_level_set='checkerboard',\n    smoothing=1, lambda1=1, lambda2=1, iter_callback=lambda x: None): [MASK]\n"}
{"method_name": "relabel_sequential", "full_method_name": "relabel_sequential", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/_join.py", "method_code": "import numpy as np\ndef relabel_sequential(label_field, offset=1):\n    \"\"\"Relabel arbitrary labels to {`offset`, ... `offset` + number_of_labels}.\n\n    This function also returns the forward map (mapping the original labels to\n    the reduced labels) and the inverse map (mapping the reduced labels back\n    to the original ones).\n\n    Parameters\n    ----------\n    label_field : numpy array of int, arbitrary shape\n        An array of labels, which must be non-negative integers.\n    offset : int, optional\n        The return labels will start at `offset`, which should be\n        strictly positive.\n\n    Returns\n    -------\n    relabeled : numpy array of int, same shape as `label_field`\n        The input label field with labels mapped to\n        {offset, ..., number_of_labels + offset - 1}.\n        The data type will be the same as `label_field`, except when\n        offset + number_of_labels causes overflow of the current data type.\n    forward_map : ArrayMap\n        The map from the original label space to the returned label\n        space. Can be used to re-apply the same mapping. See examples\n        for usage. The output data type will be the same as `relabeled`.\n    inverse_map : ArrayMap\n        The map from the new label space to the original space. This\n        can be used to reconstruct the original label field from the\n        relabeled one. The output data type will be the same as `label_field`.\n\n    Notes\n    -----\n    The label 0 is assumed to denote the background and is never remapped.\n\n    The forward map can be extremely big for some inputs, since its\n    length is given by the maximum of the label field. However, in most\n    situations, ``label_field.max()`` is much smaller than\n    ``label_field.size``, and in these cases the forward map is\n    guaranteed to be smaller than either the input or output images.\n\n    Examples\n    --------\n    >>> from skimage.segmentation import relabel_sequential\n    >>> label_field = np.array([1, 1, 5, 5, 8, 99, 42])\n    >>> relab, fw, inv = relabel_sequential(label_field)\n    >>> relab\n    array([1, 1, 2, 2, 3, 5, 4])\n    >>> print(fw)\n    ArrayMap:\n      1 \u2192 1\n      5 \u2192 2\n      8 \u2192 3\n      42 \u2192 4\n      99 \u2192 5\n    >>> np.array(fw)\n    array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5])\n    >>> np.array(inv)\n    array([ 0,  1,  5,  8, 42, 99])\n    >>> (fw[label_field] == relab).all()\n    True\n    >>> (inv[relab] == label_field).all()\n    True\n    >>> relab, fw, inv = relabel_sequential(label_field, offset=5)\n    >>> relab\n    array([5, 5, 6, 6, 7, 9, 8])\n    \"\"\"\n    if offset <= 0:\n        raise ValueError('Offset must be strictly positive.')\n    if np.min(label_field) < 0:\n        raise ValueError('Cannot relabel array that contains negative values.')\n    offset = int(offset)\n    in_vals = np.unique(label_field)\n    if in_vals[0] == 0:\n        out_vals = np.concatenate([[0], np.arange(offset, offset + len(\n            in_vals) - 1)])\n    else:\n        out_vals = np.arange(offset, offset + len(in_vals))\n    input_type = label_field.dtype\n    if input_type.kind not in 'iu':\n        raise TypeError('label_field must have an integer dtype')\n    required_type = np.min_scalar_type(out_vals[-1])\n    if input_type.itemsize < required_type.itemsize:\n        output_type = required_type\n    elif out_vals[-1] < np.iinfo(input_type).max:\n        output_type = input_type\n    else:\n        output_type = required_type\n    out_array = np.empty(label_field.shape, dtype=output_type)\n    out_vals = out_vals.astype(output_type)\n    map_array(label_field, in_vals, out_vals, out=out_array)\n    fw_map = ArrayMap(in_vals, out_vals)\n    inv_map = ArrayMap(out_vals, in_vals)\n    return out_array, fw_map, inv_map", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_relabel_sequential_signed_overflow():\n    imax = np.iinfo(np.int32).max\n    labels = np.array([0, 1, 99, 42, 42], dtype=np.int32)\n    output, fw, inv = relabel_sequential(labels, offset=imax)\n    reference = np.array([0, imax, imax + 2, imax + 1, imax + 1], dtype=np.\n        uint32)\n    assert_array_equal(output, reference)\n    assert output.dtype == reference.dtype\n\ntest_relabel_sequential_signed_overflow()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_very_large_labels():\n    imax = np.iinfo(np.int64).max\n    labels = np.array([0, 1, imax, 42, 42], dtype=np.int64)\n    output, fw, inv = relabel_sequential(labels, offset=imax)\n    assert np.max(output) == imax + 2\n\ntest_very_large_labels()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_call():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    testing.assert_array_equal(relabeled, fw(ar))\n    testing.assert_array_equal(ar, inv(relabeled))\n\ntest_arraymap_call()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_len():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    assert len(fw) == 100\n    assert len(fw) == len(np.array(fw))\n    assert len(inv) == 6\n    assert len(inv) == len(np.array(inv))\n\ntest_arraymap_len()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_set():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    fw[72] = 6\n    assert fw[72] == 6\n\ntest_arraymap_set()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}], "instruction": "Functionality: The relabel_sequential function remaps the labels in a given label field to a sequence starting from a specified offset, while maintaining the relative order of the labels. It also generates forward and inverse maps to track the original-to-new and new-to-original label mappings, respectively.\n\nInputs: \n- label_field: A numpy array of integers representing the label field to be relabeled. The array can have an arbitrary shape but must only contain non-negative integers.\n- offset (optional): An integer that determines the starting point of the relabeled sequence. The default value is 1.\n\nOutputs: \n- relabeled: A numpy array of integers with the same shape as the input label_field, where labels have been mapped to a sequence starting from the 'offset' value. The data type of the output will match that of the input, except when the offset + number_of_labels exceeds the current data type's limit.\n- forward_map: An ArrayMap object that maps the original labels to the reduced labels. This map can be used to apply the same relabeling to other fields.\n- inverse_map: An ArrayMap object that maps the reduced labels back to the original labels. This map can be used to reconstruct the original label field from the relabeled one.", "method_code_mask": "import numpy as np\n\n\ndef relabel_sequential(label_field, offset=1): [MASK]\n"}
{"method_name": "clear_border", "full_method_name": "clear_border", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/_clear_border.py", "method_code": "import numpy as np\ndef clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    \"\"\"Clear objects connected to the label image border.\n\n    Parameters\n    ----------\n    labels : (M[, N[, ..., P]]) array of int or bool\n        Imaging data labels.\n    buffer_size : int, optional\n        The width of the border examined.  By default, only objects\n        that touch the outside of the image are removed.\n    bgval : float or int, optional\n        Cleared objects are set to this value.\n    mask : ndarray of bool, same shape as `image`, optional.\n        Image data mask. Objects in labels image overlapping with\n        False pixels of mask will be removed. If defined, the\n        argument buffer_size will be ignored.\n    out : ndarray\n        Array of the same shape as `labels`, into which the\n        output is placed. By default, a new array is created.\n\n    Returns\n    -------\n    out : (M[, N[, ..., P]]) array\n        Imaging data labels with cleared borders\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from skimage.segmentation import clear_border\n    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\n    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],\n    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],\n    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],\n    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],\n    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    >>> clear_border(labels)\n    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 1, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],\n    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\n    >>> clear_border(labels, mask=mask)\n    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],\n           [0, 0, 0, 0, 1, 0, 0, 1, 0],\n           [0, 0, 0, 1, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 1, 1, 1, 0, 0],\n           [0, 1, 1, 1, 1, 1, 1, 1, 0],\n           [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n\n    \"\"\"\n    if any(buffer_size >= s for s in labels.shape) and mask is None:\n        raise ValueError('buffer size may not be greater than labels size')\n    if out is None:\n        out = labels.copy()\n    if mask is not None:\n        err_msg = (\n            f'labels and mask should have the same shape but are {out.shape} and {mask.shape}'\n            )\n        if out.shape != mask.shape:\n            raise (ValueError, err_msg)\n        if mask.dtype != bool:\n            raise TypeError('mask should be of type bool.')\n        borders = ~mask\n    else:\n        borders = np.zeros_like(out, dtype=bool)\n        ext = buffer_size + 1\n        slstart = slice(ext)\n        slend = slice(-ext, None)\n        slices = [slice(None) for _ in out.shape]\n        for d in range(out.ndim):\n            slices[d] = slstart\n            borders[tuple(slices)] = True\n            slices[d] = slend\n            borders[tuple(slices)] = True\n            slices[d] = slice(None)\n    labels, number = label(out, background=0, return_num=True)\n    borders_indices = np.unique(labels[borders])\n    indices = np.arange(number + 1)\n    label_mask = np.isin(indices, borders_indices)\n    mask = label_mask[labels.reshape(-1)].reshape(labels.shape)\n    out[mask] = bgval\n    return out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 1,\n        0], [1, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 1,\n        1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    result = clear_border(image.copy())\n    ref = image.copy()\n    ref[1:3, 0:2] = 0\n    ref[0:2, -2] = 0\n    assert_array_equal(result, ref)\n    result = clear_border(image.copy(), 1)\n    assert_array_equal(result, np.zeros(result.shape))\n    result = clear_border(image.copy(), buffer_size=1, bgval=2)\n    assert_array_equal(result, 2 * np.ones_like(image))\n    mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, \n        1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1,\n        1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\n    result = clear_border(image.copy(), mask=mask)\n    ref = image.copy()\n    ref[1:3, 0:2] = 0\n    assert_array_equal(result, ref)\n\ntest_clear_border()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_3d():\n    image = np.array([[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, \n        0]], [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]], [[0,\n        0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]])\n    result = clear_border(image.copy())\n    ref = image.copy()\n    ref[0, 3, 0] = 0\n    assert_array_equal(result, ref)\n    result = clear_border(image.copy(), 1)\n    assert_array_equal(result, np.zeros(result.shape))\n    result = clear_border(image.copy(), buffer_size=1, bgval=2)\n    assert_array_equal(result, 2 * np.ones_like(image))\n\ntest_clear_border_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_non_binary():\n    image = np.array([[1, 2, 3, 1, 2], [3, 3, 5, 4, 2], [3, 4, 5, 4, 2], [3,\n        3, 2, 1, 2]])\n    result = clear_border(image)\n    expected = np.array([[0, 0, 0, 0, 0], [0, 0, 5, 4, 0], [0, 4, 5, 4, 0],\n        [0, 0, 0, 0, 0]])\n    assert_array_equal(result, expected)\n    assert_(not np.all(image == result))\n\ntest_clear_border_non_binary()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_non_binary_3d():\n    image3d = np.array([[[1, 2, 3, 1, 2], [3, 3, 3, 4, 2], [3, 4, 3, 4, 2],\n        [3, 3, 2, 1, 2]], [[1, 2, 3, 1, 2], [3, 3, 5, 4, 2], [3, 4, 5, 4, 2\n        ], [3, 3, 2, 1, 2]], [[1, 2, 3, 1, 2], [3, 3, 3, 4, 2], [3, 4, 3, 4,\n        2], [3, 3, 2, 1, 2]]])\n    result = clear_border(image3d)\n    expected = np.array([[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0\n        ], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0,\n        0], [0, 0, 0, 0, 0]]])\n    assert_array_equal(result, expected)\n    assert_(not np.all(image3d == result))\n\ntest_clear_border_non_binary_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}], "instruction": "Functionality: The clear_border function is designed to remove objects from a label image that are connected to the image border. This is particularly useful in image processing tasks where border-connected objects need to be isolated or removed for further analysis.\n\nInputs: \n1. labels: A multidimensional array (M[,N[, ...,P]]) of integers or booleans representing imaging data labels.\n2. buffer_size: An optional integer that defines the width of the border examined for object removal. Default is 0, meaning only objects touching the image borders are removed.\n3. bgval: An optional float or integer that objects cleared from the image are set to. Default is 0.\n4. mask: An optional boolean array with the same shape as the 'image'. Objects in the labels image overlapping with False pixels of the mask will be removed. If defined, the buffer_size argument is ignored.\n5. out: An optional output array. If provided, the function modifies this array in place. By default, a new array is created for the output.\n\nOutputs:\n1. out: A multidimensional array (M[,N[, ...,P]]) representing the imaging data labels with cleared borders. The output array has the same dimensions as the input 'labels' array, with border-connected objects removed or set to the specified 'bgval'.", "method_code_mask": "import numpy as np\n\n\ndef clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None): [MASK\n    ]\n"}
{"method_name": "make_2d_syntheticdata", "full_method_name": "make_2d_syntheticdata", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py", "method_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef make_2d_syntheticdata(lx, ly=None):\n    if ly is None:\n        ly = lx\n    np.random.seed(1234)\n    data = np.zeros((lx, ly)) + 0.1 * np.random.randn(lx, ly)\n    small_l = int(lx // 5)\n    data[lx // 2 - small_l:lx // 2 + small_l, ly // 2 - small_l:ly // 2 +\n        small_l] = 1\n    data[lx // 2 - small_l + 1:lx // 2 + small_l - 1, ly // 2 - small_l + 1\n        :ly // 2 + small_l - 1] = 0.1 * np.random.randn(2 * small_l - 2, 2 *\n        small_l - 2)\n    data[lx // 2 - small_l, ly // 2 - small_l // 8:ly // 2 + small_l // 8] = 0\n    seeds = np.zeros_like(data)\n    seeds[lx // 5, ly // 5] = 1\n    seeds[lx // 2 + small_l // 4, ly // 2 - small_l // 4] = 2\n    return data, seeds", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_reorder_labels():\n    lx = 70\n    ly = 100\n    data, labels = make_2d_syntheticdata(lx, ly)\n    labels[labels == 2] = 4\n    labels_bf = random_walker(data, labels, beta=90, mode='bf')\n    assert (labels_bf[25:45, 40:60] == 2).all()\n    assert data.shape == labels.shape\n\ntest_reorder_labels()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_2d_inactive():\n    lx = 70\n    ly = 100\n    data, labels = make_2d_syntheticdata(lx, ly)\n    labels[10:20, 10:20] = -1\n    labels[46:50, 33:38] = -2\n    labels = random_walker(data, labels, beta=90)\n    assert (labels.reshape((lx, ly))[25:45, 40:60] == 2).all()\n    assert data.shape == labels.shape\n\ntest_2d_inactive()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}], "instruction": "Functionality: The make_2d_syntheticdata function generates a 2D synthetic image data array with a specific structure and a corresponding seed array for image segmentation tasks. The function creates a noise-added background, a central disk-like feature, and two seed points inside the image for segmentation algorithms.\n\nInputs: \n- lx: An integer specifying the length of the 2D array in the x-direction. \n- ly: An optional integer specifying the length of the 2D array in the y-direction. If ly is None, it will default to lx.\n\nOutputs:\n- data: A 2D NumPy array representing the synthetic image data. This array includes the background noise and the central disk feature.\n- seeds: A 2D NumPy array of the same shape as data, containing the seed values. There are two seed points: one labeled as 1 and the other as 2 for segmentation initialization.", "method_code_mask": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_2d_syntheticdata(lx, ly=None): [MASK]\n"}
{"method_name": "make_3d_syntheticdata", "full_method_name": "make_3d_syntheticdata", "method_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py", "method_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef make_3d_syntheticdata(lx, ly=None, lz=None):\n    if ly is None:\n        ly = lx\n    if lz is None:\n        lz = lx\n    np.random.seed(1234)\n    data = np.zeros((lx, ly, lz)) + 0.1 * np.random.randn(lx, ly, lz)\n    small_l = int(lx // 5)\n    data[lx // 2 - small_l:lx // 2 + small_l, ly // 2 - small_l:ly // 2 +\n        small_l, lz // 2 - small_l:lz // 2 + small_l] = 1\n    data[lx // 2 - small_l + 1:lx // 2 + small_l - 1, ly // 2 - small_l + 1\n        :ly // 2 + small_l - 1, lz // 2 - small_l + 1:lz // 2 + small_l - 1\n        ] = 0\n    hole_size = np.max([1, small_l // 8])\n    data[lx // 2 - small_l, ly // 2 - hole_size:ly // 2 + hole_size, lz // \n        2 - hole_size:lz // 2 + hole_size] = 0\n    seeds = np.zeros_like(data)\n    seeds[lx // 5, ly // 5, lz // 5] = 1\n    seeds[lx // 2 + small_l // 4, ly // 2 - small_l // 4, lz // 2 - small_l //\n        4] = 2\n    return data, seeds", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_3d_inactive():\n    n = 30\n    lx, ly, lz = n, n, n\n    data, labels = make_3d_syntheticdata(lx, ly, lz)\n    labels[5:25, 26:29, 26:29] = -1\n    with expected_warnings(['\"cg\" mode|CObject type|scipy.sparse.linalg.cg']):\n        labels = random_walker(data, labels, mode='cg')\n    assert (labels.reshape(data.shape)[13:17, 13:17, 13:17] == 2).all()\n    assert data.shape == labels.shape\n\ntest_3d_inactive()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_spacing_0():\n    n = 30\n    lx, ly, lz = n, n, n\n    data, _ = make_3d_syntheticdata(lx, ly, lz)\n    data_aniso = np.zeros((n, n, n // 2))\n    for i, yz in enumerate(data):\n        data_aniso[i, :, :] = resize(yz, (n, n // 2), mode='constant',\n            anti_aliasing=False)\n    small_l = int(lx // 5)\n    labels_aniso = np.zeros_like(data_aniso)\n    labels_aniso[lx // 5, ly // 5, lz // 5] = 1\n    labels_aniso[lx // 2 + small_l // 4, ly // 2 - small_l // 4, lz // 4 - \n        small_l // 8] = 2\n    with expected_warnings(['\"cg\" mode|scipy.sparse.linalg.cg']):\n        labels_aniso = random_walker(data_aniso, labels_aniso, mode='cg',\n            spacing=(1.0, 1.0, 0.5))\n    assert (labels_aniso[13:17, 13:17, 7:9] == 2).all()\n\ntest_spacing_0()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}], "instruction": "Functionality: The make_3d_syntheticdata function generates a synthetic 3D dataset and a corresponding set of seeds, which can be used for testing various image processing algorithms such as segmentation. The function creates a 3D array filled with Gaussian noise, then introduces a spherical structure within it. A hole is also added to the structure. Two seed points are placed at specified locations within the array to serve as markers for segmentation algorithms.\n\nInputs: \n- lx: An integer specifying the length of the 3D array along the x-axis.\n- ly: An optional integer specifying the length of the 3D array along the y-axis (defaults to the same as lx if not provided).\n- lz: An optional integer specifying the length of the 3D array along the z-axis (defaults to the same as lx if not provided).\n\nOutputs:\n- data: A 3D NumPy array of shape (lx, ly, lz) containing the synthetic data with Gaussian noise and the introduced structure.\n- seeds: A 3D NumPy array of the same shape as data, containing seed points for segmentation. The array will have two seed points marked as 1 and 2, respectively, at predefined locations.", "method_code_mask": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_3d_syntheticdata(lx, ly=None, lz=None): [MASK]\n"}
{"method_name": "_label_bool", "full_method_name": "_label_bool", "method_path": "../srcdata/Computation/scikit-image/skimage/measure/_label.py", "method_code": "from scipy import ndimage\ndef _label_bool(image, background=None, return_num=False, connectivity=None):\n    \"\"\"Faster implementation of clabel for boolean input.\n\n    See context: https://github.com/scikit-image/scikit-image/issues/4833\n    \"\"\"\n    from ..morphology._util import _resolve_neighborhood\n    if background == 1:\n        image = ~image\n    if connectivity is None:\n        connectivity = image.ndim\n    if not 1 <= connectivity <= image.ndim:\n        raise ValueError(\n            f'Connectivity for {image.ndim}D image should be in [1, ..., {image.ndim}]. Got {connectivity}.'\n            )\n    footprint = _resolve_neighborhood(None, connectivity, image.ndim)\n    result = ndimage.label(image, structure=footprint)\n    if return_num:\n        return result\n    else:\n        return result[0]", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_no_option():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img)\n    l_cy = clabel(img)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_no_option()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_background():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img, background=0)\n    l_cy = clabel(img, background=0)\n    testing.assert_equal(l_ndi, l_cy)\n    l_ndi = _label_bool(img, background=1)\n    l_cy = clabel(img, background=1)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_background()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_return_num():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img, return_num=True)\n    l_cy = clabel(img, return_num=True)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_return_num()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_connectivity():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    for c in (1, 2, 3):\n        l_ndi = _label_bool(img, connectivity=c)\n        l_cy = clabel(img, connectivity=c)\n        testing.assert_equal(l_ndi, l_cy)\n    for c in (0, 4):\n        with pytest.raises(ValueError):\n            l_ndi = _label_bool(img, connectivity=c)\n        with pytest.raises(ValueError):\n            l_cy = clabel(img, connectivity=c)\n\ntest_connectivity()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}], "instruction": "Functionality: The _label_bool function is designed to efficiently label connected components in a boolean image. This function utilizes the scipy.ndimage module to identify and number the distinct connected components within the input image based on a specified connectivity level. The function also provides an option to return the number of distinct labels found, making it versatile for various image processing tasks.\n\nInputs:\n- image: A boolean numpy array representing the input image. True values are considered foreground, and False values are considered background.\n- background (optional): An integer specifying the value of the background pixels. If set to 1, the function will invert the input image before processing. Default is None.\n- return_num (optional): A boolean indicating whether to return the number of distinct labels in the image. If True, the function will return both the labeled image and the number of labels. Default is False.\n- connectivity (optional): An integer specifying the maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. If None, the default connectivity is the dimensionality of the input image. Must be in the range [1, ..., image.ndim]. Default is None.\n\nOutputs:\n- If return_num is False, the function returns a labeled boolean image as a numpy array, where each connected component is assigned a unique integer label.\n- If return_num is True, the function returns a tuple containing the labeled image as described above and the number of distinct labels in the image.", "method_code_mask": "from scipy import ndimage\n\n\ndef _label_bool(image, background=None, return_num=False, connectivity=None): [\n    MASK]\n"}
{"method_name": "_same_mesh", "full_method_name": "_same_mesh", "method_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py", "method_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\ndef _same_mesh(vertices1, faces1, vertices2, faces2, tol=1e-10):\n    \"\"\"Compare two meshes, using a certain tolerance and invariant to\n    the order of the faces.\n    \"\"\"\n    triangles1 = vertices1[np.array(faces1)]\n    triangles2 = vertices2[np.array(faces2)]\n    triang1 = [np.concatenate(sorted(t, key=lambda x: tuple(x))) for t in\n        triangles1]\n    triang2 = [np.concatenate(sorted(t, key=lambda x: tuple(x))) for t in\n        triangles2]\n    triang1 = np.array(sorted([tuple(x) for x in triang1]))\n    triang2 = np.array(sorted([tuple(x) for x in triang2]))\n    return triang1.shape == triang2.shape and np.allclose(triang1, triang2,\n        0, tol)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\ndef test_both_algs_same_result_ellipse():\n    sphere_small = ellipsoid(1, 1, 1, levelset=True)\n    vertices1, faces1 = marching_cubes(sphere_small, 0, allow_degenerate=False\n        )[:2]\n    vertices2, faces2 = marching_cubes(sphere_small, 0, allow_degenerate=\n        False, method='lorensen')[:2]\n    assert _same_mesh(vertices1, faces1, vertices2, faces2)\n\ntest_both_algs_same_result_ellipse()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\ndef test_both_algs_same_result_donut():\n    n = 48\n    a, b = 2.5 / n, -1.25\n    vol = np.empty((n, n, n), 'float32')\n    for iz in range(vol.shape[0]):\n        for iy in range(vol.shape[1]):\n            for ix in range(vol.shape[2]):\n                z, y, x = float(iz) * a + b, float(iy) * a + b, float(ix\n                    ) * a + b\n                vol[iz, iy, ix] = (((8 * x) ** 2 + (8 * y - 2) ** 2 + (8 *\n                    z) ** 2 + 16 - 1.85 * 1.85) * ((8 * x) ** 2 + (8 * y - \n                    2) ** 2 + (8 * z) ** 2 + 16 - 1.85 * 1.85) - 64 * ((8 *\n                    x) ** 2 + (8 * y - 2) ** 2)) * (((8 * x) ** 2 + (8 * y -\n                    2 + 4) * (8 * y - 2 + 4) + (8 * z) ** 2 + 16 - 1.85 * \n                    1.85) * ((8 * x) ** 2 + (8 * y - 2 + 4) * (8 * y - 2 + \n                    4) + (8 * z) ** 2 + 16 - 1.85 * 1.85) - 64 * ((8 * y - \n                    2 + 4) * (8 * y - 2 + 4) + (8 * z) ** 2)) + 1025\n    vertices1, faces1 = marching_cubes(vol, 0, method='lorensen')[:2]\n    vertices2, faces2 = marching_cubes(vol, 0)[:2]\n    assert not _same_mesh(vertices1, faces1, vertices2, faces2)\n\ntest_both_algs_same_result_donut()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py"}], "instruction": "Functionality: The _same_mesh function is designed to compare two 3D meshes to determine if they are the same within a certain tolerance, and the comparison is invariant to the order of the faces. It achieves this by sorting the vertices of each face and comparing the sorted triangles from both meshes.\n\nInputs: \n- vertices1: A numpy array representing the vertices of the first mesh.\n- faces1: A numpy array representing the faces of the first mesh, where each face is a set of indices into the vertices array.\n- vertices2: A numpy array representing the vertices of the second mesh.\n- faces2: A numpy array representing the faces of the second mesh, where each face is a set of indices into the vertices array.\n- tol: An optional float representing the tolerance for comparison. The default value is 1e-10.\n\nOutputs:\n- A boolean indicating whether the two meshes are the same within the given tolerance. True if both the number of triangles and the values of each triangle in both meshes are close to each other within the tolerance, False otherwise.", "method_code_mask": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\n\n\ndef _same_mesh(vertices1, faces1, vertices2, faces2, tol=1e-10): [MASK]\n"}
{"method_name": "alphanumeric_key", "full_method_name": "alphanumeric_key", "method_path": "../srcdata/Computation/scikit-image/skimage/io/collection.py", "method_code": "import os\nfrom glob import glob\nimport re\nfrom collections.abc import Sequence\nfrom copy import copy\nimport numpy as np\nfrom PIL import Image\nfrom tifffile import TiffFile\ndef alphanumeric_key(s):\n    \"\"\"Convert string to list of strings and ints that gives intuitive sorting.\n\n    Parameters\n    ----------\n    s : string\n\n    Returns\n    -------\n    k : a list of strings and ints\n\n    Examples\n    --------\n    >>> alphanumeric_key('z23a')\n    ['z', 23, 'a']\n    >>> filenames = ['f9.10.png', 'e10.png', 'f9.9.png', 'f10.10.png',\n    ...              'f10.9.png']\n    >>> sorted(filenames)\n    ['e10.png', 'f10.10.png', 'f10.9.png', 'f9.10.png', 'f9.9.png']\n    >>> sorted(filenames, key=alphanumeric_key)\n    ['e10.png', 'f9.9.png', 'f9.10.png', 'f10.9.png', 'f10.10.png']\n    \"\"\"\n    k = [(int(c) if c.isdigit() else c) for c in re.split('([0-9]+)', s)]\n    return k", "test_code_list": [{"test_code": "import os\nimport itertools\nimport numpy as np\nimport imageio.v3 as iio3\nfrom skimage import data_dir\nfrom skimage.io.collection import ImageCollection\nfrom skimage.io.collection import MultiImage\nfrom skimage.io.collection import alphanumeric_key\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_string_split():\n    test_string = 'z23a'\n    test_str_result = ['z', 23, 'a']\n    assert_equal(alphanumeric_key(test_string), test_str_result)\n\ntest_string_split()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_collection.py"}], "instruction": "Functionality: The alphanumeric_key function is designed to convert a string into a list of strings and integers. This conversion is used to create a sorting key that allows for intuitive sorting of strings that contain numbers, ensuring that numerical parts are sorted numerically rather than lexicographically.\n\nInputs: \n- s : A string that may contain both alphabetical characters and numbers. The string is the input for which the alphanumeric sorting key is to be generated.\n\nOutputs: \n- k : A list of strings and integers. The list is derived from the input string, where sequences of digits are converted to integers, and non-digit characters are left as strings. This list is used as a sorting key.", "method_code_mask": "import os\nfrom glob import glob\nimport re\nfrom collections.abc import Sequence\nfrom copy import copy\nimport numpy as np\nfrom PIL import Image\nfrom tifffile import TiffFile\n\n\ndef alphanumeric_key(s): [MASK]\n"}
{"method_name": "_palette_is_grayscale", "full_method_name": "_palette_is_grayscale", "method_path": "../srcdata/Computation/scikit-image/skimage/io/_plugins/pil_plugin.py", "method_code": "import numpy as np\nfrom PIL import Image\ndef _palette_is_grayscale(pil_image):\n    \"\"\"Return True if PIL image in palette mode is grayscale.\n\n    Parameters\n    ----------\n    pil_image : PIL image\n        PIL Image that is in Palette mode.\n\n    Returns\n    -------\n    is_grayscale : bool\n        True if all colors in image palette are gray.\n    \"\"\"\n    if pil_image.mode != 'P':\n        raise ValueError('pil_image.mode must be equal to \"P\".')\n    palette = np.asarray(pil_image.getpalette()).reshape((-1, 3))\n    start, stop = pil_image.getextrema()\n    valid_palette = palette[start:stop + 1]\n    return np.allclose(np.diff(valid_palette), 0)", "test_code_list": [{"test_code": "import os\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom PIL import Image\nfrom skimage._shared import testing\nfrom skimage._shared._tempfile import temporary_file\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import color_check\nfrom skimage._shared.testing import fetch\nfrom skimage._shared.testing import mono_check\nfrom skimage.metrics import structural_similarity\ndef test_palette_is_gray():\n    gray = Image.open(fetch('data/palette_gray.png'))\n    assert _palette_is_grayscale(gray)\n    color = Image.open(fetch('data/palette_color.png'))\n    assert not _palette_is_grayscale(color)\n\ntest_palette_is_gray()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/io/tests/test_pil.py"}], "instruction": "Functionality: The function checks if a given PIL image in Palette mode is grayscale. It verifies that all colors in the image palette are shades of gray by comparing the differences between RGB values of each color in the palette.\n\nInputs: \n- pil_image: A PIL Image object that should be in Palette mode. If the mode is not 'P', the function will raise a ValueError.\n\nOutputs:\n- is_grayscale: A boolean value indicating whether the image is grayscale. True if all colors in the image palette are gray, False otherwise.", "method_code_mask": "import numpy as np\nfrom PIL import Image\n\n\ndef _palette_is_grayscale(pil_image): [MASK]\n"}
{"method_name": "intensity_range", "full_method_name": "intensity_range", "method_path": "../srcdata/Computation/scikit-image/skimage/exposure/exposure.py", "method_code": "import numpy as np\ndef intensity_range(image, range_values='image', clip_negative=False):\n    \"\"\"Return image intensity range (min, max) based on desired value type.\n\n    Parameters\n    ----------\n    image : array\n        Input image.\n    range_values : str or 2-tuple, optional\n        The image intensity range is configured by this parameter.\n        The possible values for this parameter are enumerated below.\n\n        'image'\n            Return image min/max as the range.\n        'dtype'\n            Return min/max of the image's dtype as the range.\n        dtype-name\n            Return intensity range based on desired `dtype`. Must be valid key\n            in `DTYPE_RANGE`. Note: `image` is ignored for this range type.\n        2-tuple\n            Return `range_values` as min/max intensities. Note that there's no\n            reason to use this function if you just want to specify the\n            intensity range explicitly. This option is included for functions\n            that use `intensity_range` to support all desired range types.\n\n    clip_negative : bool, optional\n        If True, clip the negative range (i.e. return 0 for min intensity)\n        even if the image dtype allows negative values.\n    \"\"\"\n    if range_values == 'dtype':\n        range_values = image.dtype.type\n    if range_values == 'image':\n        i_min = np.min(image)\n        i_max = np.max(image)\n    elif range_values in DTYPE_RANGE:\n        i_min, i_max = DTYPE_RANGE[range_values]\n        if clip_negative:\n            i_min = 0\n    else:\n        i_min, i_max = range_values\n    return i_min, i_max", "test_code_list": [{"test_code": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\ndef test_intensity_range_clipped_float():\n    image = np.array([0.1, 0.2], dtype=np.float64)\n    out = intensity_range(image, range_values='dtype', clip_negative=True)\n    assert_array_equal(out, (0, 1))\n\ntest_intensity_range_clipped_float()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py"}], "instruction": "Functionality: The intensity_range function is designed to determine the intensity range (min, max) of an image based on the specified value type. This can be useful for image processing tasks where normalization or scaling of pixel intensities is required.\n\nInputs: \n1. image : array\n   Input image for which the intensity range is to be calculated.\n2. range_values : str or 2-tuple, optional\n   This parameter configures how the intensity range is determined. It can take values like 'image', 'dtype', a specific dtype-name, or a 2-tuple specifying the range.\n3. clip_negative : bool, optional\n   If set to True, the function will clip the negative range of the intensity values, setting the minimum intensity to 0, even if the image dtype allows negative values.\n\nOutputs:\n1. i_min, i_max : tuple\n   Returns a tuple containing the minimum and maximum intensity values based on the parameters provided. This output can be used to normalize or scale the image intensity values.", "method_code_mask": "import numpy as np\n\n\ndef intensity_range(image, range_values='image', clip_negative=False): [MASK]\n"}
{"method_name": "norm_brightness_err", "full_method_name": "norm_brightness_err", "method_path": "../srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py", "method_code": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\ndef norm_brightness_err(img1, img2):\n    \"\"\"Normalized Absolute Mean Brightness Error between two images\n\n    Parameters\n    ----------\n    img1 : array-like\n    img2 : array-like\n\n    Returns\n    -------\n    norm_brightness_error : float\n        Normalized absolute mean brightness error\n    \"\"\"\n    if img1.ndim == 3:\n        img1, img2 = rgb2gray(img1), rgb2gray(img2)\n    ambe = np.abs(img1.mean() - img2.mean())\n    nbe = ambe / dtype_range[img1.dtype.type][1]\n    return nbe", "test_code_list": [{"test_code": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\ndef test_adapthist_borders():\n    \"\"\"Test border processing\"\"\"\n    img = rgb2gray(util.img_as_float(data.astronaut()))\n    img /= 100.0\n    img[img.shape[0] // 2, img.shape[1] // 2] = 1.0\n    border_index = -1\n    for kernel_size in range(51, 71, 2):\n        adapted = exposure.equalize_adapthist(img, kernel_size, clip_limit=0.5)\n        assert norm_brightness_err(adapted[:, border_index], img[:,\n            border_index]) > 0.1\n        assert norm_brightness_err(adapted[border_index, :], img[\n            border_index, :]) > 0.1\n\ntest_adapthist_borders()\n", "code_start": "", "test_path": "../srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py"}], "instruction": "Functionality: The function calculates the Normalized Absolute Mean Brightness Error (NBE) between two images. It first ensures that both images are in grayscale by converting them if they are in RGB format. Then, it computes the absolute mean brightness difference between the two images and normalizes this difference based on the maximum value of the image's data type.\n\nInputs:\n- img1 : array-like\n    The first input image. It can be in RGB or grayscale format.\n- img2 : array-like\n    The second input image for comparison with the first image. It can also be in RGB or grayscale format.\n\nOutputs:\n- norm_brightness_error : float\n    The normalized absolute mean brightness error between the two images. This value represents how much the brightness of the two images differs, normalized by the maximum possible value in the image's data type.", "method_code_mask": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\n\n\ndef norm_brightness_err(img1, img2): [MASK]\n"}
