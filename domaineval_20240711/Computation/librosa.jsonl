{"method_name": "srand", "full_method_name": "srand", "method_path": "../srcdata/Computation/librosa/tests/test_core.py", "method_code": "from __future__ import print_function\nimport os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef srand(seed=628318530):\n    np.random.seed(seed)\n    pass", "test_code_list": [{"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_amplitude_to_db():\n    srand()\n    NOISE_FLOOR = 1e-06\n    x = np.abs(np.random.randn(1000)) + NOISE_FLOOR\n    db1 = librosa.amplitude_to_db(x, top_db=None)\n    db2 = librosa.power_to_db(x ** 2, top_db=None)\n    assert np.allclose(db1, db2)\n\ntest_amplitude_to_db()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}, {"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_amplitude_to_db_complex():\n    srand()\n    NOISE_FLOOR = 1e-06\n    x = np.abs(np.random.randn(1000)) + NOISE_FLOOR\n    with pytest.warns(UserWarning, match=\n        'amplitude_to_db was called on complex input'):\n        db1 = librosa.amplitude_to_db(x.astype(complex), top_db=None)\n    db2 = librosa.power_to_db(x ** 2, top_db=None)\n    assert np.allclose(db1, db2)\n\ntest_amplitude_to_db_complex()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}, {"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_db_to_amplitude():\n    srand()\n    NOISE_FLOOR = 1e-06\n    x = np.abs(np.random.randn(1000)) + NOISE_FLOOR\n    db = librosa.amplitude_to_db(x, top_db=None)\n    x2 = librosa.db_to_amplitude(db)\n    assert np.allclose(x, x2)\n\ntest_db_to_amplitude()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}, {"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_fmt_axis():\n    srand()\n    y = np.random.randn(32, 32)\n    f1 = librosa.fmt(y, axis=-1)\n    f2 = librosa.fmt(y.T, axis=0).T\n    assert np.allclose(f1, f2)\n\ntest_fmt_axis()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}, {"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_pcen_axes():\n    srand()\n    X = np.random.randn(3, 100, 50) ** 2\n    P1 = librosa.pcen(X[0])\n    P1a = librosa.pcen(X[0], axis=-1)\n    P2 = librosa.pcen(X[0].T, axis=0).T\n    assert np.allclose(P1, P2)\n    assert np.allclose(P1, P1a)\n    P1 = librosa.pcen(X[0], max_size=3)\n    P1a = librosa.pcen(X[0], axis=-1, max_size=3)\n    P2 = librosa.pcen(X[0].T, axis=0, max_size=3).T\n    assert np.allclose(P1, P2)\n    assert np.allclose(P1, P1a)\n    P0 = librosa.pcen(X[0])\n    P1 = librosa.pcen(X[1])\n    P2 = librosa.pcen(X[2])\n    Pa = librosa.pcen(X)\n    assert np.allclose(P0, Pa[0])\n    assert np.allclose(P1, Pa[1])\n    assert np.allclose(P2, Pa[2])\n    P0 = librosa.pcen(X[0], max_size=3)\n    P1 = librosa.pcen(X[1], max_size=3)\n    P2 = librosa.pcen(X[2], max_size=3)\n    Pa = librosa.pcen(X, max_size=3, max_axis=1)\n    assert np.allclose(P0, Pa[0])\n    assert np.allclose(P1, Pa[1])\n    assert np.allclose(P2, Pa[2])\n\ntest_pcen_axes()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}, {"test_code": "import os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\ndef test_pcen_ref():\n    srand()\n    X = np.random.randn(100, 50) ** 2\n    ones = np.ones_like(X)\n    Y = librosa.pcen(X, gain=1, bias=0, power=1, b=1, eps=1e-20)\n    assert np.allclose(Y, ones)\n    Y2 = librosa.pcen(X, gain=1, bias=0, power=1, b=1, ref=ones, eps=1e-20)\n    assert np.allclose(Y2, X)\n\ntest_pcen_ref()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Computation/librosa/tests/test_core.py"}], "instruction": "Functionality: The srand function sets the seed for the numpy random number generator. This is typically used to ensure reproducibility in experiments or simulations where random numbers are used. By setting the seed to a fixed value, the sequence of random numbers generated will be the same across multiple runs.\n\nInputs: \n- seed: An integer value used to seed the random number generator. The default value is 628318530.\n\nOutputs:\n- The srand function does not return any value; it only sets the seed for the numpy random number generator. The effect of this function is observed in the subsequent calls to numpy's random functions which will produce the same sequence of random numbers across different runs if the seed is not changed.", "method_code_mask": "from __future__ import print_function\nimport os\nimport sys\nimport soundfile\nimport audioread.rawread\nimport librosa\nimport librosa.core\nimport librosa.core.spectrum\nimport glob\nimport numpy as np\nimport scipy.io\nimport scipy.signal\nimport pytest\nimport warnings\nfrom unittest import mock\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Union\nfrom typing import cast\nimport numpy.fft as fft\n\n\ndef srand(seed=628318530): [MASK]\n"}
