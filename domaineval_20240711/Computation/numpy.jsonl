{"method_name": "get_rtol", "full_method_name": "get_rtol", "method_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py", "method_code": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\ndef get_rtol(dtype):\n    if dtype in (single, csingle):\n        return 1e-05\n    else:\n        return 1e-11", "test_code_list": [{"test_code": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\nclass TestEigvalsh():\n\tdef test_UPLO(self):\n\t    Klo = np.array([[0, 0], [1, 0]], dtype=np.double)\n\t    Kup = np.array([[0, 1], [0, 0]], dtype=np.double)\n\t    tgt = np.array([-1, 1], dtype=np.double)\n\t    rtol = get_rtol(np.double)\n\t    w = np.linalg.eigvalsh(Klo)\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Klo, UPLO='L')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Klo, UPLO='l')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Kup, UPLO='U')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Kup, UPLO='u')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t\nTestEigvalsh().test_UPLO()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py"}, {"test_code": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\nclass TestEigh():\n\tdef test_UPLO(self):\n\t    Klo = np.array([[0, 0], [1, 0]], dtype=np.double)\n\t    Kup = np.array([[0, 1], [0, 0]], dtype=np.double)\n\t    tgt = np.array([-1, 1], dtype=np.double)\n\t    rtol = get_rtol(np.double)\n\t    w, v = np.linalg.eigh(Klo)\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Klo, UPLO='L')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Klo, UPLO='l')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Kup, UPLO='U')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Kup, UPLO='u')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t\nTestEigh().test_UPLO()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py"}], "instruction": "Functionality: The function \"get_rtol\" is designed to determine the relative tolerance value based on the input data type. This is crucial for performing numerical computations, especially when comparing floating-point numbers, where precision can vary significantly based on the data type's size and the required accuracy.\n\nInputs: \n- dtype: A data type from the numpy module (numpy.dtype). This argument can be any of the following: numpy.single, numpy.double, numpy.csingle, or numpy.cdouble. It is the input data type for which the relative tolerance is to be determined.\n\nOutputs: \n- A float value representing the relative tolerance. For single-precision and single-complex (numpy.single, numpy.csingle) data types, the function returns 1e-05. For double-precision and double-complex (numpy.double, numpy.cdouble) data types, the function returns 1e-11. This value can be used in various numerical computations to handle floating-point arithmetic's inherent imprecision.", "method_code_mask": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\n\ndef get_rtol(dtype): [MASK]\n"}
{"method_name": "allequal", "full_method_name": "allequal", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef allequal(a, b, fill_value=True):\n    \"\"\"\n    Return True if all entries of a and b are equal, using\n    fill_value as a truth value where either or both are masked.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    fill_value : bool, optional\n        Whether masked values in a or b are considered equal (True) or not\n        (False).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance, False otherwise. If either array contains NaN,\n        then False is returned.\n\n    See Also\n    --------\n    all, any\n    numpy.ma.allclose\n\n    Examples\n    --------\n    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n    >>> a\n    masked_array(data=[10000000000.0, 1e-07, --],\n                 mask=[False, False,  True],\n           fill_value=1e+20)\n\n    >>> b = np.array([1e10, 1e-7, -42.0])\n    >>> b\n    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n    >>> np.ma.allequal(a, b, fill_value=False)\n    False\n    >>> np.ma.allequal(a, b)\n    True\n\n    \"\"\"\n    m = mask_or(getmask(a), getmask(b))\n    if m is nomask:\n        x = getdata(a)\n        y = getdata(b)\n        d = umath.equal(x, y)\n        return d.all()\n    elif fill_value:\n        x = getdata(a)\n        y = getdata(b)\n        d = umath.equal(x, y)\n        dm = array(d, mask=m, copy=False)\n        return dm.filled(True).all(None)\n    else:\n        return False", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_raises\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import log\nfrom numpy.ma.core import add\nfrom numpy.ma.core import hypot\nfrom numpy.ma.core import divide\nfrom numpy.ma.extras import mr_\n\nclass TestMaskedMatrix():\n\tdef test_matrix_indexing(self):\n\t    x1 = np.matrix([[1, 2, 3], [4, 3, 2]])\n\t    x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])\n\t    x3 = masked_array(x1, mask=[[0, 1, 0], [1, 0, 0]])\n\t    x4 = masked_array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(type(x2[1, 0]) is type(x1[1, 0]))\n\t    assert_(x1[1, 0] == x2[1, 0])\n\t    assert_(x2[1, 1] is masked)\n\t    assert_equal(x1[0, 2], x2[0, 2])\n\t    assert_equal(x1[0, 1:], x2[0, 1:])\n\t    assert_equal(x1[:, 2], x2[:, 2])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[0, 2] = 9\n\t    x2[0, 2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[0, 1:] = 99\n\t    x2[0, 1:] = 99\n\t    assert_equal(x1, x2)\n\t    x2[0, 1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, 1:] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, :] = x1[0, :]\n\t    x2[0, 1] = masked\n\t    assert_(allequal(getmask(x2), np.array([[0, 1, 0], [0, 1, 0]])))\n\t    x3[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x3)[1], masked_array([1, 1, 0])))\n\t    assert_(allequal(getmask(x3[1]), masked_array([1, 1, 0])))\n\t    x4[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x4[1]), masked_array([1, 1, 0])))\n\t    assert_(allequal(x4[1], masked_array([1, 2, 3])))\n\t    x1 = np.matrix(np.arange(5) * 1.0)\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(masked_array([0, 0, 0, 1, 0], dtype=MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t\nTestMaskedMatrix().test_matrix_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/matrixlib/tests/test_masked_matrix.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The functionality of the allequal function is to determine whether all elements of two input arrays, 'a' and 'b', are equal, taking into account any masked values based on the 'fill_value' parameter. It compares the elements of the arrays and returns a boolean value indicating if all corresponding elements are equal. Masked values in either array are considered based on the 'fill_value' parameter.\n\nInputs: \n1. a: array_like - The first input array to compare.\n2. b: array_like - The second input array to compare.\n3. fill_value: bool, optional - This parameter determines whether masked values in 'a' or 'b' are considered equal (True) or not (False). The default value is True.\n\nOutputs: \n1. y: bool - The function returns a boolean value. True if all elements of 'a' and 'b' are equal within the given tolerance, taking into account the 'fill_value' parameter for masked values, and False otherwise. If either array contains NaN values, the function also returns False.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef allequal(a, b, fill_value=True): [MASK]\n"}
{"method_name": "masked_values", "full_method_name": "masked_values", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True):\n    \"\"\"\n    Mask using floating point equality.\n\n    Return a MaskedArray, masked where the data in array `x` are approximately\n    equal to `value`, determined using `isclose`. The default tolerances for\n    `masked_values` are the same as those for `isclose`.\n\n    For integer types, exact equality is used, in the same way as\n    `masked_equal`.\n\n    The fill_value is set to `value` and the mask is set to ``nomask`` if\n    possible.\n\n    Parameters\n    ----------\n    x : array_like\n        Array to mask.\n    value : float\n        Masking value.\n    rtol, atol : float, optional\n        Tolerance parameters passed on to `isclose`\n    copy : bool, optional\n        Whether to return a copy of `x`.\n    shrink : bool, optional\n        Whether to collapse a mask full of False to ``nomask``.\n\n    Returns\n    -------\n    result : MaskedArray\n        The result of masking `x` where approximately equal to `value`.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n    masked_equal : Mask where equal to a given value (integers).\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = np.array([1, 1.1, 2, 1.1, 3])\n    >>> ma.masked_values(x, 1.1)\n    masked_array(data=[1.0, --, 2.0, --, 3.0],\n                 mask=[False,  True, False,  True, False],\n           fill_value=1.1)\n\n    Note that `mask` is set to ``nomask`` if possible.\n\n    >>> ma.masked_values(x, 2.1)\n    masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n                 mask=False,\n           fill_value=2.1)\n\n    Unlike `masked_equal`, `masked_values` can perform approximate equalities.\n\n    >>> ma.masked_values(x, 2.1, atol=1e-1)\n    masked_array(data=[1.0, 1.1, --, 1.1, 3.0],\n                 mask=[False, False,  True, False, False],\n           fill_value=2.1)\n\n    \"\"\"\n    xnew = filled(x, value)\n    if np.issubdtype(xnew.dtype, np.floating):\n        mask = np.isclose(xnew, value, atol=atol, rtol=rtol)\n    else:\n        mask = umath.equal(xnew, value)\n    ret = masked_array(xnew, mask=mask, copy=copy, fill_value=value)\n    if shrink:\n        ret.shrink_mask()\n    return ret", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_raises\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import log\nfrom numpy.ma.core import add\nfrom numpy.ma.core import hypot\nfrom numpy.ma.core import divide\nfrom numpy.ma.extras import mr_\n\nclass TestMaskedMatrix():\n\tdef test_matrix_indexing(self):\n\t    x1 = np.matrix([[1, 2, 3], [4, 3, 2]])\n\t    x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])\n\t    x3 = masked_array(x1, mask=[[0, 1, 0], [1, 0, 0]])\n\t    x4 = masked_array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(type(x2[1, 0]) is type(x1[1, 0]))\n\t    assert_(x1[1, 0] == x2[1, 0])\n\t    assert_(x2[1, 1] is masked)\n\t    assert_equal(x1[0, 2], x2[0, 2])\n\t    assert_equal(x1[0, 1:], x2[0, 1:])\n\t    assert_equal(x1[:, 2], x2[:, 2])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[0, 2] = 9\n\t    x2[0, 2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[0, 1:] = 99\n\t    x2[0, 1:] = 99\n\t    assert_equal(x1, x2)\n\t    x2[0, 1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, 1:] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, :] = x1[0, :]\n\t    x2[0, 1] = masked\n\t    assert_(allequal(getmask(x2), np.array([[0, 1, 0], [0, 1, 0]])))\n\t    x3[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x3)[1], masked_array([1, 1, 0])))\n\t    assert_(allequal(getmask(x3[1]), masked_array([1, 1, 0])))\n\t    x4[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x4[1]), masked_array([1, 1, 0])))\n\t    assert_(allequal(x4[1], masked_array([1, 2, 3])))\n\t    x1 = np.matrix(np.arange(5) * 1.0)\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(masked_array([0, 0, 0, 1, 0], dtype=MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t\nTestMaskedMatrix().test_matrix_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/matrixlib/tests/test_masked_matrix.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedWhereAliases():\n\tdef test_masked_values(self):\n\t    res = masked_values(np.array([-32768.0]), np.int16(-32768))\n\t    assert_equal(res.mask, [True])\n\t    res = masked_values(np.inf, np.inf)\n\t    assert_equal(res.mask, True)\n\t    res = np.ma.masked_values(np.inf, -np.inf)\n\t    assert_equal(res.mask, False)\n\t    res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=True)\n\t    assert_(res.mask is np.ma.nomask)\n\t    res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=False)\n\t    assert_equal(res.mask, [False] * 4)\n\t\nTestMaskedWhereAliases().test_masked_values()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The masked_values function masks values in an array where they are approximately equal to a given value, using floating point equality for floating point types and exact equality for integer types. It returns a masked array with the masked values set to the provided value and the mask set to nomask if possible.\n\nInputs: \n- x: array_like, the array to mask.\n- value: float, the masking value.\n- rtol: float, optional, default 1e-05, the relative tolerance parameter passed to isclose.\n- atol: float, optional, default 1e-08, the absolute tolerance parameter passed to isclose.\n- copy: bool, optional, default True, whether to return a copy of x.\n- shrink: bool, optional, default True, whether to collapse a mask full of False to nomask.\n\nOutputs:\n- result: MaskedArray, the result of masking x where the values are approximately equal to value.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True): [M\n    ASK]\n"}
{"method_name": "build_err_msg", "full_method_name": "build_err_msg", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "method_code": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef build_err_msg(arrays, err_msg, header='Items are not equal:', verbose=\n    True, names=('ACTUAL', 'DESIRED'), precision=8):\n    msg = ['\\n' + header]\n    err_msg = str(err_msg)\n    if err_msg:\n        if err_msg.find('\\n') == -1 and len(err_msg) < 79 - len(header):\n            msg = [msg[0] + ' ' + err_msg]\n        else:\n            msg.append(err_msg)\n    if verbose:\n        for i, a in enumerate(arrays):\n            if isinstance(a, ndarray):\n                r_func = partial(array_repr, precision=precision)\n            else:\n                r_func = repr\n            try:\n                r = r_func(a)\n            except Exception as exc:\n                r = f'[repr failed for <{type(a).__name__}>: {exc}]'\n            if r.count('\\n') > 3:\n                r = '\\n'.join(r.splitlines()[:3])\n                r += '...'\n            msg.append(f' {names[i]}: {r}')\n    return '\\n'.join(msg)", "test_code_list": [{"test_code": "import warnings\nimport sys\nimport os\nimport itertools\nimport pytest\nimport weakref\nimport re\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import build_err_msg\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_approx_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import clear_and_catch_warnings\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_string_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import tempdir\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import HAS_REFCOUNT\nimport datetime\n\nclass TestBuildErrorMessage():\n\tdef test_build_err_msg_no_verbose(self):\n\t    x = np.array([1.00001, 2.00002, 3.00003])\n\t    y = np.array([1.00002, 2.00003, 3.00004])\n\t    err_msg = 'There is a mismatch'\n\t    a = build_err_msg([x, y], err_msg, verbose=False)\n\t    b = '\\nItems are not equal: There is a mismatch'\n\t    assert_equal(a, b)\n\t\nTestBuildErrorMessage().test_build_err_msg_no_verbose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/testing/tests/test_utils.py"}], "instruction": "Functionality: The build_err_msg function is designed to construct an error message for comparing arrays or any other objects. It concatenates a custom error message with representations of the objects being compared, making it useful for debugging and testing purposes where detailed comparison information is needed.\n\nInputs:\n- arrays: A list or iterable of objects (typically arrays) that failed a comparison. These objects are to be included in the error message for detailed comparison.\n- err_msg: A string containing the main error message to be included in the output. This can provide context about the failure or other relevant information.\n- header: A string that acts as the header of the error message. Default is 'Items are not equal:'. This can be customized to suit the message's purpose.\n- verbose: A boolean indicating whether detailed representations of the arrays should be included in the message. Default is True.\n- names: A tuple of strings representing the labels for each object in 'arrays'. Default is ('ACTUAL', 'DESIRED') which is suitable for indicating the actual and expected values.\n- precision: An integer specifying the number of decimal places to use for array representations. Default is 8.\n\nOutputs:\n- A string that is the complete error message, which includes the provided error message, the header, and detailed representations of the objects being compared, if verbose is True.", "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef build_err_msg(arrays, err_msg, header='Items are not equal:', verbose=\n    True, names=('ACTUAL', 'DESIRED'), precision=8): [MASK]\n"}
{"method_name": "mask_or", "full_method_name": "mask_or", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef mask_or(m1, m2, copy=False, shrink=True):\n    \"\"\"\n    Combine two masks with the ``logical_or`` operator.\n\n    The result may be a view on `m1` or `m2` if the other is `nomask`\n    (i.e. False).\n\n    Parameters\n    ----------\n    m1, m2 : array_like\n        Input masks.\n    copy : bool, optional\n        If copy is False and one of the inputs is `nomask`, return a view\n        of the other input mask. Defaults to False.\n    shrink : bool, optional\n        Whether to shrink the output to `nomask` if all its values are\n        False. Defaults to True.\n\n    Returns\n    -------\n    mask : output mask\n        The result masks values that are masked in either `m1` or `m2`.\n\n    Raises\n    ------\n    ValueError\n        If `m1` and `m2` have different flexible dtypes.\n\n    Examples\n    --------\n    >>> m1 = np.ma.make_mask([0, 1, 1, 0])\n    >>> m2 = np.ma.make_mask([1, 0, 0, 0])\n    >>> np.ma.mask_or(m1, m2)\n    array([ True,  True,  True, False])\n\n    \"\"\"\n    if m1 is nomask or m1 is False:\n        dtype = getattr(m2, 'dtype', MaskType)\n        return make_mask(m2, copy=copy, shrink=shrink, dtype=dtype)\n    if m2 is nomask or m2 is False:\n        dtype = getattr(m1, 'dtype', MaskType)\n        return make_mask(m1, copy=copy, shrink=shrink, dtype=dtype)\n    if m1 is m2 and is_mask(m1):\n        return m1\n    dtype1, dtype2 = getattr(m1, 'dtype', None), getattr(m2, 'dtype', None)\n    if dtype1 != dtype2:\n        raise ValueError(\"Incompatible dtypes '%s'<>'%s'\" % (dtype1, dtype2))\n    if dtype1.names is not None:\n        newmask = np.empty(np.broadcast(m1, m2).shape, dtype1)\n        _recursive_mask_or(m1, m2, newmask)\n        return newmask\n    return make_mask(umath.logical_or(m1, m2), copy=copy, shrink=shrink)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_mask_or(self):\n\t    mtype = [('a', bool), ('b', bool)]\n\t    mask = np.array([(0, 0), (0, 1), (1, 0), (0, 0)], dtype=mtype)\n\t    test = mask_or(mask, nomask)\n\t    assert_equal(test, mask)\n\t    test = mask_or(nomask, mask)\n\t    assert_equal(test, mask)\n\t    test = mask_or(mask, False)\n\t    assert_equal(test, mask)\n\t    other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=mtype)\n\t    test = mask_or(mask, other)\n\t    control = np.array([(0, 1), (0, 1), (1, 1), (0, 1)], dtype=mtype)\n\t    assert_equal(test, control)\n\t    othertype = [('A', bool), ('B', bool)]\n\t    other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=othertype)\n\t    try:\n\t        test = mask_or(mask, other)\n\t    except ValueError:\n\t        pass\n\t    dtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n\t    amask = np.array([(0, (1, 0)), (0, (1, 0))], dtype=dtype)\n\t    bmask = np.array([(1, (0, 1)), (0, (0, 0))], dtype=dtype)\n\t    cntrl = np.array([(1, (1, 1)), (0, (1, 0))], dtype=dtype)\n\t    assert_equal(mask_or(amask, bmask), cntrl)\n\t\nTestMaskedArrayFunctions().test_mask_or()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The mask_or function is designed to combine two masks using the logical OR operation. It is useful in scenarios where you want to create a new mask that includes any values masked in either of the input masks. The function supports various options for handling copies of masks and shrinking the result to 'nomask' (False) if all values are False.\n\nInputs:\nm1, m2: array_like\n    The input masks to be combined. They can be any array-like objects that can be interpreted as masks (e.g., numpy arrays, lists, etc.).\ncopy: bool, optional\n    A boolean flag indicating whether to return a copy of the input mask if the other input is 'nomask'. If False (default), a view of the input mask may be returned. If True, a copy will be returned.\nshrink: bool, optional\n    A boolean flag indicating whether to shrink the output to 'nomask' if all its values are False. If True (default), the output will be shrunk to 'nomask' if applicable.\n\nOutputs:\nmask: output mask\n    The resulting mask after combining m1 and m2 using the logical OR operation. This mask will have values masked if they were masked in either m1 or m2.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef mask_or(m1, m2, copy=False, shrink=True): [MASK]\n"}
{"method_name": "fromarrays", "full_method_name": "fromarrays", "method_path": "../srcdata/Computation/numpy/numpy/ma/mrecords.py", "method_code": "from numpy.ma import MAError\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.ma import masked_array\nfrom numpy.ma import getdata\nfrom numpy.ma import getmaskarray\nfrom numpy.ma import filled\nimport numpy.ma as ma\nimport warnings\nimport numpy as np\nfrom numpy import dtype\nfrom numpy import ndarray\nfrom numpy import array as narray\ndef fromarrays(arraylist, dtype=None, shape=None, formats=None, names=None,\n    titles=None, aligned=False, byteorder=None, fill_value=None):\n    \"\"\"\n    Creates a mrecarray from a (flat) list of masked arrays.\n\n    Parameters\n    ----------\n    arraylist : sequence\n        A list of (masked) arrays. Each element of the sequence is first converted\n        to a masked array if needed. If a 2D array is passed as argument, it is\n        processed line by line\n    dtype : {None, dtype}, optional\n        Data type descriptor.\n    shape : {None, integer}, optional\n        Number of records. If None, shape is defined from the shape of the\n        first array in the list.\n    formats : {None, sequence}, optional\n        Sequence of formats for each individual field. If None, the formats will\n        be autodetected by inspecting the fields and selecting the highest dtype\n        possible.\n    names : {None, sequence}, optional\n        Sequence of the names of each field.\n    fill_value : {None, sequence}, optional\n        Sequence of data to be used as filling values.\n\n    Notes\n    -----\n    Lists of tuples should be preferred over lists of lists for faster processing.\n\n    \"\"\"\n    datalist = [getdata(x) for x in arraylist]\n    masklist = [np.atleast_1d(getmaskarray(x)) for x in arraylist]\n    _array = recfromarrays(datalist, dtype=dtype, shape=shape, formats=\n        formats, names=names, titles=titles, aligned=aligned, byteorder=\n        byteorder).view(mrecarray)\n    _array._mask.flat = list(zip(*masklist))\n    if fill_value is not None:\n        _array.fill_value = fill_value\n    return _array", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.testing import temppath\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.mrecords import mrecarray\nfrom numpy.ma.mrecords import fromarrays\nfrom numpy.ma.mrecords import fromtextfile\nfrom numpy.ma.mrecords import fromrecords\nfrom numpy.ma.mrecords import addfield\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_equal_records\n\nclass TestMRecords():\n\tdef test_filled(self):\n\t    _a = ma.array([1, 2, 3], mask=[0, 0, 1], dtype=int)\n\t    _b = ma.array([1.1, 2.2, 3.3], mask=[0, 0, 1], dtype=float)\n\t    _c = ma.array(['one', 'two', 'three'], mask=[0, 0, 1], dtype='|S8')\n\t    ddtype = [('a', int), ('b', float), ('c', '|S8')]\n\t    mrec = fromarrays([_a, _b, _c], dtype=ddtype, fill_value=(99999, \n\t        99999.0, 'N/A'))\n\t    mrecfilled = mrec.filled()\n\t    assert_equal(mrecfilled['a'], np.array((1, 2, 99999), dtype=int))\n\t    assert_equal(mrecfilled['b'], np.array((1.1, 2.2, 99999.0), dtype=float))\n\t    assert_equal(mrecfilled['c'], np.array(('one', 'two', 'N/A'), dtype='|S8'))\n\t\nTestMRecords().test_filled()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_mrecords.py"}, {"test_code": "import pickle\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.testing import temppath\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.mrecords import mrecarray\nfrom numpy.ma.mrecords import fromarrays\nfrom numpy.ma.mrecords import fromtextfile\nfrom numpy.ma.mrecords import fromrecords\nfrom numpy.ma.mrecords import addfield\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_equal_records\n\nclass TestMRecords():\n\tdef test_tolist(self):\n\t    _a = ma.array([1, 2, 3], mask=[0, 0, 1], dtype=int)\n\t    _b = ma.array([1.1, 2.2, 3.3], mask=[0, 0, 1], dtype=float)\n\t    _c = ma.array(['one', 'two', 'three'], mask=[1, 0, 0], dtype='|S8')\n\t    ddtype = [('a', int), ('b', float), ('c', '|S8')]\n\t    mrec = fromarrays([_a, _b, _c], dtype=ddtype, fill_value=(99999, \n\t        99999.0, 'N/A'))\n\t    assert_equal(mrec.tolist(), [(1, 1.1, None), (2, 2.2, b'two'), (None,\n\t        None, b'three')])\n\t\nTestMRecords().test_tolist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_mrecords.py"}], "instruction": "Functionality: The fromarrays function is designed to create a mrecarray (a record array with masked values) from a flat list of masked or unmasked arrays. It supports specifying data types, shapes, formats, names, and filling values for the fields of the resulting mrecarray.\n\nInputs: \n- arraylist: A sequence of (masked) arrays. Each element of the sequence is converted to a masked array if required. Two-dimensional arrays are processed line by line.\n- dtype: Optional data type descriptor for the resulting mrecarray.\n- shape: Optional integer defining the number of records. If None, the shape is inferred from the first array in the list.\n- formats: Optional sequence of formats for each individual field. If None, formats are detected by analyzing the fields and selecting the highest dtype possible.\n- names: Optional sequence of names for each field.\n- fill_value: Optional sequence of data to be used as filling values for masked positions.\n\nOutputs:\n- A mrecarray object constructed from the provided arrays, with optional fields specified through the parameters. This includes the data, masks, and filling values for masked positions.", "method_code_mask": "from numpy.ma import MAError\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.ma import masked_array\nfrom numpy.ma import getdata\nfrom numpy.ma import getmaskarray\nfrom numpy.ma import filled\nimport numpy.ma as ma\nimport warnings\nimport numpy as np\nfrom numpy import dtype\nfrom numpy import ndarray\nfrom numpy import array as narray\n\n\ndef fromarrays(arraylist, dtype=None, shape=None, formats=None, names=None,\n    titles=None, aligned=False, byteorder=None, fill_value=None): [MASK]\n"}
{"method_name": "masked_all", "full_method_name": "masked_all", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef masked_all(shape, dtype=float):\n    \"\"\"\n    Empty masked array with all elements masked.\n\n    Return an empty masked array of the given shape and dtype, where all the\n    data are masked.\n\n    Parameters\n    ----------\n    shape : int or tuple of ints\n        Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``.\n    dtype : dtype, optional\n        Data type of the output.\n\n    Returns\n    -------\n    a : MaskedArray\n        A masked array with all data masked.\n\n    See Also\n    --------\n    masked_all_like : Empty masked array modelled on an existing array.\n\n    Notes\n    -----\n    Unlike other masked array creation functions (e.g. `numpy.ma.zeros`,\n    `numpy.ma.ones`, `numpy.ma.full`), `masked_all` does not initialize the\n    values of the array, and may therefore be marginally faster. However,\n    the values stored in the newly allocated array are arbitrary. For\n    reproducible behavior, be sure to set each element of the array before\n    reading.\n\n    Examples\n    --------\n    >>> np.ma.masked_all((3, 3))\n    masked_array(\n      data=[[--, --, --],\n            [--, --, --],\n            [--, --, --]],\n      mask=[[ True,  True,  True],\n            [ True,  True,  True],\n            [ True,  True,  True]],\n      fill_value=1e+20,\n      dtype=float64)\n\n    The `dtype` parameter defines the underlying data type.\n\n    >>> a = np.ma.masked_all((3, 3))\n    >>> a.dtype\n    dtype('float64')\n    >>> a = np.ma.masked_all((3, 3), dtype=np.int32)\n    >>> a.dtype\n    dtype('int32')\n\n    \"\"\"\n    a = masked_array(np.empty(shape, dtype), mask=np.ones(shape,\n        make_mask_descr(dtype)))\n    return a", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\ndef test_append_masked_array():\n    a = np.ma.masked_equal([1, 2, 3], value=2)\n    b = np.ma.masked_equal([4, 3, 2], value=2)\n    result = np.ma.append(a, b)\n    expected_data = [1, 2, 3, 4, 3, 2]\n    expected_mask = [False, True, False, False, False, True]\n    assert_array_equal(result.data, expected_data)\n    assert_array_equal(result.mask, expected_mask)\n    a = masked_all((2, 2))\n    b = np.ma.ones((3, 1))\n    result = np.ma.append(a, b)\n    expected_data = [1] * 3\n    expected_mask = [True] * 4 + [False] * 3\n    assert_array_equal(result.data[-3], expected_data)\n    assert_array_equal(result.mask, expected_mask)\n    result = np.ma.append(a, b, axis=None)\n    assert_array_equal(result.data[-3], expected_data)\n    assert_array_equal(result.mask, expected_mask)\n\ntest_append_masked_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_object_dtype(self):\n\t    a = masked_all(1, dtype='O')\n\t    assert_equal(a.filled('x')[0], 'x')\n\t\nTestMaskedArray().test_filled_with_object_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedFields():\n\tdef test_setitem(self):\n\t    ndtype = np.dtype([('a', float), ('b', int)])\n\t    ma = np.ma.MaskedArray([(1.0, 1), (2.0, 2)], dtype=ndtype)\n\t    ma['a'][1] = 3.0\n\t    assert_equal(ma['a'], np.array([1.0, 3.0]))\n\t    ma[1]['a'] = 4.0\n\t    assert_equal(ma['a'], np.array([1.0, 4.0]))\n\t    mdtype = np.dtype([('a', bool), ('b', bool)])\n\t    control = np.array([(False, True), (True, True)], dtype=mdtype)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a['a'][0] = 2\n\t    assert_equal(a.mask, control)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a[0]['a'] = 2\n\t    assert_equal(a.mask, control)\n\t    control = np.array([(True, True), (True, True)], dtype=mdtype)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a.harden_mask()\n\t    a['a'][0] = 2\n\t    assert_equal(a.mask, control)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a.harden_mask()\n\t    a[0]['a'] = 2\n\t    assert_equal(a.mask, control)\n\t\nTestMaskedFields().test_setitem()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all(self):\n\t    test = masked_all((2,), dtype=float)\n\t    control = array([1, 1], mask=[1, 1], dtype=float)\n\t    assert_equal(test, control)\n\t    dt = np.dtype({'names': ['a', 'b'], 'formats': ['f', 'f']})\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(0, 0), (0, 0)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((2, 2), dtype=dt)\n\t    control = array([[(0, 0), (0, 0)], [(0, 0), (0, 0)]], mask=[[(1, 1), (1,\n\t        1)], [(1, 1), (1, 1)]], dtype=dt)\n\t    assert_equal(test, control)\n\t    dt = np.dtype([('a', 'f'), ('b', [('ba', 'f'), ('bb', 'f')])])\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((1, 1), dtype=dt)\n\t    control = array([[(1, (1, 1))]], mask=[[(1, (1, 1))]], dtype=dt)\n\t    assert_equal(test, control)\n\t\nTestGeneric().test_masked_all()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_with_object_nested(self):\n\t    my_dtype = np.dtype([('b', ([('c', object)], (1,)))])\n\t    masked_arr = masked_all((1,), my_dtype)\n\t    assert_equal(type(masked_arr['b']), np.ma.core.MaskedArray)\n\t    assert_equal(type(masked_arr['b']['c']), np.ma.core.MaskedArray)\n\t    assert_equal(len(masked_arr['b']['c']), 1)\n\t    assert_equal(masked_arr['b']['c'].shape, (1, 1))\n\t    assert_equal(masked_arr['b']['c']._fill_value.shape, ())\n\t\nTestGeneric().test_masked_all_with_object_nested()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_with_object(self):\n\t    my_dtype = np.dtype([('b', (object, (1,)))])\n\t    masked_arr = masked_all((1,), my_dtype)\n\t    assert_equal(type(masked_arr['b']), np.ma.core.MaskedArray)\n\t    assert_equal(len(masked_arr['b']), 1)\n\t    assert_equal(masked_arr['b'].shape, (1, 1))\n\t    assert_equal(masked_arr['b']._fill_value.shape, ())\n\t\nTestGeneric().test_masked_all_with_object()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: Create an empty masked array with all elements masked.\nInputs: \n- shape: int or tuple of ints - The shape of the required MaskedArray, for example, (2, 3) or 2.\n- dtype: dtype, optional - The data type of the output, default is float.\nOutputs: \n- a: MaskedArray - A masked array with all data masked, where the data type can be specified by the dtype argument. All elements in the array are masked, and the underlying data values are arbitrary and should not be relied upon for reproducible behavior until explicitly set. The `masked_all` function is potentially faster than other masked array creation functions like `numpy.ma.zeros`, `numpy.ma.ones`, or `numpy.ma.full` because it does not initialize the array values.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef masked_all(shape, dtype=float): [MASK]\n"}
{"method_name": "default_fill_value", "full_method_name": "default_fill_value", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef default_fill_value(obj):\n    \"\"\"\n    Return the default fill value for the argument object.\n\n    The default filling value depends on the datatype of the input\n    array or the type of the input scalar:\n\n       ========  ========\n       datatype  default\n       ========  ========\n       bool      True\n       int       999999\n       float     1.e20\n       complex   1.e20+0j\n       object    '?'\n       string    'N/A'\n       ========  ========\n\n    For structured types, a structured scalar is returned, with each field the\n    default fill value for its type.\n\n    For subarray types, the fill value is an array of the same size containing\n    the default scalar fill value.\n\n    Parameters\n    ----------\n    obj : ndarray, dtype or scalar\n        The array data-type or scalar for which the default fill value\n        is returned.\n\n    Returns\n    -------\n    fill_value : scalar\n        The default fill value.\n\n    Examples\n    --------\n    >>> np.ma.default_fill_value(1)\n    999999\n    >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n    1e+20\n    >>> np.ma.default_fill_value(np.dtype(complex))\n    (1e+20+0j)\n\n    \"\"\"\n\n    def _scalar_fill_value(dtype):\n        if dtype.kind in 'Mm':\n            return default_filler.get(dtype.str[1:], '?')\n        else:\n            return default_filler.get(dtype.kind, '?')\n    dtype = _get_dtype_of(obj)\n    return _recursive_fill_value(dtype, _scalar_fill_value)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\ndef test_default_fill_value_complex():\n    assert_(default_fill_value(1 + 1.0j) == 1e+20 + 0.0j)\n\ntest_default_fill_value_complex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_flexible_dtype(self):\n\t    flexi = array([(1, 1, 1)], dtype=[('i', int), ('s', '|S8'), ('f', float)])\n\t    flexi[0] = masked\n\t    assert_equal(flexi.filled(), np.array([(default_fill_value(0),\n\t        default_fill_value('0'), default_fill_value(0.0))], dtype=flexi.dtype))\n\t    flexi[0] = masked\n\t    assert_equal(flexi.filled(1), np.array([(1, '1', 1.0)], dtype=flexi.dtype))\n\t\nTestMaskedArray().test_filled_with_flexible_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_mvoid(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = mvoid((1, 2.0), mask=[(0, 1)], dtype=ndtype)\n\t    test = a.filled()\n\t    assert_equal(tuple(test), (1, default_fill_value(1.0)))\n\t    test = a.filled((-1, -1))\n\t    assert_equal(tuple(test), (1, -1))\n\t    a.fill_value = -999, -999\n\t    assert_equal(tuple(a.filled()), (1, -999))\n\t\nTestMaskedArray().test_filled_with_mvoid()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_check_on_scalar(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    fval = _check_fill_value(0, int)\n\t    assert_equal(fval, 0)\n\t    fval = _check_fill_value(None, int)\n\t    assert_equal(fval, default_fill_value(0))\n\t    fval = _check_fill_value(0, '|S3')\n\t    assert_equal(fval, b'0')\n\t    fval = _check_fill_value(None, '|S3')\n\t    assert_equal(fval, default_fill_value(b'camelot!'))\n\t    assert_raises(TypeError, _check_fill_value, 1e+20, int)\n\t    assert_raises(TypeError, _check_fill_value, 'stuff', int)\n\t\nTestFillingValues().test_check_on_scalar()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_conversion(self):\n\t    a = array([b'3', b'4', b'5'])\n\t    a._optinfo.update({'comment': 'updated!'})\n\t    b = array(a, dtype=int)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0))\n\t    b = array(a, dtype=float)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0.0))\n\t    b = a.astype(int)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0))\n\t    assert_equal(b._optinfo['comment'], 'updated!')\n\t    b = a.astype([('a', '|S3')])\n\t    assert_equal(b['a']._data, a._data)\n\t    assert_equal(b['a'].fill_value, a.fill_value)\n\t\nTestFillingValues().test_fillvalue_conversion()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value(self):\n\t    f1 = default_fill_value(1.0)\n\t    f2 = default_fill_value(np.array(1.0))\n\t    f3 = default_fill_value(np.array(1.0).dtype)\n\t    assert_equal(f1, f2)\n\t    assert_equal(f1, f3)\n\t\nTestFillingValues().test_default_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value_structured(self):\n\t    fields = array([(1, 1, 1)], dtype=[('i', int), ('s', '|S8'), ('f', float)])\n\t    f1 = default_fill_value(fields)\n\t    f2 = default_fill_value(fields.dtype)\n\t    expected = np.array((default_fill_value(0), default_fill_value('0'),\n\t        default_fill_value(0.0)), dtype=fields.dtype)\n\t    assert_equal(f1, expected)\n\t    assert_equal(f2, expected)\n\t\nTestFillingValues().test_default_fill_value_structured()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value_void(self):\n\t    dt = np.dtype([('v', 'V7')])\n\t    f = default_fill_value(dt)\n\t    assert_equal(f['v'], np.array(default_fill_value(dt['v']), dt['v']))\n\t\nTestFillingValues().test_default_fill_value_void()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_exotic_dtype(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    ndtype = [('i', int), ('s', '|S8'), ('f', float)]\n\t    control = np.array((default_fill_value(0), default_fill_value('0'),\n\t        default_fill_value(0.0)), dtype=ndtype)\n\t    assert_equal(_check_fill_value(None, ndtype), control)\n\t    ndtype = [('f0', float, (2, 2))]\n\t    control = np.array((default_fill_value(0.0),), dtype=[('f0', float)]\n\t        ).astype(ndtype)\n\t    assert_equal(_check_fill_value(None, ndtype), control)\n\t    control = np.array((0,), dtype=[('f0', float)]).astype(ndtype)\n\t    assert_equal(_check_fill_value(0, ndtype), control)\n\t    ndtype = np.dtype('int, (2,3)float, float')\n\t    control = np.array((default_fill_value(0), default_fill_value(0.0),\n\t        default_fill_value(0.0)), dtype='int, float, float').astype(ndtype)\n\t    test = _check_fill_value(None, ndtype)\n\t    assert_equal(test, control)\n\t    control = np.array((0, 0, 0), dtype='int, float, float').astype(ndtype)\n\t    assert_equal(_check_fill_value(0, ndtype), control)\n\t    M = masked_array(control)\n\t    assert_equal(M['f1'].fill_value.ndim, 0)\n\t\nTestFillingValues().test_fillvalue_exotic_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_datetime_timedelta(self):\n\t    for timecode in ('as', 'fs', 'ps', 'ns', 'us', 'ms', 's', 'm', 'h', 'D',\n\t        'W', 'M', 'Y'):\n\t        control = numpy.datetime64('NaT', timecode)\n\t        test = default_fill_value(numpy.dtype('<M8[' + timecode + ']'))\n\t        np.testing.assert_equal(test, control)\n\t        control = numpy.timedelta64('NaT', timecode)\n\t        test = default_fill_value(numpy.dtype('<m8[' + timecode + ']'))\n\t        np.testing.assert_equal(test, control)\n\t\nTestFillingValues().test_fillvalue_datetime_timedelta()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_extremum_fill_value(self):\n\t    a = array([(1, (2, 3)), (4, (5, 6))], dtype=[('A', int), ('B', [('BA',\n\t        int), ('BB', int)])])\n\t    test = a.fill_value\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test['A'], default_fill_value(a['A']))\n\t    assert_equal(test['B']['BA'], default_fill_value(a['B']['BA']))\n\t    assert_equal(test['B']['BB'], default_fill_value(a['B']['BB']))\n\t    test = minimum_fill_value(a)\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test[0], minimum_fill_value(a['A']))\n\t    assert_equal(test[1][0], minimum_fill_value(a['B']['BA']))\n\t    assert_equal(test[1][1], minimum_fill_value(a['B']['BB']))\n\t    assert_equal(test[1], minimum_fill_value(a['B']))\n\t    test = maximum_fill_value(a)\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test[0], maximum_fill_value(a['A']))\n\t    assert_equal(test[1][0], maximum_fill_value(a['B']['BA']))\n\t    assert_equal(test[1][1], maximum_fill_value(a['B']['BB']))\n\t    assert_equal(test[1], maximum_fill_value(a['B']))\n\t\nTestFillingValues().test_extremum_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_individual_fields(self):\n\t    ndtype = [('a', int), ('b', int)]\n\t    a = array(list(zip([1, 2, 3], [4, 5, 6])), fill_value=(-999, -999),\n\t        dtype=ndtype)\n\t    aa = a['a']\n\t    aa.set_fill_value(10)\n\t    assert_equal(aa._fill_value, np.array(10))\n\t    assert_equal(tuple(a.fill_value), (10, -999))\n\t    a.fill_value['b'] = -10\n\t    assert_equal(tuple(a.fill_value), (10, -10))\n\t    t = array(list(zip([1, 2, 3], [4, 5, 6])), dtype=ndtype)\n\t    tt = t['a']\n\t    tt.set_fill_value(10)\n\t    assert_equal(tt._fill_value, np.array(10))\n\t    assert_equal(tuple(t.fill_value), (10, default_fill_value(0)))\n\t\nTestFillingValues().test_fillvalue_individual_fields()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_implicit_structured_array(self):\n\t    ndtype = 'b', float\n\t    adtype = 'a', float\n\t    a = array([(1.0,), (2.0,)], mask=[(False,), (False,)], fill_value=(np.\n\t        nan,), dtype=np.dtype([adtype]))\n\t    b = empty(a.shape, dtype=[adtype, ndtype])\n\t    b['a'] = a['a']\n\t    b['a'].set_fill_value(a['a'].fill_value)\n\t    f = b._fill_value[()]\n\t    assert_(np.isnan(f[0]))\n\t    assert_equal(f[-1], default_fill_value(1.0))\n\t\nTestFillingValues().test_fillvalue_implicit_structured_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_bytes_or_str(self):\n\t    a = empty(shape=(3,), dtype='(2,)3S,(2,)3U')\n\t    assert_equal(a['f0'].fill_value, default_fill_value(b'spam'))\n\t    assert_equal(a['f1'].fill_value, default_fill_value('eggs'))\n\t\nTestFillingValues().test_fillvalue_bytes_or_str()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The default_fill_value function is designed to determine the default fill value for a given input object, which could be a NumPy ndarray, a dtype, or a scalar value. The function returns a suitable default value based on the data type of the input. For instance, it returns True for boolean types, 999999 for integers, 1.e20 for floats, 1.e20+0j for complex numbers, '?' for objects, and 'N/A' for strings. For structured types, it returns a structured scalar with each field set to its default fill value, and for subarray types, it returns an array of the same size with the default scalar fill value.\n\nInputs: \n- obj: The input object can be a NumPy ndarray, a data type (dtype), or a scalar value. This object's data type defines the default fill value that the function will return.\n\nOutputs: \n- fill_value: A scalar value that represents the default fill value for the data type of the input object. This can be a boolean, integer, float, complex number, string, or a structured scalar for structured types, or an array for subarray types, depending on the input's data type.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef default_fill_value(obj): [MASK]\n"}
{"method_name": "doc_note", "full_method_name": "doc_note", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef doc_note(initialdoc, note):\n    \"\"\"\n    Adds a Notes section to an existing docstring.\n\n    \"\"\"\n    if initialdoc is None:\n        return\n    if note is None:\n        return initialdoc\n    notesplit = re.split('\\\\n\\\\s*?Notes\\\\n\\\\s*?-----', inspect.cleandoc(\n        initialdoc))\n    notedoc = '\\n\\nNotes\\n-----\\n%s\\n' % inspect.cleandoc(note)\n    return ''.join(notesplit[:1] + [notedoc] + notesplit[1:])", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n@pytest.mark.skipif(sys.flags.optimize > 1, reason=\n    'no docstrings present to inspect when PYTHONOPTIMIZE/Py_OptimizeFlag > 1')\ndef test_doc_note():\n\n    def method(self):\n        \"\"\"This docstring\n\n        Has multiple lines\n\n        And notes\n\n        Notes\n        -----\n        original note\n        \"\"\"\n        pass\n    expected_doc = \"\"\"This docstring\n\nHas multiple lines\n\nAnd notes\n\nNotes\n-----\nnote\n\noriginal note\"\"\"\n    assert_equal(doc_note(method.__doc__, 'note'), expected_doc)\n\ntest_doc_note()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The doc_note function is designed to augment an existing docstring by adding a 'Notes' section. This is particularly useful for enhancing documentation with additional details, explanations, or caveats that should be considered when using a function or class.\n\nInputs: \n1. initialdoc (str): This is the original docstring that needs to be augmented. It can be the docstring of any function, class, or method. If the input is None, the function should return nothing.\n2. note (str): This is the additional note or information that needs to be incorporated into the 'Notes' section of the docstring. If this input is None, the function should return the original docstring without modification.\n\nOutputs:\n1. The function returns a modified docstring with the 'Notes' section included, containing the information provided in the 'note' parameter. If 'initialdoc' is None, the function returns nothing. If 'note' is None, the function returns the original 'initialdoc' without changes.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef doc_note(initialdoc, note): [MASK]\n"}
{"method_name": "filled", "full_method_name": "filled", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef filled(a, fill_value=None):\n    \"\"\"\n    Return input as an `~numpy.ndarray`, with masked values replaced by\n    `fill_value`.\n\n    If `a` is not a `MaskedArray`, `a` itself is returned.\n    If `a` is a `MaskedArray` with no masked values, then ``a.data`` is\n    returned.\n    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to\n    ``a.fill_value``.\n\n    Parameters\n    ----------\n    a : MaskedArray or array_like\n        An input object.\n    fill_value : array_like, optional.\n        Can be scalar or non-scalar. If non-scalar, the\n        resulting filled array should be broadcastable\n        over input array. Default is None.\n\n    Returns\n    -------\n    a : ndarray\n        The filled array.\n\n    See Also\n    --------\n    compressed\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n    ...                                                [1, 0, 0],\n    ...                                                [0, 0, 0]])\n    >>> x.filled()\n    array([[999999,      1,      2],\n           [999999,      4,      5],\n           [     6,      7,      8]])\n    >>> x.filled(fill_value=333)\n    array([[333,   1,   2],\n           [333,   4,   5],\n           [  6,   7,   8]])\n    >>> x.filled(fill_value=np.arange(3))\n    array([[0, 1, 2],\n           [0, 4, 5],\n           [6, 7, 8]])\n\n    \"\"\"\n    if hasattr(a, 'filled'):\n        return a.filled(fill_value)\n    elif isinstance(a, ndarray):\n        return a\n    elif isinstance(a, dict):\n        return np.array(a, 'O')\n    else:\n        return np.array(a)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_maskedelement(self):\n\t    x = arange(6)\n\t    x[1] = masked\n\t    assert_(str(masked) == '--')\n\t    assert_(x[1] is masked)\n\t    assert_equal(filled(x[1], 0), 0)\n\t\nTestMaskedArray().test_maskedelement()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayAttributes():\n\tdef test_hardmask(self):\n\t    d = arange(5)\n\t    n = [0, 0, 0, 1, 1]\n\t    m = make_mask(n)\n\t    xh = array(d, mask=m, hard_mask=True)\n\t    xs = array(d, mask=m, hard_mask=False, copy=True)\n\t    xh[[1, 4]] = [10, 40]\n\t    xs[[1, 4]] = [10, 40]\n\t    assert_equal(xh._data, [0, 10, 2, 3, 4])\n\t    assert_equal(xs._data, [0, 10, 2, 3, 40])\n\t    assert_equal(xs.mask, [0, 0, 0, 1, 0])\n\t    assert_(xh._hardmask)\n\t    assert_(not xs._hardmask)\n\t    xh[1:4] = [10, 20, 30]\n\t    xs[1:4] = [10, 20, 30]\n\t    assert_equal(xh._data, [0, 10, 20, 3, 4])\n\t    assert_equal(xs._data, [0, 10, 20, 30, 40])\n\t    assert_equal(xs.mask, nomask)\n\t    xh[0] = masked\n\t    xs[0] = masked\n\t    assert_equal(xh.mask, [1, 0, 0, 1, 1])\n\t    assert_equal(xs.mask, [1, 0, 0, 0, 0])\n\t    xh[:] = 1\n\t    xs[:] = 1\n\t    assert_equal(xh._data, [0, 1, 1, 3, 4])\n\t    assert_equal(xs._data, [1, 1, 1, 1, 1])\n\t    assert_equal(xh.mask, [1, 0, 0, 1, 1])\n\t    assert_equal(xs.mask, nomask)\n\t    xh.soften_mask()\n\t    xh[:] = arange(5)\n\t    assert_equal(xh._data, [0, 1, 2, 3, 4])\n\t    assert_equal(xh.mask, nomask)\n\t    xh.harden_mask()\n\t    xh[xh < 3] = masked\n\t    assert_equal(xh._data, [0, 1, 2, 3, 4])\n\t    assert_equal(xh._mask, [1, 1, 1, 0, 0])\n\t    xh[filled(xh > 1, False)] = 5\n\t    assert_equal(xh._data, [0, 1, 2, 5, 5])\n\t    assert_equal(xh._mask, [1, 1, 1, 0, 0])\n\t    xh = array([[1, 2], [3, 4]], mask=[[1, 0], [0, 0]], hard_mask=True)\n\t    xh[0] = 0\n\t    assert_equal(xh._data, [[1, 0], [3, 4]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t    xh[-1, -1] = 5\n\t    assert_equal(xh._data, [[1, 0], [3, 5]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t    xh[filled(xh < 5, False)] = 2\n\t    assert_equal(xh._data, [[1, 2], [2, 5]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t\nTestMaskedArrayAttributes().test_hardmask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The function 'filled' is designed to replace masked values in a MaskedArray with a specified 'fill_value'. If the input is not a MaskedArray, it simply returns the input. If the input is a MaskedArray with no masked values, it returns the data of the array. If the input is a MaskedArray with masked values and no 'fill_value' is provided, it uses the array's 'fill_value'. \n\nInputs: \n1. a : MaskedArray or array_like\n   An input object which could be a MaskedArray, a regular array, or any array-like object.\n2. fill_value : array_like, optional (default is None)\n   This can be a scalar or non-scalar value. If non-scalar, the resulting filled array should be broadcastable over the input array.\n\nOutputs: \n1. a : ndarray\n   The function returns an ndarray where masked values in the input array have been replaced by 'fill_value'. If the input is not a MaskedArray or if it is a MaskedArray with no masked values, the original data is returned as an ndarray.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef filled(a, fill_value=None): [MASK]\n"}
{"method_name": "concatenate", "full_method_name": "concatenate", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef concatenate(arrays, axis=0):\n    \"\"\"\n    Concatenate a sequence of arrays along the given axis.\n\n    Parameters\n    ----------\n    arrays : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined. Default is 0.\n\n    Returns\n    -------\n    result : MaskedArray\n        The concatenated array with any masked entries preserved.\n\n    See Also\n    --------\n    numpy.concatenate : Equivalent function in the top-level NumPy module.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = ma.arange(3)\n    >>> a[1] = ma.masked\n    >>> b = ma.arange(2, 5)\n    >>> a\n    masked_array(data=[0, --, 2],\n                 mask=[False,  True, False],\n           fill_value=999999)\n    >>> b\n    masked_array(data=[2, 3, 4],\n                 mask=False,\n           fill_value=999999)\n    >>> ma.concatenate([a, b])\n    masked_array(data=[0, --, 2, 2, 3, 4],\n                 mask=[False,  True, False, False, False, False],\n           fill_value=999999)\n\n    \"\"\"\n    d = np.concatenate([getdata(a) for a in arrays], axis)\n    rcls = get_masked_subclass(*arrays)\n    data = d.view(rcls)\n    for x in arrays:\n        if getmask(x) is not nomask:\n            break\n    else:\n        return data\n    dm = np.concatenate([getmaskarray(a) for a in arrays], axis)\n    dm = dm.reshape(d.shape)\n    data._mask = _shrink_mask(dm)\n    return data", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_concatenate_flexible(self):\n\t    data = masked_array(list(zip(np.random.rand(10), np.arange(10))), dtype\n\t        =[('a', float), ('b', int)])\n\t    test = concatenate([data[:5], data[5:]])\n\t    assert_equal_records(test, data)\n\t\nTestMaskedArray().test_concatenate_flexible()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The concatenate function merges a list of array-like objects into a single array along a specified axis. This function is particularly useful for combining multiple arrays with compatible shapes but varying data along a specific dimension.\n\nInputs:\n- arrays: A sequence of array-like objects. These arrays must have the same shape, except in the dimension corresponding to the axis parameter. This means that all arrays except for the dimension specified by 'axis' must have identical sizes.\n- axis: An integer representing the dimension along which the arrays will be joined. The default value for 'axis' is 0, which refers to the first dimension.\n\nOutputs:\n- result: A MaskedArray object. This is the resulting array after concatenation, with any masked entries from the input arrays being preserved. The returned array will have the same shape as the input arrays, except for the dimension specified by 'axis', which will be the sum of the corresponding dimensions from the input arrays.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef concatenate(arrays, axis=0): [MASK]\n"}
{"method_name": "asarray", "full_method_name": "asarray", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef asarray(a, dtype=None, order=None):\n    \"\"\"\n    Convert the input to a masked array of the given data-type.\n\n    No copy is performed if the input is already an `ndarray`. If `a` is\n    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to a masked array. This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists, ndarrays and masked arrays.\n    dtype : dtype, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Default is 'C'.\n\n    Returns\n    -------\n    out : MaskedArray\n        Masked array interpretation of `a`.\n\n    See Also\n    --------\n    asanyarray : Similar to `asarray`, but conserves subclasses.\n\n    Examples\n    --------\n    >>> x = np.arange(10.).reshape(2, 5)\n    >>> x\n    array([[0., 1., 2., 3., 4.],\n           [5., 6., 7., 8., 9.]])\n    >>> np.ma.asarray(x)\n    masked_array(\n      data=[[0., 1., 2., 3., 4.],\n            [5., 6., 7., 8., 9.]],\n      mask=False,\n      fill_value=1e+20)\n    >>> type(np.ma.asarray(x))\n    <class 'numpy.ma.MaskedArray'>\n\n    \"\"\"\n    order = order or 'C'\n    return masked_array(a, dtype=dtype, copy=False, keep_mask=True, subok=\n        False, order=order)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_asarray_default_order(self):\n\t    m = np.eye(3).T\n\t    assert_(not m.flags.c_contiguous)\n\t    new_m = asarray(m)\n\t    assert_(new_m.flags.c_contiguous)\n\t\nTestMaskedArray().test_asarray_default_order()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_asarray_enforce_order(self):\n\t    m = np.eye(3).T\n\t    assert_(not m.flags.c_contiguous)\n\t    new_m = asarray(m, order='C')\n\t    assert_(new_m.flags.c_contiguous)\n\t\nTestMaskedArray().test_asarray_enforce_order()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The asarray function is designed to convert the input data into a masked array of the specified data-type. If the input is already an ndarray, no copy is performed. If the input is a subclass of MaskedArray, a base class MaskedArray is returned.\n\nInputs: \n1. a: array_like - This is the input data in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays, and masked arrays.\n2. dtype: dtype, optional - This is the data-type of the returned array. If not specified, the data-type is inferred from the input data.\n3. order: {'C', 'F'}, optional - This specifies whether to use row-major ('C') or column-major ('FORTRAN') memory representation. The default is 'C'.\n\nOutputs:\n1. out: MaskedArray - This is the masked array interpretation of the input 'a'. The output is a masked array that is a subclass of ndarray, with the capability to handle missing or invalid entries.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef asarray(a, dtype=None, order=None): [MASK]\n"}
{"method_name": "sort", "full_method_name": "sort", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None,\n    *, stable=None):\n    \"\"\"\n    Return a sorted copy of the masked array.\n\n    Equivalent to creating a copy of the array\n    and applying the  MaskedArray ``sort()`` method.\n\n    Refer to ``MaskedArray.sort`` for the full documentation\n\n    See Also\n    --------\n    MaskedArray.sort : equivalent method\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)\n    >>> ma.sort(masked_x)\n    masked_array(data=[-3.973, 0.801, 11.2, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)\n    \"\"\"\n    a = np.array(a, copy=True, subok=True)\n    if axis is None:\n        a = a.flatten()\n        axis = 0\n    if isinstance(a, MaskedArray):\n        a.sort(axis=axis, kind=kind, order=order, endwith=endwith,\n            fill_value=fill_value, stable=stable)\n    else:\n        a.sort(axis=axis, kind=kind, order=order, stable=stable)\n    return a", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    sortedx = sort(x)\n\t    assert_equal(sortedx._data, [1, 2, 3, 4])\n\t    assert_equal(sortedx._mask, [0, 0, 0, 1])\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [4, 1, 2, 3])\n\t    assert_equal(sortedx._mask, [1, 0, 0, 0])\n\t    x.sort()\n\t    assert_equal(x._data, [1, 2, 3, 4])\n\t    assert_equal(x._mask, [0, 0, 0, 1])\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    x.sort(endwith=False)\n\t    assert_equal(x._data, [4, 1, 2, 3])\n\t    assert_equal(x._mask, [1, 0, 0, 0])\n\t    x = [1, 4, 2, 3]\n\t    sortedx = sort(x)\n\t    assert_(not isinstance(sorted, MaskedArray))\n\t    x = array([0, 1, -1, -2, 2], mask=nomask, dtype=np.int8)\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [-2, -1, 0, 1, 2])\n\t    x = array([0, 1, -1, -2, 2], mask=[0, 1, 0, 0, 1], dtype=np.int8)\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [1, 2, -2, -1, 0])\n\t    assert_equal(sortedx._mask, [1, 1, 0, 0, 0])\n\t    x = array([0, -1], dtype=np.int8)\n\t    sortedx = sort(x, kind='stable')\n\t    assert_equal(sortedx, array([-1, 0], dtype=np.int8))\n\t\nTestMaskedArrayMethods().test_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort_matches_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    for kwargs in [dict(), dict(endwith=True), dict(endwith=False), dict(\n\t        fill_value=2), dict(fill_value=2, endwith=True), dict(fill_value=2,\n\t        endwith=False)]:\n\t        sortedx = sort(x, **kwargs)\n\t        argsortedx = x[argsort(x, **kwargs)]\n\t        assert_equal(sortedx._data, argsortedx._data)\n\t        assert_equal(sortedx._mask, argsortedx._mask)\n\t\nTestMaskedArrayMethods().test_argsort_matches_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_sort_flexible(self):\n\t    a = array(data=[(3, 3), (3, 2), (2, 2), (2, 1), (1, 0), (1, 1), (1, 2)],\n\t        mask=[(0, 0), (0, 1), (0, 0), (0, 0), (1, 0), (0, 0), (0, 0)],\n\t        dtype=[('A', int), ('B', int)])\n\t    mask_last = array(data=[(1, 1), (1, 2), (2, 1), (2, 2), (3, 3), (3, 2),\n\t        (1, 0)], mask=[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (1, \n\t        0)], dtype=[('A', int), ('B', int)])\n\t    mask_first = array(data=[(1, 0), (1, 1), (1, 2), (2, 1), (2, 2), (3, 2),\n\t        (3, 3)], mask=[(1, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (0, \n\t        0)], dtype=[('A', int), ('B', int)])\n\t    test = sort(a)\n\t    assert_equal(test, mask_last)\n\t    assert_equal(test.mask, mask_last.mask)\n\t    test = sort(a, endwith=False)\n\t    assert_equal(test, mask_first)\n\t    assert_equal(test.mask, mask_first.mask)\n\t    dt = np.dtype([('v', int, 2)])\n\t    a = a.view(dt)\n\t    test = sort(a)\n\t    test = sort(a, endwith=False)\n\t\nTestMaskedArrayMethods().test_sort_flexible()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The sort function is designed to return a sorted copy of a masked array. It works by creating a copy of the input array and applying the MaskedArray sort method. This function is particularly useful for sorting elements in arrays that might contain masked values.\n\nInputs: \n- a: The input array to be sorted. This can be a numpy array or a masked array.\n- axis: The axis along which to sort. The default is -1, which sorts along the last axis.\n- kind: The sorting algorithm used. Possible values are 'quicksort', 'mergesort', 'heapsort', and 'stable'. If kind is not specified, the default is 'quicksort'.\n- order: When sorting structured arrays, this argument specifies which fields to compare first, second, etc. A list of field names or a single field name is accepted. By default, all fields are used.\n- endwith: Boolean value that specifies whether missing values (NaNs) or masked values are placed at the end or beginning of the sorted array when sorting. The default is True, which places them at the end.\n- fill_value: Value used to fill in the masked values before sorting. If None, the default fill value for the array type is used.\n- stable: If True, the sort will be stable meaning that equal elements will maintain their relative order. By default, the stability of the sort is determined by the kind parameter.\n\nOutputs:\n- A sorted copy of the input array. The sorted array maintains the same type as the input array (numpy array or masked array). The sorted array will have the elements sorted according to the specified parameters.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None,\n    *, stable=None): [MASK]\n"}
{"method_name": "masked_where", "full_method_name": "masked_where", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_where(condition, a, copy=True):\n    \"\"\"\n    Mask an array where a condition is met.\n\n    Return `a` as an array masked where `condition` is True.\n    Any masked values of `a` or `condition` are also masked in the output.\n\n    Parameters\n    ----------\n    condition : array_like\n        Masking condition.  When `condition` tests floating point values for\n        equality, consider using ``masked_values`` instead.\n    a : array_like\n        Array to mask.\n    copy : bool\n        If True (default) make a copy of `a` in the result.  If False modify\n        `a` in place and return a view.\n\n    Returns\n    -------\n    result : MaskedArray\n        The result of masking `a` where `condition` is True.\n\n    See Also\n    --------\n    masked_values : Mask using floating point equality.\n    masked_equal : Mask where equal to a given value.\n    masked_not_equal : Mask where *not* equal to a given value.\n    masked_less_equal : Mask where less than or equal to a given value.\n    masked_greater_equal : Mask where greater than or equal to a given value.\n    masked_less : Mask where less than a given value.\n    masked_greater : Mask where greater than a given value.\n    masked_inside : Mask inside a given interval.\n    masked_outside : Mask outside a given interval.\n    masked_invalid : Mask invalid values (NaNs or infs).\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_where(a <= 2, a)\n    masked_array(data=[--, --, --, 3],\n                 mask=[ True,  True,  True, False],\n           fill_value=999999)\n\n    Mask array `b` conditional on `a`.\n\n    >>> b = ['a', 'b', 'c', 'd']\n    >>> ma.masked_where(a == 2, b)\n    masked_array(data=['a', 'b', --, 'd'],\n                 mask=[False, False,  True, False],\n           fill_value='N/A',\n                dtype='<U1')\n\n    Effect of the `copy` argument.\n\n    >>> c = ma.masked_where(a <= 2, a)\n    >>> c\n    masked_array(data=[--, --, --, 3],\n                 mask=[ True,  True,  True, False],\n           fill_value=999999)\n    >>> c[0] = 99\n    >>> c\n    masked_array(data=[99, --, --, 3],\n                 mask=[False,  True,  True, False],\n           fill_value=999999)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> c = ma.masked_where(a <= 2, a, copy=False)\n    >>> c[0] = 99\n    >>> c\n    masked_array(data=[99, --, --, 3],\n                 mask=[False,  True,  True, False],\n           fill_value=999999)\n    >>> a\n    array([99,  1,  2,  3])\n\n    When `condition` or `a` contain masked values.\n\n    >>> a = np.arange(4)\n    >>> a = ma.masked_where(a == 2, a)\n    >>> a\n    masked_array(data=[0, 1, --, 3],\n                 mask=[False, False,  True, False],\n           fill_value=999999)\n    >>> b = np.arange(4)\n    >>> b = ma.masked_where(b == 0, b)\n    >>> b\n    masked_array(data=[--, 1, 2, 3],\n                 mask=[ True, False, False, False],\n           fill_value=999999)\n    >>> ma.masked_where(a == 3, b)\n    masked_array(data=[--, 1, --, --],\n                 mask=[ True, False,  True,  True],\n           fill_value=999999)\n\n    \"\"\"\n    cond = make_mask(condition, shrink=False)\n    a = np.array(a, copy=copy, subok=True)\n    cshape, ashape = cond.shape, a.shape\n    if cshape and cshape != ashape:\n        raise IndexError(\n            'Inconsistent shape between the condition and the input (got %s and %s)'\n             % (cshape, ashape))\n    if hasattr(a, '_mask'):\n        cond = mask_or(cond, a._mask)\n        cls = type(a)\n    else:\n        cls = MaskedArray\n    result = a.view(cls)\n    result.mask = _shrink_mask(cond)\n    if not copy and hasattr(a, '_mask') and getmask(a) is nomask:\n        a._mask = result._mask.view()\n    return result", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_1(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_equal(z.real, x)\n\t    assert_equal(z.imag, 10 * x)\n\t    assert_equal((z * conjugate(z)).real, 101 * x * x)\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_equal(x, z)\n\t\nTestMaskedArray().test_oddfeatures_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestUfuncs():\n\tdef test_minmax(self):\n\t    a = arange(1, 13).reshape(3, 4)\n\t    amask = masked_where(a < 5, a)\n\t    assert_equal(amask.max(), a.max())\n\t    assert_equal(amask.min(), 5)\n\t    assert_equal(amask.max(0), a.max(0))\n\t    assert_equal(amask.min(0), [5, 6, 7, 8])\n\t    assert_(amask.max(1)[0].mask)\n\t    assert_(amask.min(1)[0].mask)\n\t\nTestUfuncs().test_minmax()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_bool(self):\n\t    x = [1, 2]\n\t    y = masked_where(False, x)\n\t    assert_equal(y, [1, 2])\n\t    assert_equal(y[1], 2)\n\t\nTestMaskedArrayFunctions().test_masked_where_bool()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    x[2] = masked\n\t    assert_equal(masked_where(greater(x, 2), x), masked_greater(x, 2))\n\t    assert_equal(masked_where(greater_equal(x, 2), x), masked_greater_equal\n\t        (x, 2))\n\t    assert_equal(masked_where(less(x, 2), x), masked_less(x, 2))\n\t    assert_equal(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where(equal(x, 2), x), masked_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3,\n\t        4, 5])\n\t\nTestMaskedArrayFunctions().test_masked_where_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_oddities(self):\n\t    atest = ones((10, 10, 10), dtype=float)\n\t    btest = zeros(atest.shape, MaskType)\n\t    ctest = masked_where(btest, atest)\n\t    assert_equal(atest, ctest)\n\t\nTestMaskedArrayFunctions().test_masked_where_oddities()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_structured_masked(self):\n\t    dt = np.dtype([('a', int), ('b', int)])\n\t    x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)\n\t    ma = where([0, 1, 1], x, masked)\n\t    expected = masked_where([1, 0, 0], x)\n\t    assert_equal(ma.dtype, expected.dtype)\n\t    assert_equal(ma, expected)\n\t    assert_equal(ma.mask, expected.mask)\n\t\nTestMaskedArrayFunctions().test_where_structured_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: Mask an array where a condition is met. This function takes an array and masks it based on a provided condition. Any existing masked values in the condition or the array are also masked in the output.\n\nInputs:\n    condition: An array-like object. This is the masking condition. It tests the elements of the array 'a' and masks them where the condition is True.\n    a: An array-like object. This is the array to mask based on the 'condition'.\n    copy: A boolean value (default is True). If True, the function makes a copy of 'a' for the result. If False, it modifies 'a' in place and returns a view.\n\nOutputs:\n    result: A MaskedArray object. This is the result of masking 'a' where 'condition' is True. The output preserves the shape of 'a' and masks the elements of 'a' where 'condition' is True. Existing masked values in 'a' or 'condition' are also masked in the output.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_where(condition, a, copy=True): [MASK]\n"}
{"method_name": "where", "full_method_name": "where", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef where(condition, x=_NoValue, y=_NoValue):\n    \"\"\"\n    Return a masked array with elements from `x` or `y`, depending on condition.\n\n    .. note::\n        When only `condition` is provided, this function is identical to\n        `nonzero`. The rest of this documentation covers only the case where\n        all three arguments are provided.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        Where True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x`, `y` and `condition` need to be\n        broadcastable to some shape.\n\n    Returns\n    -------\n    out : MaskedArray\n        An masked array with `masked` elements where the condition is masked,\n        elements from `x` where `condition` is True, and elements from `y`\n        elsewhere.\n\n    See Also\n    --------\n    numpy.where : Equivalent function in the top-level NumPy module.\n    nonzero : The function that is called when x and y are omitted\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n    ...                                                    [1, 0, 1],\n    ...                                                    [0, 1, 0]])\n    >>> x\n    masked_array(\n      data=[[0.0, --, 2.0],\n            [--, 4.0, --],\n            [6.0, --, 8.0]],\n      mask=[[False,  True, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=1e+20)\n    >>> np.ma.where(x > 5, x, -3.1416)\n    masked_array(\n      data=[[-3.1416, --, -3.1416],\n            [--, -3.1416, --],\n            [6.0, --, 8.0]],\n      mask=[[False,  True, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=1e+20)\n\n    \"\"\"\n    missing = (x is _NoValue, y is _NoValue).count(True)\n    if missing == 1:\n        raise ValueError(\"Must provide both 'x' and 'y' or neither.\")\n    if missing == 2:\n        return nonzero(condition)\n    cf = filled(condition, False)\n    xd = getdata(x)\n    yd = getdata(y)\n    cm = getmaskarray(condition)\n    xm = getmaskarray(x)\n    ym = getmaskarray(y)\n    if x is masked and y is not masked:\n        xd = np.zeros((), dtype=yd.dtype)\n        xm = np.ones((), dtype=ym.dtype)\n    elif y is masked and x is not masked:\n        yd = np.zeros((), dtype=xd.dtype)\n        ym = np.ones((), dtype=xm.dtype)\n    data = np.where(cf, xd, yd)\n    mask = np.where(cf, xm, ym)\n    mask = np.where(cm, np.ones((), dtype=mask.dtype), mask)\n    mask = _shrink_mask(mask)\n    return masked_array(data, mask=mask)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_1(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_equal(z.real, x)\n\t    assert_equal(z.imag, 10 * x)\n\t    assert_equal((z * conjugate(z)).real, 101 * x * x)\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_equal(x, z)\n\t\nTestMaskedArray().test_oddfeatures_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_2(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t\nTestMaskedArray().test_oddfeatures_2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_round(self):\n\t    a = array([1.23456, 2.34567, 3.45678, 4.56789, 5.6789], mask=[0, 1, 0, \n\t        0, 0])\n\t    assert_equal(a.round(), [1.0, 2.0, 3.0, 5.0, 6.0])\n\t    assert_equal(a.round(1), [1.2, 2.3, 3.5, 4.6, 5.7])\n\t    assert_equal(a.round(3), [1.235, 2.346, 3.457, 4.568, 5.679])\n\t    b = empty_like(a)\n\t    a.round(out=b)\n\t    assert_equal(b, [1.0, 2.0, 3.0, 5.0, 6.0])\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t\nTestMaskedArrayFunctions().test_round()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_with_masked_choice(self):\n\t    x = arange(10)\n\t    x[3] = masked\n\t    c = x >= 8\n\t    z = where(c, x, masked)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is masked)\n\t    assert_(z[7] is masked)\n\t    assert_(z[8] is not masked)\n\t    assert_(z[9] is not masked)\n\t    assert_equal(x, z)\n\t    z = where(c, masked, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t\nTestMaskedArrayFunctions().test_where_with_masked_choice()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_with_masked_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    x = arange(1, 6)\n\t    x[-1] = masked\n\t    y = arange(1, 6) * 10\n\t    y[2] = masked\n\t    c = array([1, 1, 1, 0, 0], mask=[1, 0, 0, 0, 0])\n\t    cm = c.filled(1)\n\t    z = where(c, x, y)\n\t    zm = where(cm, x, y)\n\t    assert_equal(z, zm)\n\t    assert_(getmask(zm) is nomask)\n\t    assert_equal(zm, [1, 2, 3, 40, 50])\n\t    z = where(c, masked, 1)\n\t    assert_equal(z, [99, 99, 99, 1, 1])\n\t    z = where(c, 1, masked)\n\t    assert_equal(z, [99, 1, 1, 99, 99])\n\t\nTestMaskedArrayFunctions().test_where_with_masked_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_type(self):\n\t    x = np.arange(4, dtype=np.int32)\n\t    y = np.arange(4, dtype=np.float32) * 2.2\n\t    test = where(x > 1.5, y, x).dtype\n\t    control = np.result_type(np.int32, np.float32)\n\t    assert_equal(test, control)\n\t\nTestMaskedArrayFunctions().test_where_type()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_broadcast(self):\n\t    x = np.arange(9).reshape(3, 3)\n\t    y = np.zeros(3)\n\t    core = np.where([1, 0, 1], x, y)\n\t    ma = where([1, 0, 1], x, y)\n\t    assert_equal(core, ma)\n\t    assert_equal(core.dtype, ma.dtype)\n\t\nTestMaskedArrayFunctions().test_where_broadcast()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_structured_masked(self):\n\t    dt = np.dtype([('a', int), ('b', int)])\n\t    x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)\n\t    ma = where([0, 1, 1], x, masked)\n\t    expected = masked_where([1, 0, 0], x)\n\t    assert_equal(ma.dtype, expected.dtype)\n\t    assert_equal(ma, expected)\n\t    assert_equal(ma.mask, expected.mask)\n\t\nTestMaskedArrayFunctions().test_where_structured_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The where function is designed to return a masked array with elements selected from two provided arrays, x and y, based on a given condition. It operates element-wise over the arrays, choosing elements from x where the condition is True, and from y where the condition is False. If only the condition is provided without x and y, the function behaves like the nonzero function, returning the indices where the condition is True.\n\nInputs: \n- condition: A boolean array-like object where True specifies the elements to be taken from x and False from y. This condition array needs to be broadcastable to the shapes of x and y.\n- x: An array-like object from which elements are chosen where the condition is True. This array needs to be broadcastable to the shape of the condition.\n- y: An array-like object from which elements are chosen where the condition is False. This array needs to be broadcastable to the shape of the condition.\n\nOutputs:\n- out: A masked array where masked elements correspond to masked elements in the condition array, elements from x where the condition is True, and elements from y where the condition is False.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef where(condition, x=_NoValue, y=_NoValue): [MASK]\n"}
{"method_name": "flatten_structured_array", "full_method_name": "flatten_structured_array", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef flatten_structured_array(a):\n    \"\"\"\n    Flatten a structured array.\n\n    The data type of the output is chosen such that it can represent all of the\n    (nested) fields.\n\n    Parameters\n    ----------\n    a : structured array\n\n    Returns\n    -------\n    output : masked array or ndarray\n        A flattened masked array if the input is a masked array, otherwise a\n        standard ndarray.\n\n    Examples\n    --------\n    >>> ndtype = [('a', int), ('b', float)]\n    >>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n    >>> np.ma.flatten_structured_array(a)\n    array([[1., 1.],\n           [2., 2.]])\n\n    \"\"\"\n\n    def flatten_sequence(iterable):\n        \"\"\"\n        Flattens a compound of nested iterables.\n\n        \"\"\"\n        for elm in iter(iterable):\n            if hasattr(elm, '__iter__'):\n                yield from flatten_sequence(elm)\n            else:\n                yield elm\n    a = np.asanyarray(a)\n    inishape = a.shape\n    a = a.ravel()\n    if isinstance(a, MaskedArray):\n        out = np.array([tuple(flatten_sequence(d.item())) for d in a._data])\n        out = out.view(MaskedArray)\n        out._mask = np.array([tuple(flatten_sequence(d.item())) for d in\n            getmaskarray(a)])\n    else:\n        out = np.array([tuple(flatten_sequence(d.item())) for d in a])\n    if len(inishape) > 1:\n        newshape = list(out.shape)\n        newshape[0] = inishape\n        out.shape = tuple(flatten_sequence(newshape))\n    return out", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_flatten_structured_array(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = np.array([[1.0, 1.0], [2.0, 2.0]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    a = array([(1, 1), (2, 2)], mask=[(0, 1), (1, 0)], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = array([[1.0, 1.0], [2.0, 2.0]], mask=[[0, 1], [1, 0]], dtype=\n\t        float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    assert_equal(test.mask, control.mask)\n\t    ndtype = [('a', int), ('b', [('ba', int), ('bb', float)])]\n\t    a = array([(1, (1, 1.1)), (2, (2, 2.2))], mask=[(0, (1, 0)), (1, (0, 1)\n\t        )], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = array([[1.0, 1.0, 1.1], [2.0, 2.0, 2.2]], mask=[[0, 1, 0], [1,\n\t        0, 1]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    assert_equal(test.mask, control.mask)\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = np.array([[(1, 1)], [(2, 2)]], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = np.array([[[1.0, 1.0]], [[2.0, 2.0]]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t\nTestMaskedArray().test_flatten_structured_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: Flattens a structured array into a single array where each element is a tuple containing all the fields of the structured array. The function can handle nested fields and adjusts the output type to accommodate all fields.\n\nInputs: \n- a : structured array\n  A structured numpy array. The array can contain a variety of data types, including nested structured arrays.\n\nOutputs: \n- output : masked array or ndarray\n  A flattened masked array if the input is a masked array, otherwise, a standard ndarray. The output array will have each element as a tuple containing all the fields from the structured array, flattened and structured in the same order.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef flatten_structured_array(a): [MASK]\n"}
{"method_name": "getmaskarray", "full_method_name": "getmaskarray", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef getmaskarray(arr):\n    \"\"\"\n    Return the mask of a masked array, or full boolean array of False.\n\n    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and\n    the mask is not `nomask`, else return a full boolean array of False of\n    the same shape as `arr`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input `MaskedArray` for which the mask is required.\n\n    See Also\n    --------\n    getmask : Return the mask of a masked array, or nomask.\n    getdata : Return the data of a masked array as an ndarray.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = ma.masked_equal([[1,2],[3,4]], 2)\n    >>> a\n    masked_array(\n      data=[[1, --],\n            [3, 4]],\n      mask=[[False,  True],\n            [False, False]],\n      fill_value=2)\n    >>> ma.getmaskarray(a)\n    array([[False,  True],\n           [False, False]])\n\n    Result when mask == ``nomask``\n\n    >>> b = ma.masked_array([[1,2],[3,4]])\n    >>> b\n    masked_array(\n      data=[[1, 2],\n            [3, 4]],\n      mask=False,\n      fill_value=999999)\n    >>> ma.getmaskarray(b)\n    array([[False, False],\n           [False, False]])\n\n    \"\"\"\n    mask = getmask(arr)\n    if mask is nomask:\n        mask = make_mask_none(np.shape(arr), getattr(arr, 'dtype', None))\n    return mask", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_limits_arithmetic(self):\n\t    tiny = np.finfo(float).tiny\n\t    a = array([tiny, 1.0 / tiny, 0.0])\n\t    assert_equal(getmaskarray(a / 2), [0, 0, 0])\n\t    assert_equal(getmaskarray(2 / a), [1, 0, 1])\n\t\nTestMaskedArrayArithmetic().test_limits_arithmetic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedFields():\n\tdef test_getmaskarray(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    test = empty(3, dtype=ndtype)\n\t    assert_equal(getmaskarray(test), np.array([(0, 0), (0, 0), (0, 0)],\n\t        dtype=[('a', '|b1'), ('b', '|b1')]))\n\t    test[:] = masked\n\t    assert_equal(getmaskarray(test), np.array([(1, 1), (1, 1), (1, 1)],\n\t        dtype=[('a', '|b1'), ('b', '|b1')]))\n\t\nTestMaskedFields().test_getmaskarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The function 'getmaskarray' is designed to return the mask of a masked array. If the input is a 'MaskedArray' and the mask is not 'nomask', it returns the mask as an ndarray. Otherwise, it returns a full boolean array of False of the same shape as the input array.\n\nInputs: \n- arr : array_like\n    The input 'MaskedArray' for which the mask is required.\n\nOutputs:\n- mask : ndarray\n    The mask of the input array as an ndarray if the input array is a 'MaskedArray' and the mask is not 'nomask'. Otherwise, returns a full boolean array of False with the same shape as the input array.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef getmaskarray(arr): [MASK]\n"}
{"method_name": "outer", "full_method_name": "outer", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef outer(a, b):\n    \"\"\"maskedarray version of the numpy function.\"\"\"\n    fa = filled(a, 0).ravel()\n    fb = filled(b, 0).ravel()\n    d = np.outer(fa, fb)\n    ma = getmask(a)\n    mb = getmask(b)\n    if ma is nomask and mb is nomask:\n        return masked_array(d)\n    ma = getmaskarray(a)\n    mb = getmaskarray(b)\n    m = make_mask(1 - np.outer(1 - ma, 1 - mb), copy=False)\n    return masked_array(d, mask=m)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The function 'outer' is a maskedarray version of the numpy outer product function. It computes the outer product of two arrays, considering masked values. The outer product is calculated between each element of the first array and each element of the second array. If either of the input arrays has a masked value at a certain position, the corresponding element in the output array will also be masked.\n\nInputs: \n- 'a' (maskedarray): The first input array. This should be a numpy masked array.\n- 'b' (maskedarray): The second input array. This should also be a numpy masked array.\n\nOutputs: \n- A maskedarray representing the outer product of 'a' and 'b', taking into account the masked values. The result is a numpy masked array where the mask indicates if an element is a result of an operation involving a masked value.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef outer(a, b): [MASK]\n"}
{"method_name": "take", "full_method_name": "take", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef take(a, indices, axis=None, out=None, mode='raise'):\n    \"\"\"\n    \"\"\"\n    a = masked_array(a)\n    return a.take(indices, axis=axis, out=out, mode=mode)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_take(self):\n\t    x = masked_array([10, 20, 30, 40], [0, 1, 0, 1])\n\t    assert_equal(x.take([0, 0, 3]), masked_array([10, 10, 40], [0, 0, 1]))\n\t    assert_equal(x.take([0, 0, 3]), x[[0, 0, 3]])\n\t    assert_equal(x.take([[0, 1], [0, 1]]), masked_array([[10, 20], [10, 20]\n\t        ], [[0, 1], [0, 1]]))\n\t    assert_(x[1] is np.ma.masked)\n\t    assert_(x.take(1) is np.ma.masked)\n\t    x = array([[10, 20, 30], [40, 50, 60]], mask=[[0, 0, 1], [1, 0, 0]])\n\t    assert_equal(x.take([0, 2], axis=1), array([[10, 30], [40, 60]], mask=[\n\t        [0, 1], [1, 0]]))\n\t    assert_equal(take(x, [0, 2], axis=1), array([[10, 30], [40, 60]], mask=\n\t        [[0, 1], [1, 0]]))\n\t\nTestMaskedArrayMethods().test_take()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_take_masked_indices(self):\n\t    a = np.array((40, 18, 37, 9, 22))\n\t    indices = np.arange(3)[None, :] + np.arange(5)[:, None]\n\t    mindices = array(indices, mask=indices >= len(a))\n\t    test = take(a, mindices, mode='clip')\n\t    ctrl = array([[40, 18, 37], [18, 37, 9], [37, 9, 22], [9, 22, 22], [22,\n\t        22, 22]])\n\t    assert_equal(test, ctrl)\n\t    test = take(a, mindices)\n\t    ctrl = array([[40, 18, 37], [18, 37, 9], [37, 9, 22], [9, 22, 40], [22,\n\t        40, 40]])\n\t    ctrl[3, 2] = ctrl[4, 1] = ctrl[4, 2] = masked\n\t    assert_equal(test, ctrl)\n\t    assert_equal(test.mask, ctrl.mask)\n\t    a = array((40, 18, 37, 9, 22), mask=(0, 1, 0, 0, 0))\n\t    test = take(a, mindices)\n\t    ctrl[0, 1] = ctrl[1, 0] = masked\n\t    assert_equal(test, ctrl)\n\t    assert_equal(test.mask, ctrl.mask)\n\t\nTestMaskedArrayMethods().test_take_masked_indices()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The take function is designed to extract elements from an array along a specific axis based on the given indices. It supports various operations such as slicing or selecting elements from a multi-dimensional array. The function can also handle cases where the indices provided are out of bounds by specifying the mode parameter.\n\nInputs:\n- a: An array-like object from which elements will be taken. This can be a numpy array or any object that can be converted into an array using masked_array.\n- indices: An array-like object that specifies the indices of the elements to be taken from the array 'a'.\n- axis: An optional integer that specifies the axis along which elements are taken. By default, it is None, which flattens the array before taking elements.\n- out: An optional output array to store the result. If not provided, a new array will be created.\n- mode: An optional string that determines the behavior when an index is out of bounds. The default is 'raise', which raises an IndexError. Other possible values are 'wrap' (uses wrap-around semantics) and 'clip' (clips out-of-range indices).\n\nOutputs:\n- The function returns a new array containing the elements taken from the input array 'a' based on the specified indices and axis. If the 'out' parameter is provided, the result is stored in that array instead of creating a new one.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef take(a, indices, axis=None, out=None, mode='raise'): [MASK]\n"}
{"method_name": "inner", "full_method_name": "inner", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef inner(a, b):\n    \"\"\"\n    Returns the inner product of a and b for arrays of floating point types.\n\n    Like the generic NumPy equivalent the product sum is over the last dimension\n    of a and b. The first argument is not conjugated.\n\n    \"\"\"\n    fa = filled(a, 0)\n    fb = filled(b, 0)\n    if fa.ndim == 0:\n        fa.shape = 1,\n    if fb.ndim == 0:\n        fb.shape = 1,\n    return np.inner(fa, fb).view(MaskedArray)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The inner function calculates the inner product of two input arrays, a and b, for arrays of floating point types. The product sum is computed over the last dimension of both a and b. It's important to note that the first argument, a, is not conjugated during the calculation.\nInputs: \na: A NumPy array of floating point numbers. It can be of any shape.\nb: Another NumPy array of floating point numbers. It should have a compatible shape with 'a' for inner product calculation.\nOutputs: \nThe function returns the inner product of a and b as a NumPy MaskedArray. If the input arrays have scalar values (0-dimensional), their shapes are adjusted to 1-D before the calculation.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef inner(a, b): [MASK]\n"}
{"method_name": "asbytes", "full_method_name": "asbytes", "method_path": "../srcdata/Computation/numpy/numpy/_utils/_convertions.py", "method_code": "\ndef asbytes(s):\n    if isinstance(s, bytes):\n        return s\n    return str(s).encode('latin1')", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_check_on_fields(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    ndtype = [('a', int), ('b', float), ('c', '|S3')]\n\t    fval = _check_fill_value([-999, -12345678.9, '???'], ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fval = _check_fill_value(None, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [default_fill_value(0), default_fill_value(\n\t        0.0), asbytes(default_fill_value('0'))])\n\t    fill_val = np.array((-999, -12345678.9, '???'), dtype=ndtype)\n\t    fval = _check_fill_value(fill_val, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fill_val = np.array((-999, -12345678.9, '???'), dtype=[('A', int), ('B',\n\t        float), ('C', '|S3')])\n\t    fval = _check_fill_value(fill_val, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fill_val = np.ndarray(shape=(1,), dtype=object)\n\t    fill_val[0] = -999, -12345678.9, b'???'\n\t    fval = _check_fill_value(fill_val, object)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    ndtype = [('a', int)]\n\t    fval = _check_fill_value(-999999999, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), (-999999999,))\n\t\nTestFillingValues().test_check_on_fields()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestSaveTxt():\n\tdef test_array(self):\n\t    a = np.array([[1, 2], [3, 4]], float)\n\t    fmt = '%.18e'\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt=fmt)\n\t    c.seek(0)\n\t    assert_equal(c.readlines(), [asbytes((fmt + ' ' + fmt + '\\n') % (1, 2)),\n\t        asbytes((fmt + ' ' + fmt + '\\n') % (3, 4))])\n\t    a = np.array([[1, 2], [3, 4]], int)\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt='%d')\n\t    c.seek(0)\n\t    assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\t\nTestSaveTxt().test_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestSaveTxt():\n\tdef test_header_footer(self):\n\t    c = BytesIO()\n\t    a = np.array([(1, 2), (3, 4)], dtype=int)\n\t    test_header_footer = 'Test header / footer'\n\t    np.savetxt(c, a, fmt='%1d', header=test_header_footer)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('# ' + test_header_footer + '\\n1 2\\n3 4\\n'))\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt='%1d', footer=test_header_footer)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('1 2\\n3 4\\n# ' + test_header_footer + '\\n'))\n\t    c = BytesIO()\n\t    commentstr = '% '\n\t    np.savetxt(c, a, fmt='%1d', header=test_header_footer, comments=commentstr)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes(commentstr + test_header_footer + '\\n' +\n\t        '1 2\\n3 4\\n'))\n\t    c = BytesIO()\n\t    commentstr = '% '\n\t    np.savetxt(c, a, fmt='%1d', footer=test_header_footer, comments=commentstr)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('1 2\\n3 4\\n' + commentstr +\n\t        test_header_footer + '\\n'))\n\t\nTestSaveTxt().test_header_footer()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import copy\nimport sys\nimport gc\nimport tempfile\nimport pytest\nfrom os import path\nfrom io import BytesIO\nfrom itertools import chain\nimport pickle\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import _assert_valid_refcount\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.testing._private.utils import requires_memory\nfrom math import radians\nfrom hashlib import sha256\nimport re\nimport operator as op\n\nclass TestRegression():\n\tdef test_junk_in_string_fields_of_recarray(self):\n\t    r = np.array([[b'abc']], dtype=[('var1', '|S20')])\n\t    assert_(asbytes(r['var1'][0][0]) == b'abc')\n\t\nTestRegression().test_junk_in_string_fields_of_recarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_regression.py"}], "instruction": "Functionality: The function 'asbytes' aims to convert a given string into bytes format. It is designed to handle both cases where the input is already in bytes format and where it is a string. In the case where the input is already in bytes, it returns the input as is. If the input is a string, it converts this string to bytes using the 'latin1' encoding.\n\nInputs: \n1. s: This is the input argument that could be either a string or bytes. It is the data that needs to be converted to bytes format.\n\nOutputs:\n1. A bytes object: The function returns the input in bytes format. If the input was already in bytes format, it returns the input unchanged. If the input was a string, it encodes the string to bytes using 'latin1' encoding and returns this encoded bytes object.", "method_code_mask": "def asbytes(s): [MASK]\n"}
{"method_name": "allclose", "full_method_name": "allclose", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    This function is equivalent to `allclose` except that masked values\n    are treated as equal (default) or unequal, depending on the `masked_equal`\n    argument.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    masked_equal : bool, optional\n        Whether masked values in `a` and `b` are considered equal (True) or not\n        (False). They are considered equal by default.\n    rtol : float, optional\n        Relative tolerance. The relative difference is equal to ``rtol * b``.\n        Default is 1e-5.\n    atol : float, optional\n        Absolute tolerance. The absolute difference is equal to `atol`.\n        Default is 1e-8.\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance, False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any\n    numpy.allclose : the non-masked `allclose`.\n\n    Notes\n    -----\n    If the following equation is element-wise True, then `allclose` returns\n    True::\n\n      absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Return True if all elements of `a` and `b` are equal subject to\n    given tolerances.\n\n    Examples\n    --------\n    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n    >>> a\n    masked_array(data=[10000000000.0, 1e-07, --],\n                 mask=[False, False,  True],\n           fill_value=1e+20)\n    >>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    False\n\n    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n    >>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    True\n    >>> np.ma.allclose(a, b, masked_equal=False)\n    False\n\n    Masked values are not compared directly.\n\n    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n    >>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    True\n    >>> np.ma.allclose(a, b, masked_equal=False)\n    False\n\n    \"\"\"\n    x = masked_array(a, copy=False)\n    y = masked_array(b, copy=False)\n    if y.dtype.kind != 'm':\n        dtype = np.result_type(y, 1.0)\n        if y.dtype != dtype:\n            y = masked_array(y, dtype=dtype, copy=False)\n    m = mask_or(getmask(x), getmask(y))\n    xinf = np.isinf(masked_array(x, copy=False, mask=m)).filled(False)\n    if not np.all(xinf == filled(np.isinf(y), False)):\n        return False\n    if not np.any(xinf):\n        d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),\n            masked_equal)\n        return np.all(d)\n    if not np.all(filled(x[xinf] == y[xinf], masked_equal)):\n        return False\n    x = x[~xinf]\n    y = y[~xinf]\n    d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),\n        masked_equal)\n    return np.all(d)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_allclose(self):\n\t    a = np.random.rand(10)\n\t    b = a + np.random.rand(10) * 1e-08\n\t    assert_(allclose(a, b))\n\t    a[0] = np.inf\n\t    assert_(not allclose(a, b))\n\t    b[0] = np.inf\n\t    assert_(allclose(a, b))\n\t    a = masked_array(a)\n\t    a[-1] = masked\n\t    assert_(allclose(a, b, masked_equal=True))\n\t    assert_(not allclose(a, b, masked_equal=False))\n\t    a *= 1e-08\n\t    a[0] = 0\n\t    assert_(allclose(a, 0, masked_equal=True))\n\t    a = masked_array([np.iinfo(np.int_).min], dtype=np.int_)\n\t    assert_(allclose(a, a))\n\t\nTestMaskedArrayMethods().test_allclose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_allclose_timedelta(self):\n\t    a = np.array([[1, 2, 3, 4]], dtype='m8[ns]')\n\t    assert allclose(a, a, atol=0)\n\t    assert allclose(a, a, atol=np.timedelta64(1, 'ns'))\n\t\nTestMaskedArrayMethods().test_allclose_timedelta()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The function 'allclose' checks if two arrays are element-wise equal within a specified tolerance. It treats masked values either as equal or unequal based on the 'masked_equal' parameter. The function returns True if the arrays are equal within the given tolerances, False otherwise. It returns False if either array contains NaN.\n\nInputs: \n- a, b: These are the array_like input arrays to compare.\n- masked_equal: A boolean optional parameter. If True, masked values in 'a' and 'b' are considered equal. If False, they are considered unequal. The default is True.\n- rtol: A float optional parameter for the relative tolerance. The relative difference is equal to 'rtol * b'. The default is 1e-5.\n- atol: A float optional parameter for the absolute tolerance. The absolute difference is equal to 'atol'. The default is 1e-8.\n\nOutputs: \n- y: A boolean value. True if the two input arrays are equal within the given tolerances, False otherwise.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08): [MASK]\n"}
{"method_name": "putmask", "full_method_name": "putmask", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef putmask(a, mask, values):\n    \"\"\"\n    Changes elements of an array based on conditional and input values.\n\n    This is the masked array version of `numpy.putmask`, for details see\n    `numpy.putmask`.\n\n    See Also\n    --------\n    numpy.putmask\n\n    Notes\n    -----\n    Using a masked array as `values` will **not** transform a `ndarray` into\n    a `MaskedArray`.\n\n    Examples\n    --------\n    >>> arr = [[1, 2], [3, 4]]\n    >>> mask = [[1, 0], [0, 0]]\n    >>> x = np.ma.array(arr, mask=mask)\n    >>> np.ma.putmask(x, x < 4, 10*x)\n    >>> x\n    masked_array(\n      data=[[--, 20],\n            [30, 4]],\n      mask=[[ True, False],\n            [False, False]],\n      fill_value=999999)\n    >>> x.data\n    array([[10, 20],\n           [30,  4]])\n\n    \"\"\"\n    if not isinstance(a, MaskedArray):\n        a = a.view(MaskedArray)\n    valdata, valmask = getdata(values), getmask(values)\n    if getmask(a) is nomask:\n        if valmask is not nomask:\n            a._sharedmask = True\n            a._mask = make_mask_none(a.shape, a.dtype)\n            np.copyto(a._mask, valmask, where=mask)\n    elif a._hardmask:\n        if valmask is not nomask:\n            m = a._mask.copy()\n            np.copyto(m, valmask, where=mask)\n            a.mask |= m\n    else:\n        if valmask is nomask:\n            valmask = getmaskarray(values)\n        np.copyto(a._mask, valmask, where=mask)\n    np.copyto(a._data, valdata, where=mask)\n    return", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_putmask(self):\n\t    x = arange(6) + 1\n\t    mx = array(x, mask=[0, 0, 0, 1, 1, 1])\n\t    mask = [0, 0, 1, 0, 0, 1]\n\t    xx = x.copy()\n\t    putmask(xx, mask, 99)\n\t    assert_equal(xx, [1, 2, 99, 4, 5, 99])\n\t    mxx = mx.copy()\n\t    putmask(mxx, mask, 99)\n\t    assert_equal(mxx._data, [1, 2, 99, 4, 5, 99])\n\t    assert_equal(mxx._mask, [0, 0, 0, 1, 1, 0])\n\t    values = array([10, 20, 30, 40, 50, 60], mask=[1, 1, 1, 0, 0, 0])\n\t    xx = x.copy()\n\t    putmask(xx, mask, values)\n\t    assert_equal(xx._data, [1, 2, 30, 4, 5, 60])\n\t    assert_equal(xx._mask, [0, 0, 1, 0, 0, 0])\n\t    mxx = mx.copy()\n\t    putmask(mxx, mask, values)\n\t    assert_equal(mxx._data, [1, 2, 30, 4, 5, 60])\n\t    assert_equal(mxx._mask, [0, 0, 1, 1, 1, 0])\n\t    mxx = mx.copy()\n\t    mxx.harden_mask()\n\t    putmask(mxx, mask, values)\n\t    assert_equal(mxx, [1, 2, 30, 4, 5, 60])\n\t\nTestMaskedArrayMethods().test_putmask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The putmask function modifies elements of an array based on a specified condition and input values. It operates on masked arrays, where the mask defines which elements of the array are considered valid. The function updates the array's data where the condition (mask) is true, replacing those elements with values provided.\n\nInputs: \n- a: A numpy masked array to be modified. This could be a standard numpy array, which will be converted into a masked array internally.\n- mask: A boolean array of the same shape as 'a'. Elements of 'a' for which the mask is True will be updated.\n- values: The values to place in 'a' where the mask is True. This can be a scalar or an array of the same shape as 'a'.\n\nOutputs: \n- None: The function modifies the input array 'a' in place and does not return a value. The modification is reflected in the data and mask of the input array.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef putmask(a, mask, values): [MASK]\n"}
{"method_name": "argsort", "full_method_name": "argsort", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True,\n    fill_value=None, *, stable=None):\n    \"\"\"Function version of the eponymous method.\"\"\"\n    a = np.asanyarray(a)\n    if axis is np._NoValue:\n        axis = _deprecate_argsort_axis(a)\n    if isinstance(a, MaskedArray):\n        return a.argsort(axis=axis, kind=kind, order=order, endwith=endwith,\n            fill_value=fill_value, stable=None)\n    else:\n        return a.argsort(axis=axis, kind=kind, order=order, stable=None)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_stable_sort(self):\n\t    x = array([1, 2, 3, 1, 2, 3], dtype=np.uint8)\n\t    expected = array([0, 3, 1, 4, 2, 5])\n\t    computed = argsort(x, kind='stable')\n\t    assert_equal(computed, expected)\n\t\nTestMaskedArrayMethods().test_stable_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort_matches_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    for kwargs in [dict(), dict(endwith=True), dict(endwith=False), dict(\n\t        fill_value=2), dict(fill_value=2, endwith=True), dict(fill_value=2,\n\t        endwith=False)]:\n\t        sortedx = sort(x, **kwargs)\n\t        argsortedx = x[argsort(x, **kwargs)]\n\t        assert_equal(sortedx._data, argsortedx._data)\n\t        assert_equal(sortedx._mask, argsortedx._mask)\n\t\nTestMaskedArrayMethods().test_argsort_matches_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort(self):\n\t    a = array([1, 5, 2, 4, 3], mask=[1, 0, 0, 1, 0])\n\t    assert_equal(np.argsort(a), argsort(a))\n\t\nTestMaskedArrayMethods().test_argsort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The argsort function is designed to perform an indirect sort along the given axis using the specified kind of sort, returning an array of indices that would sort the array. The function sorts the array and then returns the indices of the original array which would have resulted in this sorted array.\n\nInputs: \n1. a (ndarray): The array to be sorted.\n2. axis (int, optional): Axis along which to sort. The default is -1, which sorts along the last axis.\n3. kind (str, optional): Sorting algorithm. Options include 'quicksort', 'mergesort', and 'heapsort'. 'stable' is also accepted which uses 'mergesort' if 'kind' is not specified. The default is None, which uses 'quicksort'.\n4. order (list, optional): When a is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified. The default is None.\n5. endwith (bool, optional): Whether missing values (if any) should be treated as the largest values (True) or smallest values (False) when sorting along with the filled values. The default is True.\n6. fill_value (scalar, optional): Value used internally for the masked values. This value is placed at the beginning (or the end if endwith is True) of the returned data. The default is None.\n7. stable (bool, optional): Whether to specify a stable sorting algorithm. If True, 'mergesort' is used. If False, 'heapsort' is used. If None, the value of 'kind' is used to decide the sorting algorithm. The default is None.\n\nOutputs: \n1. index_array (ndarray, int): An array of indices that would sort the original array 'a'. The return type is always an array of 64-bit integers.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True,\n    fill_value=None, *, stable=None): [MASK]\n"}
{"method_name": "diag", "full_method_name": "diag", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef diag(v, k=0):\n    \"\"\"\n    Extract a diagonal or construct a diagonal array.\n\n    This function is the equivalent of `numpy.diag` that takes masked\n    values into account, see `numpy.diag` for details.\n\n    See Also\n    --------\n    numpy.diag : Equivalent function for ndarrays.\n\n    Examples\n    --------\n\n    Create an array with negative values masked:\n\n    >>> import numpy as np\n    >>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])\n    >>> masked_x = np.ma.masked_array(x, mask=x < 0)\n    >>> masked_x\n    masked_array(\n      data=[[11.2, --, 18.0],\n            [0.801, --, 12.0],\n            [7.0, 33.0, --]],\n      mask=[[False,  True, False],\n            [False,  True, False],\n            [False, False,  True]],\n      fill_value=1e+20)\n\n    Isolate the main diagonal from the masked array:\n\n    >>> np.ma.diag(masked_x)\n    masked_array(data=[11.2, --, --],\n                 mask=[False,  True,  True],\n           fill_value=1e+20)\n\n    Isolate the first diagonal below the main diagonal:\n\n    >>> np.ma.diag(masked_x, -1)\n    masked_array(data=[0.801, 33.0],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    output = np.diag(v, k).view(MaskedArray)\n    if getmask(v) is not nomask:\n        output._mask = np.diag(v._mask, k)\n    return output", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMathMethods():\n\tdef test_diag(self):\n\t    x = arange(9).reshape((3, 3))\n\t    x[1, 1] = masked\n\t    out = np.diag(x)\n\t    assert_equal(out, [0, 4, 8])\n\t    out = diag(x)\n\t    assert_equal(out, [0, 4, 8])\n\t    assert_equal(out.mask, [0, 1, 0])\n\t    out = diag(out)\n\t    control = array([[0, 0, 0], [0, 4, 0], [0, 0, 8]], mask=[[0, 0, 0], [0,\n\t        1, 0], [0, 0, 0]])\n\t    assert_equal(out, control)\n\t\nTestMaskedArrayMathMethods().test_diag()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The diag function is designed to either extract a diagonal from a given array or create a diagonal array based on the input vector. It is a masked array version of numpy's diag function, which means it takes masked values into account when operating on masked arrays.\n\nInputs: \n- v: A 1-D or 2-D array-like object. If a 2-D array-like is given, the function extracts the desired diagonal from it. If a 1-D array-like is given, the function creates a 2-D array with the elements of the input vector along the diagonal.\n- k: An integer (default is 0). The k-th diagonal is used. A positive value means the diagonal is above the main diagonal, and a negative value means it is below the main diagonal.\n\nOutputs:\n- A 1-D or 2-D masked array. If the input was a 2-D array-like, the output is a 1-D masked array containing the selected diagonal. If the input was a 1-D array-like, the output is a 2-D masked array with the input vector's elements along the selected diagonal. The output array will also have masked values where the original array had masked values.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef diag(v, k=0): [MASK]\n"}
{"method_name": "requires_memory", "full_method_name": "requires_memory", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "method_code": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef requires_memory(free_bytes):\n    \"\"\"Decorator to skip a test if not enough memory is available\"\"\"\n    import pytest\n\n    def decorator(func):\n\n        @wraps(func)\n        def wrapper(*a, **kw):\n            msg = check_free_memory(free_bytes)\n            if msg is not None:\n                pytest.skip(msg)\n            try:\n                return func(*a, **kw)\n            except MemoryError:\n                pytest.xfail('MemoryError raised')\n        return wrapper\n    return decorator", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMathMethods():\n\t@requires_memory(free_bytes=2 * 10000 * 1000 * 2)\n\tdef test_mean_overflow(self):\n\t    a = masked_array(np.full((10000, 10000), 65535, dtype=np.uint16), mask=\n\t        np.zeros((10000, 10000)))\n\t    assert_equal(a.mean(), 65535.0)\n\t\nTestMaskedArrayMathMethods().test_mean_overflow()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import copy\nimport sys\nimport gc\nimport tempfile\nimport pytest\nfrom os import path\nfrom io import BytesIO\nfrom itertools import chain\nimport pickle\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import _assert_valid_refcount\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.testing._private.utils import requires_memory\nfrom math import radians\nfrom hashlib import sha256\nimport re\nimport operator as op\n\nclass TestRegression():\n\t@pytest.mark.skipif(sys.maxsize < 2 ** 31 + 1, reason='overflows 32-bit python'\n\t    )\n\t@requires_memory(free_bytes=9000000000.0)\n\tdef test_dot_big_stride(self):\n\t    int32_max = np.iinfo(np.int32).max\n\t    n = int32_max + 3\n\t    a = np.empty([n], dtype=np.float32)\n\t    b = a[::n - 1]\n\t    b[...] = 1\n\t    assert b.strides[0] > int32_max * b.dtype.itemsize\n\t    assert np.dot(b, b) == 2.0\n\t\nTestRegression().test_dot_big_stride()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_regression.py"}], "instruction": "Functionality: The requires_memory function is a decorator designed to skip a test if the system does not have enough free memory to run it. It aims to prevent tests from failing due to insufficient memory resources by checking the available memory against the specified threshold before executing the test.\n\nInputs: \n- free_bytes (int): The amount of free memory in bytes required to run the test. This argument is used to determine whether the system has enough memory to proceed with the test execution.\n\nOutputs:\n- decorator (function): The decorator function that wraps around the test function. This decorator function checks the system's free memory before executing the test. If the available free memory is less than the specified threshold, the test is skipped, and a skip message is displayed. If the memory is sufficient, the test function is executed. If a MemoryError occurs during test execution, the test is marked as xfailed.", "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef requires_memory(free_bytes): [MASK]\n"}
{"method_name": "masked_equal", "full_method_name": "masked_equal", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_equal(x, value, copy=True):\n    \"\"\"\n    Mask an array where equal to a given value.\n\n    Return a MaskedArray, masked where the data in array `x` are\n    equal to `value`. The fill_value of the returned MaskedArray\n    is set to `value`.\n\n    For floating point arrays, consider using ``masked_values(x, value)``.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n    masked_values : Mask using floating point equality.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_equal(a, 2)\n    masked_array(data=[0, 1, --, 3],\n                 mask=[False, False,  True, False],\n           fill_value=2)\n\n    \"\"\"\n    output = masked_where(equal(x, value), x, copy=copy)\n    output.fill_value = value\n    return output", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_equal_wlist(self):\n\t    x = [1, 2, 3]\n\t    mx = masked_equal(x, 3)\n\t    assert_equal(mx, x)\n\t    assert_equal(mx._mask, [0, 0, 1])\n\t    mx = masked_not_equal(x, 3)\n\t    assert_equal(mx, x)\n\t    assert_equal(mx._mask, [1, 1, 0])\n\t\nTestMaskedArrayFunctions().test_masked_equal_wlist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_equal_fill_value(self):\n\t    x = [1, 2, 3]\n\t    mx = masked_equal(x, 3)\n\t    assert_equal(mx._mask, [0, 0, 1])\n\t    assert_equal(mx.fill_value, 3)\n\t\nTestMaskedArrayFunctions().test_masked_equal_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    x[2] = masked\n\t    assert_equal(masked_where(greater(x, 2), x), masked_greater(x, 2))\n\t    assert_equal(masked_where(greater_equal(x, 2), x), masked_greater_equal\n\t        (x, 2))\n\t    assert_equal(masked_where(less(x, 2), x), masked_less(x, 2))\n\t    assert_equal(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where(equal(x, 2), x), masked_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3,\n\t        4, 5])\n\t\nTestMaskedArrayFunctions().test_masked_where_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_shape_constraint(self):\n\t    a = arange(10)\n\t    with assert_raises(IndexError):\n\t        masked_equal(1, a)\n\t    test = masked_equal(a, 1)\n\t    assert_equal(test.mask, [0, 1, 0, 0, 0, 0, 0, 0, 0, 0])\n\t\nTestMaskedArrayFunctions().test_masked_where_shape_constraint()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The masked_equal function takes an array and a value, then masks the array at positions where the array elements are equal to the given value. The function returns a masked array with the fill_value set to the specified value.\n\nInputs: \n1. x: An array-like object (e.g., list, ndarray) where the masking will be applied.\n2. value: The value to be masked in the array. This can be any type that is compatible with the array's data type.\n3. copy (optional): A boolean indicating whether to copy the input array. If True (default), the input array is copied; if False, the function attempts to return a view on the input array.\n\nOutputs:\n- A masked array object where elements equal to the 'value' parameter are masked. The fill_value of the returned masked array is set to the 'value' parameter.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_equal(x, value, copy=True): [MASK]\n"}
{"method_name": "masked_outside", "full_method_name": "masked_outside", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_outside(x, v1, v2, copy=True):\n    \"\"\"\n    Mask an array outside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` outside\n    the interval [v1,v2] (x < v1)|(x > v2).\n    The boundaries `v1` and `v2` can be given in either order.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The array `x` is prefilled with its filling value.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_outside(x, -0.3, 0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_outside(x, 0.3, -0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)\n\n    \"\"\"\n    if v2 < v1:\n        v1, v2 = v2, v1\n    xf = filled(x)\n    condition = (xf < v1) | (xf > v2)\n    return masked_where(condition, x, copy=copy)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The masked_outside function masks an array outside a given interval. It's a shortcut to the masked_where function, where the condition is True for elements in the array that fall outside the interval [v1, v2] (i.e., elements less than v1 or greater than v2). The boundaries v1 and v2 can be given in either order. The array is prefilled with its filling value before applying the mask.\n\nInputs: \n- x: The input array to be masked.\n- v1: The first boundary of the interval.\n- v2: The second boundary of the interval.\n- copy (optional, default=True): A boolean flag to determine if the input array should be copied before applying the mask. If False, the mask is applied in-place.\n\nOutputs:\n- A masked_array: The output is a masked array where elements outside the interval [v1, v2] are masked. The masked array includes the data, mask, and fill_value attributes.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_outside(x, v1, v2, copy=True): [MASK]\n"}
{"method_name": "masked_inside", "full_method_name": "masked_inside", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_inside(x, v1, v2, copy=True):\n    \"\"\"\n    Mask an array inside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` inside\n    the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`\n    can be given in either order.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The array `x` is prefilled with its filling value.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_inside(x, -0.3, 0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_inside(x, 0.3, -0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    if v2 < v1:\n        v1, v2 = v2, v1\n    xf = filled(x)\n    condition = (xf >= v1) & (xf <= v2)\n    return masked_where(condition, x, copy=copy)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The masked_inside function is designed to mask elements of an array that fall within a specified interval. It essentially applies a mask to the input array 'x' where the values are within the range [v1, v2]. This function uses a condition to determine which elements should be masked based on whether they are inside the given interval. The boundaries 'v1' and 'v2' can be specified in any order, and the function will internally adjust them to ensure the correct interval.\n\nInputs: \n- x: An array (numpy.ndarray or a list) of values from which the elements will be masked if they are within the interval [v1, v2].\n- v1: A numerical value indicating the lower boundary of the interval. It does not need to be smaller than v2.\n- v2: A numerical value indicating the upper boundary of the interval. It does not need to be larger than v1.\n- copy (optional): A boolean value indicating whether the input array 'x' should be copied before applying the mask. Default is True.\n\nOutputs:\n- A masked array of the same shape as 'x' where elements within the interval [v1, v2] are masked. The masked array will have a 'mask' attribute indicating which elements are masked. Elements within the specified interval will have their corresponding mask value set to True, indicating they are masked. The 'fill_value' attribute of the masked array will contain the default fill value for the masked elements.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_inside(x, v1, v2, copy=True): [MASK]\n"}
{"method_name": "power", "full_method_name": "power", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef power(a, b, third=None):\n    \"\"\"\n    Returns element-wise base array raised to power from second array.\n\n    This is the masked array version of `numpy.power`. For details see\n    `numpy.power`.\n\n    See Also\n    --------\n    numpy.power\n\n    Notes\n    -----\n    The *out* argument to `numpy.power` is not supported, `third` has to be\n    None.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, 2)\n    masked_array(data=[125.43999999999998, 15.784728999999999,\n                   0.6416010000000001, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> y = [-0.5, 2, 0, 17]\n    >>> masked_y = ma.masked_array(y, mask)\n    >>> masked_y\n    masked_array(data=[-0.5, 2.0, 0.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, masked_y)\n    masked_array(data=[0.2988071523335984, 15.784728999999999, 1.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n\n    \"\"\"\n    if third is not None:\n        raise MaskError('3-argument power not supported.')\n    ma = getmask(a)\n    mb = getmask(b)\n    m = mask_or(ma, mb)\n    fa = getdata(a)\n    fb = getdata(b)\n    if isinstance(a, MaskedArray):\n        basetype = type(a)\n    else:\n        basetype = MaskedArray\n    with np.errstate(divide='ignore', invalid='ignore'):\n        result = np.where(m, fa, umath.power(fa, fb)).view(basetype)\n    result._update_from(a)\n    invalid = np.logical_not(np.isfinite(result.view(ndarray)))\n    if m is not nomask:\n        if not result.ndim:\n            return masked\n        result._mask = np.logical_or(m, invalid)\n    if invalid.any():\n        if not result.ndim:\n            return masked\n        elif result._mask is nomask:\n            result._mask = invalid\n        result._data[invalid] = result.fill_value\n    return result", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_power(self):\n\t    x = -1.1\n\t    assert_almost_equal(power(x, 2.0), 1.21)\n\t    assert_(power(x, masked) is masked)\n\t    x = array([-1.1, -1.1, 1.1, 1.1, 0.0])\n\t    b = array([0.5, 2.0, 0.5, 2.0, -1.0], mask=[0, 0, 0, 0, 1])\n\t    y = power(x, b)\n\t    assert_almost_equal(y, [0, 1.21, 1.04880884817, 1.21, 0.0])\n\t    assert_equal(y._mask, [1, 0, 0, 0, 1])\n\t    b.mask = nomask\n\t    y = power(x, b)\n\t    assert_equal(y._mask, [1, 0, 0, 0, 1])\n\t    z = x ** b\n\t    assert_equal(z._mask, y._mask)\n\t    assert_almost_equal(z, y)\n\t    assert_almost_equal(z._data, y._data)\n\t    x **= b\n\t    assert_equal(x._mask, y._mask)\n\t    assert_almost_equal(x, y)\n\t    assert_almost_equal(x._data, y._data)\n\t\nTestMaskedArrayFunctions().test_power()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The power function takes two input arguments, a base array and a power array, and returns a new array with each element of the base array raised to the power of the corresponding element in the power array. This operation is performed element-wise, meaning that each element of the first array is raised to the power of the element in the same position in the second array. The function is designed to work with masked arrays, which are arrays that may have missing or invalid values marked as 'masked'. The function handles these masked values appropriately, returning a masked value in the output array for any position where either input array has a masked value.\n\nInputs: \n1. a: A masked array representing the base array. This array should contain the base values for the power operation.\n2. b: A masked array representing the power array. This array should contain the exponent values for the power operation.\n\nOutputs: \n1. The function returns a masked array. Each element of this array is the result of raising the corresponding element from the base array (a) to the power of the corresponding element from the power array (b). If any of the input arrays has a masked value at a certain position, the output array will also have a masked value at that position.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef power(a, b, third=None): [MASK]\n"}
{"method_name": "choose", "full_method_name": "choose", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef choose(indices, choices, out=None, mode='raise'):\n    \"\"\"\n    Use an index array to construct a new array from a list of choices.\n\n    Given an array of integers and a list of n choice arrays, this method\n    will create a new array that merges each of the choice arrays.  Where a\n    value in `index` is i, the new array will have the value that choices[i]\n    contains in the same place.\n\n    Parameters\n    ----------\n    indices : ndarray of ints\n        This array must contain integers in ``[0, n-1]``, where n is the\n        number of choices.\n    choices : sequence of arrays\n        Choice arrays. The index array and all of the choices should be\n        broadcastable to the same shape.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and `dtype`.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' : raise an error\n        * 'wrap' : wrap around\n        * 'clip' : clip to the range\n\n    Returns\n    -------\n    merged_array : array\n\n    See Also\n    --------\n    choose : equivalent function\n\n    Examples\n    --------\n    >>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n    >>> a = np.array([2, 1, 0])\n    >>> np.ma.choose(a, choice)\n    masked_array(data=[3, 2, 1],\n                 mask=False,\n           fill_value=999999)\n\n    \"\"\"\n\n    def fmask(x):\n        \"\"\"Returns the filled array, or True if masked.\"\"\"\n        if x is masked:\n            return True\n        return filled(x)\n\n    def nmask(x):\n        \"\"\"Returns the mask, True if ``masked``, False if ``nomask``.\"\"\"\n        if x is masked:\n            return True\n        return getmask(x)\n    c = filled(indices, 0)\n    masks = [nmask(x) for x in choices]\n    data = [fmask(x) for x in choices]\n    outputmask = np.choose(c, masks, mode=mode)\n    outputmask = make_mask(mask_or(outputmask, getmask(indices)), copy=\n        False, shrink=True)\n    d = np.choose(c, data, mode=mode, out=out).view(MaskedArray)\n    if out is not None:\n        if isinstance(out, MaskedArray):\n            out.__setmask__(outputmask)\n        return out\n    d.__setmask__(outputmask)\n    return d", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_choose(self):\n\t    choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, \n\t        32, 33]]\n\t    chosen = choose([2, 3, 1, 0], choices)\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    chosen = choose([2, 4, 1, 0], choices, mode='clip')\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    chosen = choose([2, 4, 1, 0], choices, mode='wrap')\n\t    assert_equal(chosen, array([20, 1, 12, 3]))\n\t    indices_ = array([2, 4, 1, 0], mask=[1, 0, 0, 1])\n\t    chosen = choose(indices_, choices, mode='wrap')\n\t    assert_equal(chosen, array([99, 1, 12, 99]))\n\t    assert_equal(chosen.mask, [1, 0, 0, 1])\n\t    choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 0],\n\t        [0, 0, 0, 0]])\n\t    indices_ = [2, 3, 1, 0]\n\t    chosen = choose(indices_, choices, mode='wrap')\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    assert_equal(chosen.mask, [1, 0, 0, 1])\n\t\nTestMaskedArrayFunctions().test_choose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_choose_with_out(self):\n\t    choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, \n\t        32, 33]]\n\t    store = empty(4, dtype=int)\n\t    chosen = choose([2, 3, 1, 0], choices, out=store)\n\t    assert_equal(store, array([20, 31, 12, 3]))\n\t    assert_(store is chosen)\n\t    store = empty(4, dtype=int)\n\t    indices_ = array([2, 3, 1, 0], mask=[1, 0, 0, 1])\n\t    chosen = choose(indices_, choices, mode='wrap', out=store)\n\t    assert_equal(store, array([99, 31, 12, 99]))\n\t    assert_equal(store.mask, [1, 0, 0, 1])\n\t    choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 0],\n\t        [0, 0, 0, 0]])\n\t    indices_ = [2, 3, 1, 0]\n\t    store = empty(4, dtype=int).view(ndarray)\n\t    chosen = choose(indices_, choices, mode='wrap', out=store)\n\t    assert_equal(store, array([999999, 31, 12, 999999]))\n\t\nTestMaskedArrayFunctions().test_choose_with_out()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The choose function constructs a new array by selecting elements from a list of choice arrays based on an index array. For each index in the index array, the function will take the corresponding element from the choice arrays and place it in the new array.\n\nInputs:\nindices : ndarray of ints\n    An array containing integers that represent indices in the range [0, n-1], where n is the number of choices.\nchoices : sequence of arrays\n    A sequence of arrays from which elements will be chosen. The index array and all choices should be broadcastable to the same shape.\nout : array, optional\n    An optional output array where the result can be inserted. If provided, it should have the appropriate shape and dtype.\nmode : {'raise', 'wrap', 'clip'}, optional\n    Specifies how out-of-bounds indices should be handled. 'raise' will raise an error, 'wrap' will wrap the index around, and 'clip' will clip the index to the valid range.\n\nOutputs:\nmerged_array : array\n    A new array that is constructed by merging the elements from the choice arrays based on the indices.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef choose(indices, choices, out=None, mode='raise'): [MASK]\n"}
{"method_name": "flatten_mask", "full_method_name": "flatten_mask", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef flatten_mask(mask):\n    \"\"\"\n    Returns a completely flattened version of the mask, where nested fields\n    are collapsed.\n\n    Parameters\n    ----------\n    mask : array_like\n        Input array, which will be interpreted as booleans.\n\n    Returns\n    -------\n    flattened_mask : ndarray of bools\n        The flattened input.\n\n    Examples\n    --------\n    >>> mask = np.array([0, 0, 1])\n    >>> np.ma.flatten_mask(mask)\n    array([False, False,  True])\n\n    >>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n    >>> np.ma.flatten_mask(mask)\n    array([False, False, False,  True])\n\n    >>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n    >>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)\n    >>> np.ma.flatten_mask(mask)\n    array([False, False, False, False, False,  True])\n\n    \"\"\"\n\n    def _flatmask(mask):\n        \"\"\"Flatten the mask and returns a (maybe nested) sequence of booleans.\"\"\"\n        mnames = mask.dtype.names\n        if mnames is not None:\n            return [flatten_mask(mask[name]) for name in mnames]\n        else:\n            return mask\n\n    def _flatsequence(sequence):\n        \"\"\"Generates a flattened version of the sequence.\"\"\"\n        try:\n            for element in sequence:\n                if hasattr(element, '__iter__'):\n                    yield from _flatsequence(element)\n                else:\n                    yield element\n        except TypeError:\n            yield sequence\n    mask = np.asarray(mask)\n    flattened = _flatsequence(_flatmask(mask))\n    return np.array([_ for _ in flattened], dtype=bool)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_flatten_mask(self):\n\t    mask = np.array([0, 0, 1], dtype=bool)\n\t    assert_equal(flatten_mask(mask), mask)\n\t    mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n\t    test = flatten_mask(mask)\n\t    control = np.array([0, 0, 0, 1], dtype=bool)\n\t    assert_equal(test, control)\n\t    mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n\t    data = [(0, (0, 0)), (0, (0, 1))]\n\t    mask = np.array(data, dtype=mdtype)\n\t    test = flatten_mask(mask)\n\t    control = np.array([0, 0, 0, 0, 0, 1], dtype=bool)\n\t    assert_equal(test, control)\n\t\nTestMaskedArrayFunctions().test_flatten_mask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The function 'flatten_mask' takes an input array that represents a mask and flattens it, converting any nested fields into a single, flat array of boolean values. This is particularly useful for handling complex masks with multiple levels of structure, ensuring that all elements are represented in a one-dimensional format.\n\nInputs: \n- mask : array_like\n    Input array, which will be interpreted as booleans. This can include complex arrays with nested structures.\n\nOutputs: \n- flattened_mask : ndarray of bools\n    The output is a completely flattened version of the input mask, where all nested fields have been collapsed into a single-dimensional array of boolean values.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef flatten_mask(mask): [MASK]\n"}
{"method_name": "reshape", "full_method_name": "reshape", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "method_code": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef reshape(a, new_shape, order='C'):\n    \"\"\"\n    Returns an array containing the same data with a new shape.\n\n    Refer to `MaskedArray.reshape` for full documentation.\n\n    See Also\n    --------\n    MaskedArray.reshape : equivalent function\n\n    \"\"\"\n    try:\n        return a.reshape(new_shape, order=order)\n    except AttributeError:\n        _tmp = np.asarray(a).reshape(new_shape, order=order)\n        return _tmp.view(MaskedArray)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_on_ndarray(self):\n\t    a = np.array([1, 2, 3, 4])\n\t    m = array(a, mask=False)\n\t    test = anom(a)\n\t    assert_equal(test, m.anom())\n\t    test = reshape(a, (2, 2))\n\t    assert_equal(test, m.reshape(2, 2))\n\t\nTestMaskedArrayFunctions().test_on_ndarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "instruction": "Functionality: The reshape function allows for the modification of the shape of an input array, a, without changing its data. It returns a new array with the specified new_shape while maintaining the order of elements based on the specified order ('C' for row-major, 'F' for column-major).\n\nInputs:\n    a: The input array to be reshaped. It could be a numpy array or any object that can be converted to a numpy array.\n    new_shape: A tuple or an integer specifying the new shape of the array. If an integer is provided, the array will be reshaped to a one-dimensional array of that length.\n    order: A string, either 'C' (default) or 'F', indicating the memory layout of the array. 'C' represents row-major order, and 'F' represents column-major order.\n\nOutputs:\n    A new array with the same data as the input array but with the shape specified by new_shape. The order of elements in the new array is determined by the order parameter.", "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef reshape(a, new_shape, order='C'): [MASK]\n"}
{"method_name": "masked_all_like", "full_method_name": "masked_all_like", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef masked_all_like(arr):\n    \"\"\"\n    Empty masked array with the properties of an existing array.\n\n    Return an empty masked array of the same shape and dtype as\n    the array `arr`, where all the data are masked.\n\n    Parameters\n    ----------\n    arr : ndarray\n        An array describing the shape and dtype of the required MaskedArray.\n\n    Returns\n    -------\n    a : MaskedArray\n        A masked array with all data masked.\n\n    Raises\n    ------\n    AttributeError\n        If `arr` doesn't have a shape attribute (i.e. not an ndarray)\n\n    See Also\n    --------\n    masked_all : Empty masked array with all elements masked.\n\n    Notes\n    -----\n    Unlike other masked array creation functions (e.g. `numpy.ma.zeros_like`,\n    `numpy.ma.ones_like`, `numpy.ma.full_like`), `masked_all_like` does not\n    initialize the values of the array, and may therefore be marginally\n    faster. However, the values stored in the newly allocated array are\n    arbitrary. For reproducible behavior, be sure to set each element of the\n    array before reading.\n\n    Examples\n    --------\n    >>> arr = np.zeros((2, 3), dtype=np.float32)\n    >>> arr\n    array([[0., 0., 0.],\n           [0., 0., 0.]], dtype=float32)\n    >>> np.ma.masked_all_like(arr)\n    masked_array(\n      data=[[--, --, --],\n            [--, --, --]],\n      mask=[[ True,  True,  True],\n            [ True,  True,  True]],\n      fill_value=np.float64(1e+20),\n      dtype=float32)\n\n    The dtype of the masked array matches the dtype of `arr`.\n\n    >>> arr.dtype\n    dtype('float32')\n    >>> np.ma.masked_all_like(arr).dtype\n    dtype('float32')\n\n    \"\"\"\n    a = np.empty_like(arr).view(MaskedArray)\n    a._mask = np.ones(a.shape, dtype=make_mask_descr(a.dtype))\n    return a", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_like(self):\n\t    base = array([1, 2], dtype=float)\n\t    test = masked_all_like(base)\n\t    control = array([1, 1], mask=[1, 1], dtype=float)\n\t    assert_equal(test, control)\n\t    dt = np.dtype({'names': ['a', 'b'], 'formats': ['f', 'f']})\n\t    base = array([(0, 0), (0, 0)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    test = masked_all_like(base)\n\t    control = array([(10, 10), (10, 10)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    assert_equal(test, control)\n\t    dt = np.dtype([('a', 'f'), ('b', [('ba', 'f'), ('bb', 'f')])])\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    test = masked_all_like(control)\n\t    assert_equal(test, control)\n\t\nTestGeneric().test_masked_all_like()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: masked_all_like function creates an empty masked array with the same shape and dtype as the input array, where all the data are masked.\n\nInputs: \n    arr: ndarray\n        An existing array that describes the shape and data type (dtype) of the required masked array.\n\nOutputs: \n    a: MaskedArray\n        A new masked array with the same shape and dtype as the input array 'arr', where all elements are masked. The values of the array are not initialized and are arbitrary, which allows for potentially faster performance compared to functions that initialize values.\n\nRaises:\n    AttributeError: If the input 'arr' does not have a shape attribute, indicating it is not an ndarray.\n\nSee Also:\n    masked_all: Creates an empty masked array with all elements masked, but without the shape or dtype requirement based on an existing array.\n\nNotes:\n    The function does not initialize the values of the masked array. For reproducible behavior, each element of the array should be explicitly set before reading.\n\nExamples:\n    Input array:\n        arr = np.zeros((2, 3), dtype=np.float32)\n    Output masked array:\n        masked_array(\n          data=[[--, --, --],\n                [--, --, --]],\n          mask=[[ True,  True,  True],\n                [ True,  True,  True]],\n          fill_value=np.float64(1e+20),\n          dtype=float32)\n\n    The dtype of the masked array matches the dtype of 'arr'.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef masked_all_like(arr): [MASK]\n"}
{"method_name": "flatnotmasked_contiguous", "full_method_name": "flatnotmasked_contiguous", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef flatnotmasked_contiguous(a):\n    \"\"\"\n    Find contiguous unmasked data in a masked array.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n\n    Returns\n    -------\n    slice_list : list\n        A sorted sequence of `slice` objects (start index, end index).\n\n        .. versionchanged:: 1.15.0\n            Now returns an empty list instead of None for a fully masked array\n\n    See Also\n    --------\n    flatnotmasked_edges, notmasked_contiguous, notmasked_edges\n    clump_masked, clump_unmasked\n\n    Notes\n    -----\n    Only accepts 2-D arrays at most.\n\n    Examples\n    --------\n    >>> a = np.ma.arange(10)\n    >>> np.ma.flatnotmasked_contiguous(a)\n    [slice(0, 10, None)]\n\n    >>> mask = (a < 3) | (a > 8) | (a == 5)\n    >>> a[mask] = np.ma.masked\n    >>> np.array(a[~a.mask])\n    array([3, 4, 6, 7, 8])\n\n    >>> np.ma.flatnotmasked_contiguous(a)\n    [slice(3, 5, None), slice(6, 9, None)]\n    >>> a[:] = np.ma.masked\n    >>> np.ma.flatnotmasked_contiguous(a)\n    []\n\n    \"\"\"\n    m = getmask(a)\n    if m is nomask:\n        return [slice(0, a.size)]\n    i = 0\n    result = []\n    for k, g in itertools.groupby(m.ravel()):\n        n = len(list(g))\n        if not k:\n            result.append(slice(i, i + n))\n        i += n\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_flatnotmasked_contiguous(self):\n\t    a = arange(10)\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [slice(0, a.size)])\n\t    a.mask = np.zeros(10, dtype=bool)\n\t    assert_equal(test, [slice(0, a.size)])\n\t    a[(a < 3) | (a > 8) | (a == 5)] = masked\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [slice(3, 5), slice(6, 9)])\n\t    a[:] = masked\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [])\n\t\nTestGeneric().test_flatnotmasked_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The function flatnotmasked_contiguous is designed to identify and return the slices representing contiguous segments of unmasked data from a given masked array. It processes the array to find sequences of elements that are not masked and returns them as a list of slice objects, each indicating the start and end indices of an unmasked segment.\n\nInputs: \n- a : array_like\n  The input array from which contiguous unmasked data segments are to be found. This array is expected to be a masked array, typically created using numpy's masked array functionality.\n\nOutputs: \n- slice_list : list\n  A list of slice objects, each representing a contiguous segment of unmasked data in the input array. The list is sorted and will be empty if the input array is fully masked.\n\nNotes:\n- The function only accepts arrays of at most 2 dimensions.\n- For a fully masked array, the function returns an empty list instead of None.\n\nExample usage is provided in the function's docstring.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef flatnotmasked_contiguous(a): [MASK]\n"}
{"method_name": "average", "full_method_name": "average", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef average(a, axis=None, weights=None, returned=False, *, keepdims=np._NoValue\n    ):\n    \"\"\"\n    Return the weighted average of array over the given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Data to be averaged.\n        Masked entries are not taken into account in the computation.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to average `a`.  The default,\n        `axis=None`, will average over all of the elements of the input array.\n        If axis is a tuple of ints, averaging is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The array of weights must be the same shape as `a` if no axis is\n        specified, otherwise the weights must have dimensions and shape\n        consistent with `a` along the specified axis.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n        The calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        where the sum is over all included elements.\n        The only constraint on the values of `weights` is that `sum(weights)`\n        must not be 0.\n    returned : bool, optional\n        Flag indicating whether a tuple ``(result, sum of weights)``\n        should be returned as output (True), or just the result (False).\n        Default is False.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n        *Note:* `keepdims` will not work with instances of `numpy.matrix`\n        or other classes whose methods do not support `keepdims`.\n\n        .. versionadded:: 1.23.0\n\n    Returns\n    -------\n    average, [sum_of_weights] : (tuple of) scalar or MaskedArray\n        The average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `np.float64`\n        if `a` is of integer type and floats smaller than `float64`, or the\n        input data-type, otherwise. If returned, `sum_of_weights` is always\n        `float64`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When `weights` does not have the same shape as `a`, and `axis=None`.\n    ValueError\n        When `weights` does not have dimensions and shape consistent with `a`\n        along specified `axis`.\n\n    Examples\n    --------\n    >>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n    >>> np.ma.average(a, weights=[3, 1, 0, 0])\n    1.25\n\n    >>> x = np.ma.arange(6.).reshape(3, 2)\n    >>> x\n    masked_array(\n      data=[[0., 1.],\n            [2., 3.],\n            [4., 5.]],\n      mask=False,\n      fill_value=1e+20)\n    >>> data = np.arange(8).reshape((2, 2, 2))\n    >>> data\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.ma.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])\n    masked_array(data=[3.4, 4.4],\n             mask=[False, False],\n       fill_value=1e+20)\n    >>> np.ma.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Shape of weights must be consistent\n    with shape of a along specified axis.\n\n    >>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n    ...                                 returned=True)\n    >>> avg\n    masked_array(data=[2.6666666666666665, 3.6666666666666665],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    With ``keepdims=True``, the following result has shape (3, 1).\n\n    >>> np.ma.average(x, axis=1, keepdims=True)\n    masked_array(\n      data=[[0.5],\n            [2.5],\n            [4.5]],\n      mask=False,\n      fill_value=1e+20)\n    \"\"\"\n    a = asarray(a)\n    m = getmask(a)\n    if axis is not None:\n        axis = normalize_axis_tuple(axis, a.ndim, argname='axis')\n    if keepdims is np._NoValue:\n        keepdims_kw = {}\n    else:\n        keepdims_kw = {'keepdims': keepdims}\n    if weights is None:\n        avg = a.mean(axis, **keepdims_kw)\n        scl = avg.dtype.type(a.count(axis))\n    else:\n        wgt = asarray(weights)\n        if issubclass(a.dtype.type, (np.integer, np.bool)):\n            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')\n        else:\n            result_dtype = np.result_type(a.dtype, wgt.dtype)\n        if a.shape != wgt.shape:\n            if axis is None:\n                raise TypeError(\n                    'Axis must be specified when shapes of a and weights differ.'\n                    )\n            if wgt.shape != tuple(a.shape[ax] for ax in axis):\n                raise ValueError(\n                    'Shape of weights must be consistent with shape of a along specified axis.'\n                    )\n            wgt = wgt.transpose(np.argsort(axis))\n            wgt = wgt.reshape(tuple(s if ax in axis else 1 for ax, s in\n                enumerate(a.shape)))\n        if m is not nomask:\n            wgt = wgt * ~a.mask\n            wgt.mask |= a.mask\n        scl = wgt.sum(axis=axis, dtype=result_dtype, **keepdims_kw)\n        avg = np.multiply(a, wgt, dtype=result_dtype).sum(axis, **keepdims_kw\n            ) / scl\n    if returned:\n        if scl.shape != avg.shape:\n            scl = np.broadcast_to(scl, avg.shape).copy()\n        return avg, scl\n    else:\n        return avg", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage1(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[True, False, False, False])\n\t    assert_equal(2.0, average(ott, axis=0))\n\t    assert_equal(2.0, average(ott, weights=[1.0, 1.0, 2.0, 1.0]))\n\t    result, wts = average(ott, weights=[1.0, 1.0, 2.0, 1.0], returned=True)\n\t    assert_equal(2.0, result)\n\t    assert_(wts == 4.0)\n\t    ott[:] = masked\n\t    assert_equal(average(ott, axis=0).mask, [True])\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[True, False, False, False])\n\t    ott = ott.reshape(2, 2)\n\t    ott[:, 1] = masked\n\t    assert_equal(average(ott, axis=0), [2.0, 0.0])\n\t    assert_equal(average(ott, axis=1).mask[0], [True])\n\t    assert_equal([2.0, 0.0], average(ott, axis=0))\n\t    result, wts = average(ott, axis=0, returned=True)\n\t    assert_equal(wts, [1.0, 0.0])\n\t\nTestAverage().test_testAverage1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage2(self):\n\t    w1 = [0, 1, 1, 1, 1, 0]\n\t    w2 = [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1]]\n\t    x = arange(6, dtype=np.float64)\n\t    assert_equal(average(x, axis=0), 2.5)\n\t    assert_equal(average(x, axis=0, weights=w1), 2.5)\n\t    y = array([arange(6, dtype=np.float64), 2.0 * arange(6)])\n\t    assert_equal(average(y, None), np.add.reduce(np.arange(6)) * 3.0 / 12.0)\n\t    assert_equal(average(y, axis=0), np.arange(6) * 3.0 / 2.0)\n\t    assert_equal(average(y, axis=1), [average(x, axis=0), average(x, axis=0\n\t        ) * 2.0])\n\t    assert_equal(average(y, None, weights=w2), 20.0 / 6.0)\n\t    assert_equal(average(y, axis=0, weights=w2), [0.0, 1.0, 2.0, 3.0, 4.0, \n\t        10.0])\n\t    assert_equal(average(y, axis=1), [average(x, axis=0), average(x, axis=0\n\t        ) * 2.0])\n\t    m1 = zeros(6)\n\t    m2 = [0, 0, 1, 1, 0, 0]\n\t    m3 = [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]]\n\t    m4 = ones(6)\n\t    m5 = [0, 1, 1, 1, 1, 1]\n\t    assert_equal(average(masked_array(x, m1), axis=0), 2.5)\n\t    assert_equal(average(masked_array(x, m2), axis=0), 2.5)\n\t    assert_equal(average(masked_array(x, m4), axis=0).mask, [True])\n\t    assert_equal(average(masked_array(x, m5), axis=0), 0.0)\n\t    assert_equal(count(average(masked_array(x, m4), axis=0)), 0)\n\t    z = masked_array(y, m3)\n\t    assert_equal(average(z, None), 20.0 / 6.0)\n\t    assert_equal(average(z, axis=0), [0.0, 1.0, 99.0, 99.0, 4.0, 7.5])\n\t    assert_equal(average(z, axis=1), [2.5, 5.0])\n\t    assert_equal(average(z, axis=0, weights=w2), [0.0, 1.0, 99.0, 99.0, 4.0,\n\t        10.0])\n\t\nTestAverage().test_testAverage2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage3(self):\n\t    a = arange(6)\n\t    b = arange(6) * 3\n\t    r1, w1 = average([[a, b], [b, a]], axis=1, returned=True)\n\t    assert_equal(shape(r1), shape(w1))\n\t    assert_equal(r1.shape, w1.shape)\n\t    r2, w2 = average(ones((2, 2, 3)), axis=0, weights=[3, 1], returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), weights=ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    a2d = array([[1, 2], [0, 4]], float)\n\t    a2dm = masked_array(a2d, [[False, False], [True, False]])\n\t    a2da = average(a2d, axis=0)\n\t    assert_equal(a2da, [0.5, 3.0])\n\t    a2dma = average(a2dm, axis=0)\n\t    assert_equal(a2dma, [1.0, 3.0])\n\t    a2dma = average(a2dm, axis=None)\n\t    assert_equal(a2dma, 7.0 / 3.0)\n\t    a2dma = average(a2dm, axis=1)\n\t    assert_equal(a2dma, [1.5, 4.0])\n\t\nTestAverage().test_testAverage3()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_onintegers_with_mask(self):\n\t    a = average(array([1, 2]))\n\t    assert_equal(a, 1.5)\n\t    a = average(array([1, 2, 3, 4], mask=[False, False, True, True]))\n\t    assert_equal(a, 1.5)\n\t\nTestAverage().test_onintegers_with_mask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_complex(self):\n\t    mask = np.array([[0, 0, 0, 1, 0], [0, 1, 0, 0, 0]], dtype=bool)\n\t    a = masked_array([[0, 1 + 2.0j, 3 + 4.0j, 5 + 6.0j, 7 + 8.0j], [9.0j, 0 +\n\t        1.0j, 2 + 3.0j, 4 + 5.0j, 7 + 7.0j]], mask=mask)\n\t    av = average(a)\n\t    expected = np.average(a.compressed())\n\t    assert_almost_equal(av.real, expected.real)\n\t    assert_almost_equal(av.imag, expected.imag)\n\t    av0 = average(a, axis=0)\n\t    expected0 = average(a.real, axis=0) + average(a.imag, axis=0) * 1.0j\n\t    assert_almost_equal(av0.real, expected0.real)\n\t    assert_almost_equal(av0.imag, expected0.imag)\n\t    av1 = average(a, axis=1)\n\t    expected1 = average(a.real, axis=1) + average(a.imag, axis=1) * 1.0j\n\t    assert_almost_equal(av1.real, expected1.real)\n\t    assert_almost_equal(av1.imag, expected1.imag)\n\t    wts = np.array([[0.5, 1.0, 2.0, 1.0, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n\t    wav = average(a, weights=wts)\n\t    expected = np.average(a.compressed(), weights=wts[~mask])\n\t    assert_almost_equal(wav.real, expected.real)\n\t    assert_almost_equal(wav.imag, expected.imag)\n\t    wav0 = average(a, weights=wts, axis=0)\n\t    expected0 = average(a.real, weights=wts, axis=0) + average(a.imag,\n\t        weights=wts, axis=0) * 1.0j\n\t    assert_almost_equal(wav0.real, expected0.real)\n\t    assert_almost_equal(wav0.imag, expected0.imag)\n\t    wav1 = average(a, weights=wts, axis=1)\n\t    expected1 = average(a.real, weights=wts, axis=1) + average(a.imag,\n\t        weights=wts, axis=1) * 1.0j\n\t    assert_almost_equal(wav1.real, expected1.real)\n\t    assert_almost_equal(wav1.imag, expected1.imag)\n\t\nTestAverage().test_complex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: This function calculates the weighted average of array elements over the given axis. It supports multiple dimensions, masked arrays, and custom weights for each element.\n\nInputs:\n1. a: array_like - The data to be averaged. Masked entries are not considered in the computation.\n2. axis: None or int or tuple of ints (optional) - Axis or axes along which to average the data. The default, axis=None, averages over all elements.\n3. weights: array_like (optional) - An array of weights associated with the values in a. The shape of the weights must match the shape of a along the specified axis.\n4. returned: bool (optional) - If True, returns a tuple containing the average and the sum of the weights. If False, returns only the average.\n5. keepdims: bool (optional) - If True, reduced axes are left in the result as dimensions with size one, allowing the result to broadcast correctly against the original array.\n\nOutputs:\n1. average: scalar or MaskedArray - The average of the array elements along the specified axis.\n2. sum_of_weights: scalar (optional) - The sum of the weights. This is only returned if the 'returned' parameter is set to True.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef average(a, axis=None, weights=None, returned=False, *, keepdims=np._NoValue\n    ): [MASK]\n"}
{"method_name": "notmasked_edges", "full_method_name": "notmasked_edges", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef notmasked_edges(a, axis=None):\n    \"\"\"\n    Find the indices of the first and last unmasked values along an axis.\n\n    If all values are masked, return None.  Otherwise, return a list\n    of two tuples, corresponding to the indices of the first and last\n    unmasked values respectively.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    axis : int, optional\n        Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array.\n\n    Returns\n    -------\n    edges : ndarray or list\n        An array of start and end indexes if there are any masked data in\n        the array. If there are no masked data in the array, `edges` is a\n        list of the first and last index.\n\n    See Also\n    --------\n    flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous\n    clump_masked, clump_unmasked\n\n    Examples\n    --------\n    >>> a = np.arange(9).reshape((3, 3))\n    >>> m = np.zeros_like(a)\n    >>> m[1:, 1:] = 1\n\n    >>> am = np.ma.array(a, mask=m)\n    >>> np.array(am[~am.mask])\n    array([0, 1, 2, 3, 6])\n\n    >>> np.ma.notmasked_edges(am)\n    array([0, 6])\n\n    \"\"\"\n    a = asarray(a)\n    if axis is None or a.ndim == 1:\n        return flatnotmasked_edges(a)\n    m = getmaskarray(a)\n    idx = array(np.indices(a.shape), mask=np.asarray([m] * a.ndim))\n    return [tuple([idx[i].min(axis).compressed() for i in range(a.ndim)]),\n        tuple([idx[i].max(axis).compressed() for i in range(a.ndim)])]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNotMasked():\n\tdef test_edges(self):\n\t    data = masked_array(np.arange(25).reshape(5, 5), mask=[[0, 0, 1, 0, 0],\n\t        [0, 0, 0, 1, 1], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]])\n\t    test = notmasked_edges(data, None)\n\t    assert_equal(test, [0, 24])\n\t    test = notmasked_edges(data, 0)\n\t    assert_equal(test[0], [(0, 0, 1, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(3, 3, 3, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data, 1)\n\t    assert_equal(test[0], [(0, 1, 2, 3, 4), (0, 0, 2, 0, 3)])\n\t    assert_equal(test[1], [(0, 1, 2, 3, 4), (4, 2, 4, 4, 4)])\n\t    test = notmasked_edges(data.data, None)\n\t    assert_equal(test, [0, 24])\n\t    test = notmasked_edges(data.data, 0)\n\t    assert_equal(test[0], [(0, 0, 0, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(4, 4, 4, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data.data, -1)\n\t    assert_equal(test[0], [(0, 1, 2, 3, 4), (0, 0, 0, 0, 0)])\n\t    assert_equal(test[1], [(0, 1, 2, 3, 4), (4, 4, 4, 4, 4)])\n\t    data[-2] = masked\n\t    test = notmasked_edges(data, 0)\n\t    assert_equal(test[0], [(0, 0, 1, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(1, 1, 2, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data, -1)\n\t    assert_equal(test[0], [(0, 1, 2, 4), (0, 0, 2, 3)])\n\t    assert_equal(test[1], [(0, 1, 2, 4), (4, 2, 4, 4)])\n\t\nTestNotMasked().test_edges()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The notmasked_edges function is designed to find the indices of the first and last unmasked values along a specified axis in a masked array. If all values are masked, it returns None. Otherwise, it returns a list containing two tuples, each representing the indices of the first and last unmasked values, respectively.\n\nInputs: \n1. a : array_like\n   The input array which can be an array-like object, such as a list or a numpy array.\n\n2. axis : int, optional\n   The axis along which the operation will be performed. If None (default), the function applies to a flattened version of the array.\n\nOutputs: \n1. edges : ndarray or list\n   An array or list containing the start and end indexes of the unmasked data if there are any masked data in the array. If there are no masked data in the array, 'edges' is a list of the first and last index.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef notmasked_edges(a, axis=None): [MASK]\n"}
{"method_name": "notmasked_contiguous", "full_method_name": "notmasked_contiguous", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef notmasked_contiguous(a, axis=None):\n    \"\"\"\n    Find contiguous unmasked data in a masked array along the given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    axis : int, optional\n        Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array, and this\n        is the same as `flatnotmasked_contiguous`.\n\n    Returns\n    -------\n    endpoints : list\n        A list of slices (start and end indexes) of unmasked indexes\n        in the array.\n\n        If the input is 2d and axis is specified, the result is a list of lists.\n\n    See Also\n    --------\n    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\n    clump_masked, clump_unmasked\n\n    Notes\n    -----\n    Only accepts 2-D arrays at most.\n\n    Examples\n    --------\n    >>> a = np.arange(12).reshape((3, 4))\n    >>> mask = np.zeros_like(a)\n    >>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n    >>> ma = np.ma.array(a, mask=mask)\n    >>> ma\n    masked_array(\n      data=[[0, --, 2, 3],\n            [--, --, --, 7],\n            [8, --, --, 11]],\n      mask=[[False,  True, False, False],\n            [ True,  True,  True, False],\n            [False,  True,  True, False]],\n      fill_value=999999)\n    >>> np.array(ma[~ma.mask])\n    array([ 0,  2,  3,  7, 8, 11])\n\n    >>> np.ma.notmasked_contiguous(ma)\n    [slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n    >>> np.ma.notmasked_contiguous(ma, axis=0)\n    [[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n    >>> np.ma.notmasked_contiguous(ma, axis=1)\n    [[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]\n\n    \"\"\"\n    a = asarray(a)\n    nd = a.ndim\n    if nd > 2:\n        raise NotImplementedError('Currently limited to at most 2D array.')\n    if axis is None or nd == 1:\n        return flatnotmasked_contiguous(a)\n    result = []\n    other = (axis + 1) % 2\n    idx = [0, 0]\n    idx[axis] = slice(None, None)\n    for i in range(a.shape[other]):\n        idx[other] = i\n        result.append(flatnotmasked_contiguous(a[tuple(idx)]))\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNotMasked():\n\tdef test_contiguous(self):\n\t    a = masked_array(np.arange(24).reshape(3, 8), mask=[[0, 0, 0, 0, 1, 1, \n\t        1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0]])\n\t    tmp = notmasked_contiguous(a, None)\n\t    assert_equal(tmp, [slice(0, 4, None), slice(16, 22, None), slice(23, 24,\n\t        None)])\n\t    tmp = notmasked_contiguous(a, 0)\n\t    assert_equal(tmp, [[slice(0, 1, None), slice(2, 3, None)], [slice(0, 1,\n\t        None), slice(2, 3, None)], [slice(0, 1, None), slice(2, 3, None)],\n\t        [slice(0, 1, None), slice(2, 3, None)], [slice(2, 3, None)], [slice\n\t        (2, 3, None)], [], [slice(2, 3, None)]])\n\t    tmp = notmasked_contiguous(a, 1)\n\t    assert_equal(tmp, [[slice(0, 4, None)], [], [slice(0, 6, None), slice(7,\n\t        8, None)]])\n\t\nTestNotMasked().test_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: Identify contiguous unmasked data segments in a masked array along a given axis.\nInputs: \n    a : array_like\n        The input masked array.\n    axis : int, optional\n        The axis along which the operation should be performed. If None, the array is flattened before processing.\nOutputs: \n    endpoints : list\n        A list of slices representing the start and end indexes of unmasked data segments in the array. For a 2D array with a specified axis, it returns a list of lists.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef notmasked_contiguous(a, axis=None): [MASK]\n"}
{"method_name": "compress_nd", "full_method_name": "compress_nd", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef compress_nd(x, axis=None):\n    \"\"\"Suppress slices from multiple dimensions which contain masked values.\n\n    Parameters\n    ----------\n    x : array_like, MaskedArray\n        The array to operate on. If not a MaskedArray instance (or if no array\n        elements are masked), `x` is interpreted as a MaskedArray with `mask`\n        set to `nomask`.\n    axis : tuple of ints or int, optional\n        Which dimensions to suppress slices from can be configured with this\n        parameter.\n        - If axis is a tuple of ints, those are the axes to suppress slices from.\n        - If axis is an int, then that is the only axis to suppress slices from.\n        - If axis is None, all axis are selected.\n\n    Returns\n    -------\n    compress_array : ndarray\n        The compressed array.\n\n    Examples\n    --------\n    >>> arr = [[1, 2], [3, 4]]\n    >>> mask = [[0, 1], [0, 0]]\n    >>> x = np.ma.array(arr, mask=mask)\n    >>> np.ma.compress_nd(x, axis=0)\n    array([[3, 4]])\n    >>> np.ma.compress_nd(x, axis=1)\n    array([[1],\n           [3]])\n    >>> np.ma.compress_nd(x)\n    array([[3]])\n\n    \"\"\"\n    x = asarray(x)\n    m = getmask(x)\n    if axis is None:\n        axis = tuple(range(x.ndim))\n    else:\n        axis = normalize_axis_tuple(axis, x.ndim)\n    if m is nomask or not m.any():\n        return x._data\n    if m.all():\n        return nxarray([])\n    data = x._data\n    for ax in axis:\n        axes = tuple(list(range(ax)) + list(range(ax + 1, x.ndim)))\n        data = data[(slice(None),) * ax + (~m.any(axis=axes),)]\n    return data", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_compress_nd(self):\n\t    x = np.array(list(range(3 * 4 * 5))).reshape(3, 4, 5)\n\t    m = np.zeros((3, 4, 5)).astype(bool)\n\t    m[1, 1, 1] = True\n\t    x = array(x, mask=m)\n\t    a = compress_nd(x)\n\t    assert_equal(a, [[[0, 2, 3, 4], [10, 12, 13, 14], [15, 17, 18, 19]], [[\n\t        40, 42, 43, 44], [50, 52, 53, 54], [55, 57, 58, 59]]])\n\t    a = compress_nd(x, 0)\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14\n\t        ], [15, 16, 17, 18, 19]], [[40, 41, 42, 43, 44], [45, 46, 47, 48, \n\t        49], [50, 51, 52, 53, 54], [55, 56, 57, 58, 59]]])\n\t    a = compress_nd(x, 1)\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [10, 11, 12, 13, 14], [15, 16, 17, \n\t        18, 19]], [[20, 21, 22, 23, 24], [30, 31, 32, 33, 34], [35, 36, 37,\n\t        38, 39]], [[40, 41, 42, 43, 44], [50, 51, 52, 53, 54], [55, 56, 57,\n\t        58, 59]]])\n\t    a2 = compress_nd(x, (1,))\n\t    a3 = compress_nd(x, -2)\n\t    a4 = compress_nd(x, (-2,))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, 2)\n\t    assert_equal(a, [[[0, 2, 3, 4], [5, 7, 8, 9], [10, 12, 13, 14], [15, 17,\n\t        18, 19]], [[20, 22, 23, 24], [25, 27, 28, 29], [30, 32, 33, 34], [\n\t        35, 37, 38, 39]], [[40, 42, 43, 44], [45, 47, 48, 49], [50, 52, 53,\n\t        54], [55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (2,))\n\t    a3 = compress_nd(x, -1)\n\t    a4 = compress_nd(x, (-1,))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, (0, 1))\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [10, 11, 12, 13, 14], [15, 16, 17, \n\t        18, 19]], [[40, 41, 42, 43, 44], [50, 51, 52, 53, 54], [55, 56, 57,\n\t        58, 59]]])\n\t    a2 = compress_nd(x, (0, -2))\n\t    assert_equal(a, a2)\n\t    a = compress_nd(x, (1, 2))\n\t    assert_equal(a, [[[0, 2, 3, 4], [10, 12, 13, 14], [15, 17, 18, 19]], [[\n\t        20, 22, 23, 24], [30, 32, 33, 34], [35, 37, 38, 39]], [[40, 42, 43,\n\t        44], [50, 52, 53, 54], [55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (-2, 2))\n\t    a3 = compress_nd(x, (1, -1))\n\t    a4 = compress_nd(x, (-2, -1))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, (0, 2))\n\t    assert_equal(a, [[[0, 2, 3, 4], [5, 7, 8, 9], [10, 12, 13, 14], [15, 17,\n\t        18, 19]], [[40, 42, 43, 44], [45, 47, 48, 49], [50, 52, 53, 54], [\n\t        55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (0, -1))\n\t    assert_equal(a, a2)\n\t\nTestCompressFunctions().test_compress_nd()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The function compress_nd is designed to remove slices from an n-dimensional masked array (MaskedArray) along specified axes where all elements are masked. This operation effectively compresses the array by removing dimensions that contain only masked values.\n\nInputs: \n- x: An array-like object or a MaskedArray. If it is not a MaskedArray, it is treated as one with a 'nomask' attribute.\n- axis: Optional. Specifies the axes along which to compress the array. It can be:\n  - A tuple of integers, indicating the specific axes to compress.\n  - A single integer, specifying a single axis.\n  - None, indicating that compression should occur along all axes.\n\nOutputs:\n- compress_array: An ndarray representing the compressed version of the input array. Slices along the specified axes that contain masked values are removed. If all elements in the array are masked, an empty array is returned.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef compress_nd(x, axis=None): [MASK]\n"}
{"method_name": "compress_rowcols", "full_method_name": "compress_rowcols", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef compress_rowcols(x, axis=None):\n    \"\"\"\n    Suppress the rows and/or columns of a 2-D array that contain\n    masked values.\n\n    The suppression behavior is selected with the `axis` parameter.\n\n    - If axis is None, both rows and columns are suppressed.\n    - If axis is 0, only rows are suppressed.\n    - If axis is 1 or -1, only columns are suppressed.\n\n    Parameters\n    ----------\n    x : array_like, MaskedArray\n        The array to operate on.  If not a MaskedArray instance (or if no array\n        elements are masked), `x` is interpreted as a MaskedArray with\n        `mask` set to `nomask`. Must be a 2D array.\n    axis : int, optional\n        Axis along which to perform the operation. Default is None.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        The compressed array.\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n    ...                                                   [1, 0, 0],\n    ...                                                   [0, 0, 0]])\n    >>> x\n    masked_array(\n      data=[[--, 1, 2],\n            [--, 4, 5],\n            [6, 7, 8]],\n      mask=[[ True, False, False],\n            [ True, False, False],\n            [False, False, False]],\n      fill_value=999999)\n\n    >>> np.ma.compress_rowcols(x)\n    array([[7, 8]])\n    >>> np.ma.compress_rowcols(x, 0)\n    array([[6, 7, 8]])\n    >>> np.ma.compress_rowcols(x, 1)\n    array([[1, 2],\n           [4, 5],\n           [7, 8]])\n\n    \"\"\"\n    if asarray(x).ndim != 2:\n        raise NotImplementedError('compress_rowcols works for 2D arrays only.')\n    return compress_nd(x, axis=axis)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_compress_rowcols(self):\n\t    x = array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0], [0, 0, 0], [0, 0,\n\t        0]])\n\t    assert_equal(compress_rowcols(x), [[4, 5], [7, 8]])\n\t    assert_equal(compress_rowcols(x, 0), [[3, 4, 5], [6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[1, 2], [4, 5], [7, 8]])\n\t    x = array(x._data, mask=[[0, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(compress_rowcols(x), [[0, 2], [6, 8]])\n\t    assert_equal(compress_rowcols(x, 0), [[0, 1, 2], [6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[0, 2], [3, 5], [6, 8]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(compress_rowcols(x), [[8]])\n\t    assert_equal(compress_rowcols(x, 0), [[6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[2], [5], [8]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\t    assert_equal(compress_rowcols(x).size, 0)\n\t    assert_equal(compress_rowcols(x, 0).size, 0)\n\t    assert_equal(compress_rowcols(x, 1).size, 0)\n\t\nTestCompressFunctions().test_compress_rowcols()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The compress_rowcols function is designed to suppress rows and/or columns of a 2-D array that contain masked values. The behavior of suppression can be controlled through the 'axis' parameter: None for both rows and columns, 0 for only rows, and 1 or -1 for only columns.\n\nInputs: \n1. x: array_like, MaskedArray. This is the array to operate on. If not a MaskedArray instance (or if no array elements are masked), 'x' is interpreted as a MaskedArray with 'mask' set to 'nomask'. The input must be a 2D array.\n2. axis: int, optional. This parameter decides along which axis the operation should be performed. The default value is None.\n\nOutputs: \n1. compressed_array: ndarray. This is the array resulting from the compression of rows and/or columns based on the presence of masked values, according to the 'axis' parameter.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef compress_rowcols(x, axis=None): [MASK]\n"}
{"method_name": "mask_rowcols", "full_method_name": "mask_rowcols", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef mask_rowcols(a, axis=None):\n    \"\"\"\n    Mask rows and/or columns of a 2D array that contain masked values.\n\n    Mask whole rows and/or columns of a 2D array that contain\n    masked values.  The masking behavior is selected using the\n    `axis` parameter.\n\n      - If `axis` is None, rows *and* columns are masked.\n      - If `axis` is 0, only rows are masked.\n      - If `axis` is 1 or -1, only columns are masked.\n\n    Parameters\n    ----------\n    a : array_like, MaskedArray\n        The array to mask.  If not a MaskedArray instance (or if no array\n        elements are masked), the result is a MaskedArray with `mask` set\n        to `nomask` (False). Must be a 2D array.\n    axis : int, optional\n        Axis along which to perform the operation. If None, applies to a\n        flattened version of the array.\n\n    Returns\n    -------\n    a : MaskedArray\n        A modified version of the input array, masked depending on the value\n        of the `axis` parameter.\n\n    Raises\n    ------\n    NotImplementedError\n        If input array `a` is not 2D.\n\n    See Also\n    --------\n    mask_rows : Mask rows of a 2D array that contain masked values.\n    mask_cols : Mask cols of a 2D array that contain masked values.\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The input array's mask is modified by this function.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), dtype=int)\n    >>> a[1, 1] = 1\n    >>> a\n    array([[0, 0, 0],\n           [0, 1, 0],\n           [0, 0, 0]])\n    >>> a = np.ma.masked_equal(a, 1)\n    >>> a\n    masked_array(\n      data=[[0, 0, 0],\n            [0, --, 0],\n            [0, 0, 0]],\n      mask=[[False, False, False],\n            [False,  True, False],\n            [False, False, False]],\n      fill_value=1)\n    >>> np.ma.mask_rowcols(a)\n    masked_array(\n      data=[[0, --, 0],\n            [--, --, --],\n            [0, --, 0]],\n      mask=[[False,  True, False],\n            [ True,  True,  True],\n            [False,  True, False]],\n      fill_value=1)\n\n    \"\"\"\n    a = array(a, subok=False)\n    if a.ndim != 2:\n        raise NotImplementedError('mask_rowcols works for 2D arrays only.')\n    m = getmask(a)\n    if m is nomask or not m.any():\n        return a\n    maskedval = m.nonzero()\n    a._mask = a._mask.copy()\n    if not axis:\n        a[np.unique(maskedval[0])] = masked\n    if axis in [None, 1, -1]:\n        a[:, np.unique(maskedval[1])] = masked\n    return a", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_mask_rowcols(self):\n\t    x = array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0], [0, 0, 0], [0, 0,\n\t        0]])\n\t    assert_equal(mask_rowcols(x).mask, [[1, 1, 1], [1, 0, 0], [1, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[1, 1, 1], [0, 0, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[1, 0, 0], [1, 0, 0], [1, 0, 0]])\n\t    x = array(x._data, mask=[[0, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x).mask, [[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[0, 0, 0], [1, 1, 1], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[0, 1, 0], [0, 1, 0], [0, 1, 0]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x).mask, [[1, 1, 1], [1, 1, 1], [1, 1, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[1, 1, 1], [1, 1, 1], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[1, 1, 0], [1, 1, 0], [1, 1, 0]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\t    assert_(mask_rowcols(x).all() is masked)\n\t    assert_(mask_rowcols(x, 0).all() is masked)\n\t    assert_(mask_rowcols(x, 1).all() is masked)\n\t    assert_(mask_rowcols(x).mask.all())\n\t    assert_(mask_rowcols(x, 0).mask.all())\n\t    assert_(mask_rowcols(x, 1).mask.all())\n\t\nTestCompressFunctions().test_mask_rowcols()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: Mask rows and/or columns of a 2D array that contain masked values based on the specified axis.\n\nInputs: \n1. a : array_like, MaskedArray - The array to mask. Must be a 2D array. If not a MaskedArray instance or if no array elements are masked, the result is a MaskedArray with mask set to nomask (False).\n2. axis : int, optional - Axis along which to perform the operation. If None, applies to a flattened version of the array. The masking behavior is axis-dependent:\n   - If axis is None, rows and columns are masked.\n   - If axis is 0, only rows are masked.\n   - If axis is 1 or -1, only columns are masked.\n\nOutputs:\n1. a : MaskedArray - A modified version of the input array, masked depending on the value of the 'axis' parameter. The input array's mask is modified in place.\n\nRaises:\n- NotImplementedError: If input array 'a' is not 2D.\n\nSee Also:\n- mask_rows : Mask rows of a 2D array that contain masked values.\n- mask_cols : Mask columns of a 2D array that contain masked values.\n- masked_where : Mask where a condition is met.\n\nNotes:\n- The function modifies the input array's mask.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef mask_rowcols(a, axis=None): [MASK]\n"}
{"method_name": "apply_along_axis", "full_method_name": "apply_along_axis", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef apply_along_axis(func1d, axis, arr, *args, **kwargs):\n    \"\"\"\n    (This docstring should be overwritten)\n    \"\"\"\n    arr = array(arr, copy=False, subok=True)\n    nd = arr.ndim\n    axis = normalize_axis_index(axis, nd)\n    ind = [0] * (nd - 1)\n    i = np.zeros(nd, 'O')\n    indlist = list(range(nd))\n    indlist.remove(axis)\n    i[axis] = slice(None, None)\n    outshape = np.asarray(arr.shape).take(indlist)\n    i.put(indlist, ind)\n    res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n    asscalar = np.isscalar(res)\n    if not asscalar:\n        try:\n            len(res)\n        except TypeError:\n            asscalar = True\n    dtypes = []\n    if asscalar:\n        dtypes.append(np.asarray(res).dtype)\n        outarr = zeros(outshape, object)\n        outarr[tuple(ind)] = res\n        Ntot = np.prod(outshape)\n        k = 1\n        while k < Ntot:\n            ind[-1] += 1\n            n = -1\n            while ind[n] >= outshape[n] and n > 1 - nd:\n                ind[n - 1] += 1\n                ind[n] = 0\n                n -= 1\n            i.put(indlist, ind)\n            res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n            outarr[tuple(ind)] = res\n            dtypes.append(asarray(res).dtype)\n            k += 1\n    else:\n        res = array(res, copy=False, subok=True)\n        j = i.copy()\n        j[axis] = [slice(None, None)] * res.ndim\n        j.put(indlist, ind)\n        Ntot = np.prod(outshape)\n        holdshape = outshape\n        outshape = list(arr.shape)\n        outshape[axis] = res.shape\n        dtypes.append(asarray(res).dtype)\n        outshape = flatten_inplace(outshape)\n        outarr = zeros(outshape, object)\n        outarr[tuple(flatten_inplace(j.tolist()))] = res\n        k = 1\n        while k < Ntot:\n            ind[-1] += 1\n            n = -1\n            while ind[n] >= holdshape[n] and n > 1 - nd:\n                ind[n - 1] += 1\n                ind[n] = 0\n                n -= 1\n            i.put(indlist, ind)\n            j.put(indlist, ind)\n            res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n            outarr[tuple(flatten_inplace(j.tolist()))] = res\n            dtypes.append(asarray(res).dtype)\n            k += 1\n    max_dtypes = np.dtype(np.asarray(dtypes).max())\n    if not hasattr(arr, '_mask'):\n        result = np.asarray(outarr, dtype=max_dtypes)\n    else:\n        result = asarray(outarr, dtype=max_dtypes)\n        result.fill_value = ma.default_fill_value(result)\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyAlongAxis():\n\tdef test_3d(self):\n\t    a = arange(12.0).reshape(2, 2, 3)\n\t\n\t    def myfunc(b):\n\t        return b[1]\n\t    xa = apply_along_axis(myfunc, 2, a)\n\t    assert_equal(xa, [[1, 4], [7, 10]])\n\t\nTestApplyAlongAxis().test_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyAlongAxis():\n\tdef test_3d_kwargs(self):\n\t    a = arange(12).reshape(2, 2, 3)\n\t\n\t    def myfunc(b, offset=0):\n\t        return b[1 + offset]\n\t    xa = apply_along_axis(myfunc, 2, a, offset=1)\n\t    assert_equal(xa, [[2, 5], [8, 11]])\n\t\nTestApplyAlongAxis().test_3d_kwargs()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The apply_along_axis function applies a specified function 'func1d' to 1-D slices along the given 'axis' of 'arr'. It is designed to work on NumPy arrays and can handle scalar outputs or outputs that are arrays themselves. The function iterates over the array, applying 'func1d' to each slice, and collects the results into an output array.\n\nInputs: \n1. func1d: A callable function that accepts a 1-D array and additional arguments. It should return a single value or an array.\n2. axis: An integer indicating along which axis the function is applied. The axis is normalized to be within the range of the array's dimensions.\n3. arr: A NumPy array (ndarray) on which the function is to be applied.\n4. *args: Variable-length argument list passed to 'func1d'.\n5. **kwargs: Arbitrary keyword arguments passed to 'func1d'.\n\nOutputs:\n1. outarr: A NumPy array that contains the results of applying 'func1d' to each slice of 'arr' along the specified 'axis'. The type and shape of 'outarr' are determined by the output of 'func1d' and the structure of 'arr'.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef apply_along_axis(func1d, axis, arr, *args, **kwargs): [MASK]\n"}
{"method_name": "apply_over_axes", "full_method_name": "apply_over_axes", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef apply_over_axes(func, a, axes):\n    \"\"\"\n    (This docstring will be overwritten)\n    \"\"\"\n    val = asarray(a)\n    N = a.ndim\n    if array(axes).ndim == 0:\n        axes = axes,\n    for axis in axes:\n        if axis < 0:\n            axis = N + axis\n        args = val, axis\n        res = func(*args)\n        if res.ndim == val.ndim:\n            val = res\n        else:\n            res = ma.expand_dims(res, axis)\n            if res.ndim == val.ndim:\n                val = res\n            else:\n                raise ValueError(\n                    'function is not returning an array of the correct shape')\n    return val", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyOverAxes():\n\tdef test_basic(self):\n\t    a = arange(24).reshape(2, 3, 4)\n\t    test = apply_over_axes(np.sum, a, [0, 2])\n\t    ctrl = np.array([[[60], [92], [124]]])\n\t    assert_equal(test, ctrl)\n\t    a[(a % 2).astype(bool)] = masked\n\t    test = apply_over_axes(np.sum, a, [0, 2])\n\t    ctrl = np.array([[[28], [44], [60]]])\n\t    assert_equal(test, ctrl)\n\t\nTestApplyOverAxes().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The apply_over_axes function applies a given function 'func' along specific axes 'axes' of a multidimensional array 'a'. It is designed to perform operations that can be applied along one or more axes of the array, similar to numpy's own axis-based operations but with more flexibility.\n\nInputs: \n1. func: A callable function that will be applied over the specified axes of the array 'a'. This function should accept an array and an integer representing the axis, and return an array.\n2. a: An array-like object (e.g., list, tuple) or a numpy ndarray on which 'func' will be applied.\n3. axes: An integer or a sequence of integers indicating the axes along which 'func' should be applied. Negative axes are also supported and are interpreted as counting from the end of the array's dimensions.\n\nOutputs:\n1. Returns a numpy ndarray representing the result of applying 'func' along the specified axes of 'a'. The shape of the output array will match the shape of 'a' unless the application of 'func' naturally changes it, in which case an error will be raised if the resulting array does not have the correct shape.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef apply_over_axes(func, a, axes): [MASK]\n"}
{"method_name": "median", "full_method_name": "median", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef median(a, axis=None, out=None, overwrite_input=False, keepdims=False):\n    \"\"\"\n    Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which the medians are computed. The default (None) is\n        to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow use of memory of input array (a) for\n        calculations. The input array will be modified by the call to\n        median. This will save memory when you do not need to preserve\n        the contents of the input array. Treat the input as undefined,\n        but it will probably be fully or partially sorted. Default is\n        False. Note that, if `overwrite_input` is True, and the input\n        is not already an `ndarray`, an error will be raised.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result is returned unless out is\n        specified, in which case a reference to out is returned.\n        Return data-type is `float64` for integers and floats smaller than\n        `float64`, or the input data-type, otherwise.\n\n    See Also\n    --------\n    mean\n\n    Notes\n    -----\n    Given a vector ``V`` with ``N`` non masked values, the median of ``V``\n    is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.\n    ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``\n    when ``N`` is even.\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n    >>> np.ma.median(x)\n    1.5\n\n    >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n    >>> np.ma.median(x)\n    2.5\n    >>> np.ma.median(x, axis=-1, overwrite_input=True)\n    masked_array(data=[2.0, 5.0],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    if not hasattr(a, 'mask'):\n        m = np.median(getdata(a, subok=True), axis=axis, out=out,\n            overwrite_input=overwrite_input, keepdims=keepdims)\n        if isinstance(m, np.ndarray) and 1 <= m.ndim:\n            return masked_array(m, copy=False)\n        else:\n            return m\n    return _ureduce(a, func=_median, keepdims=keepdims, axis=axis, out=out,\n        overwrite_input=overwrite_input)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_pytype(self):\n\t    r = median([[np.inf, np.inf], [np.inf, np.inf]], axis=-1)\n\t    assert_equal(r, np.inf)\n\t\nTestMedian().test_pytype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_inf(self):\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ]), axis=-1)\n\t    assert_equal(r, np.inf)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ]), axis=None)\n\t    assert_equal(r, np.inf)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ], mask=True), axis=-1)\n\t    assert_equal(r.mask, True)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ], mask=True), axis=None)\n\t    assert_equal(r.mask, True)\n\t\nTestMedian().test_inf()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_non_masked(self):\n\t    x = np.arange(9)\n\t    assert_equal(median(x), 4.0)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = range(8)\n\t    assert_equal(median(x), 3.5)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = 5\n\t    assert_equal(median(x), 5.0)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = np.arange(9 * 8).reshape(9, 8)\n\t    assert_equal(median(x, axis=0), np.median(x, axis=0))\n\t    assert_equal(median(x, axis=1), np.median(x, axis=1))\n\t    assert_(median(x, axis=1) is not MaskedArray)\n\t    x = np.arange(9 * 8.0).reshape(9, 8)\n\t    assert_equal(median(x, axis=0), np.median(x, axis=0))\n\t    assert_equal(median(x, axis=1), np.median(x, axis=1))\n\t    assert_(median(x, axis=1) is not MaskedArray)\n\t\nTestMedian().test_non_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_docstring_examples(self):\n\t    \"\"\"test the examples given in the docstring of ma.median\"\"\"\n\t    x = array(np.arange(8), mask=[0] * 4 + [1] * 4)\n\t    assert_equal(median(x), 1.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(10).reshape(2, 5), mask=[0] * 6 + [1] * 4)\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    ma_x = median(x, axis=-1, overwrite_input=True)\n\t    assert_equal(ma_x, [2.0, 5.0])\n\t    assert_equal(ma_x.shape, (2,), 'shape mismatch')\n\t    assert_(type(ma_x) is MaskedArray)\n\t\nTestMedian().test_docstring_examples()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_masked_0d(self):\n\t    x = array(1, mask=False)\n\t    assert_equal(median(x), 1)\n\t    x = array(1, mask=True)\n\t    assert_equal(median(x), np.ma.masked)\n\t\nTestMedian().test_masked_0d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_masked_1d(self):\n\t    x = array(np.arange(5), mask=True)\n\t    assert_equal(median(x), np.ma.masked)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is np.ma.core.MaskedConstant)\n\t    x = array(np.arange(5), mask=False)\n\t    assert_equal(median(x), 2.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 0, 0, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 1, 1, 1])\n\t    assert_equal(median(x), 0.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 1, 0, 0])\n\t    assert_equal(median(x), 3.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5.0), mask=[0, 1, 1, 0, 0])\n\t    assert_equal(median(x), 3.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(6), mask=[0, 1, 1, 1, 1, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(6.0), mask=[0, 1, 1, 1, 1, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t\nTestMedian().test_masked_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_1d_shape_consistency(self):\n\t    assert_equal(median(array([1, 2, 3], mask=[0, 0, 0])).shape, np.\n\t        ma.median(array([1, 2, 3], mask=[0, 1, 0])).shape)\n\t\nTestMedian().test_1d_shape_consistency()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d(self):\n\t    n, p = 101, 30\n\t    x = masked_array(np.linspace(-1.0, 1.0, n))\n\t    x[:10] = x[-10:] = masked\n\t    z = masked_array(np.empty((n, p), dtype=float))\n\t    z[:, 0] = x[:]\n\t    idx = np.arange(len(x))\n\t    for i in range(1, p):\n\t        np.random.shuffle(idx)\n\t        z[:, i] = x[idx]\n\t    assert_equal(median(z[:, 0]), 0)\n\t    assert_equal(median(z), 0)\n\t    assert_equal(median(z, axis=0), np.zeros(p))\n\t    assert_equal(median(z.T, axis=1), np.zeros(p))\n\t\nTestMedian().test_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d_waxis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x), 14.5)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    assert_equal(median(x, axis=0), [13.5, 14.5, 15.5])\n\t    assert_(type(median(x, axis=0)) is MaskedArray)\n\t    assert_equal(median(x, axis=1), [0, 0, 0, 10, 13, 16, 19, 0, 0, 0])\n\t    assert_(type(median(x, axis=1)) is MaskedArray)\n\t    assert_equal(median(x, axis=1).mask, [1, 1, 1, 0, 0, 0, 0, 1, 1, 1])\n\t\nTestMedian().test_2d_waxis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d_waxis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x), 14.5)\n\t    assert_(type(np.ma.median(x)) is not MaskedArray)\n\t    assert_equal(median(x, axis=0), [13.5, 14.5, 15.5])\n\t    assert_(type(np.ma.median(x, axis=0)) is MaskedArray)\n\t    assert_equal(median(x, axis=1), [0, 0, 0, 10, 13, 16, 19, 0, 0, 0])\n\t    assert_(type(np.ma.median(x, axis=1)) is MaskedArray)\n\t    assert_equal(median(x, axis=1).mask, [1, 1, 1, 0, 0, 0, 0, 1, 1, 1])\n\t\nTestMedian().test_2d_waxis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_3d(self):\n\t    x = np.ma.arange(24).reshape(3, 4, 2)\n\t    x[x % 3 == 0] = masked\n\t    assert_equal(median(x, 0), [[12, 9], [6, 15], [12, 9], [18, 15]])\n\t    x.shape = 4, 3, 2\n\t    assert_equal(median(x, 0), [[99, 10], [11, 99], [13, 14]])\n\t    x = np.ma.arange(24).reshape(4, 3, 2)\n\t    x[x % 5 == 0] = masked\n\t    assert_equal(median(x, 0), [[12, 10], [8, 9], [16, 17]])\n\t\nTestMedian().test_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_neg_axis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x, axis=-1), median(x, axis=1))\n\t\nTestMedian().test_neg_axis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out_1d(self):\n\t    for v in (30, 30.0, 31, 31.0):\n\t        x = masked_array(np.arange(v))\n\t        x[:3] = x[-3:] = masked\n\t        out = masked_array(np.ones(()))\n\t        r = median(x, out=out)\n\t        if v == 30:\n\t            assert_equal(out, 14.5)\n\t        else:\n\t            assert_equal(out, 15.0)\n\t        assert_(r is out)\n\t        assert_(type(r) is MaskedArray)\n\t\nTestMedian().test_out_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out(self):\n\t    for v in (40, 40.0, 30, 30.0):\n\t        x = masked_array(np.arange(v).reshape(10, -1))\n\t        x[:3] = x[-3:] = masked\n\t        out = masked_array(np.ones(10))\n\t        r = median(x, axis=1, out=out)\n\t        if v == 30:\n\t            e = masked_array([0.0] * 3 + [10, 13, 16, 19] + [0.0] * 3, mask\n\t                =[True] * 3 + [False] * 4 + [True] * 3)\n\t        else:\n\t            e = masked_array([0.0] * 3 + [13.5, 17.5, 21.5, 25.5] + [0.0] *\n\t                3, mask=[True] * 3 + [False] * 4 + [True] * 3)\n\t        assert_equal(r, e)\n\t        assert_(r is out)\n\t        assert_(type(r) is MaskedArray)\n\t\nTestMedian().test_out()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_single_non_masked_value_on_axis(self):\n\t    data = [[1.0, 0.0], [0.0, 3.0], [0.0, 0.0]]\n\t    masked_arr = np.ma.masked_equal(data, 0)\n\t    expected = [1.0, 3.0]\n\t    assert_array_equal(median(masked_arr, axis=0), expected)\n\t\nTestMedian().test_single_non_masked_value_on_axis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_nan(self):\n\t    for mask in (False, np.zeros(6, dtype=bool)):\n\t        dm = np.ma.array([[1, np.nan, 3], [1, 2, 3]])\n\t        dm.mask = mask\n\t        r = median(dm, axis=None)\n\t        assert_(np.isscalar(r))\n\t        assert_array_equal(r, np.nan)\n\t        r = median(dm.ravel(), axis=0)\n\t        assert_(np.isscalar(r))\n\t        assert_array_equal(r, np.nan)\n\t        r = median(dm, axis=0)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [1, np.nan, 3])\n\t        r = median(dm, axis=1)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [np.nan, 2])\n\t        r = median(dm, axis=-1)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [np.nan, 2])\n\t    dm = np.ma.array([[1, np.nan, 3], [1, 2, 3]])\n\t    dm[:, 2] = np.ma.masked\n\t    assert_array_equal(median(dm, axis=None), np.nan)\n\t    assert_array_equal(median(dm, axis=0), [1, np.nan, 3])\n\t    assert_array_equal(median(dm, axis=1), [np.nan, 1.5])\n\t\nTestMedian().test_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out_nan(self):\n\t    o = np.ma.masked_array(np.zeros((4,)))\n\t    d = np.ma.masked_array(np.ones((3, 4)))\n\t    d[2, 1] = np.nan\n\t    d[2, 2] = np.ma.masked\n\t    assert_equal(median(d, 0, out=o), o)\n\t    o = np.ma.masked_array(np.zeros((3,)))\n\t    assert_equal(median(d, 1, out=o), o)\n\t    o = np.ma.masked_array(np.zeros(()))\n\t    assert_equal(median(d, out=o), o)\n\t\nTestMedian().test_out_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_nan_behavior(self):\n\t    a = np.ma.masked_array(np.arange(24, dtype=float))\n\t    a[::3] = np.ma.masked\n\t    a[2] = np.nan\n\t    assert_array_equal(median(a), np.nan)\n\t    assert_array_equal(median(a, axis=0), np.nan)\n\t    a = np.ma.masked_array(np.arange(24, dtype=float).reshape(2, 3, 4))\n\t    a.mask = np.arange(a.size) % 2 == 1\n\t    aorig = a.copy()\n\t    a[1, 2, 3] = np.nan\n\t    a[1, 1, 2] = np.nan\n\t    assert_array_equal(median(a), np.nan)\n\t    assert_(np.isscalar(median(a)))\n\t    b = median(aorig, axis=0)\n\t    b[2, 3] = np.nan\n\t    b[1, 2] = np.nan\n\t    assert_equal(median(a, 0), b)\n\t    b = median(aorig, axis=1)\n\t    b[1, 3] = np.nan\n\t    b[1, 2] = np.nan\n\t    assert_equal(median(a, 1), b)\n\t    b = median(aorig, axis=(0, 2))\n\t    b[1] = np.nan\n\t    b[2] = np.nan\n\t    assert_equal(median(a, (0, 2)), b)\n\t\nTestMedian().test_nan_behavior()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_ambigous_fill(self):\n\t    a = np.array([[3, 3, 255], [3, 3, 255]], dtype=np.uint8)\n\t    a = np.ma.masked_array(a, mask=a == 3)\n\t    assert_array_equal(median(a, axis=1), 255)\n\t    assert_array_equal(median(a, axis=1).mask, False)\n\t    assert_array_equal(median(a, axis=0), a[0])\n\t    assert_array_equal(median(a), 255)\n\t\nTestMedian().test_ambigous_fill()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_special(self):\n\t    for inf in [np.inf, -np.inf]:\n\t        a = np.array([[inf, np.nan], [np.nan, np.nan]])\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        assert_equal(median(a, axis=0), [inf, np.nan])\n\t        assert_equal(median(a, axis=1), [inf, np.nan])\n\t        assert_equal(median(a), inf)\n\t        a = np.array([[np.nan, np.nan, inf], [np.nan, np.nan, inf]])\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        assert_array_equal(median(a, axis=1), inf)\n\t        assert_array_equal(median(a, axis=1).mask, False)\n\t        assert_array_equal(median(a, axis=0), a[0])\n\t        assert_array_equal(median(a), inf)\n\t        a = np.array([[inf, inf], [inf, inf]])\n\t        assert_equal(median(a), inf)\n\t        assert_equal(median(a, axis=0), inf)\n\t        assert_equal(median(a, axis=1), inf)\n\t        a = np.array([[inf, 7, -inf, -9], [-10, np.nan, np.nan, 5], [4, np.\n\t            nan, np.nan, inf]], dtype=np.float32)\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        if inf > 0:\n\t            assert_equal(median(a, axis=0), [4.0, 7.0, -inf, 5.0])\n\t            assert_equal(median(a), 4.5)\n\t        else:\n\t            assert_equal(median(a, axis=0), [-10.0, 7.0, -inf, -9.0])\n\t            assert_equal(median(a), -2.5)\n\t        assert_equal(median(a, axis=1), [-1.0, -2.5, inf])\n\t        for i in range(0, 10):\n\t            for j in range(1, 10):\n\t                a = np.array([[np.nan] * i + [inf] * j] * 2)\n\t                a = np.ma.masked_array(a, mask=np.isnan(a))\n\t                assert_equal(median(a), inf)\n\t                assert_equal(median(a, axis=1), inf)\n\t                assert_equal(median(a, axis=0), [np.nan] * i + [inf] * j)\n\t\nTestMedian().test_special()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_empty(self):\n\t    a = np.ma.masked_array(np.array([], dtype=float))\n\t    with suppress_warnings() as w:\n\t        w.record(RuntimeWarning)\n\t        assert_array_equal(median(a), np.nan)\n\t        assert_(w.log[0].category is RuntimeWarning)\n\t    a = np.ma.masked_array(np.array([], dtype=float, ndmin=3))\n\t    with suppress_warnings() as w:\n\t        w.record(RuntimeWarning)\n\t        warnings.filterwarnings('always', '', RuntimeWarning)\n\t        assert_array_equal(median(a), np.nan)\n\t        assert_(w.log[0].category is RuntimeWarning)\n\t    b = np.ma.masked_array(np.array([], dtype=float, ndmin=2))\n\t    assert_equal(median(a, axis=0), b)\n\t    assert_equal(median(a, axis=1), b)\n\t    b = np.ma.masked_array(np.array(np.nan, dtype=float, ndmin=2))\n\t    with warnings.catch_warnings(record=True) as w:\n\t        warnings.filterwarnings('always', '', RuntimeWarning)\n\t        assert_equal(median(a, axis=2), b)\n\t        assert_(w[0].category is RuntimeWarning)\n\t\nTestMedian().test_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_object(self):\n\t    o = np.ma.masked_array(np.arange(7.0))\n\t    assert_(type(median(o.astype(object))), float)\n\t    o[2] = np.nan\n\t    assert_(type(median(o.astype(object))), float)\n\t\nTestMedian().test_object()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: Compute the median along the specified axis of the input array elements.\n\nInputs: \n    a: array_like\n        Input array or object that can be converted to an array.\n    axis: int, optional (default: None)\n        Axis along which the medians are computed. If None, compute median along a flattened version of the array.\n    out: ndarray, optional (default: None)\n        Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary.\n    overwrite_input: bool, optional (default: False)\n        If True, allow use of memory of input array (a) for calculations, which will save memory but modify the input array contents. Default is False.\n    keepdims: bool, optional (default: False)\n        If True, reduced axes are left in the result as dimensions with size one. This option ensures proper broadcasting against the input array.\n\nOutputs:\n    median: ndarray\n        A new array holding the result is returned unless 'out' is specified, in which case a reference to 'out' is returned. The data-type of the result is 'float64' for integers and floats smaller than 'float64', or the input data-type, otherwise.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef median(a, axis=None, out=None, overwrite_input=False, keepdims=False): [M\n    ASK]\n"}
{"method_name": "polyfit", "full_method_name": "polyfit", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):\n    \"\"\"\n    Any masked values in x is propagated in y, and vice-versa.\n\n    \"\"\"\n    x = asarray(x)\n    y = asarray(y)\n    m = getmask(x)\n    if y.ndim == 1:\n        m = mask_or(m, getmask(y))\n    elif y.ndim == 2:\n        my = getmask(mask_rows(y))\n        if my is not nomask:\n            m = mask_or(m, my[:, 0])\n    else:\n        raise TypeError('Expected a 1D or 2D array for y!')\n    if w is not None:\n        w = asarray(w)\n        if w.ndim != 1:\n            raise TypeError('expected a 1-d array for weights')\n        if w.shape[0] != y.shape[0]:\n            raise TypeError('expected w and y to have the same length')\n        m = mask_or(m, getmask(w))\n    if m is not nomask:\n        not_m = ~m\n        if w is not None:\n            w = w[not_m]\n        return np.polyfit(x[not_m], y[not_m], deg, rcond, full, w, cov)\n    else:\n        return np.polyfit(x, y, deg, rcond, full, w, cov)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestPolynomial():\n\tdef test_polyfit(self):\n\t    x = np.random.rand(10)\n\t    y = np.random.rand(20).reshape(-1, 2)\n\t    assert_almost_equal(polyfit(x, y, 3), np.polyfit(x, y, 3))\n\t    x = x.view(MaskedArray)\n\t    x[0] = masked\n\t    y = y.view(MaskedArray)\n\t    y[0, 0] = y[-1, -1] = masked\n\t    C, R, K, S, D = polyfit(x, y[:, 0], 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:], y[1:, 0].compressed(), 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    C, R, K, S, D = polyfit(x, y[:, -1], 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, -1], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, :], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    w = np.random.rand(10) + 1\n\t    wo = w.copy()\n\t    xs = x[1:-1]\n\t    ys = y[1:-1]\n\t    ws = w[1:-1]\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True, w=w)\n\t    c, r, k, s, d = np.polyfit(xs, ys, 3, full=True, w=ws)\n\t    assert_equal(w, wo)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t\nTestPolynomial().test_polyfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestPolynomial():\n\tdef test_polyfit_with_masked_NaNs(self):\n\t    x = np.random.rand(10)\n\t    y = np.random.rand(20).reshape(-1, 2)\n\t    x[0] = np.nan\n\t    y[-1, -1] = np.nan\n\t    x = x.view(MaskedArray)\n\t    y = y.view(MaskedArray)\n\t    x[0] = masked\n\t    y[-1, -1] = masked\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, :], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t\nTestPolynomial().test_polyfit_with_masked_NaNs()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The polyfit function performs a least-squares polynomial fit on the data points specified by the input arrays x and y. It calculates the coefficients of the polynomial of degree deg that best approximates the data points. The function can handle masked values in the input arrays, and it supports weighting and covariance matrix calculation.\n\nInputs: \n- x: A 1D numpy ndarray representing the x-coordinates of the data points. \n- y: A 1D or 2D numpy ndarray representing the y-coordinates of the data points.\n- deg: An integer specifying the degree of the polynomial to fit.\n- rcond: Optional. The relative condition number of the fit. Singular values smaller than this relative to the largest singular value will be ignored. \n- full: Optional. A boolean, if True, all relevant data is returned: coefficient, residuals, rank, singular values, and rcond. \n- w: Optional. An array of weights of the same length as x. \n- cov: Optional. A boolean, if True, the covariance matrix of the coefficient estimates is returned.\n\nOutputs: \n- If full is False and cov is False, the function returns the least-squares solution (a ndarray of shape (deg + 1,) containing the polynomial coefficients, highest power first).\n- If full is True and cov is False, the function returns a tuple of size 5 containing the least-squares solution, the residuals of the least-squares fit, the rank of the design matrix, two singular values, and rcond.\n- If cov is True, the function returns a tuple of size 2 containing the least-squares solution and the covariance matrix of the coefficient estimates. If full is True, it returns a tuple of size 6 containing the least-squares solution, the residuals, the rank, two singular values, rcond, and the covariance matrix.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False): [MASK]\n"}
{"method_name": "unique", "full_method_name": "unique", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef unique(ar1, return_index=False, return_inverse=False):\n    \"\"\"\n    Finds the unique elements of an array.\n\n    Masked values are considered the same element (masked). The output array\n    is always a masked array. See `numpy.unique` for more details.\n\n    See Also\n    --------\n    numpy.unique : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> a = [1, 2, 1000, 2, 3]\n    >>> mask = [0, 0, 1, 0, 0]\n    >>> masked_a = np.ma.masked_array(a, mask)\n    >>> masked_a\n    masked_array(data=[1, 2, --, 2, 3],\n                mask=[False, False,  True, False, False],\n        fill_value=999999)\n    >>> np.ma.unique(masked_a)\n    masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999)\n    >>> np.ma.unique(masked_a, return_index=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]))\n    >>> np.ma.unique(masked_a, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 3, 1, 2]))\n    >>> np.ma.unique(masked_a, return_index=True, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))\n    \"\"\"\n    output = np.unique(ar1, return_index=return_index, return_inverse=\n        return_inverse)\n    if isinstance(output, tuple):\n        output = list(output)\n        output[0] = output[0].view(MaskedArray)\n        output = tuple(output)\n    else:\n        output = output.view(MaskedArray)\n    return output", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_onlist(self):\n\t    data = [1, 1, 1, 2, 2, 3]\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_(isinstance(test[0], MaskedArray))\n\t    assert_equal(test[0], masked_array([1, 2, 3], mask=[0, 0, 0]))\n\t    assert_equal(test[1], [0, 3, 5])\n\t    assert_equal(test[2], [0, 0, 0, 1, 1, 2])\n\t\nTestArraySetOps().test_unique_onlist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_onmaskedarray(self):\n\t    data = masked_array([1, 1, 1, 2, 2, 3], mask=[0, 0, 1, 0, 1, 0])\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1, 2, 3, -1], mask=[0, 0, 0, 1]))\n\t    assert_equal(test[1], [0, 3, 5, 2])\n\t    assert_equal(test[2], [0, 0, 3, 1, 3, 2])\n\t    data.fill_value = 3\n\t    data = masked_array(data=[1, 1, 1, 2, 2, 3], mask=[0, 0, 1, 0, 1, 0],\n\t        fill_value=3)\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1, 2, 3, -1], mask=[0, 0, 0, 1]))\n\t    assert_equal(test[1], [0, 3, 5, 2])\n\t    assert_equal(test[2], [0, 0, 3, 1, 3, 2])\n\t\nTestArraySetOps().test_unique_onmaskedarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_allmasked(self):\n\t    data = masked_array([1, 1, 1], mask=True)\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1], mask=[True]))\n\t    assert_equal(test[1], [0])\n\t    assert_equal(test[2], [0, 0, 0])\n\t    data = masked\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array(masked))\n\t    assert_equal(test[1], [0])\n\t    assert_equal(test[2], [0])\n\t\nTestArraySetOps().test_unique_allmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: This function finds the unique elements of a masked array. Masked values are treated as the same element (masked), and the output array is always a masked array. It can return the indices of the unique elements in the original array, and/or an array that can be used to reconstruct the original array from the unique array.\n\nInputs: \n   ar1: A masked array from which to find the unique elements.\n   return_index: A boolean indicating whether to return the indices of the unique elements in the original array. Default is False.\n   return_inverse: A boolean indicating whether to return an array that can be used to reconstruct the original array from the unique array. Default is False.\n\nOutputs: \n   Depending on the flags, the function returns:\n   - The unique masked array.\n   - Optionally, the indices of the unique elements in the original array.\n   - Optionally, an array that can be used to reconstruct the original array from the unique array.\n   If both additional flags are False, only the unique masked array is returned. If one or both flags are True, the function returns a tuple where the first element is the unique masked array, followed by the requested additional outputs.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef unique(ar1, return_index=False, return_inverse=False): [MASK]\n"}
{"method_name": "ediff1d", "full_method_name": "ediff1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef ediff1d(arr, to_end=None, to_begin=None):\n    \"\"\"\n    Compute the differences between consecutive elements of an array.\n\n    This function is the equivalent of `numpy.ediff1d` that takes masked\n    values into account, see `numpy.ediff1d` for details.\n\n    See Also\n    --------\n    numpy.ediff1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> arr = np.ma.array([1, 2, 4, 7, 0])\n    >>> np.ma.ediff1d(arr)\n    masked_array(data=[ 1,  2,  3, -7],\n                 mask=False,\n           fill_value=999999)\n\n    \"\"\"\n    arr = ma.asanyarray(arr).flat\n    ed = arr[1:] - arr[:-1]\n    arrays = [ed]\n    if to_begin is not None:\n        arrays.insert(0, to_begin)\n    if to_end is not None:\n        arrays.append(to_end)\n    if len(arrays) != 1:\n        ed = hstack(arrays)\n    return ed", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    control = array([1, 1, 1, 4], mask=[1, 0, 0, 1])\n\t    test = ediff1d(x)\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_tobegin(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4], mask=[1, 1, 0, 0, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_begin=[1, 2, 3])\n\t    control = array([1, 2, 3, 1, 1, 1, 4], mask=[0, 0, 0, 1, 0, 0, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_tobegin()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_toend(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_end=masked)\n\t    control = array([1, 1, 1, 4, 0], mask=[1, 0, 0, 1, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=[1, 2, 3])\n\t    control = array([1, 1, 1, 4, 1, 2, 3], mask=[1, 0, 0, 1, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_toend()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_tobegin_toend(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_end=masked, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4, 0], mask=[1, 1, 0, 0, 1, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=[1, 2, 3], to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4, 1, 2, 3], mask=[1, 1, 0, 0, 1, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_tobegin_toend()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_ndarray(self):\n\t    x = np.arange(5)\n\t    test = ediff1d(x)\n\t    control = array([1, 1, 1, 1], mask=[0, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=masked, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 1, 0], mask=[1, 0, 0, 0, 0, 1])\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_ndarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The ediff1d function computes the differences between consecutive elements of an array, similar to numpy's ediff1d function but with support for masked arrays. It can optionally add differences at the beginning and end of the array.\n\nInputs: \n- arr: An array-like input in the form of a masked array. This is the primary array from which differences between consecutive elements will be calculated.\n- to_end: An optional input that represents the difference value to add at the end of the result array.\n- to_begin: An optional input that represents the difference value to add at the beginning of the result array.\n\nOutputs: \n- A masked array containing the calculated differences between consecutive elements of the input array. If to_begin or to_end are provided, the output array will include these values at the beginning or end, respectively.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef ediff1d(arr, to_end=None, to_begin=None): [MASK]\n"}
{"method_name": "intersect1d", "full_method_name": "intersect1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef intersect1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Returns the unique elements common to both arrays.\n\n    Masked values are considered equal one to the other.\n    The output is always a masked array.\n\n    See `numpy.intersect1d` for more details.\n\n    See Also\n    --------\n    numpy.intersect1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n    >>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n    >>> np.ma.intersect1d(x, y)\n    masked_array(data=[1, 3, --],\n                 mask=[False, False,  True],\n           fill_value=999999)\n\n    \"\"\"\n    if assume_unique:\n        aux = ma.concatenate((ar1, ar2))\n    else:\n        aux = ma.concatenate((unique(ar1), unique(ar2)))\n    aux.sort()\n    return aux[:-1][aux[1:] == aux[:-1]]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_intersect1d(self):\n\t    x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n\t    y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n\t    test = intersect1d(x, y)\n\t    control = array([1, 3, -1], mask=[0, 0, 1])\n\t    assert_equal(test, control)\n\t\nTestArraySetOps().test_intersect1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The intersect1d function is designed to find and return the unique elements that are common to two given input arrays. Masked values in the arrays are treated as equal, and the result is always returned as a masked array.\n\nInputs: \n- ar1: The first input array, which can be a numpy ndarray or a masked array.\n- ar2: The second input array, similar to the first one, it can be an ndarray or a masked array.\n- assume_unique: An optional boolean parameter. If set to True, the function assumes that the input arrays are already unique. This can speed up the function, but if the assumption is incorrect, incorrect results may be returned.\n\nOutputs:\n- A masked array containing the unique elements that are common to both input arrays. Masked values in the output represent elements that were masked in either or both input arrays.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef intersect1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"method_name": "setxor1d", "full_method_name": "setxor1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef setxor1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Set exclusive-or of 1-D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setxor1d` for more details.\n\n    See Also\n    --------\n    numpy.setxor1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> ar1 = np.ma.array([1, 2, 3, 2, 4])\n    >>> ar2 = np.ma.array([2, 3, 5, 7, 5])\n    >>> np.ma.setxor1d(ar1, ar2)\n    masked_array(data=[1, 4, 5, 7],\n                 mask=False,    \n           fill_value=999999)\n\n    \"\"\"\n    if not assume_unique:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n    aux = ma.concatenate((ar1, ar2), axis=None)\n    if aux.size == 0:\n        return aux\n    aux.sort()\n    auxf = aux.filled()\n    flag = ma.concatenate(([True], auxf[1:] != auxf[:-1], [True]))\n    flag2 = flag[1:] == flag[:-1]\n    return aux[flag2]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setxor1d(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    test = setxor1d(a, b)\n\t    assert_equal(test, array([3, 4, 7]))\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = [1, 2, 3, 4, 5]\n\t    test = setxor1d(a, b)\n\t    assert_equal(test, array([3, 4, 7, -1], mask=[0, 0, 0, 1]))\n\t    a = array([1, 2, 3])\n\t    b = array([6, 5, 4])\n\t    test = setxor1d(a, b)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test, [1, 2, 3, 4, 5, 6])\n\t    a = array([1, 8, 2, 3], mask=[0, 1, 0, 0])\n\t    b = array([6, 5, 4, 8], mask=[0, 0, 0, 1])\n\t    test = setxor1d(a, b)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test, [1, 2, 3, 4, 5, 6])\n\t    assert_array_equal([], setxor1d([], []))\n\t\nTestArraySetOps().test_setxor1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The setxor1d function computes the set exclusive-or (XOR) of two 1-D arrays with unique elements. It returns a masked array that contains elements that are in either of the input arrays but not in both. The function ensures that all elements in the output are unique.\n\nInputs: \n- ar1: A numpy masked array representing the first 1-D array.\n- ar2: A numpy masked array representing the second 1-D array.\n- assume_unique: A boolean flag indicating whether the input arrays are already composed of unique elements (default False). If False, the function will internally perform a uniqueness check.\n\nOutputs: \n- A numpy masked array containing the unique elements that are in either ar1 or ar2 but not in both. The output array is sorted in ascending order, and masked values are not included in the computation.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef setxor1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"method_name": "isin", "full_method_name": "isin", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef isin(element, test_elements, assume_unique=False, invert=False):\n    \"\"\"\n    Calculates `element in test_elements`, broadcasting over\n    `element` only.\n\n    The output is always a masked array of the same shape as `element`.\n    See `numpy.isin` for more details.\n\n    See Also\n    --------\n    in1d       : Flattened version of this function.\n    numpy.isin : Equivalent function for ndarrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.13.0\n\n    Examples\n    --------\n    >>> element = np.ma.array([1, 2, 3, 4, 5, 6])\n    >>> test_elements = [0, 2]\n    >>> np.ma.isin(element, test_elements)\n    masked_array(data=[False,  True, False, False, False, False],\n                 mask=False,\n           fill_value=True)\n\n    \"\"\"\n    element = ma.asarray(element)\n    return in1d(element, test_elements, assume_unique=assume_unique, invert\n        =invert).reshape(element.shape)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_isin(self):\n\t    a = np.arange(24).reshape([2, 3, 4])\n\t    mask = np.zeros([2, 3, 4])\n\t    mask[1, 2, 0] = 1\n\t    a = array(a, mask=mask)\n\t    b = array(data=[0, 10, 20, 30, 1, 3, 11, 22, 33], mask=[0, 1, 0, 1, 0, \n\t        1, 0, 1, 0])\n\t    ec = zeros((2, 3, 4), dtype=bool)\n\t    ec[0, 0, 0] = True\n\t    ec[0, 0, 1] = True\n\t    ec[0, 2, 3] = True\n\t    c = isin(a, b)\n\t    assert_(isinstance(c, MaskedArray))\n\t    assert_array_equal(c, ec)\n\t    d = np.isin(a, b[~b.mask]) & ~a.mask\n\t    assert_array_equal(c, d)\n\t\nTestArraySetOps().test_isin()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The isin function checks whether each element in the input array 'element' is present in the 'test_elements' array. It broadcasts over the 'element' array, returning a masked array of the same shape as 'element', where each element is True if the corresponding element in 'element' is in 'test_elements', and False otherwise. If 'invert' is True, the function returns True for elements in 'element' that are not in 'test_elements'. The 'assume_unique' parameter can be set to True if both 'element' and 'test_elements' are already unique to speed up the computation.\n\nInputs: \n- element: A masked array of any dimension where the elements will be checked against 'test_elements'.\n- test_elements: An array-like object against which 'element' will be checked. It can be a list, array, or any iterable.\n- assume_unique: A boolean value indicating if 'element' and 'test_elements' are already unique. Setting this to True can speed up the operation.\n- invert: A boolean value indicating if the result should be inverted. If True, the function returns True for elements in 'element' that are not in 'test_elements'.\n\nOutputs: \n- A masked array of the same shape as 'element', where each element is True if the corresponding element in 'element' is in 'test_elements' (or not in 'test_elements' if 'invert' is True), and False otherwise.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef isin(element, test_elements, assume_unique=False, invert=False): [MASK]\n"}
{"method_name": "in1d", "full_method_name": "in1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef in1d(ar1, ar2, assume_unique=False, invert=False):\n    \"\"\"\n    Test whether each element of an array is also present in a second\n    array.\n\n    The output is always a masked array. See `numpy.in1d` for more details.\n\n    We recommend using :func:`isin` instead of `in1d` for new code.\n\n    See Also\n    --------\n    isin       : Version of this function that preserves the shape of ar1.\n    numpy.in1d : Equivalent function for ndarrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> ar1 = np.ma.array([0, 1, 2, 5, 0])\n    >>> ar2 = [0, 2]\n    >>> np.ma.in1d(ar1, ar2)\n    masked_array(data=[ True, False,  True, False,  True],\n                 mask=False,\n           fill_value=True)\n\n    \"\"\"\n    if not assume_unique:\n        ar1, rev_idx = unique(ar1, return_inverse=True)\n        ar2 = unique(ar2)\n    ar = ma.concatenate((ar1, ar2))\n    order = ar.argsort(kind='mergesort')\n    sar = ar[order]\n    if invert:\n        bool_ar = sar[1:] != sar[:-1]\n    else:\n        bool_ar = sar[1:] == sar[:-1]\n    flag = ma.concatenate((bool_ar, [invert]))\n    indx = order.argsort(kind='mergesort')[:len(ar1)]\n    if assume_unique:\n        return flag[indx]\n    else:\n        return flag[indx][rev_idx]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_in1d(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    test = in1d(a, b)\n\t    assert_equal(test, [True, True, True, False, True])\n\t    a = array([5, 5, 2, 1, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 5, -1], mask=[0, 0, 1])\n\t    test = in1d(a, b)\n\t    assert_equal(test, [True, True, False, True, True])\n\t    assert_array_equal([], in1d([], []))\n\t\nTestArraySetOps().test_in1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_in1d_invert(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    assert_equal(np.invert(in1d(a, b)), in1d(a, b, invert=True))\n\t    a = array([5, 5, 2, 1, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 5, -1], mask=[0, 0, 1])\n\t    assert_equal(np.invert(in1d(a, b)), in1d(a, b, invert=True))\n\t    assert_array_equal([], in1d([], [], invert=True))\n\t\nTestArraySetOps().test_in1d_invert()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The in1d function tests whether each element of a given array (ar1) is also present in a second array (ar2). It returns a masked array of boolean values that indicate the presence or absence of each element of ar1 in ar2. The output is always a masked array, and the function supports options for assuming unique elements and inverting the result.\n\nInputs: \n- ar1: The first array of elements to test for containment in ar2.\n- ar2: The second array, which is tested for containing elements of ar1.\n- assume_unique: An optional boolean argument that determines if the input arrays are assumed to be unique. Default is False.\n- invert: An optional boolean argument that determines if the returned mask should be inverted. Default is False.\n\nOutputs:\n- A masked array of boolean values corresponding to the presence of elements from ar1 in ar2. The length of the output array is the same as the length of ar1. Each element in the output array is True if the corresponding element in ar1 is found in ar2 and False otherwise. If invert is True, the Boolean values in the output array are inverted.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef in1d(ar1, ar2, assume_unique=False, invert=False): [MASK]\n"}
{"method_name": "setdiff1d", "full_method_name": "setdiff1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef setdiff1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Set difference of 1D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setdiff1d` for more\n    details.\n\n    See Also\n    --------\n    numpy.setdiff1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n    >>> np.ma.setdiff1d(x, [1, 2])\n    masked_array(data=[3, --],\n                 mask=[False,  True],\n           fill_value=999999)\n\n    \"\"\"\n    if assume_unique:\n        ar1 = ma.asarray(ar1).ravel()\n    else:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n    return ar1[in1d(ar1, ar2, assume_unique=True, invert=True)]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setdiff1d(self):\n\t    a = array([6, 5, 4, 7, 7, 1, 2, 1], mask=[0, 0, 0, 0, 0, 0, 0, 1])\n\t    b = array([2, 4, 3, 3, 2, 1, 5])\n\t    test = setdiff1d(a, b)\n\t    assert_equal(test, array([6, 7, -1], mask=[0, 0, 1]))\n\t    a = arange(10)\n\t    b = arange(8)\n\t    assert_equal(setdiff1d(a, b), array([8, 9]))\n\t    a = array([], np.uint32, mask=[])\n\t    assert_equal(setdiff1d(a, []).dtype, np.uint32)\n\t\nTestArraySetOps().test_setdiff1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setdiff1d_char_array(self):\n\t    a = np.array(['a', 'b', 'c'])\n\t    b = np.array(['a', 'b', 's'])\n\t    assert_array_equal(setdiff1d(a, b), np.array(['c']))\n\t\nTestArraySetOps().test_setdiff1d_char_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: The setdiff1d function computes the set difference of two 1D arrays, which means it returns the values from the first array (ar1) that are not present in the second array (ar2). The result is always returned as a masked array, where elements not present in ar2 are unmasked, and elements that were in ar2 are masked.\n\nInputs: \n- ar1: A 1D array-like object from which elements are to be removed.\n- ar2: A 1D array-like object containing elements to be removed from ar1.\n- assume_unique: A boolean flag indicating whether the input arrays are unique or not. If set to True, the function assumes the arrays have unique elements.\n\nOutputs: \n- A masked array, where the unmasked elements are those from ar1 that do not appear in ar2. The masked elements are those that were present in both ar1 and ar2. The output is always a masked array, and the mask indicates whether an element was present in ar2.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef setdiff1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"method_name": "ndenumerate", "full_method_name": "ndenumerate", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "method_code": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef ndenumerate(a, compressed=True):\n    \"\"\"\n    Multidimensional index iterator.\n\n    Return an iterator yielding pairs of array coordinates and values,\n    skipping elements that are masked. With `compressed=False`,\n    `ma.masked` is yielded as the value of masked elements. This\n    behavior differs from that of `numpy.ndenumerate`, which yields the\n    value of the underlying data array.\n\n    Notes\n    -----\n    .. versionadded:: 1.23.0\n\n    Parameters\n    ----------\n    a : array_like\n        An array with (possibly) masked elements.\n    compressed : bool, optional\n        If True (default), masked elements are skipped.\n\n    See Also\n    --------\n    numpy.ndenumerate : Equivalent function ignoring any mask.\n\n    Examples\n    --------\n    >>> a = np.ma.arange(9).reshape((3, 3))\n    >>> a[1, 0] = np.ma.masked\n    >>> a[1, 2] = np.ma.masked\n    >>> a[2, 1] = np.ma.masked\n    >>> a\n    masked_array(\n      data=[[0, 1, 2],\n            [--, 4, --],\n            [6, --, 8]],\n      mask=[[False, False, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=999999)\n    >>> for index, x in np.ma.ndenumerate(a):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 1) 4\n    (2, 0) 6\n    (2, 2) 8\n\n    >>> for index, x in np.ma.ndenumerate(a, compressed=False):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 0) --\n    (1, 1) 4\n    (1, 2) --\n    (2, 0) 6\n    (2, 1) --\n    (2, 2) 8\n    \"\"\"\n    for it, mask in zip(np.ndenumerate(a), getmaskarray(a).flat):\n        if not mask:\n            yield it\n        elif not compressed:\n            yield it[0], masked", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_nomasked(self):\n\t    ordinary = np.arange(6.0).reshape((1, 3, 2))\n\t    empty_mask = np.zeros_like(ordinary, dtype=bool)\n\t    with_mask = masked_array(ordinary, mask=empty_mask)\n\t    assert_equal(list(np.ndenumerate(ordinary)), list(ndenumerate(ordinary)))\n\t    assert_equal(list(ndenumerate(ordinary)), list(ndenumerate(with_mask)))\n\t    assert_equal(list(ndenumerate(with_mask)), list(ndenumerate(with_mask,\n\t        compressed=False)))\n\t\nTestNDEnumerate().test_ndenumerate_nomasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_allmasked(self):\n\t    a = masked_all(())\n\t    b = masked_all((100,))\n\t    c = masked_all((2, 3, 4))\n\t    assert_equal(list(ndenumerate(a)), [])\n\t    assert_equal(list(ndenumerate(b)), [])\n\t    assert_equal(list(ndenumerate(b, compressed=False)), list(zip(np.\n\t        ndindex((100,)), 100 * [masked])))\n\t    assert_equal(list(ndenumerate(c)), [])\n\t    assert_equal(list(ndenumerate(c, compressed=False)), list(zip(np.\n\t        ndindex((2, 3, 4)), 2 * 3 * 4 * [masked])))\n\t\nTestNDEnumerate().test_ndenumerate_allmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_mixedmasked(self):\n\t    a = masked_array(np.arange(12).reshape((3, 4)), mask=[[1, 1, 1, 1], [1,\n\t        1, 0, 1], [0, 0, 0, 0]])\n\t    items = [((1, 2), 6), ((2, 0), 8), ((2, 1), 9), ((2, 2), 10), ((2, 3), 11)]\n\t    assert_equal(list(ndenumerate(a)), items)\n\t    assert_equal(len(list(ndenumerate(a, compressed=False))), a.size)\n\t    for coordinate, value in ndenumerate(a, compressed=False):\n\t        assert_equal(a[coordinate], value)\n\t\nTestNDEnumerate().test_ndenumerate_mixedmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "instruction": "Functionality: \nThe ndenumerate function is designed to iterate over the elements of an array, yielding pairs of array coordinates and values. Unlike numpy's ndenumerate, this function skips masked elements when the 'compressed' parameter is set to True. If 'compressed' is False, masked elements are included in the iteration, represented by 'ma.masked'.\n\nInputs: \n- a : array_like\n    An array with possibly masked elements.\n- compressed : bool, optional (default=True)\n    Determines whether masked elements should be skipped (True) or included (False) in the iteration.\n\nOutputs: \n- Iterator yielding tuples\n    Each tuple contains the index of an element in the array (as a tuple) and the value of the element. If 'compressed' is False and the element is masked, the value will be 'ma.masked'.", "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef ndenumerate(a, compressed=True): [MASK]\n"}
{"method_name": "eq", "full_method_name": "eq", "method_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py", "method_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\ndef eq(v, w, msg=''):\n    result = allclose(v, w)\n    if not result:\n        print(f'Not eq:{msg}\\n{v}\\n----{w}')\n    return result", "test_code_list": [{"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_xtestCount(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_equal(3, count(ott))\n\t    assert_equal(1, count(1))\n\t    assert_(eq(0, array(1, mask=[1])))\n\t    ott = ott.reshape((2, 2))\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_(isinstance(count(ott, 0), np.ndarray))\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_(eq(3, count(ott)))\n\t    assert_(getmask(count(ott, 0)) is nomask)\n\t    assert_(eq([1, 2], count(ott, 0)))\n\t\nTestMa().test_xtestCount()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testCI(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(eq(np.sort(x1), sort(x2, fill_value=0)))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_(eq(x1[2], x2[2]))\n\t    assert_(eq(x1[2:5], x2[2:5]))\n\t    assert_(eq(x1[:], x2[:]))\n\t    assert_(eq(x1[1:], x3[1:]))\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_(eq(x1, x2))\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_(eq(x1, x2))\n\t    x2[1] = masked\n\t    assert_(eq(x1, x2))\n\t    x2[1:3] = masked\n\t    assert_(eq(x1, x2))\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_(eq(x1, x2))\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_(eq(3.0, x2.fill_value))\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMa().test_testCI()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testCopySize(self):\n\t    n = [0, 0, 1, 0, 0]\n\t    m = make_mask(n)\n\t    m2 = make_mask(m)\n\t    assert_(m is m2)\n\t    m3 = make_mask(m, copy=True)\n\t    assert_(m is not m3)\n\t    x1 = np.arange(5)\n\t    y1 = array(x1, mask=m)\n\t    assert_(y1._data is not x1)\n\t    assert_(allequal(x1, y1._data))\n\t    assert_(y1._mask is m)\n\t    y1a = array(y1, copy=0)\n\t    assert_(y1a._mask.__array_interface__ == y1._mask.__array_interface__)\n\t    y2 = array(x1, mask=m3, copy=0)\n\t    assert_(y2._mask is m3)\n\t    assert_(y2[2] is masked)\n\t    y2[2] = 9\n\t    assert_(y2[2] is not masked)\n\t    assert_(y2._mask is m3)\n\t    assert_(allequal(y2.mask, 0))\n\t    y2a = array(x1, mask=m, copy=1)\n\t    assert_(y2a._mask is not m)\n\t    assert_(y2a[2] is masked)\n\t    y2a[2] = 9\n\t    assert_(y2a[2] is not masked)\n\t    assert_(y2a._mask is not m)\n\t    assert_(allequal(y2a.mask, 0))\n\t    y3 = array(x1 * 1.0, mask=m)\n\t    assert_(filled(y3).dtype is (x1 * 1.0).dtype)\n\t    x4 = arange(4)\n\t    x4[2] = masked\n\t    y4 = resize(x4, (8,))\n\t    assert_(eq(concatenate([x4, x4]), y4))\n\t    assert_(eq(getmask(y4), [0, 0, 1, 0, 0, 0, 1, 0]))\n\t    y5 = repeat(x4, (2, 2, 2, 2), axis=0)\n\t    assert_(eq(y5, [0, 0, 1, 1, 2, 2, 3, 3]))\n\t    y6 = repeat(x4, 2, axis=0)\n\t    assert_(eq(y5, y6))\n\t\nTestMa().test_testCopySize()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPut(self):\n\t    d = arange(5)\n\t    n = [0, 0, 0, 1, 1]\n\t    m = make_mask(n)\n\t    m2 = m.copy()\n\t    x = array(d, mask=m)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is masked)\n\t    x[[1, 4]] = [10, 40]\n\t    assert_(x._mask is m)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is not masked)\n\t    assert_(eq(x, [0, 10, 2, -1, 40]))\n\t    x = array(d, mask=m2, copy=True)\n\t    x.put([0, 1, 2], [-1, 100, 200])\n\t    assert_(x._mask is not m2)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is masked)\n\t    assert_(eq(x, [-1, 100, 200, 0, 0]))\n\t\nTestMa().test_testPut()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPut2(self):\n\t    d = arange(5)\n\t    x = array(d, mask=[0, 0, 0, 0, 0])\n\t    z = array([10, 40], mask=[1, 0])\n\t    assert_(x[2] is not masked)\n\t    assert_(x[3] is not masked)\n\t    x[2:4] = z\n\t    assert_(x[2] is masked)\n\t    assert_(x[3] is not masked)\n\t    assert_(eq(x, [0, 1, 10, 40, 4]))\n\t    d = arange(5)\n\t    x = array(d, mask=[0, 0, 0, 0, 0])\n\t    y = x[2:4]\n\t    z = array([10, 40], mask=[1, 0])\n\t    assert_(x[2] is not masked)\n\t    assert_(x[3] is not masked)\n\t    y[:] = z\n\t    assert_(y[0] is masked)\n\t    assert_(y[1] is not masked)\n\t    assert_(eq(y, [10, 40]))\n\t    assert_(x[2] is masked)\n\t    assert_(x[3] is not masked)\n\t    assert_(eq(x, [0, 1, 10, 40, 4]))\n\t\nTestMa().test_testPut2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testOddFeatures(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_(eq(z.real, x))\n\t    assert_(eq(z.imag, 10 * x))\n\t    assert_(eq((z * conjugate(z)).real, 101 * x * x))\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = where(c, x, masked)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is masked)\n\t    assert_(z[7] is masked)\n\t    assert_(z[8] is not masked)\n\t    assert_(z[9] is not masked)\n\t    assert_(eq(x, z))\n\t    z = where(c, masked, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_(eq(x, z))\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    assert_(eq(masked_where(greater(x, 2), x), masked_greater(x, 2)))\n\t    assert_(eq(masked_where(greater_equal(x, 2), x), masked_greater_equal(x,\n\t        2)))\n\t    assert_(eq(masked_where(less(x, 2), x), masked_less(x, 2)))\n\t    assert_(eq(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2)))\n\t    assert_(eq(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2)))\n\t    assert_(eq(masked_where(equal(x, 2), x), masked_equal(x, 2)))\n\t    assert_(eq(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2)))\n\t    assert_(eq(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4]))\n\t    assert_(eq(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199]))\n\t    assert_(eq(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]), 1,\n\t        3).mask, [1, 1, 1, 1, 0]))\n\t    assert_(eq(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]), \n\t        1, 3).mask, [1, 1, 0, 0, 1]))\n\t    assert_(eq(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), 2)\n\t        .mask, [1, 0, 1, 0, 0]))\n\t    assert_(eq(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, 0]\n\t        ), 2).mask, [1, 0, 1, 0, 1]))\n\t    assert_(eq(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3, \n\t        4, 5]))\n\t    atest = ones((10, 10, 10), dtype=np.float32)\n\t    btest = zeros(atest.shape, MaskType)\n\t    ctest = masked_where(btest, atest)\n\t    assert_(eq(atest, ctest))\n\t    z = choose(c, (-x, x))\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    x = arange(6)\n\t    x[5] = masked\n\t    y = arange(6) * 10\n\t    y[2] = masked\n\t    c = array([1, 1, 1, 0, 0, 0], mask=[1, 0, 0, 0, 0, 0])\n\t    cm = c.filled(1)\n\t    z = where(c, x, y)\n\t    zm = where(cm, x, y)\n\t    assert_(eq(z, zm))\n\t    assert_(getmask(zm) is nomask)\n\t    assert_(eq(zm, [0, 1, 2, 30, 40, 50]))\n\t    z = where(c, masked, 1)\n\t    assert_(eq(z, [99, 99, 99, 1, 1, 1]))\n\t    z = where(c, 1, masked)\n\t    assert_(eq(z, [99, 1, 1, 99, 99, 99]))\n\t\nTestMa().test_testOddFeatures()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testMinMax2(self):\n\t    assert_(eq(minimum([1, 2, 3], [4, 0, 9]), [1, 0, 3]))\n\t    assert_(eq(maximum([1, 2, 3], [4, 0, 9]), [4, 2, 9]))\n\t    x = arange(5)\n\t    y = arange(5) - 2\n\t    x[3] = masked\n\t    y[0] = masked\n\t    assert_(eq(minimum(x, y), where(less(x, y), x, y)))\n\t    assert_(eq(maximum(x, y), where(greater(x, y), x, y)))\n\t    assert_(minimum.reduce(x) == 0)\n\t    assert_(maximum.reduce(x) == 4)\n\t\nTestMa().test_testMinMax2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testTakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_(eq(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1))))\n\t    assert_(eq(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1)))\n\t    assert_(eq(np.inner(filled(x, 0), filled(y, 0)), inner(x, y)))\n\t    assert_(eq(np.outer(filled(x, 0), filled(y, 0)), outer(x, y)))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMa().test_testTakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testInplace(self):\n\t    y = arange(10)\n\t    x = arange(10)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x += 1\n\t    assert_(eq(x, y + 1))\n\t    xm += 1\n\t    assert_(eq(x, y + 1))\n\t    x = arange(10)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x -= 1\n\t    assert_(eq(x, y - 1))\n\t    xm -= 1\n\t    assert_(eq(xm, y - 1))\n\t    x = arange(10) * 1.0\n\t    xm = arange(10) * 1.0\n\t    xm[2] = masked\n\t    x *= 2.0\n\t    assert_(eq(x, y * 2))\n\t    xm *= 2.0\n\t    assert_(eq(xm, y * 2))\n\t    x = arange(10) * 2\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x //= 2\n\t    assert_(eq(x, y))\n\t    xm //= 2\n\t    assert_(eq(x, y))\n\t    x = arange(10) * 1.0\n\t    xm = arange(10) * 1.0\n\t    xm[2] = masked\n\t    x /= 2.0\n\t    assert_(eq(x, y / 2.0))\n\t    xm /= arange(10)\n\t    assert_(eq(xm, ones((10,))))\n\t    x = arange(10).astype(np.float32)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x += 1.0\n\t    assert_(eq(x, y + 1.0))\n\t\nTestMa().test_testInplace()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPickle(self):\n\t    x = arange(12)\n\t    x[4:10:2] = masked\n\t    x = x.reshape(4, 3)\n\t    for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n\t        s = pickle.dumps(x, protocol=proto)\n\t        y = pickle.loads(s)\n\t        assert_(eq(x, y))\n\t\nTestMa().test_testPickle()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testAverage1(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    assert_(eq(2.0, average(ott, axis=0)))\n\t    assert_(eq(2.0, average(ott, weights=[1.0, 1.0, 2.0, 1.0])))\n\t    result, wts = average(ott, weights=[1.0, 1.0, 2.0, 1.0], returned=True)\n\t    assert_(eq(2.0, result))\n\t    assert_(wts == 4.0)\n\t    ott[:] = masked\n\t    assert_(average(ott, axis=0) is masked)\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    ott = ott.reshape(2, 2)\n\t    ott[:, 1] = masked\n\t    assert_(eq(average(ott, axis=0), [2.0, 0.0]))\n\t    assert_(average(ott, axis=1)[0] is masked)\n\t    assert_(eq([2.0, 0.0], average(ott, axis=0)))\n\t    result, wts = average(ott, axis=0, returned=True)\n\t    assert_(eq(wts, [1.0, 0.0]))\n\t\nTestMa().test_testAverage1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testAverage2(self):\n\t    w1 = [0, 1, 1, 1, 1, 0]\n\t    w2 = [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1]]\n\t    x = arange(6)\n\t    assert_(allclose(average(x, axis=0), 2.5))\n\t    assert_(allclose(average(x, axis=0, weights=w1), 2.5))\n\t    y = array([arange(6), 2.0 * arange(6)])\n\t    assert_(allclose(average(y, None), np.add.reduce(np.arange(6)) * 3.0 / \n\t        12.0))\n\t    assert_(allclose(average(y, axis=0), np.arange(6) * 3.0 / 2.0))\n\t    assert_(allclose(average(y, axis=1), [average(x, axis=0), average(x,\n\t        axis=0) * 2.0]))\n\t    assert_(allclose(average(y, None, weights=w2), 20.0 / 6.0))\n\t    assert_(allclose(average(y, axis=0, weights=w2), [0.0, 1.0, 2.0, 3.0, \n\t        4.0, 10.0]))\n\t    assert_(allclose(average(y, axis=1), [average(x, axis=0), average(x,\n\t        axis=0) * 2.0]))\n\t    m1 = zeros(6)\n\t    m2 = [0, 0, 1, 1, 0, 0]\n\t    m3 = [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]]\n\t    m4 = ones(6)\n\t    m5 = [0, 1, 1, 1, 1, 1]\n\t    assert_(allclose(average(masked_array(x, m1), axis=0), 2.5))\n\t    assert_(allclose(average(masked_array(x, m2), axis=0), 2.5))\n\t    assert_(average(masked_array(x, m4), axis=0) is masked)\n\t    assert_equal(average(masked_array(x, m5), axis=0), 0.0)\n\t    assert_equal(count(average(masked_array(x, m4), axis=0)), 0)\n\t    z = masked_array(y, m3)\n\t    assert_(allclose(average(z, None), 20.0 / 6.0))\n\t    assert_(allclose(average(z, axis=0), [0.0, 1.0, 99.0, 99.0, 4.0, 7.5]))\n\t    assert_(allclose(average(z, axis=1), [2.5, 5.0]))\n\t    assert_(allclose(average(z, axis=0, weights=w2), [0.0, 1.0, 99.0, 99.0,\n\t        4.0, 10.0]))\n\t    a = arange(6)\n\t    b = arange(6) * 3\n\t    r1, w1 = average([[a, b], [b, a]], axis=1, returned=True)\n\t    assert_equal(shape(r1), shape(w1))\n\t    assert_equal(r1.shape, w1.shape)\n\t    r2, w2 = average(ones((2, 2, 3)), axis=0, weights=[3, 1], returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), weights=ones((2, 2, 3)), returned=True)\n\t    assert_(shape(w2) == shape(r2))\n\t    a2d = array([[1, 2], [0, 4]], float)\n\t    a2dm = masked_array(a2d, [[0, 0], [1, 0]])\n\t    a2da = average(a2d, axis=0)\n\t    assert_(eq(a2da, [0.5, 3.0]))\n\t    a2dma = average(a2dm, axis=0)\n\t    assert_(eq(a2dma, [1.0, 3.0]))\n\t    a2dma = average(a2dm, axis=None)\n\t    assert_(eq(a2dma, 7.0 / 3.0))\n\t    a2dma = average(a2dm, axis=1)\n\t    assert_(eq(a2dma, [1.5, 4.0]))\n\t\nTestMa().test_testAverage2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testArrayMethods(self):\n\t    a = array([1, 3, 2])\n\t    assert_(eq(a.any(), a._data.any()))\n\t    assert_(eq(a.all(), a._data.all()))\n\t    assert_(eq(a.argmax(), a._data.argmax()))\n\t    assert_(eq(a.argmin(), a._data.argmin()))\n\t    assert_(eq(a.choose(0, 1, 2, 3, 4), a._data.choose(0, 1, 2, 3, 4)))\n\t    assert_(eq(a.compress([1, 0, 1]), a._data.compress([1, 0, 1])))\n\t    assert_(eq(a.conj(), a._data.conj()))\n\t    assert_(eq(a.conjugate(), a._data.conjugate()))\n\t    m = array([[1, 2], [3, 4]])\n\t    assert_(eq(m.diagonal(), m._data.diagonal()))\n\t    assert_(eq(a.sum(), a._data.sum()))\n\t    assert_(eq(a.take([1, 2]), a._data.take([1, 2])))\n\t    assert_(eq(m.transpose(), m._data.transpose()))\n\t\nTestMa().test_testArrayMethods()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestUfuncs():\n\tdef test_nonzero(self):\n\t    for t in '?bhilqpBHILQPfdgFDGO':\n\t        x = array([1, 0, 2, 0], mask=[0, 0, 1, 1])\n\t        assert_(eq(nonzero(x), [0]))\n\t\nTestUfuncs().test_nonzero()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}], "instruction": "Functionality: The eq function is designed to compare two input values (v and w) for equality with a tolerance, using the numpy.allclose function. It is particularly useful for comparing arrays or values that may have slight differences due to computational imprecision. If the values are not close enough to be considered equal, it prints a detailed message showing the values of v and w.\n\nInputs: \n1. v: The first value or array to be compared.\n2. w: The second value or array to be compared with the first.\n3. msg: An optional string message that can be printed if the comparison fails. It serves to provide context or additional information about the comparison.\n\nOutputs:\n1. result: A boolean value indicating whether the two input values are considered equal within a tolerance. True if they are close enough to be equal, False otherwise.", "method_code_mask": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\n\ndef eq(v, w, msg=''): [MASK]\n"}
{"method_name": "markinnerspaces", "full_method_name": "markinnerspaces", "method_path": "../srcdata/Computation/numpy/numpy/f2py/crackfortran.py", "method_code": "import sys\nimport string\nimport fileinput\nimport re\nimport os\nimport copy\nimport platform\nimport codecs\nfrom pathlib import Path\nimport charset_normalizer\ndef markinnerspaces(line):\n    \"\"\"\n    The function replace all spaces in the input variable line which are \n    surrounded with quotation marks, with the triplet \"@_@\".\n\n    For instance, for the input \"a 'b c'\" the function returns \"a 'b@_@c'\"\n\n    Parameters\n    ----------\n    line : str\n\n    Returns\n    -------\n    str\n\n    \"\"\"\n    fragment = ''\n    inside = False\n    current_quote = None\n    escaped = ''\n    for c in line:\n        if escaped == '\\\\' and c in ['\\\\', \"'\", '\"']:\n            fragment += c\n            escaped = c\n            continue\n        if not inside and c in [\"'\", '\"']:\n            current_quote = c\n        if c == current_quote:\n            inside = not inside\n        elif c == ' ' and inside:\n            fragment += '@_@'\n            continue\n        fragment += c\n        escaped = c\n    return fragment", "test_code_list": [{"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_do_not_touch_normal_spaces(self):\n\t    test_list = ['a ', ' a', 'a b c', \"'abcdefghij'\"]\n\t    for i in test_list:\n\t        assert markinnerspaces(i) == i\n\t\nTestMarkinnerspaces().test_do_not_touch_normal_spaces()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}, {"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_one_relevant_space(self):\n\t    assert markinnerspaces(\"a 'b c' \\\\' \\\\'\") == \"a 'b@_@c' \\\\' \\\\'\"\n\t    assert markinnerspaces('a \"b c\" \\\\\" \\\\\"') == 'a \"b@_@c\" \\\\\" \\\\\"'\n\t\nTestMarkinnerspaces().test_one_relevant_space()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}, {"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_ignore_inner_quotes(self):\n\t    assert markinnerspaces('a \\'b c\" \" d\\' e') == 'a \\'b@_@c\"@_@\"@_@d\\' e'\n\t    assert markinnerspaces('a \"b c\\' \\' d\" e') == 'a \"b@_@c\\'@_@\\'@_@d\" e'\n\t\nTestMarkinnerspaces().test_ignore_inner_quotes()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}], "instruction": "Functionality: The function markinnerspaces takes a string as input and replaces all spaces that are found inside quotation marks with the string \"@_@\". It correctly handles escaped characters and quotation marks within the string.\n\nInputs: \n- line : str - The input string that contains characters and potentially quotation marks and spaces.\n\nOutputs: \n- str - The modified string where spaces within quotation marks have been replaced with \"@_@\".", "method_code_mask": "import sys\nimport string\nimport fileinput\nimport re\nimport os\nimport copy\nimport platform\nimport codecs\nfrom pathlib import Path\nimport charset_normalizer\n\n\ndef markinnerspaces(line): [MASK]\n"}
{"method_name": "fft1", "full_method_name": "fft1", "method_path": "../srcdata/Computation/numpy/numpy/fft/tests/test_pocketfft.py", "method_code": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\ndef fft1(x):\n    L = len(x)\n    phase = -2.0j * np.pi * (np.arange(L) / L)\n    phase = np.arange(L).reshape(-1, 1) * phase\n    return np.sum(x * np.exp(phase), axis=1)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\n\nclass TestFFT1D():\n\tdef test_fft(self):\n\t    x = random(30) + 1.0j * random(30)\n\t    assert_allclose(fft1(x), np.fft.fft(x), atol=1e-06)\n\t    assert_allclose(fft1(x), np.fft.fft(x, norm='backward'), atol=1e-06)\n\t    assert_allclose(fft1(x) / np.sqrt(30), np.fft.fft(x, norm='ortho'),\n\t        atol=1e-06)\n\t    assert_allclose(fft1(x) / 30.0, np.fft.fft(x, norm='forward'), atol=1e-06)\n\t\nTestFFT1D().test_fft()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/fft/tests/test_pocketfft.py"}], "instruction": "Functionality: The fft1 function computes the Discrete Fourier Transform (DFT) of a given input signal using a fast Fourier transform (FFT) algorithm. It calculates the complex exponential function for each element of the input signal, multiplies it with the signal, and sums the results.\n\nInputs: \n- x: A 1D array-like input signal. It can be a list, tuple, or a 1D numpy array of real or complex numbers. The length of the input signal determines the size of the output.\n\nOutputs: \n- A 1D numpy array containing the complex DFT coefficients of the input signal. The size of the output array is the same as the size of the input array.", "method_code_mask": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\n\n\ndef fft1(x): [MASK]\n"}
{"method_name": "hermval", "full_method_name": "hermval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermval(x, c, tensor=True):\n    \"\"\"\n    Evaluate an Hermite series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    hermval2d, hermgrid2d, hermval3d, hermgrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermval\n    >>> coef = [1,2,3]\n    >>> hermval(1, coef)\n    11.0\n    >>> hermval([[1,2],[3,4]], coef)\n    array([[ 11.,   51.],\n           [115.,  203.]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    x2 = x * 2\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (2 * (nd - 1))\n            c1 = tmp + c1 * x2\n    return c0 + c1 * x2", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_hermvander(self):\n\t    x = np.arange(3)\n\t    v = herm.hermvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = herm.hermvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermval(x, coef))\n\t\nTestVander().test_hermvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_hermfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], -1)\n\t    assert_raises(TypeError, herm.hermfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], [-1])\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = herm.hermfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermval(x, coef3), y)\n\t    coef3 = herm.hermfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermval(x, coef3), y)\n\t    coef4 = herm.hermfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef4 = herm.hermfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef4 = herm.hermfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef2d = herm.hermfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = herm.hermfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = herm.hermfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = herm.hermfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = herm.hermfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = herm.hermfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(herm.hermfit(x, x, 1), [0, 0.5])\n\t    assert_almost_equal(herm.hermfit(x, x, [0, 1]), [0, 0.5])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = herm.hermfit(x, y, 4)\n\t    assert_almost_equal(hermval(x, coef1), y)\n\t    coef2 = herm.hermfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(hermval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_hermfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "instruction": "Functionality: Evaluate an Hermite series at points x using the Clenshaw recursion method.\n\nInputs: \n1. x : array_like, compatible object\n   - If x is a list or tuple, it gets converted to an ndarray. Otherwise, it is treated as a scalar.\n   - x or its elements must support addition and multiplication with themselves and with the elements of c.\n2. c : array_like\n   - Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n].\n   - If c is multidimensional, the remaining indices enumerate multiple polynomials.\n3. tensor : boolean, optional (default=True)\n   - If True, the shape of the coefficient array c is extended with ones on the right, one for each dimension of x.\n   - If False, x is broadcast over the columns of c for the evaluation.\n\nOutputs: \n1. values : ndarray, algebra_like\n   - The shape of the return value is described above in the documentation.\n   - It represents the evaluation of the Hermite series at points x.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermval(x, c, tensor=True): [MASK]\n"}
{"method_name": "polyval", "full_method_name": "polyval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef polyval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a polynomial at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value\n\n    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, compatible object\n        The shape of the returned array is described above.\n\n    See Also\n    --------\n    polyval2d, polygrid2d, polyval3d, polygrid3d\n\n    Notes\n    -----\n    The evaluation uses Horner's method.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.polynomial import polyval\n    >>> polyval(1, [1,2,3])\n    6.0\n    >>> a = np.arange(4).reshape(2,2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> polyval(a, [1, 2, 3])\n    array([[ 1.,   6.],\n           [17.,  34.]])\n    >>> coef = np.arange(4).reshape(2, 2)  # multidimensional coefficients\n    >>> coef\n    array([[0, 1],\n           [2, 3]])\n    >>> polyval([1, 2], coef, tensor=True)\n    array([[2.,  4.],\n           [4.,  7.]])\n    >>> polyval([1, 2], coef, tensor=False)\n    array([2.,  7.])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c + 0.0\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    c0 = c[-1] + x * 0\n    for i in range(2, len(c) + 1):\n        c0 = c[-i] + c0 * x\n    return c0", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestEvaluation():\n\tdef test_polyval(self):\n\t    assert_equal(polyval([], [1]).size, 0)\n\t    x = np.linspace(-1, 1)\n\t    y = [(x ** i) for i in range(5)]\n\t    for i in range(5):\n\t        tgt = y[i]\n\t        res = polyval(x, [0] * i + [1])\n\t        assert_almost_equal(res, tgt)\n\t    tgt = x * (x ** 2 - 1)\n\t    res = polyval(x, [0, -1, 0, 1])\n\t    assert_almost_equal(res, tgt)\n\t    for i in range(3):\n\t        dims = [2] * i\n\t        x = np.zeros(dims)\n\t        assert_equal(polyval(x, [1]).shape, dims)\n\t        assert_equal(polyval(x, [1, 0]).shape, dims)\n\t        assert_equal(polyval(x, [1, 0, 0]).shape, dims)\n\t    mask = [False, True, False]\n\t    mx = np.ma.array([1, 2, 3], mask=mask)\n\t    res = np.polyval([7, 5, 3], mx)\n\t    assert_array_equal(res.mask, mask)\n\t\n\t\n\t    class C(np.ndarray):\n\t        pass\n\t    cx = np.array([1, 2, 3]).view(C)\n\t    assert_equal(type(np.polyval([2, 3, 4], cx)), C)\n\t\nTestEvaluation().test_polyval()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestVander():\n\tdef test_polyvander(self):\n\t    x = np.arange(3)\n\t    v = poly.polyvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], polyval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = poly.polyvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], polyval(x, coef))\n\t\nTestVander().test_polyvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], -1)\n\t    assert_raises(TypeError, poly.polyfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], [-1])\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = poly.polyfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(polyval(x, coef3), y)\n\t    coef3 = poly.polyfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(polyval(x, coef3), y)\n\t    coef4 = poly.polyfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(polyval(x, coef4), y)\n\t    coef4 = poly.polyfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(polyval(x, coef4), y)\n\t    coef2d = poly.polyfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = poly.polyfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    yw[0::2] = 0\n\t    wcoef3 = poly.polyfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = poly.polyfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(poly.polyfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(poly.polyfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = poly.polyfit(x, y, 4)\n\t    assert_almost_equal(polyval(x, coef1), y)\n\t    coef2 = poly.polyfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(polyval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestMisc().test_polyfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "instruction": "Functionality: The polyval function evaluates a polynomial at specified points. It supports scalar and array inputs, multidimensional coefficients, and offers a tensor option for extended coefficient array shape.\n\nInputs: \n- x: The points at which the polynomial is evaluated. It can be an array-like object or a compatible object that supports addition and multiplication operations.\n- c: Array-like coefficients of the polynomial. The coefficients are ordered so that the coefficients for terms of degree n are contained in c[n]. Multidimensional coefficients enumerate multiple polynomials.\n- tensor: A boolean (default True) that determines the output shape when c is multidimensional. If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. If False, x is broadcast over the columns of c for the evaluation.\n\nOutputs:\n- values: An ndarray or a compatible object representing the evaluated polynomial at the input points x. The shape of the returned array depends on the input parameters, specifically the shape of x, c, and the tensor parameter.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyval(x, c, tensor=True): [MASK]\n"}
{"method_name": "hermline", "full_method_name": "hermline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermline(off, scl):\n    \"\"\"\n    Hermite series whose graph is a straight line.\n\n\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Hermite series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermline, hermval\n    >>> hermval(0,hermline(3, 2))\n    3.0\n    >>> hermval(1,hermline(3, 2))\n    5.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl / 2])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_hermline(self):\n\t    assert_equal(hermline(3, 4), [3, 2])\n\t\nTestMisc().test_hermline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "instruction": "Functionality: hermline(off, scl) is a function that generates the Hermite series representation of a straight line given by the equation 'off + scl*x'. This function is particularly useful in polynomial manipulation.\n\nInputs: \n- off: A scalar representing the offset or y-intercept of the line in the equation 'off + scl*x'.\n- scl: A scalar representing the slope of the line in the equation 'off + scl*x'. This parameter defines the rate of change of the line.\n\nOutputs:\n- y: An ndarray representing the Hermite series for the line defined by 'off + scl*x'. The output is the coefficients of the Hermite series that would give the same line when evaluated. If the slope 'scl' is not zero, the output will be an array with two elements representing the coefficients of the Hermite series. If 'scl' is zero, the output will be a single element array representing the constant term of the Hermite series. \n\nFor example:\n    >>> from numpy.polynomial.hermite import hermline, hermval\n    >>> print(hermline(3, 2))\n    array([3., 1.])\n    # Represents the Hermite series for the line y=3+2*x\n    >>> print(hermline(5, 0))\n    array([5.])\n    # Represents the Hermite series for the horizontal line y=5", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermline(off, scl): [MASK]\n"}
{"method_name": "hermweight", "full_method_name": "hermweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermweight(x):\n    \"\"\"\n    Weight function of the Hermite polynomials.\n\n    The weight function is :math:`\\\\exp(-x^2)` and the interval of\n    integration is :math:`[-\\\\inf, \\\\inf]`. the Hermite polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermweight\n    >>> x = np.arange(-2, 2)\n    >>> hermweight(x)\n    array([0.01831564, 0.36787944, 1.        , 0.36787944])\n\n    \"\"\"\n    w = np.exp(-x ** 2)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-5, 5, 11)\n\t    tgt = np.exp(-x ** 2)\n\t    res = hermweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "instruction": "Functionality: The hermweight function computes the weight function of the Hermite polynomials, which is defined as the exponential of the negative square of the input values. This weight function is crucial for the orthogonality property of Hermite polynomials over the interval from negative infinity to infinity.\n\nInputs: \n- x : array_like\n    A set of numeric values at which the weight function will be computed. This can be a single value or an array of values.\n\nOutputs: \n- w : ndarray\n    The calculated weight function values at the input points x. The shape of the output array will match the shape of the input array x.\n\nThe function implements the formula w(x) = exp(-x^2) to generate the weights for the given input values.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermweight(x): [MASK]\n"}
{"method_name": "trimseq", "full_method_name": "trimseq", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polyutils.py", "method_code": "import operator\nimport functools\nimport warnings\nimport numpy as np\ndef trimseq(seq):\n    \"\"\"Remove small Poly series coefficients.\n\n    Parameters\n    ----------\n    seq : sequence\n        Sequence of Poly series coefficients.\n\n    Returns\n    -------\n    series : sequence\n        Subsequence with trailing zeros removed. If the resulting sequence\n        would be empty, return the first element. The returned sequence may\n        or may not be a view.\n\n    Notes\n    -----\n    Do not lose the type info if the sequence contains unknown objects.\n\n    \"\"\"\n    if len(seq) == 0 or seq[-1] != 0:\n        return seq\n    else:\n        for i in range(len(seq) - 1, -1, -1):\n            if seq[i] != 0:\n                break\n        return seq[:i + 1]", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_trimseq(self):\n\t    tgt = [1]\n\t    for num_trailing_zeros in range(5):\n\t        res = trimseq([1] + [0] * num_trailing_zeros)\n\t        assert_equal(res, tgt)\n\t\nTestMisc().test_trimseq()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}, {"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_trimseq_empty_input(self):\n\t    for empty_seq in [[], np.array([], dtype=np.int32)]:\n\t        assert_equal(trimseq(empty_seq), empty_seq)\n\t\nTestMisc().test_trimseq_empty_input()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}], "instruction": "Functionality: The trimseq function is designed to remove trailing small or zero coefficients from a sequence representing Poly series coefficients. This ensures that the sequence does not contain unnecessary trailing zeros, which can be indicative of small or insignificant coefficients in polynomial expressions.\n\nInputs: \n- seq: A sequence (such as a list or array) of coefficients for a Poly series. These coefficients can be any numerical values or objects, and the sequence can be of any length.\n\nOutputs:\n- series: A new sequence with trailing zeros removed. If removing trailing zeros results in an empty sequence, the function returns the first element of the original sequence. The returned sequence might be a view of the original sequence or a new sequence, depending on the implementation details.\n  \nNote: The function must preserve the type information of the objects in the sequence if they are not numerical values. This means that if the sequence contains objects of unknown types, the function should not alter their type or representation.\n", "method_code_mask": "import operator\nimport functools\nimport warnings\nimport numpy as np\n\n\ndef trimseq(seq): [MASK]\n"}
{"method_name": "mapparms", "full_method_name": "mapparms", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polyutils.py", "method_code": "import operator\nimport functools\nimport warnings\nimport numpy as np\ndef mapparms(old, new):\n    \"\"\"\n    Linear map parameters between domains.\n\n    Return the parameters of the linear map ``offset + scale*x`` that maps\n    `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.\n\n    Parameters\n    ----------\n    old, new : array_like\n        Domains. Each domain must (successfully) convert to a 1-d array\n        containing precisely two values.\n\n    Returns\n    -------\n    offset, scale : scalars\n        The map ``L(x) = offset + scale*x`` maps the first domain to the\n        second.\n\n    See Also\n    --------\n    getdomain, mapdomain\n\n    Notes\n    -----\n    Also works for complex numbers, and thus can be used to calculate the\n    parameters required to map any line in the complex plane to any other\n    line therein.\n\n    Examples\n    --------\n    >>> from numpy.polynomial import polyutils as pu\n    >>> pu.mapparms((-1,1),(-1,1))\n    (0.0, 1.0)\n    >>> pu.mapparms((1,-1),(-1,1))\n    (-0.0, -1.0)\n    >>> i = complex(0,1)\n    >>> pu.mapparms((-i,-1),(1,i))\n    ((1+1j), (1-0j))\n\n    \"\"\"\n    oldlen = old[1] - old[0]\n    newlen = new[1] - new[0]\n    off = (old[1] * new[0] - old[0] * new[1]) / oldlen\n    scl = newlen / oldlen\n    return off, scl", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestDomain():\n\tdef test_mapparms(self):\n\t    dom1 = [0, 4]\n\t    dom2 = [1, 3]\n\t    tgt = [1, 0.5]\n\t    res = mapparms(dom1, dom2)\n\t    assert_almost_equal(res, tgt)\n\t    dom1 = [0 - 1.0j, 2 + 1.0j]\n\t    dom2 = [-2, 2]\n\t    tgt = [-1 + 1.0j, 1 - 1.0j]\n\t    res = mapparms(dom1, dom2)\n\t    assert_almost_equal(res, tgt)\n\t\nTestDomain().test_mapparms()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}], "instruction": "Functionality: Linear map parameters between domains.\n\nThe 'mapparms' function is designed to calculate the parameters for a linear map that transforms one domain (old) to another domain (new) such that specific points in the old domain are mapped to corresponding points in the new domain. Specifically, it finds the offset and scale factors for the linear transformation L(x) = offset + scale*x, ensuring that old[i] maps to new[i] for i = 0, 1.\n\nInputs: \n- old, new : array_like\n  Two domains specified as array_like objects. Each domain must be convertible to a 1-dimensional array containing exactly two values. These domains can represent ranges of real numbers or complex numbers.\n\nOutputs:\n- offset, scale : scalars\n  The function returns two scalars, 'offset' and 'scale', which define the linear transformation required to map the 'old' domain to the 'new' domain. The transformation is given by L(x) = offset + scale*x. These parameters are suitable for mapping any line in the complex plane to any other line therein.", "method_code_mask": "import operator\nimport functools\nimport warnings\nimport numpy as np\n\n\ndef mapparms(old, new): [MASK]\n"}
{"method_name": "lagval", "full_method_name": "lagval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/laguerre.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef lagval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Laguerre series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    lagval2d, laggrid2d, lagval3d, laggrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.laguerre import lagval\n    >>> coef = [1, 2, 3]\n    >>> lagval(1, coef)\n    -0.5\n    >>> lagval([[1, 2],[3, 4]], coef)\n    array([[-0.5, -4. ],\n           [-4.5, -2. ]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1) / nd\n            c1 = tmp + c1 * (2 * nd - 1 - x) / nd\n    return c0 + c1 * (1 - x)", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_lagvander(self):\n\t    x = np.arange(3)\n\t    v = lag.lagvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], lagval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = lag.lagvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], lagval(x, coef))\n\t\nTestVander().test_lagvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_lagfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], -1)\n\t    assert_raises(TypeError, lag.lagfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], [-1])\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = lag.lagfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(lagval(x, coef3), y)\n\t    coef3 = lag.lagfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(lagval(x, coef3), y)\n\t    coef4 = lag.lagfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(lagval(x, coef4), y)\n\t    coef4 = lag.lagfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(lagval(x, coef4), y)\n\t    coef2d = lag.lagfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = lag.lagfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = lag.lagfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = lag.lagfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = lag.lagfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = lag.lagfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(lag.lagfit(x, x, 1), [1, -1])\n\t    assert_almost_equal(lag.lagfit(x, x, [0, 1]), [1, -1])\n\t\nTestFitting().test_lagfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}], "instruction": "Functionality: Evaluate a Laguerre series at points x using the Clenshaw recursion method. The function computes the value of a polynomial represented in the Laguerre basis at given points x. The polynomial is defined by its coefficients c, and the evaluation can be performed for scalar or array-like inputs, with an option to control the output shape for multidimensional coefficients.\n\nInputs: \nx : array_like, compatible object\n    If x is a list or tuple, it is converted to an ndarray, otherwise, it is treated as a scalar. In either case, x or its elements must support addition and multiplication with themselves and with the elements of c.\nc : array_like\n    Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If c is multidimensional, the remaining indices enumerate multiple polynomials.\ntensor : boolean, optional (default True)\n    If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x. If False, x is broadcast over the columns of c for the evaluation.\n\nOutputs:\nvalues : ndarray, algebra_like\n    The return value shape depends on the input parameters. If tensor is True, the shape is c.shape[1:] + x.shape; if False, it's c.shape[1:]. The result is an array of values representing the evaluated Laguerre series at the given points x.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef lagval(x, c, tensor=True): [MASK]\n"}
{"method_name": "lagweight", "full_method_name": "lagweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/laguerre.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef lagweight(x):\n    \"\"\"Weight function of the Laguerre polynomials.\n\n    The weight function is :math:`exp(-x)` and the interval of integration\n    is :math:`[0, \\\\inf]`. The Laguerre polynomials are orthogonal, but not\n    normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    Examples\n    --------\n    >>> from numpy.polynomial.laguerre import lagweight\n    >>> x = np.array([0, 1, 2])\n    >>> lagweight(x)\n    array([1.        , 0.36787944, 0.13533528])\n\n    \"\"\"\n    w = np.exp(-x)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(0, 10, 11)\n\t    tgt = np.exp(-x)\n\t    res = lagweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}], "instruction": "Functionality: The Laguerre weight function computes the weight function of the Laguerre polynomials, which is given by the formula exp(-x). The function is designed to be used over the interval [0, infinity], where the Laguerre polynomials are orthogonal but not normalized with respect to this weight function.\n\nInputs: \nx : array_like\n    A set of values at which the weight function will be computed.\n\nOutputs:\nw : ndarray\n    The computed weight function at each value of x, resulting in an array where each element corresponds to the weight function evaluated at each value provided in x.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef lagweight(x): [MASK]\n"}
{"method_name": "_cseries_to_zseries", "full_method_name": "_cseries_to_zseries", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef _cseries_to_zseries(c):\n    \"\"\"Convert Chebyshev series to z-series.\n\n    Convert a Chebyshev series to the equivalent z-series. The result is\n    never an empty array. The dtype of the return is the same as that of\n    the input. No checks are run on the arguments as this routine is for\n    internal use.\n\n    Parameters\n    ----------\n    c : 1-D ndarray\n        Chebyshev coefficients, ordered from low to high\n\n    Returns\n    -------\n    zs : 1-D ndarray\n        Odd length symmetric z-series, ordered from  low to high.\n\n    \"\"\"\n    n = c.size\n    zs = np.zeros(2 * n - 1, dtype=c.dtype)\n    zs[n - 1:] = c / 2\n    return zs + zs[::-1]", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestPrivate():\n\tdef test__cseries_to_zseries(self):\n\t    for i in range(5):\n\t        inp = np.array([2] + [1] * i, np.double)\n\t        tgt = np.array([0.5] * i + [2] + [0.5] * i, np.double)\n\t        res = _cseries_to_zseries(inp)\n\t        assert_equal(res, tgt)\n\t\nTestPrivate().test__cseries_to_zseries()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: The function _cseries_to_zseries is designed to convert a Chebyshev series to the equivalent z-series. It ensures the output is never empty and maintains the same data type as the input. This function is intended for internal use and performs the conversion without running any checks on the arguments.\n\nInputs: \n- c : A 1-D ndarray containing Chebyshev coefficients. The coefficients are ordered from low to high.\n\nOutputs: \n- zs : A 1-D ndarray representing the odd length symmetric z-series, also ordered from low to high. The size of this array is 2 * n - 1, where n is the size of the input array. The first half of this array (up to the middle element) contains the converted Chebyshev coefficients divided by 2, while the rest is a mirror image of the first half.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef _cseries_to_zseries(c): [MASK]\n"}
{"method_name": "_zseries_to_cseries", "full_method_name": "_zseries_to_cseries", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef _zseries_to_cseries(zs):\n    \"\"\"Convert z-series to a Chebyshev series.\n\n    Convert a z series to the equivalent Chebyshev series. The result is\n    never an empty array. The dtype of the return is the same as that of\n    the input. No checks are run on the arguments as this routine is for\n    internal use.\n\n    Parameters\n    ----------\n    zs : 1-D ndarray\n        Odd length symmetric z-series, ordered from  low to high.\n\n    Returns\n    -------\n    c : 1-D ndarray\n        Chebyshev coefficients, ordered from  low to high.\n\n    \"\"\"\n    n = (zs.size + 1) // 2\n    c = zs[n - 1:].copy()\n    c[1:n] *= 2\n    return c", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestPrivate():\n\tdef test__zseries_to_cseries(self):\n\t    for i in range(5):\n\t        inp = np.array([0.5] * i + [2] + [0.5] * i, np.double)\n\t        tgt = np.array([2] + [1] * i, np.double)\n\t        res = _zseries_to_cseries(inp)\n\t        assert_equal(res, tgt)\n\t\nTestPrivate().test__zseries_to_cseries()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: Convert z-series to a Chebyshev series.\nInputs: zs -- A 1-D ndarray representing an odd length symmetric z-series, ordered from low to high.\nOutputs: c -- A 1-D ndarray representing Chebyshev coefficients, ordered from low to high. The dtype of the return is the same as that of the input. The result is never an empty array.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef _zseries_to_cseries(zs): [MASK]\n"}
{"method_name": "chebval", "full_method_name": "chebval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef chebval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Chebyshev series at points x.\n\n    If `c` is of length `n + 1`, this function returns the value:\n\n    .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    chebval2d, chebgrid2d, chebval3d, chebgrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=True)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        x2 = 2 * x\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            c0 = c[-i] - c1\n            c1 = tmp + c1 * x2\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_chebvander(self):\n\t    x = np.arange(3)\n\t    v = cheb.chebvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], chebval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = cheb.chebvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], chebval(x, coef))\n\t\nTestVander().test_chebvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_chebfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], -1)\n\t    assert_raises(TypeError, cheb.chebfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], [-1])\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = cheb.chebfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(chebval(x, coef3), y)\n\t    coef3 = cheb.chebfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(chebval(x, coef3), y)\n\t    coef4 = cheb.chebfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef4 = cheb.chebfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef4 = cheb.chebfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef2d = cheb.chebfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = cheb.chebfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = cheb.chebfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = cheb.chebfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = cheb.chebfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = cheb.chebfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(cheb.chebfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(cheb.chebfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = cheb.chebfit(x, y, 4)\n\t    assert_almost_equal(chebval(x, coef1), y)\n\t    coef2 = cheb.chebfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(chebval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_chebfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestInterpolate():\n\tdef test_approximation(self):\n\t\n\t    def powx(x, p):\n\t        return x ** p\n\t    x = np.linspace(-1, 1, 10)\n\t    for deg in range(0, 10):\n\t        for p in range(0, deg + 1):\n\t            c = cheb.chebinterpolate(powx, deg, (p,))\n\t            assert_almost_equal(chebval(x, c), powx(x, p), decimal=12)\n\t\nTestInterpolate().test_approximation()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: The chebval function evaluates a Chebyshev series at one or more points. The Chebyshev series is represented by the coefficients `c`, and the evaluation is performed at the points given by `x`. The function supports both scalar and array inputs for `x`, and multidimensional coefficients `c`. It uses Clenshaw recursion (also known as synthetic division) for efficient evaluation.\n\nInputs: \n1. x : array_like, compatible object - The points at which the Chebyshev series is to be evaluated. If `x` is a list or tuple, it is converted to an ndarray, otherwise, it is treated as a scalar.\n2. c : array_like - The coefficients of the Chebyshev series, ordered so that the coefficient for terms of degree n are contained in `c[n]`. If `c` is multidimensional, the remaining indices enumerate multiple polynomials.\n3. tensor : boolean, optional - If True, the shape of the coefficient array `c` is extended with ones on the right, one for each dimension of `x`. This results in every column of coefficients in `c` being evaluated for every element of `x`. If False, `x` is broadcast over the columns of `c`. The default value is True.\n\nOutputs: \n1. values : ndarray or algebra_like - The result of evaluating the Chebyshev series at the points specified by `x`. The shape of the return value depends on the value of `tensor` and the shapes of `c` and `x`.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebval(x, c, tensor=True): [MASK]\n"}
{"method_name": "chebline", "full_method_name": "chebline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef chebline(off, scl):\n    \"\"\"\n    Chebyshev series whose graph is a straight line.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Chebyshev series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> import numpy.polynomial.chebyshev as C\n    >>> C.chebline(3,2)\n    array([3, 2])\n    >>> C.chebval(-3, C.chebline(3,2)) # should be -3\n    -3.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_chebline(self):\n\t    assert_equal(chebline(3, 4), [3, 4])\n\t\nTestMisc().test_chebline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: The chebline function generates a Chebyshev series that represents a straight line defined by the equation off + scl*x, where 'off' is the offset and 'scl' is the slope.\n\nInputs: \n- off, scl : scalars\n  The 'off' and 'scl' parameters are used to define the straight line as 'off + scl*x'. Both 'off' and 'scl' are scalars, with 'off' representing the y-intercept of the line and 'scl' representing its slope.\n\nOutputs:\n- y : ndarray\n  The function returns an array representing the Chebyshev series for the given line 'off + scl*x'. If 'scl' is not equal to 0, the array will contain two elements: the first element is 'off' and the second is 'scl'. If 'scl' is 0, the array will contain only one element, which is 'off'.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebline(off, scl): [MASK]\n"}
{"method_name": "chebweight", "full_method_name": "chebweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef chebweight(x):\n    \"\"\"\n    The weight function of the Chebyshev polynomials.\n\n    The weight function is :math:`1/\\\\sqrt{1 - x^2}` and the interval of\n    integration is :math:`[-1, 1]`. The Chebyshev polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = 1.0 / (np.sqrt(1.0 + x) * np.sqrt(1.0 - x))\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-1, 1, 11)[1:-1]\n\t    tgt = 1.0 / (np.sqrt(1 + x) * np.sqrt(1 - x))\n\t    res = chebweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: The chebweight function calculates the weight function of the Chebyshev polynomials, which is defined as 1/sqrt(1 - x^2), for a given set of input values.\n\nInputs: \nx : array_like\n   Values at which the weight function will be computed. This can be a single value, a list, or a numpy array.\n\nOutputs: \nw : ndarray\n   The weight function at each value in x, returned as a numpy array. The shape of the output will match the shape of the input x.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebweight(x): [MASK]\n"}
{"method_name": "chebpts1", "full_method_name": "chebpts1", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef chebpts1(npts):\n    \"\"\"\n    Chebyshev points of the first kind.\n\n    The Chebyshev points of the first kind are the points ``cos(x)``,\n    where ``x = [pi*(k + .5)/npts for k in range(npts)]``.\n\n    Parameters\n    ----------\n    npts : int\n        Number of sample points desired.\n\n    Returns\n    -------\n    pts : ndarray\n        The Chebyshev points of the first kind.\n\n    See Also\n    --------\n    chebpts2\n\n    Notes\n    -----\n\n    .. versionadded:: 1.5.0\n\n    \"\"\"\n    _npts = int(npts)\n    if _npts != npts:\n        raise ValueError('npts must be integer')\n    if _npts < 1:\n        raise ValueError('npts must be >= 1')\n    x = 0.5 * np.pi / _npts * np.arange(-_npts + 1, _npts + 1, 2)\n    return np.sin(x)", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_chebpts1(self):\n\t    assert_raises(ValueError, chebpts1, 1.5)\n\t    assert_raises(ValueError, chebpts1, 0)\n\t    tgt = [0]\n\t    assert_almost_equal(chebpts1(1), tgt)\n\t    tgt = [-0.7071067811865475, 0.7071067811865475]\n\t    assert_almost_equal(chebpts1(2), tgt)\n\t    tgt = [-0.8660254037844387, 0, 0.8660254037844387]\n\t    assert_almost_equal(chebpts1(3), tgt)\n\t    tgt = [-0.9238795325, -0.3826834323, 0.3826834323, 0.9238795325]\n\t    assert_almost_equal(chebpts1(4), tgt)\n\t\nTestMisc().test_chebpts1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "instruction": "Functionality: This function calculates the Chebyshev points of the first kind, which are used in numerical analysis for polynomial interpolation and quadrature. The points are determined by the cosine of angles derived from the input parameter.\n\nInputs:\n- npts: An integer specifying the number of sample points desired. It must be a positive integer value.\n\nOutputs:\n- pts: A NumPy ndarray containing the Chebyshev points of the first kind. These points are calculated as the sine of angles that are derived from the input parameter npts, following a specific formula.\n\nNote: The function raises a ValueError if npts is not an integer or if it is less than 1.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebpts1(npts): [MASK]\n"}
{"method_name": "polyvalfromroots", "full_method_name": "polyvalfromroots", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef polyvalfromroots(x, r, tensor=True):\n    \"\"\"\n    Evaluate a polynomial specified by its roots at points x.\n\n    If `r` is of length ``N``, this function returns the value\n\n    .. math:: p(x) = \\\\prod_{n=1}^{N} (x - r_n)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `r`.\n\n    If `r` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If `r`\n    is multidimensional, then the shape of the result depends on the value of\n    `tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;\n    that is, each polynomial is evaluated at every value of `x`. If `tensor` is\n    ``False``, the shape will be r.shape[1:]; that is, each polynomial is\n    evaluated only for the corresponding broadcast value of `x`. Note that\n    scalars have shape (,).\n\n    .. versionadded:: 1.12\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `r`.\n    r : array_like\n        Array of roots. If `r` is multidimensional the first index is the\n        root index, while the remaining indices enumerate multiple\n        polynomials. For instance, in the two dimensional case the roots\n        of each polynomial may be thought of as stored in the columns of `r`.\n    tensor : boolean, optional\n        If True, the shape of the roots array is extended with ones on the\n        right, one for each dimension of `x`. Scalars have dimension 0 for this\n        action. The result is that every column of coefficients in `r` is\n        evaluated for every element of `x`. If False, `x` is broadcast over the\n        columns of `r` for the evaluation.  This keyword is useful when `r` is\n        multidimensional. The default value is True.\n\n    Returns\n    -------\n    values : ndarray, compatible object\n        The shape of the returned array is described above.\n\n    See Also\n    --------\n    polyroots, polyfromroots, polyval\n\n    Examples\n    --------\n    >>> from numpy.polynomial.polynomial import polyvalfromroots\n    >>> polyvalfromroots(1, [1, 2, 3])\n    0.0\n    >>> a = np.arange(4).reshape(2, 2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> polyvalfromroots(a, [-1, 0, 1])\n    array([[-0.,   0.],\n           [ 6.,  24.]])\n    >>> r = np.arange(-2, 2).reshape(2,2)  # multidimensional coefficients\n    >>> r # each column of r defines one polynomial\n    array([[-2, -1],\n           [ 0,  1]])\n    >>> b = [-2, 1]\n    >>> polyvalfromroots(b, r, tensor=True)\n    array([[-0.,  3.],\n           [ 3., 0.]])\n    >>> polyvalfromroots(b, r, tensor=False)\n    array([-0.,  0.])\n\n    \"\"\"\n    r = np.array(r, ndmin=1, copy=None)\n    if r.dtype.char in '?bBhHiIlLqQpP':\n        r = r.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray):\n        if tensor:\n            r = r.reshape(r.shape + (1,) * x.ndim)\n        elif x.ndim >= r.ndim:\n            raise ValueError('x.ndim must be < r.ndim when tensor == False')\n    return np.prod(x - r, axis=0)", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestEvaluation():\n\tdef test_polyvalfromroots(self):\n\t    assert_raises(ValueError, polyvalfromroots, [1], [1], tensor=False)\n\t    assert_equal(polyvalfromroots([], [1]).size, 0)\n\t    assert_(polyvalfromroots([], [1]).shape == (0,))\n\t    assert_equal(polyvalfromroots([], [[1] * 5]).size, 0)\n\t    assert_(polyvalfromroots([], [[1] * 5]).shape == (5, 0))\n\t    assert_equal(polyvalfromroots(1, 1), 0)\n\t    assert_(polyvalfromroots(1, np.ones((3, 3))).shape == (3,))\n\t    x = np.linspace(-1, 1)\n\t    y = [(x ** i) for i in range(5)]\n\t    for i in range(1, 5):\n\t        tgt = y[i]\n\t        res = polyvalfromroots(x, [0] * i)\n\t        assert_almost_equal(res, tgt)\n\t    tgt = x * (x - 1) * (x + 1)\n\t    res = polyvalfromroots(x, [-1, 0, 1])\n\t    assert_almost_equal(res, tgt)\n\t    for i in range(3):\n\t        dims = [2] * i\n\t        x = np.zeros(dims)\n\t        assert_equal(polyvalfromroots(x, [1]).shape, dims)\n\t        assert_equal(polyvalfromroots(x, [1, 0]).shape, dims)\n\t        assert_equal(polyvalfromroots(x, [1, 0, 0]).shape, dims)\n\t    ptest = [15, 2, -16, -2, 1]\n\t    r = poly.polyroots(ptest)\n\t    x = np.linspace(-1, 1)\n\t    assert_almost_equal(poly.polyval(x, ptest), polyvalfromroots(x, r))\n\t    rshape = 3, 5\n\t    x = np.arange(-3, 2)\n\t    r = np.random.randint(-5, 5, size=rshape)\n\t    res = polyvalfromroots(x, r, tensor=False)\n\t    tgt = np.empty(r.shape[1:])\n\t    for ii in range(tgt.size):\n\t        tgt[ii] = polyvalfromroots(x[ii], r[:, ii])\n\t    assert_equal(res, tgt)\n\t    x = np.vstack([x, 2 * x])\n\t    res = polyvalfromroots(x, r, tensor=True)\n\t    tgt = np.empty(r.shape[1:] + x.shape)\n\t    for ii in range(r.shape[1]):\n\t        for jj in range(x.shape[0]):\n\t            tgt[ii, jj, :] = polyvalfromroots(x[jj], r[:, ii])\n\t    assert_equal(res, tgt)\n\t\nTestEvaluation().test_polyvalfromroots()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "instruction": "Functionality: Evaluate a polynomial specified by its roots at points x. The function calculates the product of (x - r_n) for n from 1 to N, where N is the length of the roots array 'r'.\n\nInputs:\n- x: array_like, compatible object. If x is a list or tuple, it is converted to an ndarray, otherwise it is treated as a scalar. In either case, x or its elements must support addition and multiplication with themselves and with the elements of r.\n- r: array_like. Array of roots. If r is multidimensional, the first index is the root index, while the remaining indices enumerate multiple polynomials.\n- tensor: boolean, optional. If True, the shape of the roots array is extended with ones on the right, one for each dimension of x. Scalars have dimension 0 for this action. The result is that every column of coefficients in r is evaluated for every element of x. If False, x is broadcast over the columns of r for the evaluation. The default value is True.\n\nOutputs:\n- values: ndarray, compatible object. The shape of the returned array varies based on the input arguments and the value of the 'tensor' keyword. Specifically, if 'tensor' is True, the shape will be r.shape[1:] + x.shape; if 'tensor' is False, the shape will be r.shape[1:]. In either case, the output represents the evaluated polynomial at points x.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyvalfromroots(x, r, tensor=True): [MASK]\n"}
{"method_name": "polyline", "full_method_name": "polyline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef polyline(off, scl):\n    \"\"\"\n    Returns an array representing a linear polynomial.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The \"y-intercept\" and \"slope\" of the line, respectively.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the linear polynomial ``off +\n        scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> from numpy.polynomial import polynomial as P\n    >>> P.polyline(1, -1)\n    array([ 1, -1])\n    >>> P.polyval(1, P.polyline(1, -1))  # should be 0\n    0.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyline(self):\n\t    assert_equal(polyline(3, 4), [3, 4])\n\t\nTestMisc().test_polyline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyline_zero(self):\n\t    assert_equal(polyline(3, 0), [3])\n\t\nTestMisc().test_polyline_zero()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "instruction": "Functionality: The polyline function generates an array that represents a linear polynomial with given y-intercept and slope.\n\nInputs: \n1. off: scalar, the y-intercept of the line.\n2. scl: scalar, the slope of the line.\n\nOutputs: \n1. y: ndarray, an array that represents the linear polynomial defined by `off + scl*x`. If the slope is 0, the output will be a single-element array containing only the y-intercept.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyline(off, scl): [MASK]\n"}
{"method_name": "hermeval", "full_method_name": "hermeval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermeval(x, c, tensor=True):\n    \"\"\"\n    Evaluate an HermiteE series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    hermeval2d, hermegrid2d, hermeval3d, hermegrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite_e import hermeval\n    >>> coef = [1,2,3]\n    >>> hermeval(1, coef)\n    3.0\n    >>> hermeval([[1,2],[3,4]], coef)\n    array([[ 3., 14.],\n           [31., 54.]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1)\n            c1 = tmp + c1 * x\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_hermevander(self):\n\t    x = np.arange(3)\n\t    v = herme.hermevander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermeval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = herme.hermevander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermeval(x, coef))\n\t\nTestVander().test_hermevander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_hermefit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], -1)\n\t    assert_raises(TypeError, herme.hermefit, [[1]], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], [-1])\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = herme.hermefit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermeval(x, coef3), y)\n\t    coef3 = herme.hermefit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermeval(x, coef3), y)\n\t    coef4 = herme.hermefit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef4 = herme.hermefit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef4 = herme.hermefit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef2d = herme.hermefit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = herme.hermefit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = herme.hermefit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = herme.hermefit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = herme.hermefit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = herme.hermefit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(herme.hermefit(x, x, 1), [0, 1])\n\t    assert_almost_equal(herme.hermefit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = herme.hermefit(x, y, 4)\n\t    assert_almost_equal(hermeval(x, coef1), y)\n\t    coef2 = herme.hermefit(x, y, [0, 2, 4])\n\t    assert_almost_equal(hermeval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_hermefit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "instruction": "Functionality: Evaluate a HermiteE series at points x using the Clenshaw recursion method for efficient computation. The HermiteE series is a series expansion of a function in terms of the HermiteE polynomials. The function supports scalar inputs and arrays, with options to handle multidimensional coefficient arrays.\n\nInputs: \n- x: An array-like object or a compatible object that can be converted to an ndarray, representing the points at which the HermiteE series is evaluated. This can be a scalar or an array.\n- c: An array-like object containing the coefficients of the HermiteE series. The coefficients are ordered so that the coefficient for terms of degree n are contained in c[n]. If c is multidimensional, the remaining indices enumerate multiple polynomials.\n- tensor: A boolean value. If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of x, allowing every column of coefficients in c to be evaluated for every element of x. If False, x is broadcast over the columns of c for the evaluation. Default is True.\n\nOutputs:\n- values: An ndarray or algebra-like object that contains the evaluated HermiteE series. The shape of the return value is determined by the parameters: if tensor is True, the shape is c.shape[1:] + x.shape; if tensor is False, the shape is c.shape[1:]. Scalars have shape (,).", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeval(x, c, tensor=True): [MASK]\n"}
{"method_name": "hermeline", "full_method_name": "hermeline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermeline(off, scl):\n    \"\"\"\n    Hermite series whose graph is a straight line.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Hermite series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite_e import hermeline\n    >>> from numpy.polynomial.hermite_e import hermeline, hermeval\n    >>> hermeval(0,hermeline(3, 2))\n    3.0\n    >>> hermeval(1,hermeline(3, 2))\n    5.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_hermeline(self):\n\t    assert_equal(hermeline(3, 4), [3, 4])\n\t\nTestMisc().test_hermeline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "instruction": "Functionality: The hermeline function generates a Hermite series whose graph is a straight line defined by the equation 'off + scl*x'. This function is part of a module that deals with Hermite series and is used to create a Hermite series representation of a linear function.\n\nInputs:\n- off: A scalar representing the offset or y-intercept of the line.\n- scl: A scalar representing the slope of the line.\n\nOutputs:\n- y: An ndarray representing the Hermite series coefficients for the line 'off + scl*x'. If the slope 'scl' is not equal to 0, the output is an array with two elements [off, scl]. If 'scl' is 0, the output is a single-element array [off], indicating a horizontal line.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeline(off, scl): [MASK]\n"}
{"method_name": "hermeweight", "full_method_name": "hermeweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef hermeweight(x):\n    \"\"\"Weight function of the Hermite_e polynomials.\n\n    The weight function is :math:`\\\\exp(-x^2/2)` and the interval of\n    integration is :math:`[-\\\\inf, \\\\inf]`. the HermiteE polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = np.exp(-0.5 * x ** 2)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-5, 5, 11)\n\t    tgt = np.exp(-0.5 * x ** 2)\n\t    res = hermeweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "instruction": "Functionality: The hermeweight function computes the weight function of the Hermite_e polynomials, which is \\exp(-x^2/2). The HermiteE polynomials are orthogonal with respect to this weight function over the interval of integration that spans from negative infinity to positive infinity. However, they are not normalized with respect to this weight.\n\nInputs: \n- x : array_like\n    A set of values at which the weight function is to be computed.\n\nOutputs:\n- w : ndarray\n    The computed weight function at each value in `x`.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeweight(x): [MASK]\n"}
{"method_name": "legval", "full_method_name": "legval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef legval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Legendre series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    legval2d, leggrid2d, legval3d, leggrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1) / nd\n            c1 = tmp + c1 * x * (2 * nd - 1) / nd\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_legvander(self):\n\t    x = np.arange(3)\n\t    v = leg.legvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], legval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = leg.legvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], legval(x, coef))\n\t\nTestVander().test_legvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_legfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, leg.legfit, [1], [1], -1)\n\t    assert_raises(TypeError, leg.legfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, leg.legfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, leg.legfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, leg.legfit, [1], [1], [-1])\n\t    assert_raises(ValueError, leg.legfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, leg.legfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = leg.legfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(legval(x, coef3), y)\n\t    coef3 = leg.legfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(legval(x, coef3), y)\n\t    coef4 = leg.legfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef4 = leg.legfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef4 = leg.legfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef2d = leg.legfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = leg.legfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = leg.legfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = leg.legfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = leg.legfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = leg.legfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(leg.legfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(leg.legfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = leg.legfit(x, y, 4)\n\t    assert_almost_equal(legval(x, coef1), y)\n\t    coef2 = leg.legfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(legval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_legfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "instruction": "Functionality: Evaluate a Legendre polynomial series at points x using the Clenshaw recursion method. This function can handle scalar inputs or arrays of inputs and supports multidimensional coefficients.\n\nInputs: \n1. x - an array-like object or a scalar value. If `x` is a list or tuple, it gets converted to an ndarray. `x` or its elements must support addition and multiplication with themselves and the elements of `c`.\n2. c - an array-like object containing the coefficients of the Legendre polynomial series. The coefficients are ordered so that the coefficients for terms of degree n are contained in `c[n]`.\n3. tensor - a boolean flag (default is True). If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of `x`. This results in every column of coefficients in `c` being evaluated for every element of `x`. If False, `x` is broadcasted over the columns of `c`.\n\nOutputs:\n1. values - a multidimensional array or scalar (depending on the shape and type of inputs) representing the evaluated Legendre polynomial series. The shape of the output depends on the input arrays and the `tensor` flag.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legval(x, c, tensor=True): [MASK]\n"}
{"method_name": "legline", "full_method_name": "legline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef legline(off, scl):\n    \"\"\"\n    Legendre series whose graph is a straight line.\n\n\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Legendre series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> import numpy.polynomial.legendre as L\n    >>> L.legline(3,2)\n    array([3, 2])\n    >>> L.legval(-3, L.legline(3,2)) # should be -3\n    -3.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_legline(self):\n\t    assert_equal(legline(3, 4), [3, 4])\n\t\nTestMisc().test_legline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_legline_zeroscl(self):\n\t    assert_equal(legline(3, 0), [3])\n\t\nTestMisc().test_legline_zeroscl()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "instruction": "Functionality: The legline function generates the coefficients of a Legendre series that represents a straight line defined by the equation off + scl*x.\n\nInputs: \n- off: A scalar that represents the offset of the line.\n- scl: A scalar that represents the slope of the line.\n\nOutputs: \n- y: An ndarray that represents the coefficients of the Legendre series for the line defined by off + scl*x. The output array will contain two elements: the first element is the offset (off), and the second element is the slope (scl), unless the slope is 0, in which case the output will be a single-element array containing only the offset.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legline(off, scl): [MASK]\n"}
{"method_name": "legweight", "full_method_name": "legweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "method_code": "import numpy as np\nimport numpy.linalg as la\ndef legweight(x):\n    \"\"\"\n    Weight function of the Legendre polynomials.\n\n    The weight function is :math:`1` and the interval of integration is\n    :math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not\n    normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = x * 0.0 + 1.0\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-1, 1, 11)\n\t    tgt = 1.0\n\t    res = legweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "instruction": "Functionality: Implement the weight function of the Legendre polynomials.\nInputs: \n   x : array_like\n       Values at which the weight function will be computed. This input is an array of numbers where the weight function will be evaluated.\nOutputs: \n   w : ndarray\n       The weight function at `x`. This output is an array of the same shape as `x`, containing the values of the weight function at each point in `x`.\n\nThe weight function for the Legendre polynomials is defined to be a constant value of 1 on the interval [-1, 1]. This function is crucial for the orthogonal property of the Legendre polynomials. Note, the function does not normalize the values, it merely computes the weight.", "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legweight(x): [MASK]\n"}
{"method_name": "drop_metadata", "full_method_name": "drop_metadata", "method_path": "../srcdata/Computation/numpy/numpy/lib/_utils_impl.py", "method_code": "import os\nimport sys\nimport textwrap\nimport types\nimport re\nimport warnings\nimport functools\nimport platform\nimport numpy as np\nfrom pprint import pprint\nfrom threadpoolctl import threadpool_info\nimport numpy\nimport pydoc\nimport inspect\nimport ast\ndef drop_metadata(dtype, /):\n    \"\"\"\n    Returns the dtype unchanged if it contained no metadata or a copy of the\n    dtype if it (or any of its structure dtypes) contained metadata.\n\n    This utility is used by `np.save` and `np.savez` to drop metadata before\n    saving.\n\n    .. note::\n\n        Due to its limitation this function may move to a more appropriate\n        home or change in the future and is considered semi-public API only.\n\n    .. warning::\n\n        This function does not preserve more strange things like record dtypes\n        and user dtypes may simply return the wrong thing.  If you need to be\n        sure about the latter, check the result with:\n        ``np.can_cast(new_dtype, dtype, casting=\"no\")``.\n\n    \"\"\"\n    if dtype.fields is not None:\n        found_metadata = dtype.metadata is not None\n        names = []\n        formats = []\n        offsets = []\n        titles = []\n        for name, field in dtype.fields.items():\n            field_dt = drop_metadata(field[0])\n            if field_dt is not field[0]:\n                found_metadata = True\n            names.append(name)\n            formats.append(field_dt)\n            offsets.append(field[1])\n            titles.append(None if len(field) < 3 else field[2])\n        if not found_metadata:\n            return dtype\n        structure = dict(names=names, formats=formats, offsets=offsets,\n            titles=titles, itemsize=dtype.itemsize)\n        return np.dtype(structure, align=dtype.isalignedstruct)\n    elif dtype.subdtype is not None:\n        subdtype, shape = dtype.subdtype\n        new_subdtype = drop_metadata(subdtype)\n        if dtype.metadata is None and new_subdtype is subdtype:\n            return dtype\n        return np.dtype((new_subdtype, shape))\n    else:\n        if dtype.metadata is None:\n            return dtype\n        return np.dtype(dtype.str)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_raises_regex\nfrom io import StringIO\ndef test_drop_metadata():\n\n    def _compare_dtypes(dt1, dt2):\n        return np.can_cast(dt1, dt2, casting='no')\n    dt = np.dtype([('l1', [('l2', np.dtype('S8', metadata={'msg': 'toto'}))\n        ])], metadata={'msg': 'titi'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    assert dt_m['l1'].metadata is None\n    assert dt_m['l1']['l2'].metadata is None\n    dt = np.dtype([('x', '<f8'), ('y', '<i4')], align=True, metadata={'msg':\n        'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    dt = np.dtype('8f', metadata={'msg': 'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    dt = np.dtype('uint32', metadata={'msg': 'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n\ntest_drop_metadata()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_utils.py"}], "instruction": "Functionality: The drop_metadata function is designed to clean up a given data type (dtype) by removing any metadata it contains. If the input dtype contains no metadata, it is returned unchanged. If the dtype contains metadata, either directly or within any of its structure dtypes, a copy of the dtype is returned with all metadata removed. This function is particularly useful for preparing dtypes for saving with numpy's save functions, as metadata may not be compatible with the saving process.\n\nInputs:\n- dtype: A numpy data type object. This can be a simple type (like int, float, etc.) or a structured type with fields, subtypes, or metadata.\n\nOutputs:\n- The original dtype object if it does not contain any metadata.\n- A copy of the dtype object with all metadata removed if the original dtype contained metadata. This includes metadata in any structured fields or subtypes.", "method_code_mask": "import os\nimport sys\nimport textwrap\nimport types\nimport re\nimport warnings\nimport functools\nimport platform\nimport numpy as np\nfrom pprint import pprint\nfrom threadpoolctl import threadpool_info\nimport numpy\nimport pydoc\nimport inspect\nimport ast\n\n\ndef drop_metadata(dtype, /): [MASK]\n"}
{"method_name": "get_mat", "full_method_name": "get_mat", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py", "method_code": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\ndef get_mat(n):\n    data = np.arange(n)\n    data = np.add.outer(data, data)\n    return data", "test_code_list": [{"test_code": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\nclass TestFlip():\n\tdef test_basic_lr(self):\n\t    a = get_mat(4)\n\t    b = a[:, ::-1]\n\t    assert_equal(np.flip(a, 1), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[2, 1, 0], [5, 4, 3]]\n\t    assert_equal(np.flip(a, 1), b)\n\t\nTestFlip().test_basic_lr()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py"}, {"test_code": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\nclass TestFlip():\n\tdef test_basic_ud(self):\n\t    a = get_mat(4)\n\t    b = a[::-1, :]\n\t    assert_equal(np.flip(a, 0), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[3, 4, 5], [0, 1, 2]]\n\t    assert_equal(np.flip(a, 0), b)\n\t\nTestFlip().test_basic_ud()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py"}], "instruction": "Functionality: The 'get_mat' function is designed to generate a square matrix of size 'n' x 'n'. This matrix is constructed by performing an outer addition operation on a one-dimensional array of numbers ranging from 0 to 'n-1'. The result is a two-dimensional array where the value at position (i, j) is the sum of 'i' and 'j', both being the indices of the original one-dimensional array.\n\nInputs: \n- n: An integer representing the size of the matrix. It indicates both the number of rows and the number of columns in the resulting square matrix.\n\nOutputs: \n- A numpy ndarray of shape ('n', 'n'), where the value at each position (i, j) is the sum of 'i' and 'j'. This array is the result of performing an outer addition operation on a sequence of numbers ranging from 0 to 'n-1'.", "method_code_mask": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\n\ndef get_mat(n): [MASK]\n"}
{"method_name": "easy_dtype", "full_method_name": "easy_dtype", "method_path": "../srcdata/Computation/numpy/numpy/lib/_iotools.py", "method_code": "import numpy as np\ndef easy_dtype(ndtype, names=None, defaultfmt='f%i', **validationargs):\n    \"\"\"\n    Convenience function to create a `np.dtype` object.\n\n    The function processes the input `dtype` and matches it with the given\n    names.\n\n    Parameters\n    ----------\n    ndtype : var\n        Definition of the dtype. Can be any string or dictionary recognized\n        by the `np.dtype` function, or a sequence of types.\n    names : str or sequence, optional\n        Sequence of strings to use as field names for a structured dtype.\n        For convenience, `names` can be a string of a comma-separated list\n        of names.\n    defaultfmt : str, optional\n        Format string used to define missing names, such as ``\"f%i\"``\n        (default) or ``\"fields_%02i\"``.\n    validationargs : optional\n        A series of optional arguments used to initialize a\n        `NameValidator`.\n\n    Examples\n    --------\n    >>> np.lib._iotools.easy_dtype(float)\n    dtype('float64')\n    >>> np.lib._iotools.easy_dtype(\"i4, f8\")\n    dtype([('f0', '<i4'), ('f1', '<f8')])\n    >>> np.lib._iotools.easy_dtype(\"i4, f8\", defaultfmt=\"field_%03i\")\n    dtype([('field_000', '<i4'), ('field_001', '<f8')])\n\n    >>> np.lib._iotools.easy_dtype((int, float, float), names=\"a,b,c\")\n    dtype([('a', '<i8'), ('b', '<f8'), ('c', '<f8')])\n    >>> np.lib._iotools.easy_dtype(float, names=\"a,b,c\")\n    dtype([('a', '<f8'), ('b', '<f8'), ('c', '<f8')])\n\n    \"\"\"\n    try:\n        ndtype = np.dtype(ndtype)\n    except TypeError:\n        validate = NameValidator(**validationargs)\n        nbfields = len(ndtype)\n        if names is None:\n            names = [''] * len(ndtype)\n        elif isinstance(names, str):\n            names = names.split(',')\n        names = validate(names, nbfields=nbfields, defaultfmt=defaultfmt)\n        ndtype = np.dtype(dict(formats=ndtype, names=names))\n    else:\n        if names is not None:\n            validate = NameValidator(**validationargs)\n            if isinstance(names, str):\n                names = names.split(',')\n            if ndtype.names is None:\n                formats = tuple([ndtype.type] * len(names))\n                names = validate(names, defaultfmt=defaultfmt)\n                ndtype = np.dtype(list(zip(names, formats)))\n            else:\n                ndtype.names = validate(names, nbfields=len(ndtype.names),\n                    defaultfmt=defaultfmt)\n        elif ndtype.names is not None:\n            validate = NameValidator(**validationargs)\n            numbered_names = tuple('f%i' % i for i in range(len(ndtype.names)))\n            if ndtype.names == numbered_names and defaultfmt != 'f%i':\n                ndtype.names = validate([''] * len(ndtype.names),\n                    defaultfmt=defaultfmt)\n            else:\n                ndtype.names = validate(ndtype.names, defaultfmt=defaultfmt)\n    return ndtype", "test_code_list": [{"test_code": "import time\nfrom datetime import date\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_raises\nfrom numpy.lib._iotools import LineSplitter\nfrom numpy.lib._iotools import NameValidator\nfrom numpy.lib._iotools import StringConverter\nfrom numpy.lib._iotools import has_nested_fields\nfrom numpy.lib._iotools import easy_dtype\nfrom numpy.lib._iotools import flatten_dtype\n\nclass TestMiscFunctions():\n\tdef test_easy_dtype(self):\n\t    \"\"\"Test ndtype on dtypes\"\"\"\n\t    ndtype = float\n\t    assert_equal(easy_dtype(ndtype), np.dtype(float))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('f0', 'i4'), ('f1', 'f8')]))\n\t    assert_equal(easy_dtype(ndtype, defaultfmt='field_%03i'), np.dtype([(\n\t        'field_000', 'i4'), ('field_001', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names='a, b'), np.dtype([('a', 'i4'), (\n\t        'b', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([('a', 'i4'),\n\t        ('b', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names=', b'), np.dtype([('f0', 'i4'), (\n\t        'b', 'f8')]))\n\t    assert_equal(easy_dtype(ndtype, names='a', defaultfmt='f%02i'), np.\n\t        dtype([('a', 'i4'), ('f00', 'f8')]))\n\t    ndtype = [('A', int), ('B', float)]\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('A', int), ('B', float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a,b'), np.dtype([('a', int), (\n\t        'b', float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a'), np.dtype([('a', int), ('f0',\n\t        float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a,b,c'), np.dtype([('a', int), (\n\t        'b', float)]))\n\t    ndtype = int, float, float\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('f0', int), ('f1', float),\n\t        ('f2', float)]))\n\t    ndtype = int, float, float\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([('a', int),\n\t        ('b', float), ('c', float)]))\n\t    ndtype = np.dtype(float)\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([(_, float) for\n\t        _ in ('a', 'b', 'c')]))\n\t    ndtype = np.dtype(float)\n\t    assert_equal(easy_dtype(ndtype, names=['', '', ''], defaultfmt='f%02i'),\n\t        np.dtype([(_, float) for _ in ('f00', 'f01', 'f02')]))\n\t\nTestMiscFunctions().test_easy_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test__iotools.py"}], "instruction": "Functionality: Create and process a numpy dtype (data type) object with convenience features for handling field names and formats.\n\nInputs:\n- ndtype: Definition of the dtype. Can be any string or dictionary recognized by the np.dtype function, or a sequence of types.\n- names: Optional. Sequence of strings to use as field names for a structured dtype. Can also be a single string with comma-separated names.\n- defaultfmt: Optional. Format string used to define missing names, such as \"f%i\" (default) or \"fields_%02i\".\n- validationargs: Optional. Additional arguments used to initialize a `NameValidator`.\n\nOutputs:\n- Returns a processed np.dtype object. The dtype is structured based on the inputs provided, including field names and formats.", "method_code_mask": "import numpy as np\n\n\ndef easy_dtype(ndtype, names=None, defaultfmt='f%i', **validationargs): [MASK]\n"}
{"method_name": "flatten_dtype", "full_method_name": "flatten_dtype", "method_path": "../srcdata/Computation/numpy/numpy/lib/_iotools.py", "method_code": "import numpy as np\ndef flatten_dtype(ndtype, flatten_base=False):\n    \"\"\"\n    Unpack a structured data-type by collapsing nested fields and/or fields\n    with a shape.\n\n    Note that the field names are lost.\n\n    Parameters\n    ----------\n    ndtype : dtype\n        The datatype to collapse\n    flatten_base : bool, optional\n       If True, transform a field with a shape into several fields. Default is\n       False.\n\n    Examples\n    --------\n    >>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n    ...                ('block', int, (2, 3))])\n    >>> np.lib._iotools.flatten_dtype(dt)\n    [dtype('S4'), dtype('float64'), dtype('float64'), dtype('int64')]\n    >>> np.lib._iotools.flatten_dtype(dt, flatten_base=True)\n    [dtype('S4'),\n     dtype('float64'),\n     dtype('float64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64')]\n\n    \"\"\"\n    names = ndtype.names\n    if names is None:\n        if flatten_base:\n            return [ndtype.base] * int(np.prod(ndtype.shape))\n        return [ndtype.base]\n    else:\n        types = []\n        for field in names:\n            info = ndtype.fields[field]\n            flat_dt = flatten_dtype(info[0], flatten_base)\n            types.extend(flat_dt)\n        return types", "test_code_list": [{"test_code": "import time\nfrom datetime import date\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_raises\nfrom numpy.lib._iotools import LineSplitter\nfrom numpy.lib._iotools import NameValidator\nfrom numpy.lib._iotools import StringConverter\nfrom numpy.lib._iotools import has_nested_fields\nfrom numpy.lib._iotools import easy_dtype\nfrom numpy.lib._iotools import flatten_dtype\n\nclass TestMiscFunctions():\n\tdef test_flatten_dtype(self):\n\t    \"\"\"Testing flatten_dtype\"\"\"\n\t    dt = np.dtype([('a', 'f8'), ('b', 'f8')])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, float])\n\t    dt = np.dtype([('a', [('aa', '|S1'), ('ab', '|S2')]), ('b', int)])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [np.dtype('|S1'), np.dtype('|S2'), int])\n\t    dt = np.dtype([('a', (float, 2)), ('b', (int, 3))])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, int])\n\t    dt_flat = flatten_dtype(dt, True)\n\t    assert_equal(dt_flat, [float] * 2 + [int] * 3)\n\t    dt = np.dtype([(('a', 'A'), 'f8'), (('b', 'B'), 'f8')])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, float])\n\t\nTestMiscFunctions().test_flatten_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test__iotools.py"}], "instruction": "Functionality: The function 'flatten_dtype' is designed to unpack and simplify a structured data-type by collapsing nested fields and/or fields with a shape. This is particularly useful when dealing with complex numpy data types that contain multiple nested fields or fields with shapes. The function allows for the transformation of fields with shapes into multiple fields if the 'flatten_base' parameter is set to True. Note that this process does not preserve field names, focusing solely on the data types.\n\nInputs: \n- ndtype : dtype\n  The numpy datatype to be flattened. This should be a numpy dtype object.\n- flatten_base : bool, optional\n  A flag that indicates whether to transform a field with a shape into several fields. The default is False, meaning fields with shapes will not be expanded into multiple fields.\n\nOutputs:\n- A list of dtype objects\n  The output is a list where each element is a dtype object representing a flattened element from the input ndtype. If 'flatten_base' is True, fields with shapes are expanded into multiple dtype objects in the list. If 'flatten_base' is False, fields with shapes are not expanded and are represented as a single dtype object in the list.", "method_code_mask": "import numpy as np\n\n\ndef flatten_dtype(ndtype, flatten_base=False): [MASK]\n"}
{"method_name": "get_mat", "full_method_name": "get_mat", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py", "method_code": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\ndef get_mat(n):\n    data = arange(n)\n    data = add.outer(data, data)\n    return data", "test_code_list": [{"test_code": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\nclass TestFliplr():\n\tdef test_basic(self):\n\t    assert_raises(ValueError, fliplr, ones(4))\n\t    a = get_mat(4)\n\t    b = a[:, ::-1]\n\t    assert_equal(fliplr(a), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[2, 1, 0], [5, 4, 3]]\n\t    assert_equal(fliplr(a), b)\n\t\nTestFliplr().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py"}, {"test_code": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\nclass TestFlipud():\n\tdef test_basic(self):\n\t    a = get_mat(4)\n\t    b = a[::-1, :]\n\t    assert_equal(flipud(a), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[3, 4, 5], [0, 1, 2]]\n\t    assert_equal(flipud(a), b)\n\t\nTestFlipud().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py"}], "instruction": "Functionality: The get_mat function is designed to generate a square matrix of size n x n, where each element [i, j] is the sum of the indices i and j. This is accomplished by creating an array of numbers from 0 to n-1, and then using the outer product operation to add every pair of these numbers. The resulting matrix will have symmetrical values around the diagonal.\n\nInputs: \n- n: An integer representing the size of the square matrix to be created. The matrix will have dimensions n x n.\n\nOutputs:\n- A 2D numpy array of shape (n, n) where each element [i, j] is the sum of i and j. The array is the outer sum of two arrays of size n, which effectively creates a matrix where each row and each column is a sequence of numbers from 0 to 2*(n-1).", "method_code_mask": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\n\ndef get_mat(n): [MASK]\n"}
{"method_name": "_add_keepdims", "full_method_name": "_add_keepdims", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py", "method_code": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\ndef _add_keepdims(func):\n    \"\"\" hack in keepdims behavior into a function taking an axis \"\"\"\n\n    @functools.wraps(func)\n    def wrapped(a, axis, **kwargs):\n        res = func(a, axis=axis, **kwargs)\n        if axis is None:\n            axis = 0\n        return np.expand_dims(res, axis=axis)\n    return wrapped", "test_code_list": [{"test_code": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\nclass TestTakeAlongAxis():\n\tdef test_argequivalent(self):\n\t    \"\"\" Test it translates from arg<func> to <func> \"\"\"\n\t    from numpy.random import rand\n\t    a = rand(3, 4, 5)\n\t    funcs = [(np.sort, np.argsort, dict()), (_add_keepdims(np.min),\n\t        _add_keepdims(np.argmin), dict()), (_add_keepdims(np.max),\n\t        _add_keepdims(np.argmax), dict())]\n\t    for func, argfunc, kwargs in funcs:\n\t        for axis in (list(range(a.ndim)) + [None]):\n\t            a_func = func(a, axis=axis, **kwargs)\n\t            ai_func = argfunc(a, axis=axis, **kwargs)\n\t            assert_equal(a_func, take_along_axis(a, ai_func, axis=axis))\n\t\nTestTakeAlongAxis().test_argequivalent()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py"}, {"test_code": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\nclass TestPutAlongAxis():\n\tdef test_replace_max(self):\n\t    a_base = np.array([[10, 30, 20], [60, 40, 50]])\n\t    for axis in (list(range(a_base.ndim)) + [None]):\n\t        a = a_base.copy()\n\t        i_max = _add_keepdims(np.argmax)(a, axis=axis)\n\t        put_along_axis(a, i_max, -99, axis=axis)\n\t        i_min = _add_keepdims(np.argmin)(a, axis=axis)\n\t        assert_equal(i_min, i_max)\n\t\nTestPutAlongAxis().test_replace_max()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py"}], "instruction": "Functionality: The _add_keepdims function is a decorator that modifies any given function (func) to include keepdims behavior. It ensures that the output of func retains the same number of dimensions as the input array (a), by adding a dimension of size 1 at the specified axis if the function reduces the dimensionality of the input array.\n\nInputs: \n- a: The input array on which the decorated function will operate.\n- axis: The axis along which the operation is applied. If axis is None, the function will operate on the flattened array, and then a dimension of size 1 will be added at axis=0 in the output.\n- **kwargs: Additional keyword arguments to pass to the decorated function.\n\nOutputs: \n- res: The result of applying the decorated function (func) on the input array (a). If the operation reduces the dimensionality of the input, a dimension of size 1 is added at the specified axis to match the input's dimensionality.", "method_code_mask": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\n\ndef _add_keepdims(func): [MASK]\n"}
{"method_name": "roundtrip", "full_method_name": "roundtrip", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_format.py", "method_code": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\ndef roundtrip(arr):\n    f = BytesIO()\n    format.write_array(f, arr)\n    f2 = BytesIO(f.getvalue())\n    arr2 = format.read_array(f2, allow_pickle=True)\n    return arr2", "test_code_list": [{"test_code": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\ndef test_long_str():\n    long_str_arr = np.ones(1, dtype=np.dtype((str, format.BUFFER_SIZE + 1)))\n    long_str_arr2 = roundtrip(long_str_arr)\n    assert_array_equal(long_str_arr, long_str_arr2)\n\ntest_long_str()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_format.py"}], "instruction": "Functionality: The roundtrip function simulates writing a given NumPy array to a file-like object in a specific format and then reads it back to verify the integrity of the data after serialization and deserialization. The function takes an input NumPy array, writes it to a BytesIO object using the NumPy's format module, then reads the array back from the BytesIO object and returns the read array.\n\nInputs: \n- arr: A NumPy array of any dimension and data type.\n\nOutputs: \n- arr2: The NumPy array that has been read back from the BytesIO object. The function checks if arr2 is equal to the original array arr in terms of shape and values, to ensure the data has been successfully written and read back without any loss or change.", "method_code_mask": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\n\n\ndef roundtrip(arr): [MASK]\n"}
{"method_name": "_replace_nan", "full_method_name": "_replace_nan", "method_path": "../srcdata/Computation/numpy/numpy/lib/_nanfunctions_impl.py", "method_code": "import functools\nimport warnings\nimport numpy as np\ndef _replace_nan(a, val):\n    \"\"\"\n    If `a` is of inexact type, make a copy of `a`, replace NaNs with\n    the `val` value, and return the copy together with a boolean mask\n    marking the locations where NaNs were present. If `a` is not of\n    inexact type, do nothing and return `a` together with a mask of None.\n\n    Note that scalars will end up as array scalars, which is important\n    for using the result as the value of the out argument in some\n    operations.\n\n    Parameters\n    ----------\n    a : array-like\n        Input array.\n    val : float\n        NaN values are set to val before doing the operation.\n\n    Returns\n    -------\n    y : ndarray\n        If `a` is of inexact type, return a copy of `a` with the NaNs\n        replaced by the fill value, otherwise return `a`.\n    mask: {bool, None}\n        If `a` is of inexact type, return a boolean mask marking locations of\n        NaNs, otherwise return None.\n\n    \"\"\"\n    a = np.asanyarray(a)\n    if a.dtype == np.object_:\n        mask = np.not_equal(a, a, dtype=bool)\n    elif issubclass(a.dtype.type, np.inexact):\n        mask = np.isnan(a)\n    else:\n        mask = None\n    if mask is not None:\n        a = np.array(a, subok=True, copy=True)\n        np.copyto(a, val, where=mask)\n    return a, mask", "test_code_list": [{"test_code": "import warnings\nimport pytest\nimport inspect\nfrom functools import partial\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import suppress_warnings\ndef test__replace_nan():\n    \"\"\" Test that _replace_nan returns the original array if there are no\n    NaNs, not a copy.\n    \"\"\"\n    for dtype in [np.bool, np.int32, np.int64]:\n        arr = np.array([0, 1], dtype=dtype)\n        result, mask = _replace_nan(arr, 0)\n        assert mask is None\n        assert result is arr\n    for dtype in [np.float32, np.float64]:\n        arr = np.array([0, 1], dtype=dtype)\n        result, mask = _replace_nan(arr, 2)\n        assert (mask == False).all()\n        assert result is not arr\n        assert_equal(result, arr)\n        arr_nan = np.array([0, 1, np.nan], dtype=dtype)\n        result_nan, mask_nan = _replace_nan(arr_nan, 2)\n        assert_equal(mask_nan, np.array([False, False, True]))\n        assert result_nan is not arr_nan\n        assert_equal(result_nan, np.array([0, 1, 2]))\n        assert np.isnan(arr_nan[-1])\n\ntest__replace_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_nanfunctions.py"}], "instruction": "Functionality: The function '_replace_nan' is designed to handle NaN (Not a Number) values in an input array 'a'. If 'a' contains inexact types (floating point numbers), the function replaces NaNs with a specified value 'val' and returns a copy of the array with NaNs replaced, along with a boolean mask indicating the locations where NaNs were originally present. If 'a' does not contain inexact types, the function returns 'a' as is, along with None as the mask.\n\nInputs: \n- a : array-like\n    Input array that may contain NaNs.\n- val : float\n    The value that will replace NaNs in the array.\n\nOutputs: \n- y : ndarray\n    If 'a' is of inexact type, this is a copy of 'a' with NaNs replaced by 'val'. If 'a' is not of inexact type, this is simply 'a' itself.\n- mask: {bool, None}\n    If 'a' is of inexact type, this is a boolean mask where True indicates the original location of NaNs in the input array. If 'a' is not of inexact type, this is None.", "method_code_mask": "import functools\nimport warnings\nimport numpy as np\n\n\ndef _replace_nan(a, val): [MASK]\n"}
{"method_name": "_as_pairs", "full_method_name": "_as_pairs", "method_path": "../srcdata/Computation/numpy/numpy/lib/_arraypad_impl.py", "method_code": "import numpy as np\ndef _as_pairs(x, ndim, as_index=False):\n    \"\"\"\n    Broadcast `x` to an array with the shape (`ndim`, 2).\n\n    A helper function for `pad` that prepares and validates arguments like\n    `pad_width` for iteration in pairs.\n\n    Parameters\n    ----------\n    x : {None, scalar, array-like}\n        The object to broadcast to the shape (`ndim`, 2).\n    ndim : int\n        Number of pairs the broadcasted `x` will have.\n    as_index : bool, optional\n        If `x` is not None, try to round each element of `x` to an integer\n        (dtype `np.intp`) and ensure every element is positive.\n\n    Returns\n    -------\n    pairs : nested iterables, shape (`ndim`, 2)\n        The broadcasted version of `x`.\n\n    Raises\n    ------\n    ValueError\n        If `as_index` is True and `x` contains negative elements.\n        Or if `x` is not broadcastable to the shape (`ndim`, 2).\n    \"\"\"\n    if x is None:\n        return ((None, None),) * ndim\n    x = np.array(x)\n    if as_index:\n        x = np.round(x).astype(np.intp, copy=False)\n    if x.ndim < 3:\n        if x.size == 1:\n            x = x.ravel()\n            if as_index and x < 0:\n                raise ValueError(\"index can't contain negative values\")\n            return ((x[0], x[0]),) * ndim\n        if x.size == 2 and x.shape != (2, 1):\n            x = x.ravel()\n            if as_index and (x[0] < 0 or x[1] < 0):\n                raise ValueError(\"index can't contain negative values\")\n            return ((x[0], x[1]),) * ndim\n    if as_index and x.min() < 0:\n        raise ValueError(\"index can't contain negative values\")\n    return np.broadcast_to(x, (ndim, 2)).tolist()", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_single_value(self):\n\t    \"\"\"Test casting for a single value.\"\"\"\n\t    expected = np.array([[3, 3]] * 10)\n\t    for x in (3, [3], [[3]]):\n\t        result = _as_pairs(x, 10)\n\t        assert_equal(result, expected)\n\t    obj = object()\n\t    assert_equal(_as_pairs(obj, 10), np.array([[obj, obj]] * 10))\n\t\nTestAsPairs().test_single_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_two_values(self):\n\t    \"\"\"Test proper casting for two different values.\"\"\"\n\t    expected = np.array([[3, 4]] * 10)\n\t    for x in ([3, 4], [[3, 4]]):\n\t        result = _as_pairs(x, 10)\n\t        assert_equal(result, expected)\n\t    obj = object()\n\t    assert_equal(_as_pairs(['a', obj], 10), np.array([['a', obj]] * 10))\n\t    assert_equal(_as_pairs([[3], [4]], 2), np.array([[3, 3], [4, 4]]))\n\t    assert_equal(_as_pairs([['a'], [obj]], 2), np.array([['a', 'a'], [obj,\n\t        obj]]))\n\t\nTestAsPairs().test_two_values()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_with_none(self):\n\t    expected = (None, None), (None, None), (None, None)\n\t    assert_equal(_as_pairs(None, 3, as_index=False), expected)\n\t    assert_equal(_as_pairs(None, 3, as_index=True), expected)\n\t\nTestAsPairs().test_with_none()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_pass_through(self):\n\t    \"\"\"Test if `x` already matching desired output are passed through.\"\"\"\n\t    expected = np.arange(12).reshape((6, 2))\n\t    assert_equal(_as_pairs(expected, 6), expected)\n\t\nTestAsPairs().test_pass_through()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_as_index(self):\n\t    \"\"\"Test results if `as_index=True`.\"\"\"\n\t    assert_equal(_as_pairs([2.6, 3.3], 10, as_index=True), np.array([[3, 3]\n\t        ] * 10, dtype=np.intp))\n\t    assert_equal(_as_pairs([2.6, 4.49], 10, as_index=True), np.array([[3, 4\n\t        ]] * 10, dtype=np.intp))\n\t    for x in (-3, [-3], [[-3]], [-3, 4], [3, -4], [[-3, 4]], [[4, -3]], [[1,\n\t        2]] * 9 + [[1, -2]]):\n\t        with pytest.raises(ValueError, match='negative values'):\n\t            _as_pairs(x, 10, as_index=True)\n\t\nTestAsPairs().test_as_index()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}], "instruction": "Functionality: The _as_pairs function broadcasts the input `x` to an array with the shape (`ndim`, 2). It prepares and validates arguments, like `pad_width` for iteration in pairs, for the `pad` function. It also handles converting the elements of `x` to integers and ensures they are positive if `as_index` is set to True.\n\nInputs: \n- x: None, scalar, or array-like. The object to be broadcasted to the shape (`ndim`, 2).\n- ndim: int. The number of pairs the broadcasted `x` will have.\n- as_index: bool, optional. If True and `x` is not None, tries to round each element of `x` to an integer (dtype `np.intp`) and ensures every element is positive.\n\nOutputs:\n- pairs: nested iterables with the shape (`ndim`, 2). This is the broadcasted version of `x`.\n\nRaises:\n- ValueError: If `as_index` is True and `x` contains negative elements, or if `x` is not broadcastable to the shape (`ndim`, 2).", "method_code_mask": "import numpy as np\n\n\ndef _as_pairs(x, ndim, as_index=False): [MASK]\n"}
{"method_name": "get_fieldstructure", "full_method_name": "get_fieldstructure", "method_path": "../srcdata/Computation/numpy/numpy/lib/recfunctions.py", "method_code": "import itertools\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy import ndarray\nfrom numpy.ma import MaskedArray\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.lib._iotools import _is_string_like\ndef get_fieldstructure(adtype, lastname=None, parents=None):\n    \"\"\"\n    Returns a dictionary with fields indexing lists of their parent fields.\n\n    This function is used to simplify access to fields nested in other fields.\n\n    Parameters\n    ----------\n    adtype : np.dtype\n        Input datatype\n    lastname : optional\n        Last processed field name (used internally during recursion).\n    parents : dictionary\n        Dictionary of parent fields (used interbally during recursion).\n\n    Examples\n    --------\n    >>> from numpy.lib import recfunctions as rfn\n    >>> ndtype =  np.dtype([('A', int),\n    ...                     ('B', [('BA', int),\n    ...                            ('BB', [('BBA', int), ('BBB', int)])])])\n    >>> rfn.get_fieldstructure(ndtype)\n    ... # XXX: possible regression, order of BBA and BBB is swapped\n    {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}\n\n    \"\"\"\n    if parents is None:\n        parents = {}\n    names = adtype.names\n    for name in names:\n        current = adtype[name]\n        if current.names is not None:\n            if lastname:\n                parents[name] = [lastname]\n            else:\n                parents[name] = []\n            parents.update(get_fieldstructure(current, name, parents))\n        else:\n            lastparent = [_ for _ in parents.get(lastname, []) or []]\n            if lastparent:\n                lastparent.append(lastname)\n            elif lastname:\n                lastparent = [lastname]\n            parents[name] = lastparent or []\n    return parents", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.lib.recfunctions import drop_fields\nfrom numpy.lib.recfunctions import rename_fields\nfrom numpy.lib.recfunctions import get_fieldstructure\nfrom numpy.lib.recfunctions import recursive_fill_fields\nfrom numpy.lib.recfunctions import find_duplicates\nfrom numpy.lib.recfunctions import merge_arrays\nfrom numpy.lib.recfunctions import append_fields\nfrom numpy.lib.recfunctions import stack_arrays\nfrom numpy.lib.recfunctions import join_by\nfrom numpy.lib.recfunctions import repack_fields\nfrom numpy.lib.recfunctions import unstructured_to_structured\nfrom numpy.lib.recfunctions import structured_to_unstructured\nfrom numpy.lib.recfunctions import apply_along_fields\nfrom numpy.lib.recfunctions import require_fields\nfrom numpy.lib.recfunctions import assign_fields_by_name\nfrom datetime import date\n\nclass TestRecFunctions():\n\tdef test_get_fieldstructure(self):\n\t    ndtype = np.dtype([('A', '|S3'), ('B', float)])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {'A': [], 'B': []})\n\t    ndtype = np.dtype([('A', int), ('B', [('BA', float), ('BB', '|S1')])])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B']})\n\t    ndtype = np.dtype([('A', int), ('B', [('BA', int), ('BB', [('BBA', int),\n\t        ('BBB', int)])])])\n\t    test = get_fieldstructure(ndtype)\n\t    control = {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B',\n\t        'BB'], 'BBB': ['B', 'BB']}\n\t    assert_equal(test, control)\n\t    ndtype = np.dtype([])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {})\n\t\nTestRecFunctions().test_get_fieldstructure()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_recfunctions.py"}], "instruction": "Functionality: The get_fieldstructure function is designed to analyze a given numpy datatype (adtype) and create a dictionary that maps each field to a list of its parent fields. This is particularly useful for navigating complex, nested datatypes where fields may be contained within other fields.\n\nInputs:\n- adtype: A numpy datatype (np.dtype) that serves as the input to analyze.\n- lastname: An optional parameter representing the last processed field name. This is used internally during recursion and should not be set by the user.\n- parents: A dictionary used internally during recursion to keep track of parent fields. This should also not be set by the user.\n\nOutputs:\n- A dictionary where each key is a field name and the value is a list of the field's parent names. This structure helps to understand the hierarchy of fields within the input numpy datatype.\n\nNote: The function uses recursion to traverse nested fields and construct the output dictionary. Users should not manipulate the 'lastname' and 'parents' parameters, as they are for internal use only during the function's execution.", "method_code_mask": "import itertools\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy import ndarray\nfrom numpy.ma import MaskedArray\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.lib._iotools import _is_string_like\n\n\ndef get_fieldstructure(adtype, lastname=None, parents=None): [MASK]\n"}
{"method_name": "break_cycles", "full_method_name": "break_cycles", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "method_code": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef break_cycles():\n    \"\"\"\n    Break reference cycles by calling gc.collect\n    Objects can call other objects' methods (for instance, another object's\n     __del__) inside their own __del__. On PyPy, the interpreter only runs\n    between calls to gc.collect, so multiple calls are needed to completely\n    release all cycles.\n    \"\"\"\n    gc.collect()\n    if IS_PYPY:\n        gc.collect()\n        gc.collect()\n        gc.collect()\n        gc.collect()", "test_code_list": [{"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestPathUsage():\n\tdef test_save_load_memmap(self):\n\t    with temppath(suffix='.npy') as path:\n\t        path = Path(path)\n\t        a = np.array([[1, 2], [3, 4]], int)\n\t        np.save(path, a)\n\t        data = np.load(path, mmap_mode='r')\n\t        assert_array_equal(data, a)\n\t        del data\n\t        if IS_PYPY:\n\t            break_cycles()\n\t            break_cycles()\n\t\nTestPathUsage().test_save_load_memmap()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestCTypes():\n\tdef test_ctypes_as_parameter_holds_reference(self):\n\t    arr = np.array([None]).copy()\n\t    arr_ref = weakref.ref(arr)\n\t    ctypes_ptr = arr.ctypes._as_parameter_\n\t    del arr\n\t    break_cycles()\n\t    assert_(arr_ref() is not None,\n\t        'ctypes pointer did not hold onto a reference')\n\t    del ctypes_ptr\n\t    if IS_PYPY:\n\t        break_cycles()\n\t    assert_(arr_ref() is None,\n\t        'unknowable whether ctypes pointer holds a reference')\n\t\nTestCTypes().test_ctypes_as_parameter_holds_reference()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}, {"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestArrayFinalize():\n\tdef test_lifetime_on_error(self):\n\t\n\t\n\t    class RaisesInFinalize(np.ndarray):\n\t\n\t        def __array_finalize__(self, obj):\n\t            raise Exception(self)\n\t\n\t\n\t    class Dummy:\n\t        pass\n\t    obj_arr = np.array(Dummy())\n\t    obj_ref = weakref.ref(obj_arr[()])\n\t    with assert_raises(Exception) as e:\n\t        obj_arr.view(RaisesInFinalize)\n\t    obj_subarray = e.exception.args[0]\n\t    del e\n\t    assert_(isinstance(obj_subarray, RaisesInFinalize))\n\t    break_cycles()\n\t    assert_(obj_ref() is not None, 'object should not already be dead')\n\t    del obj_arr\n\t    break_cycles()\n\t    assert_(obj_ref() is not None, 'obj_arr should not hold the last reference'\n\t        )\n\t    del obj_subarray\n\t    break_cycles()\n\t    assert_(obj_ref() is None, 'no references should remain')\n\t\nTestArrayFinalize().test_lifetime_on_error()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}], "instruction": "Functionality: The break_cycles function aims to break reference cycles in memory by invoking the Python garbage collector. This is particularly useful in scenarios where objects reference each other, creating cycles that the garbage collector might not be able to resolve automatically. The function calls gc.collect() multiple times to ensure that all cycles are broken, which is especially necessary in the PyPy implementation of Python where additional calls to gc.collect() are made due to the interpreter's behavior.\n\nInputs: None. The function does not require any input arguments.\n\nOutputs: None. The function does not return any value. Its purpose is to perform an operation (garbage collection) rather than to compute a value.", "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef break_cycles(): [MASK]\n"}
{"method_name": "_new_duck_type_and_implements", "full_method_name": "_new_duck_type_and_implements", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_overrides.py", "method_code": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\ndef _new_duck_type_and_implements():\n    \"\"\"Create a duck array type and implements functions.\"\"\"\n    HANDLED_FUNCTIONS = {}\n\n\n    class MyArray:\n\n        def __array_function__(self, func, types, args, kwargs):\n            if func not in HANDLED_FUNCTIONS:\n                return NotImplemented\n            if not all(issubclass(t, MyArray) for t in types):\n                return NotImplemented\n            return HANDLED_FUNCTIONS[func](*args, **kwargs)\n\n    def implements(numpy_function):\n        \"\"\"Register an __array_function__ implementations.\"\"\"\n\n        def decorator(func):\n            HANDLED_FUNCTIONS[numpy_function] = func\n            return func\n        return decorator\n    return MyArray, implements", "test_code_list": [{"test_code": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\n\nclass TestNumPyFunctions():\n\tdef test_override_sum(self):\n\t    MyArray, implements = _new_duck_type_and_implements()\n\t\n\t    @implements(np.sum)\n\t    def _(array):\n\t        return 'yes'\n\t    assert_equal(np.sum(MyArray()), 'yes')\n\t\nTestNumPyFunctions().test_override_sum()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_overrides.py"}], "instruction": "Functionality: _new_duck_type_and_implements function is designed to create a custom duck array type and implement various functions to support operations on this type. The function returns a tuple containing a class (MyArray) and a decorator (implements) for registering functions that operate on instances of the MyArray class. The MyArray class defines an __array_function__ method, which is called when a NumPy function is applied to an instance of MyArray. The implements decorator is used to register functions that can be called by the __array_function__ method when the corresponding NumPy function is applied to a MyArray instance.\n\nInputs: There are no input arguments for the _new_duck_type_and_implements function. It is invoked as a standalone function.\n\nOutputs: The function returns a tuple containing two components:\n1. MyArray: A custom class that supports the duck typing protocol by defining the __array_function__ method.\n2. implements: A decorator that is used to register functions that can be used with instances of the MyArray class. Functions registered with this decorator will be called by the __array_function__ method when the corresponding NumPy function is applied to a MyArray instance.", "method_code_mask": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\n\n\ndef _new_duck_type_and_implements(): [MASK]\n"}
{"method_name": "_block_dispatcher", "full_method_name": "_block_dispatcher", "method_path": "../srcdata/Computation/numpy/numpy/_core/shape_base.py", "method_code": "import functools\nimport itertools\nimport operator\nimport warnings\ndef _block_dispatcher(arrays):\n    if type(arrays) is list:\n        for subarrays in arrays:\n            yield from _block_dispatcher(subarrays)\n    else:\n        yield arrays", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nimport operator\ndef test_block_dispatcher():\n\n\n    class ArrayLike:\n        pass\n    a = ArrayLike()\n    b = ArrayLike()\n    c = ArrayLike()\n    assert_equal(list(_block_dispatcher(a)), [a])\n    assert_equal(list(_block_dispatcher([a])), [a])\n    assert_equal(list(_block_dispatcher([a, b])), [a, b])\n    assert_equal(list(_block_dispatcher([[a], [b, [c]]])), [a, b, c])\n    assert_equal(list(_block_dispatcher((a, b))), [(a, b)])\n\ntest_block_dispatcher()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_shape_base.py"}], "instruction": "Functionality: The _block_dispatcher function is designed to flatten a nested list of arbitrary depth, meaning it will take a list that may contain other lists as elements and return each non-list element in a sequential, flattened order. It works recursively, processing each sub-list it encounters until it reaches non-list elements which it then yields one by one.\n\nInputs: \n- arrays: This is the primary input to the function, which should be a list (potentially nested to any level) containing elements that could be either other lists or non-list items. The function will process this structure and output the non-list elements in a flattened sequence.\n\nOutputs:\n- The function yields the non-list elements in the flattened structure. This means that when called in a context where the function output is iterated over (e.g., in a for loop), it will provide each non-list item from the input in the order they are found, without any nested list structure.", "method_code_mask": "import functools\nimport itertools\nimport operator\nimport warnings\n\n\ndef _block_dispatcher(arrays): [MASK]\n"}
{"method_name": "_aligned_zeros", "full_method_name": "_aligned_zeros", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py", "method_code": "from __future__ import annotations\nimport collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\ndef _aligned_zeros(shape, dtype=float, order='C', align=None):\n    \"\"\"\n    Allocate a new ndarray with aligned memory.\n\n    The ndarray is guaranteed *not* aligned to twice the requested alignment.\n    Eg, if align=4, guarantees it is not aligned to 8. If align=None uses\n    dtype.alignment.\"\"\"\n    dtype = np.dtype(dtype)\n    if dtype == np.dtype(object):\n        if align is not None:\n            raise ValueError('object array alignment not supported')\n        return np.zeros(shape, dtype=dtype, order=order)\n    if align is None:\n        align = dtype.alignment\n    if not hasattr(shape, '__len__'):\n        shape = shape,\n    size = functools.reduce(operator.mul, shape) * dtype.itemsize\n    buf = np.empty(size + 2 * align + 1, np.uint8)\n    ptr = buf.__array_interface__['data'][0]\n    offset = ptr % align\n    if offset != 0:\n        offset = align - offset\n    if ptr % (2 * align) == 0:\n        offset += align\n    buf = buf[offset:offset + size + 1][:-1]\n    buf.fill(0)\n    data = np.ndarray(shape, dtype, buf, order=order)\n    return data", "test_code_list": [{"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestMethods():\n\tdef test_dot_out_mem_overlap(self):\n\t    np.random.seed(1)\n\t    dtypes = [np.dtype(code) for code in np.typecodes['All'] if code not in\n\t        'USVM']\n\t    for dtype in dtypes:\n\t        a = np.random.rand(3, 3).astype(dtype)\n\t        b = _aligned_zeros((3, 3), dtype=dtype)\n\t        b[...] = np.random.rand(3, 3)\n\t        y = np.dot(a, b)\n\t        x = np.dot(a, b, out=b)\n\t        assert_equal(x, y, err_msg=repr(dtype))\n\t        assert_raises(ValueError, np.dot, a, b, out=b[::2])\n\t        assert_raises(ValueError, np.dot, a, b, out=b.T)\n\t\nTestMethods().test_dot_out_mem_overlap()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}], "instruction": "Functionality: The _aligned_zeros function creates a new ndarray with a specified shape, data type, and alignment. The memory allocated for this array is guaranteed not to be aligned to twice the requested alignment, ensuring a specific memory layout. If the align parameter is set to None, it defaults to the alignment of the data type.\n\nInputs: \n- shape: A single integer or a tuple of integers specifying the shape of the new array.\n- dtype: The data type of the array elements. Defaults to float.\n- order: A string specifying the memory layout of the array. 'C' (C-style) or 'F' (Fortran-style) are valid options. Defaults to 'C'.\n- align: An integer specifying the alignment of the array. If set to None, it uses the alignment of the data type. If set to a value, the array's memory will not be aligned to twice this value.\n\nOutputs:\n- data: A new ndarray with the specified shape, data type, and alignment. The memory is initialized to zero values.", "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\n\ndef _aligned_zeros(shape, dtype=float, order='C', align=None): [MASK]\n"}
{"method_name": "iter_multi_index", "full_method_name": "iter_multi_index", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "method_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_multi_index(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.multi_index)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_1d():\n    a = arange(4)\n    i = nditer(a, ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0,), (1,), (2,), (3,)])\n    i = nditer(a[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(3,), (2,), (1,), (0,)])\n\ntest_iter_best_order_multi_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0), (0, 1), (0, 2), (1, 0), (1, \n        1), (1, 2)])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['multi_index'], [['readonly']]\n        )\n    assert_equal(iter_multi_index(i), [(0, 0), (1, 0), (0, 1), (1, 1), (0, \n        2), (1, 2)])\n    i = nditer(a.reshape(2, 3)[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0), (1, 1), (1, 2), (0, 0), (0, \n        1), (0, 2)])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2), (0, 1), (0, 0), (1, 2), (1, \n        1), (1, 0)])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 2), (1, 1), (1, 0), (0, 2), (0, \n        1), (0, 0)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['multi_index'], [[\n        'readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0), (0, 0), (1, 1), (0, 1), (1, \n        2), (0, 2)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['multi_index'], [\n        ['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2), (1, 2), (0, 1), (1, 1), (0, \n        0), (1, 0)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['multi_index'],\n        [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 2), (0, 2), (1, 1), (0, 1), (1, \n        0), (0, 0)])\n\ntest_iter_best_order_multi_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0,\n        1, 1), (0, 2, 0), (0, 2, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1,\n        1), (1, 2, 0), (1, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['multi_index'], [[\n        'readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1,\n        1, 0), (0, 2, 0), (1, 2, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1,\n        1), (0, 2, 1), (1, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0, 0), (1, 0, 1), (1, 1, 0), (1,\n        1, 1), (1, 2, 0), (1, 2, 1), (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1,\n        1), (0, 2, 0), (0, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2, 0), (0, 2, 1), (0, 1, 0), (0,\n        1, 1), (0, 0, 0), (0, 0, 1), (1, 2, 0), (1, 2, 1), (1, 1, 0), (1, 1,\n        1), (1, 0, 0), (1, 0, 1)])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 1), (0, 0, 0), (0, 1, 1), (0,\n        1, 0), (0, 2, 1), (0, 2, 0), (1, 0, 1), (1, 0, 0), (1, 1, 1), (1, 1,\n        0), (1, 2, 1), (1, 2, 0)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['multi_index'], [\n        ['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0, 0), (0, 0, 0), (1, 1, 0), (0,\n        1, 0), (1, 2, 0), (0, 2, 0), (1, 0, 1), (0, 0, 1), (1, 1, 1), (0, 1,\n        1), (1, 2, 1), (0, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['multi_index'],\n        [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2, 0), (1, 2, 0), (0, 1, 0), (1,\n        1, 0), (0, 0, 0), (1, 0, 0), (0, 2, 1), (1, 2, 1), (0, 1, 1), (1, 1,\n        1), (0, 0, 1), (1, 0, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], [\n        'multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 1), (1, 0, 1), (0, 1, 1), (1,\n        1, 1), (0, 2, 1), (1, 2, 1), (0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1,\n        0), (0, 2, 0), (1, 2, 0)])\n\ntest_iter_best_order_multi_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "instruction": "Functionality: The iter_multi_index function is designed to iterate over a multi-dimensional index and collect all the index tuples in a list. It takes an iterator object, which is expected to be a numpy nditer object, as input. This iterator should be previously configured to iterate over a multi-dimensional array. The function will advance the iterator to each position in the array, retrieving the multi_index at each step, which represents the current position in the array. The function will then return a list containing all these multi_indices as tuples.\n\nInputs: \n- i: A numpy nditer object that has been configured to iterate over a multi-dimensional array. This object should have the 'multi_index' attribute enabled, which allows it to return the current index as a tuple of integers.\n\nOutputs: \n- A list of tuples, where each tuple represents the multi_index (i.e., the current position) in the array at each step of the iteration. This list will contain as many tuples as there are elements in the array that the iterator is configured to iterate over.", "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_multi_index(i): [MASK]\n"}
{"method_name": "iter_indices", "full_method_name": "iter_indices", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "method_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_indices(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.index)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_1d():\n    a = arange(4)\n    i = nditer(a, ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3])\n    i = nditer(a[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 2, 1, 0])\n\ntest_iter_best_order_c_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 3, 1, 4, 2, 5])\n    i = nditer(a.reshape(2, 3)[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 4, 5, 0, 1, 2])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [2, 1, 0, 5, 4, 3])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [3, 0, 4, 1, 5, 2])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [2, 5, 1, 4, 0, 3])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [5, 2, 4, 1, 3, 0])\n\ntest_iter_best_order_c_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], ['c_index'],\n        [['readonly']])\n    assert_equal(iter_indices(i), [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])\n\ntest_iter_best_order_c_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_1d():\n    a = arange(4)\n    i = nditer(a, ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3])\n    i = nditer(a[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 2, 1, 0])\n\ntest_iter_best_order_f_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 2, 4, 1, 3, 5])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3)[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 3, 5, 0, 2, 4])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 2, 0, 5, 3, 1])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [5, 3, 1, 4, 2, 0])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])\n\ntest_iter_best_order_f_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], ['f_index'],\n        [['readonly']])\n    assert_equal(iter_indices(i), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])\n\ntest_iter_best_order_f_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "instruction": "Functionality: The function iter_indices is designed to iterate over a NumPy iterator (nditer) and collect the indices of each iteration. This is useful for understanding the order in which elements are accessed in a NumPy array or multi-dimensional array.\n\nInputs: \n- i: A NumPy iterator object (nditer). The iterator should be initialized before passing it to the function. It can be created from a NumPy array or any array-like object that supports iteration.\n\nOutputs: \n- A list of integers representing the indices (or positions) of each element in the array as the iterator iterates over the array. The list will have a length equal to the number of elements in the array, and the order of indices reflects the iteration order of the iterator.", "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_indices(i): [MASK]\n"}
{"method_name": "iter_iterindices", "full_method_name": "iter_iterindices", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "method_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_iterindices(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.iterindex)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_iterindex():\n    buffersize = 5\n    a = arange(24).reshape(4, 3, 2)\n    for flags in ([], ['buffered']):\n        i = nditer(a, flags, buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 2\n        assert_equal(iter_iterindices(i), list(range(2, 24)))\n        i = nditer(a, flags, order='F', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 5\n        assert_equal(iter_iterindices(i), list(range(5, 24)))\n        i = nditer(a[::-1], flags, order='F', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 9\n        assert_equal(iter_iterindices(i), list(range(9, 24)))\n        i = nditer(a[::-1, ::-1], flags, order='C', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 13\n        assert_equal(iter_iterindices(i), list(range(13, 24)))\n        i = nditer(a[::1, ::-1], flags, buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 23\n        assert_equal(iter_iterindices(i), list(range(23, 24)))\n        i.reset()\n        i.iterindex = 2\n        assert_equal(iter_iterindices(i), list(range(2, 24)))\n\ntest_iter_iterindex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "instruction": "Functionality: The function 'iter_iterindices' is designed to iterate over a numpy iterator 'i' and collect the indices of each iteration. This function is particularly useful for understanding the iteration mechanism over numpy arrays, especially when dealing with complex structures or multi-dimensional arrays.\n\nInputs: \n- i: a numpy iterator object obtained from numpy's nditer() function. This iterator is expected to be initialized over a numpy array and its flags and attributes should be set appropriately for the operation you intend to perform.\n\nOutputs: \n- A list of integers, representing the index at each iteration of the numpy iterator 'i'. This list provides insights into the order of iteration over the array and can help verify the correctness of the iterator's settings or the structure of the array being iterated over.", "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_iterindices(i): [MASK]\n"}
{"method_name": "check_dir", "full_method_name": "check_dir", "method_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py", "method_code": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef check_dir(module, module_name=None):\n    \"\"\"Returns a mapping of all objects with the wrong __module__ attribute.\"\"\"\n    if module_name is None:\n        module_name = module.__name__\n    results = {}\n    for name in dir(module):\n        if name == 'core':\n            continue\n        item = getattr(module, name)\n        if hasattr(item, '__module__') and hasattr(item, '__name__'\n            ) and item.__module__ != module_name:\n            results[name] = item.__module__ + '.' + item.__name__\n    return results", "test_code_list": [{"test_code": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef test_numpy_linalg():\n    bad_results = check_dir(np.linalg)\n    assert bad_results == {}\n\ntest_numpy_linalg()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py"}, {"test_code": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef test_numpy_fft():\n    bad_results = check_dir(np.fft)\n    assert bad_results == {}\n\ntest_numpy_fft()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py"}], "instruction": "Functionality: The check_dir function is designed to inspect a given Python module and identify all the objects within that module whose __module__ attribute does not match the module's name. This is particularly useful for identifying objects that may have been imported from other modules, which could lead to unexpected behavior or conflicts.\n\nInputs: \n1. module: A Python module object to be inspected. This is the primary input to the function, specifying the module whose objects' __module__ attributes are to be checked.\n2. module_name: An optional string input that represents the expected name of the module. If not provided, the function will use the __name__ attribute of the 'module' input.\n\nOutputs: \nThe function returns a dictionary where the keys are the names of the objects found within the module that have a __module__ attribute different from the expected module name. The values are strings that represent the actual __module__ attribute concatenated with the object's __name__ attribute, formatted as \"<module_name>.<object_name>\". This dictionary is useful for debugging purposes and can help identify and resolve conflicts or issues related to object ownership and import paths within the module.", "method_code_mask": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\n\n\ndef check_dir(module, module_name=None): [MASK]\n"}
{"method_name": "ndpointer", "full_method_name": "ndpointer", "method_path": "../srcdata/Computation/numpy/numpy/ctypeslib.py", "method_code": "import os\nfrom numpy import integer\nfrom numpy import ndarray\nfrom numpy import dtype as _dtype\nfrom numpy import asarray\nfrom numpy import frombuffer\nimport ctypes\nfrom numpy import intp as c_intp\nimport sys\nimport sysconfig\ndef ndpointer(dtype=None, ndim=None, shape=None, flags=None):\n    \"\"\"\n    Array-checking restype/argtypes.\n\n    An ndpointer instance is used to describe an ndarray in restypes\n    and argtypes specifications.  This approach is more flexible than\n    using, for example, ``POINTER(c_double)``, since several restrictions\n    can be specified, which are verified upon calling the ctypes function.\n    These include data type, number of dimensions, shape and flags.  If a\n    given array does not satisfy the specified restrictions,\n    a ``TypeError`` is raised.\n\n    Parameters\n    ----------\n    dtype : data-type, optional\n        Array data-type.\n    ndim : int, optional\n        Number of array dimensions.\n    shape : tuple of ints, optional\n        Array shape.\n    flags : str or tuple of str\n        Array flags; may be one or more of:\n\n        - C_CONTIGUOUS / C / CONTIGUOUS\n        - F_CONTIGUOUS / F / FORTRAN\n        - OWNDATA / O\n        - WRITEABLE / W\n        - ALIGNED / A\n        - WRITEBACKIFCOPY / X\n\n    Returns\n    -------\n    klass : ndpointer type object\n        A type object, which is an ``_ndtpr`` instance containing\n        dtype, ndim, shape and flags information.\n\n    Raises\n    ------\n    TypeError\n        If a given array does not satisfy the specified restrictions.\n\n    Examples\n    --------\n    >>> clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,\n    ...                                                  ndim=1,\n    ...                                                  flags='C_CONTIGUOUS')]\n    ... #doctest: +SKIP\n    >>> clib.somefunc(np.array([1, 2, 3], dtype=np.float64))\n    ... #doctest: +SKIP\n\n    \"\"\"\n    if dtype is not None:\n        dtype = _dtype(dtype)\n    num = None\n    if flags is not None:\n        if isinstance(flags, str):\n            flags = flags.split(',')\n        elif isinstance(flags, (int, integer)):\n            num = flags\n            flags = _flags_fromnum(num)\n        elif isinstance(flags, flagsobj):\n            num = flags.num\n            flags = _flags_fromnum(num)\n        if num is None:\n            try:\n                flags = [x.strip().upper() for x in flags]\n            except Exception as e:\n                raise TypeError('invalid flags specification') from e\n            num = _num_fromflags(flags)\n    if shape is not None:\n        try:\n            shape = tuple(shape)\n        except TypeError:\n            shape = shape,\n    cache_key = dtype, ndim, shape, num\n    try:\n        return _pointer_type_cache[cache_key]\n    except KeyError:\n        pass\n    if dtype is None:\n        name = 'any'\n    elif dtype.names is not None:\n        name = str(id(dtype))\n    else:\n        name = dtype.str\n    if ndim is not None:\n        name += '_%dd' % ndim\n    if shape is not None:\n        name += '_' + 'x'.join(str(x) for x in shape)\n    if flags is not None:\n        name += '_' + '_'.join(flags)\n    if dtype is not None and shape is not None:\n        base = _concrete_ndptr\n    else:\n        base = _ndptr\n    klass = type('ndpointer_%s' % name, (base,), {'_dtype_': dtype,\n        '_shape_': shape, '_ndim_': ndim, '_flags_': num})\n    _pointer_type_cache[cache_key] = klass\n    return klass", "test_code_list": [{"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_dtype(self):\n\t    dt = np.intc\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.array([1], dt)))\n\t    dt = '<i4'\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.array([1], dt)))\n\t    dt = np.dtype('>i4')\n\t    p = ndpointer(dtype=dt)\n\t    p.from_param(np.array([1], dt))\n\t    assert_raises(TypeError, p.from_param, np.array([1], dt.newbyteorder(\n\t        'swap')))\n\t    dtnames = ['x', 'y']\n\t    dtformats = [np.intc, np.float64]\n\t    dtdescr = {'names': dtnames, 'formats': dtformats}\n\t    dt = np.dtype(dtdescr)\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.zeros((10,), dt)))\n\t    samedt = np.dtype(dtdescr)\n\t    p = ndpointer(dtype=samedt)\n\t    assert_(p.from_param(np.zeros((10,), dt)))\n\t    dt2 = np.dtype(dtdescr, align=True)\n\t    if dt.itemsize != dt2.itemsize:\n\t        assert_raises(TypeError, p.from_param, np.zeros((10,), dt2))\n\t    else:\n\t        assert_(p.from_param(np.zeros((10,), dt2)))\n\t\nTestNdpointer().test_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_ndim(self):\n\t    p = ndpointer(ndim=0)\n\t    assert_(p.from_param(np.array(1)))\n\t    assert_raises(TypeError, p.from_param, np.array([1]))\n\t    p = ndpointer(ndim=1)\n\t    assert_raises(TypeError, p.from_param, np.array(1))\n\t    assert_(p.from_param(np.array([1])))\n\t    p = ndpointer(ndim=2)\n\t    assert_(p.from_param(np.array([[1]])))\n\t\nTestNdpointer().test_ndim()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_shape(self):\n\t    p = ndpointer(shape=(1, 2))\n\t    assert_(p.from_param(np.array([[1, 2]])))\n\t    assert_raises(TypeError, p.from_param, np.array([[1], [2]]))\n\t    p = ndpointer(shape=())\n\t    assert_(p.from_param(np.array(1)))\n\t\nTestNdpointer().test_shape()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_flags(self):\n\t    x = np.array([[1, 2], [3, 4]], order='F')\n\t    p = ndpointer(flags='FORTRAN')\n\t    assert_(p.from_param(x))\n\t    p = ndpointer(flags='CONTIGUOUS')\n\t    assert_raises(TypeError, p.from_param, x)\n\t    p = ndpointer(flags=x.flags.num)\n\t    assert_(p.from_param(x))\n\t    assert_raises(TypeError, p.from_param, np.array([[1, 2], [3, 4]]))\n\t\nTestNdpointer().test_flags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_cache(self):\n\t    assert_(ndpointer(dtype=np.float64) is ndpointer(dtype=np.float64))\n\t    assert_(ndpointer(shape=2) is ndpointer(shape=(2,)))\n\t    assert_(ndpointer(shape=2) is not ndpointer(ndim=2))\n\t    assert_(ndpointer(ndim=2) is not ndpointer(shape=2))\n\t\nTestNdpointer().test_cache()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}], "instruction": "Functionality: The ndpointer function is a utility within the numpy and ctypes libraries used to define the structure of an ndarray that will be passed to or returned from a ctypes function. It checks and enforces restrictions on data type, number of dimensions, shape, and flags of the array to ensure compatibility and consistency.\n\nInputs: \n- dtype: Optional data-type of the array elements. If provided, the array must match this data-type.\n- ndim: Optional number of dimensions the array must have. If not provided, the number of dimensions is not restricted.\n- shape: Optional tuple of integers specifying the exact shape the array must have. If not provided, the shape of the array is not restricted.\n- flags: Optional string or tuple of strings indicating array flags that must be set. Possible flags include 'C_CONTIGUOUS', 'F_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', 'ALIGNED', 'WRITEBACKIFCOPY'.\n\nOutputs:\n- The function returns a type object (an instance of _ndtpr) that contains information about the specified dtype, ndim, shape, and flags. This type object can then be used in ctypes function specifications (e.g., in argtypes or restype) to define how arrays should be passed to or returned from the ctypes function.\n\nRaises:\n- TypeError: If a given array does not satisfy the specified restrictions.", "method_code_mask": "import os\nfrom numpy import integer\nfrom numpy import ndarray\nfrom numpy import dtype as _dtype\nfrom numpy import asarray\nfrom numpy import frombuffer\nimport ctypes\nfrom numpy import intp as c_intp\nimport sys\nimport sysconfig\n\n\ndef ndpointer(dtype=None, ndim=None, shape=None, flags=None): [MASK]\n"}
{"method_name": "ones", "full_method_name": "ones", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "method_code": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef ones(shape, dtype=None, order='C'):\n    \"\"\"\n    Matrix of ones.\n\n    Return a matrix of given shape and type, filled with ones.\n\n    Parameters\n    ----------\n    shape : {sequence of ints, int}\n        Shape of the matrix\n    dtype : data-type, optional\n        The desired data-type for the matrix, default is np.float64.\n    order : {'C', 'F'}, optional\n        Whether to store matrix in C- or Fortran-contiguous order,\n        default is 'C'.\n\n    Returns\n    -------\n    out : matrix\n        Matrix of ones of given shape, dtype, and order.\n\n    See Also\n    --------\n    ones : Array of ones.\n    matlib.zeros : Zero matrix.\n\n    Notes\n    -----\n    If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,\n    `out` becomes a single row matrix of shape ``(1,N)``.\n\n    Examples\n    --------\n    >>> np.matlib.ones((2,3))\n    matrix([[1.,  1.,  1.],\n            [1.,  1.,  1.]])\n\n    >>> np.matlib.ones(2)\n    matrix([[1.,  1.]])\n\n    \"\"\"\n    a = ndarray.__new__(matrix, shape, dtype, order=order)\n    a.fill(1)\n    return a", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_ones():\n    assert_array_equal(ones((2, 3)), np.matrix([[1.0, 1.0, 1.0\n        ], [1.0, 1.0, 1.0]]))\n    assert_array_equal(ones(2), np.matrix([[1.0, 1.0]]))\n\ntest_ones()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "instruction": "Functionality: The ones function creates a matrix filled with ones of a specified shape, data type, and order.\n\nInputs:\n1. shape: A sequence of integers or a single integer that defines the shape of the output matrix. If a single integer is provided, the output becomes a single row matrix of shape (1, N).\n2. dtype: Optional. The desired data type for the matrix. Default is np.float64.\n3. order: Optional. Defines the memory storage order of the output matrix. It can be 'C' for C-contiguous or 'F' for Fortran-contiguous. Default is 'C'.\n\nOutputs:\n1. out: A matrix filled with ones of the given shape, data type, and memory order.", "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef ones(shape, dtype=None, order='C'): [MASK]\n"}
{"method_name": "zeros", "full_method_name": "zeros", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "method_code": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef zeros(shape, dtype=None, order='C'):\n    \"\"\"\n    Return a matrix of given shape and type, filled with zeros.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the matrix\n    dtype : data-type, optional\n        The desired data-type for the matrix, default is float.\n    order : {'C', 'F'}, optional\n        Whether to store the result in C- or Fortran-contiguous order,\n        default is 'C'.\n\n    Returns\n    -------\n    out : matrix\n        Zero matrix of given shape, dtype, and order.\n\n    See Also\n    --------\n    numpy.zeros : Equivalent array function.\n    matlib.ones : Return a matrix of ones.\n\n    Notes\n    -----\n    If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,\n    `out` becomes a single row matrix of shape ``(1,N)``.\n\n    Examples\n    --------\n    >>> import numpy.matlib\n    >>> np.matlib.zeros((2, 3))\n    matrix([[0.,  0.,  0.],\n            [0.,  0.,  0.]])\n\n    >>> np.matlib.zeros(2)\n    matrix([[0.,  0.]])\n\n    \"\"\"\n    a = ndarray.__new__(matrix, shape, dtype, order=order)\n    a.fill(0)\n    return a", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_zeros():\n    assert_array_equal(zeros((2, 3)), np.matrix([[0.0, 0.0, \n        0.0], [0.0, 0.0, 0.0]]))\n    assert_array_equal(zeros(2), np.matrix([[0.0, 0.0]]))\n\ntest_zeros()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "instruction": "Functionality: The zeros function returns a matrix of the specified shape, filled entirely with zeros. The function allows customization of the data type and memory layout order of the matrix.\n\nInputs:\n1. shape: An integer or a sequence of integers that defines the shape of the matrix to be created.\n2. dtype (optional): The desired data type for the elements of the matrix. If not specified, the default is float.\n3. order (optional): A string that determines the memory layout of the matrix. It can be either 'C' (C-contiguous) or 'F' (Fortran-contiguous), with 'C' being the default.\n\nOutputs:\n1. out: A matrix of zeros with the specified shape, data type, and memory layout order.\n\nNote: If the input shape is a single integer or a one-element tuple, the output will be a single row matrix with the dimension (1, N).", "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef zeros(shape, dtype=None, order='C'): [MASK]\n"}
{"method_name": "rand", "full_method_name": "rand", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "method_code": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef rand(*args):\n    \"\"\"\n    Return a matrix of random values with given shape.\n\n    Create a matrix of the given shape and propagate it with\n    random samples from a uniform distribution over ``[0, 1)``.\n\n    Parameters\n    ----------\n    \\\\*args : Arguments\n        Shape of the output.\n        If given as N integers, each integer specifies the size of one\n        dimension.\n        If given as a tuple, this tuple gives the complete shape.\n\n    Returns\n    -------\n    out : ndarray\n        The matrix of random values with shape given by `\\\\*args`.\n\n    See Also\n    --------\n    randn, numpy.random.RandomState.rand\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> import numpy.matlib\n    >>> np.matlib.rand(2, 3)\n    matrix([[0.69646919, 0.28613933, 0.22685145],\n            [0.55131477, 0.71946897, 0.42310646]])\n    >>> np.matlib.rand((2, 3))\n    matrix([[0.9807642 , 0.68482974, 0.4809319 ],\n            [0.39211752, 0.34317802, 0.72904971]])\n\n    If the first argument is a tuple, other arguments are ignored:\n\n    >>> np.matlib.rand((2, 3), 4)\n    matrix([[0.43857224, 0.0596779 , 0.39804426],\n            [0.73799541, 0.18249173, 0.17545176]])\n\n    \"\"\"\n    if isinstance(args[0], tuple):\n        args = args[0]\n    return asmatrix(np.random.rand(*args))", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_rand():\n    x = rand(3)\n    assert_(x.ndim == 2)\n\ntest_rand()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "instruction": "Functionality: Create a matrix of random values with a given shape.\nInputs: *args - Arguments that define the shape of the output matrix. If given as N integers, each integer specifies the size of one dimension. If given as a tuple, this tuple gives the complete shape.\nOutputs: out - The matrix of random values with the shape specified by *args, with values drawn from a uniform distribution over [0, 1).", "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef rand(*args): [MASK]\n"}
{"method_name": "randn", "full_method_name": "randn", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "method_code": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef randn(*args):\n    \"\"\"\n    Return a random matrix with data from the \"standard normal\" distribution.\n\n    `randn` generates a matrix filled with random floats sampled from a\n    univariate \"normal\" (Gaussian) distribution of mean 0 and variance 1.\n\n    Parameters\n    ----------\n    \\\\*args : Arguments\n        Shape of the output.\n        If given as N integers, each integer specifies the size of one\n        dimension. If given as a tuple, this tuple gives the complete shape.\n\n    Returns\n    -------\n    Z : matrix of floats\n        A matrix of floating-point samples drawn from the standard normal\n        distribution.\n\n    See Also\n    --------\n    rand, numpy.random.RandomState.randn\n\n    Notes\n    -----\n    For random samples from the normal distribution with mean ``mu`` and\n    standard deviation ``sigma``, use::\n\n        sigma * np.matlib.randn(...) + mu\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> import numpy.matlib\n    >>> np.matlib.randn(1)\n    matrix([[-1.0856306]])\n    >>> np.matlib.randn(1, 2, 3)\n    matrix([[ 0.99734545,  0.2829785 , -1.50629471],\n            [-0.57860025,  1.65143654, -2.42667924]])\n\n    Two-by-four matrix of samples from the normal distribution with\n    mean 3 and standard deviation 2.5:\n\n    >>> 2.5 * np.matlib.randn((2, 4)) + 3\n    matrix([[1.92771843, 6.16484065, 0.83314899, 1.30278462],\n            [2.76322758, 6.72847407, 1.40274501, 1.8900451 ]])\n\n    \"\"\"\n    if isinstance(args[0], tuple):\n        args = args[0]\n    return asmatrix(np.random.randn(*args))", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_randn():\n    x = randn(3)\n    assert_(x.ndim == 2)\n\ntest_randn()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "instruction": "Functionality: The function `randn` is designed to generate a matrix filled with random floating-point numbers sampled from a univariate \"normal\" (Gaussian) distribution of mean 0 and variance 1. This is commonly referred to as the \"standard normal\" distribution.\n\nInputs: The function `randn` accepts variable arguments to define the shape of the output matrix.\n- If the arguments are given as N integers, each integer specifies the size of one dimension.\n- If the arguments are given as a single tuple, this tuple completely defines the shape of the output matrix.\n\nOutputs: The function `randn` returns a matrix (`Z`) of floats. Each element of the matrix is a sample drawn from the standard normal distribution.", "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef randn(*args): [MASK]\n"}
{"method_name": "repmat", "full_method_name": "repmat", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "method_code": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef repmat(a, m, n):\n    \"\"\"\n    Repeat a 0-D to 2-D array or matrix MxN times.\n\n    Parameters\n    ----------\n    a : array_like\n        The array or matrix to be repeated.\n    m, n : int\n        The number of times `a` is repeated along the first and second axes.\n\n    Returns\n    -------\n    out : ndarray\n        The result of repeating `a`.\n\n    Examples\n    --------\n    >>> import numpy.matlib\n    >>> a0 = np.array(1)\n    >>> np.matlib.repmat(a0, 2, 3)\n    array([[1, 1, 1],\n           [1, 1, 1]])\n\n    >>> a1 = np.arange(4)\n    >>> np.matlib.repmat(a1, 2, 2)\n    array([[0, 1, 2, 3, 0, 1, 2, 3],\n           [0, 1, 2, 3, 0, 1, 2, 3]])\n\n    >>> a2 = np.asmatrix(np.arange(6).reshape(2, 3))\n    >>> np.matlib.repmat(a2, 2, 3)\n    matrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],\n            [3, 4, 5, 3, 4, 5, 3, 4, 5],\n            [0, 1, 2, 0, 1, 2, 0, 1, 2],\n            [3, 4, 5, 3, 4, 5, 3, 4, 5]])\n\n    \"\"\"\n    a = asanyarray(a)\n    ndim = a.ndim\n    if ndim == 0:\n        origrows, origcols = 1, 1\n    elif ndim == 1:\n        origrows, origcols = 1, a.shape[0]\n    else:\n        origrows, origcols = a.shape\n    rows = origrows * m\n    cols = origcols * n\n    c = a.reshape(1, a.size).repeat(m, 0).reshape(rows, origcols).repeat(n, 0)\n    return c.reshape(rows, cols)", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_repmat():\n    a1 = np.arange(4)\n    x = repmat(a1, 2, 2)\n    y = np.array([[0, 1, 2, 3, 0, 1, 2, 3], [0, 1, 2, 3, 0, 1, 2, 3]])\n    assert_array_equal(x, y)\n\ntest_repmat()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "instruction": "Functionality: The repmat function is designed to repeat a 0-D to 2-D array or matrix M times along the first axis and N times along the second axis. This function can handle inputs from single elements to matrices and replicate them as specified.\n\nInputs:\n    a : array_like\n        The array or matrix to be repeated.\n    m, n : int\n        The number of times `a` is to be repeated along the first and second axes, respectively.\n\nOutputs:\n    out : ndarray\n        The result of repeating `a` as specified by `m` and `n`, returned as a NumPy array.\n\nUsage Instructions:\n1. Call the function repmat with the desired array or matrix `a` and integers `m` and `n`.\n2. Ensure that `m` and `n` are positive integers representing the number of repetitions along each axis.\n3. The output will be an ndarray with the input array or matrix repeated `m` times along the first axis and `n` times along the second axis.", "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef repmat(a, m, n): [MASK]\n"}
{"method_name": "minrelpath", "full_method_name": "minrelpath", "method_path": "../srcdata/Computation/numpy/numpy/distutils/misc_util.py", "method_code": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\ndef minrelpath(path):\n    \"\"\"Resolve `..` and '.' from path.\n    \"\"\"\n    if not is_string(path):\n        return path\n    if '.' not in path:\n        return path\n    l = path.split(os.sep)\n    while l:\n        try:\n            i = l.index('.', 1)\n        except ValueError:\n            break\n        del l[i]\n    j = 1\n    while l:\n        try:\n            i = l.index('..', j)\n        except ValueError:\n            break\n        if l[i - 1] == '..':\n            j += 1\n        else:\n            del l[i], l[i - 1]\n            j = 1\n    if not l:\n        return ''\n    return os.sep.join(l)", "test_code_list": [{"test_code": "from os.path import join\nfrom os.path import sep\nfrom os.path import dirname\nimport pytest\nfrom numpy.distutils.misc_util import appendpath\nfrom numpy.distutils.misc_util import minrelpath\nfrom numpy.distutils.misc_util import gpaths\nfrom numpy.distutils.misc_util import get_shared_lib_extension\nfrom numpy.distutils.misc_util import get_info\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nimport sys\n\nclass TestMinrelpath():\n\tdef test_1(self):\n\t    n = lambda path: path.replace('/', sep)\n\t    assert_equal(minrelpath(n('aa/bb')), n('aa/bb'))\n\t    assert_equal(minrelpath('..'), '..')\n\t    assert_equal(minrelpath(n('aa/..')), '')\n\t    assert_equal(minrelpath(n('aa/../bb')), 'bb')\n\t    assert_equal(minrelpath(n('aa/bb/..')), 'aa')\n\t    assert_equal(minrelpath(n('aa/bb/../..')), '')\n\t    assert_equal(minrelpath(n('aa/bb/../cc/../dd')), n('aa/dd'))\n\t    assert_equal(minrelpath(n('.././..')), n('../..'))\n\t    assert_equal(minrelpath(n('aa/bb/.././../dd')), n('dd'))\n\t\nTestMinrelpath().test_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_misc_util.py"}], "instruction": "### Functionality:\nThe `minrelpath` function is designed to resolve occurrences of `..` and `.` from a given file path, thus simplifying the path by removing unnecessary relative directory references.\n\n### Inputs:\n- `path`: A string representing the file path that potentially contains `..` and `.` segments. The input is required to be a string; if it is not a string, the function will return the input as is without any processing.\n\n### Outputs:\n- The output of the function is the simplified path as a string, where all occurrences of `..` and `.` have been resolved. If the path is already simple (i.e., does not contain `..` or `.`) or if the input is not a string, the function returns the input unchanged.\n- If the resulting path is empty due to resolution (e.g., when the input is `'./..'`), the function returns an empty string `''`.\n- The function ensures that consecutive occurrences of `..` in the input are handled appropriately, and it removes redundant `..` that do not contribute to the path simplification.", "method_code_mask": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\n\n\ndef minrelpath(path): [MASK]\n"}
{"method_name": "get_shared_lib_extension", "full_method_name": "get_shared_lib_extension", "method_path": "../srcdata/Computation/numpy/numpy/distutils/misc_util.py", "method_code": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\ndef get_shared_lib_extension(is_python_ext=False):\n    \"\"\"Return the correct file extension for shared libraries.\n\n    Parameters\n    ----------\n    is_python_ext : bool, optional\n        Whether the shared library is a Python extension.  Default is False.\n\n    Returns\n    -------\n    so_ext : str\n        The shared library extension.\n\n    Notes\n    -----\n    For Python shared libs, `so_ext` will typically be '.so' on Linux and OS X,\n    and '.pyd' on Windows.  For Python >= 3.2 `so_ext` has a tag prepended on\n    POSIX systems according to PEP 3149.\n\n    \"\"\"\n    confvars = distutils.sysconfig.get_config_vars()\n    so_ext = confvars.get('EXT_SUFFIX', '')\n    if not is_python_ext:\n        if sys.platform.startswith('linux') or sys.platform.startswith(\n            'gnukfreebsd'):\n            so_ext = '.so'\n        elif sys.platform.startswith('darwin'):\n            so_ext = '.dylib'\n        elif sys.platform.startswith('win'):\n            so_ext = '.dll'\n        elif 'SOABI' in confvars:\n            so_ext = so_ext.replace('.' + confvars.get('SOABI'), '', 1)\n    return so_ext", "test_code_list": [{"test_code": "from os.path import join\nfrom os.path import sep\nfrom os.path import dirname\nimport pytest\nfrom numpy.distutils.misc_util import appendpath\nfrom numpy.distutils.misc_util import minrelpath\nfrom numpy.distutils.misc_util import gpaths\nfrom numpy.distutils.misc_util import get_shared_lib_extension\nfrom numpy.distutils.misc_util import get_info\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nimport sys\n\nclass TestSharedExtension():\n\tdef test_get_shared_lib_extension(self):\n\t    import sys\n\t    ext = get_shared_lib_extension(is_python_ext=False)\n\t    if sys.platform.startswith('linux'):\n\t        assert_equal(ext, '.so')\n\t    elif sys.platform.startswith('gnukfreebsd'):\n\t        assert_equal(ext, '.so')\n\t    elif sys.platform.startswith('darwin'):\n\t        assert_equal(ext, '.dylib')\n\t    elif sys.platform.startswith('win'):\n\t        assert_equal(ext, '.dll')\n\t    assert_(get_shared_lib_extension(is_python_ext=True))\n\t\nTestSharedExtension().test_get_shared_lib_extension()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_misc_util.py"}], "instruction": "Functionality: The get_shared_lib_extension function returns the correct file extension for shared libraries, taking into account whether the library is a Python extension or not.\n\nInputs: \n- is_python_ext: A boolean flag that indicates if the shared library is a Python extension. The default is False.\n\nOutputs: \n- so_ext: A string representing the shared library extension. This will typically be '.so' on Linux and OS X, '.pyd' on Windows for Python extensions, '.dylib' on Darwin for non-Python extensions, '.dll' on Windows for non-Python extensions, or another appropriate extension based on the platform and whether the library is a Python extension.", "method_code_mask": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\n\n\ndef get_shared_lib_extension(is_python_ext=False): [MASK]\n"}
{"method_name": "parse_flags", "full_method_name": "parse_flags", "method_path": "../srcdata/Computation/numpy/numpy/distutils/npy_pkg_config.py", "method_code": "import sys\nimport re\nimport os\nfrom configparser import RawConfigParser\nfrom optparse import OptionParser\nimport glob\ndef parse_flags(line):\n    \"\"\"\n    Parse a line from a config file containing compile flags.\n\n    Parameters\n    ----------\n    line : str\n        A single line containing one or more compile flags.\n\n    Returns\n    -------\n    d : dict\n        Dictionary of parsed flags, split into relevant categories.\n        These categories are the keys of `d`:\n\n        * 'include_dirs'\n        * 'library_dirs'\n        * 'libraries'\n        * 'macros'\n        * 'ignored'\n\n    \"\"\"\n    d = {'include_dirs': [], 'library_dirs': [], 'libraries': [], 'macros':\n        [], 'ignored': []}\n    flags = (' ' + line).split(' -')\n    for flag in flags:\n        flag = '-' + flag\n        if len(flag) > 0:\n            if flag.startswith('-I'):\n                d['include_dirs'].append(flag[2:].strip())\n            elif flag.startswith('-L'):\n                d['library_dirs'].append(flag[2:].strip())\n            elif flag.startswith('-l'):\n                d['libraries'].append(flag[2:].strip())\n            elif flag.startswith('-D'):\n                d['macros'].append(flag[2:].strip())\n            else:\n                d['ignored'].append(flag)\n    return d", "test_code_list": [{"test_code": "import os\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_\n\nclass TestParseFlags():\n\tdef test_simple_cflags(self):\n\t    d = parse_flags('-I/usr/include')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    d = parse_flags('-I/usr/include -DFOO')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    assert_(d['macros'] == ['FOO'])\n\t    d = parse_flags('-I /usr/include -DFOO')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    assert_(d['macros'] == ['FOO'])\n\t\nTestParseFlags().test_simple_cflags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_npy_pkg_config.py"}, {"test_code": "import os\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_\n\nclass TestParseFlags():\n\tdef test_simple_lflags(self):\n\t    d = parse_flags('-L/usr/lib -lfoo -L/usr/lib -lbar')\n\t    assert_(d['library_dirs'] == ['/usr/lib', '/usr/lib'])\n\t    assert_(d['libraries'] == ['foo', 'bar'])\n\t    d = parse_flags('-L /usr/lib -lfoo -L/usr/lib -lbar')\n\t    assert_(d['library_dirs'] == ['/usr/lib', '/usr/lib'])\n\t    assert_(d['libraries'] == ['foo', 'bar'])\n\t\nTestParseFlags().test_simple_lflags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_npy_pkg_config.py"}], "instruction": "Functionality: The parse_flags function is designed to parse a line from a configuration file that contains compile flags. It categorizes these flags into specific groups for easier handling within the build process.\n\nInputs: \n- line : str\n    A single line of text that contains one or more compile flags. These flags typically control aspects such as include directories, library directories, libraries to link against, macros to define, and others.\n\nOutputs:\n- d : dict\n    A dictionary that groups the parsed flags into five categories:\n        * 'include_dirs': A list of include directories specified by the '-I' flags.\n        * 'library_dirs': A list of library directories specified by the '-L' flags.\n        * 'libraries': A list of libraries to link against, specified by the '-l' flags.\n        * 'macros': A list of macros to define, specified by the '-D' flags.\n        * 'ignored': A list of all other flags that do not fall into the above categories.", "method_code_mask": "import sys\nimport re\nimport os\nfrom configparser import RawConfigParser\nfrom optparse import OptionParser\nimport glob\n\n\ndef parse_flags(line): [MASK]\n"}
