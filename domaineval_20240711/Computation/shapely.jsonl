{"method_name": "equal_color", "full_method_name": "equal_color", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py", "method_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef equal_color(actual, expected, alpha=None):\n    import matplotlib.colors as colors\n    conv = colors.colorConverter\n    return actual == conv.to_rgba(expected, alpha=alpha)", "test_code_list": [{"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_patch_from_polygon():\n    poly = box(0, 0, 1, 1)\n    artist = patch_from_polygon(poly, facecolor='red', edgecolor='blue',\n        linewidth=3)\n    assert equal_color(artist.get_facecolor(), 'red')\n    assert equal_color(artist.get_edgecolor(), 'blue')\n    assert artist.get_linewidth() == 3\n\ntest_patch_from_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_patch_from_polygon_with_interior():\n    poly = box(0, 0, 1, 1).difference(box(0.2, 0.2, 0.5, 0.5))\n    artist = patch_from_polygon(poly, facecolor='red', edgecolor='blue',\n        linewidth=3)\n    assert equal_color(artist.get_facecolor(), 'red')\n    assert equal_color(artist.get_edgecolor(), 'blue')\n    assert artist.get_linewidth() == 3\n\ntest_patch_from_polygon_with_interior()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_patch_from_multipolygon():\n    poly = box(0, 0, 1, 1).union(box(2, 2, 3, 3))\n    artist = patch_from_polygon(poly, facecolor='red', edgecolor='blue',\n        linewidth=3)\n    assert equal_color(artist.get_facecolor(), 'red')\n    assert equal_color(artist.get_edgecolor(), 'blue')\n    assert artist.get_linewidth() == 3\n\ntest_patch_from_multipolygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_polygon():\n    poly = box(0, 0, 1, 1)\n    artist, _ = plot_polygon(poly)\n    plot_coords = artist.get_path().vertices\n    assert_allclose(plot_coords, get_coordinates(poly))\n    artist = plot_polygon(poly, add_points=False, color='red', linewidth=3)\n    assert equal_color(artist.get_facecolor(), 'red', alpha=0.3)\n    assert equal_color(artist.get_edgecolor(), 'red', alpha=1.0)\n    assert artist.get_linewidth() == 3\n\ntest_plot_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_line():\n    line = LineString([(0, 0), (1, 0), (1, 1)])\n    artist, _ = plot_line(line)\n    plot_coords = artist.get_path().vertices\n    assert_allclose(plot_coords, get_coordinates(line))\n    artist = plot_line(line, add_points=False, color='red', linewidth=3)\n    assert equal_color(artist.get_edgecolor(), 'red')\n    assert equal_color(artist.get_facecolor(), 'none')\n    assert artist.get_linewidth() == 3\n\ntest_plot_line()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}], "instruction": "Functionality: The equal_color function is designed to compare two colors given in any format recognized by matplotlib. It checks if the two colors are equal, considering an optional alpha value for transparency. This function is particularly useful for verifying if the color representations match, which is essential for graphics and visualization applications.\n\nInputs: \n1. actual: The first color representation to compare. It can be a string (like 'red' or '#FF0000'), an RGB tuple, or an RGBA tuple.\n2. expected: The second color representation to compare against the 'actual' color. Similar to the 'actual' input, it can also be a string, RGB tuple, or RGBA tuple.\n3. alpha (optional): The alpha value (transparency) to use for the comparison. This parameter is optional and, if not provided, the alpha value from the 'expected' color will be used.\n\nOutputs:\n1. A boolean value indicating whether the two color representations are equal. If the colors match exactly (including the alpha value if provided), the function returns True; otherwise, it returns False.", "method_code_mask": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\n\n\ndef equal_color(actual, expected, alpha=None): [MASK]\n"}
{"method_name": "plot_polygon", "full_method_name": "plot_polygon", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_polygon(polygon, ax=None, add_points=True, color=None, facecolor=\n    None, edgecolor=None, linewidth=None, **kwargs):\n    \"\"\"\n    Plot a (Multi)Polygon.\n\n    Note: this function is experimental, and mainly targeting (interactive)\n    exploration, debugging and illustration purposes.\n\n    Parameters\n    ----------\n    polygon : shapely.Polygon or shapely.MultiPolygon\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    add_points : bool, default True\n        If True, also plot the coordinates (vertices) as points.\n    color : matplotlib color specification\n        Color for both the polygon fill (face) and boundary (edge). By default,\n        the fill is using an alpha of 0.3. You can specify `facecolor` and\n        `edgecolor` separately for greater control.\n    facecolor : matplotlib color specification\n        Color for the polygon fill.\n    edgecolor : matplotlib color specification\n        Color for the polygon boundary.\n    linewidth : float\n        The line width for the polygon boundary.\n    **kwargs\n        Additional keyword arguments passed to the matplotlib Patch.\n\n    Returns\n    -------\n    Matplotlib artist (PathPatch), if `add_points` is false.\n    A tuple of Matplotlib artists (PathPatch, Line2D), if `add_points` is true.\n    \"\"\"\n    from matplotlib import colors\n    if ax is None:\n        ax = _default_ax()\n    if color is None:\n        color = 'C0'\n    color = colors.to_rgba(color)\n    if facecolor is None:\n        facecolor = list(color)\n        facecolor[-1] = 0.3\n        facecolor = tuple(facecolor)\n    if edgecolor is None:\n        edgecolor = color\n    patch = patch_from_polygon(polygon, facecolor=facecolor, edgecolor=\n        edgecolor, linewidth=linewidth, **kwargs)\n    ax.add_patch(patch)\n    ax.autoscale_view()\n    if add_points:\n        line = plot_points(polygon, ax=ax, color=color)\n        return patch, line\n    return patch", "test_code_list": [{"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_polygon_with_interior():\n    poly = box(0, 0, 1, 1).difference(box(0.2, 0.2, 0.5, 0.5))\n    artist, _ = plot_polygon(poly)\n    plot_coords = artist.get_path().vertices\n    assert_allclose(plot_coords, get_coordinates(poly))\n\ntest_plot_polygon_with_interior()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_multipolygon():\n    poly = box(0, 0, 1, 1).union(box(2, 2, 3, 3))\n    artist, _ = plot_polygon(poly)\n    plot_coords = artist.get_path().vertices\n    assert_allclose(plot_coords, get_coordinates(poly))\n\ntest_plot_multipolygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}], "instruction": "Functionality: The plot_polygon function is designed to visualize a given Polygon or MultiPolygon on a matplotlib Axes. It can plot the shape with a customizable fill color and boundary color. Additionally, it can optionally plot the vertices of the polygon as points.\n\nInputs: \n- polygon: A shapely Polygon or MultiPolygon object that is to be plotted.\n- ax: A matplotlib Axes object where the polygon will be drawn. If None (default), the function will use the current active axes or create a new figure.\n- add_points: A boolean indicating whether to plot the coordinates (vertices) of the polygon as points. Default is True.\n- color: A matplotlib color specification for both the polygon fill and boundary. Default is 'C0' with an alpha of 0.3 for the fill if not specified.\n- facecolor: A matplotlib color specification for the polygon fill. Default uses the color with an alpha of 0.3 if not specified.\n- edgecolor: A matplotlib color specification for the polygon boundary. Default uses the color value if not specified.\n- linewidth: A float specifying the line width for the polygon boundary.\n- **kwargs: Additional keyword arguments to be passed to the matplotlib Patch.\n\nOutputs:\n- If add_points is False, the function returns a Matplotlib artist (PathPatch).\n- If add_points is True, the function returns a tuple of Matplotlib artists (PathPatch, Line2D).", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_polygon(polygon, ax=None, add_points=True, color=None, facecolor=\n    None, edgecolor=None, linewidth=None, **kwargs): [MASK]\n"}
{"method_name": "plot_line", "full_method_name": "plot_line", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_line(line, ax=None, add_points=True, color=None, linewidth=2, **kwargs\n    ):\n    \"\"\"\n    Plot a (Multi)LineString/LinearRing.\n\n    Note: this function is experimental, and mainly targeting (interactive)\n    exploration, debugging and illustration purposes.\n\n    Parameters\n    ----------\n    line : shapely.LineString or shapely.LinearRing\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    add_points : bool, default True\n        If True, also plot the coordinates (vertices) as points.\n    color : matplotlib color specification\n        Color for the line (edgecolor under the hood) and points.\n    linewidth : float, default 2\n        The line width for the polygon boundary.\n    **kwargs\n        Additional keyword arguments passed to the matplotlib Patch.\n\n    Returns\n    -------\n    Matplotlib artist (PathPatch)\n    \"\"\"\n    from matplotlib.patches import PathPatch\n    from matplotlib.path import Path\n    if ax is None:\n        ax = _default_ax()\n    if color is None:\n        color = 'C0'\n    if isinstance(line, shapely.MultiLineString):\n        path = Path.make_compound_path(*[Path(np.asarray(mline.coords)[:, :\n            2]) for mline in line.geoms])\n    else:\n        path = Path(np.asarray(line.coords)[:, :2])\n    patch = PathPatch(path, facecolor='none', edgecolor=color, linewidth=\n        linewidth, **kwargs)\n    ax.add_patch(patch)\n    ax.autoscale_view()\n    if add_points:\n        line = plot_points(line, ax=ax, color=color)\n        return patch, line\n    return patch", "test_code_list": [{"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_multilinestring():\n    line = MultiLineString([LineString([(0, 0), (1, 0), (1, 1)]),\n        LineString([(2, 2), (3, 3)])])\n    artist, _ = plot_line(line)\n    plot_coords = artist.get_path().vertices\n    assert_allclose(plot_coords, get_coordinates(line))\n\ntest_plot_multilinestring()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}], "instruction": "Functionality: The plot_line function is designed to visualize a shapely LineString or LinearRing object. It can plot a single line or a MultiLineString, and provides options to add point markers at the vertices, customize the color and line width, and pass additional arguments to the matplotlib patch for further styling. Notably, this function is experimental and is best suited for interactive exploration, debugging, and illustrative purposes.\n\nInputs:\n1. line: A shapely LineString, LinearRing, or MultiLineString object to be plotted.\n2. ax (optional): A matplotlib Axes instance where the plot will be placed. If not specified, the function will use the current active axes or create a new one.\n3. add_points (optional): A boolean to determine if points should be added at the vertices of the line. Default is True.\n4. color (optional): A color specification for the line and points using matplotlib's color format. If not specified, 'C0' is used.\n5. linewidth (optional): The width of the line. Default is 2.\n6. **kwargs: Additional keyword arguments that can be passed to matplotlib's Patch object for further customization.\n\nOutputs:\n- If add_points is True, the function returns a tuple containing the matplotlib PathPatch object for the line and the matplotlib Artist object for the points.\n- If add_points is False, the function returns the matplotlib PathPatch object for the line only.\n\nPlease note that the function utilizes matplotlib's PathPatch and Path to create the visual representation of the input LineString or LinearRing.", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_line(line, ax=None, add_points=True, color=None, linewidth=2, **kwargs\n    ): [MASK]\n"}
{"method_name": "plot_points", "full_method_name": "plot_points", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_points(geom, ax=None, color=None, marker='o', **kwargs):\n    \"\"\"\n    Plot a Point/MultiPoint or the vertices of any other geometry type.\n\n    Parameters\n    ----------\n    geom : shapely.Geometry\n        Any shapely Geometry object, from which all vertices are extracted\n        and plotted.\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    color : matplotlib color specification\n        Color for the filled points. You can use `markeredgecolor` and\n        `markerfacecolor` to have different edge and fill colors.\n    marker : str, default \"o\"\n        The matplotlib marker for the points.\n    **kwargs\n        Additional keyword arguments passed to matplotlib `plot` (Line2D).\n\n    Returns\n    -------\n    Matplotlib artist (Line2D)\n    \"\"\"\n    if ax is None:\n        ax = _default_ax()\n    coords = shapely.get_coordinates(geom)\n    line, = ax.plot(coords[:, 0], coords[:, 1], linestyle='', marker=marker,\n        color=color, **kwargs)\n    return line", "test_code_list": [{"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef test_plot_points():\n    for geom in [Point(0, 0), LineString([(0, 0), (1, 0), (1, 1)]), box(0, \n        0, 1, 1)]:\n        artist = plot_points(geom)\n        plot_coords = artist.get_path().vertices\n        assert_allclose(plot_coords, get_coordinates(geom))\n        assert artist.get_linestyle() == 'None'\n    geom = Point(0, 0)\n    artist = plot_points(geom, color='red', marker='+', fillstyle='top')\n    assert artist.get_color() == 'red'\n    assert artist.get_marker() == '+'\n    assert artist.get_fillstyle() == 'top'\n\ntest_plot_points()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py"}], "instruction": "Functionality: The plot_points function is designed to plot points based on the vertices of any Shapely geometry object. It supports plotting points from Point, MultiPoint, or any other geometry type. The function can also customize the color and marker style of the plotted points.\n\nInputs:\n1. geom: A Shapely Geometry object (e.g., Point, MultiPoint, Polygon, etc.). This is the geometry from which all vertices will be extracted and plotted.\n2. ax: A matplotlib Axes object, optional (default is None). This specifies the axes on which the plot will be drawn. If not provided, the function will use the current active axes or create a new figure.\n3. color: A matplotlib color specification, optional. This sets the color for the filled points. Different edge and fill colors can be specified using `markeredgecolor` and `markerfacecolor`.\n4. marker: A string specifying the matplotlib marker for the points, defaulting to \"o\". This determines the appearance of each point on the plot.\n5. **kwargs: Additional keyword arguments to be passed to matplotlib's `plot` function (Line2D). These can be used to further customize the appearance of the plotted points.\n\nOutputs:\n1. Matplotlib artist (Line2D): The function returns a Line2D artist object, which represents the plotted points. This can be used for further customization or reference in the plot.", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_points(geom, ax=None, color=None, marker='o', **kwargs): [MASK]\n"}
{"method_name": "ignore_invalid", "full_method_name": "ignore_invalid", "method_path": "../srcdata/Computation/shapely/shapely/tests/common.py", "method_code": "import warnings\nfrom contextlib import contextmanager\nimport numpy as np\nimport pytest\nimport shapely\n@contextmanager\ndef ignore_invalid(condition=True):\n    if condition:\n        with np.errstate(invalid='ignore'):\n            yield\n    else:\n        yield", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport shapely\nfrom shapely import Geometry\nfrom shapely import GeometryCollection\nfrom shapely import GEOSException\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import ArrayLike\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_polygon\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import multi_point\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\ndef test_offset_curve_empty():\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        actual = shapely.offset_curve(empty_line_string, 2.0)\n    assert shapely.is_empty(actual)\n\ntest_offset_curve_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_constructive.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import multi_line_string\nfrom shapely.tests.common import multi_point\nfrom shapely.tests.common import multi_polygon\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_polygon_testdata\nfrom shapely.tests.common import polygon\nfrom shapely.tests.common import polygon_with_hole\ndef test_distance_duplicated():\n    a = Point(1, 2)\n    b = LineString([(0, 0), (0, 0), (1, 1)])\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        actual = shapely.distance(a, b)\n    assert actual == 1.0\n\ntest_distance_duplicated()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_measurement.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import multi_line_string\nfrom shapely.tests.common import multi_point\nfrom shapely.tests.common import multi_polygon\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_polygon_testdata\nfrom shapely.tests.common import polygon\nfrom shapely.tests.common import polygon_with_hole\ndef test_hausdorff_distance():\n    a = shapely.linestrings([[0, 0], [100, 0], [10, 100], [10, 100]])\n    b = shapely.linestrings([[0, 100], [0, 10], [80, 10]])\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        actual = shapely.hausdorff_distance(a, b)\n    assert actual == pytest.approx(22.360679775, abs=1e-07)\n\ntest_hausdorff_distance()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_measurement.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import multi_line_string\nfrom shapely.tests.common import multi_point\nfrom shapely.tests.common import multi_polygon\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_polygon_testdata\nfrom shapely.tests.common import polygon\nfrom shapely.tests.common import polygon_with_hole\ndef test_hausdorff_distance_densify():\n    a = shapely.linestrings([[0, 0], [100, 0], [10, 100], [10, 100]])\n    b = shapely.linestrings([[0, 100], [0, 10], [80, 10]])\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        actual = shapely.hausdorff_distance(a, b, densify=0.001)\n    assert actual == pytest.approx(47.8, abs=0.1)\n\ntest_hausdorff_distance_densify()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_measurement.py"}, {"test_code": "from functools import partial\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import Point\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import point\nfrom shapely.tests.common import polygon\ndef test_binary_empty_result():\n    a = LineString([(0, 0), (3, 0), (3, 3), (0, 3)])\n    b = LineString([(5, 1), (6, 1)])\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        assert shapely.intersection(a, b).is_empty\n\ntest_binary_empty_result()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_predicates.py"}, {"test_code": "from functools import partial\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import Point\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import point\nfrom shapely.tests.common import polygon\ndef test_relate_pattern_empty():\n    with ignore_invalid(shapely.geos_version < (3, 12, 0)):\n        assert shapely.relate_pattern(empty, empty, '*' * 9).item() is True\n\ntest_relate_pattern_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_predicates.py"}, {"test_code": "import warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import empty as empty_geometry_collection\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_line_string_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import empty_polygon\nfrom shapely.tests.common import geometry_collection\nfrom shapely.tests.common import geometry_collection_z\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import line_string\nfrom shapely.tests.common import line_string_nan\nfrom shapely.tests.common import line_string_z\nfrom shapely.tests.common import linear_ring\nfrom shapely.tests.common import multi_line_string\nfrom shapely.tests.common import multi_line_string_z\nfrom shapely.tests.common import multi_point\nfrom shapely.tests.common import multi_point_z\nfrom shapely.tests.common import multi_polygon\nfrom shapely.tests.common import multi_polygon_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon\nfrom shapely.tests.common import polygon_with_hole\nfrom shapely.tests.common import polygon_with_hole_z\nfrom shapely.tests.common import polygon_z\ndef test_set_nan():\n    with ignore_invalid():\n        a = set(shapely.linestrings([[[np.nan, np.nan], [np.nan, np.nan]]] *\n            10))\n    assert len(a) == 10\n\ntest_set_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_geometry.py"}, {"test_code": "import numpy as np\nimport pytest\nimport shapely\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\ndef test_equality_with_nan_z_false():\n    with ignore_invalid():\n        left = LineString([(0, 1, np.nan), (2, 3, np.nan)])\n        right = LineString([(0, 1, np.nan), (2, 3, 4)])\n    if shapely.geos_version < (3, 10, 0):\n        assert left == right\n    elif shapely.geos_version < (3, 12, 0):\n        assert left == right\n    else:\n        assert left != right\n\ntest_equality_with_nan_z_false()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/geometry/test_equality.py"}], "instruction": "Functionality: The ignore_invalid function is a context manager that is used to suppress numpy warnings that occur within its context, specifically the warnings related to invalid operations such as NaNs (Not a Number). This function is particularly useful when dealing with numerical computations that might produce warnings due to operations on undefined values, but where these warnings are not indicative of errors in the logic of the code.\n\nInputs: \n- condition (bool): A boolean argument that determines whether the warnings for invalid operations should be ignored. If condition is True, warnings will be ignored; if False, warnings will not be suppressed.\n\nOutputs:\n- None: The function itself does not return any value. It is designed to be used as a context manager where you can wrap a block of code that might generate warnings. It ensures that any warnings for invalid operations are ignored within that block if the condition is True.", "method_code_mask": "import warnings\nfrom contextlib import contextmanager\nimport numpy as np\nimport pytest\nimport shapely\n\n\n@contextmanager\ndef ignore_invalid(condition=True): [MASK]\n"}
{"method_name": "set_first_element", "full_method_name": "set_first_element", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_misc.py", "method_code": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\n@multithreading_enabled\ndef set_first_element(value, *args, **kwargs):\n    for arg in chain(args, kwargs.values()):\n        if hasattr(arg, '__setitem__'):\n            arg[0] = value\n            return arg", "test_code_list": [{"test_code": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\ndef test_multithreading_enabled_raises_arg():\n    arr = np.empty((1,), dtype=object)\n    with pytest.raises(ValueError):\n        set_first_element(42, arr)\n    arr[0] = 42\n    assert arr[0] == 42\n\ntest_multithreading_enabled_raises_arg()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_misc.py"}, {"test_code": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\ndef test_multithreading_enabled_raises_kwarg():\n    arr = np.empty((1,), dtype=object)\n    with pytest.raises(ValueError):\n        set_first_element(42, arr=arr)\n    assert arr.flags.writeable\n\ntest_multithreading_enabled_raises_kwarg()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_misc.py"}, {"test_code": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\ndef test_multithreading_enabled_preserves_flag():\n    arr = np.empty((1,), dtype=object)\n    arr.flags.writeable = False\n    with pytest.raises(ValueError):\n        set_first_element(42, arr)\n    assert not arr.flags.writeable\n\ntest_multithreading_enabled_preserves_flag()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_misc.py"}], "instruction": "Functionality: The 'set_first_element' function is designed to set the first element of any mutable sequence passed to it as a parameter to a specified value. This function supports both positional and keyword arguments and can operate on any argument that supports item assignment, such as lists, tuples (if they are mutable), and dictionaries. The function modifies the passed argument in place and returns it.\n\nInputs: \n1. value: The new value that should replace the current first element of the sequence.\n2. *args: A variable number of positional arguments. The function will iterate through these arguments to find a mutable sequence to modify.\n3. **kwargs: A variable number of keyword arguments. Similar to positional arguments, the function will iterate through the values of these keyword arguments.\n\nOutputs: \n1. The modified argument (either from *args or **kwargs) that was successfully modified. If multiple arguments are mutable and can be modified, the first one encountered in the argument list will be returned.", "method_code_mask": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\n\n\n@multithreading_enabled\ndef set_first_element(value, *args, **kwargs): [MASK]\n"}
{"method_name": "to_wkt", "full_method_name": "to_wkt", "method_path": "../srcdata/Computation/shapely/shapely/io.py", "method_code": "import numpy as np\nfrom shapely import geos_version\nfrom shapely import lib\nfrom shapely._enum import ParamEnum\nfrom shapely._ragged_array import from_ragged_array\nfrom shapely._ragged_array import to_ragged_array\nfrom shapely.decorators import requires_geos\nfrom shapely.errors import UnsupportedGEOSVersionError\ndef to_wkt(geometry, rounding_precision=6, trim=True, output_dimension=None,\n    old_3d=False, **kwargs):\n    \"\"\"\n    Converts to the Well-Known Text (WKT) representation of a Geometry.\n\n    The Well-known Text format is defined in the `OGC Simple Features\n    Specification for SQL <https://www.opengeospatial.org/standards/sfs>`__.\n\n    The following limitations apply to WKT serialization:\n\n    - for GEOS <= 3.8 a multipoint with an empty sub-geometry will raise an exception\n    - for GEOS <= 3.8 empty geometries are always serialized to 2D\n    - for GEOS >= 3.9 only simple empty geometries can be 3D, collections are still\n      always 2D\n\n    Parameters\n    ----------\n    geometry : Geometry or array_like\n    rounding_precision : int, default 6\n        The rounding precision when writing the WKT string. Set to a value of\n        -1 to indicate the full precision.\n    trim : bool, default True\n        If True, trim unnecessary decimals (trailing zeros).\n    output_dimension : int, default None\n        The output dimension for the WKT string. Supported values are 2, 3 and\n        4 for GEOS 3.12+. Default None will automatically choose 3 or 4,\n        depending on the version of GEOS.\n        Specifying 3 means that up to 3 dimensions will be written but 2D\n        geometries will still be represented as 2D in the WKT string.\n    old_3d : bool, default False\n        Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT\n        (ie. \"POINT Z (10 20 30)\") is returned, but with ``old_3d=True``\n        the WKT will be formatted in the style \"POINT (10 20 30)\".\n    **kwargs\n        See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\n    Examples\n    --------\n    >>> from shapely import Point\n    >>> to_wkt(Point(0, 0))\n    'POINT (0 0)'\n    >>> to_wkt(Point(0, 0), rounding_precision=3, trim=False)\n    'POINT (0.000 0.000)'\n    >>> to_wkt(Point(0, 0), rounding_precision=-1, trim=False)\n    'POINT (0.0000000000000000 0.0000000000000000)'\n    >>> to_wkt(Point(1, 2, 3), trim=True)\n    'POINT Z (1 2 3)'\n    >>> to_wkt(Point(1, 2, 3), trim=True, output_dimension=2)\n    'POINT (1 2)'\n    >>> to_wkt(Point(1, 2, 3), trim=True, old_3d=True)\n    'POINT (1 2 3)'\n\n    Notes\n    -----\n    The defaults differ from the default of the GEOS library. To mimic this,\n    use::\n\n        to_wkt(geometry, rounding_precision=-1, trim=False, output_dimension=2)\n\n    \"\"\"\n    if not np.isscalar(rounding_precision):\n        raise TypeError('rounding_precision only accepts scalar values')\n    if not np.isscalar(trim):\n        raise TypeError('trim only accepts scalar values')\n    if output_dimension is None:\n        output_dimension = 3 if geos_version < (3, 12, 0) else 4\n    elif not np.isscalar(output_dimension):\n        raise TypeError('output_dimension only accepts scalar values')\n    if not np.isscalar(old_3d):\n        raise TypeError('old_3d only accepts scalar values')\n    return lib.to_wkt(geometry, np.intc(rounding_precision), np.bool_(trim),\n        np.intc(output_dimension), np.bool_(old_3d), **kwargs)", "test_code_list": [{"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt():\n    point = shapely.points(1, 1)\n    actual = to_wkt(point)\n    assert actual == 'POINT (1 1)'\n    actual = to_wkt(point, trim=False)\n    assert actual == 'POINT (1.000000 1.000000)'\n    actual = to_wkt(point, rounding_precision=3, trim=False)\n    assert actual == 'POINT (1.000 1.000)'\n\ntest_to_wkt()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_z():\n    point = shapely.points(1, 2, 3)\n    assert to_wkt(point) == 'POINT Z (1 2 3)'\n    assert to_wkt(point, output_dimension=2) == 'POINT (1 2)'\n    assert to_wkt(point, output_dimension=3) == 'POINT Z (1 2 3)'\n    assert to_wkt(point, old_3d=True) == 'POINT (1 2 3)'\n    if shapely.geos_version >= (3, 12, 0):\n        assert to_wkt(point, output_dimension=4) == 'POINT Z (1 2 3)'\n\ntest_to_wkt_z()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_m():\n    point = shapely.from_wkt('POINT M (1 2 4)')\n    assert to_wkt(point, output_dimension=2) == 'POINT (1 2)'\n    if shapely.geos_version < (3, 12, 0):\n        assert to_wkt(point) == 'POINT Z (1 2 4)'\n        assert to_wkt(point, output_dimension=3) == 'POINT Z (1 2 4)'\n        assert to_wkt(point, old_3d=True) == 'POINT (1 2 4)'\n    else:\n        assert to_wkt(point) == 'POINT M (1 2 4)'\n        assert to_wkt(point, output_dimension=3) == 'POINT M (1 2 4)'\n        assert to_wkt(point, output_dimension=4) == 'POINT M (1 2 4)'\n        assert to_wkt(point, old_3d=True) == 'POINT M (1 2 4)'\n\ntest_to_wkt_m()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_zm():\n    point = shapely.from_wkt('POINT ZM (1 2 3 4)')\n    assert to_wkt(point, output_dimension=2) == 'POINT (1 2)'\n    assert to_wkt(point, output_dimension=3) == 'POINT Z (1 2 3)'\n    if shapely.geos_version < (3, 12, 0):\n        assert to_wkt(point) == 'POINT Z (1 2 3)'\n        assert to_wkt(point, old_3d=True) == 'POINT (1 2 3)'\n    else:\n        assert to_wkt(point) == 'POINT ZM (1 2 3 4)'\n        assert to_wkt(point, output_dimension=4\n            ) == 'POINT ZM (1 2 3 4)'\n        assert to_wkt(point, old_3d=True) == 'POINT (1 2 3 4)'\n\ntest_to_wkt_zm()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_none():\n    assert to_wkt(None) is None\n\ntest_to_wkt_none()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_array_with_empty_z():\n    empty_wkt = ['POINT Z EMPTY', None, 'POLYGON Z EMPTY']\n    empty_geoms = shapely.from_wkt(empty_wkt)\n    if shapely.geos_version < (3, 9, 0):\n        empty_wkt = ['POINT EMPTY', None, 'POLYGON EMPTY']\n    assert list(to_wkt(empty_geoms)) == empty_wkt\n\ntest_to_wkt_array_with_empty_z()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_point_empty():\n    assert to_wkt(empty_point) == 'POINT EMPTY'\n\ntest_to_wkt_point_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_geometrycollection_with_point_empty():\n    collection = shapely.geometrycollections([empty_point, point])\n    assert to_wkt(collection).endswith('(POINT EMPTY, POINT (2 3))')\n\ntest_to_wkt_geometrycollection_with_point_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\n@pytest.mark.skipif(shapely.geos_version < (3, 9, 0), reason=\n    'MULTIPOINT (EMPTY, (2 3)) only works for GEOS >= 3.9')\ndef test_to_wkt_multipoint_with_point_empty():\n    geom = shapely.multipoints([empty_point, point])\n    if shapely.geos_version >= (3, 12, 0):\n        expected = 'MULTIPOINT (EMPTY, (2 3))'\n    else:\n        expected = 'MULTIPOINT (EMPTY, 2 3)'\n    assert to_wkt(geom) == expected\n\ntest_to_wkt_multipoint_with_point_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_large_float_skip_z():\n    assert to_wkt(Point(0, 0, 1e+101), output_dimension=2\n        ) == 'POINT (0 0)'\n\ntest_to_wkt_large_float_skip_z()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkt_large_float_no_trim():\n    assert to_wkt(Point(1e+101, 0), trim=False).startswith('POINT (')\n\ntest_to_wkt_large_float_no_trim()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}, {"test_code": "import json\nimport pickle\nimport struct\nimport warnings\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import all_types\nfrom shapely.tests.common import all_types_z\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import empty_point_z\nfrom shapely.tests.common import point\nfrom shapely.tests.common import point_z\nfrom shapely.tests.common import polygon_z\ndef test_to_wkb_srid():\n    ewkb = '01010000200400000000000000000000000000000000000000'\n    wkb = '010100000000000000000000000000000000000000'\n    actual = shapely.from_wkb(ewkb)\n    assert to_wkt(actual, trim=True) == 'POINT (0 0)'\n    assert shapely.to_wkb(actual, hex=True, byte_order=1) == wkb\n    assert shapely.to_wkb(actual, hex=True, include_srid=True, byte_order=1\n        ) == ewkb\n    point = shapely.points(1, 1)\n    point_with_srid = shapely.set_srid(point, np.int32(4326))\n    result = shapely.to_wkb(point_with_srid, include_srid=True, byte_order=1)\n    assert np.frombuffer(result[5:9], '<u4').item() == 4326\n\ntest_to_wkb_srid()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_io.py"}], "instruction": "Functionality: The to_wkt function converts a given geometry object into its Well-Known Text (WKT) representation. This function adheres to the OGC Simple Features Specification for SQL for formatting geometries as text. It supports various options for rounding precision, trimming of trailing zeros, output dimension, and style of 3D/4D WKT generation.\n\nInputs: \n- geometry: The geometry object to be converted into WKT format. This can be a single geometry object or an array-like collection of geometry objects.\n- rounding_precision: An integer specifying the rounding precision for the WKT string. The default value is 6. Set to -1 to indicate full precision.\n- trim: A boolean value indicating whether unnecessary decimals (trailing zeros) should be trimmed from the output. The default value is True.\n- output_dimension: An integer specifying the output dimension for the WKT string. The default is automatically chosen based on the GEOS version. Supported values are 2, 3, or 4 for GEOS 3.12 and above.\n- old_3d: A boolean value to enable old-style 3D/4D WKT generation. The default is False, which uses new-style 3D/4D WKT generation.\n- **kwargs: Additional keyword arguments that are passed to the NumPy ufunc function.\n\nOutputs:\n- A string or an array of strings representing the WKT format of the input geometry. The output format is determined by the input parameters provided.", "method_code_mask": "import numpy as np\nfrom shapely import geos_version\nfrom shapely import lib\nfrom shapely._enum import ParamEnum\nfrom shapely._ragged_array import from_ragged_array\nfrom shapely._ragged_array import to_ragged_array\nfrom shapely.decorators import requires_geos\nfrom shapely.errors import UnsupportedGEOSVersionError\n\n\ndef to_wkt(geometry, rounding_precision=6, trim=True, output_dimension=None,\n    old_3d=False, **kwargs): [MASK]\n"}
{"method_name": "tree", "full_method_name": "tree.query", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_strtree.py", "method_code": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\n@pytest.fixture(scope='session')\ndef tree():\n    geoms = shapely.points(np.arange(10), np.arange(10))\n    yield STRtree(geoms)", "test_code_list": [{"test_code": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\ndef test_references():\n    point1 = Point()\n    point2 = Point(0, 1)\n    geoms = [point1, point2]\n    tree = STRtree(geoms)\n    point1 = None\n    point2 = None\n    import gc\n    gc.collect()\n    assert tree.query(box(0, 0, 1, 1)).tolist() == [1]\n\ntest_references()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_strtree.py"}, {"test_code": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\ndef test_nearest_empty_tree():\n    tree = STRtree([])\n    assert tree.nearest(point) is None\n\ntest_nearest_empty_tree()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_strtree.py"}, {"test_code": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\ndef test_query_nearest_empty_tree():\n    tree = STRtree([])\n    assert_array_equal(tree.query_nearest(point), [])\n    assert_array_equal(tree.query_nearest([point]), [[], []])\n\ntest_query_nearest_empty_tree()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/test_strtree.py"}], "instruction": "Functionality: The tree.query function is designed to identify geometric objects within a specified range or nearest to a given geometry. It operates on an STRtree instance, which allows for efficient spatial querying. The function supports finding geometries that are within a given distance of a point, within a rectangle, or finding the nearest geometry to a target geometry. It's a versatile tool for spatial indexing and querying.\n\nInputs: \n- geometry: A Shapely geometric object. This can be a Point, LineString, Polygon, etc. It serves as the reference geometry for the query.\n- predicate: A string specifying the type of spatial relationship to look for. Valid predicates include 'intersects', 'contains', 'within', 'disjoint', 'crosses', 'overlaps', 'touches'.\n- distance: A floating-point number representing the distance from the 'geometry' within which to find objects. This is applicable only when the 'predicate' is not specified or is set to 'intersects'.\n- n_nearest: An integer representing the number of nearest neighbors to return. This is applicable only when the 'predicate' is not specified or is set to 'nearest'.\n- objects: A boolean value. If True, the function returns the geometric objects themselves. If False, it returns the indices of the objects in the STRtree.\n\nOutputs: \n- Depending on the value of 'objects', the function returns either a list of Shapely geometric objects or a list of indices corresponding to the geometric objects in the STRtree that fulfill the query criteria.", "method_code_mask": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\n\n\n@pytest.fixture(scope='session')\ndef tree(): [MASK]\n"}
{"method_name": "triangulate", "full_method_name": "triangulate", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef triangulate(geom, tolerance=0.0, edges=False):\n    \"\"\"Creates the Delaunay triangulation and returns a list of geometries\n\n    The source may be any geometry type. All vertices of the geometry will be\n    used as the points of the triangulation.\n\n    From the GEOS documentation:\n    tolerance is the snapping tolerance used to improve the robustness of\n    the triangulation computation. A tolerance of 0.0 specifies that no\n    snapping will take place.\n\n    If edges is False, a list of Polygons (triangles) will be returned.\n    Otherwise the list of LineString edges is returned.\n\n    \"\"\"\n    collection = shapely.delaunay_triangles(geom, tolerance=tolerance,\n        only_edges=edges)\n    return [g for g in collection.geoms]", "test_code_list": [{"test_code": "import unittest\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import triangulate\n\nclass DelaunayTriangulation(unittest.TestCase):\n\tdef test_point(self):\n\t    p = Point(1, 1)\n\t    polys = triangulate(p)\n\t    assert len(polys) == 0\n\t\nDelaunayTriangulation().test_point()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_delaunay.py"}], "instruction": "Functionality: The triangulate function creates the Delaunay triangulation of the input geometry and returns a list of geometries. It supports any geometry type as input, using all vertices of the geometry as the points for triangulation. The function allows for a snapping tolerance to improve the robustness of the triangulation computation. If edges is set to False, the function returns a list of Polygon (triangle) geometries. If edges is set to True, it returns a list of LineString edges.\n\nInputs: \n- geom: A Shapely geometry object (e.g., Point, LineString, Polygon, GeometryCollection). This is the geometry for which the Delaunay triangulation will be computed.\n- tolerance: A float representing the snapping tolerance used to improve the robustness of the triangulation computation. A tolerance of 0.0 specifies that no snapping will take place. Default is 0.0.\n- edges: A boolean indicating whether to return a list of LineString edges (True) or a list of Polygon (triangle) geometries (False). Default is False.\n\nOutputs:\n- A list of Shapely geometries. If edges is False, the list will contain Polygon (triangle) geometries representing the Delaunay triangulation. If edges is True, the list will contain LineString geometries representing the edges of the triangulation.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef triangulate(geom, tolerance=0.0, edges=False): [MASK]\n"}
{"method_name": "nearest_points", "full_method_name": "nearest_points", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef nearest_points(g1, g2):\n    \"\"\"Returns the calculated nearest points in the input geometries\n\n    The points are returned in the same order as the input geometries.\n    \"\"\"\n    seq = shapely.shortest_line(g1, g2)\n    if seq is None:\n        if g1.is_empty:\n            raise ValueError('The first input geometry is empty')\n        else:\n            raise ValueError('The second input geometry is empty')\n    p1 = shapely.get_point(seq, 0)\n    p2 = shapely.get_point(seq, 1)\n    return p1, p2", "test_code_list": [{"test_code": "import unittest\nimport pytest\nfrom shapely.geometry import Point\nfrom shapely.ops import nearest_points\n\nclass Nearest(unittest.TestCase):\n\tdef test_nearest(self):\n\t    first, second = nearest_points(Point(0, 0).buffer(1.0), Point(3, 0).\n\t        buffer(1.0))\n\t    assert first.x == pytest.approx(1.0)\n\t    assert second.x == pytest.approx(2.0)\n\t    assert first.y == pytest.approx(0.0)\n\t    assert second.y == pytest.approx(0.0)\n\t\nNearest().test_nearest()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_nearest.py"}], "instruction": "Functionality: The function nearest_points calculates and returns the nearest points between two input geometries. The geometries can be any Shapely geometry type such as points, lines, or polygons. The points are returned in an order that corresponds to the order of the input geometries.\n\nInputs: \n- g1: The first geometry object (required). This can be any geometry type from the Shapely library (e.g., Point, LineString, Polygon, etc.).\n- g2: The second geometry object (required). This can also be any geometry type from the Shapely library.\n\nOutputs: \n- p1: The nearest point on the first geometry to the second geometry (output).\n- p2: The nearest point on the second geometry to the first geometry (output). These two points are returned as a tuple (p1, p2).", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef nearest_points(g1, g2): [MASK]\n"}
{"method_name": "dumps", "full_method_name": "dumps", "method_path": "../srcdata/Computation/shapely/shapely/wkb.py", "method_code": "import shapely\ndef dumps(ob, hex=False, srid=None, **kw):\n    \"\"\"Dump a WKB representation of a geometry to a byte string, or a\n    hex-encoded string if ``hex=True``.\n\n    Parameters\n    ----------\n    ob : geometry\n        The geometry to export to well-known binary (WKB) representation\n    hex : bool\n        If true, export the WKB as a hexadecimal string. The default is to\n        return a binary string/bytes object.\n    srid : int\n        Spatial reference system ID to include in the output. The default value\n        means no SRID is included.\n    **kw : kwargs, optional\n        Keyword output options passed to :func:`~shapely.to_wkb`.\n    \"\"\"\n    if srid is not None:\n        ob = shapely.set_srid(ob, srid)\n        kw['include_srid'] = True\n    if 'big_endian' in kw:\n        big_endian = kw.pop('big_endian')\n        byte_order = 0 if big_endian else 1\n        kw.update(byte_order=byte_order)\n    return shapely.to_wkb(ob, hex=hex, **kw)", "test_code_list": [{"test_code": "import binascii\nimport math\nimport struct\nimport sys\nimport pytest\nfrom shapely import wkt\nfrom shapely.geometry import Point\nfrom shapely.geos import geos_version\nfrom shapely.tests.legacy.conftest import shapely20_todo\nfrom shapely.wkb import dump\nfrom shapely.wkb import dumps\nfrom shapely.wkb import load\nfrom shapely.wkb import loads\ndef test_point_empty():\n    g = wkt.loads('POINT EMPTY')\n    result = dumps(g, big_endian=False)\n    assert result[:-2 * 8] == b'\\x01\\x01\\x00\\x00\\x00'\n    coords = struct.unpack('<2d', result[-2 * 8:])\n    assert len(coords) == 2\n    assert all(math.isnan(val) for val in coords)\n\ntest_point_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_wkb.py"}, {"test_code": "import pickle\nimport struct\nimport unittest\nfrom shapely import wkb\nfrom shapely import wkt\nfrom shapely.geometry import Point\n\nclass PersistTestCase(unittest.TestCase):\n\tdef test_wkb(self):\n\t    p = Point(0.0, 0.0)\n\t    wkb_big_endian = dumps(p, big_endian=True)\n\t    wkb_little_endian = dumps(p, big_endian=False)\n\t    assert p.equals(wkb.loads(wkb_big_endian))\n\t    assert p.equals(wkb.loads(wkb_little_endian))\n\t\nPersistTestCase().test_wkb()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_persist.py"}, {"test_code": "import pickle\nimport struct\nimport unittest\nfrom shapely import wkb\nfrom shapely import wkt\nfrom shapely.geometry import Point\n\nclass PersistTestCase(unittest.TestCase):\n\tdef test_wkb_dumps_endianness(self):\n\t    p = Point(0.5, 2.0)\n\t    wkb_big_endian = dumps(p, big_endian=True)\n\t    wkb_little_endian = dumps(p, big_endian=False)\n\t    assert wkb_big_endian != wkb_little_endian\n\t    assert wkb_big_endian[0] == 0\n\t    assert wkb_little_endian[0] == 1\n\t    double_size = struct.calcsize('d')\n\t    assert wkb_big_endian[-2 * double_size:] == struct.pack('>2d', p.x, p.y)\n\t    assert wkb_little_endian[-2 * double_size:] == struct.pack('<2d', p.x, p.y)\n\t\nPersistTestCase().test_wkb_dumps_endianness()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_persist.py"}], "instruction": "Functionality: The dumps function is designed to export a geometry object into a well-known binary (WKB) representation as a byte string. It also offers the option to encode this binary representation into a hexadecimal string if specified. The function is versatile, allowing for the inclusion of a spatial reference system identifier (SRID) in the output if provided.\n\nInputs:\n- ob: A geometry object, such as a Point, LineString, Polygon, etc., that is to be converted into WKB format.\n- hex: A boolean argument that, when set to True, converts the WKB output into a hexadecimal string. By default, it returns a binary string/bytes object.\n- srid: An optional integer argument representing the spatial reference system ID to be included in the output. If not provided, no SRID is included.\n- **kw: Additional keyword arguments that can be passed to the shapely.to_wkb function to customize the output further.\n\nOutputs:\n- The function returns a byte string or a hexadecimal string (if hex=True) that represents the input geometry object in WKB format. If an SRID is provided, it is included in the output.", "method_code_mask": "import shapely\n\n\ndef dumps(ob, hex=False, srid=None, **kw): [MASK]\n"}
{"method_name": "shape", "full_method_name": "shape", "method_path": "../srcdata/Computation/shapely/shapely/geometry/geo.py", "method_code": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\ndef shape(context):\n    \"\"\"\n    Returns a new, independent geometry with coordinates *copied* from the\n    context. Changes to the original context will not be reflected in the\n    geometry object.\n\n    Parameters\n    ----------\n    context :\n        a GeoJSON-like dict, which provides a \"type\" member describing the type\n        of the geometry and \"coordinates\" member providing a list of coordinates,\n        or an object which implements __geo_interface__.\n\n    Returns\n    -------\n    Geometry object\n\n    Examples\n    --------\n    Create a Point from GeoJSON, and then create a copy using __geo_interface__.\n\n    >>> context = {'type': 'Point', 'coordinates': [0, 1]}\n    >>> geom = shape(context)\n    >>> geom.geom_type == 'Point'\n    True\n    >>> geom.wkt\n    'POINT (0 1)'\n    >>> geom2 = shape(geom)\n    >>> geom == geom2\n    True\n    \"\"\"\n    if hasattr(context, '__geo_interface__'):\n        ob = context.__geo_interface__\n    else:\n        ob = context\n    geom_type = ob.get('type').lower()\n    if geom_type == 'feature':\n        ob = ob['geometry']\n        geom_type = ob.get('type').lower()\n    if 'coordinates' in ob and _is_coordinates_empty(ob['coordinates']):\n        return _empty_shape_for_no_coordinates(geom_type)\n    elif geom_type == 'point':\n        return Point(ob['coordinates'])\n    elif geom_type == 'linestring':\n        return LineString(ob['coordinates'])\n    elif geom_type == 'linearring':\n        return LinearRing(ob['coordinates'])\n    elif geom_type == 'polygon':\n        return Polygon(ob['coordinates'][0], ob['coordinates'][1:])\n    elif geom_type == 'multipoint':\n        return MultiPoint(ob['coordinates'])\n    elif geom_type == 'multilinestring':\n        return MultiLineString(ob['coordinates'])\n    elif geom_type == 'multipolygon':\n        return MultiPolygon([[c[0], c[1:]] for c in ob['coordinates']])\n    elif geom_type == 'geometrycollection':\n        geoms = [shape(g) for g in ob.get('geometries', [])]\n        return GeometryCollection(geoms)\n    else:\n        raise GeometryTypeError(f'Unknown geometry type: {geom_type!r}')", "test_code_list": [{"test_code": "import pytest\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.geo import _is_coordinates_empty\ndef test_polygon_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([])}\n    assert shape(geom) == Polygon()\n\ntest_polygon_empty_np_array()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_shape.py"}, {"test_code": "import pytest\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.geo import _is_coordinates_empty\ndef test_polygon_with_coords_list():\n    geom = {'type': 'Polygon', 'coordinates': [[[5, 10], [10, 10], [10, 5]]]}\n    obj = shape(geom)\n    assert obj == Polygon([(5, 10), (10, 10), (10, 5)])\n\ntest_polygon_with_coords_list()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_shape.py"}, {"test_code": "import pytest\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.geo import _is_coordinates_empty\ndef test_polygon_not_empty_np_array():\n    np = pytest.importorskip('numpy')\n    geom = {'type': 'Polygon', 'coordinates': np.array([[[5, 10], [10, 10],\n        [10, 5]]])}\n    obj = shape(geom)\n    assert obj == Polygon([(5, 10), (10, 10), (10, 5)])\n\ntest_polygon_not_empty_np_array()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_shape.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom shapely import GeometryCollection\nfrom shapely import LinearRing\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import MultiPoint\nfrom shapely import MultiPolygon\nfrom shapely import Point\nfrom shapely import Polygon\nfrom shapely.geometry import mapping\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import EmptyGeometry\ndef test_shape_empty():\n    empty_mp = MultiPolygon()\n    empty_json = mapping(empty_mp)\n    empty_shape = shape(empty_json)\n    assert empty_shape.is_empty\n\ntest_shape_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/geometry/test_emptiness.py"}], "instruction": "Functionality: The shape function creates a new, independent geometry object based on the input context. The geometry object is a copy and will not be affected by any changes to the original context.\n\nInputs: \n- context: A GeoJSON-like dictionary with a \"type\" member that describes the type of the geometry and a \"coordinates\" member that provides a list of coordinates. Alternatively, the context can be an object that implements __geo_interface__.\n\nOutputs:\n- A new Geometry object corresponding to the input context. This can be one of the following:\n    - Point\n    - LineString\n    - LinearRing\n    - Polygon\n    - MultiPoint\n    - MultiLineString\n    - MultiPolygon\n    - GeometryCollection\n\nExamples of usage are provided within the function's docstring. The function handles various geometry types and can create an empty geometry object if the coordinates are empty. Note that the function raises a GeometryTypeError if the geometry type is unknown or unsupported.", "method_code_mask": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\n\n\ndef shape(context): [MASK]\n"}
{"method_name": "box", "full_method_name": "box", "method_path": "../srcdata/Computation/shapely/shapely/geometry/geo.py", "method_code": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\ndef box(minx, miny, maxx, maxy, ccw=True):\n    \"\"\"Returns a rectangular polygon with configurable normal vector\"\"\"\n    coords = [(maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]\n    if not ccw:\n        coords = coords[::-1]\n    return Polygon(coords)", "test_code_list": [{"test_code": "import unittest\nimport numpy as np\nfrom shapely.geometry import box\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.vectorized import contains\nfrom shapely.vectorized import touches\nfrom numpy.testing import assert_array_equal\n\nclass VectorizedTouchesTestCase(unittest.TestCase):\n\tdef test_touches(self):\n\t    from shapely.vectorized import touches\n\t    y, x = np.mgrid[-2:3:6.0j, -1:3:5.0j]\n\t    geom = box(0, -1, 2, 2)\n\t    result = touches(geom, x, y)\n\t    expected = np.array([[False, False, False, False, False], [False, True,\n\t        True, True, False], [False, True, False, True, False], [False, True,\n\t        False, True, False], [False, True, True, True, False], [False, \n\t        False, False, False, False]], dtype=bool)\n\t    from numpy.testing import assert_array_equal\n\t    assert_array_equal(result, expected)\n\t\nVectorizedTouchesTestCase().test_touches()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_vectorized.py"}, {"test_code": "import unittest\nfrom shapely import geometry\n\nclass BoxTestCase(unittest.TestCase):\n\tdef test_ccw(self):\n\t    b = box(0, 0, 1, 1, ccw=True)\n\t    assert b.exterior.coords[0] == (1.0, 0.0)\n\t    assert b.exterior.coords[1] == (1.0, 1.0)\n\t\nBoxTestCase().test_ccw()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_box.py"}, {"test_code": "import unittest\nfrom shapely import geometry\n\nclass BoxTestCase(unittest.TestCase):\n\tdef test_ccw_default(self):\n\t    b = box(0, 0, 1, 1)\n\t    assert b.exterior.coords[0] == (1.0, 0.0)\n\t    assert b.exterior.coords[1] == (1.0, 1.0)\n\t\nBoxTestCase().test_ccw_default()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_box.py"}, {"test_code": "import unittest\nfrom shapely import geometry\n\nclass BoxTestCase(unittest.TestCase):\n\tdef test_cw(self):\n\t    b = box(0, 0, 1, 1, ccw=False)\n\t    assert b.exterior.coords[0] == (0.0, 0.0)\n\t    assert b.exterior.coords[1] == (0.0, 1.0)\n\t\nBoxTestCase().test_cw()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_box.py"}], "instruction": "Functionality: The function 'box' is designed to generate a rectangular polygon with configurable vertices. This function allows the creation of a rectangular polygon by specifying the minimum and maximum x and y coordinates, and also provides an option to define the orientation of the vertices, either counterclockwise (default) or clockwise.\n\nInputs: \n- minx: A float representing the minimum x-coordinate of the rectangle.\n- miny: A float representing the minimum y-coordinate of the rectangle.\n- maxx: A float representing the maximum x-coordinate of the rectangle.\n- maxy: A float representing the maximum y-coordinate of the rectangle.\n- ccw: A boolean value (default True) indicating the orientation of the vertices. If True, vertices are defined in counterclockwise order, and if False, vertices are defined in clockwise order.\n\nOutputs:\n- A Shapely Polygon object that represents the rectangular polygon created using the coordinates provided. The polygon is defined by the four vertices: (maxx, miny), (maxx, maxy), (minx, maxy), and (minx, miny), in the order specified by the 'ccw' parameter.", "method_code_mask": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\n\n\ndef box(minx, miny, maxx, maxy, ccw=True): [MASK]\n"}
{"method_name": "make_valid", "full_method_name": "make_valid", "method_path": "../srcdata/Computation/shapely/shapely/validation.py", "method_code": "import shapely\ndef make_valid(ob):\n    \"\"\"\n    Make the input geometry valid according to the GEOS MakeValid algorithm.\n\n    If the input geometry is already valid, then it will be returned.\n\n    If the geometry must be split into multiple parts of the same type to be made valid,\n    then a multi-part geometry will be returned.\n\n    If the geometry must be split into multiple parts of different types to be made valid,\n    then a GeometryCollection will be returned.\n\n    Parameters\n    ----------\n    ob : Geometry\n        A shapely geometry object which should be made valid. If the object is already valid,\n        it will be returned as-is.\n\n    Returns\n    -------\n    Geometry\n        The input geometry, made valid according to the GEOS MakeValid algorithm.\n\n    \"\"\"\n    if ob.is_valid:\n        return ob\n    return shapely.make_valid(ob)", "test_code_list": [{"test_code": "from shapely.geometry import Polygon\nfrom shapely.validation import make_valid\ndef test_make_valid_invalid_input():\n    geom = Polygon([(0, 0), (0, 2), (1, 1), (2, 2), (2, 0), (1, 1), (0, 0)])\n    valid = make_valid(geom)\n    assert len(valid.geoms) == 2\n    assert all(geom.geom_type == 'Polygon' for geom in valid.geoms)\n\ntest_make_valid_invalid_input()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_make_valid.py"}, {"test_code": "from shapely.geometry import Polygon\nfrom shapely.validation import make_valid\ndef test_make_valid_input():\n    geom = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n    valid = make_valid(geom)\n    assert id(valid) == id(geom)\n\ntest_make_valid_input()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_make_valid.py"}], "instruction": "Functionality: The make_valid function takes a single input, a shapely geometry object, and returns a valid geometry. If the input geometry is already valid, it will return the geometry as it is. If the geometry must be split to be made valid, the function will return either a multi-part geometry or a GeometryCollection, depending on whether the parts are of the same type or different types. The function uses the GEOS MakeValid algorithm to ensure the geometry's validity.\n\nInputs: \nob : Geometry\n    A shapely geometry object which should be made valid. If the object is already valid, it will be returned as-is.\n\nOutputs: \nGeometry\n    The input geometry, made valid according to the GEOS MakeValid algorithm.", "method_code_mask": "import shapely\n\n\ndef make_valid(ob): [MASK]\n"}
{"method_name": "dumps", "full_method_name": "dumps", "method_path": "../srcdata/Computation/shapely/shapely/wkt.py", "method_code": "import shapely\ndef dumps(ob, trim=False, rounding_precision=-1, **kw):\n    \"\"\"\n    Dump a WKT representation of a geometry to a string.\n\n    Parameters\n    ----------\n    ob :\n        A geometry object of any type to be dumped to WKT.\n    trim : bool, default False\n        Remove excess decimals from the WKT.\n    rounding_precision : int, default -1\n        Round output to the specified number of digits.\n        Default behavior returns full precision.\n    **kw : kwargs, optional\n        Keyword output options passed to :func:`~shapely.to_wkt`.\n\n    Returns\n    -------\n    input geometry as WKT string\n    \"\"\"\n    return shapely.to_wkt(ob, trim=trim, rounding_precision=\n        rounding_precision, **kw)", "test_code_list": [{"test_code": "import locale\nimport sys\nimport unittest\nfrom shapely.wkt import dumps\nfrom shapely.wkt import loads\n\nclass LocaleTestCase(unittest.TestCase):\n\tdef test_wkt_locale(self):\n\t    p = loads('POINT (0.0 0.0)')\n\t    assert p.x == 0.0\n\t    assert p.y == 0.0\n\t    wkt = dumps(p)\n\t    assert wkt.startswith('POINT')\n\t    assert ',' not in wkt\n\t\nLocaleTestCase().test_wkt_locale()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_locale.py"}, {"test_code": "import pickle\nimport struct\nimport unittest\nfrom shapely import wkb\nfrom shapely import wkt\nfrom shapely.geometry import Point\n\nclass PersistTestCase(unittest.TestCase):\n\tdef test_wkt(self):\n\t    p = Point(0.0, 0.0)\n\t    text = dumps(p)\n\t    assert text.startswith('POINT')\n\t    pt = wkt.loads(text)\n\t    assert pt.equals(p)\n\t\nPersistTestCase().test_wkt()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_persist.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_point_outside():\n    \"\"\"Point outside\"\"\"\n    geom1 = load_wkt('POINT (0 0)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_point_outside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_point_inside():\n    \"\"\"Point inside\"\"\"\n    geom1 = load_wkt('POINT (15 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'POINT (15 15)'\n\ntest_point_inside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_point_on_boundary():\n    \"\"\"Point on boundary\"\"\"\n    geom1 = load_wkt('POINT (15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_point_on_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_line_outside():\n    \"\"\"Line outside\"\"\"\n    geom1 = load_wkt('LINESTRING (0 0, -5 5)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_line_outside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_line_inside():\n    \"\"\"Line inside\"\"\"\n    geom1 = load_wkt('LINESTRING (15 15, 16 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'LINESTRING (15 15, 16 15)'\n\ntest_line_inside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_line_on_boundary():\n    \"\"\"Line on boundary\"\"\"\n    geom1 = load_wkt('LINESTRING (10 15, 10 10, 15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_line_on_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef test_line_splitting_rectangle():\n    \"\"\"Line splitting rectangle\"\"\"\n    geom1 = load_wkt('LINESTRING (10 5, 25 20)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'LINESTRING (15 10, 20 15)'\n\ntest_line_splitting_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef polygon_hole_ccw_fully_on_rectangle_boundary():\n    \"\"\"Polygon hole (CCW) fully on rectangle boundary\"\"\"\n    geom1 = load_wkt(\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\npolygon_hole_ccw_fully_on_rectangle_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef polygon_hole_cw_fully_on_rectangle_boundary():\n    \"\"\"Polygon hole (CW) fully on rectangle boundary\"\"\"\n    geom1 = load_wkt(\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 10 20, 20 20, 20 10, 10 10))'\n        )\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dumps(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\npolygon_hole_cw_fully_on_rectangle_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef polygon_fully_within_rectangle():\n    \"\"\"Polygon fully within rectangle\"\"\"\n    wkt = (\n        'POLYGON ((1 1, 1 30, 30 30, 30 1, 1 1), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom1 = load_wkt(wkt)\n    geom2 = clip_by_rect(geom1, 0, 0, 40, 40)\n    assert dumps(geom2, rounding_precision=0) == wkt\n\npolygon_fully_within_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dumps\nfrom shapely.wkt import loads as load_wkt\ndef polygon_overlapping_rectangle():\n    \"\"\"Polygon overlapping rectangle\"\"\"\n    wkt = (\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom1 = load_wkt(wkt)\n    geom2 = clip_by_rect(geom1, 5, 5, 15, 15)\n    assert dumps(geom2, rounding_precision=0\n        ) == 'POLYGON ((5 5, 5 15, 10 15, 10 10, 15 10, 15 5, 5 5))'\n\npolygon_overlapping_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}], "instruction": "Functionality: The function 'dumps' converts a given geometry object into a Well-Known Text (WKT) representation as a string. It supports trimming of excess decimals and rounding to a specified number of digits for precision.\n\nInputs: \n1. ob: A geometry object of any type to be converted to WKT.\n2. trim: A boolean flag indicating if the output should remove excess decimals. The default value is False.\n3. rounding_precision: An integer specifying the number of digits to round the output to. The default value is -1, indicating full precision.\n4. **kw: Optional keyword arguments that can be passed to the 'shapely.to_wkt' function.\n\nOutputs:\n1. A string representing the input geometry in WKT format.", "method_code_mask": "import shapely\n\n\ndef dumps(ob, trim=False, rounding_precision=-1, **kw): [MASK]\n"}
{"method_name": "voronoi_diagram", "full_method_name": "voronoi_diagram", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef voronoi_diagram(geom, envelope=None, tolerance=0.0, edges=False):\n    \"\"\"\n    Constructs a Voronoi Diagram [1] from the given geometry.\n    Returns a list of geometries.\n\n    Parameters\n    ----------\n    geom: geometry\n        the input geometry whose vertices will be used to calculate\n        the final diagram.\n    envelope: geometry, None\n        clipping envelope for the returned diagram, automatically\n        determined if None. The diagram will be clipped to the larger\n        of this envelope or an envelope surrounding the sites.\n    tolerance: float, 0.0\n        sets the snapping tolerance used to improve the robustness\n        of the computation. A tolerance of 0.0 specifies that no\n        snapping will take place.\n    edges: bool, False\n        If False, return regions as polygons. Else, return only\n        edges e.g. LineStrings.\n\n    GEOS documentation can be found at [2]\n\n    Returns\n    -------\n    GeometryCollection\n        geometries representing the Voronoi regions.\n\n    Notes\n    -----\n    The tolerance `argument` can be finicky and is known to cause the\n    algorithm to fail in several cases. If you're using `tolerance`\n    and getting a failure, try removing it. The test cases in\n    tests/test_voronoi_diagram.py show more details.\n\n\n    References\n    ----------\n    [1] https://en.wikipedia.org/wiki/Voronoi_diagram\n    [2] https://geos.osgeo.org/doxygen/geos__c_8h_source.html  (line 730)\n    \"\"\"\n    try:\n        result = shapely.voronoi_polygons(geom, tolerance=tolerance,\n            extend_to=envelope, only_edges=edges)\n    except shapely.GEOSException as err:\n        errstr = 'Could not create Voronoi Diagram with the specified inputs '\n        errstr += f'({err!s}).'\n        if tolerance:\n            errstr += ' Try running again with default tolerance value.'\n        raise ValueError(errstr) from err\n    if result.geom_type != 'GeometryCollection':\n        return GeometryCollection([result])\n    return result", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_no_regions():\n    mp = MultiPoint(points=[(0.5, 0.5)])\n    with np.errstate(invalid='ignore'):\n        regions = voronoi_diagram(mp)\n    assert len(regions.geoms) == 0\n\ntest_no_regions()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_two_regions():\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    regions = voronoi_diagram(mp)\n    assert len(regions.geoms) == 2\n\ntest_two_regions()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_edges():\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    regions = voronoi_diagram(mp, edges=True)\n    assert len(regions.geoms) == 1\n    assert all(r.geom_type.endswith('LineString') for r in regions.geoms)\n\ntest_edges()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_smaller_envelope():\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    poly = load_wkt('POLYGON ((0 0, 0.5 0, 0.5 0.5, 0 0.5, 0 0))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert len(regions.geoms) == 2\n    assert sum(r.area for r in regions.geoms) > poly.area\n\ntest_smaller_envelope()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_larger_envelope():\n    \"\"\"When the envelope we specify is larger than the\n    area of the input feature, the created regions should\n    expand to fill that area.\"\"\"\n    mp = MultiPoint(points=[(0.5, 0.5), (1.0, 1.0)])\n    poly = load_wkt('POLYGON ((0 0, 2 0, 2 2, 0 2, 0 0))')\n    regions = voronoi_diagram(mp, envelope=poly)\n    assert len(regions.geoms) == 2\n    assert sum(r.area for r in regions.geoms) == poly.area\n\ntest_larger_envelope()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_polygon():\n    poly = load_wkt('POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))')\n    regions = voronoi_diagram(poly)\n    assert len(regions.geoms) == 4\n\ntest_from_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_polygon_with_enough_tolerance():\n    poly = load_wkt('POLYGON ((0 0, 0.5 0, 0.5 0.5, 0 0.5, 0 0))')\n    regions = voronoi_diagram(poly, tolerance=1.0)\n    assert len(regions.geoms) == 2\n\ntest_from_polygon_with_enough_tolerance()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_polygon_without_enough_tolerance():\n    poly = load_wkt('POLYGON ((0 0, 0.5 0, 0.5 0.5, 0 0.5, 0 0))')\n    with pytest.raises(ValueError) as exc:\n        voronoi_diagram(poly, tolerance=0.6)\n    assert 'Could not create Voronoi Diagram with the specified inputs' in str(\n        exc.value)\n    assert 'Try running again with default tolerance value.' in str(exc.value)\n\ntest_from_polygon_without_enough_tolerance()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_polygon_without_floating_point_coordinates():\n    poly = load_wkt('POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))')\n    with pytest.raises(ValueError) as exc:\n        voronoi_diagram(poly, tolerance=0.1)\n    assert 'Could not create Voronoi Diagram with the specified inputs' in str(\n        exc.value)\n    assert 'Try running again with default tolerance value.' in str(exc.value)\n\ntest_from_polygon_without_floating_point_coordinates()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_multipoint_without_floating_point_coordinates():\n    \"\"\"A Multipoint with the same \"shape\" as the above Polygon raises the same error...\"\"\"\n    mp = load_wkt('MULTIPOINT (0 0, 1 0, 1 1, 0 1)')\n    with pytest.raises(ValueError) as exc:\n        voronoi_diagram(mp, tolerance=0.1)\n    assert 'Could not create Voronoi Diagram with the specified inputs' in str(\n        exc.value)\n    assert 'Try running again with default tolerance value.' in str(exc.value)\n\ntest_from_multipoint_without_floating_point_coordinates()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_multipoint_with_tolerace_without_floating_point_coordinates():\n    \"\"\"This multipoint will not work with a tolerance value.\"\"\"\n    mp = load_wkt('MULTIPOINT (0 0, 1 0, 1 2, 0 1)')\n    with pytest.raises(ValueError) as exc:\n        voronoi_diagram(mp, tolerance=0.1)\n    assert 'Could not create Voronoi Diagram with the specified inputs' in str(\n        exc.value)\n    assert 'Try running again with default tolerance value.' in str(exc.value)\n\ntest_from_multipoint_with_tolerace_without_floating_point_coordinates()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom shapely.geometry import MultiPoint\nfrom shapely.ops import voronoi_diagram\nfrom shapely.wkt import loads as load_wkt\ndef test_from_multipoint_without_tolerace_without_floating_point_coordinates():\n    \"\"\"But it's fine without it.\"\"\"\n    mp = load_wkt('MULTIPOINT (0 0, 1 0, 1 2, 0 1)')\n    regions = voronoi_diagram(mp)\n    assert len(regions.geoms) == 4\n\ntest_from_multipoint_without_tolerace_without_floating_point_coordinates()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_voronoi_diagram.py"}], "instruction": "Functionality: Constructs a Voronoi Diagram from the given geometry and returns a list of geometries representing the Voronoi regions. The function allows for an optional clipping envelope, snapping tolerance, and the choice to return either polygonal regions or just the edges.\n\nInputs:\n- geom: geometry\n    the input geometry whose vertices will be used to calculate the final diagram.\n- envelope: geometry, None (optional)\n    clipping envelope for the returned diagram, automatically determined if None. The diagram will be clipped to the larger of this envelope or an envelope surrounding the sites.\n- tolerance: float, 0.0 (optional)\n    sets the snapping tolerance used to improve the robustness of the computation. A tolerance of 0.0 specifies that no snapping will take place.\n- edges: bool, False (optional)\n    If False, return regions as polygons. Else, return only edges e.g. LineStrings.\n\nOutputs:\n- GeometryCollection\n    geometries representing the Voronoi regions.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef voronoi_diagram(geom, envelope=None, tolerance=0.0, edges=False): [MASK]\n"}
{"method_name": "orient", "full_method_name": "orient", "method_path": "../srcdata/Computation/shapely/shapely/geometry/polygon.py", "method_code": "import numpy as np\nimport shapely\nfrom shapely.algorithms.cga import is_ccw_impl\nfrom shapely.algorithms.cga import signed_area\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.point import Point\ndef orient(polygon, sign=1.0):\n    s = float(sign)\n    rings = []\n    ring = polygon.exterior\n    if signed_area(ring) / s >= 0.0:\n        rings.append(ring)\n    else:\n        rings.append(list(ring.coords)[::-1])\n    for ring in polygon.interiors:\n        if signed_area(ring) / s <= 0.0:\n            rings.append(ring)\n        else:\n            rings.append(list(ring.coords)[::-1])\n    return Polygon(rings[0], rings[1:])", "test_code_list": [{"test_code": "import unittest\nimport pytest\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import orient\nfrom shapely.geometry.polygon import Polygon\nfrom shapely.geometry.polygon import signed_area\n\nclass PolygonOrienterTestCase(unittest.TestCase):\n\tdef test_no_holes(self):\n\t    ring = LinearRing([(0, 0), (0, 1), (1, 0)])\n\t    polygon = Polygon(ring)\n\t    assert not polygon.exterior.is_ccw\n\t    polygon = orient(polygon, 1)\n\t    assert polygon.exterior.is_ccw\n\t\nPolygonOrienterTestCase().test_no_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_cga.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import orient\nfrom shapely.geometry.polygon import Polygon\nfrom shapely.geometry.polygon import signed_area\n\nclass PolygonOrienterTestCase(unittest.TestCase):\n\tdef test_holes(self):\n\t    polygon = Polygon([(0, 0), (0, 1), (1, 0)], [[(0.5, 0.25), (0.25, 0.5),\n\t        (0.25, 0.25)]])\n\t    assert not polygon.exterior.is_ccw\n\t    assert polygon.interiors[0].is_ccw\n\t    polygon = orient(polygon, 1)\n\t    assert polygon.exterior.is_ccw\n\t    assert not polygon.interiors[0].is_ccw\n\t\nPolygonOrienterTestCase().test_holes()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_cga.py"}], "instruction": "Functionality: The function 'orient' is designed to orient a given Shapely polygon in a specific direction based on the sign parameter. It modifies the vertices of the polygon's exterior and interiors rings to ensure they are oriented in a clockwise or counterclockwise direction, depending on the sign value. A positive sign value will orient the exterior ring counterclockwise and the interior rings clockwise. A negative sign value will do the opposite.\n\nInputs: \n1. polygon (Shapely Polygon): A Shapely Polygon object that represents the geometric shape to be oriented.\n2. sign (float): An optional parameter that determines the orientation direction. It defaults to 1.0. A positive value (greater than 0) orients the exterior ring counterclockwise and the interior rings clockwise. A negative value (less than 0) orients the exterior ring clockwise and the interior rings counterclockwise.\n\nOutputs:\n1. Shapely Polygon: A new Shapely Polygon object with oriented exterior and interior rings according to the sign parameter.", "method_code_mask": "import numpy as np\nimport shapely\nfrom shapely.algorithms.cga import is_ccw_impl\nfrom shapely.algorithms.cga import signed_area\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.point import Point\n\n\ndef orient(polygon, sign=1.0): [MASK]\n"}
{"method_name": "orient", "full_method_name": "orient", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef orient(geom, sign=1.0):\n    \"\"\"A properly oriented copy of the given geometry.\n\n    The signed area of the result will have the given sign. A sign of\n    1.0 means that the coordinates of the product's exterior rings will\n    be oriented counter-clockwise.\n\n    Parameters\n    ----------\n    geom : Geometry\n        The original geometry. May be a Polygon, MultiPolygon, or\n        GeometryCollection.\n    sign : float, optional.\n        The sign of the result's signed area.\n\n    Returns\n    -------\n    Geometry\n\n    \"\"\"\n    if isinstance(geom, BaseMultipartGeometry):\n        return geom.__class__(list(map(lambda geom: orient(geom, sign),\n            geom.geoms)))\n    if isinstance(geom, (Polygon,)):\n        return orient_(geom, sign)\n    return geom", "test_code_list": [{"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_point(self):\n\t    point = Point(0, 0)\n\t    assert orient(point, 1) == point\n\t    assert orient(point, -1) == point\n\t\nOrientTestCase().test_point()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_multipoint(self):\n\t    multipoint = MultiPoint([(0, 0), (1, 1)])\n\t    assert orient(multipoint, 1) == multipoint\n\t    assert orient(multipoint, -1) == multipoint\n\t\nOrientTestCase().test_multipoint()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_linestring(self):\n\t    linestring = LineString([(0, 0), (1, 1)])\n\t    assert orient(linestring, 1) == linestring\n\t    assert orient(linestring, -1) == linestring\n\t\nOrientTestCase().test_linestring()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_multilinestring(self):\n\t    multilinestring = MultiLineString([[(0, 0), (1, 1)], [(1, 0), (0, 1)]])\n\t    assert orient(multilinestring, 1) == multilinestring\n\t    assert orient(multilinestring, -1) == multilinestring\n\t\nOrientTestCase().test_multilinestring()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_linearring(self):\n\t    linearring = LinearRing([(0, 0), (0, 1), (1, 0)])\n\t    assert orient(linearring, 1) == linearring\n\t    assert orient(linearring, -1) == linearring\n\t\nOrientTestCase().test_linearring()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_polygon(self):\n\t    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n\t    polygon_reversed = Polygon(polygon.exterior.coords[::-1])\n\t    assert orient(polygon, 1) == polygon_reversed\n\t    assert orient(polygon, -1) == polygon\n\t\nOrientTestCase().test_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_multipolygon(self):\n\t    polygon1 = Polygon([(0, 0), (0, 1), (1, 0)])\n\t    polygon2 = Polygon([(1, 0), (2, 0), (2, 1)])\n\t    polygon1_reversed = Polygon(polygon1.exterior.coords[::-1])\n\t    polygon2_reversed = Polygon(polygon2.exterior.coords[::-1])\n\t    multipolygon = MultiPolygon([polygon1, polygon2])\n\t    assert not polygon1.exterior.is_ccw\n\t    assert polygon2.exterior.is_ccw\n\t    assert orient(multipolygon, 1) == MultiPolygon([polygon1_reversed,\n\t        polygon2])\n\t    assert orient(multipolygon, -1) == MultiPolygon([polygon1,\n\t        polygon2_reversed])\n\t\nOrientTestCase().test_multipolygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}, {"test_code": "import unittest\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import MultiPolygon\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.ops import orient\n\nclass OrientTestCase(unittest.TestCase):\n\tdef test_geometrycollection(self):\n\t    polygon = Polygon([(0, 0), (0, 1), (1, 0)])\n\t    polygon_reversed = Polygon(polygon.exterior.coords[::-1])\n\t    collection = GeometryCollection([polygon])\n\t    assert orient(collection, 1) == GeometryCollection([polygon_reversed])\n\t    assert orient(collection, -1) == GeometryCollection([polygon])\n\t\nOrientTestCase().test_geometrycollection()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_orient.py"}], "instruction": "Functionality: The orient function returns a properly oriented copy of the given geometry such that the signed area of the result will have the given sign. For a positive sign, the exterior rings of the geometry will be oriented counter-clockwise.\n\nInputs:\n1. geom: Geometry\n    The original geometry which can be a Polygon, MultiPolygon, or GeometryCollection.\n2. sign: float, optional (default is 1.0)\n    Determines the sign of the result's signed area. A positive sign indicates that the exterior rings will be oriented counter-clockwise.\n\nOutputs:\n1. Geometry\n    A new geometry object with the desired orientation.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef orient(geom, sign=1.0): [MASK]\n"}
{"method_name": "polylabel", "full_method_name": "polylabel", "method_path": "../srcdata/Computation/shapely/shapely/algorithms/polylabel.py", "method_code": "from heapq import heappop\nfrom heapq import heappush\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import Point\ndef polylabel(polygon, tolerance=1.0):\n    \"\"\"Finds pole of inaccessibility for a given polygon. Based on\n    Vladimir Agafonkin's https://github.com/mapbox/polylabel\n\n    Parameters\n    ----------\n    polygon : shapely.geometry.Polygon\n    tolerance : int or float, optional\n                `tolerance` represents the highest resolution in units of the\n                input geometry that will be considered for a solution. (default\n                value is 1.0).\n\n    Returns\n    -------\n    shapely.geometry.Point\n        A point representing the pole of inaccessibility for the given input\n        polygon.\n\n    Raises\n    ------\n    shapely.errors.TopologicalError\n        If the input polygon is not a valid geometry.\n\n    Example\n    -------\n    >>> from shapely import LineString\n    >>> polygon = LineString([(0, 0), (50, 200), (100, 100), (20, 50),\n    ... (-100, -20), (-150, -200)]).buffer(100)\n    >>> polylabel(polygon, tolerance=10).wkt\n    'POINT (59.35615556364569 121.83919629746435)'\n    \"\"\"\n    if not polygon.is_valid:\n        raise TopologicalError('Invalid polygon')\n    minx, miny, maxx, maxy = polygon.bounds\n    width = maxx - minx\n    height = maxy - miny\n    cell_size = min(width, height)\n    h = cell_size / 2.0\n    cell_queue = []\n    x, y = polygon.centroid.coords[0]\n    best_cell = Cell(x, y, 0, polygon)\n    bbox_cell = Cell(minx + width / 2.0, miny + height / 2, 0, polygon)\n    if bbox_cell.distance > best_cell.distance:\n        best_cell = bbox_cell\n    x = minx\n    while x < maxx:\n        y = miny\n        while y < maxy:\n            heappush(cell_queue, Cell(x + h, y + h, h, polygon))\n            y += cell_size\n        x += cell_size\n    while cell_queue:\n        cell = heappop(cell_queue)\n        if cell.distance > best_cell.distance:\n            best_cell = cell\n        if cell.max_distance - best_cell.distance <= tolerance:\n            continue\n        h = cell.h / 2.0\n        heappush(cell_queue, Cell(cell.x - h, cell.y - h, h, polygon))\n        heappush(cell_queue, Cell(cell.x + h, cell.y - h, h, polygon))\n        heappush(cell_queue, Cell(cell.x - h, cell.y + h, h, polygon))\n        heappush(cell_queue, Cell(cell.x + h, cell.y + h, h, polygon))\n    return best_cell.centroid", "test_code_list": [{"test_code": "import unittest\nimport pytest\nfrom shapely.algorithms.polylabel import Cell\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\n\nclass PolylabelTestCase(unittest.TestCase):\n\tdef test_polylabel(self):\n\t    \"\"\"\n\t        Finds pole of inaccessibility for a polygon with a tolerance of 10\n\t\n\t        \"\"\"\n\t    polygon = LineString([(0, 0), (50, 200), (100, 100), (20, 50), (-100, -\n\t        20), (-150, -200)]).buffer(100)\n\t    label = polylabel(polygon, tolerance=10)\n\t    expected = Point(59.35615556364569, 121.8391962974644)\n\t    assert expected.equals_exact(label, 1e-06)\n\t\nPolylabelTestCase().test_polylabel()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_polylabel.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely.algorithms.polylabel import Cell\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\n\nclass PolylabelTestCase(unittest.TestCase):\n\tdef test_concave_polygon(self):\n\t    \"\"\"\n\t        Finds pole of inaccessibility for a concave polygon and ensures that\n\t        the point is inside.\n\t\n\t        \"\"\"\n\t    concave_polygon = LineString([(500, 0), (0, 0), (0, 500), (500, 500)]\n\t        ).buffer(100)\n\t    label = polylabel(concave_polygon)\n\t    assert concave_polygon.contains(label)\n\t\nPolylabelTestCase().test_concave_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_polylabel.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely.algorithms.polylabel import Cell\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\n\nclass PolylabelTestCase(unittest.TestCase):\n\tdef test_rectangle_special_case(self):\n\t    \"\"\"\n\t        The centroid algorithm used is vulnerable to floating point errors\n\t        and can give unexpected results for rectangular polygons. Test\n\t        that this special case is handled correctly.\n\t        https://github.com/mapbox/polylabel/issues/3\n\t        \"\"\"\n\t    polygon = Polygon([(32.71997, -117.1931), (32.71997, -117.21065), (\n\t        32.72408, -117.21065), (32.72408, -117.1931)])\n\t    label = polylabel(polygon)\n\t    assert label.coords[:] == [(32.722025, -117.201875)]\n\t\nPolylabelTestCase().test_rectangle_special_case()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_polylabel.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely.algorithms.polylabel import Cell\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\n\nclass PolylabelTestCase(unittest.TestCase):\n\tdef test_polygon_with_hole(self):\n\t    \"\"\"\n\t        Finds pole of inaccessibility for a polygon with a hole\n\t        https://github.com/shapely/shapely/issues/817\n\t        \"\"\"\n\t    polygon = Polygon(shell=[(0, 0), (10, 0), (10, 10), (0, 10), (0, 0)],\n\t        holes=[[(2, 2), (6, 2), (6, 6), (2, 6), (2, 2)]])\n\t    label = polylabel(polygon, 0.05)\n\t    assert label.x == pytest.approx(7.65625)\n\t    assert label.y == pytest.approx(7.65625)\n\t\nPolylabelTestCase().test_polygon_with_hole()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_polylabel.py"}], "instruction": "Functionality: Finds the pole of inaccessibility (the point within a polygon that has the greatest distance from the boundary) for a given polygon using a heuristic algorithm.\nInputs: \n- polygon: A shapely.geometry.Polygon object representing the input geometry.\n- tolerance: An optional integer or float parameter representing the highest resolution in units of the input geometry that will be considered for a solution. Default value is 1.0.\n\nOutputs:\n- A shapely.geometry.Point object representing the pole of inaccessibility for the provided polygon.\n\nRaises:\n- TopologicalError: If the input polygon is not a valid geometry.\n\nNote: The function initializes a priority queue of cells and iteratively refines the search for the inaccessibility pole until the difference between the maximum distance of any cell and the distance of the best cell does not change more than the tolerance value. The output is the centroid of the cell with the highest distance from the polygon boundary.", "method_code_mask": "from heapq import heappop\nfrom heapq import heappush\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import Point\n\n\ndef polylabel(polygon, tolerance=1.0): [MASK]\n"}
{"method_name": "shared_paths", "full_method_name": "shared_paths", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef shared_paths(g1, g2):\n    \"\"\"Find paths shared between the two given lineal geometries\n\n    Returns a GeometryCollection with two elements:\n     - First element is a MultiLineString containing shared paths with the\n       same direction for both inputs.\n     - Second element is a MultiLineString containing shared paths with the\n       opposite direction for the two inputs.\n\n    Parameters\n    ----------\n    g1 : geometry\n        The first geometry\n    g2 : geometry\n        The second geometry\n    \"\"\"\n    if not isinstance(g1, LineString):\n        raise GeometryTypeError('First geometry must be a LineString')\n    if not isinstance(g2, LineString):\n        raise GeometryTypeError('Second geometry must be a LineString')\n    return shapely.shared_paths(g1, g2)", "test_code_list": [{"test_code": "import unittest\nimport pytest\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import Point\nfrom shapely.ops import shared_paths\n\nclass SharedPaths(unittest.TestCase):\n\tdef test_shared_paths_forward(self):\n\t    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n\t    g2 = LineString([(5, 0), (15, 0)])\n\t    result = shared_paths(g1, g2)\n\t    assert isinstance(result, GeometryCollection)\n\t    assert len(result.geoms) == 2\n\t    a, b = result.geoms\n\t    assert isinstance(a, MultiLineString)\n\t    assert len(a.geoms) == 1\n\t    assert a.geoms[0].coords[:] == [(5, 0), (10, 0)]\n\t    assert b.is_empty\n\t\nSharedPaths().test_shared_paths_forward()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_shared_paths.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import Point\nfrom shapely.ops import shared_paths\n\nclass SharedPaths(unittest.TestCase):\n\tdef test_shared_paths_forward2(self):\n\t    g1 = LineString([(0, 0), (10, 0), (10, 5), (20, 5)])\n\t    g2 = LineString([(15, 0), (5, 0)])\n\t    result = shared_paths(g1, g2)\n\t    assert isinstance(result, GeometryCollection)\n\t    assert len(result.geoms) == 2\n\t    a, b = result.geoms\n\t    assert isinstance(b, MultiLineString)\n\t    assert len(b.geoms) == 1\n\t    assert b.geoms[0].coords[:] == [(5, 0), (10, 0)]\n\t    assert a.is_empty\n\t\nSharedPaths().test_shared_paths_forward2()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_shared_paths.py"}], "instruction": "Functionality: The shared_paths function is designed to identify and return paths that are shared between two given lineal geometries. It processes two LineString geometries and returns a GeometryCollection with two elements: the first is a MultiLineString containing shared paths with the same direction for both input geometries, and the second is a MultiLineString containing shared paths with opposite directions for the two input geometries.\n\nInputs: \n- g1: A LineString object representing the first geometry.\n- g2: A LineString object representing the second geometry.\n\nOutputs:\n- A GeometryCollection with two elements:\n  - First element: A MultiLineString containing shared paths with the same direction for both input geometries.\n  - Second element: A MultiLineString containing shared paths with opposite directions for the two input geometries.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef shared_paths(g1, g2): [MASK]\n"}
{"method_name": "transform", "full_method_name": "transform", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef transform(func, geom):\n    \"\"\"Applies `func` to all coordinates of `geom` and returns a new\n    geometry of the same type from the transformed coordinates.\n\n    `func` maps x, y, and optionally z to output xp, yp, zp. The input\n    parameters may iterable types like lists or arrays or single values.\n    The output shall be of the same type. Scalars in, scalars out.\n    Lists in, lists out.\n\n    For example, here is an identity function applicable to both types\n    of input.\n\n      def id_func(x, y, z=None):\n          return tuple(filter(None, [x, y, z]))\n\n      g2 = transform(id_func, g1)\n\n    Using pyproj >= 2.1, this example will accurately project Shapely geometries:\n\n      import pyproj\n\n      wgs84 = pyproj.CRS('EPSG:4326')\n      utm = pyproj.CRS('EPSG:32618')\n\n      project = pyproj.Transformer.from_crs(wgs84, utm, always_xy=True).transform\n\n      g2 = transform(project, g1)\n\n    Note that the always_xy kwarg is required here as Shapely geometries only support\n    X,Y coordinate ordering.\n\n    Lambda expressions such as the one in\n\n      g2 = transform(lambda x, y, z=None: (x+1.0, y+1.0), g1)\n\n    also satisfy the requirements for `func`.\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if geom.geom_type in ('Point', 'LineString', 'LinearRing', 'Polygon'):\n        try:\n            if geom.geom_type in ('Point', 'LineString', 'LinearRing'):\n                return type(geom)(zip(*func(*zip(*geom.coords))))\n            elif geom.geom_type == 'Polygon':\n                shell = type(geom.exterior)(zip(*func(*zip(*geom.exterior.\n                    coords))))\n                holes = list(type(ring)(zip(*func(*zip(*ring.coords)))) for\n                    ring in geom.interiors)\n                return type(geom)(shell, holes)\n        except TypeError:\n            if geom.geom_type in ('Point', 'LineString', 'LinearRing'):\n                return type(geom)([func(*c) for c in geom.coords])\n            elif geom.geom_type == 'Polygon':\n                shell = type(geom.exterior)([func(*c) for c in geom.\n                    exterior.coords])\n                holes = list(type(ring)([func(*c) for c in ring.coords]) for\n                    ring in geom.interiors)\n                return type(geom)(shell, holes)\n    elif geom.geom_type.startswith('Multi'\n        ) or geom.geom_type == 'GeometryCollection':\n        return type(geom)([transform(func, part) for part in geom.geoms])\n    else:\n        raise GeometryTypeError(f'Type {geom.geom_type!r} not recognized')", "test_code_list": [{"test_code": "import unittest\nimport pytest\nfrom shapely import geometry\nfrom shapely.ops import transform\n\nclass LambdaTestCase(unittest.TestCase):\n\tdef test_point(self):\n\t    g = geometry.Point(0, 1)\n\t    h = transform(lambda x, y, z=None: (x + 1.0, y + 1.0), g)\n\t    assert h.geom_type == 'Point'\n\t    assert list(h.coords) == [(1.0, 2.0)]\n\t\nLambdaTestCase().test_point()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_transform.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely import geometry\nfrom shapely.ops import transform\n\nclass LambdaTestCase(unittest.TestCase):\n\tdef test_line(self):\n\t    g = geometry.LineString([(0, 1), (2, 3)])\n\t    h = transform(lambda x, y, z=None: (x + 1.0, y + 1.0), g)\n\t    assert h.geom_type == 'LineString'\n\t    assert list(h.coords) == [(1.0, 2.0), (3.0, 4.0)]\n\t\nLambdaTestCase().test_line()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_transform.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely import geometry\nfrom shapely.ops import transform\n\nclass LambdaTestCase(unittest.TestCase):\n\tdef test_polygon(self):\n\t    g = geometry.Point(0, 1).buffer(1.0)\n\t    h = transform(lambda x, y, z=None: (x + 1.0, y + 1.0), g)\n\t    assert h.geom_type == 'Polygon'\n\t    assert g.area == pytest.approx(h.area)\n\t    assert h.centroid.x == pytest.approx(1.0)\n\t    assert h.centroid.y == pytest.approx(2.0)\n\t\nLambdaTestCase().test_polygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_transform.py"}, {"test_code": "import unittest\nimport pytest\nfrom shapely import geometry\nfrom shapely.ops import transform\n\nclass LambdaTestCase(unittest.TestCase):\n\tdef test_multipolygon(self):\n\t    g = geometry.MultiPoint([(0, 1), (0, 4)]).buffer(1.0)\n\t    h = transform(lambda x, y, z=None: (x + 1.0, y + 1.0), g)\n\t    assert h.geom_type == 'MultiPolygon'\n\t    assert g.area == pytest.approx(h.area)\n\t    assert h.centroid.x == pytest.approx(1.0)\n\t    assert h.centroid.y == pytest.approx(3.5)\n\t\nLambdaTestCase().test_multipolygon()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_transform.py"}], "instruction": "Functionality: The transform function applies a given coordinate transformation function to all coordinates of a geometric object (geom) and returns a new geometry of the same type from the transformed coordinates. This function supports various geometric types including Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, and GeometryCollection.\n\nInputs: \n- func: A function that maps x, y, and optionally z to output xp, yp, zp. The input parameters may be iterable types like lists or arrays or single values. The output shall be of the same type as the input, i.e., lists in, lists out; scalars in, scalars out.\n- geom: A geometric object of type Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, or GeometryCollection.\n\nOutputs:\n- A new geometry of the same type as geom, with coordinates transformed by the func. If geom is empty, it is returned as is.\n\nAdditional information:\n- The function is compatible with both iterable and scalar inputs for x, y, and z.\n- For usage with pyproj for geographic projections, the always_xy kwarg is required as Shapely geometries only support X,Y coordinate ordering.\n- The function uses zip and type conversions to apply the transformation to coordinates.\n- In case of a TypeError, a list comprehension is used to apply the transformation to each coordinate.\n- If the geom is of type 'Multi' or 'GeometryCollection', the transform function is recursively applied to each part of the geometry.\n- Unsupported geometric types will raise a GeometryTypeError.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef transform(func, geom): [MASK]\n"}
{"method_name": "clip_by_rect", "full_method_name": "clip_by_rect", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef clip_by_rect(geom, xmin, ymin, xmax, ymax):\n    \"\"\"Returns the portion of a geometry within a rectangle\n\n    The geometry is clipped in a fast but possibly dirty way. The output is\n    not guaranteed to be valid. No exceptions will be raised for topological\n    errors.\n\n    Parameters\n    ----------\n    geom : geometry\n        The geometry to be clipped\n    xmin : float\n        Minimum x value of the rectangle\n    ymin : float\n        Minimum y value of the rectangle\n    xmax : float\n        Maximum x value of the rectangle\n    ymax : float\n        Maximum y value of the rectangle\n\n    Notes\n    -----\n    New in 1.7.\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    return shapely.clip_by_rect(geom, xmin, ymin, xmax, ymax)", "test_code_list": [{"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_point_outside():\n    \"\"\"Point outside\"\"\"\n    geom1 = load_wkt('POINT (0 0)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_point_outside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_point_inside():\n    \"\"\"Point inside\"\"\"\n    geom1 = load_wkt('POINT (15 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'POINT (15 15)'\n\ntest_point_inside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_point_on_boundary():\n    \"\"\"Point on boundary\"\"\"\n    geom1 = load_wkt('POINT (15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_point_on_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_line_outside():\n    \"\"\"Line outside\"\"\"\n    geom1 = load_wkt('LINESTRING (0 0, -5 5)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_line_outside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_line_inside():\n    \"\"\"Line inside\"\"\"\n    geom1 = load_wkt('LINESTRING (15 15, 16 15)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (15 15, 16 15)'\n\ntest_line_inside()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_line_on_boundary():\n    \"\"\"Line on boundary\"\"\"\n    geom1 = load_wkt('LINESTRING (10 15, 10 10, 15 10)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\ntest_line_on_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef test_line_splitting_rectangle():\n    \"\"\"Line splitting rectangle\"\"\"\n    geom1 = load_wkt('LINESTRING (10 5, 25 20)')\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'LINESTRING (15 10, 20 15)'\n\ntest_line_splitting_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef polygon_hole_ccw_fully_on_rectangle_boundary():\n    \"\"\"Polygon hole (CCW) fully on rectangle boundary\"\"\"\n    geom1 = load_wkt(\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\npolygon_hole_ccw_fully_on_rectangle_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef polygon_hole_cw_fully_on_rectangle_boundary():\n    \"\"\"Polygon hole (CW) fully on rectangle boundary\"\"\"\n    geom1 = load_wkt(\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 10 20, 20 20, 20 10, 10 10))'\n        )\n    geom2 = clip_by_rect(geom1, 10, 10, 20, 20)\n    assert dump_wkt(geom2, rounding_precision=0) == 'GEOMETRYCOLLECTION EMPTY'\n\npolygon_hole_cw_fully_on_rectangle_boundary()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef polygon_fully_within_rectangle():\n    \"\"\"Polygon fully within rectangle\"\"\"\n    wkt = (\n        'POLYGON ((1 1, 1 30, 30 30, 30 1, 1 1), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom1 = load_wkt(wkt)\n    geom2 = clip_by_rect(geom1, 0, 0, 40, 40)\n    assert dump_wkt(geom2, rounding_precision=0) == wkt\n\npolygon_fully_within_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}, {"test_code": "import pytest\nfrom shapely.ops import clip_by_rect\nfrom shapely.wkt import dumps as dump_wkt\nfrom shapely.wkt import loads as load_wkt\ndef polygon_overlapping_rectangle():\n    \"\"\"Polygon overlapping rectangle\"\"\"\n    wkt = (\n        'POLYGON ((0 0, 0 30, 30 30, 30 0, 0 0), (10 10, 20 10, 20 20, 10 20, 10 10))'\n        )\n    geom1 = load_wkt(wkt)\n    geom2 = clip_by_rect(geom1, 5, 5, 15, 15)\n    assert dump_wkt(geom2, rounding_precision=0\n        ) == 'POLYGON ((5 5, 5 15, 10 15, 10 10, 15 10, 15 5, 5 5))'\n\npolygon_overlapping_rectangle()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_clip_by_rect.py"}], "instruction": "Functionality: The clip_by_rect function is designed to extract the part of a given geometry that lies within a specified rectangular area. This process, known as clipping, is performed in a quick but potentially imprecise manner. The function does not validate the output for topological correctness and does not raise exceptions for errors related to geometry topology.\n\nInputs: \n- geom: A geometry object, such as a Point, LineString, Polygon, etc., that is to be clipped.\n- xmin: A float representing the minimum x-coordinate of the clipping rectangle.\n- ymin: A float representing the minimum y-coordinate of the clipping rectangle.\n- xmax: A float representing the maximum x-coordinate of the clipping rectangle.\n- ymax: A float representing the maximum y-coordinate of the clipping rectangle.\n\nOutputs:\n- A geometry object representing the portion of the input geometry that falls within the specified rectangular bounds. If the input geometry is empty, the same empty geometry is returned.", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef clip_by_rect(geom, xmin, ymin, xmax, ymax): [MASK]\n"}
{"method_name": "affine_transform", "full_method_name": "affine_transform", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef affine_transform(geom, matrix):\n    \"\"\"Return a transformed geometry using an affine transformation matrix.\n\n    The coefficient matrix is provided as a list or tuple with 6 or 12 items\n    for 2D or 3D transformations, respectively.\n\n    For 2D affine transformations, the 6 parameter matrix is::\n\n        [a, b, d, e, xoff, yoff]\n\n    which represents the augmented matrix::\n\n        [x']   / a  b xoff \\\\ [x]\n        [y'] = | d  e yoff | [y]\n        [1 ]   \\\\ 0  0   1  / [1]\n\n    or the equations for the transformed coordinates::\n\n        x' = a * x + b * y + xoff\n        y' = d * x + e * y + yoff\n\n    For 3D affine transformations, the 12 parameter matrix is::\n\n        [a, b, c, d, e, f, g, h, i, xoff, yoff, zoff]\n\n    which represents the augmented matrix::\n\n        [x']   / a  b  c xoff \\\\ [x]\n        [y'] = | d  e  f yoff | [y]\n        [z']   | g  h  i zoff | [z]\n        [1 ]   \\\\ 0  0  0   1  / [1]\n\n    or the equations for the transformed coordinates::\n\n        x' = a * x + b * y + c * z + xoff\n        y' = d * x + e * y + f * z + yoff\n        z' = g * x + h * y + i * z + zoff\n    \"\"\"\n    if len(matrix) == 6:\n        ndim = 2\n        a, b, d, e, xoff, yoff = matrix\n        if geom.has_z:\n            ndim = 3\n            i = 1.0\n            c = f = g = h = zoff = 0.0\n    elif len(matrix) == 12:\n        ndim = 3\n        a, b, c, d, e, f, g, h, i, xoff, yoff, zoff = matrix\n        if not geom.has_z:\n            ndim = 2\n    else:\n        raise ValueError(\"'matrix' expects either 6 or 12 coefficients\")\n    if ndim == 2:\n        A = np.array([[a, b], [d, e]], dtype=float)\n        off = np.array([xoff, yoff], dtype=float)\n    else:\n        A = np.array([[a, b, c], [d, e, f], [g, h, i]], dtype=float)\n        off = np.array([xoff, yoff, zoff], dtype=float)\n\n    def _affine_coords(coords):\n        return np.matmul(A, coords.T).T + off\n    return shapely.transform(geom, _affine_coords, include_z=ndim == 3)", "test_code_list": [{"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass AffineTestCase(unittest.TestCase):\n\tdef test_affine_geom_types(self):\n\t    matrix2d = 1, 0, 0, 1, 0, 0\n\t    matrix3d = 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0\n\t    empty2d = load_wkt('MULTIPOLYGON EMPTY')\n\t    assert affine_transform(empty2d, matrix2d).is_empty\n\t\n\t    def test_geom(g2, g3=None):\n\t        assert not g2.has_z\n\t        a2 = affine_transform(g2, matrix2d)\n\t        assert not a2.has_z\n\t        assert g2.equals(a2)\n\t        if g3 is not None:\n\t            assert g3.has_z\n\t            a3 = affine_transform(g3, matrix3d)\n\t            assert a3.has_z\n\t            assert g3.equals(a3)\n\t        return\n\t    pt2d = load_wkt('POINT(12.3 45.6)')\n\t    pt3d = load_wkt('POINT(12.3 45.6 7.89)')\n\t    test_geom(pt2d, pt3d)\n\t    ls2d = load_wkt('LINESTRING(0.9 3.4, 0.7 2, 2.5 2.7)')\n\t    ls3d = load_wkt('LINESTRING(0.9 3.4 3.3, 0.7 2 2.3, 2.5 2.7 5.5)')\n\t    test_geom(ls2d, ls3d)\n\t    lr2d = load_wkt('LINEARRING(0.9 3.4, 0.7 2, 2.5 2.7, 0.9 3.4)')\n\t    lr3d = load_wkt(\n\t        'LINEARRING(0.9 3.4 3.3, 0.7 2 2.3, 2.5 2.7 5.5, 0.9 3.4 3.3)')\n\t    test_geom(lr2d, lr3d)\n\t    test_geom(load_wkt(\n\t        'POLYGON((0.9 2.3, 0.5 1.1, 2.4 0.8, 0.9 2.3), (1.1 1.7, 0.9 1.3, 1.4 1.2, 1.1 1.7), (1.6 1.3, 1.7 1, 1.9 1.1, 1.6 1.3))'\n\t        ))\n\t    test_geom(load_wkt(\n\t        'MULTIPOINT ((-300 300), (700 300), (-800 -1100), (200 -300))'))\n\t    test_geom(load_wkt(\n\t        'MULTILINESTRING((0 0, -0.7 -0.7, 0.6 -1), (-0.5 0.5, 0.7 0.6, 0 -0.6))'\n\t        ))\n\t    test_geom(load_wkt(\n\t        'MULTIPOLYGON(((900 4300, -1100 -400, 900 -800, 900 4300)), ((1200 4300, 2300 4400, 1900 1000, 1200 4300)))'\n\t        ))\n\t    test_geom(load_wkt(\n\t        'GEOMETRYCOLLECTION(POINT(20 70), POLYGON((60 70, 13 35, 60 -30, 60 70)), LINESTRING(60 70, 50 100, 80 100))'\n\t        ))\n\t\nAffineTestCase().test_affine_geom_types()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}, {"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass AffineTestCase(unittest.TestCase):\n\tdef test_affine_2d(self):\n\t    g = load_wkt('LINESTRING(2.4 4.1, 2.4 3, 3 3)')\n\t    expected2d = load_wkt('LINESTRING(-0.2 14.35, -0.2 11.6, 1 11.6)')\n\t    matrix2d = 2, 0, 0, 2.5, -5, 4.1\n\t    a2 = affine_transform(g, matrix2d)\n\t    assert a2.equals_exact(expected2d, 1e-06)\n\t    assert not a2.has_z\n\t    matrix3d = 2, 0, 0, 0, 2.5, 0, 0, 0, 10, -5, 4.1, 100\n\t    a3 = affine_transform(g, matrix3d)\n\t    assert a3.equals_exact(expected2d, 1e-06)\n\t    assert not a3.has_z\n\t\nAffineTestCase().test_affine_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}, {"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass AffineTestCase(unittest.TestCase):\n\tdef test_affine_3d(self):\n\t    g2 = load_wkt('LINESTRING(2.4 4.1, 2.4 3, 3 3)')\n\t    g3 = load_wkt('LINESTRING(2.4 4.1 100.2, 2.4 3 132.8, 3 3 128.6)')\n\t    matrix2d = 2, 0, 0, 2.5, -5, 4.1\n\t    matrix3d = 2, 0, 0, 0, 2.5, 0, 0, 0, 0.3048, -5, 4.1, 100\n\t    a22 = affine_transform(g2, matrix2d)\n\t    a23 = affine_transform(g2, matrix3d)\n\t    a32 = affine_transform(g3, matrix2d)\n\t    a33 = affine_transform(g3, matrix3d)\n\t    assert not a22.has_z\n\t    assert not a23.has_z\n\t    assert a32.has_z\n\t    assert a33.has_z\n\t    expected2d = load_wkt('LINESTRING(-0.2 14.35, -0.2 11.6, 1 11.6)')\n\t    expected3d = load_wkt(\n\t        'LINESTRING(-0.2 14.35 130.54096, -0.2 11.6 140.47744, 1 11.6 139.19728)'\n\t        )\n\t    expected32 = load_wkt(\n\t        'LINESTRING(-0.2 14.35 100.2, -0.2 11.6 132.8, 1 11.6 128.6)')\n\t    assert a22.equals_exact(expected2d, 1e-06)\n\t    assert a23.equals_exact(expected2d, 1e-06)\n\t    for a, e in zip(a32.coords, expected32.coords):\n\t        for ap, ep in zip(a, e):\n\t            self.assertAlmostEqual(ap, ep)\n\t    for a, e in zip(a33.coords, expected3d.coords):\n\t        for ap, ep in zip(a, e):\n\t            self.assertAlmostEqual(ap, ep)\n\t\nAffineTestCase().test_affine_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}], "instruction": "Functionality: The affine_transform function applies an affine transformation to a geometric object using a given coefficient matrix. The transformation can be either 2D or 3D, depending on the length of the matrix, and is represented by an augmented matrix that can scale, rotate, skew, and translate the geometric object.\n\nInputs: \n- geom: A geometric object to be transformed.\n- matrix: A list or tuple containing the coefficients of the affine transformation. It should have either 6 elements for 2D transformations or 12 elements for 3D transformations.\n\nOutputs: \n- A transformed geometric object. The transformation is applied based on the equations defined by the input matrix. The specific transformations (rotation, scaling, etc.) are derived from the coefficients in the matrix.", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef affine_transform(geom, matrix): [MASK]\n"}
{"method_name": "rotate", "full_method_name": "rotate", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef rotate(geom, angle, origin='center', use_radians=False):\n    \"\"\"Returns a rotated geometry on a 2D plane.\n\n    The angle of rotation can be specified in either degrees (default) or\n    radians by setting ``use_radians=True``. Positive angles are\n    counter-clockwise and negative are clockwise rotations.\n\n    The point of origin can be a keyword 'center' for the bounding box\n    center (default), 'centroid' for the geometry's centroid, a Point object\n    or a coordinate tuple (x0, y0).\n\n    The affine transformation matrix for 2D rotation is:\n\n      / cos(r) -sin(r) xoff \\\\\n      | sin(r)  cos(r) yoff |\n      \\\\   0       0      1  /\n\n    where the offsets are calculated from the origin Point(x0, y0):\n\n        xoff = x0 - x0 * cos(r) + y0 * sin(r)\n        yoff = y0 - x0 * sin(r) - y0 * cos(r)\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if not use_radians:\n        angle = angle * pi / 180.0\n    cosp = cos(angle)\n    sinp = sin(angle)\n    if abs(cosp) < 2.5e-16:\n        cosp = 0.0\n    if abs(sinp) < 2.5e-16:\n        sinp = 0.0\n    x0, y0 = interpret_origin(geom, origin, 2)\n    matrix = (cosp, -sinp, 0.0, sinp, cosp, 0.0, 0.0, 0.0, 1.0, x0 - x0 *\n        cosp + y0 * sinp, y0 - x0 * sinp - y0 * cosp, 0.0)\n    return affine_transform(geom, matrix)", "test_code_list": [{"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass TransformOpsTestCase(unittest.TestCase):\n\tdef test_rotate_empty(self):\n\t    rls = rotate(load_wkt('LINESTRING EMPTY'), 90)\n\t    els = load_wkt('LINESTRING EMPTY')\n\t    assert rls.equals(els)\n\t\nTransformOpsTestCase().test_rotate_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}], "instruction": "Functionality: The rotate function is designed to rotate a given geometry on a 2D plane by a specified angle. The rotation can be defined in degrees or radians and can be clockwise or counter-clockwise. The origin of rotation can be the bounding box center, the geometry's centroid, a Point object, or a coordinate tuple.\n\nInputs: \n- geom: The geometry to be rotated. It must be a valid Shapely geometry.\n- angle: The angle of rotation. This can be a positive or negative number representing counter-clockwise or clockwise rotation, respectively.\n- origin: The point of origin for the rotation. It can be a keyword ('center' for bounding box center, 'centroid' for geometry's centroid), a Point object, or a coordinate tuple (x0, y0). Default is 'center'.\n- use_radians: A boolean indicating whether the angle is provided in radians (True) or degrees (False). Default is False.\n\nOutputs:\n- The function returns the rotated geometry as a Shapely geometry object.", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef rotate(geom, angle, origin='center', use_radians=False): [MASK]\n"}
{"method_name": "scale", "full_method_name": "scale", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef scale(geom, xfact=1.0, yfact=1.0, zfact=1.0, origin='center'):\n    \"\"\"Returns a scaled geometry, scaled by factors along each dimension.\n\n    The point of origin can be a keyword 'center' for the 2D bounding box\n    center (default), 'centroid' for the geometry's 2D centroid, a Point\n    object or a coordinate tuple (x0, y0, z0).\n\n    Negative scale factors will mirror or reflect coordinates.\n\n    The general 3D affine transformation matrix for scaling is:\n\n        / xfact  0    0   xoff \\\\\n        |   0  yfact  0   yoff |\n        |   0    0  zfact zoff |\n        \\\\   0    0    0     1  /\n\n    where the offsets are calculated from the origin Point(x0, y0, z0):\n\n        xoff = x0 - x0 * xfact\n        yoff = y0 - y0 * yfact\n        zoff = z0 - z0 * zfact\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    x0, y0, z0 = interpret_origin(geom, origin, 3)\n    matrix = (xfact, 0.0, 0.0, 0.0, yfact, 0.0, 0.0, 0.0, zfact, x0 - x0 *\n        xfact, y0 - y0 * yfact, z0 - z0 * zfact)\n    return affine_transform(geom, matrix)", "test_code_list": [{"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass TransformOpsTestCase(unittest.TestCase):\n\tdef test_scale_empty(self):\n\t    sls = scale(load_wkt('LINESTRING EMPTY'))\n\t    els = load_wkt('LINESTRING EMPTY')\n\t    assert sls.equals(els)\n\t\nTransformOpsTestCase().test_scale_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}], "instruction": "Functionality: The scale function is designed to return a geometry (geom) that has been scaled by factors along each dimension. This operation effectively transforms the geometry by resizing it according to given scale factors for the x, y, and z dimensions. Negative scale factors result in mirroring or reflecting the coordinates.\n\nInputs: \n    - geom: A geometry object to be scaled.\n    - xfact (optional): A scale factor for the x dimension. Default is 1.0.\n    - yfact (optional): A scale factor for the y dimension. Default is 1.0.\n    - zfact (optional): A scale factor for the z dimension. Default is 1.0.\n    - origin (optional): The point of origin for scaling. It can be a keyword 'center' for the 2D bounding box center (default), 'centroid' for the geometry's 2D centroid, a Point object, or a coordinate tuple (x0, y0, z0). Default is 'center'.\n\nOutputs: \n    - A scaled geometry object. If the input geometry is empty, the function returns the geometry unchanged.", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef scale(geom, xfact=1.0, yfact=1.0, zfact=1.0, origin='center'): [MASK]\n"}
{"method_name": "skew", "full_method_name": "skew", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef skew(geom, xs=0.0, ys=0.0, origin='center', use_radians=False):\n    \"\"\"Returns a skewed geometry, sheared by angles along x and y dimensions.\n\n    The shear angle can be specified in either degrees (default) or radians\n    by setting ``use_radians=True``.\n\n    The point of origin can be a keyword 'center' for the bounding box\n    center (default), 'centroid' for the geometry's centroid, a Point object\n    or a coordinate tuple (x0, y0).\n\n    The general 2D affine transformation matrix for skewing is:\n\n        /   1    tan(xs) xoff \\\\\n        | tan(ys)  1     yoff |\n        \\\\   0      0       1  /\n\n    where the offsets are calculated from the origin Point(x0, y0):\n\n        xoff = -y0 * tan(xs)\n        yoff = -x0 * tan(ys)\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if not use_radians:\n        xs = xs * pi / 180.0\n        ys = ys * pi / 180.0\n    tanx = tan(xs)\n    tany = tan(ys)\n    if abs(tanx) < 2.5e-16:\n        tanx = 0.0\n    if abs(tany) < 2.5e-16:\n        tany = 0.0\n    x0, y0 = interpret_origin(geom, origin, 2)\n    matrix = (1.0, tanx, 0.0, tany, 1.0, 0.0, 0.0, 0.0, 1.0, -y0 * tanx, -\n        x0 * tany, 0.0)\n    return affine_transform(geom, matrix)", "test_code_list": [{"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass TransformOpsTestCase(unittest.TestCase):\n\tdef test_skew_empty(self):\n\t    sls = skew(load_wkt('LINESTRING EMPTY'))\n\t    els = load_wkt('LINESTRING EMPTY')\n\t    assert sls.equals(els)\n\t\nTransformOpsTestCase().test_skew_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}], "instruction": "Functionality: The 'skew' function is designed to return a skewed geometry, sheared by angles along the x and y dimensions. The shearing angles can be given in degrees (default) or radians, and the point of origin for the skew operation can be specified as the bounding box center (default), the geometry's centroid, a Point object, or a coordinate tuple (x0, y0). The function implements a 2D affine transformation.\n\nInputs: \n- 'geom': A shapely geometry object to be skewed.\n- 'xs': A float representing the shear angle along the x-axis in degrees (default is 0.0).\n- 'ys': A float representing the shear angle along the y-axis in degrees (default is 0.0).\n- 'origin': A string ('center' or 'centroid'), a Point object, or a coordinate tuple (x0, y0) specifying the point of origin for the skew operation (default is 'center').\n- 'use_radians': A boolean indicating whether the shear angles are given in radians (default is False).\n\nOutputs: \n- A skewed shapely geometry object, transformed according to the specified shear angles and origin point.", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef skew(geom, xs=0.0, ys=0.0, origin='center', use_radians=False): [MASK]\n"}
{"method_name": "translate", "full_method_name": "translate", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef translate(geom, xoff=0.0, yoff=0.0, zoff=0.0):\n    \"\"\"Returns a translated geometry shifted by offsets along each dimension.\n\n    The general 3D affine transformation matrix for translation is:\n\n        / 1  0  0 xoff \\\\\n        | 0  1  0 yoff |\n        | 0  0  1 zoff |\n        \\\\ 0  0  0   1  /\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    matrix = 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, xoff, yoff, zoff\n    return affine_transform(geom, matrix)", "test_code_list": [{"test_code": "import unittest\nfrom math import pi\nimport numpy as np\nimport pytest\nfrom shapely import affinity\nfrom shapely.geometry import Point\nfrom shapely.wkt import loads as load_wkt\n\nclass TransformOpsTestCase(unittest.TestCase):\n\tdef test_translate_empty(self):\n\t    tls = translate(load_wkt('LINESTRING EMPTY'))\n\t    els = load_wkt('LINESTRING EMPTY')\n\t    self.assertTrue(tls.equals(els))\n\t    assert tls.equals(els)\n\t\nTransformOpsTestCase().test_translate_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/shapely/shapely/tests/legacy/test_affinity.py"}], "instruction": "Functionality: The function 'translate' is designed to return a geometry object that has been translated or shifted by specified offsets along the x, y, and z dimensions. The movement is achieved through an affine transformation matrix, which is applied to the input geometry. The transformation matrix for translation is:\n        / 1  0  0 xoff \\\\\n        | 0  1  0 yoff |\n        | 0  0  1 zoff |\n        \\\\ 0  0  0   1  /\n\nInputs: \n    geom: A Shapely geometry object that represents the input shape or geometry to be translated.\n    xoff: A float representing the offset along the x-axis. Default is 0.0.\n    yoff: A float representing the offset along the y-axis. Default is 0.0.\n    zoff: A float representing the offset along the z-axis. Default is 0.0.\n\nOutputs:\n    The function returns a Shapely geometry object that represents the translated version of the input geometry, shifted by the specified xoff, yoff, and zoff values.", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef translate(geom, xoff=0.0, yoff=0.0, zoff=0.0): [MASK]\n"}
