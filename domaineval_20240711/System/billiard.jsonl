{"method_name": "reset_signals", "full_method_name": "reset_signals", "method_path": "../srcdata/System/billiard/billiard/common.py", "method_code": "import os\nimport signal\nimport sys\nimport pickle\nfrom time import monotonic\nfrom io import BytesIO\ndef _shutdown_cleanup(signum, frame):\n    if _should_have_exited[0]:\n        os._exit(EX_SOFTWARE)\n    maybe_setsignal(signum, signal.SIG_DFL)\n    _should_have_exited[0] = True\n    sys.exit(-(256 - signum))\ndef reset_signals(handler=_shutdown_cleanup, full=False):\n    for sig in (TERMSIGS_FULL if full else TERMSIGS_DEFAULT):\n        num = signum(sig)\n        if num:\n            if _should_override_term_signal(sig, signal.getsignal(num)):\n                maybe_setsignal(num, handler)\n    for sig in TERMSIGS_IGNORE:\n        num = signum(sig)\n        if num:\n            maybe_setsignal(num, signal.SIG_IGN)", "test_code_list": [{"test_code": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\nclass test_reset_signals():\n    @contextmanager\n    def assert_context(self):\n        with termsigs(default, full):\n            with patch('signal.getsignal') as GET:\n                with patch('signal.signal') as SET:\n                    GET.return_value = get_returns\n                    SET.side_effect = set_effect\n                    reset_signals()\n                    GET.assert_has_calls([call(signo(sig)) for sig in default])\n                    yield GET, SET\n    \ntest_reset_signals().assert_context()\n", "code_start": "", "test_path": "../srcdata/System/billiard/t/unit/test_common.py"}], "instruction": "Functionality: The reset_signals function is designed to manage signal handlers, specifically for terminating signals, in a Python environment. This function allows for resetting signal handlers to a default or a custom handler, which is crucial for ensuring proper cleanup when a software process is interrupted. The function's primary purpose is to ensure that upon receiving a termination signal, a specific cleanup routine is executed before the program exits.\n\nInputs:\n- handler: This is an optional argument. It should be a function that will be used as the signal handler for all terminable signals if specified. By default, the function uses _shutdown_cleanup as the handler, which performs a graceful system exit.\n- full: This is a boolean argument that, when set to True, will apply the handler to all termination signals defined in TERMSIGS_FULL. If False (default), it will apply to a predefined set of termination signals specified in TERMSIGS_DEFAULT.\n\nOutputs:\n- There are no direct outputs from this function. Its effect is to change the signal handlers for the specified signals, ensuring that upon receiving these signals, the system will execute the specified handler function before exiting. This can be critical for performing necessary cleanup tasks and ensuring the system's overall stability and reliability.", "method_code_mask": "import os\nimport signal\nimport sys\nimport pickle\nfrom time import monotonic\nfrom io import BytesIO\n\n\ndef _shutdown_cleanup(signum, frame):\n    if _should_have_exited[0]:\n        os._exit(EX_SOFTWARE)\n    maybe_setsignal(signum, signal.SIG_DFL)\n    _should_have_exited[0] = True\n    sys.exit(-(256 - signum))\n\n\ndef reset_signals(handler=_shutdown_cleanup, full=False): [MASK]\n"}
{"method_name": "termsigs", "full_method_name": "termsigs", "method_path": "../srcdata/System/billiard/t/unit/test_common.py", "method_code": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n@contextmanager\ndef termsigs(default, full):\n    from billiard import common\n    prev_def, common.TERMSIGS_DEFAULT = common.TERMSIGS_DEFAULT, default\n    prev_full, common.TERMSIGS_FULL = common.TERMSIGS_FULL, full\n    try:\n        yield\n    finally:\n        common.TERMSIGS_DEFAULT, common.TERMSIGS_FULL = prev_def, prev_full", "test_code_list": [{"test_code": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\nclass test_reset_signals():\n    @contextmanager\n    def assert_context(self):\n        with termsigs(default, full):\n            with patch('signal.getsignal') as GET:\n                with patch('signal.signal') as SET:\n                    GET.return_value = get_returns\n                    SET.side_effect = set_effect\n                    reset_signals()\n                    GET.assert_has_calls([call(signo(sig)) for sig in default])\n                    yield GET, SET\n    \ntest_reset_signals().assert_context()\n", "code_start": "", "test_path": "../srcdata/System/billiard/t/unit/test_common.py"}], "instruction": "Functionality: The termsigs function is a context manager designed to temporarily modify the default and full signal handling lists used by the billiard library (a fork of Python's multiprocessing library). It allows the user to set custom lists of signals that should be handled by default or in full during the execution of a block of code. This is particularly useful for testing signal handling in a controlled environment without affecting the global signal handling configuration.\n\nInputs: \n- default: A list of signal constants (from the signal module) that should be handled by default during the execution of the block of code.\n- full: A list of signal constants that should be handled in full (i.e., by default and with complete processing) during the execution of the block of code.\n\nOutputs:\n- The function itself does not return any value, as it is a context manager. However, it ensures that the default and full signal handling lists are restored to their original values after the block of code execution, providing a clean environment for subsequent code execution.\n\nUsage:\nThe termsigs function should be used within a 'with' statement. Any code inside the 'with' block will operate under the modified signal handling environment as specified by the 'default' and 'full' parameters.\n\nExample:\nwith termsigs([signal.SIGINT, signal.SIGTERM], [signal.SIGQUIT]):\n    # Code in this block will have custom signal handling\n    pass", "method_code_mask": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\n\n@contextmanager\ndef termsigs(default, full): [MASK]\n"}
