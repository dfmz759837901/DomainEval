{"method_name": "_parse_client_id", "full_method_name": "_parse_client_id", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "method_code": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\ndef _parse_client_id(client_id: str) ->ParseResult:\n    \"\"\"Test if client id is a valid URL according to IndieAuth section 3.2.\n    https://indieauth.spec.indieweb.org/#client-identifier\n    \"\"\"\n    parts = _parse_url(client_id)\n    if parts.scheme not in ('http', 'https'):\n        raise ValueError\n    if any(segment in ('.', '..') for segment in parts.path.split('/')):\n        raise ValueError(\n            'Client ID cannot contain single-dot or double-dot path segments')\n    if parts.fragment != '':\n        raise ValueError('Client ID cannot contain a fragment')\n    if parts.username is not None:\n        raise ValueError('Client ID cannot contain username')\n    if parts.password is not None:\n        raise ValueError('Client ID cannot contain password')\n    try:\n        _ = parts.port\n    except ValueError as ex:\n        raise ValueError('Client ID contains invalid port') from ex\n    address = None\n    try:\n        netloc = parts.netloc\n        if netloc[0] == '[' and netloc[-1] == ']':\n            netloc = netloc[1:-1]\n        address = ip_address(netloc)\n    except ValueError:\n        pass\n    if address is None or is_local(address):\n        return parts\n    raise ValueError('Hostname should be a domain name or local IP address')", "test_code_list": [{"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_client_id_scheme() ->None:\n    \"\"\"Test we enforce valid scheme.\"\"\"\n    assert _parse_client_id('http://ex.com/')\n    assert _parse_client_id('https://ex.com/')\n    with pytest.raises(ValueError):\n        _parse_client_id('ftp://ex.com')\n\ntest_client_id_scheme()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}, {"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_client_id_path() ->None:\n    \"\"\"Test we enforce valid path.\"\"\"\n    assert _parse_client_id('http://ex.com').path == '/'\n    assert _parse_client_id('http://ex.com/hello').path == '/hello'\n    assert _parse_client_id('http://ex.com/hello/.world'\n        ).path == '/hello/.world'\n    assert _parse_client_id('http://ex.com/hello./.world'\n        ).path == '/hello./.world'\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/.')\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/hello/./yo')\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/hello/../yo')\n\ntest_client_id_path()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}], "instruction": "Functionality: The _parse_client_id function is designed to validate a client identifier (client_id) to ensure it conforms to IndieAuth section 3.2 standards. This includes checking the URL's scheme, path segments, fragment, username, password, port, and ensuring that the hostname is a domain name or a local IP address.\n\nInputs: \n- client_id: A string representing the client identifier URL to be validated.\n\nOutputs:\n- If the client_id is valid, the function returns a ParseResult object that represents the parsed and canonicalized URL.\n- If the client_id is invalid, the function raises a ValueError with an appropriate error message detailing the validation failure.", "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\n\n\ndef _parse_client_id(client_id: str) ->ParseResult: [MASK]\n"}
{"method_name": "_parse_url", "full_method_name": "_parse_url", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "method_code": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts", "test_code_list": [{"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_parse_url_lowercase_host() ->None:\n    \"\"\"Test we update empty paths.\"\"\"\n    assert _parse_url('http://ex.com/hello').path == '/hello'\n    assert _parse_url('http://EX.COM/hello').hostname == 'ex.com'\n    parts = _parse_url('http://EX.COM:123/HELLO')\n    assert parts.netloc == 'ex.com:123'\n    assert parts.path == '/HELLO'\n\ntest_parse_url_lowercase_host()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}, {"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_parse_url_path() ->None:\n    \"\"\"Test we update empty paths.\"\"\"\n    assert _parse_url('http://ex.com').path == '/'\n\ntest_parse_url_path()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}], "instruction": "Functionality: The _parse_url function is designed to parse a given URL into its constituent parts and then canonicalize it according to the IndieAuth specification. This includes converting the network location (netloc) to lowercase and ensuring that the path component is not empty, appending a '/' if necessary.\n\nInputs: \n- url: A string representing the URL to be parsed. This URL should be a valid web address.\n\nOutputs:\n- A urllib.parse.ParseResult object containing the parsed URL components after canonicalization. The returned object will have the netloc in lowercase and a non-empty path component, with a '/' added if the original path was empty. This object includes the scheme, netloc, path, params, query, and fragment of the URL.", "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult: [MASK]\n"}
{"method_name": "as_number", "full_method_name": "as_number", "method_path": "../srcdata/System/core/homeassistant/components/ista_ecotrend/util.py", "method_code": "from __future__ import annotations\nimport datetime\nfrom typing import Any\ndef as_number(value: (str | float | None)) ->(float | int | None):\n    \"\"\"Convert readings to float or int.\n\n    Readings in the json response are returned as strings,\n    float values have comma as decimal separator\n    \"\"\"\n    if isinstance(value, str):\n        return int(value) if value.isdigit() else float(value.replace(',', '.')\n            )\n    return value", "test_code_list": [{"test_code": "def test_as_number() ->None:\n    \"\"\"Test as_number formatting function.\"\"\"\n    assert as_number('10') == 10\n    assert isinstance(as_number('10'), int)\n    assert as_number('9,5') == 9.5\n    assert isinstance(as_number('9,5'), float)\n    assert as_number(None) is None\n    assert isinstance(as_number(10.0), float)\n\ntest_as_number()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/ista_ecotrend/test_util.py"}], "instruction": "Functionality: The as_number function is designed to convert a given value, which could be in string, float, or None format, to either a float, int, or None. This function is particularly useful for handling readings from JSON responses, where these readings are often represented as strings. If the input is a string and represents an integer, it will be converted to an int. If the input is a string and represents a float, with a comma as the decimal separator, it will be converted to a float by replacing the comma with a dot. If the input is already a float or None, it will be returned as is.\n\nInputs: The function takes a single argument: a value which can be of any type (str | float | None).\n\nOutputs: The function returns a value which can be of any type (float | int | None), depending on the input. If the input is a string representing an integer, it returns an int. If the input is a string representing a float with a comma as the decimal separator, it returns a float. If the input is a float or None, it returns the input value unchanged.", "method_code_mask": "from __future__ import annotations\nimport datetime\nfrom typing import Any\n\n\ndef as_number(value: (str | float | None)) ->(float | int | None): [MASK]\n"}
{"method_name": "_get_community_post_import_url", "full_method_name": "_get_community_post_import_url", "method_path": "../srcdata/System/core/homeassistant/components/blueprint/importer.py", "method_code": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\ndef _get_community_post_import_url(url: str) ->str:\n    \"\"\"Convert a forum post url to an import url.\n    Async friendly.\n    \"\"\"\n    if (match := COMMUNITY_TOPIC_PATTERN.match(url)) is None:\n        raise UnsupportedUrl('Not a topic url')\n    _topic, post = match.groups()\n    json_url = url\n    if post is not None:\n        json_url = json_url[:-len(post) - 1]\n    json_url += '.json'\n    return json_url", "test_code_list": [{"test_code": "import json\nfrom pathlib import Path\nimport pytest\ndef test_get_community_post_import_url() ->None:\n    \"\"\"Test variations of generating import forum url.\"\"\"\n    assert _get_community_post_import_url(\n        'https://community.home-assistant.io/t/test-topic/123'\n        ) == 'https://community.home-assistant.io/t/test-topic/123.json'\n    assert _get_community_post_import_url(\n        'https://community.home-assistant.io/t/test-topic/123/2'\n        ) == 'https://community.home-assistant.io/t/test-topic/123.json'\n\ntest_get_community_post_import_url()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/blueprint/test_importer.py"}], "instruction": "Functionality: The function _get_community_post_import_url is designed to convert a given community forum post URL into an import URL format. This import URL is used for specific operations within the software, such as importing data or posts for further processing. The function ensures that the URL is in the correct format and adjusts it if necessary to include a .json extension, which is crucial for JSON data retrieval.\n\nInputs: \n- The function takes a single string argument, 'url', which should be a URL string pointing to a specific post on the community forum.\n\nOutputs:\n- The function returns a string that represents the modified URL, adjusted to include a .json extension at the end, making it suitable for JSON data import. If the input URL does not match the expected pattern (i.e., is not a valid community topic URL), the function raises an UnsupportedUrl exception.", "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\n\n\ndef _get_community_post_import_url(url: str) ->str: [MASK]\n"}
{"method_name": "density_to_air_quality", "full_method_name": "density_to_air_quality", "method_path": "../srcdata/System/core/homeassistant/components/homekit/util.py", "method_code": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\ndef density_to_air_quality(density: float) ->int:\n    \"\"\"Map PM2.5 \u00b5g/m3 density to HomeKit AirQuality level.\"\"\"\n    if density <= 9:\n        return 1\n    if density <= 35.4:\n        return 2\n    if density <= 55.4:\n        return 3\n    if density <= 125.4:\n        return 4\n    return 5", "test_code_list": [{"test_code": "from unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\ndef test_density_to_air_quality() ->None:\n    \"\"\"Test map PM2.5 density to HomeKit AirQuality level.\"\"\"\n    assert density_to_air_quality(0) == 1\n    assert density_to_air_quality(9) == 1\n    assert density_to_air_quality(9.1) == 2\n    assert density_to_air_quality(12) == 2\n    assert density_to_air_quality(35.4) == 2\n    assert density_to_air_quality(35.5) == 3\n    assert density_to_air_quality(55.4) == 3\n    assert density_to_air_quality(55.5) == 4\n    assert density_to_air_quality(125.4) == 4\n    assert density_to_air_quality(125.5) == 5\n    assert density_to_air_quality(200) == 5\n\ntest_density_to_air_quality()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/homekit/test_util.py"}], "instruction": "Functionality: The function maps PM2.5 particulate matter density to an air quality level as defined by HomeKit standards. PM2.5 is a measure of the concentration of particulate matter in the air, with a size of 2.5 micrometers or less, indicating air pollution levels. The function uses predefined density thresholds to categorize the air quality into levels, which can be useful for devices to display or react to the air quality status.\n\nInputs: \n- density (float): This represents the PM2.5 particulate matter density in micrograms per cubic meter (\u00b5g/m3). It is the input parameter that the function uses to determine the air quality level.\n\nOutputs: \n- (int): The function returns an integer representing the HomeKit AirQuality level based on the input density. The levels are as follows:\n    - 1: for densities <= 9 \u00b5g/m3\n    - 2: for densities > 9 \u00b5g/m3 and <= 35.4 \u00b5g/m3\n    - 3: for densities > 35.4 \u00b5g/m3 and <= 55.4 \u00b5g/m3\n    - 4: for densities > 55.4 \u00b5g/m3 and <= 125.4 \u00b5g/m3\n    - 5: for densities > 125.4 \u00b5g/m3", "method_code_mask": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\n\n\ndef density_to_air_quality(density: float) ->int: [MASK]\n"}
{"method_name": "create_matcher", "full_method_name": "create_matcher", "method_path": "../srcdata/System/core/homeassistant/components/conversation/util.py", "method_code": "from __future__ import annotations\nimport re\ndef create_matcher(utterance: str) ->re.Pattern[str]:\n    \"\"\"Create a regex that matches the utterance.\"\"\"\n    parts = re.split('({\\\\w+}|\\\\[[\\\\w\\\\s]+\\\\] *)', utterance)\n    group_matcher = re.compile('{(\\\\w+)}')\n    optional_matcher = re.compile('\\\\[([\\\\w ]+)\\\\] *')\n    pattern = ['^']\n    for part in parts:\n        group_match = group_matcher.match(part)\n        optional_match = optional_matcher.match(part)\n        if group_match is None and optional_match is None:\n            pattern.append(part)\n            continue\n        if group_match is not None:\n            pattern.append(f'(?P<{group_match.groups()[0]}>[\\\\w ]+?)\\\\s*')\n        elif optional_match is not None:\n            pattern.append(f'(?:{optional_match.groups()[0]} *)?')\n    pattern.append('$')\n    return re.compile(''.join(pattern), re.IGNORECASE)", "test_code_list": [{"test_code": "def test_create_matcher() ->None:\n    \"\"\"Test the create matcher method.\"\"\"\n    pattern = create_matcher('Hello world')\n    assert pattern.match('Hello world') is not None\n    pattern = create_matcher('Hello {name}')\n    match = pattern.match('hello world')\n    assert match is not None\n    assert match.groupdict()['name'] == 'world'\n    no_match = pattern.match('Hello world, how are you?')\n    assert no_match is None\n    pattern = create_matcher('Turn on [the] {name}')\n    match = pattern.match('turn on the kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn off kitchen lights')\n    assert match is None\n    pattern = create_matcher('Turn on [the] [a] {name}')\n    match = pattern.match('turn on the kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on a kitchen light')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen light'\n    pattern = create_matcher('Turn {name}[s] on')\n    match = pattern.match('turn kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen light'\n    pattern = create_matcher('Turn [the great] {name} on')\n    match = pattern.match('turn the great kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n\ntest_create_matcher()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/conversation/test_util.py"}], "instruction": "Functionality: The create_matcher function is designed to generate a regex pattern that matches the provided utterance string. This regex pattern will account for placeholders denoted by curly braces `{}` and optional segments denoted by square brackets `[]`. Placeholders should be replaced with any word (letters and spaces) and optional segments should be considered as parts of the pattern that may or may not be present.\n\nInputs: \n- utterance: A string representing the utterance for which the regex pattern is to be created. The utterance may contain placeholders (e.g., `{greeting}`) and optional segments (e.g., `[ hi ]`).\n\nOutputs:\n- A compiled regex pattern (re.Pattern[str]) that matches the utterance, accounting for placeholders and optional segments. This regex pattern can be used to match strings against the provided utterance.", "method_code_mask": "from __future__ import annotations\nimport re\n\n\ndef create_matcher(utterance: str) ->re.Pattern[str]: [MASK]\n"}
{"method_name": "gps_accuracy", "full_method_name": "gps_accuracy", "method_path": "../srcdata/System/core/homeassistant/components/aprs/device_tracker.py", "method_code": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int:\n    \"\"\"Calculate the GPS accuracy based on APRS posambiguity.\"\"\"\n    pos_a_map = {(0): 0, (1): 1 / 600, (2): 1 / 60, (3): 1 / 6, (4): 1}\n    if posambiguity in pos_a_map:\n        degrees = pos_a_map[posambiguity]\n        gps2 = gps[0], gps[1] + degrees\n        dist_m: float = geopy.distance.distance(gps, gps2).m\n        accuracy = round(dist_m)\n    else:\n        message = f\"APRS position ambiguity must be 0-4, not '{posambiguity}'.\"\n        raise ValueError(message)\n    return accuracy", "test_code_list": [{"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_0() ->None:\n    \"\"\"Test GPS accuracy level 0.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 0)\n    assert acc == 0\ntest_gps_accuracy_0()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_1() ->None:\n    \"\"\"Test GPS accuracy level 1.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 1)\n    assert acc == 186\ntest_gps_accuracy_1()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_2() ->None:\n    \"\"\"Test GPS accuracy level 2.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 2)\n    assert acc == 1855\ntest_gps_accuracy_2()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_3() ->None:\n    \"\"\"Test GPS accuracy level 3.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 3)\n    assert acc == 18553\ntest_gps_accuracy_3()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_4() ->None:\n    \"\"\"Test GPS accuracy level 4.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 4)\n    assert acc == 111319\ntest_gps_accuracy_4()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}], "instruction": "Functionality: The gps_accuracy function calculates the accuracy of a GPS coordinate based on the APRS (Automatic Packet Reporting System) posambiguity value. It uses the geopy.distance module to compute the distance between the given GPS coordinate and a modified version of it, where the longitude is incremented by a degree value corresponding to the posambiguity. The accuracy is determined as the distance in meters between these two points.\n\nInputs: \n- gps: A tuple containing two float values representing the latitude and longitude of the GPS coordinate.\n- posambiguity: An integer (0-4) indicating the ambiguity of the position reported by APRS. This value determines the degree increment for the longitude in the GPS coordinate.\n\nOutputs:\n- accuracy: An integer representing the calculated GPS accuracy in meters. The function raises a ValueError if the posambiguity is not within the range of 0-4.", "method_code_mask": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\n\n\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int: [MASK]\n"}
{"method_name": "instance", "full_method_name": "TurboJPEGSingleton.instance", "method_path": "../srcdata/System/core/homeassistant/components/camera/img_util.py", "method_code": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None):\n        \"\"\"Singleton for TurboJPEG.\"\"\"\n        if TurboJPEGSingleton.__instance is None:\n            TurboJPEGSingleton()\n        return TurboJPEGSingleton.__instance\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False", "test_code_list": [{"test_code": "from unittest.mock import patch\nimport pytest\ndef _clear_turbojpeg_singleton():\n    TurboJPEGSingleton.__instance = None\ndef test_turbojpeg_singleton() ->None:\n    \"\"\"Verify the instance always gives back the same.\"\"\"\n    _clear_turbojpeg_singleton()\n    assert TurboJPEGSingleton.instance() == TurboJPEGSingleton.instance()\ntest_turbojpeg_singleton()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/camera/test_img_util.py"}], "instruction": "Functionality: The TurboJPEGSingleton.instance function is designed to ensure that the TurboJPEG library is loaded only once to avoid redundant load attempts and potential failures during each snapshot taken by the camera. It implements a singleton pattern, allowing access to a single instance of TurboJPEG or a fallback mechanism when loading the library fails.\n\nInputs: The function does not require any input arguments. It is a static method that is called without passing any parameters.\n\nOutputs: The function returns TurboJPEG | Literal[False] | None. If the TurboJPEG library loads successfully, it returns an instance of TurboJPEG. If the load attempt fails, it returns the value False to indicate that the library could not be loaded, and performance may be sub-optimal. If the instance is yet to be determined or an error occurs during initialization, it returns None.", "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\n\n\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None): [MASK]\n\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False\n"}
{"method_name": "chunk_samples", "full_method_name": "chunk_samples", "method_path": "../srcdata/System/core/homeassistant/components/assist_pipeline/vad.py", "method_code": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]:\n    \"\"\"Yield fixed-sized chunks from samples, keeping leftover bytes from previous call(s).\"\"\"\n    if len(leftover_chunk_buffer) + len(samples) < bytes_per_chunk:\n        leftover_chunk_buffer.append(samples)\n        return\n    next_chunk_idx = 0\n    if leftover_chunk_buffer:\n        bytes_to_copy = bytes_per_chunk - len(leftover_chunk_buffer)\n        leftover_chunk_buffer.append(samples[:bytes_to_copy])\n        next_chunk_idx = bytes_to_copy\n        yield leftover_chunk_buffer.bytes()\n        leftover_chunk_buffer.clear()\n    while next_chunk_idx < len(samples) - bytes_per_chunk + 1:\n        yield samples[next_chunk_idx:next_chunk_idx + bytes_per_chunk]\n        next_chunk_idx += bytes_per_chunk\n    if (rest_samples := samples[next_chunk_idx:]):\n        leftover_chunk_buffer.append(rest_samples)", "test_code_list": [{"test_code": "import itertools as it\nfrom unittest.mock import patch\ndef test_partial_chunk() ->None:\n    \"\"\"Test that chunk_samples returns when given a partial chunk.\"\"\"\n    bytes_per_chunk = 5\n    samples = bytes([1, 2, 3])\n    leftover_chunk_buffer = AudioBuffer(bytes_per_chunk)\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 0\n    assert leftover_chunk_buffer.bytes() == samples\n\ntest_partial_chunk()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/assist_pipeline/test_vad.py"}, {"test_code": "import itertools as it\nfrom unittest.mock import patch\ndef test_chunk_samples_leftover() ->None:\n    \"\"\"Test that chunk_samples property keeps left over bytes across calls.\"\"\"\n    bytes_per_chunk = 5\n    samples = bytes([1, 2, 3, 4, 5, 6])\n    leftover_chunk_buffer = AudioBuffer(bytes_per_chunk)\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 1\n    assert leftover_chunk_buffer.bytes() == bytes([6])\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 1\n    assert leftover_chunk_buffer.bytes() == bytes([5, 6])\n\ntest_chunk_samples_leftover()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/assist_pipeline/test_vad.py"}], "instruction": "Functionality: The chunk_samples function takes a bytes object containing audio samples and divides it into fixed-sized chunks. It also uses a buffer to store any leftover bytes from previous calls that did not fit into a complete chunk. This function ensures that all samples are processed in complete chunks of the specified size, with any incomplete chunks being held over for the next call.\n\nInputs: \n1. samples: A bytes object representing the audio samples to be processed.\n2. bytes_per_chunk: An integer specifying the size of each chunk to be yielded.\n3. leftover_chunk_buffer: An AudioBuffer object used to hold any leftover bytes from previous calls that did not fit into a complete chunk.\n\nOutputs:\n1. An Iterable of bytes objects, where each object is a chunk of samples of the specified size. If the combined size of the leftover bytes and new samples is less than the chunk size, no chunks are yielded, and the leftover bytes are appended to the buffer for the next call.", "method_code_mask": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\n\n\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\n\n\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]: [MASK]\n"}
{"method_name": "get_time_zone", "full_method_name": "get_time_zone", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "method_code": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None):\n    \"\"\"Get time zone from string. Return None if unable to determine.\n\n    Must be run in the executor if the ZoneInfo is not already\n    in the cache. If you are not sure, use async_get_time_zone.\n    \"\"\"\n    try:\n        return zoneinfo.ZoneInfo(time_zone_str)\n    except zoneinfo.ZoneInfoNotFoundError:\n        return None", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\nTEST_TIME_ZONE = 'America/Los_Angeles'\ndef test_get_time_zone_retrieves_valid_time_zone() ->None:\n    \"\"\"Test getting a time zone.\"\"\"\n    assert get_time_zone(TEST_TIME_ZONE) is not None\ntest_get_time_zone_retrieves_valid_time_zone()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}, {"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\ndef test_get_time_zone_returns_none_for_garbage_time_zone() ->None:\n    \"\"\"Test getting a non existing time zone.\"\"\"\n    assert get_time_zone('Non existing time zone') is None\n\ntest_get_time_zone_returns_none_for_garbage_time_zone()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}], "instruction": "Functionality: The function 'get_time_zone' is designed to convert a string that represents a time zone into a timezone object that can be understood and used by Python's datetime library. The function aims to help in determining the timezone information from a string representation. If the string does not represent a valid or recognizable timezone, the function returns None.\n\nInputs: \n    time_zone_str: str\n        A string that potentially represents a time zone. The string should follow the format recognized by the 'zoneinfo' library in Python, such as \"America/New_York\", \"Europe/London\", etc.\n\nOutputs:\n    dt.tzinfo | None\n        The function returns a timezone object that can be used with datetime objects to localize times to specific time zones. If the provided string does not correspond to a valid timezone, the function returns None.", "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None): [MASK]\n"}
{"method_name": "parse_time_expression", "full_method_name": "parse_time_expression", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "method_code": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]:\n    \"\"\"Parse the time expression part and return a list of times to match.\"\"\"\n    if parameter is None or parameter == '*':\n        res = list(range(min_value, max_value + 1))\n    elif isinstance(parameter, str):\n        if parameter.startswith('/'):\n            parameter = int(parameter[1:])\n            res = [x for x in range(min_value, max_value + 1) if x %\n                parameter == 0]\n        else:\n            res = [int(parameter)]\n    elif not hasattr(parameter, '__iter__'):\n        res = [int(parameter)]\n    else:\n        res = sorted(int(x) for x in parameter)\n    for val in res:\n        if val < min_value or val > max_value:\n            raise ValueError(\n                f\"Time expression '{parameter}': parameter {val} out of range ({min_value} to {max_value})\"\n                )\n    return res", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\ndef test_parse_time_expression() ->None:\n    \"\"\"Test parse_time_expression.\"\"\"\n    assert list(range(60)) == parse_time_expression('*', 0, 59)\n    assert list(range(60)) == parse_time_expression(None, 0, 59)\n    assert list(range(0, 60, 5)) == parse_time_expression('/5', 0, 59)\n    assert parse_time_expression([2, 1, 3], 0, 59) == [1, 2, 3]\n    assert list(range(24)) == parse_time_expression('*', 0, 23)\n    assert parse_time_expression(42, 0, 59) == [42]\n    assert parse_time_expression('42', 0, 59) == [42]\n    with pytest.raises(ValueError):\n        parse_time_expression(61, 0, 60)\n\ntest_parse_time_expression()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}], "instruction": "Functionality: The parse_time_expression function is designed to interpret and parse a given time expression, which could be a string, integer, or iterable, and translates it into a list of integers representing times that match the expression within a specified range.\n\nInputs: \n- parameter: Any\n    This is the time expression to be parsed. It can be None, a string (e.g., '*', '5', or '/2'), an integer, or an iterable of integers or strings that can be converted to integers.\n- min_value: int\n    The minimum value in the range of times to consider.\n- max_value: int\n    The maximum value in the range of times to consider.\n\nOutputs:\n- list[int]\n    A list of integers representing times that match the given time expression within the specified range. If the expression is '*', the function returns all times in the range as a list.\n    If the expression starts with '/', it returns a list of times divisible by the number following '/'.\n    If the expression is an integer or a string that can be converted to an integer, the function returns a list containing that single time.\n    If the expression is an iterable, the function returns a sorted list of the times contained in the iterable.\n    If any of the times in the output list are outside the range specified by min_value and max_value, the function raises a ValueError.", "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]: [MASK]\n"}
{"method_name": "is_ip_address", "full_method_name": "is_ip_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ip_address() ->None:\n    \"\"\"Test if strings are IP addresses.\"\"\"\n    assert is_ip_address('192.168.0.1')\n    assert is_ip_address('8.8.8.8')\n    assert is_ip_address('::ffff:127.0.0.0')\n    assert not is_ip_address('192.168.0.999')\n    assert not is_ip_address('192.168.0.0/24')\n    assert not is_ip_address('example.com')\n\ntest_is_ip_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "instruction": "Functionality: This function is designed to verify whether a provided string is a valid Internet Protocol (IP) address. It supports both IPv4 and IPv6 formats. The function utilizes the ipaddress module from the Python Standard Library to perform the validation.\n\nInputs: \n- address: A string representing the IP address that needs to be checked.\n\nOutputs: \n- bool: The function returns a boolean value. It returns True if the input string is a valid IP address (either IPv4 or IPv6), and False otherwise. If the input string is not a valid IP address, the function catches the ValueError exception and returns False.", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool: [MASK]\n"}
{"method_name": "is_ipv4_address", "full_method_name": "is_ipv4_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv4_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv4 address.\"\"\"\n    try:\n        IPv4Address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ipv4_address() ->None:\n    \"\"\"Test if strings are IPv4 addresses.\"\"\"\n    assert is_ipv4_address('192.168.0.1') is True\n    assert is_ipv4_address('8.8.8.8') is True\n    assert is_ipv4_address('192.168.0.999') is False\n    assert is_ipv4_address('192.168.0.0/24') is False\n    assert is_ipv4_address('example.com') is False\n\ntest_is_ipv4_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "instruction": "Functionality: The function is designed to determine whether a given string is a valid IPv4 address. It uses the `IPv4Address` class from the `ipaddress` module to attempt to create an IPv4 address object from the input string. If the creation is successful, the function returns True, indicating that the input string is a valid IPv4 address. If a `ValueError` is raised during the attempt, this implies that the input string is not a valid IPv4 address, and the function returns False.\n\nInputs: The function takes a single argument, `address`, which is expected to be a string. This string is to be checked to see if it represents a valid IPv4 address.\n\nOutputs: The function returns a Boolean value. It returns True if the input string is a valid IPv4 address, and False otherwise.", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv4_address(address: str) ->bool: [MASK]\n"}
{"method_name": "is_ipv6_address", "full_method_name": "is_ipv6_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv6_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv6 address.\"\"\"\n    try:\n        IPv6Address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ipv6_address() ->None:\n    \"\"\"Test if strings are IPv6 addresses.\"\"\"\n    assert is_ipv6_address('::1') is True\n    assert is_ipv6_address('8.8.8.8') is False\n    assert is_ipv6_address('8.8.8.8') is False\n\ntest_is_ipv6_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "instruction": "Functionality: The function is intended to determine whether a given string is a valid IPv6 address. It uses the ipaddress module from the Python Standard Library to perform this check.\n\nInputs: The function takes a single argument, 'address', which is expected to be a string. This string should represent a potential IPv6 address to be validated.\n\nOutputs: The function returns a boolean value. True is returned if the input string is a valid IPv6 address, and False is returned if the input string is not a valid IPv6 address.", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv6_address(address: str) ->bool: [MASK]\n"}
{"method_name": "is_host_valid", "full_method_name": "is_host_valid", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\ndef is_host_valid(host: str) ->bool:\n    \"\"\"Check if a given string is an IP address or valid hostname.\"\"\"\n    if is_ip_address(host):\n        return True\n    if len(host) > 255:\n        return False\n    if re.match('^[0-9\\\\.]+$', host):\n        return False\n    if host.endswith('.'):\n        host = host[:-1]\n    allowed = re.compile('(?!-)[A-Z\\\\d\\\\-]{1,63}(?<!-)$', re.IGNORECASE)\n    return all(allowed.match(x) for x in host.split('.'))", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_valid_host() ->None:\n    \"\"\"Test if strings are IPv6 addresses.\"\"\"\n    assert is_host_valid('::1')\n    assert is_host_valid('::ffff:127.0.0.0')\n    assert is_host_valid('2001:0db8:85a3:0000:0000:8a2e:0370:7334'\n        )\n    assert is_host_valid('8.8.8.8')\n    assert is_host_valid('local')\n    assert is_host_valid('host-host')\n    assert is_host_valid('example.com')\n    assert is_host_valid('example.com.')\n    assert is_host_valid('Example123.com')\n    assert not is_host_valid('')\n    assert not is_host_valid('192.168.0.1:8080')\n    assert not is_host_valid('192.168.0.999')\n    assert not is_host_valid('2001:hb8::1:0:0:1')\n    assert not is_host_valid('-host-host')\n    assert not is_host_valid('host-host-')\n    assert not is_host_valid('host_host')\n    assert not is_host_valid('example.com/path')\n    assert not is_host_valid('example.com:8080')\n    assert not is_host_valid('verylonghostname' * 4)\n    assert not is_host_valid('verydeepdomain.' * 18)\n\ntest_is_valid_host()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "instruction": "Functionality: The function is_host_valid is designed to determine whether a given string is a valid host, which could be either an IP address (IPv4 or IPv6) or a valid hostname.\nInputs: The function takes a single string argument, 'host', which is the host to be validated.\nOutputs: The function returns a boolean value, True if the 'host' is a valid IP address or hostname, and False if it is not.", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\n\n\ndef is_host_valid(host: str) ->bool: [MASK]\n"}
{"method_name": "normalize_url", "full_method_name": "normalize_url", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef normalize_url(address: str) ->str:\n    \"\"\"Normalize a given URL.\"\"\"\n    url = yarl.URL(address.rstrip('/'))\n    if url.is_absolute() and url.is_default_port():\n        return str(url.with_port(None))\n    return str(url)", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_normalize_url() ->None:\n    \"\"\"Test the normalizing of URLs.\"\"\"\n    assert normalize_url('http://example.com'\n        ) == 'http://example.com'\n    assert normalize_url('https://example.com'\n        ) == 'https://example.com'\n    assert normalize_url('https://example.com/'\n        ) == 'https://example.com'\n    assert normalize_url('https://example.com:443'\n        ) == 'https://example.com'\n    assert normalize_url('http://example.com:80'\n        ) == 'http://example.com'\n    assert normalize_url('https://example.com:80'\n        ) == 'https://example.com:80'\n    assert normalize_url('http://example.com:443'\n        ) == 'http://example.com:443'\n    assert normalize_url('https://example.com:443/test/'\n        ) == 'https://example.com/test'\n    assert normalize_url('/test/') == '/test'\n\ntest_normalize_url()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "instruction": "Functionality: The normalize_url function aims to normalize a given URL string. It removes any trailing slashes from the URL, and if the URL is absolute and contains a default port, it will remove the port number from the URL string. This function ensures that URLs are in a consistent format, which is useful for various web-related tasks such as web scraping, URL validation, or storing URLs in a database.\n\nInputs: A single string argument, 'address', which represents the URL to be normalized. The URL could be in various formats, including absolute or relative URLs, with or without a trailing slash, and with or without a specified default port.\n\nOutputs: A single string, which is the normalized URL. If the input URL was absolute and contained a default port, the port number will be removed from the output. Trailing slashes from the input URL will also be removed. The output string represents the normalized form of the input URL.", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef normalize_url(address: str) ->str: [MASK]\n"}
{"method_name": "serialize_response", "full_method_name": "serialize_response", "method_path": "../srcdata/System/core/homeassistant/util/aiohttp.py", "method_code": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\ndef serialize_response(response: web.Response) ->dict[str, Any]:\n    \"\"\"Serialize an aiohttp response to a dictionary.\"\"\"\n    if (body := response.body) is None:\n        body_decoded = None\n    elif isinstance(body, payload.StringPayload):\n        body_decoded = body._value.decode(body.encoding)\n    elif isinstance(body, bytes):\n        body_decoded = body.decode(response.charset or 'utf-8')\n    else:\n        raise TypeError('Unknown payload encoding')\n    return {'status': response.status, 'body': body_decoded, 'headers':\n        dict(response.headers)}", "test_code_list": [{"test_code": "from aiohttp import web\ndef test_serialize_text() ->None:\n    \"\"\"Test serializing a text response.\"\"\"\n    response = web.Response(status=201, text='Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {'Content-Type': 'text/plain; charset=utf-8'}}\n\ntest_serialize_text()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_str() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body='Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {'Content-Type': 'text/plain; charset=utf-8'}}\n\ntest_serialize_body_str()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_None() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body=None)\n    assert serialize_response(response) == {'status': 201, 'body':\n        None, 'headers': {}}\n\ntest_serialize_body_None()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_bytes() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body=b'Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {}}\n\ntest_serialize_body_bytes()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_json() ->None:\n    \"\"\"Test serializing a JSON response.\"\"\"\n    response = web.json_response({'how': 'what'})\n    assert serialize_response(response) == {'status': 200, 'body':\n        '{\"how\": \"what\"}', 'headers': {'Content-Type':\n        'application/json; charset=utf-8'}}\n\ntest_serialize_json()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}], "instruction": "Functionality: The serialize_response function is designed to serialize an aiohttp response to a dictionary, making it easier to inspect or process the response data. It handles various types of response bodies, decoding them if necessary, and extracts the status code and headers.\n\nInputs: \n- response: An instance of aiohttp.web.Response. This is the response object received from an aiohttp request, which contains the status code, headers, and body of the response.\n\nOutputs:\n- A dictionary containing the following keys:\n  - 'status': The HTTP status code of the response (an integer).\n  - 'body': The decoded body content of the response. If the body is None, it returns None. If the body is a payload.StringPayload, the value is decoded using the payload's encoding. If the body is bytes, it's decoded using the response's charset or defaults to 'utf-8'.\n  - 'headers': A dictionary representation of the response headers, converted from CIMultiDict to a regular dict for easier handling.", "method_code_mask": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\n\n\ndef serialize_response(response: web.Response) ->dict[str, Any]: [MASK]\n"}
{"method_name": "chunked_or_all", "full_method_name": "chunked_or_all", "method_path": "../srcdata/System/core/homeassistant/util/collection.py", "method_code": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]:\n    \"\"\"Break *collection* into iterables of length *n*.\n    Returns the collection if its length is less than *n*.\n    Unlike chunked, this function requires a collection so it can\n    determine the length of the collection and return the collection\n    if it is less than *n*.\n    \"\"\"\n    if len(iterable) <= chunked_num:\n        return iterable,\n    return chunked(iterable, chunked_num)", "test_code_list": [{"test_code": "def test_chunked_or_all() ->None:\n    \"\"\"Test chunked_or_all can iterate chunk sizes larger than the passed in collection.\"\"\"\n    all_items = []\n    incoming = 1, 2, 3, 4\n    for chunk in chunked_or_all(incoming, 2):\n        assert len(chunk) == 2\n        all_items.extend(chunk)\n    assert all_items == [1, 2, 3, 4]\n    all_items = []\n    incoming = 1, 2, 3, 4\n    for chunk in chunked_or_all(incoming, 5):\n        assert len(chunk) == 4\n        assert chunk is incoming\n        all_items.extend(chunk)\n    assert all_items == [1, 2, 3, 4]\n\ntest_chunked_or_all()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_collection.py"}], "instruction": "Functionality: The function 'chunked_or_all' breaks a collection into iterables of a specified length 'chunked_num'. If the length of the collection is less than or equal to 'chunked_num', it returns the collection itself as a single iterable. Otherwise, it divides the collection into chunks of 'chunked_num' elements each.\nInputs: \n- iterable: Collection[Any] - A collection of any type of elements.\n- chunked_num: int - The desired length of each chunk.\nOutputs: \n- Iterable[Any] - A single iterable of the original collection if its length is less than or equal to 'chunked_num', or multiple iterables, each of length 'chunked_num' (except possibly the last one if the collection's size is not a multiple of 'chunked_num').", "method_code_mask": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\n\n\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\n\n\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\n\n\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]: [MASK]\n"}
{"method_name": "color_hsv_to_RGB", "full_method_name": "color_hsv_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]:\n    \"\"\"Convert an hsv color into its rgb representation.\n\n    Hue is scaled 0-360\n    Sat is scaled 0-100\n    Val is scaled 0-100\n    \"\"\"\n    fRGB = colorsys.hsv_to_rgb(iH / 360, iS / 100, iV / 100)\n    return int(fRGB[0] * 255), int(fRGB[1] * 255), int(fRGB[2] * 255)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_hsv_to_RGB() ->None:\n    \"\"\"Test color_hsv_to_RGB.\"\"\"\n    assert color_hsv_to_RGB(0, 0, 0) == (0, 0, 0)\n    assert color_hsv_to_RGB(0, 0, 100) == (255, 255, 255)\n    assert color_hsv_to_RGB(240, 100, 100) == (0, 0, 255)\n    assert color_hsv_to_RGB(120, 100, 100) == (0, 255, 0)\n    assert color_hsv_to_RGB(0, 100, 100) == (255, 0, 0)\n\ntest_color_hsv_to_RGB()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The color_hsv_to_RGB function converts a color from HSV (Hue, Saturation, Value) format to RGB (Red, Green, Blue) format. The conversion scales the HSV components to match the RGB color space, where the RGB values are integers ranging from 0 to 255.\n\nInputs: \n- iH: A float representing the Hue component of the color, scaled from 0 to 360.\n- iS: A float representing the Saturation component of the color, scaled from 0 to 100.\n- iV: A float representing the Value (brightness) component of the color, scaled from 0 to 100.\n\nOutputs:\n- A tuple of three integers (R, G, B), where R, G, and B represent the Red, Green, and Blue components of the color, respectively, each ranging from 0 to 255.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]: [\n    MASK]\n"}
{"method_name": "color_hsb_to_RGB", "full_method_name": "color_hsb_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]:\n    \"\"\"Convert a hsb into its rgb representation.\"\"\"\n    if fS == 0.0:\n        fV = int(fB * 255)\n        return fV, fV, fV\n    r = g = b = 0\n    h = fH / 60\n    f = h - float(math.floor(h))\n    p = fB * (1 - fS)\n    q = fB * (1 - fS * f)\n    t = fB * (1 - fS * (1 - f))\n    if int(h) == 0:\n        r = int(fB * 255)\n        g = int(t * 255)\n        b = int(p * 255)\n    elif int(h) == 1:\n        r = int(q * 255)\n        g = int(fB * 255)\n        b = int(p * 255)\n    elif int(h) == 2:\n        r = int(p * 255)\n        g = int(fB * 255)\n        b = int(t * 255)\n    elif int(h) == 3:\n        r = int(p * 255)\n        g = int(q * 255)\n        b = int(fB * 255)\n    elif int(h) == 4:\n        r = int(t * 255)\n        g = int(p * 255)\n        b = int(fB * 255)\n    elif int(h) == 5:\n        r = int(fB * 255)\n        g = int(p * 255)\n        b = int(q * 255)\n    return r, g, b", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_hsb_to_RGB() ->None:\n    \"\"\"Test color_hsb_to_RGB.\"\"\"\n    assert color_hsb_to_RGB(0, 0, 0) == (0, 0, 0)\n    assert color_hsb_to_RGB(0, 0, 1.0) == (255, 255, 255)\n    assert color_hsb_to_RGB(240, 1.0, 1.0) == (0, 0, 255)\n    assert color_hsb_to_RGB(120, 1.0, 1.0) == (0, 255, 0)\n    assert color_hsb_to_RGB(0, 1.0, 1.0) == (255, 0, 0)\n\ntest_color_hsb_to_RGB()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The function color_hsb_to_RGB is designed to convert a color represented in the HSB (Hue, Saturation, Brightness) color space into its RGB (Red, Green, Blue) equivalent. The conversion takes into account the hue angle (0-360 degrees), saturation (0.0-1.0), and brightness (0.0-1.0) values and returns the corresponding RGB values in the range of 0-255 for each color channel.\n\nInputs: The function accepts three floating-point parameters:\n- fH: A float representing the hue of the color. The hue is an angle in the color wheel and ranges from 0 to 360.\n- fS: A float representing the saturation of the color. Saturation describes the intensity of the color and ranges from 0.0 (no color, grayscale) to 1.0 (full color).\n- fB: A float representing the brightness (or value) of the color. Brightness determines the lightness of the color and ranges from 0.0 (black) to 1.0 (full brightness).\n\nOutputs: The function returns a tuple of three integers:\n- r: An integer representing the red component of the color in the range of 0 to 255.\n- g: An integer representing the green component of the color in the range of 0 to 255.\n- b: An integer representing the blue component of the color in the range of 0 to 255.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]: [\n    MASK]\n"}
{"method_name": "rgb_hex_to_rgb_list", "full_method_name": "rgb_hex_to_rgb_list", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]:\n    \"\"\"Return an RGB color value list from a hex color string.\"\"\"\n    return [int(hex_string[i:i + len(hex_string) // 3], 16) for i in range(\n        0, len(hex_string), len(hex_string) // 3)]", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_rgb_hex_to_rgb_list() ->None:\n    \"\"\"Test rgb_hex_to_rgb_list.\"\"\"\n    assert rgb_hex_to_rgb_list('ffffff') == [255, 255, 255]\n    assert rgb_hex_to_rgb_list('000000') == [0, 0, 0]\n    assert rgb_hex_to_rgb_list('ffffffff') == [255, 255, 255, 255]\n    assert rgb_hex_to_rgb_list('00000000') == [0, 0, 0, 0]\n    assert rgb_hex_to_rgb_list('3399ff') == [51, 153, 255]\n    assert rgb_hex_to_rgb_list('3399ff00') == [51, 153, 255, 0]\n\ntest_rgb_hex_to_rgb_list()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: This function converts a hexadecimal color string to a list of integers representing the RGB (Red, Green, Blue) color values. The hexadecimal color string is expected to be in the format commonly used to define colors in web and graphic design, without any prefix like '#'.\n\nInputs: \n- hex_string: A string representing the hexadecimal color code. The string should consist of 6 characters (0-9, A-F), where the first two characters represent the Red component, the next two represent the Green component, and the last two represent the Blue component.\n\nOutputs:\n- A list of three integers, each representing the Red, Green, and Blue components of the color, respectively. Each integer value will be in the range of 0 to 255.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]: [MASK]\n"}
{"method_name": "color_rgb_to_rgbw", "full_method_name": "color_rgb_to_rgbw", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbw representation.\"\"\"\n    w = min(r, g, b)\n    rgbw = r - w, g - w, b - w, w\n    return match_max_scale((r, g, b), rgbw)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgb_to_rgbw() ->None:\n    \"\"\"Test color_rgb_to_rgbw.\"\"\"\n    assert color_rgb_to_rgbw(0, 0, 0) == (0, 0, 0, 0)\n    assert color_rgb_to_rgbw(255, 255, 255) == (0, 0, 0, 255)\n    assert color_rgb_to_rgbw(255, 0, 0) == (255, 0, 0, 0)\n    assert color_rgb_to_rgbw(0, 255, 0) == (0, 255, 0, 0)\n    assert color_rgb_to_rgbw(0, 0, 255) == (0, 0, 255, 0)\n    assert color_rgb_to_rgbw(255, 127, 0) == (255, 127, 0, 0)\n    assert color_rgb_to_rgbw(255, 127, 127) == (255, 0, 0, 253)\n    assert color_rgb_to_rgbw(127, 127, 127) == (0, 0, 0, 127)\n\ntest_color_rgb_to_rgbw()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: Convert an RGB color representation to an RGBW (Red, Green, Blue, White) color representation.\nInputs: Three integers (r, g, b) representing the red, green, and blue components of a color. Each value should be in the range of 0 to 255.\nOutputs: A tuple of four integers (r, g, b, w) representing the red, green, blue, and white components of the converted color. Each value will be in the range of 0 to 255, with the white component representing the common intensity to be subtracted from the RGB values to achieve the equivalent RGBW color.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]: [M\n    ASK]\n"}
{"method_name": "color_rgbw_to_rgb", "full_method_name": "color_rgbw_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbw color to an rgb representation.\"\"\"\n    rgb = r + w, g + w, b + w\n    return match_max_scale((r, g, b, w), rgb)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgbw_to_rgb() ->None:\n    \"\"\"Test color_rgbw_to_rgb.\"\"\"\n    assert color_rgbw_to_rgb(0, 0, 0, 0) == (0, 0, 0)\n    assert color_rgbw_to_rgb(0, 0, 0, 255) == (255, 255, 255)\n    assert color_rgbw_to_rgb(255, 0, 0, 0) == (255, 0, 0)\n    assert color_rgbw_to_rgb(0, 255, 0, 0) == (0, 255, 0)\n    assert color_rgbw_to_rgb(0, 0, 255, 0) == (0, 0, 255)\n    assert color_rgbw_to_rgb(255, 127, 0, 0) == (255, 127, 0)\n    assert color_rgbw_to_rgb(255, 0, 0, 253) == (255, 127, 127)\n    assert color_rgbw_to_rgb(0, 0, 0, 127) == (127, 127, 127)\n\ntest_color_rgbw_to_rgb()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: This function is designed to convert an RGBW (Red, Green, Blue, White) color representation to a standard RGB (Red, Green, Blue) color representation. The conversion process involves adding the white component to each of the red, green, and blue components, and then scaling the resulting RGB values to match the maximum value of the original input colors.\n\nInputs: The function takes four integer arguments, r, g, b, and w, representing the red, green, blue, and white components of the color, respectively. Each component is expected to be in the range of 0 to 255.\n\nOutputs: The function returns a tuple of three integers, representing the red, green, and blue components of the converted color. These values are also in the range of 0 to 255.\n\nExample usage is not provided to avoid revealing test cases, but you can call the function like this: `color_rgbw_to_rgb(r, g, b, w)`, where r, g, b, and w are the respective color components you want to convert.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]: [\n    MASK]\n"}
{"method_name": "color_xy_to_temperature", "full_method_name": "color_xy_to_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_xy_to_temperature(x: float, y: float) ->int:\n    \"\"\"Convert an xy color to a color temperature in Kelvin.\n\n    Uses McCamy's approximation (https://doi.org/10.1002/col.5080170211),\n    close enough for uses between 2000 K and 10000 K.\n    \"\"\"\n    n = (x - 0.332) / (0.1858 - y)\n    CCT = 437 * n ** 3 + 3601 * n ** 2 + 6861 * n + 5517\n    return int(CCT)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_xy_to_temperature() ->None:\n    \"\"\"Test color_xy_to_temperature.\"\"\"\n    assert color_xy_to_temperature(0.5119, 0.4147) == 2136\n    assert color_xy_to_temperature(0.368, 0.3686) == 4302\n    assert color_xy_to_temperature(0.4448, 0.4066) == 2893\n    assert color_xy_to_temperature(0.1, 0.8) == 8645\n    assert color_xy_to_temperature(0.5, 0.4) == 2140\n\ntest_color_xy_to_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The function color_xy_to_temperature is designed to convert a color from CIE 1931 xy chromaticity coordinates to a correlated color temperature (CCT) in Kelvin. This conversion uses McCamy's approximation, suitable for CCT values ranging from 2000 K to 10000 K.\n\nInputs: \n- x: A float representing the x-coordinate of the CIE 1931 xy chromaticity coordinates of the color.\n- y: A float representing the y-coordinate of the CIE 1931 xy chromaticity coordinates of the color.\n\nOutputs:\n- Returns an integer which represents the correlated color temperature (CCT) of the input color in Kelvin.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_xy_to_temperature(x: float, y: float) ->int: [MASK]\n"}
{"method_name": "color_temperature_to_rgb", "full_method_name": "color_temperature_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_returns_same_value_for_any_two_temperatures_below_1000() ->None:\n    \"\"\"Function should return same value for 999 Kelvin and 0 Kelvin.\"\"\"\n    rgb_1 = color_temperature_to_rgb(999)\n    rgb_2 = color_temperature_to_rgb(0)\n    assert rgb_1 == rgb_2\n\ntest_returns_same_value_for_any_two_temperatures_below_1000()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_returns_same_value_for_any_two_temperatures_above_40000() ->None:\n    \"\"\"Function should return same value for 40001K and 999999K.\"\"\"\n    rgb_1 = color_temperature_to_rgb(40001)\n    rgb_2 = color_temperature_to_rgb(999999)\n    assert rgb_1 == rgb_2\n\ntest_returns_same_value_for_any_two_temperatures_above_40000()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_should_return_pure_white_at_6600() ->None:\n    \"\"\"Function should return red=255, blue=255, green=255 when given 6600K.\n\n    6600K is considered \"pure white\" light.\n    This is just a rough estimate because the formula itself is a \"best\n    guess\" approach.\n    \"\"\"\n    rgb = color_temperature_to_rgb(6600)\n    assert rgb == (255, 255, 255)\n\ntest_should_return_pure_white_at_6600()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_color_above_6600_should_have_more_blue_than_red_or_green() ->None:\n    \"\"\"Function should return a higher blue value for blue-ish light.\"\"\"\n    rgb = color_temperature_to_rgb(6700)\n    assert rgb[2] > rgb[1]\n    assert rgb[2] > rgb[0]\n\ntest_color_above_6600_should_have_more_blue_than_red_or_green()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_color_below_6600_should_have_more_red_than_blue_or_green() ->None:\n    \"\"\"Function should return a higher red value for red-ish light.\"\"\"\n    rgb = color_temperature_to_rgb(6500)\n    assert rgb[0] > rgb[1]\n    assert rgb[0] > rgb[2]\n\ntest_color_below_6600_should_have_more_red_than_blue_or_green()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The function 'color_temperature_to_rgb' takes a color temperature in Kelvin and converts it into an RGB color representation. This conversion is based on an approximation formula provided by T. Helland.\n\nInputs: \n- color_temperature_kelvin (float): The color temperature in Kelvin. This value should be within the range of 1000 to 40000 Kelvin.\n\nOutputs:\n- tuple[float, float, float]: A tuple representing the RGB color components (Red, Green, Blue) corresponding to the input color temperature. Each component of the tuple is a float value in the range of 0 to 255.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]: [MASK]\n"}
{"method_name": "color_rgb_to_rgbww", "full_method_name": "color_rgb_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbww representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    mired_midpoint = min_mireds + mired_range / 2\n    color_temp_kelvin = color_temperature_mired_to_kelvin(mired_midpoint)\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = min(r / w_r if w_r else 0, g / w_g if w_g else 0, b / w_b if\n        w_b else 0)\n    rgb = r - w_r * white_level, g - w_g * white_level, b - w_b * white_level\n    rgbww = *rgb, round(white_level * 255), round(white_level * 255)\n    return match_max_scale((r, g, b), rgbww)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgb_to_rgbww() ->None:\n    \"\"\"Test color_rgb_to_rgbww conversions.\"\"\"\n    assert color_rgb_to_rgbww(255, 255, 255, 2702, 6493) == (0, \n        54, 98, 255, 255)\n    assert color_rgb_to_rgbww(255, 255, 255, 1000, 10000) == (\n        255, 255, 255, 0, 0)\n    assert color_rgb_to_rgbww(255, 255, 255, 1000, 1000000) == (\n        0, 118, 241, 255, 255)\n    assert color_rgb_to_rgbww(128, 128, 128, 2702, 6493) == (0, \n        27, 49, 128, 128)\n    assert color_rgb_to_rgbww(64, 64, 64, 2702, 6493) == (0, 14,\n        25, 64, 64)\n    assert color_rgb_to_rgbww(32, 64, 16, 2702, 6493) == (9, 64,\n        0, 38, 38)\n    assert color_rgb_to_rgbww(0, 0, 0, 2702, 6493) == (0, 0, 0, 0, 0\n        )\n    assert color_rgb_to_rgbww(0, 0, 0, 10000, 1000000) == (0, 0,\n        0, 0, 0)\n    assert color_rgb_to_rgbww(255, 255, 255, 200000, 1000000) == (\n        103, 69, 0, 255, 255)\n\ntest_color_rgb_to_rgbww()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The function color_rgb_to_rgbww converts a given RGB color to an RGBWW (Red, Green, Blue, Warm White, Cold White) representation, which is commonly used for controlling color and white balance in smart lighting systems. RGBWW allows for a wider range of color temperatures and more precise control over white light.\n\nInputs: The inputs to this function are:\n- r: An integer representing the red component of the RGB color (0-255).\n- g: An integer representing the green component of the RGB color (0-255).\n- b: An integer representing the blue component of the RGB color (0-255).\n- min_kelvin: An integer representing the minimum color temperature in Kelvin (default is 2700K, warm white).\n- max_kelvin: An integer representing the maximum color temperature in Kelvin (default is 6500K, cold white).\n\nOutputs: The function returns a tuple consisting of five integers, representing the Red, Green, Blue, Warm White, and Cold White components of the RGBWW color. Each component is in the range of 0 to 255, where 0 represents the lowest intensity and 255 represents the highest intensity.\n\nNote: The function calculates the appropriate color temperature in the range specified by min_kelvin and max_kelvin, and converts the RGB color to an equivalent RGBWW representation that maintains the color and intensity as closely as possible. The output is also scaled to match the maximum value of the input RGB color.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]: [MASK]\n"}
{"method_name": "color_rgbww_to_rgb", "full_method_name": "color_rgbww_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbww color to an rgb representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    try:\n        ct_ratio = ww / (cw + ww)\n    except ZeroDivisionError:\n        ct_ratio = 0.5\n    color_temp_mired = min_mireds + ct_ratio * mired_range\n    if color_temp_mired:\n        color_temp_kelvin = color_temperature_mired_to_kelvin(color_temp_mired)\n    else:\n        color_temp_kelvin = 0\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = max(cw, ww) / 255\n    rgb = r + w_r * white_level, g + w_g * white_level, b + w_b * white_level\n    return match_max_scale((r, g, b, cw, ww), rgb)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgbww_to_rgb() ->None:\n    \"\"\"Test color_rgbww_to_rgb conversions.\"\"\"\n    assert color_rgbww_to_rgb(0, 54, 98, 255, 255, 2702, 6493) == (\n        255, 255, 255)\n    assert color_rgbww_to_rgb(255, 255, 255, 0, 0, 2702, 6493) == (\n        255, 255, 255)\n    assert color_rgbww_to_rgb(0, 118, 241, 255, 255, 2702, 6493\n        ) == (163, 204, 255)\n    assert color_rgbww_to_rgb(0, 27, 49, 128, 128, 2702, 6493) == (\n        128, 128, 128)\n    assert color_rgbww_to_rgb(0, 14, 25, 64, 64, 2702, 6493) == (\n        64, 64, 64)\n    assert color_rgbww_to_rgb(9, 64, 0, 38, 38, 2702, 6493) == (\n        32, 64, 16)\n    assert color_rgbww_to_rgb(0, 0, 0, 0, 0, 2702, 6493) == (0, 0, 0\n        )\n    assert color_rgbww_to_rgb(103, 69, 0, 255, 255, 2702, 6535) == (\n        255, 193, 112)\n\ntest_color_rgbww_to_rgb()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: Convert an RGBWW color representation to an RGB representation by calculating the appropriate RGB values based on the input RGBWW components and the color temperature range provided.\n\nInputs:\n- r: An integer representing the red component of the RGBWW color (0-255).\n- g: An integer representing the green component of the RGBWW color (0-255).\n- b: An integer representing the blue component of the RGBWW color (0-255).\n- cw: An integer representing the cold white component of the RGBWW color (0-255).\n- ww: An integer representing the warm white component of the RGBWW color (0-255).\n- min_kelvin: An integer representing the minimum color temperature in Kelvin for the conversion (must be in the range 1000-40000).\n- max_kelvin: An integer representing the maximum color temperature in Kelvin for the conversion (must be in the range 1000-40000).\n\nOutputs:\n- A tuple of three integers representing the converted red, green, and blue components of the RGB color, respectively (each in the range 0-255).", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]: [MASK]\n"}
{"method_name": "color_temperature_to_rgbww", "full_method_name": "color_temperature_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert color temperature in kelvin to rgbcw.\n    Returns a (r, g, b, cw, ww) tuple.\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    temperature = color_temperature_kelvin_to_mired(temperature)\n    mired_range = max_mireds - min_mireds\n    cold = (max_mireds - temperature) / mired_range * brightness\n    warm = brightness - cold\n    return 0, 0, 0, round(cold), round(warm)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_temperature_to_rgbww() ->None:\n    \"\"\"Test color temp to warm, cold conversion.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert color_temperature_to_rgbww(6535, 255, 2000, 6535) == (\n        0, 0, 0, 255, 0)\n    assert color_temperature_to_rgbww(6535, 128, 2000, 6535) == (\n        0, 0, 0, 128, 0)\n    assert color_temperature_to_rgbww(2000, 255, 2000, 6535) == (\n        0, 0, 0, 0, 255)\n    assert color_temperature_to_rgbww(2000, 128, 2000, 6535) == (\n        0, 0, 0, 0, 128)\n    assert color_temperature_to_rgbww(2881, 255, 2000, 6535) == (\n        0, 0, 0, 112, 143)\n    assert color_temperature_to_rgbww(2881, 128, 2000, 6535) == (\n        0, 0, 0, 56, 72)\n\ntest_color_temperature_to_rgbww()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: Convert color temperature in Kelvin to RGBWW (Red, Green, Blue, Cold White, Warm White) color representation. This function is designed to calculate the appropriate RGBWW values based on the given color temperature and brightness levels, ensuring that the output can be used to adjust the color and intensity of lights that support RGBWW control.\n\nInputs: \n- temperature: An integer representing the color temperature in degrees Kelvin. This value will be converted to a mired shift to determine the ratio of cold to warm white light.\n- brightness: An integer representing the brightness level of the light. This value is used to scale the intensity of the cold and warm white components.\n- min_kelvin: An integer representing the minimum color temperature in degrees Kelvin. This is used to calculate the mired shift range.\n- max_kelvin: An integer representing the maximum color temperature in degrees Kelvin. This is also used to calculate the mired shift range.\n\nOutputs:\n- A tuple of five integers (r, g, b, cw, ww) where:\n  - r: The red component of the color, always 0 for this conversion.\n  - g: The green component of the color, always 0 for this conversion.\n  - b: The blue component of the color, always 0 for this conversion.\n  - cw: The cold white component of the color, adjusted based on the temperature and brightness.\n  - ww: The warm white component of the color, also adjusted based on the temperature and brightness.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]: [MASK]\n"}
{"method_name": "rgbww_to_color_temperature", "full_method_name": "rgbww_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert rgbcw to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    _, _, _, cold, warm = rgbww\n    return _white_levels_to_color_temperature(cold, warm, min_kelvin,\n        max_kelvin)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_rgbww_to_color_temperature() ->None:\n    \"\"\"Test rgbww conversion to color temp.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert rgbww_to_color_temperature((0, 0, 0, 255, 0), 2000, 6535\n        ) == (6535, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 128, 0), 2000, 6535\n        ) == (6535, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 255), 2000, 6535\n        ) == (2000, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 128), 2000, 6535\n        ) == (2000, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 112, 143), 2000,\n        6535) == (2876, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 56, 72), 2000, 6535\n        ) == (2872, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 0), 2000, 6535\n        ) == (2000, 0)\n\ntest_rgbww_to_color_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: Convert an RGBWW color representation to color temperature in degrees Kelvin and brightness level.\nInputs: \n- rgbww: A tuple of 5 integers (r, g, b, w1, w2) representing the red, green, blue, cold white, and warm white components of the color.\n- min_kelvin: An integer representing the minimum color temperature in Kelvin.\n- max_kelvin: An integer representing the maximum color temperature in Kelvin.\nOutputs:\n- Returns a tuple of 2 integers (color_temperature, brightness) where color_temperature is the calculated color temperature in Kelvin, and brightness is the calculated brightness level.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\n\n\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]: [MASK]\n"}
{"method_name": "_white_levels_to_color_temperature", "full_method_name": "_white_levels_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_white_levels_to_color_temperature() ->None:\n    \"\"\"Test warm, cold conversion to color temp.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert _white_levels_to_color_temperature(255, 0, 2000, 6535\n        ) == (6535, 255)\n    assert _white_levels_to_color_temperature(128, 0, 2000, 6535\n        ) == (6535, 128)\n    assert _white_levels_to_color_temperature(0, 255, 2000, 6535\n        ) == (2000, 255)\n    assert _white_levels_to_color_temperature(0, 128, 2000, 6535\n        ) == (2000, 128)\n    assert _white_levels_to_color_temperature(112, 143, 2000, 6535\n        ) == (2876, 255)\n    assert _white_levels_to_color_temperature(56, 72, 2000, 6535\n        ) == (2872, 128)\n    assert _white_levels_to_color_temperature(0, 0, 2000, 6535) == (\n        2000, 0)\n\ntest_white_levels_to_color_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "instruction": "Functionality: The function '_white_levels_to_color_temperature' converts the levels of cold and warm white LEDs into a color temperature in degrees Kelvin and a brightness level. This is achieved by calculating the ratio of the cold white LED level to the total (cold + warm) level, and using this ratio to interpolate between the minimum and maximum Kelvin temperatures provided.\n\nInputs:\n- cold: An integer representing the level of the cold white LED (0-255).\n- warm: An integer representing the level of the warm white LED (0-255).\n- min_kelvin: An integer indicating the minimum color temperature in degrees Kelvin.\n- max_kelvin: An integer indicating the maximum color temperature in degrees Kelvin.\n\nOutputs:\n- color_temperature: An integer representing the color temperature in degrees Kelvin.\n- brightness: An integer representing the brightness level (0-255).\nThe function returns these two values as a tuple (color_temperature, brightness). If the total brightness (cold + warm) is zero, it returns the minimum Kelvin temperature and zero brightness.", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]: [MASK]\n"}
{"method_name": "distance", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_distance_to_same_place() ->None:\n    \"\"\"Test getting the distance.\"\"\"\n    meters = distance(COORDINATES_PARIS[0], COORDINATES_PARIS\n        [1], COORDINATES_PARIS[0], COORDINATES_PARIS[1])\n    assert meters == 0\ntest_get_distance_to_same_place()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "instruction": "Functionality: The 'distance' function calculates the geographical distance between two points on the Earth's surface using the Vincenty formula (inverse method). This function is designed to be async-friendly, allowing for concurrent execution in an asynchronous environment.\n\nInputs: \n- lat1: A float representing the latitude of the first point. If the latitude is unknown, it can be None.\n- lon1: A float representing the longitude of the first point. If the longitude is unknown, it can be None.\n- lat2: A float representing the latitude of the second point.\n- lon2: A float representing the longitude of the second point.\n\nOutputs: \n- If both lat1 and lon1 are not None, the function returns the distance between the two points in meters as a float, rounded to six decimal places.\n- If either lat1 or lon1 is None, the function returns None, indicating that the distance cannot be calculated with the given data.", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n"}
{"method_name": "distance", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nDISTANCE_KM = 5846.39\nCOORDINATES_NEW_YORK = 40.73061, -73.935242\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_distance() ->None:\n    \"\"\"Test getting the distance.\"\"\"\n    meters = distance(COORDINATES_PARIS[0], COORDINATES_PARIS\n        [1], COORDINATES_NEW_YORK[0], COORDINATES_NEW_YORK[1])\n    assert meters / 1000 - DISTANCE_KM < 0.01\ntest_get_distance()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "instruction": "Functionality: The 'distance' function is designed to calculate the distance in meters between two points on the Earth's surface, using the Vincenty formula (inverse method). This method takes into account the Earth's oblate spheroid shape for more accurate distance calculations. The function is also declared as being asynchronous friendly, meaning it can be used in asynchronous code.\n\nInputs: The 'distance' function takes four input arguments:\n1. lat1: A floating-point number or None representing the latitude of the first point.\n2. lon1: A floating-point number or None representing the longitude of the first point.\n3. lat2: A floating-point number representing the latitude of the second point.\n4. lon2: A floating-point number representing the longitude of the second point.\n\nOutputs: The function returns a floating-point number representing the distance in meters between the two points, or None if either of the first two arguments (lat1, lon1) is None, or if the algorithm fails to converge within the specified number of iterations.", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n"}
{"method_name": "vincenty", "full_method_name": "vincenty", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nDISTANCE_KM = 5846.39\nCOORDINATES_NEW_YORK = 40.73061, -73.935242\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_kilometers() ->None:\n    \"\"\"Test getting the distance between given coordinates in km.\"\"\"\n    kilometers = vincenty(COORDINATES_PARIS, COORDINATES_NEW_YORK\n        )\n    assert round(kilometers, 2) == DISTANCE_KM\ntest_get_kilometers()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "instruction": "Functionality: The Vincenty formula (inverse method) is implemented in this function to calculate the geodesic distance between two points on the surface of an ellipsoidal model of Earth. This distance is calculated in kilometers or miles, taking into account the Earth's oblateness.\n\nInputs: \n- point1: A tuple representing the latitude and longitude of the first geographical point in decimal degrees.\n- point2: A tuple representing the latitude and longitude of the second geographical point in decimal degrees.\n- miles: A boolean flag that, when set to True, returns the distance in miles; otherwise, the distance is returned in kilometers.\n\nOutputs: \n- A float representing the distance between the two points in kilometers (if miles is False) or miles (if miles is True). If the two points are identical or represent the same location, the function returns 0.0. If after the maximum number of iterations (200), convergence is not achieved, the function returns None.", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None): [MASK]\n"}
{"method_name": "recursive_flatten", "full_method_name": "recursive_flatten", "method_path": "../srcdata/System/core/homeassistant/helpers/translation.py", "method_code": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]:\n    \"\"\"Return a flattened representation of dict data.\"\"\"\n    output: dict[str, str] = {}\n    for key, value in data.items():\n        if isinstance(value, dict):\n            output.update(recursive_flatten(f'{prefix}{key}.', value))\n        else:\n            output[f'{prefix}{key}'] = value\n    return output", "test_code_list": [{"test_code": "import asyncio\nimport pathlib\nfrom typing import Any\nfrom unittest.mock import Mock\nfrom unittest.mock import call\nfrom unittest.mock import patch\nimport pytest\ndef test_recursive_flatten() ->None:\n    \"\"\"Test the flatten function.\"\"\"\n    data = {'parent1': {'child1': 'data1', 'child2': 'data2'}, 'parent2':\n        'data3'}\n    flattened = recursive_flatten('prefix.', data)\n    assert flattened == {'prefix.parent1.child1': 'data1',\n        'prefix.parent1.child2': 'data2', 'prefix.parent2': 'data3'}\n\ntest_recursive_flatten()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_translation.py"}], "instruction": "Functionality: The recursive_flatten function is designed to transform a nested dictionary into a flattened dictionary. It achieves this by iterating through the input dictionary, recursively flattening any nested dictionaries, and combining all key-value pairs into a single-level dictionary with keys reflecting the hierarchical path in the original structure.\nInputs: The function takes two parameters:\n    - prefix: A string representing the prefix for the keys. This is an internal parameter and should not be modified by the interviewee.\n    - data: A dictionary where keys are strings and values are either another dictionary or a string. This dictionary may contain nested dictionaries to any depth.\nOutputs: The function returns a dictionary with flattened keys and string values. Each key represents the hierarchical path through the original nested dictionary, with each level separated by a dot. For example, if the input dictionary had a structure like {'a': {'b': 'value'}}, the output would be {'a.b': 'value'}.", "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\n\n\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]: [MASK]\n"}
{"method_name": "icon_for_signal_level", "full_method_name": "icon_for_signal_level", "method_path": "../srcdata/System/core/homeassistant/helpers/icon.py", "method_code": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str:\n    \"\"\"Return a signal icon valid identifier.\"\"\"\n    if signal_level is None or signal_level == 0:\n        return 'mdi:signal-cellular-outline'\n    if signal_level > 70:\n        return 'mdi:signal-cellular-3'\n    if signal_level > 30:\n        return 'mdi:signal-cellular-2'\n    return 'mdi:signal-cellular-1'", "test_code_list": [{"test_code": "import pathlib\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\ndef test_signal_icon() ->None:\n    \"\"\"Test icon generator for signal sensor.\"\"\"\n    assert icon_for_signal_level(None) == 'mdi:signal-cellular-outline'\n    assert icon_for_signal_level(0) == 'mdi:signal-cellular-outline'\n    assert icon_for_signal_level(5) == 'mdi:signal-cellular-1'\n    assert icon_for_signal_level(40) == 'mdi:signal-cellular-2'\n    assert icon_for_signal_level(80) == 'mdi:signal-cellular-3'\n    assert icon_for_signal_level(100) == 'mdi:signal-cellular-3'\n\ntest_signal_icon()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_icon.py"}], "instruction": "Functionality: The function \"icon_for_signal_level\" is designed to return an appropriate signal icon identifier based on the given signal level. The signal level is a numeric value that represents the strength of a cellular signal. This function maps the signal level to one of four icons, indicating the strength of the signal.\n\nInputs: \n- signal_level: (int | None) - This is the input parameter representing the strength of a cellular signal. It can be an integer value or None. If it is an integer, it should be a value between 0 and 100, where 0 represents no signal and 100 represents maximum strength. If the signal level is None or 0, it indicates that there is no signal or the signal strength is unknown.\n\nOutputs:\n- str: The function returns a string that is an icon identifier relevant to the signal level. The possible return values are:\n    - 'mdi:signal-cellular-outline' if the signal level is None or 0.\n    - 'mdi:signal-cellular-3' if the signal level is greater than 70.\n    - 'mdi:signal-cellular-2' if the signal level is greater than 30 but less than or equal to 70.\n    - 'mdi:signal-cellular-1' if the signal level is 30 or less.", "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\n\n\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str: [MASK]\n"}
{"method_name": "generate_filter", "full_method_name": "generate_filter", "method_path": "../srcdata/System/core/homeassistant/helpers/entityfilter.py", "method_code": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or\n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]:\n    \"\"\"Return a function that will filter entities based on the args.\"\"\"\n    return _generate_filter_from_sets_and_pattern_lists(set(include_domains\n        ), set(include_entities), set(exclude_domains), set(\n        exclude_entities), _convert_globs_to_pattern(include_entity_globs),\n        _convert_globs_to_pattern(exclude_entity_globs))", "test_code_list": [{"test_code": "def test_no_filters_case_1() ->None:\n    \"\"\"If include and exclude not included, pass everything.\"\"\"\n    incl_dom = {}\n    incl_ent = {}\n    excl_dom = {}\n    excl_ent = {}\n    testfilter = generate_filter(incl_dom, incl_ent, excl_dom, excl_ent)\n    for value in ('sensor.test', 'sun.sun', 'light.test'):\n        assert testfilter(value)\n\ntest_no_filters_case_1()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_entityfilter.py"}, {"test_code": "def test_no_domain_case6() ->None:\n    \"\"\"Test case 6 - include and exclude specified, with no domains.\"\"\"\n    incl_dom = {}\n    incl_ent = {'binary_sensor.working'}\n    excl_dom = {}\n    excl_ent = {'light.ignoreme', 'sensor.notworking'}\n    testfilter = generate_filter(incl_dom, incl_ent, excl_dom, excl_ent)\n    assert testfilter('sensor.test') is False\n    assert testfilter('sensor.notworking') is False\n    assert testfilter('light.test') is False\n    assert testfilter('light.ignoreme') is False\n    assert testfilter('binary_sensor.working')\n    assert testfilter('binary_sensor.another') is False\n    assert testfilter('sun.sun') is False\n\ntest_no_domain_case6()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_entityfilter.py"}], "instruction": "Functionality: \nThe generate_filter function is designed to create a filter function based on the provided inclusion and exclusion criteria for entity IDs. This filter function can then be used to determine whether a given entity ID passes the defined filters.\n\nInputs:\n- include_domains: A list of strings representing domains that should be included.\n- include_entities: A list of strings representing specific entities that should be included.\n- exclude_domains: A list of strings representing domains that should be excluded.\n- exclude_entities: A list of strings representing specific entities that should be excluded.\n- include_entity_globs: An optional list of strings representing glob patterns for entities to be included.\n- exclude_entity_globs: An optional list of strings representing glob patterns for entities to be excluded.\n\nOutputs:\n- A Callable object, which is a filter function that takes a single argument (entity_id) and returns a boolean value:\n  - True if the entity_id passes the filters (i.e., it is included and not excluded).\n  - False if the entity_id does not pass the filters (i.e., it is excluded or not included when inclusion criteria are defined).\n\nNote: The filter function may use caching to improve performance for frequently checked entity IDs.", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\n\n\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\n\n\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or \n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\n\n\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]: [MASK]\n"}
