{"method_name": "coordinate_from_string", "full_method_name": "coordinate_from_string", "method_path": "../srcdata/System/openpyxl/openpyxl/cell/cell.py", "method_code": "from __future__ import absolute_import\nfrom numbers import Number\nimport datetime\nimport re\nimport warnings\nfrom openpyxl.styles import is_date_format\nCOORD_RE = re.compile('^[$]?([A-Z]+)[$]?(\\\\d+)$')\ndef coordinate_from_string(coord_string):\n    \"\"\"Convert a coordinate string like 'B12' to a tuple ('B', 12)\"\"\"\n    match = COORD_RE.match(coord_string.upper())\n    if not match:\n        msg = 'Invalid cell coordinates (%s)' % coord_string\n        raise CellCoordinatesException(msg)\n    column, row = match.groups()\n    row = int(row)\n    if not row:\n        msg = 'There is no row 0 (%s)' % coord_string\n        raise CellCoordinatesException(msg)\n    return column, row", "test_code_list": [{"test_code": "from datetime import time\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import date\nimport pytest\nfrom openpyxl.compat import safe_string\nfrom openpyxl.workbook import Workbook\nfrom openpyxl.cell import Cell\nfrom openpyxl.comments import Comment\nimport decimal\nfrom itertools import chain\ndef test_coordinates():\n    column, row = coordinate_from_string('ZF46')\n    assert 'ZF' == column\n    assert 46 == row\n\ntest_coordinates()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/cell/tests/test_cell.py"}], "instruction": "Functionality: This function converts a given string representing a cell coordinate in a spreadsheet (e.g., 'B12') into a tuple where the first element is the column identifier (e.g., 'B') and the second element is the row number as an integer (e.g., 12).\n\nInputs: \n- coord_string: A string representing the cell coordinate in the format 'LetterNumber'. It can include optional '$' characters for absolute referencing (e.g., '$B$12').\n\nOutputs:\n- A tuple consisting of:\n  - The first element is a string representing the column identifier.\n  - The second element is an integer representing the row number.\n\nExceptions:\n- CellCoordinatesException: This exception is raised if the input string does not match the expected coordinate format or if the row number is zero.", "method_code_mask": "from __future__ import absolute_import\nfrom numbers import Number\nimport datetime\nimport re\nimport warnings\nfrom openpyxl.styles import is_date_format\nCOORD_RE = re.compile('^[$]?([A-Z]+)[$]?(\\\\d+)$')\n\n\ndef coordinate_from_string(coord_string): [MASK]\n"}
{"method_name": "absolute_coordinate", "full_method_name": "absolute_coordinate", "method_path": "../srcdata/System/openpyxl/openpyxl/cell/cell.py", "method_code": "from __future__ import absolute_import\nfrom numbers import Number\nimport datetime\nimport re\nimport warnings\nfrom openpyxl.styles import is_date_format\nABSOLUTE_RE = re.compile('^[$]?([A-Z]+)[$]?(\\\\d+)(:[$]?([A-Z]+)[$]?(\\\\d+))?$')\ndef absolute_coordinate(coord_string):\n    \"\"\"Convert a coordinate to an absolute coordinate string (B12 -> $B$12)\"\"\"\n    m = ABSOLUTE_RE.match(coord_string)\n    if m:\n        parts = m.groups()\n        if all(parts[-2:]):\n            return '$%s$%s:$%s$%s' % (parts[0], parts[1], parts[3], parts[4])\n        else:\n            return '$%s$%s' % (parts[0], parts[1])\n    else:\n        return coord_string", "test_code_list": [{"test_code": "from datetime import time\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import date\nimport pytest\nfrom openpyxl.compat import safe_string\nfrom openpyxl.workbook import Workbook\nfrom openpyxl.cell import Cell\nfrom openpyxl.comments import Comment\nimport decimal\nfrom itertools import chain\ndef test_absolute():\n    assert '$ZF$51' == absolute_coordinate('ZF51')\n\ntest_absolute()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/cell/tests/test_cell.py"}, {"test_code": "from datetime import time\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import date\nimport pytest\nfrom openpyxl.compat import safe_string\nfrom openpyxl.workbook import Workbook\nfrom openpyxl.cell import Cell\nfrom openpyxl.comments import Comment\nimport decimal\nfrom itertools import chain\ndef test_absolute_multiple():\n    assert '$ZF$51:$ZF$53' == absolute_coordinate('ZF51:ZF$53')\n\ntest_absolute_multiple()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/cell/tests/test_cell.py"}], "instruction": "Functionality: The absolute_coordinate function is designed to convert a given coordinate string into an absolute coordinate format used in spreadsheet applications. This conversion changes relative references (like B12) into absolute references ($B$12).\n\nInputs: \n- coord_string: A string representing a coordinate in a spreadsheet application. This can be in the form of a single cell reference (e.g., \"B12\") or a range of cells (e.g., \"B12:D15\").\n\nOutputs: \n- A string representing the absolute coordinate or range of coordinates. If the input is a single cell, the output will be in the format $Column$Row (e.g., \"$B$12\"). If the input is a range, the output will be in the format $StartColumn$StartRow:$EndColumn$EndRow (e.g., \"$B$12:$D$15\").", "method_code_mask": "from __future__ import absolute_import\nfrom numbers import Number\nimport datetime\nimport re\nimport warnings\nfrom openpyxl.styles import is_date_format\nABSOLUTE_RE = re.compile('^[$]?([A-Z]+)[$]?(\\\\d+)(:[$]?([A-Z]+)[$]?(\\\\d+))?$')\n\n\ndef absolute_coordinate(coord_string): [MASK]\n"}
{"method_name": "_get_author_list", "full_method_name": "_get_author_list", "method_path": "../srcdata/System/openpyxl/openpyxl/reader/comments.py", "method_code": "from __future__ import absolute_import\nimport os.path\nfrom openpyxl.comments import Comment\nfrom openpyxl.xml.constants import PACKAGE_WORKSHEET_RELS\nfrom openpyxl.xml.constants import PACKAGE_WORKSHEETS\nfrom openpyxl.xml.constants import SHEET_MAIN_NS\nfrom openpyxl.xml.constants import COMMENTS_NS\nfrom openpyxl.xml.functions import fromstring\ndef _get_author_list(root):\n    author_subtree = root.find('{%s}authors' % SHEET_MAIN_NS)\n    return [author.text for author in author_subtree]", "test_code_list": [{"test_code": "from zipfile import ZipFile\nfrom zipfile import ZIP_DEFLATED\nimport os.path\nfrom openpyxl.workbook import Workbook\nfrom openpyxl.reader.excel import load_workbook\nfrom openpyxl.xml.functions import fromstring\ndef test_get_author_list():\n    xml = \"\"\"<?xml version=\"1.0\" standalone=\"yes\"?><comments\n    xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><authors>\n    <author>Cuke</author><author>Not Cuke</author></authors><commentList>\n    </commentList></comments>\"\"\"\n    assert _get_author_list(fromstring(xml)) == ['Cuke', 'Not Cuke']\n\ntest_get_author_list()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/tests/test_comment_reader.py"}], "instruction": "Functionality: The function _get_author_list is designed to extract a list of author names from an XML document that conforms to the openpyxl library's schema. This function specifically targets the 'authors' subtree within the XML document, which contains individual 'author' elements, each with text content representing an author's name.\n\nInputs: \n- root: This is the root element of an XML document parsed by the openpyxl library. It is assumed to be in the correct format that includes an 'authors' subtree with 'author' elements.\n\nOutputs:\n- A list of strings, where each string is the text content of an 'author' element found within the 'authors' subtree of the XML document. If no 'authors' subtree or 'author' elements are present, the function should return an empty list.", "method_code_mask": "from __future__ import absolute_import\nimport os.path\nfrom openpyxl.comments import Comment\nfrom openpyxl.xml.constants import PACKAGE_WORKSHEET_RELS\nfrom openpyxl.xml.constants import PACKAGE_WORKSHEETS\nfrom openpyxl.xml.constants import SHEET_MAIN_NS\nfrom openpyxl.xml.constants import COMMENTS_NS\nfrom openpyxl.xml.functions import fromstring\n\n\ndef _get_author_list(root): [MASK]\n"}
{"method_name": "split_named_range", "full_method_name": "split_named_range", "method_path": "../srcdata/System/openpyxl/openpyxl/namedrange.py", "method_code": "from __future__ import absolute_import\nimport re\nNAMED_RANGE_RE = re.compile(\n    \"^(('(?P<quoted>([^']|'')*)')|(?P<notquoted>[^']*))!(?P<range>(\\\\$([A-Za-z]+))?(\\\\$([0-9]+))?(:(\\\\$([A-Za-z]+))?(\\\\$([0-9]+))?)?)\"\n    )\nSPLIT_NAMED_RANGE_RE = re.compile(\"((?:[^,']|'(?:[^']|'')*')+)\")\ndef split_named_range(range_string):\n    \"\"\"Separate a named range into its component parts\"\"\"\n    destinations = []\n    for range_string in SPLIT_NAMED_RANGE_RE.split(range_string)[1::2]:\n        match = NAMED_RANGE_RE.match(range_string)\n        if not match:\n            raise NamedRangeException('Invalid named range string: \"%s\"' %\n                range_string)\n        else:\n            match = match.groupdict()\n            sheet_name = match['quoted'] or match['notquoted']\n            xlrange = match['range']\n            sheet_name = sheet_name.replace(\"''\", \"'\")\n            destinations.append((sheet_name, xlrange))\n    return destinations", "test_code_list": [{"test_code": "import os.path\nimport pytest\nfrom openpyxl.reader.excel import load_workbook\nfrom openpyxl.workbook import Workbook\ndef test_split():\n    assert [('My Sheet', '$D$8')] == split_named_range(\"'My Sheet'!$D$8\")\n\ntest_split()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/tests/test_named_range.py"}, {"test_code": "import os.path\nimport pytest\nfrom openpyxl.reader.excel import load_workbook\nfrom openpyxl.workbook import Workbook\ndef test_split_no_quotes():\n    assert [('HYPOTHESES', '$B$3:$L$3')] == split_named_range(\n        'HYPOTHESES!$B$3:$L$3')\n\ntest_split_no_quotes()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/tests/test_named_range.py"}], "instruction": "Functionality: The split_named_range function is designed to parse and separate a named range string into its component parts, namely the sheet name and the range. It processes a string that represents one or more named ranges, each consisting of a sheet name followed by a range, and returns a list of tuples. Each tuple contains the sheet name and the range extracted from the input string.\n\nInputs: \n- range_string: A string representing one or more named ranges, with each named range in the format: 'sheet_name!range'. Sheet names and ranges can include single quotes and dollar signs, and named ranges are separated by commas.\n\nOutputs:\n- A list of tuples, where each tuple contains two elements: \n  1. sheet_name: A string representing the name of the sheet.\n  2. xlrange: A string representing the range within the sheet.\nThe function throws a NamedRangeException if any of the named ranges in the input string is invalid.", "method_code_mask": "from __future__ import absolute_import\nimport re\nNAMED_RANGE_RE = re.compile(\n    \"^(('(?P<quoted>([^']|'')*)')|(?P<notquoted>[^']*))!(?P<range>(\\\\$([A-Za-z]+))?(\\\\$([0-9]+))?(:(\\\\$([A-Za-z]+))?(\\\\$([0-9]+))?)?)\"\n    )\nSPLIT_NAMED_RANGE_RE = re.compile(\"((?:[^,']|'(?:[^']|'')*')+)\")\n\n\ndef split_named_range(range_string): [MASK]\n"}
{"method_name": "hash_password", "full_method_name": "hash_password", "method_path": "../srcdata/System/openpyxl/openpyxl/worksheet/password_hasher.py", "method_code": "from __future__ import absolute_import\ndef hash_password(plaintext_password=''):\n    \"\"\"Create a password hash from a given string.\n\n    This method is based on the algorithm provided by\n    Daniel Rentz of OpenOffice and the PEAR package\n    Spreadsheet_Excel_Writer by Xavier Noguer <xnoguer@rezebra.com>.\n\n    \"\"\"\n    password = 0\n    i = 1\n    for char in plaintext_password:\n        value = ord(char) << i\n        rotated_bits = value >> 15\n        value &= 32767\n        password ^= value | rotated_bits\n        i += 1\n    password ^= len(plaintext_password)\n    password ^= 52811\n    return str(hex(password)).upper()[2:]", "test_code_list": [{"test_code": "def test_hasher():\n    assert 'CBEB' == hash_password('test')\n\ntest_hasher()\n", "code_start": "", "test_path": "../srcdata/System/openpyxl/openpyxl/tests/test_password_hash.py"}], "instruction": "Functionality: The hash_password function is designed to create a password hash from a given string using a specific algorithm. This algorithm iterates through each character of the input string, manipulates its ASCII value based on its position, and then combines these values to produce a hash. The hash is then adjusted based on the length of the input string and a constant value before being returned as a hexadecimal string.\n\nInputs: \n- plaintext_password: A string representing the password to be hashed. The default value is an empty string.\n\nOutputs: \n- A string representing the hashed password in hexadecimal format. The returned string is the hexadecimal representation of the calculated hash, converted to uppercase and stripped of the '0x' prefix.", "method_code_mask": "from __future__ import absolute_import\n\n\ndef hash_password(plaintext_password=''): [MASK]\n"}
