{"method_name": "should_colorize", "full_method_name": "should_colorize", "method_path": "../srcdata/System/loguru/loguru/_colorama.py", "method_code": "import builtins\nimport os\nimport sys\nimport IPython\nfrom colorama.win32 import winapi_test\nfrom colorama import AnsiToWin32\ndef should_colorize(stream):\n    if stream is None:\n        return False\n    if getattr(builtins, '__IPYTHON__', False) and (stream is sys.stdout or\n        stream is sys.stderr):\n        try:\n            import ipykernel\n            import IPython\n            ipython = IPython.get_ipython()\n            is_jupyter_stream = isinstance(stream, ipykernel.iostream.OutStream\n                )\n            is_jupyter_shell = isinstance(ipython, ipykernel.zmqshell.\n                ZMQInteractiveShell)\n        except Exception:\n            pass\n        else:\n            if is_jupyter_stream and is_jupyter_shell:\n                return True\n    if stream is sys.__stdout__ or stream is sys.__stderr__:\n        if 'CI' in os.environ and any(ci in os.environ for ci in ['TRAVIS',\n            'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS']):\n            return True\n        if 'PYCHARM_HOSTED' in os.environ:\n            return True\n        if os.name == 'nt' and 'TERM' in os.environ:\n            return True\n    try:\n        return stream.isatty()\n    except Exception:\n        return False", "test_code_list": [{"test_code": "import builtins\nimport os\nimport sys\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_stream_is_none():\n    assert not should_colorize(None)\n\ntest_stream_is_none()\n", "code_start": "", "test_path": "../srcdata/System/loguru/tests/test_colorama.py"}], "instruction": "Functionality: The should_colorize function determines whether the given stream (usually an output or error stream like sys.stdout or sys.stderr) should have colorization applied to it. This is particularly useful for enhancing the readability of console outputs by applying color codes to text.\n\nInputs: \n1. stream: A file-like object that represents an output or error stream. This could be sys.stdout, sys.stderr, or similar.\n\nOutputs:\n1. A boolean value indicating whether the given stream should be colorized. If the function returns True, it means color codes should be applied to the text output on the stream. If it returns False, plain text output without color codes is recommended.\n\nDetails:\nThe function checks for several conditions to determine if colorization should be applied:\n- If the stream is None, the function returns False.\n- If the environment is an IPython or Jupyter notebook, and the stream is one of sys.stdout or sys.stderr, colorization is enabled.\n- If the stream is sys.__stdout__ or sys.__stderr__, and the environment is a CI/CD platform (like Travis, CircleCI, AppVeyor, GitLab CI, GitHub Actions) or PyCharm, colorization is enabled.\n- If the environment is Windows and the TERM environment variable is set, colorization is enabled.\n- If the stream is a tty (terminal) device, colorization is enabled. This check is performed by calling the isatty() method on the stream.\n- If any of the checks above fail, the function returns False.", "method_code_mask": "import builtins\nimport os\nimport sys\nimport IPython\nfrom colorama.win32 import winapi_test\nfrom colorama import AnsiToWin32\n\n\ndef should_colorize(stream): [MASK]\n"}
{"method_name": "get_frame_fallback", "full_method_name": "get_frame_fallback", "method_path": "../srcdata/System/loguru/loguru/_get_frame.py", "method_code": "import sys\nfrom sys import exc_info\ndef get_frame_fallback(n):\n    try:\n        raise Exception\n    except Exception:\n        frame = exc_info()[2].tb_frame.f_back\n        for _ in range(n):\n            frame = frame.f_back\n        return frame", "test_code_list": [{"test_code": "import sys\ndef test_get_frame_fallback():\n    frame_root = frame_a = frame_b = None\n\n    def a():\n        nonlocal frame_a\n        frame_a = get_frame_fallback(1)\n        b()\n\n    def b():\n        nonlocal frame_b\n        frame_b = get_frame_fallback(2)\n    frame_root = get_frame_fallback(0)\n    a()\n    assert frame_a == frame_b == frame_root\n\ntest_get_frame_fallback()\n", "code_start": "", "test_path": "../srcdata/System/loguru/tests/test_get_frame.py"}], "instruction": "Functionality: The function 'get_frame_fallback' is designed to navigate up the call stack by 'n' levels and return the frame object that exists at that level. This is particularly useful for debugging purposes, where understanding the call stack and the context of where a function was called from can provide insights into the flow of execution.\n\nInputs: The function takes a single integer argument 'n', which specifies the number of levels up the call stack to navigate. For instance, if 'n' is 1, the function returns the frame one level up from the current frame; if 'n' is 2, it returns the frame two levels up, and so on.\n\nOutputs: The function returns a frame object that exists 'n' levels up the call stack. This frame object can be used to access details such as the local variables, the function name, and the file name, providing an insight into the context of the code execution at that level.", "method_code_mask": "import sys\nfrom sys import exc_info\n\n\ndef get_frame_fallback(n): [MASK]\n"}
