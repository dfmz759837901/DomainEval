{"method_name": "flatten_dict", "full_method_name": "flatten_dict", "method_path": "../srcdata/System/poetry/tests/helpers.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport os\nimport re\nimport shutil\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom collections.abc import Iterator\nfrom typing import Any\nfrom typing import Mapping\nfrom tomlkit.toml_document import TOMLDocument\ndef flatten_dict(obj: Mapping[str, Any], delimiter: str='.') ->Mapping[str, Any\n    ]:\n    \"\"\"\n    Flatten a nested dict.\n\n    A flatdict replacement.\n\n    :param obj: A nested dict to be flattened\n    :delimiter str: A delimiter used in the key path\n    :return: Flattened dict\n    \"\"\"\n\n    def recurse_keys(obj: Mapping[str, Any]) ->Iterator[tuple[list[str], Any]]:\n        \"\"\"\n        A recursive generator to yield key paths and their values\n\n        :param obj: A nested dict to be flattened\n        :return:  dict\n        \"\"\"\n        if isinstance(obj, dict):\n            for key in obj:\n                for leaf in recurse_keys(obj[key]):\n                    leaf_path, leaf_value = leaf\n                    leaf_path.insert(0, key)\n                    yield leaf_path, leaf_value\n        else:\n            yield [], obj\n    return {delimiter.join(path): value for path, value in recurse_keys(obj)}", "test_code_list": [{"test_code": "def test_flatten_dict() ->None:\n    orig_dict = {'a': 1, 'b': 2, 'c': {'x': 8, 'y': 9}}\n    flattened_dict = {'a': 1, 'b': 2, 'c:x': 8, 'c:y': 9}\n    assert flattened_dict == flatten_dict(orig_dict, delimiter=':')\n\ntest_flatten_dict()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/poetry/tests/test_helpers.py"}], "instruction": "Functionality: The function 'flatten_dict' is designed to flatten a nested dictionary into a single-level dictionary. This is achieved by joining the nested keys with a specified delimiter to create unique keys for the flattened dictionary.\n\nInputs: \n1. obj: A Mapping[str, Any]. This argument is a nested dictionary that you want to flatten.\n2. delimiter: A str (default is '.'). This argument is the delimiter used to join nested keys in the resulting flattened dictionary. \n\nOutputs: \n1. A Mapping[str, Any]: This is the flattened dictionary, where keys are joined with the specified 'delimiter', and values are the same as the leaf nodes in the original nested dictionary.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport os\nimport re\nimport shutil\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom collections.abc import Iterator\nfrom typing import Any\nfrom typing import Mapping\nfrom tomlkit.toml_document import TOMLDocument\n\n\ndef flatten_dict(obj: Mapping[str, Any], delimiter: str='.') ->Mapping[str, Any\n    ]: [MASK]\n"}
