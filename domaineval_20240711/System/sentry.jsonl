{"method_name": "color", "full_method_name": "color", "method_path": "../srcdata/System/sentry/tools/docker_memory_check.py", "method_code": "from __future__ import annotations\nimport argparse\nimport json\nimport os.path\nimport sys\nfrom collections.abc import Sequence\ndef color(s: str, color: str, *, use_color: bool) ->str:\n    if use_color:\n        return f'{color}{s}\\x1b[m'\n    else:\n        return s", "test_code_list": [{"test_code": "import os\nfrom unittest import mock\nimport pytest\ndef test_color_using_color():\n    ret = color('hello hello', '\\x1b[33m', use_color=True)\n    assert ret == '\\x1b[33mhello hello\\x1b[m'\n\ntest_color_using_color()\n", "code_start": "", "test_path": "../srcdata/System/sentry/tests/tools/test_docker_memory_check.py"}, {"test_code": "import os\nfrom unittest import mock\nimport pytest\ndef test_color_not_using_color():\n    ret = color('hello hello', '\\x1b[33m', use_color=False)\n    assert ret == 'hello hello'\n\ntest_color_not_using_color()\n", "code_start": "", "test_path": "../srcdata/System/sentry/tests/tools/test_docker_memory_check.py"}], "instruction": "Functionality: The color function is designed to modify a given string by applying a specific color to it. This is done based on a boolean flag that determines whether color should be applied. If the flag is set to True, the function will return the string with the specified color code applied. If the flag is False or colors are not supported in the environment, the function will return the original string without any color modifications.\n\nInputs: \n1. s (str): The string to which the color will be applied.\n2. color (str): The color code that will be applied to the string. This is a placeholder for the actual ANSI escape sequence that represents the color.\n3. use_color (bool, keyword-only argument): A flag that determines whether color should be applied to the string. If True, the color is applied; if False, the string is returned without any color modifications.\n\nOutputs:\n1. str: The modified string with the color applied if use_color is True. Otherwise, returns the original string without any modifications.", "method_code_mask": "from __future__ import annotations\nimport argparse\nimport json\nimport os.path\nimport sys\nfrom collections.abc import Sequence\n\n\ndef color(s: str, color: str, *, use_color: bool) ->str: [MASK]\n"}
{"method_name": "_glob_to_re", "full_method_name": "_glob_to_re", "method_path": "../srcdata/System/sentry/tools/mypy_helpers/check_stronglist.py", "method_code": "import argparse\nimport glob\nimport os.path\nimport re\nfrom collections.abc import Sequence\ndef _glob_to_re(s: str) ->str:\n    if s.endswith('.*'):\n        pat = f\"{re.escape(s.removesuffix('.*'))}(?:|\\\\..*+)\"\n    else:\n        pat = re.escape(s)\n    return f'^{pat}$'", "test_code_list": [{"test_code": "import re\ndef test_glob_to_re_exact_matches():\n    pat = re.compile(_glob_to_re('a.b.c'))\n    assert pat.fullmatch('a.b.c')\n    assert not pat.fullmatch('a.b.c.d')\n    assert not pat.fullmatch('a_b_c')\n\ntest_glob_to_re_exact_matches()\n", "code_start": "", "test_path": "../srcdata/System/sentry/tests/tools/mypy_helpers/test_check_stronglist.py"}], "instruction": "Functionality: The function \"_glob_to_re\" is designed to convert a glob pattern string into a regular expression (regex) pattern that can be used to match filenames or strings. This is particularly useful for file system operations where wildcards in glob patterns need to be translated into regex for matching purposes.\n\nInputs: \n- A single string argument \"s\" is passed to the function. This string represents a glob pattern that might include wildcard characters such as \"*\" and \"?\" to match multiple files or patterns.\n\nOutputs:\n- The function returns a string which is a regular expression pattern. This pattern is derived from the input glob pattern and is capable of matching the same set of filenames or strings as the original glob pattern. The output regex string will be anchored with '^' at the beginning and '$' at the end, ensuring that the entire string must match the pattern.", "method_code_mask": "import argparse\nimport glob\nimport os.path\nimport re\nfrom collections.abc import Sequence\n\n\ndef _glob_to_re(s: str) ->str: [MASK]\n"}
