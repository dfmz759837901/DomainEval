{"method_name": "xldate_from_date_tuple", "full_method_name": "xldate_from_date_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "method_code": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "instruction": "Functionality: The xldate_from_date_tuple function converts a given date in tuple format (year, month, day) to an Excel date format, which is represented as a float. This conversion takes into consideration the datemode (0 for 1900-based, 1 for 1904-based), allowing compatibility with different Excel versions.\n\nInputs: \n- date_tuple: A tuple containing three elements (year, month, day) representing the date in Gregorian calendar format.\n- datemode: An integer (0 or 1) indicating the Excel date system to use (0 for 1900-based, 1 for 1904-based).\n\nOutputs:\n- A float representing the Excel date equivalent of the input date_tuple.\n\nNote: The function raises exceptions for invalid inputs, including XLDateBadDatemode for incorrect datemode values, XLDateBadTuple for invalid date tuples, and XLDateAmbiguous for dates before 1900-03-01 when using the 1900-based datemode.", "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"method_name": "xldate_from_time_tuple", "full_method_name": "xldate_from_time_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "method_code": "import datetime\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "instruction": "Functionality: The xldate_from_time_tuple function converts a time tuple, represented as (hour, minute, second), into an Excel \"date\" value, which is a fraction of a day. This conversion is useful for interfacing with Excel spreadsheets where time is stored as a decimal fraction of a day.\n\nInputs: \n- time_tuple: A tuple containing three integers representing hour, minute, and second respectively.\n- hour: An integer representing the hour of the day where 0 <= hour < 24.\n- minute: An integer representing the minute where 0 <= minute < 60.\n- second: An integer representing the second where 0 <= second < 60.\n\nOutputs: \n- Returns a float representing the fraction of a day that corresponds to the given time tuple if the input is valid.\n- Raises an XLDateBadTuple exception if any of the values in the time_tuple are out of their valid ranges.\n\nNote: The XLDateBadTuple exception will be raised if the input hour, minute, or second values are outside of their valid ranges (0-23 for hour, 0-59 for minute, and second).", "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"method_name": "xldate_from_datetime_tuple", "full_method_name": "xldate_from_datetime_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "method_code": "import datetime\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple ``(year, month, day, hour, minute, second)`` to an\n    Excel date value.\n    For more details, refer to other xldate_from_*_tuple functions.\n    :param datetime_tuple: ``(year, month, day, hour, minute, second)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    \"\"\"\n    return xldate_from_date_tuple(datetime_tuple[:3], datemode\n        ) + xldate_from_time_tuple(datetime_tuple[3:])", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "instruction": "Functionality: Convert a datetime tuple `(year, month, day, hour, minute, second)` to an Excel date value, which is a floating-point number representing the number of days since a base date, taking into account the datemode (0 for 1900-based, 1 for 1904-based).\nInputs: \n- `datetime_tuple`: A tuple of integers representing a date and time `(year, month, day, hour, minute, second)`.\n- `datemode`: An integer indicating the date system used by Excel (0 for 1900-based, 1 for 1904-based).\nOutputs: \n- A float representing the Excel date value, which includes both the date and the time as fraction of a day.", "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
