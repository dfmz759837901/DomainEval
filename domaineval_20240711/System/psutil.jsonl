{"method_name": "supports_ipv6", "full_method_name": "supports_ipv6", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = args, frozenset(sorted(kwargs.items()))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n@memoize\ndef supports_ipv6():\n    \"\"\"Return True if IPv6 is supported on this platform.\"\"\"\n    if not socket.has_ipv6 or AF_INET6 is None:\n        return False\n    try:\n        sock = socket.socket(AF_INET6, socket.SOCK_STREAM)\n        with contextlib.closing(sock):\n            sock.bind(('::1', 0))\n        return True\n    except socket.error:\n        return False", "test_code_list": [{"test_code": "import ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\nfrom io import StringIO\nfrom psutil.tests.runner import run_from_name\n\nclass TestCommonModule(PsutilTestCase):\n    def test_supports_ipv6(self):\n        self.addCleanup(supports_ipv6.cache_clear)\n        if supports_ipv6():\n            with mock.patch('psutil._common.socket') as s:\n                s.has_ipv6 = False\n                supports_ipv6.cache_clear()\n                assert not supports_ipv6()\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket', side_effect=socket.\n                error) as s:\n                assert not supports_ipv6()\n                assert s.called\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket', side_effect=socket.\n                gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket.bind', side_effect=\n                socket.gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n        else:\n            with self.assertRaises(socket.error):\n                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n                try:\n                    sock.bind(('::1', 0))\n                finally:\n                    sock.close()\n    \nTestCommonModule().test_supports_ipv6()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_misc.py"}, {"test_code": "import ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\nfrom io import StringIO\nfrom psutil.tests.runner import run_from_name\n\nclass TestCommonModule(PsutilTestCase):\n    def test_supports_ipv6(self):\n        self.addCleanup(supports_ipv6.cache_clear)\n        if supports_ipv6():\n            with mock.patch('psutil._common.socket') as s:\n                s.has_ipv6 = False\n                supports_ipv6.cache_clear()\n                assert not supports_ipv6()\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket', side_effect=socket.\n                error) as s:\n                assert not supports_ipv6()\n                assert s.called\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket', side_effect=socket.\n                gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n            supports_ipv6.cache_clear()\n            with mock.patch('psutil._common.socket.socket.bind', side_effect=\n                socket.gaierror) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n        else:\n            with self.assertRaises(socket.error):\n                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n                try:\n                    sock.bind(('::1', 0))\n                finally:\n                    sock.close()\n    \nTestCommonModule().test_supports_ipv6()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_misc.py"}], "instruction": "Functionality: The supports_ipv6 function determines whether the current platform supports IPv6. It checks if the system has IPv6 capabilities and attempts to create an IPv6 socket, binding it to a local address to verify support.\n\nInputs: None. This function does not require any input arguments.\n\nOutputs: A boolean value indicating whether the platform supports IPv6. Returns True if IPv6 is supported, otherwise returns False.", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = args, frozenset(sorted(kwargs.items()))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\n\n@memoize\ndef supports_ipv6(): [MASK]\n"}
{"method_name": "free_physmem", "full_method_name": "free_physmem", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef free_physmem():\n    \"\"\"Parse 'free' cmd and return physical memory's total, used\n    and free values.\n    \"\"\"\n    out = sh(['free', '-b'], env={'LANG': 'C.UTF-8'})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Mem'):\n            total, used, free, shared = (int(x) for x in line.split()[1:5])\n            nt = collections.namedtuple('free', 'total used free shared output'\n                )\n            return nt(total, used, free, shared, out)\n    raise ValueError(\"can't find 'Mem' in 'free' output:\\n%s\" % '\\n'.join(\n        lines))", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    def test_total(self):\n        cli_value = free_physmem().total\n        psutil_value = psutil.virtual_memory().total\n        self.assertEqual(cli_value, psutil_value)\n    \nTestSystemVirtualMemoryAgainstFree().test_total()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef get_free_version_info():\n    out = sh(['free', '-V']).strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, re.findall('\\\\d+', out.split()[-1])))\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    @retry_on_failure()\n    def test_used(self):\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest('free version too old')\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest('free version too recent')\n        cli_value = free_physmem().used\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(cli_value, psutil_value, delta=TOLERANCE_SYS_MEM)\nTestSystemVirtualMemoryAgainstFree().test_used()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    @retry_on_failure()\n    def test_free(self):\n        cli_value = free_physmem().free\n        psutil_value = psutil.virtual_memory().free\n        self.assertAlmostEqual(cli_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstFree().test_free()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    @retry_on_failure()\n    def test_shared(self):\n        free = free_physmem()\n        free_value = free.shared\n        if free_value == 0:\n            raise unittest.SkipTest(\"free does not support 'shared' column\")\n        psutil_value = psutil.virtual_memory().shared\n        self.assertAlmostEqual(free_value, psutil_value, delta=\n            TOLERANCE_SYS_MEM, msg='%s %s \\n%s' % (free_value, psutil_value,\n            free.output))\n    \nTestSystemVirtualMemoryAgainstFree().test_shared()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The function `free_physmem` is designed to parse the output of the 'free' command (run with '-b' option) to determine the physical memory state on a Linux system. It calculates and returns the total, used, and free physical memory values in bytes. Additionally, it provides the shared memory information and the raw output of the 'free' command.\n\nInputs: This function does not take any input arguments. It uses the 'free' command to gather system memory information.\n\nOutputs: The function returns a namedtuple object 'free' with the following fields:\n- total: Total physical memory available on the system in bytes.\n- used: Amount of physical memory currently in use in bytes.\n- free: Amount of physical memory not being used in bytes.\n- shared: Amount of memory shared among processes in bytes.\n- output: The raw output of the 'free' command as a string.\n\nAn exception (ValueError) is raised if the 'Mem' line cannot be found in the output of the 'free' command.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef free_physmem(): [MASK]\n"}
{"method_name": "get_free_version_info", "full_method_name": "get_free_version_info", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef get_free_version_info():\n    out = sh(['free', '-V']).strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, re.findall('\\\\d+', out.split()[-1])))", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef free_physmem():\n    \"\"\"Parse 'free' cmd and return physical memory's total, used\n    and free values.\n    \"\"\"\n    out = sh(['free', '-b'], env={'LANG': 'C.UTF-8'})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Mem'):\n            total, used, free, shared = (int(x) for x in line.split()[1:5])\n            nt = collections.namedtuple('free', 'total used free shared output'\n                )\n            return nt(total, used, free, shared, out)\n    raise ValueError(\"can't find 'Mem' in 'free' output:\\n%s\" % '\\n'.join(\n        lines))\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    @retry_on_failure()\n    def test_used(self):\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest('free version too old')\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest('free version too recent')\n        cli_value = free_physmem().used\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(cli_value, psutil_value, delta=TOLERANCE_SYS_MEM)\nTestSystemVirtualMemoryAgainstFree().test_used()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef vmstat(stat):\n    out = sh(['vmstat', '-s'], env={'LANG': 'C.UTF-8'})\n    for line in out.split('\\n'):\n        line = line.strip()\n        if stat in line:\n            return int(line.split(' ')[0])\n    raise ValueError(\"can't find %r in 'vmstat' output\" % stat)\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_used(self):\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest('free version too old')\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest('free version too recent')\n        vmstat_value = vmstat('used memory') * 1024\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\nTestSystemVirtualMemoryAgainstVmstat().test_used()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The get_free_version_info function is designed to extract and return the version information of the 'free' command-line tool, which is used to display the amount of free and used physical and swap memory in the system. The function executes the 'free -V' command, processes the output to extract the version number, and returns it as a tuple of integers.\n\nInputs: The function does not take any input arguments.\n\nOutputs: The function returns a tuple containing integers, which represent the version number of the 'free' command. The version number is extracted from the command's output and is returned as a tuple to facilitate comparison and version checking.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef get_free_version_info(): [MASK]\n"}
{"method_name": "vmstat", "full_method_name": "vmstat", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef vmstat(stat):\n    out = sh(['vmstat', '-s'], env={'LANG': 'C.UTF-8'})\n    for line in out.split('\\n'):\n        line = line.strip()\n        if stat in line:\n            return int(line.split(' ')[0])\n    raise ValueError(\"can't find %r in 'vmstat' output\" % stat)", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    def test_total(self):\n        vmstat_value = vmstat('total memory') * 1024\n        psutil_value = psutil.virtual_memory().total\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstVmstat().test_total()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef get_free_version_info():\n    out = sh(['free', '-V']).strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, re.findall('\\\\d+', out.split()[-1])))\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_used(self):\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest('free version too old')\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest('free version too recent')\n        vmstat_value = vmstat('used memory') * 1024\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\nTestSystemVirtualMemoryAgainstVmstat().test_used()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_free(self):\n        vmstat_value = vmstat('free memory') * 1024\n        psutil_value = psutil.virtual_memory().free\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstVmstat().test_free()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_buffers(self):\n        vmstat_value = vmstat('buffer memory') * 1024\n        psutil_value = psutil.virtual_memory().buffers\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstVmstat().test_buffers()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_active(self):\n        vmstat_value = vmstat('active memory') * 1024\n        psutil_value = psutil.virtual_memory().active\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstVmstat().test_active()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    @retry_on_failure()\n    def test_inactive(self):\n        vmstat_value = vmstat('inactive memory') * 1024\n        psutil_value = psutil.virtual_memory().inactive\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM)\n    \nTestSystemVirtualMemoryAgainstVmstat().test_inactive()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestMisc(PsutilTestCase):\n    def test_boot_time(self):\n        vmstat_value = vmstat('boot time')\n        psutil_value = psutil.boot_time()\n        self.assertEqual(int(vmstat_value), int(psutil_value))\n    \nTestMisc().test_boot_time()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The vmstat function is designed to retrieve specific system statistics from the vmstat command on Linux systems. It takes a string argument representing the statistic of interest and returns the corresponding value as an integer. If the requested statistic is not found in the vmstat output, the function raises a ValueError.\n\nInputs: \n1. stat: A string representing the statistic name (e.g., \"free memory\") to be retrieved from the vmstat command's output. This is a case-sensitive string that must match the exact name as it appears in the vmstat output.\n\nOutputs:\n1. Returns the value of the requested statistic as an integer. This value represents the system metric associated with the input argument, as reported by the vmstat command. If the requested statistic is not found, a ValueError is raised.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef vmstat(stat): [MASK]\n"}
{"method_name": "calculate_avail_vmem", "full_method_name": "calculate_avail_vmem", "method_path": "../srcdata/System/psutil/psutil/_pslinux.py", "method_code": "from __future__ import division\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\nimport enum\nfrom resource import prlimit\nimport ctypes\ndef calculate_avail_vmem(mems):\n    \"\"\"Fallback for kernels < 3.14 where /proc/meminfo does not provide\n    \"MemAvailable\", see:\n    https://blog.famzah.net/2014/09/24/.\n\n    This code reimplements the algorithm outlined here:\n    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n        commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n\n    We use this function also when \"MemAvailable\" returns 0 (possibly a\n    kernel bug, see: https://github.com/giampaolo/psutil/issues/1915).\n    In that case this routine matches \"free\" CLI tool result (\"available\"\n    column).\n\n    XXX: on recent kernels this calculation may differ by ~1.5% compared\n    to \"MemAvailable:\", as it's calculated slightly differently.\n    It is still way more realistic than doing (free + cached) though.\n    See:\n    * https://gitlab.com/procps-ng/procps/issues/42\n    * https://github.com/famzah/linux-memavailable-procfs/issues/2\n    \"\"\"\n    free = mems[b'MemFree:']\n    fallback = free + mems.get(b'Cached:', 0)\n    try:\n        lru_active_file = mems[b'Active(file):']\n        lru_inactive_file = mems[b'Inactive(file):']\n        slab_reclaimable = mems[b'SReclaimable:']\n    except KeyError as err:\n        debug(\n            '%s is missing from /proc/meminfo; using an approximation for calculating available memory'\n             % err.args[0])\n        return fallback\n    try:\n        f = open_binary('%s/zoneinfo' % get_procfs_path())\n    except IOError:\n        return fallback\n    watermark_low = 0\n    with f:\n        for line in f:\n            line = line.strip()\n            if line.startswith(b'low'):\n                watermark_low += int(line.split()[1])\n    watermark_low *= PAGESIZE\n    avail = free - watermark_low\n    pagecache = lru_active_file + lru_inactive_file\n    pagecache -= min(pagecache / 2, watermark_low)\n    avail += pagecache\n    avail += slab_reclaimable - min(slab_reclaimable / 2.0, watermark_low)\n    return int(avail)", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemVirtualMemoryMocks(PsutilTestCase):\n    @retry_on_failure()\n    def test_avail_old_percent(self):\n        mems = {}\n        with open_binary('/proc/meminfo') as f:\n            for line in f:\n                fields = line.split()\n                mems[fields[0]] = int(fields[1]) * 1024\n        a = calculate_avail_vmem(mems)\n        if b'MemAvailable:' in mems:\n            b = mems[b'MemAvailable:']\n            diff_percent = abs(a - b) / a * 100\n            self.assertLess(diff_percent, 15)\n    \nTestSystemVirtualMemoryMocks().test_avail_old_percent()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: Calculate the available virtual memory for systems running on kernels older than 3.14 or where the \"MemAvailable\" value in /proc/meminfo is zero. This function implements the algorithm used by the Linux kernel to estimate available memory based on free memory, cached memory, file-backed memory, and reclaimable slab memory, adjusting for watermark low values.\n\nInputs: \n- mems: A dictionary-like object where keys are bytes strings that represent memory statistics labels (e.g., b\"MemFree:\", b\"Cached:\") and values are the corresponding memory values in bytes. The dictionary should include at least \"MemFree:\", \"Cached:\", \"Active(file):\", \"Inactive(file):\", and \"SReclaimable:\" entries.\n\nOutputs:\n- avail: An integer value representing the calculated available memory in bytes.", "method_code_mask": "from __future__ import division\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\nimport enum\nfrom resource import prlimit\nimport ctypes\n\n\ndef calculate_avail_vmem(mems): [MASK]\n"}
{"method_name": "free_swap", "full_method_name": "free_swap", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef free_swap():\n    \"\"\"Parse 'free' cmd and return swap memory's s total, used and free\n    values.\n    \"\"\"\n    out = sh(['free', '-b'], env={'LANG': 'C.UTF-8'})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Swap'):\n            _, total, used, free = line.split()\n            nt = collections.namedtuple('free', 'total used free')\n            return nt(int(total), int(used), int(free))\n    raise ValueError(\"can't find 'Swap' in 'free' output:\\n%s\" % '\\n'.join(\n        lines))", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemSwapMemory(PsutilTestCase):\n    def test_total(self):\n        free_value = free_swap().total\n        psutil_value = psutil.swap_memory().total\n        return self.assertAlmostEqual(free_value, psutil_value, delta=\n            TOLERANCE_SYS_MEM)\n    \nTestSystemSwapMemory().test_total()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemSwapMemory(PsutilTestCase):\n    @retry_on_failure()\n    def test_used(self):\n        free_value = free_swap().used\n        psutil_value = psutil.swap_memory().used\n        return self.assertAlmostEqual(free_value, psutil_value, delta=\n            TOLERANCE_SYS_MEM)\n    \nTestSystemSwapMemory().test_used()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}, {"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\nclass TestSystemSwapMemory(PsutilTestCase):\n    @retry_on_failure()\n    def test_free(self):\n        free_value = free_swap().free\n        psutil_value = psutil.swap_memory().free\n        return self.assertAlmostEqual(free_value, psutil_value, delta=\n            TOLERANCE_SYS_MEM)\n    \nTestSystemSwapMemory().test_free()\n", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The free_swap function is designed to parse the output of the 'free' command and extract the swap memory statistics including total, used, and free swap memory in bytes.\n\nInputs: The function does not take any input arguments. It internally calls the 'free' command with the '-b' flag to get the output in bytes and processes this output to extract the required swap memory statistics.\n\nOutputs: The function returns a namedtuple with the following fields: \n         - total: the total amount of swap memory in bytes.\n         - used: the amount of swap memory currently in use in bytes.\n         - free: the amount of swap memory that is not being used in bytes.\n         The namedtuple is returned as nt(int(total), int(used), int(free)).\n         If the function cannot find the 'Swap' line in the output of the 'free' command, it raises a ValueError.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef free_swap(): [MASK]\n"}
{"method_name": "get_ipv4_netmask", "full_method_name": "get_ipv4_netmask", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFNETMASK = 35099\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFNETMASK,\n            struct.pack('256s', ifname))[20:24])", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(s.fileno(), SIOCGIFHWADDR, struct.pack('256s',\n            ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join([('%02x:' % ord(char)) for char in info[18:24]])[:-1]\ndef get_ipv6_addresses(ifname):\n    with open('/proc/net/if_inet6') as f:\n        all_fields = []\n        for line in f:\n            fields = line.split()\n            if fields[-1] == ifname:\n                all_fields.append(fields)\n        if len(all_fields) == 0:\n            raise ValueError('could not find interface %r' % ifname)\n    for i in range(len(all_fields)):\n        unformatted = all_fields[i][0]\n        groups = []\n        for j in range(0, len(unformatted), 4):\n            groups.append(unformatted[j:j + 4])\n        formatted = ':'.join(groups)\n        packed = socket.inet_pton(socket.AF_INET6, formatted)\n        all_fields[i] = socket.inet_ntop(socket.AF_INET6, packed)\n    return all_fields\nSIOCGIFBRDADDR = 35097\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFBRDADDR,\n            struct.pack('256s', ifname))[20:24])\nSIOCGIFADDR = 35093\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct\n            .pack('256s', ifname))[20:24])\nclass TestSystemNetIfAddrs(PsutilTestCase):\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(addr.broadcast, get_ipv4_broadcast(name))\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    address = addr.address.split('%')[0]\n                    self.assertIn(address, get_ipv6_addresses(name))\nTestSystemNetIfAddrs().test_ips()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: This function retrieves the IPv4 netmask associated with a given network interface name on a Linux system. It utilizes the SIOCGIFNETMASK ioctl system call to fetch the netmask information from the kernel and then formats it for human-readable output.\n\nInputs: \n- ifname (str): The name of the network interface to query, e.g., \"eth0\" or \"wlan0\". The name is case-sensitive and must match the interface name exactly as it appears in the system's network device listing.\n\nOutputs:\n- str: The function returns the netmask in its human-readable dotted decimal format (e.g., \"255.255.255.0\"). If the interface name is invalid or if the netmask cannot be determined, an exception may be raised.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFNETMASK = 35099\n\n\ndef get_ipv4_netmask(ifname): [MASK]\n"}
{"method_name": "get_mac_address", "full_method_name": "get_mac_address", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(s.fileno(), SIOCGIFHWADDR, struct.pack('256s',\n            ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join([('%02x:' % ord(char)) for char in info[18:24]])[:-1]", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef get_ipv6_addresses(ifname):\n    with open('/proc/net/if_inet6') as f:\n        all_fields = []\n        for line in f:\n            fields = line.split()\n            if fields[-1] == ifname:\n                all_fields.append(fields)\n        if len(all_fields) == 0:\n            raise ValueError('could not find interface %r' % ifname)\n    for i in range(len(all_fields)):\n        unformatted = all_fields[i][0]\n        groups = []\n        for j in range(0, len(unformatted), 4):\n            groups.append(unformatted[j:j + 4])\n        formatted = ':'.join(groups)\n        packed = socket.inet_pton(socket.AF_INET6, formatted)\n        all_fields[i] = socket.inet_ntop(socket.AF_INET6, packed)\n    return all_fields\nSIOCGIFBRDADDR = 35097\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFBRDADDR,\n            struct.pack('256s', ifname))[20:24])\nSIOCGIFNETMASK = 35099\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFNETMASK,\n            struct.pack('256s', ifname))[20:24])\nSIOCGIFADDR = 35093\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct\n            .pack('256s', ifname))[20:24])\nclass TestSystemNetIfAddrs(PsutilTestCase):\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(addr.broadcast, get_ipv4_broadcast(name))\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    address = addr.address.split('%')[0]\n                    self.assertIn(address, get_ipv6_addresses(name))\nTestSystemNetIfAddrs().test_ips()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: This function retrieves the MAC address of a network interface on a Linux system. It takes the interface name as an argument, performs a system call to fetch the hardware address associated with the interface, and formats the address as a string in hexadecimal format.\n\nInputs: A string representing the name of the network interface. The interface name should not exceed 15 characters.\n\nOutputs: A string representing the MAC address of the network interface in the format xx:xx:xx:xx:xx:xx, where xx are hexadecimal digits.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\n\n\ndef get_mac_address(ifname): [MASK]\n"}
{"method_name": "get_ipv4_broadcast", "full_method_name": "get_ipv4_broadcast", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFBRDADDR = 35097\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFBRDADDR,\n            struct.pack('256s', ifname))[20:24])", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(s.fileno(), SIOCGIFHWADDR, struct.pack('256s',\n            ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join([('%02x:' % ord(char)) for char in info[18:24]])[:-1]\ndef get_ipv6_addresses(ifname):\n    with open('/proc/net/if_inet6') as f:\n        all_fields = []\n        for line in f:\n            fields = line.split()\n            if fields[-1] == ifname:\n                all_fields.append(fields)\n        if len(all_fields) == 0:\n            raise ValueError('could not find interface %r' % ifname)\n    for i in range(len(all_fields)):\n        unformatted = all_fields[i][0]\n        groups = []\n        for j in range(0, len(unformatted), 4):\n            groups.append(unformatted[j:j + 4])\n        formatted = ':'.join(groups)\n        packed = socket.inet_pton(socket.AF_INET6, formatted)\n        all_fields[i] = socket.inet_ntop(socket.AF_INET6, packed)\n    return all_fields\nSIOCGIFNETMASK = 35099\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFNETMASK,\n            struct.pack('256s', ifname))[20:24])\nSIOCGIFADDR = 35093\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct\n            .pack('256s', ifname))[20:24])\nclass TestSystemNetIfAddrs(PsutilTestCase):\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(addr.broadcast, get_ipv4_broadcast(name))\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    address = addr.address.split('%')[0]\n                    self.assertIn(address, get_ipv6_addresses(name))\nTestSystemNetIfAddrs().test_ips()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The function get_ipv4_broadcast retrieves the IPv4 broadcast address of a given network interface on a Linux system. It utilizes the ioctl system call to fetch the broadcast address information from the socket interface.\n\nInputs: \n- ifname: a string representing the name of the network interface (e.g., 'eth0', 'wlan0').\n\nOutputs:\n- The function returns a string representing the IPv4 broadcast address of the specified network interface.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFBRDADDR = 35097\n\n\ndef get_ipv4_broadcast(ifname): [MASK]\n"}
{"method_name": "get_ipv4_address", "full_method_name": "get_ipv4_address", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFADDR = 35093\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct\n            .pack('256s', ifname))[20:24])", "test_code_list": [{"test_code": "import collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(s.fileno(), SIOCGIFHWADDR, struct.pack('256s',\n            ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join([('%02x:' % ord(char)) for char in info[18:24]])[:-1]\ndef get_ipv6_addresses(ifname):\n    with open('/proc/net/if_inet6') as f:\n        all_fields = []\n        for line in f:\n            fields = line.split()\n            if fields[-1] == ifname:\n                all_fields.append(fields)\n        if len(all_fields) == 0:\n            raise ValueError('could not find interface %r' % ifname)\n    for i in range(len(all_fields)):\n        unformatted = all_fields[i][0]\n        groups = []\n        for j in range(0, len(unformatted), 4):\n            groups.append(unformatted[j:j + 4])\n        formatted = ':'.join(groups)\n        packed = socket.inet_pton(socket.AF_INET6, formatted)\n        all_fields[i] = socket.inet_ntop(socket.AF_INET6, packed)\n    return all_fields\nSIOCGIFBRDADDR = 35097\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFBRDADDR,\n            struct.pack('256s', ifname))[20:24])\nSIOCGIFNETMASK = 35099\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFNETMASK,\n            struct.pack('256s', ifname))[20:24])\nclass TestSystemNetIfAddrs(PsutilTestCase):\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(addr.broadcast, get_ipv4_broadcast(name))\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    address = addr.address.split('%')[0]\n                    self.assertIn(address, get_ipv6_addresses(name))\nTestSystemNetIfAddrs().test_ips()", "code_start": "from __future__ import division\n", "test_path": "../srcdata/System/psutil/psutil/tests/test_linux.py"}], "instruction": "Functionality: The get_ipv4_address function retrieves the Internet Protocol version 4 (IPv4) address associated with a network interface on a Linux system. It accomplishes this by sending a socket ioctl request to the kernel to fetch the address information.\n\nInputs: \n- ifname: A string representing the name of the network interface (e.g., 'eth0', 'wlan0'). The function ensures that this name is truncated to the first 15 characters before use.\n\nOutputs: \n- The function returns a string representing the IPv4 address of the specified network interface. If the interface does not exist or does not have an IPv4 address, a socket.error or other exception may be raised.", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFADDR = 35093\n\n\ndef get_ipv4_address(ifname): [MASK]\n"}
{"method_name": "parse_environ_block", "full_method_name": "parse_environ_block", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef parse_environ_block(data):\n    \"\"\"Parse a C environ block of environment variables into a dictionary.\"\"\"\n    ret = {}\n    pos = 0\n    WINDOWS_ = WINDOWS\n    while True:\n        next_pos = data.find('\\x00', pos)\n        if next_pos <= pos:\n            break\n        equal_pos = data.find('=', pos, next_pos)\n        if equal_pos > pos:\n            key = data[pos:equal_pos]\n            value = data[equal_pos + 1:next_pos]\n            if WINDOWS_:\n                key = key.upper()\n            ret[key] = value\n        pos = next_pos + 1\n    return ret", "test_code_list": [{"test_code": "import ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\nfrom io import StringIO\nfrom psutil.tests.runner import run_from_name\n\nclass TestCommonModule(PsutilTestCase):\n    def test_parse_environ_block(self):\n    \n        def k(s):\n            return s.upper() if WINDOWS else s\n        self.assertEqual(parse_environ_block('a=1\\x00'), {k('a'): '1'})\n        self.assertEqual(parse_environ_block('a=1\\x00b=2\\x00\\x00'), {k('a'):\n            '1', k('b'): '2'})\n        self.assertEqual(parse_environ_block('a=1\\x00b=\\x00\\x00'), {k('a'): '1',\n            k('b'): ''})\n        self.assertEqual(parse_environ_block('a=1\\x00b=2\\x00\\x00c=3\\x00'), {k(\n            'a'): '1', k('b'): '2'})\n        self.assertEqual(parse_environ_block('xxx\\x00a=1\\x00'), {k('a'): '1'})\n        self.assertEqual(parse_environ_block('a=1\\x00=b=2\\x00'), {k('a'): '1'})\n        self.assertEqual(parse_environ_block('a=1\\x00b=2'), {k('a'): '1'})\n    \nTestCommonModule().test_parse_environ_block()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_misc.py"}], "instruction": "Functionality: The function parse_environ_block is designed to parse a C environ block of environment variables into a dictionary. It reads through the provided string data, looking for key-value pairs separated by an equals sign (=), and each pair is terminated by a null character (\\x00). The function returns a dictionary where the keys are the environment variable names and the values are their corresponding values. If the global variable WINDOWS is True, the keys are converted to uppercase before being added to the dictionary.\n\nInputs: \n- data (str): A string representing the C environ block. This string is composed of null-terminated strings, each of which is a key-value pair in the form \"key=value\", concatenated together.\n\nOutputs:\n- ret (dict): A Python dictionary where each key is an environment variable name (in uppercase if WINDOWS is True) and each value is the corresponding value of that environment variable. The dictionary contains all the key-value pairs found in the provided data string until a null character is encountered that is not part of a key-value pair.", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef parse_environ_block(data): [MASK]\n"}
{"method_name": "wrap_numbers", "full_method_name": "wrap_numbers", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef wrap_numbers(input_dict, name):\n    \"\"\"Given an `input_dict` and a function `name`, adjust the numbers\n    which \"wrap\" (restart from zero) across different calls by adding\n    \"old value\" to \"new value\" and return an updated dict.\n    \"\"\"\n    with _wn.lock:\n        return _wn.run(input_dict, name)", "test_code_list": [{"test_code": "import ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\nfrom io import StringIO\nfrom psutil.tests.runner import run_from_name\n\nclass TestWrapNumbers(PsutilTestCase):\n    def test_real_data(self):\n        d = {'nvme0n1': (300, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n            'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8), 'nvme0n1p2':\n            (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28), 'nvme0n1p3': (2389,\n            4539, 5154, 150, 4828, 1844, 2019, 398, 348)}\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        d = {'nvme0n1': (100, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n            'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8), 'nvme0n1p2':\n            (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28), 'nvme0n1p3': (2389,\n            4539, 5154, 150, 4828, 1844, 2019, 398, 348)}\n        out = wrap_numbers(d, 'disk_io')\n        self.assertEqual(out['nvme0n1'][0], 400)\n    \nTestWrapNumbers().test_real_data()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_misc.py"}, {"test_code": "import ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\nfrom io import StringIO\nfrom psutil.tests.runner import run_from_name\n\nclass TestWrapNumbers(PsutilTestCase):\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_cache_clear_public_apis(self):\n        if not psutil.disk_io_counters() or not psutil.net_io_counters():\n            raise unittest.SkipTest('no disks or NICs available')\n        psutil.disk_io_counters()\n        psutil.net_io_counters()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.disk_io_counters', cache)\n            self.assertIn('psutil.net_io_counters', cache)\n        psutil.disk_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.net_io_counters', cache)\n            self.assertNotIn('psutil.disk_io_counters', cache)\n        psutil.net_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        self.assertEqual(caches, ({}, {}, {}))\n    \nTestWrapNumbers().test_cache_clear_public_apis()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_misc.py"}], "instruction": "Functionality: The wrap_numbers function modifies numbers in a dictionary that \"wrap\" or restart from zero across function calls. It takes an input dictionary and a function name, and if a number in the dictionary has hit its maximum value and reset to zero, the function adds the \"old value\" stored from a previous call to the \"new value\" of that number. This ensures consistent and correct accumulation of values for numbers that wrap around their maximum.\n\nInputs: \n- input_dict: A dictionary containing keys that map to numeric values. This dictionary is the primary data structure that the function modifies.\n- name: A string representing the name of the function that is calling wrap_numbers. This is used for internal tracking and state management within the function.\n\nOutputs:\n- The function returns an updated dictionary with the values modified according to the wrapping behavior described. If a value has wrapped around its maximum, it will be adjusted by adding the \"old value\" to the \"new value\", maintaining the correct accumulation of the number.", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef wrap_numbers(input_dict, name): [MASK]\n"}
{"method_name": "sysctl", "full_method_name": "sysctl", "method_path": "../srcdata/System/psutil/psutil/tests/test_bsd.py", "method_code": "import datetime\nimport os\nimport re\nimport time\nimport unittest\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\nfrom psutil._psutil_posix import getpagesize\nfrom psutil.tests.runner import run_from_name\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    result = sh('sysctl ' + cmdline)\n    if FREEBSD:\n        result = result[result.find(': ') + 2:]\n    elif OPENBSD or NETBSD:\n        result = result[result.find('=') + 1:]\n    try:\n        return int(result)\n    except ValueError:\n        return result", "test_code_list": [{"test_code": "import datetime\nimport os\nimport re\nimport time\nimport unittest\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\nfrom psutil._psutil_posix import getpagesize\nfrom psutil.tests.runner import run_from_name\n\nclass FreeBSDSystemTestCase(PsutilTestCase):\n    @unittest.skipIf(HAS_BATTERY, 'has battery')\n    def test_sensors_battery_no_battery(self):\n        with self.assertRaises(RuntimeError):\n            sysctl('hw.acpi.battery.life')\n            sysctl('hw.acpi.battery.time')\n            sysctl('hw.acpi.acline')\n        self.assertIsNone(psutil.sensors_battery())\n    \nFreeBSDSystemTestCase().test_sensors_battery_no_battery()\n", "code_start": "", "test_path": "../srcdata/System/psutil/psutil/tests/test_bsd.py"}], "instruction": "Functionality: The sysctl function is designed to execute a sysctl command with a specified argument on a Unix-like system (such as FreeBSD, OpenBSD, or NetBSD) and parse the output to return the value of interest. The function takes into account the differences in sysctl output formatting between these systems to ensure accurate parsing of the results.\n\nInputs: \n- cmdline: A string representing the sysctl command and its argument. This argument should correspond to a sysctl variable that can be queried on the system.\n\nOutputs:\n- The function returns the extracted value as an integer if the result is numeric, or as a string if the result contains non-numeric characters. This value is the result of the sysctl command, parsed from the system's output.", "method_code_mask": "import datetime\nimport os\nimport re\nimport time\nimport unittest\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\nfrom psutil._psutil_posix import getpagesize\nfrom psutil.tests.runner import run_from_name\n\n\ndef sysctl(cmdline): [MASK]\n"}
