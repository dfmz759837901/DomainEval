{"method_name": "make_response", "full_method_name": "make_response", "method_path": "../srcdata/Network/mechanize/mechanize/_response.py", "method_code": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\nclass closeable_response:\n    \"\"\"Avoids unnecessarily clobbering urllib.addinfourl methods on .close().\n\n    Only supports responses returned by mechanize.HTTPHandler.\n\n    After .close(), the following methods are supported:\n\n    .read()\n    .readline()\n    .info()\n    .geturl()\n    .__iter__()\n    .next()\n    .close()\n\n    and the following attributes are supported:\n\n    .code\n    .msg\n    .http_version\n\n    Also supports pickling (but the stdlib currently does something to prevent\n    it: http://python.org/sf/1144636).\n\n    \"\"\"\n    closeable_response = None\n\n    def __init__(self, fp, headers, url, code=200, msg='OK', http_version=None\n        ):\n        self._set_fp(fp)\n        self._headers = headers\n        self._url = url\n        self.code = code\n        self.msg = msg\n        self.http_version = http_version\n\n    def _set_fp(self, fp):\n        self.fp = fp\n        self.read = self.fp.read\n        self.readline = self.fp.readline\n        if hasattr(self.fp, 'readlines'):\n            self.readlines = self.fp.readlines\n        if hasattr(self.fp, 'fileno'):\n            self.fileno = self.fp.fileno\n        else:\n            self.fileno = lambda : None\n        self.__iter__ = self.fp.__iter__\n        self.next = partial(next, self.fp)\n\n    def __repr__(self):\n        return '<%s at %s whose fp = %r>' % (self.__class__.__name__, hex(\n            abs(id(self))), self.fp)\n\n    def info(self):\n        return self._headers\n\n    @property\n    def headers(self):\n        return self._headers\n\n    def getcode(self):\n        return self.code\n\n    def get_header_values(self, name):\n        return self._headers.get_all(name)\n\n    def get_all_header_names(self, normalize=True):\n        ans = self._headers.keys()\n        if normalize:\n            ans = list(map(normalize_header_name, ans))\n        return ans\n\n    def __getitem__(self, name):\n        return self._headers[name]\n\n    def get(self, name, default):\n        return self._headers.get(name)\n\n    def geturl(self):\n        return self._url\n\n    def close(self):\n        wrapped = self.fp\n        wrapped.close()\n        new_wrapped = eofresponse(self._url, self._headers, self.code, self.msg\n            )\n        self._set_fp(new_wrapped)\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))\ndef make_response(data, headers, url=None, code=200, msg='OK'):\n    \"\"\"Convenient factory for objects implementing response interface.\n    data: string containing response body data\n    headers: sequence of (name, value) pairs\n    url: URL of response\n    code: integer response code (e.g. 200)\n    msg: string response code message (e.g. \"OK\")\n    \"\"\"\n    mime_headers = make_headers(headers)\n    if not isinstance(data, bytes):\n        data = data.encode('utf-8')\n    r = closeable_response(BytesIO(data), mime_headers, url, code, msg)\n    return response_seek_wrapper(r)", "test_code_list": [{"test_code": "import copy\nimport os\nimport re\nfrom io import BytesIO\nfrom unittest import TestCase\nimport mechanize\nimport mechanize._response\nimport mechanize._testcase\nfrom mechanize._gzip import HTTPGzipProcessor\nfrom mechanize._gzip import compress_readable_output\nfrom mechanize.polyglot import HTTPConnection\nfrom mechanize.polyglot import addinfourl\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nfrom mechanize.polyglot import unicode_type\nfrom mechanize import _response\nfrom mechanize._response import test_response\nfrom mechanize._rfc3986 import clean_url\nfrom mechanize import Link\nfrom mechanize import Browser\nfrom mechanize import response_seek_wrapper\nimport unittest\nclass MockMethod:\n\n    def __init__(self, meth_name, action, handle):\n        self.meth_name = meth_name\n        self.handle = handle\n        self.action = action\n\n    def __call__(self, *args):\n        return self.handle(self.meth_name, self.action, *args)\nclass MockResponse:\n    closeable_response = None\n    def __init__(self, url='http://example.com/', data=None, info=None):\n        self.url = self._url = url\n        if isinstance(data, type(u'')):\n            data = data.encode('utf-8')\n        self.fp = BytesIO(data)\n        if info is None:\n            info = {}\n        self._info = self._headers = MockHeaders(info)\n        self.close_called = False\n    def _set_fp(self, fp):\n        self.fp = fp\n    def info(self):\n        return self._info\n    def geturl(self):\n        return self.url\n    def read(self, size=-1):\n        return self.fp.read(size)\n    def seek(self, whence):\n        assert whence == 0\n        self.fp.seek(0)\n    def close(self):\n        self.close_called = True\n    def get_data(self):\n        pass\ndef make_mock_handler(response_class=MockResponse):\n    class MockHandler:\n        processor_order = 500\n        handler_order = -1\n        def __init__(self, methods):\n            self._define_methods(methods)\n        def _define_methods(self, methods):\n            for name, action in methods:\n                if name.endswith('_open'):\n                    meth = MockMethod(name, action, self.handle)\n                else:\n                    meth = MockMethod(name, action, self.process)\n                setattr(self.__class__, name, meth)\n        def handle(self, fn_name, response, *args, **kwds):\n            self.parent.calls.append((self, fn_name, args, kwds))\n            if response:\n                if isinstance(response, mechanize.HTTPError):\n                    raise response\n                r = response\n                r.seek(0)\n            else:\n                r = response_class()\n            req = args[0]\n            r.url = req.get_full_url()\n            return r\n        def process(self, fn_name, action, *args, **kwds):\n            self.parent.calls.append((self, fn_name, args, kwds))\n            if fn_name.endswith('_request'):\n                return args[0]\n            else:\n                return args[1]\n        def close(self):\n            pass\n        def add_parent(self, parent):\n            self.parent = parent\n            self.parent.calls = []\n        def __lt__(self, other):\n            if not hasattr(other, 'handler_order'):\n                return True\n            return self.handler_order < other.handler_order\n    return MockHandler\nclass TestBrowser(mechanize.Browser):\n    default_features = []\n    default_others = []\n    default_schemes = []\nclass BrowserTests(TestCase):\n    def test_set_cookie(self):\n        class CookieTestBrowser(TestBrowser):\n            default_features = list(TestBrowser.default_features) + ['_cookies']\n        url = 'ftp://example.com/'\n        br = CookieTestBrowser()\n        r = make_response(\n            '<html><head><title>Title</title></head><body></body></html>', [(\n            'content-type', 'text/html')], url, 200, 'OK')\n        br.add_handler(make_mock_handler()([('http_open', r)]))\n        handler = br._ua_handlers['_cookies']\n        cj = handler.cookiejar\n        self.assertRaises(mechanize.BrowserStateError, br.set_cookie, 'foo=bar')\n        self.assertEqual(len(cj), 0)\n        url = 'http://example.com/'\n        br = CookieTestBrowser()\n        r = make_response(\n            '<html><head><title>Title</title></head><body></body></html>', [(\n            'content-type', 'text/html')], url, 200, 'OK')\n        br.add_handler(make_mock_handler()([('http_open', r)]))\n        handler = br._ua_handlers['_cookies']\n        cj = handler.cookiejar\n        self.assertRaises(mechanize.BrowserStateError, br.set_cookie, 'foo=bar')\n        self.assertEqual(len(cj), 0)\n        br.open(url)\n        br.set_cookie('foo=bar')\n        self.assertEqual(len(cj), 1)\n        self.assertEqual(cj._cookies['example.com']['/']['foo'].value, 'bar')\nBrowserTests().test_set_cookie()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_browser.py"}, {"test_code": "import copy\nfrom io import BytesIO\nfrom unittest import TestCase\nimport mechanize\nfrom mechanize._response import seek_wrapper\nfrom mechanize import response_seek_wrapper\nfrom mechanize._response import test_response\nfrom mechanize._response import upgrade_response\nfrom mechanize._response import make_headers\nfrom mechanize._response import make_response\nfrom mechanize._response import closeable_response\nfrom mechanize.polyglot import addinfourl\nimport unittest\n\nclass DocTests(TestCase):\n    def test_upgrade_response(self):\n    \n        def is_response(r):\n            names = 'get_data read readline readlines close seek code msg'.split()\n            for name in names:\n                self.assertTrue(hasattr(r, name), 'No attr named: {}'.format(name))\n            self.assertEqual(r.get_data(), b'test data')\n        from mechanize._response import upgrade_response, make_headers, make_response, closeable_response, seek_wrapper\n        data = b'test data'\n        url = 'http://example.com/'\n        code = 200\n        msg = 'OK'\n        r1 = make_response(data, [], url, code, msg)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIs(r1.wrapped, r2.wrapped)\n        r1 = closeable_response(BytesIO(data), make_headers([]), url, code, msg)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIs(r1, r2.wrapped)\n        from mechanize.polyglot import addinfourl\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIsNot(r1, r2.wrapped)\n        self.assertIs(r1.fp, r2.wrapped.fp)\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        r1.code = 206\n        r1.msg = 'cool'\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertEqual(r2.code, r1.code)\n        self.assertEqual(r2.msg, r1.msg)\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        r1 = seek_wrapper(r1)\n        self.assertEqual(r1.read(4), b'test')\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        hdrs = make_headers([])\n        r1 = addinfourl(BytesIO(data), hdrs, url)\n    \n    \n        class MyHTTPError(mechanize.HTTPError):\n            pass\n        r1 = MyHTTPError(url, code, msg, hdrs, r1)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsInstance(r2, MyHTTPError)\n        name = MyHTTPError.__module__ + '.' + MyHTTPError.__name__\n        self.assertTrue(repr(r2).startswith(\n            '<httperror_seek_wrapper ({} instance) at'.format(name)))\n        r3 = upgrade_response(r2)\n        is_response(r3)\n        self.assertIsNot(r3, r2)\n        self.assertIs(r3.wrapped, r2.wrapped)\n        r4 = addinfourl(BytesIO(data), hdrs, url)\n        r4 = mechanize.HTTPError(url, code, msg, hdrs, r4)\n        r4 = upgrade_response(r4)\n        q = '<httperror_seek_wrapper (urllib2.HTTPError instance) at'\n        if not mechanize.polyglot.is_py2:\n            q = q.replace('urllib2', 'urllib.error')\n        self.assertTrue(repr(r4).startswith(q))\n    \nDocTests().test_upgrade_response()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_response.py"}], "instruction": "Functionality: The make_response function is a convenient factory for creating objects that implement the response interface for HTTP-like responses. It is designed to take the provided data, headers, URL, response code, and message, and encapsulate them in a response object that can be used to simulate HTTP responses. The function returns an instance of closeable_response which supports various operations like read, readline, info, geturl, iteration, and close, even after the connection has been closed.\n\nInputs: \n1. data (string): The body content of the response.\n2. headers (sequence of (name, value) pairs): The headers of the response.\n3. url (string, optional): The URL of the response. Default is None.\n4. code (integer, optional): The HTTP response status code. Default is 200.\n5. msg (string, optional): The message associated with the response code. Default is \"OK\".\n\nOutputs: \n1. response (closeable_response object): An object that implements the response interface, containing the provided data, headers, URL, code, and message. The object supports various operations for handling HTTP responses, including reading data, accessing headers, and closing the connection without losing certain functionality.", "method_code_mask": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\n\n\nclass closeable_response:\n    \"\"\"Avoids unnecessarily clobbering urllib.addinfourl methods on .close().\n\n    Only supports responses returned by mechanize.HTTPHandler.\n\n    After .close(), the following methods are supported:\n\n    .read()\n    .readline()\n    .info()\n    .geturl()\n    .__iter__()\n    .next()\n    .close()\n\n    and the following attributes are supported:\n\n    .code\n    .msg\n    .http_version\n\n    Also supports pickling (but the stdlib currently does something to prevent\n    it: http://python.org/sf/1144636).\n\n    \"\"\"\n    closeable_response = None\n\n    def __init__(self, fp, headers, url, code=200, msg='OK', http_version=None\n        ):\n        self._set_fp(fp)\n        self._headers = headers\n        self._url = url\n        self.code = code\n        self.msg = msg\n        self.http_version = http_version\n\n    def _set_fp(self, fp):\n        self.fp = fp\n        self.read = self.fp.read\n        self.readline = self.fp.readline\n        if hasattr(self.fp, 'readlines'):\n            self.readlines = self.fp.readlines\n        if hasattr(self.fp, 'fileno'):\n            self.fileno = self.fp.fileno\n        else:\n            self.fileno = lambda : None\n        self.__iter__ = self.fp.__iter__\n        self.next = partial(next, self.fp)\n\n    def __repr__(self):\n        return '<%s at %s whose fp = %r>' % (self.__class__.__name__, hex(\n            abs(id(self))), self.fp)\n\n    def info(self):\n        return self._headers\n\n    @property\n    def headers(self):\n        return self._headers\n\n    def getcode(self):\n        return self.code\n\n    def get_header_values(self, name):\n        return self._headers.get_all(name)\n\n    def get_all_header_names(self, normalize=True):\n        ans = self._headers.keys()\n        if normalize:\n            ans = list(map(normalize_header_name, ans))\n        return ans\n\n    def __getitem__(self, name):\n        return self._headers[name]\n\n    def get(self, name, default):\n        return self._headers.get(name)\n\n    def geturl(self):\n        return self._url\n\n    def close(self):\n        wrapped = self.fp\n        wrapped.close()\n        new_wrapped = eofresponse(self._url, self._headers, self.code, self.msg\n            )\n        self._set_fp(new_wrapped)\n\n\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))\n\n\ndef make_response(data, headers, url=None, code=200, msg='OK'): [MASK]\n"}
{"method_name": "attribute_names", "full_method_name": "attribute_names", "method_path": "../srcdata/Network/mechanize/test/test_cookies.py", "method_code": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\ndef attribute_names(obj):\n    return set([spec[0] for spec in inspect.getmembers(obj) if not spec[0].\n        startswith('__')])", "test_code_list": [{"test_code": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\ndef caller():\n    return sys._getframe().f_back.f_back.f_code.co_name\nclass FakeResponse:\n    def __init__(self, headers=[], url=None):\n        \"\"\"\n        headers: list of RFC822-style 'Key: value' strings\n        \"\"\"\n        f = BytesIO('\\n'.join(headers).encode('iso-8859-1'))\n        self._headers = create_response_info(f)\n        self._url = url\n    def info(self):\n        return self._headers\ndef _interact(cookiejar, url, set_cookie_hdrs, hdr_name):\n    \"\"\"Perform a single request / response cycle, returning Cookie: header.\"\"\"\n    req = Request(url)\n    cookiejar.add_cookie_header(req)\n    cookie_hdr = req.get_header('Cookie', '')\n    headers = []\n    for hdr in set_cookie_hdrs:\n        headers.append('%s: %s' % (hdr_name, hdr))\n    res = FakeResponse(headers, url)\n    cookiejar.extract_cookies(res, req)\n    return cookie_hdr\ndef interact_netscape(cookiejar, url, *set_cookie_hdrs):\n    return _interact(cookiejar, url, set_cookie_hdrs, 'Set-Cookie')\nclass CookieJarInterfaceTests(unittest.TestCase):\n    def test_add_cookie_header(self):\n        from mechanize import CookieJar\n        class MockRequest(object):\n            def __init__(self):\n                self.added_headers = []\n                self.called = set()\n            def log_called(self):\n                self.called.add(caller())\n            def get_full_url(self):\n                self.log_called()\n                return 'https://example.com:443'\n            def get_host(self):\n                self.log_called()\n                return 'example.com:443'\n            def get_type(self):\n                self.log_called()\n                return 'https'\n            def has_header(self, header_name):\n                self.log_called()\n                return False\n            def get_header(self, header_name, default=None):\n                self.log_called()\n                pass\n            def header_items(self):\n                self.log_called()\n                pass\n            def add_unredirected_header(self, key, val):\n                self.log_called()\n                self.added_headers.append((key, val))\n            def is_unverifiable(self):\n                self.log_called()\n                return False\n            @property\n            def unverifiable(self):\n                return self.is_unverifiable()\n            @property\n            def type(self):\n                return self.get_type()\n            @property\n            def host(self):\n                return self.get_host()\n        jar = CookieJar()\n        interact_netscape(jar, 'https://example.com:443',\n            'foo=bar; port=443; secure')\n        request = MockRequest()\n        jar.add_cookie_header(request)\n        expect_called = attribute_names(MockRequest) - {'port', 'get_header',\n            'header_items', 'log_called', 'unverifiable', 'type', 'host'}\n        self.assertEqual(request.called, expect_called)\n        self.assertEqual(request.added_headers, [('Cookie', 'foo=bar')])\nCookieJarInterfaceTests().test_add_cookie_header()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_cookies.py"}], "instruction": "Functionality: The attribute_names function is designed to return a set of all public attribute names of a given object. The function introspects the object to list all attributes, excluding the ones that start with '__', which are typically considered private attributes or methods in Python.\n\nInputs: The function takes a single argument:\n- obj: The object for which the public attribute names are to be retrieved.\n\nOutputs: The function returns a set containing the names of all public attributes of the provided object. An attribute is considered public if its name does not start with '__'.", "method_code_mask": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\n\n\ndef attribute_names(obj): [MASK]\n"}
{"method_name": "request_is_unverifiable", "full_method_name": "request_is_unverifiable", "method_path": "../srcdata/Network/mechanize/mechanize/_clientcookie.py", "method_code": "from __future__ import absolute_import\nimport re\nimport time\ndef request_is_unverifiable(request):\n    try:\n        return request.is_unverifiable()\n    except AttributeError:\n        if hasattr(request, 'unverifiable'):\n            return request.unverifiable\n        else:\n            raise", "test_code_list": [{"test_code": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\n\nclass CookieJarInterfaceTests(unittest.TestCase):\n    def test_unverifiable(self):\n        from mechanize._clientcookie import request_is_unverifiable\n    \n    \n        class StubRequest(object):\n    \n            def __init__(self, attrs):\n                self._attrs = attrs\n                self.accessed = set()\n    \n            def __getattr__(self, name):\n                self.accessed.add(name)\n                try:\n                    return self._attrs[name]\n                except KeyError:\n                    raise AttributeError(name)\n        request = StubRequest(dict(is_unverifiable=lambda : False))\n        self.assertEqual(request_is_unverifiable(request), False)\n        request = StubRequest(dict(is_unverifiable=lambda : False, unverifiable\n            =True))\n        self.assertEqual(request_is_unverifiable(request), False)\n        request = StubRequest(dict(unverifiable=False))\n        self.assertEqual(request_is_unverifiable(request), False)\n    \nCookieJarInterfaceTests().test_unverifiable()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_cookies.py"}], "instruction": "Functionality: The function request_is_unverifiable is designed to determine if a given request object is unverifiable. A request is considered unverifiable if it cannot be verified due to missing or incorrect information or if the request object has a property or method that indicates its unverifiability.\n\nInputs: \nThe function takes one argument:\nrequest - an object that represents a request, which might contain a method or property that indicates whether the request is unverifiable.\n\nOutputs:\nThe function returns a boolean value:\nTrue - if the request is unverifiable.\nFalse - if the request is not unverifiable.\nThe function raises an AttributeError if the request object does not have a method or property that can determine its verifiability.", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\n\n\ndef request_is_unverifiable(request): [MASK]\n"}
{"method_name": "time2netscape", "full_method_name": "time2netscape", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef time2netscape(t=None):\n    \"\"\"Return a string representing time in seconds since epoch, t.\n\n    If the function is called without an argument, it will use the current\n    time.\n\n    The format of the returned string is like this:\n\n    Wed, DD-Mon-YYYY HH:MM:SS GMT\n\n    \"\"\"\n    if t is None:\n        t = time.time()\n    year, mon, mday, hour, min, sec, wday = time.gmtime(t)[:7]\n    return '%s %02d-%s-%04d %02d:%02d:%02d GMT' % (days[wday], mday, months\n        [mon - 1], year, hour, min, sec)", "test_code_list": [{"test_code": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\nclass FakeResponse:\n\n    def __init__(self, headers=[], url=None):\n        \"\"\"\n        headers: list of RFC822-style 'Key: value' strings\n        \"\"\"\n        f = BytesIO('\\n'.join(headers).encode('iso-8859-1'))\n        self._headers = create_response_info(f)\n        self._url = url\n\n    def info(self):\n        return self._headers\ndef _interact(cookiejar, url, set_cookie_hdrs, hdr_name):\n    \"\"\"Perform a single request / response cycle, returning Cookie: header.\"\"\"\n    req = Request(url)\n    cookiejar.add_cookie_header(req)\n    cookie_hdr = req.get_header('Cookie', '')\n    headers = []\n    for hdr in set_cookie_hdrs:\n        headers.append('%s: %s' % (hdr_name, hdr))\n    res = FakeResponse(headers, url)\n    cookiejar.extract_cookies(res, req)\n    return cookie_hdr\ndef interact_netscape(cookiejar, url, *set_cookie_hdrs):\n    return _interact(cookiejar, url, set_cookie_hdrs, 'Set-Cookie')\nclass CookieTests(unittest.TestCase):\n    def test_expires(self):\n        from mechanize._util import time2netscape\n        from mechanize import CookieJar\n        c = CookieJar()\n        future = time2netscape(time.time() + 3600)\n        interact_netscape(c, 'http://www.acme.com/', 'spam=\"bar\"; expires=%s' %\n            future)\n        assert len(c) == 1\n        now = time2netscape(time.time() - 1)\n        interact_netscape(c, 'http://www.acme.com/', 'foo=\"eggs\"; expires=%s' % now\n            )\n        h = interact_netscape(c, 'http://www.acme.com/')\n        assert len(c) == 1\n        assert h.find('spam=\"bar\"') != -1 and h.find('foo') == -1\n        interact_netscape(c, 'http://www.acme.com/', 'eggs=\"bar\"; expires=%s' %\n            future)\n        interact_netscape(c, 'http://www.acme.com/', 'bar=\"bar\"; expires=%s' %\n            future)\n        assert len(c) == 3\n        interact_netscape(c, 'http://www.acme.com/',\n            'eggs=\"bar\"; expires=%s; max-age=0' % future)\n        interact_netscape(c, 'http://www.acme.com/',\n            'bar=\"bar\"; max-age=0; expires=%s' % future)\n        h = interact_netscape(c, 'http://www.acme.com/')\n        assert len(c) == 1\n        interact_netscape(c, 'http://www.rhubarb.net/', 'whum=\"fizz\"')\n        assert len(c) == 2\n        c.clear_session_cookies()\n        assert len(c) == 1\n        assert h.find('spam=\"bar\"') != -1\nCookieTests().test_expires()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_cookies.py"}], "instruction": "Functionality: The function time2netscape is designed to convert a given time (or the current time if no argument is provided) into a string formatted as per Netscape's standard timestamp. This format is: \"Day, DD-Mon-YYYY HH:MM:SS GMT\". \n\nInputs: The function accepts an optional argument 't', which represents time in seconds since epoch. If 't' is not provided, the function uses the current time.\n\nOutputs: The function returns a string formatted as \"Day, DD-Mon-YYYY HH:MM:SS GMT\", where 'Day' is the abbreviated weekday, 'DD' is the day of the month, 'Mon' is the abbreviated month name, 'YYYY' is the year, 'HH' is the hour, 'MM' is the minute, and 'SS' is the second.", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef time2netscape(t=None): [MASK]\n"}
{"method_name": "parse_ns_headers", "full_method_name": "parse_ns_headers", "method_path": "../srcdata/Network/mechanize/mechanize/_headersutil.py", "method_code": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\ndef parse_ns_headers(ns_headers):\n    \"\"\"Ad-hoc parser for Netscape protocol cookie-attributes.\n\n    The old Netscape cookie format for Set-Cookie can for instance contain\n    an unquoted \",\" in the expires field, so we have to use this ad-hoc\n    parser instead of split_header_words.\n\n    XXX This may not make the best possible effort to parse all the crap\n    that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient\n    parser is probably better, so could do worse than following that if\n    this ever gives any trouble.\n\n    Currently, this is also used for parsing RFC 2109 cookies.\n\n    \"\"\"\n    known_attrs = ('expires', 'domain', 'path', 'secure', 'version', 'port',\n        'max-age')\n    result = []\n    for ns_header in ns_headers:\n        pairs = []\n        version_set = False\n        params = re.split(';\\\\s*', ns_header)\n        for ii in range(len(params)):\n            param = params[ii]\n            param = param.rstrip()\n            if param == '':\n                continue\n            if '=' not in param:\n                k, v = param, None\n            else:\n                k, v = re.split('\\\\s*=\\\\s*', param, 1)\n                k = k.lstrip()\n            if ii != 0:\n                lc = k.lower()\n                if lc in known_attrs:\n                    k = lc\n                if k == 'version':\n                    v = strip_quotes(v)\n                    version_set = True\n                if k == 'expires':\n                    v = http2time(strip_quotes(v))\n            pairs.append((k, v))\n        if pairs:\n            if not version_set:\n                pairs.append(('version', '0'))\n            result.append(pairs)\n    return result", "test_code_list": [{"test_code": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\n\nclass CookieTests(unittest.TestCase):\n    def test_parse_ns_headers(self):\n        from mechanize._headersutil import parse_ns_headers\n        assert parse_ns_headers(['foo=bar; path=/; domain']) == [[('foo', 'bar'\n            ), ('path', '/'), ('domain', None), ('version', '0')]]\n        assert parse_ns_headers(['foo=bar; expires=Foo Bar 12 33:22:11 2000']) == [\n            [('foo', 'bar'), ('expires', None), ('version', '0')]]\n        assert parse_ns_headers(['foo']) == [[('foo', None), ('version', '0')]]\n        assert parse_ns_headers(['']) == []\n    \nCookieTests().test_parse_ns_headers()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_cookies.py"}, {"test_code": "import mechanize._headersutil\nfrom mechanize._testcase import TestCase\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize._headersutil import join_header_words\nfrom mechanize._headersutil import split_header_words\nimport traceback\nfrom io import StringIO\nimport unittest\n\nclass HeaderTests(TestCase):\n    def test_parse_ns_headers_expires(self):\n        from mechanize._headersutil import parse_ns_headers\n        self.assertEqual(parse_ns_headers([\n            'foo=bar; expires=01 Jan 2040 22:23:32 GMT']), [[('foo', 'bar'), (\n            'expires', 2209069412), ('version', '0')]])\n        self.assertEqual(parse_ns_headers([\n            'foo=bar; expires=\"01 Jan 2040 22:23:32 GMT\"']), [[('foo', 'bar'),\n            ('expires', 2209069412), ('version', '0')]])\n    \nHeaderTests().test_parse_ns_headers_expires()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_headers.py"}, {"test_code": "import mechanize._headersutil\nfrom mechanize._testcase import TestCase\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize._headersutil import join_header_words\nfrom mechanize._headersutil import split_header_words\nimport traceback\nfrom io import StringIO\nimport unittest\n\nclass HeaderTests(TestCase):\n    def test_parse_ns_headers_version(self):\n        from mechanize._headersutil import parse_ns_headers\n        expected = [[('foo', 'bar'), ('version', '1')]]\n        for hdr in ['foo=bar; version=\"1\"', 'foo=bar; Version=\"1\"']:\n            self.assertEqual(parse_ns_headers([hdr]), expected)\n    \nHeaderTests().test_parse_ns_headers_version()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_headers.py"}, {"test_code": "import mechanize._headersutil\nfrom mechanize._testcase import TestCase\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize._headersutil import join_header_words\nfrom mechanize._headersutil import split_header_words\nimport traceback\nfrom io import StringIO\nimport unittest\n\nclass HeaderTests(TestCase):\n    def test_parse_ns_headers_special_names(self):\n        from mechanize._headersutil import parse_ns_headers\n        hdr = 'expires=01 Jan 2040 22:23:32 GMT'\n        expected = [[('expires', '01 Jan 2040 22:23:32 GMT'), ('version', '0')]]\n        self.assertEqual(parse_ns_headers([hdr]), expected)\n    \nHeaderTests().test_parse_ns_headers_special_names()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_headers.py"}], "instruction": "Functionality: The parse_ns_headers function is designed to parse Netscape protocol cookie attributes from a list of header strings. It processes each header, splits them into key-value pairs, and handles specific attributes such as 'expires', 'domain', 'path', 'secure', 'version', 'port', and 'max-age'. It ensures that the 'version' attribute is set, defaulting to '0' if not provided.\n\nInputs: \n- ns_headers: A list of strings, where each string is a Netscape protocol Set-Cookie header.\n\nOutputs: \n- A list of lists, where each inner list contains tuples of (key, value) representing the parsed attributes from the corresponding header in the input list. If the 'version' attribute is not set in a header, it is added with a value of '0'.", "method_code_mask": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\n\n\ndef parse_ns_headers(ns_headers): [MASK]\n"}
{"method_name": "make_headers", "full_method_name": "make_headers", "method_path": "../srcdata/Network/mechanize/mechanize/_response.py", "method_code": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))", "test_code_list": [{"test_code": "import copy\nfrom io import BytesIO\nfrom unittest import TestCase\nimport mechanize\nfrom mechanize._response import seek_wrapper\nfrom mechanize import response_seek_wrapper\nfrom mechanize._response import test_response\nfrom mechanize._response import upgrade_response\nfrom mechanize._response import make_headers\nfrom mechanize._response import make_response\nfrom mechanize._response import closeable_response\nfrom mechanize.polyglot import addinfourl\nimport unittest\n\nclass DocTests(TestCase):\n    def test_upgrade_response(self):\n    \n        def is_response(r):\n            names = 'get_data read readline readlines close seek code msg'.split()\n            for name in names:\n                self.assertTrue(hasattr(r, name), 'No attr named: {}'.format(name))\n            self.assertEqual(r.get_data(), b'test data')\n        from mechanize._response import upgrade_response, make_headers, make_response, closeable_response, seek_wrapper\n        data = b'test data'\n        url = 'http://example.com/'\n        code = 200\n        msg = 'OK'\n        r1 = make_response(data, [], url, code, msg)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIs(r1.wrapped, r2.wrapped)\n        r1 = closeable_response(BytesIO(data), make_headers([]), url, code, msg)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIs(r1, r2.wrapped)\n        from mechanize.polyglot import addinfourl\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsNot(r1, r2)\n        self.assertIsNot(r1, r2.wrapped)\n        self.assertIs(r1.fp, r2.wrapped.fp)\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        r1.code = 206\n        r1.msg = 'cool'\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertEqual(r2.code, r1.code)\n        self.assertEqual(r2.msg, r1.msg)\n        r1 = addinfourl(BytesIO(data), make_headers([]), url)\n        r1 = seek_wrapper(r1)\n        self.assertEqual(r1.read(4), b'test')\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        hdrs = make_headers([])\n        r1 = addinfourl(BytesIO(data), hdrs, url)\n    \n    \n        class MyHTTPError(mechanize.HTTPError):\n            pass\n        r1 = MyHTTPError(url, code, msg, hdrs, r1)\n        self.assertRaises(AssertionError, is_response, r1)\n        r2 = upgrade_response(r1)\n        is_response(r2)\n        self.assertIsInstance(r2, MyHTTPError)\n        name = MyHTTPError.__module__ + '.' + MyHTTPError.__name__\n        self.assertTrue(repr(r2).startswith(\n            '<httperror_seek_wrapper ({} instance) at'.format(name)))\n        r3 = upgrade_response(r2)\n        is_response(r3)\n        self.assertIsNot(r3, r2)\n        self.assertIs(r3.wrapped, r2.wrapped)\n        r4 = addinfourl(BytesIO(data), hdrs, url)\n        r4 = mechanize.HTTPError(url, code, msg, hdrs, r4)\n        r4 = upgrade_response(r4)\n        q = '<httperror_seek_wrapper (urllib2.HTTPError instance) at'\n        if not mechanize.polyglot.is_py2:\n            q = q.replace('urllib2', 'urllib.error')\n        self.assertTrue(repr(r4).startswith(q))\n    \nDocTests().test_upgrade_response()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_response.py"}], "instruction": "Functionality: The make_headers function is designed to generate a formatted string of HTTP headers from a given sequence of (name, value) pairs. Each pair in the sequence represents a header name and its corresponding value. The function then joins these formatted header lines into a single string, ensuring it is encoded in 'iso-8859-1' if it is not already in bytes format, and returns the result encapsulated in a response information object created from this string.\n\nInputs: \n- headers: A sequence of tuples where each tuple consists of two elements: the first element is a string representing the header name, and the second element is a string representing the header value. This input is mandatory and should be provided by the user.\n\nOutputs:\n- The function returns an object created by the create_response_info function, which takes a BytesIO object as its argument. The BytesIO object contains the encoded header string generated from the input sequence of header name-value pairs.", "method_code_mask": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\n\n\ndef make_headers(headers): [MASK]\n"}
{"method_name": "time2isoz", "full_method_name": "time2isoz", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef time2isoz(t=None):\n    \"\"\"Return a string representing time in seconds since epoch, t.\n\n    If the function is called without an argument, it will use the current\n    time.\n\n    The format of the returned string is like \"YYYY-MM-DD hh:mm:ssZ\",\n    representing Universal Time (UTC, aka GMT).  An example of this format is:\n\n    1994-11-24 08:49:37Z\n\n    \"\"\"\n    if t is None:\n        t = time.time()\n    year, mon, mday, hour, min, sec = time.gmtime(t)[:6]\n    return '%04d-%02d-%02d %02d:%02d:%02dZ' % (year, mon, mday, hour, min, sec)", "test_code_list": [{"test_code": "import re\nimport time\nfrom unittest import TestCase\nfrom mechanize._util import time2isoz\nfrom mechanize._util import http2time\nimport unittest\n\nclass DateTimeTests(TestCase):\n    def test_time2isoz(self):\n        from mechanize._util import time2isoz\n        base = 1019227000\n        day = 24 * 3600\n        assert time2isoz(base) == '2002-04-19 14:36:40Z'\n        assert time2isoz(base + day) == '2002-04-20 14:36:40Z'\n        assert time2isoz(base + 2 * day) == '2002-04-21 14:36:40Z'\n        assert time2isoz(base + 3 * day) == '2002-04-22 14:36:40Z'\n        az = time2isoz()\n        bz = time2isoz(500000)\n        for text in (az, bz):\n            assert re.search('^\\\\d{4}-\\\\d\\\\d-\\\\d\\\\d \\\\d\\\\d:\\\\d\\\\d:\\\\d\\\\dZ$', text\n                ), 'bad time2isoz format: %s %s' % (az, bz)\n    \nDateTimeTests().test_time2isoz()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Network/mechanize/test/test_date.py"}, {"test_code": "import re\nimport time\nfrom unittest import TestCase\nfrom mechanize._util import time2isoz\nfrom mechanize._util import http2time\nimport unittest\n\nclass DateTimeTests(TestCase):\n    def test_http2time_formats(self):\n        from mechanize._util import http2time, time2isoz\n        tests = ['Thu, 03 Feb 1994 00:00:00 GMT',\n            'Thursday, 03-Feb-94 00:00:00 GMT',\n            'Thursday, 03-Feb-1994 00:00:00 GMT', '03 Feb 1994 00:00:00 GMT',\n            '03-Feb-94 00:00:00 GMT', '03-Feb-1994 00:00:00 GMT',\n            '03-Feb-1994 00:00 GMT', '03-Feb-1994 00:00', '03-Feb-94',\n            '03-Feb-1994', '03 Feb 1994', '  03   Feb   1994  0:00  ',\n            '  03-Feb-1994  ']\n        test_t = 760233600\n        result = time2isoz(test_t)\n        expected = '1994-02-03 00:00:00Z'\n        assert result == expected, \"%s  =>  '%s' (%s)\" % (test_t, result, expected)\n        for s in tests:\n            t = http2time(s)\n            t2 = http2time(s.lower())\n            t3 = http2time(s.upper())\n            assert t == t2 == t3 == test_t, \"'%s'  =>  %s, %s, %s (%s)\" % (s, t,\n                t2, t3, test_t)\n    \nDateTimeTests().test_http2time_formats()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Network/mechanize/test/test_date.py"}], "instruction": "Functionality: The function 'time2isoz' is designed to convert a given time in seconds since the epoch to a string formatted in UTC (Universal Time) with the pattern \"YYYY-MM-DD hh:mm:ssZ\". In the absence of an input, the function defaults to converting the current system time.\n\nInputs: \n- t (optional): A floating-point number representing the number of seconds since the epoch. If not provided, the current system time is used by default.\n\nOutputs:\n- A string representing the given time or the current system time in UTC format. The format of the returned string is \"YYYY-MM-DD hh:mm:ssZ\", where \"YYYY\" is the year, \"MM\" is the month, \"DD\" is the day, \"hh\" is the hour, \"mm\" is the minute, \"ss\" is the second, and \"Z\" indicates the time is in UTC.", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef time2isoz(t=None): [MASK]\n"}
{"method_name": "http2time", "full_method_name": "http2time", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef http2time(text):\n    \"\"\"Returns time in seconds since epoch of time represented by a string.\n\n    Return value is an integer.\n\n    None is returned if the format of str is unrecognized, the time is outside\n    the representable range, or the timezone string is not recognized.  If the\n    string contains no timezone, UTC is assumed.\n\n    The timezone in the string may be numerical (like \"-0800\" or \"+0100\") or a\n    string timezone (like \"UTC\", \"GMT\", \"BST\" or \"EST\").  Currently, only the\n    timezone strings equivalent to UTC (zero offset) are known to the function.\n\n    The function loosely parses the following formats:\n\n    Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format\n    Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format\n    Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format\n    09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)\n    08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)\n    08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)\n\n    The parser ignores leading and trailing whitespace.  The time may be\n    absent.\n\n    If the year is given with only 2 digits, the function will select the\n    century that makes the year closest to the current date.\n\n    \"\"\"\n    m = strict_re.search(text)\n    if m:\n        g = m.groups()\n        mon = months_lower.index(g[1].lower()) + 1\n        tt = int(g[2]), mon, int(g[0]), int(g[3]), int(g[4]), float(g[5])\n        return my_timegm(tt)\n    text = text.lstrip()\n    text = wkday_re.sub('', text, 1)\n    day, mon, yr, hr, min, sec, tz = [None] * 7\n    m = loose_http_re.search(text)\n    if m is not None:\n        day, mon, yr, hr, min, sec, tz = m.groups()\n    else:\n        return None\n    return _str2time(day, mon, yr, hr, min, sec, tz)", "test_code_list": [{"test_code": "import re\nimport time\nfrom unittest import TestCase\nfrom mechanize._util import time2isoz\nfrom mechanize._util import http2time\nimport unittest\n\nclass DateTimeTests(TestCase):\n    def test_parse_date(self):\n        from mechanize._util import http2time\n    \n        def parse_date(text, http2time=http2time):\n            return time.gmtime(http2time(text))[:6]\n        assert parse_date('01 Jan 2001') == (2001, 1, 1, 0, 0, 0.0)\n        assert parse_date('03-Feb-20') == (2020, 2, 3, 0, 0, 0.0)\n        assert parse_date('03-Feb-98') == (1998, 2, 3, 0, 0, 0.0)\n    \nDateTimeTests().test_parse_date()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Network/mechanize/test/test_date.py"}, {"test_code": "import re\nimport time\nfrom unittest import TestCase\nfrom mechanize._util import time2isoz\nfrom mechanize._util import http2time\nimport unittest\n\nclass DateTimeTests(TestCase):\n    def test_http2time_formats(self):\n        from mechanize._util import http2time, time2isoz\n        tests = ['Thu, 03 Feb 1994 00:00:00 GMT',\n            'Thursday, 03-Feb-94 00:00:00 GMT',\n            'Thursday, 03-Feb-1994 00:00:00 GMT', '03 Feb 1994 00:00:00 GMT',\n            '03-Feb-94 00:00:00 GMT', '03-Feb-1994 00:00:00 GMT',\n            '03-Feb-1994 00:00 GMT', '03-Feb-1994 00:00', '03-Feb-94',\n            '03-Feb-1994', '03 Feb 1994', '  03   Feb   1994  0:00  ',\n            '  03-Feb-1994  ']\n        test_t = 760233600\n        result = time2isoz(test_t)\n        expected = '1994-02-03 00:00:00Z'\n        assert result == expected, \"%s  =>  '%s' (%s)\" % (test_t, result, expected)\n        for s in tests:\n            t = http2time(s)\n            t2 = http2time(s.lower())\n            t3 = http2time(s.upper())\n            assert t == t2 == t3 == test_t, \"'%s'  =>  %s, %s, %s (%s)\" % (s, t,\n                t2, t3, test_t)\n    \nDateTimeTests().test_http2time_formats()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Network/mechanize/test/test_date.py"}, {"test_code": "import re\nimport time\nfrom unittest import TestCase\nfrom mechanize._util import time2isoz\nfrom mechanize._util import http2time\nimport unittest\n\nclass DateTimeTests(TestCase):\n    def test_http2time_garbage(self):\n        from mechanize._util import http2time\n        for test in ['', 'Garbage', 'Mandag 16. September 1996', '01-00-1980',\n            '01-13-1980', '00-01-1980', '32-01-1980', '01-01-1980 25:00:00',\n            '01-01-1980 00:61:00', '01-01-1980 00:00:62']:\n            bad = False\n            if http2time(test) is not None:\n                print('http2time(%s) is not None' % (test,))\n                print('http2time(test)', http2time(test))\n                bad = True\n            assert not bad\n    \nDateTimeTests().test_http2time_garbage()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Network/mechanize/test/test_date.py"}], "instruction": "Functionality: The http2time function is designed to convert various string representations of time into seconds since the Unix epoch. It parses strings formatted in HTTP, old rfc850 HTTP, and broken rfc850 HTTP formats, recognizing both numerical and string timezones (limited to UTC-equivalent timezones). If no timezone is specified, UTC is assumed. The function handles leading and trailing whitespace, and if a year is given with only two digits, it selects the century that makes the year closest to the current date. It returns None for unrecognized formats or times outside the representable range.\n\nInputs: \n- text (string): A string representing a time in any of the supported formats.\n\nOutputs: \n- int: The number of seconds since the Unix epoch (1970-01-01T00:00:00Z) of the time represented by the string, rounded to the nearest integer.\n- None: Returned if the format of the input string is unrecognized, the time is outside the representable range, or the timezone string is not recognized.", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef http2time(text): [MASK]\n"}
{"method_name": "get_title", "full_method_name": "get_title", "method_path": "../srcdata/Network/mechanize/mechanize/_html.py", "method_code": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\ndef get_title(root):\n    for title in root.iter('title'):\n        text = compress_whitespace(title.text)\n        if text:\n            return text", "test_code_list": [{"test_code": "from unittest import TestCase\nimport mechanize\nimport mechanize._form\nfrom mechanize._response import test_html_response\nfrom mechanize._html import content_parser\nfrom mechanize._html import get_title\nfrom mechanize._html import Factory\nimport unittest\n\nclass TitleTests(TestCase):\n    def test_title_parsing(self):\n        html = (\n            '<html><head>\\n<title> Title\\n Test</title>\\n</head><body><p>Blah.<p></body></html>\\n'\n            )\n        self.assertEqual(get_title(content_parser(html)), 'Title Test')\n    \nTitleTests().test_title_parsing()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_html.py"}, {"test_code": "from unittest import TestCase\nimport mechanize\nimport mechanize._form\nfrom mechanize._response import test_html_response\nfrom mechanize._html import content_parser\nfrom mechanize._html import get_title\nfrom mechanize._html import Factory\nimport unittest\n\nclass MiscTests(TestCase):\n    def test_title_parsing(self):\n    \n        def get_title(html):\n            factory = Factory()\n            response = test_html_response(html)\n            factory.set_response(response)\n            return factory.title\n        html = (\n            b'        <html><head>\\n        <title>T&gt;itle</title>\\n        </head><body><p>Blah.<p></body></html>\\n        '\n            )\n        self.assertEqual(get_title(html), u'T>itle')\n        html = \"\"\"        <html><head>\n            <title>  Ti<script type=\"text/strange\">alert(\"this is valid HTML -- yuck!\")</script>\n            tle &amp;&#38;\n            </title>\n            </head><body><p>Blah.<p></body></html>\n            \"\"\"\n        self.assertEqual(str(get_title(html)),\n            'Ti<script type=\"text/strange\">alert(\"this is valid HTML -- yuck!\")</script> tle &&'\n            )\n        html = \"\"\"        <html><head>\n            <title>\"\"\"\n        self.assertEqual(get_title(html), u'')\n    \nMiscTests().test_title_parsing()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_html.py"}], "instruction": "Functionality: The get_title function is designed to extract the title from an HTML document. It iterates over the 'title' tags within the document to find and return the text content of the first 'title' tag it encounters, after compressing any whitespace.\n\nInputs: \n- root: An HTML document parsed by the html5lib library. This is the root element of the parsed HTML document structure.\n\nOutputs: \n- The function returns a string, which is the text content of the first 'title' tag found within the document. If no 'title' tag is found, or if the 'title' tag is empty, the function will return None.", "method_code_mask": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\n\n\ndef get_title(root): [MASK]\n"}
{"method_name": "content_parser", "full_method_name": "content_parser", "method_path": "../srcdata/Network/mechanize/mechanize/_html.py", "method_code": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\nDEFAULT_ENCODING = 'utf-8'\ndef content_parser(data, url=None, response_info=None, transport_encoding=\n    None, default_encoding=DEFAULT_ENCODING, is_html=True):\n    \"\"\"\n    Parse data (a bytes object) into an etree representation such as\n    :py:mod:`xml.etree.ElementTree` or `lxml.etree`\n    :param bytes data: The data to parse\n    :param url: The URL of the document being parsed or None\n    :param response_info: Information about the document\n        (contains all HTTP headers as :class:`HTTPMessage`)\n    :param transport_encoding: The character encoding for the document being\n        parsed as specified in the HTTP headers or None.\n    :param default_encoding: The character encoding to use if no encoding\n        could be detected and no transport_encoding is specified\n    :param is_html: If the document is to be parsed as HTML.\n    \"\"\"\n    if not is_html:\n        return\n    try:\n        from html5_parser import parse\n    except Exception:\n        from html5lib import parse\n        kw = {'namespaceHTMLElements': False}\n        if transport_encoding and isinstance(data, bytes):\n            kw['transport_encoding'] = transport_encoding\n        return parse(data, **kw)\n    else:\n        return parse(data, transport_encoding=transport_encoding)", "test_code_list": [{"test_code": "from unittest import TestCase\nimport mechanize\nimport mechanize._form\nfrom mechanize._response import test_html_response\nfrom mechanize._html import content_parser\nfrom mechanize._html import get_title\nfrom mechanize._html import Factory\nimport unittest\n\nclass TitleTests(TestCase):\n    def test_title_parsing(self):\n        html = (\n            '<html><head>\\n<title> Title\\n Test</title>\\n</head><body><p>Blah.<p></body></html>\\n'\n            )\n        self.assertEqual(get_title(content_parser(html)), 'Title Test')\n    \nTitleTests().test_title_parsing()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_html.py"}], "instruction": "Functionality: The content_parser function is designed to parse data (given as a bytes object) into an etree representation, such as those provided by `xml.etree.ElementTree` or `lxml.etree`. This function is particularly tailored for HTML documents but can be instructed to handle other formats by setting the is_html parameter to False.\n\nInputs: \n- data: The data to parse, provided as a bytes object.\n- url: Optional parameter, indicating the URL of the document being parsed.\n- response_info: Optional parameter containing information about the document, including HTTP headers.\n- transport_encoding: Optional parameter specifying the character encoding for the document as indicated in the HTTP headers.\n- default_encoding: Character encoding to use if no encoding can be detected and no transport_encoding is specified, with 'utf-8' as the default.\n- is_html: A boolean flag indicating whether the document should be parsed as HTML. If False, the function will attempt to parse the data in a non-HTML format.\n\nOutputs:\n- The function returns an etree representation of the parsed data. If is_html is False and the parsing is not applicable, the function will return None.", "method_code_mask": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\nDEFAULT_ENCODING = 'utf-8'\n\n\ndef content_parser(data, url=None, response_info=None, transport_encoding=\n    None, default_encoding=DEFAULT_ENCODING, is_html=True): [MASK]\n"}
{"method_name": "parse_http_list", "full_method_name": "parse_http_list", "method_path": "../srcdata/Network/mechanize/mechanize/_urllib2_fork.py", "method_code": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\ndef parse_http_list(s):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Neither commas nor quotes count if they are escaped.\n    Only double-quotes count, not single-quotes.\n    \"\"\"\n    res = []\n    part = ''\n    escape = quote = False\n    for cur in s:\n        if escape:\n            part += cur\n            escape = False\n            continue\n        if quote:\n            if cur == '\\\\':\n                escape = True\n                continue\n            elif cur == '\"':\n                quote = False\n            part += cur\n            continue\n        if cur == ',':\n            res.append(part)\n            part = ''\n            continue\n        if cur == '\"':\n            quote = True\n        part += cur\n    if part:\n        res.append(part)\n    return list(filter(None, (part_.strip() for part_ in res)))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\n\nclass TrivialTests(mechanize._testcase.TestCase):\n    def test_parse_http_list(self):\n        tests = [('a,b,c', ['a', 'b', 'c']), ('path\"o,l\"og\"i\"cal, example', [\n            'path\"o,l\"og\"i\"cal', 'example']), ('a, b, \"c\", \"d\", \"e,f\", g, h', [\n            'a', 'b', '\"c\"', '\"d\"', '\"e,f\"', 'g', 'h']), (\n            'a=\"b\\\\\"c\", d=\"e\\\\,f\", g=\"h\\\\\\\\i\"', ['a=\"b\"c\"', 'd=\"e,f\"', 'g=\"h\\\\i\"'])\n            ]\n        for string, list in tests:\n            self.assertEqual(parse_http_list(string), list)\n    \nTrivialTests().test_parse_http_list()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_urllib2.py"}], "instruction": "Functionality: The function parse_http_list(s) is designed to parse comma-separated lists as described by RFC 2068 Section 2. It specifically handles lists where elements may include quoted-strings. This function ensures that elements within the list are correctly identified, even when quoted-strings contain commas or other elements are interspersed with quotes. The parsing logic accounts for escaped characters and only considers double-quotes for delineating quoted-strings, ignoring single-quotes.\n\nInputs: \n- s: A string representing a comma-separated list. The elements of the list may include quoted-strings with potentially embedded commas or quotes. The string may also contain escaped characters denoted by a backslash (\\).\n\nOutputs:\n- A list of strings, where each string is an unquoted element or a quoted-string from the input. The output list will not contain empty strings, as any empty elements resulting from parsing are filtered out. Each element in the output list is stripped of leading and trailing whitespace.", "method_code_mask": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\n\n\ndef parse_http_list(s): [MASK]\n"}
{"method_name": "http_message", "full_method_name": "http_message", "method_path": "../srcdata/Network/mechanize/test/test_urllib2.py", "method_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\ndef http_message(mapping):\n    \"\"\"\n    >>> http_message({\"Content-Type\": \"text/html\"}).items()\n    [('content-type', 'text/html')]\n\n    \"\"\"\n    f = []\n    for kv in iteritems(mapping):\n        f.append('%s: %s' % kv)\n    f.append('')\n    msg = '\\r\\n'.join(f)\n    if not isinstance(msg, bytes):\n        msg = msg.encode('iso-8859-1')\n    msg = create_response_info(BytesIO(msg))\n    return msg", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\nclass MockResponse(BytesIO):\n\n    def __init__(self, code, msg, headers, data, url=None):\n        if not isinstance(data, bytes):\n            data = data.encode('utf-8')\n        BytesIO.__init__(self, data)\n        self.code, self.msg, self.headers, self.url = code, msg, headers, url\n\n    def info(self):\n        return self.headers\n\n    def geturl(self):\n        return self.url\nclass MockOpener:\n    addheaders = []\n    finalize_request_headers = None\n    def open(self, req, data=None, timeout=_sockettimeout.\n        _GLOBAL_DEFAULT_TIMEOUT):\n        self.req, self.data, self.timeout = req, data, timeout\n    def error(self, proto, *args):\n        self.proto, self.args = proto, args\nclass HandlerTests(mechanize._testcase.TestCase):\n    def test_refresh(self):\n        h = HTTPRefreshProcessor(max_time=None, honor_time=False)\n        for val, valid in [('0; url=\"http://example.com/foo/\"', True), ('2',\n            True), ('0; \"http://example.com/foo/\"', False)]:\n            o = h.parent = MockOpener()\n            req = Request('http://example.com/')\n            headers = http_message({'refresh': val})\n            r = MockResponse(200, 'OK', headers, '', 'http://example.com/')\n            h.http_response(req, r)\n            if valid:\n                self.assertEqual(o.proto, 'http')\n                self.assertEqual(o.args, (req, r, 'refresh', 'OK', headers))\nHandlerTests().test_refresh()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_urllib2.py"}, {"test_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\nclass MockFile:\n\n    def read(self, count=None):\n        pass\n\n    def readline(self, count=None):\n        pass\n\n    def close(self):\n        pass\n\n    def __iter__(self):\n        for i in ():\n            yield i\nclass MockOpener:\n    addheaders = []\n    finalize_request_headers = None\n    def open(self, req, data=None, timeout=_sockettimeout.\n        _GLOBAL_DEFAULT_TIMEOUT):\n        self.req, self.data, self.timeout = req, data, timeout\n    def error(self, proto, *args):\n        self.proto, self.args = proto, args\nclass HandlerTests(mechanize._testcase.TestCase):\n    def test_redirect(self):\n        from_url = 'http://example.com/a.html'\n        to_url = 'http://example.com/b.html'\n        h = HTTPRedirectHandler()\n        o = h.parent = MockOpener()\n        for code in (301, 302, 303, 'refresh'):\n            for data in (None, 'blah\\nblah\\n'):\n                method = getattr(h, 'http_error_%s' % code)\n                req = Request(from_url, data)\n                req.add_header('Nonsense', 'viking=withhold')\n                req.add_unredirected_header('Spam', 'spam')\n                req.origin_req_host = 'example.com'\n                try:\n                    method(req, MockFile(), code, 'Blah', http_message({\n                        'location': to_url}))\n                except mechanize.HTTPError:\n                    self.assertEqual(code, 307)\n                    self.assertTrue(data is not None)\n                self.assertEqual(o.req.get_full_url(), to_url)\n                try:\n                    self.assertEqual(o.req.get_method(), 'GET')\n                except AttributeError:\n                    self.assertFalse(o.req.has_data())\n                headers = [x.lower() for x in o.req.headers]\n                self.assertTrue('content-length' not in headers)\n                self.assertTrue('content-type' not in headers)\n                self.assertEqual(o.req.headers['Nonsense'], 'viking=withhold')\n                self.assertTrue('Spam' not in o.req.headers)\n                self.assertTrue('Spam' not in o.req.unredirected_hdrs)\n        req = Request(from_url)\n        def redirect(h, req, url=to_url):\n            h.http_error_302(req, MockFile(), 302, 'Blah', http_message({\n                'location': url}))\n        req = Request(from_url, origin_req_host='example.com')\n        count = 0\n        try:\n            while 1:\n                redirect(h, req, 'http://example.com/')\n                count = count + 1\n        except mechanize.HTTPError:\n            self.assertEqual(count, HTTPRedirectHandler.max_repeats)\n        req = Request(from_url, origin_req_host='example.com')\n        count = 0\n        try:\n            while 1:\n                redirect(h, req, 'http://example.com/%d' % count)\n                count = count + 1\n        except mechanize.HTTPError:\n            self.assertEqual(count, HTTPRedirectHandler.max_redirections)\nHandlerTests().test_redirect()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_urllib2.py"}, {"test_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\nclass MockOpener:\n    addheaders = []\n    finalize_request_headers = None\n\n    def open(self, req, data=None, timeout=_sockettimeout.\n        _GLOBAL_DEFAULT_TIMEOUT):\n        self.req, self.data, self.timeout = req, data, timeout\n\n    def error(self, proto, *args):\n        self.proto, self.args = proto, args\nclass HandlerTests(mechanize._testcase.TestCase):\n    def test_redirect_bad_uri(self):\n        from mechanize._response import test_html_response\n        from_url = 'http://example.com/a.html'\n        bad_to_url = 'http://example.com/b. |html'\n        good_to_url = 'http://example.com/b.%20%7Chtml'\n        h = HTTPRedirectHandler()\n        o = h.parent = MockOpener()\n        req = Request(from_url)\n        h.http_error_302(req, test_html_response(), 302, 'Blah', http_message({\n            'location': bad_to_url}))\n        self.assertEqual(o.req.get_full_url(), good_to_url)\nHandlerTests().test_redirect_bad_uri()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_urllib2.py"}], "instruction": "Functionality: The http_message function takes a dictionary of HTTP header fields as input and generates an HTTP message object. The function specifically formats the input dictionary into a series of header lines following the HTTP protocol standards, and then encodes this message into bytes using the ISO-8859-1 encoding. The resulting object simulates an HTTP response, which can be used for testing and validation purposes.\n\nInputs: \n- mapping: A dictionary where keys are header field names (e.g., \"Content-Type\", \"Date\") and values are the corresponding header field values. The keys are case-insensitive.\n\nOutputs:\n- msg: An HTTP message object created from the input dictionary. This object can be used to inspect and manipulate the HTTP headers as if they were received from an HTTP server.", "method_code_mask": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\n\n\ndef http_message(mapping): [MASK]\n"}
{"method_name": "normalize_url", "full_method_name": "normalize_url", "method_path": "../srcdata/Network/mechanize/mechanize/_urllib2_fork.py", "method_code": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\ndef normalize_url(url):\n    parsed = urlparse(url)\n    netloc = parsed.netloc\n    if not isinstance(netloc, bytes) and netloc:\n\n        def safe_encode(label):\n            try:\n                return label.encode('idna').decode('ascii')\n            except ValueError:\n                return label.encode('ascii', 'replace').decode('ascii')\n        netloc = u'.'.join(map(safe_encode, netloc.split(u'.')))\n    return urlunparse(parsed._replace(path=\n        fix_invalid_bytes_in_url_component(parsed.path), netloc=netloc,\n        query=fix_invalid_bytes_in_url_component(parsed.query, QUERY_CHARS),\n        fragment=fix_invalid_bytes_in_url_component(parsed.fragment,\n        FRAGMENT_CHARS)))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\n\nclass RequestTests(unittest.TestCase):\n    def test_normalize_url(self):\n    \n        def t(x, expected=None):\n            self.assertEqual(normalize_url(x), expected or x)\n        t('https://simple.com/moo%7Ese')\n        t('https://ex.com/Sp\u00f6rt', 'https://ex.com/Sp%C3%B6rt')\n        t('https://ex.com/Sp%C3%B6rt')\n    \nRequestTests().test_normalize_url()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_urllib2.py"}], "instruction": "Functionality: The normalize_url function is designed to handle and normalize URLs. It ensures that the URL components, such as the network location (netloc), path, query, and fragment, are properly encoded and formatted. Specifically, it processes the network location to handle IDNA encoding issues and fixes invalid bytes in other components of the URL.\n\nInputs: The function takes a single argument:\n- url: A string representing the URL to be normalized. The URL can be in various formats, including those with improperly encoded or formatted components.\n\nOutputs: The function returns a single output:\n- A string representing the normalized URL. The returned URL will have its components properly encoded and formatted, adhering to URL encoding standards, including handling of IDNA encoding for the network location (netloc) and fixing invalid bytes in path, query, and fragment components.", "method_code_mask": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\n\n\ndef normalize_url(url): [MASK]\n"}
{"method_name": "BytesIO", "full_method_name": "BytesIO", "method_path": "../srcdata/Network/mechanize/test/test_form.py", "method_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef parse_file_ex(file, base_uri, select_default=False, request_class=\n    mechanize.Request, encoding=None, backwards_compat=False, add_global=True):\n    raw = file.read()\n    root = content_parser(raw, transport_encoding=encoding)\n    form_encoding = find_declared_encoding(raw) or encoding\n    forms, global_form = _form.parse_forms(root, base_uri, select_default=\n        select_default, request_class=request_class, encoding=form_encoding)\n    if not add_global:\n        return list(forms)\n    return [global_form] + list(forms)\nparse_file = partial(parse_file_ex, add_global=False)\nclass UploadTests(_testcase.TestCase):\n    def setUp(self):\n        _testcase.TestCase.setUp(self)\n        import mechanize._form_controls as fc\n        def mock_choose_boundary():\n            self.boundary_count += 1\n            return str(self.boundary_count)\n        self.choose_boundary = fc.choose_boundary\n        fc.choose_boundary = mock_choose_boundary\n        self.boundary_count = 0\n    def tearDown(self):\n        import mechanize._form_controls as fc\n        fc.choose_boundary = self.choose_boundary\n        _testcase.TestCase.tearDown(self)\n    def test_choose_boundary(self):\n        bndy = _form_controls.choose_boundary()\n        ii = bndy.find('.')\n        self.assertTrue(ii < 0)\n    def make_form(self):\n        html = \"\"\"<form action=\"/cgi-bin/upload.cgi\" method=\"POST\" enctype=\"multipart/form-data\">\n<input type=\"file\" name=\"data\">\n<input type=\"text\" name=\"user\" value=\"nobody\">\n<br>\n<input type=\"submit\">\n</form>\n\"\"\"\n        return parse_file(BytesIO(html),\n            'http://localhost/cgi-bin/upload.cgi', backwards_compat=False)[0]\n    def test_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data))\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req)\n    def test_file_request_with_filename(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='afilename')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req, filename='afilename')\n    def test_multipart_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='filenamea')\n        more_data = 'rhubarb\\nrhubarb\\n'\n        data_control.add_file(BytesIO(more_data))\n        yet_more_data = 'rheum\\nrhaponicum\\n'\n        data_control.add_file(BytesIO(yet_more_data), filename='filenamec')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        self.assertMultiLineEqual(req.get_data().decode('ascii'),\n            '--1\\r\\nContent-Disposition: form-data; name=\"data\"\\r\\nContent-Type: multipart/mixed;\\r\\n    boundary=2\\r\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamea\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nblah\\nbaz\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrhubarb\\nrhubarb\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamec\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrheum\\nrhaponicum\\n\\r\\n--2--\\r\\n\\r\\n--1\\r\\nContent-Disposition: form-data; name=\"user\"\\r\\n\\r\\njohn\\r\\n--1--\\r\\n'\n            )\n    def test_upload_data(self):\n        form = self.make_form()\n        data = form.click().get_data()\n        self.assertTrue(data.startswith(b'--'))\n    def test_empty_upload(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"./weird.html\" enctype=\"multipart/form-data\">\n<input type=\"submit\" name=\"submit\"></input>\n</form></html>\"\"\"\n            ), '.', backwards_compat=False)\n        form = forms[0]\n        data = form.click().get_data()\n        lines = data.split(b'\\r\\n')\n        self.assertTrue(lines[0].startswith(b'--'))\n        self.assertEqual(lines[1],\n            b'Content-Disposition: form-data; name=\"submit\"')\n        self.assertEqual(lines[2], b'')\n        self.assertEqual(lines[3], b'')\n        self.assertTrue(lines[4].startswith(b'--'))\n    def test_no_files(self):\n        self.monkey_patch(_form_controls, 'choose_boundary', lambda : '123')\n        forms = parse_file_ex(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"spam\" enctype=\"multipart/form-data\">\n<INPUT type=\"file\" name=\"spam\" />\n</form></html>\"\"\"\n            ), '.')\n        form = forms[1]\n        data = form.click().get_data()\n        self.assertEqual(data,\n            b'--123\\r\\nContent-Disposition: form-data; name=\"spam\"; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\\r\\n--123--\\r\\n'\n            )\ndef BytesIO(x=b''):\n    if not isinstance(x, bytes):\n        x = x.encode('utf-8')\n    return io.BytesIO(x)", "test_code_list": [{"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\nem_dash = codepoint_to_chr(8212)\nclass UnescapeTests(unittest.TestCase):\n    def test_unescape_parsing(self):\n        file = BytesIO(\n            \"\"\"<form action=\"&amp;amp;&mdash;&#x2014;&#8212;\">\n    <textarea name=\"name&amp;amp;&mdash;&#x2014;&#8212;\">val&amp;amp;&mdash;&#x2014;&#8212;</textarea>\n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False,\n            encoding='utf-8')\n        form = forms[0]\n        test_string = '&amp;' + em_dash * 3\n        self.assertEqual(form.action, 'http://localhost/' + test_string)\n        control = form.find_control(type='textarea', nr=0)\n        self.assertEqual(control.value, 'val' + test_string)\n        self.assertEqual(control.name, 'name' + test_string)\nUnescapeTests().test_unescape_parsing()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\nem_dash = codepoint_to_chr(8212)\nclass UnescapeTests(unittest.TestCase):\n    def test_unescape_parsing_select(self):\n        f = BytesIO(\n            \"\"\"<form>\n    <select name=\"a\">\n        <option>1&amp;amp;&mdash;&#x2014;&#8212;</option>\n        <option value=\"2&amp;amp;&mdash;&#x2014;&#8212;\">2&amp;amp;&mdash;&#x2014;&#8212;</option>\n    </select>\n    </form>\n    \"\"\"\n            )\n        forms = parse_file_ex(f, 'http://localhost/', encoding='utf-8')\n        form = forms[1]\n        test_string = '&amp;' + em_dash * 3\n        control = form.find_control(nr=0)\n        for ii in range(len(control.items)):\n            item = control.items[ii]\n            self.assertEqual(item.name, str(ii + 1) + test_string)\nUnescapeTests().test_unescape_parsing_select()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass UnescapeTests(unittest.TestCase):\n    def test_unescape_parsing_data(self):\n        file = BytesIO(\n            \"\"\"<form>\n        <label for=\"foo\">Blah &#x201d; &rdquo; blah</label>\n        <input type=\"text\" id=\"foo\" name=\"foo\">\n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False,\n            encoding='latin-1')\n        label = forms[0].find_control(nr=0).get_labels()[0]\n        self.assertEqual(label.text, b'Blah \\xe2\\x80\\x9d \\xe2\\x80\\x9d blah'.\n            decode('utf-8'))\n    \nUnescapeTests().test_unescape_parsing_data()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass LWPFormTests(unittest.TestCase):\n    def testEmptyParse(self):\n        forms = parse_file(BytesIO(''), 'http://localhost', backwards_compat=False)\n        self.assertTrue(len(forms) == 0)\n    \nLWPFormTests().testEmptyParse()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_unknown_control(self):\n        f = BytesIO('<form action=\"abc\">\\n<input type=\"bogus\">\\n<input>\\n</form>\\n'\n            )\n        base_uri = 'http://localhost/'\n        forms = parse_file(f, base_uri, backwards_compat=False)\n        form = forms[0]\n        for ctl in form.controls:\n            self.assertTrue(isinstance(ctl, _form_controls.TextControl))\n    \nParseTests().test_unknown_control()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_form_attribute(self):\n        f = BytesIO(\n            \"\"\"<form id=\"f\"><input name=\"a\"><input name=\"c\" form=\"o\"></form>\n                <input name=\"b\" form=\"f\"></input>\n                <form id=\"o\"><input name=\"d\"></form>\"\"\"\n            )\n        forms = parse_file(f, 'http://example.com')\n        self.assertEqual(len(forms), 2)\n        f = forms[0]\n        self.assertEqual(len(f.controls), 2)\n        self.assertEqual([c.name for c in f.controls], 'a b'.split())\n        f = forms[1]\n        self.assertEqual(len(f.controls), 2)\n        self.assertEqual([c.name for c in f.controls], 'c d'.split())\n    \nParseTests().test_form_attribute()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_ParseFileEx(self):\n        f = BytesIO('<form action=\"abc\">\\n<input type=\"text\"></input>\\n</form>\\n')\n        base_uri = 'http://localhost/'\n        forms = parse_file_ex(f, base_uri)\n        outer = forms[0]\n        self.assertEqual(len(forms), 2)\n        self.assertEqual(outer.controls, [])\n        self.assertEqual(outer.name, None)\n        self.assertEqual(outer.action, base_uri)\n        self.assertEqual(outer.method, 'GET')\n        self.assertEqual(outer.enctype, 'application/x-www-form-urlencoded')\n        self.assertEqual(outer.attrs, {})\n        f = BytesIO(\n            \"\"\"\n    <input type=\"text\" name=\"a\"></input>\n    <form action=\"abc\">\n      <input type=\"text\" name=\"b\"></input>\n    </form>\n    <input type=\"text\" name=\"c\"></input>\n    <form action=\"abc\">\n      <input type=\"text\" name=\"d\"></input>\n    </form>\n    <input type=\"text\" name=\"e\"></input>\n    \"\"\"\n            )\n        base_uri = 'http://localhost/'\n        forms = parse_file_ex(f, base_uri)\n        outer = forms[0]\n        self.assertEqual(len(forms), 3)\n        self.assertEqual([c.name for c in outer.controls], ['a', 'c', 'e'])\n        self.assertEqual(outer.name, None)\n        self.assertEqual(outer.action, base_uri)\n        self.assertEqual(outer.method, 'GET')\n        self.assertEqual(outer.enctype, 'application/x-www-form-urlencoded')\n        self.assertEqual(outer.attrs, {})\n    \nParseTests().test_ParseFileEx()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_base_uri(self):\n        file = BytesIO(\n            \"\"\"<base HREF=\"http://example.com\">\n    <form action=\"abc\">\n    <input type=\"submit\"></input>\n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        self.assertEqual(form.action, 'http://example.com/abc')\n        file = BytesIO(\n            '<form action=\"abc\">\\n<input type=\"submit\"></input>\\n</form>\\n')\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        self.assertTrue(form.action == 'http://localhost/abc')\n    \nParseTests().test_base_uri()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef hide_deprecations():\n    warnings.filterwarnings('ignore', category=DeprecationWarning)\nclass ParseTests(unittest.TestCase):\n    def testSelect(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\">\n    <select name=\"foo\">\n     <option>Hello testers &amp; &blah; users!</option>\n     <option></option><option></option>\n    </select>\n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        self.assertTrue(len(forms) == 1)\n        form = forms[0]\n        entity_ctl = form.find_control(type='select')\n        self.assertTrue(entity_ctl.name == 'foo')\n        self.assertEqual(entity_ctl.value[0], 'Hello testers & &blah; users!')\n        hide_deprecations()\n        opt = entity_ctl.get_item_attrs('Hello testers & &blah; users!')\n        reset_deprecations()\n        self.assertEqual(opt['value'], 'Hello testers & &blah; users!')\n        self.assertEqual(opt['label'], 'Hello testers & &blah; users!')\n        self.assertEqual(opt['contents'], 'Hello testers & &blah; users!')\nParseTests().testSelect()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def testButton(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\" name=\"myform\">\n    \n    <input type=\"text\" value=\"cow\" name=\"moo\">\n    \n    <button name=\"b\">blah, blah,\n    Rhubarb.</button>\n    \n    <button type=\"reset\" name=\"b2\"></button>\n    <button type=\"button\" name=\"b3\"></button>\n    \n    </form>\n    \n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        self.assertTrue(form.name == 'myform')\n        control = form.find_control(name='b')\n        self.assertEqual(control.type, 'submitbutton')\n        self.assertTrue(control.value == '')\n        self.assertTrue(form.find_control('b2').type == 'resetbutton')\n        self.assertTrue(form.find_control('b3').type == 'buttonbutton')\n        pairs = form.click_pairs()\n        self.assertTrue(pairs == [('moo', 'cow'), ('b', '')])\n    \nParseTests().testButton()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def testEmptySelect(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\">\n    <select name=\"foo\"></select>\n    \n    <select name=\"bar\" multiple></select>\n    \n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        control0 = form.find_control(type='select', nr=0)\n        control1 = form.find_control(type='select', nr=1)\n        self.assertTrue(str(control0) == '<SelectControl(foo=[])>')\n        self.assertTrue(str(control1) == '<SelectControl(bar=[])>')\n        form.set_value([], 'foo')\n        self.assertRaises(ItemNotFoundError, form.set_value, ['oops'], 'foo')\n        self.assertTrue(form.click_pairs() == [])\n    \nParseTests().testEmptySelect()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def testUnnamedControl(self):\n        file = BytesIO(\n            \"\"\"\n    <form action=\"./weird.html\">\n    \n    <input type=\"checkbox\" value=\"foo\"></input>\n    \n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        self.assertTrue(form.controls[0].name is None)\n    \nParseTests().testUnnamedControl()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef hide_deprecations():\n    warnings.filterwarnings('ignore', category=DeprecationWarning)\nclass ParseTests(unittest.TestCase):\n    def testNamelessListItems(self):\n        file = BytesIO(\n            \"\"\"<form action=\"./weird.html\">\n    <input type=\"checkbox\" name=\"foo\"></input>\n    <input type=\"radio\" name=\"bar\"></input>\n    <!--\n    <select name=\"baz\">\n      <option></option>\n    </select>\n    <select name=\"baz\" multiple>\n      <option></option>\n    </select>\n    -->\n    <input type=\"submit\" name=\"submit\">\n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        hide_deprecations()\n        self.assertTrue(form.possible_items('foo') == ['on'])\n        self.assertTrue(form.possible_items('bar') == ['on'])\n        reset_deprecations()\n        self.assertTrue(form['foo'] == [])\n        self.assertTrue(form['bar'] == [])\n        form['foo'] = ['on']\n        form['bar'] = ['on']\n        pairs = form.click_pairs()\n        self.assertEqual(pairs, [('foo', 'on'), ('bar', 'on'), ('submit', '')])\nParseTests().testNamelessListItems()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def testSingleSelectFixup(self):\n        file = BytesIO(\n            \"\"\"<form action=\"./bad.html\">\n    \n    <select name=\"spam\">\n      <option selected>1</option>\n      <option selected>2</option>\n    </select>\n    \n    <select name=\"cow\">\n      <option selected>1</option>\n      <option disabled selected>2</option>\n    </select>\n    \n    <select name=\"moo\">\n      <option selected disabled>1</option>\n      <option>2</option>\n    </select>\n    \n    <select name=\"nnn\">\n      <option disabled>1</option>\n      <option>2</option>\n      <option>3</option>\n    </select>\n    \n    </form>\n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        spam = form.find_control('spam')\n        self.assertEqual([ii.name for ii in spam.items if ii.selected], ['2'])\n        cow = form.find_control('cow')\n        self.assertEqual([ii.name for ii in cow.items if ii.selected], ['2'])\n        moo = form.find_control('moo')\n        self.assertEqual([ii.name for ii in moo.items if ii.selected], ['1'])\n        moo = form.find_control('nnn')\n        self.assertEqual([ii.name for ii in moo.items if ii.selected], ['2'])\n    \nParseTests().testSingleSelectFixup()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def testSelectDefault(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\" name=\"myform\">\n    \n    <select name=\"a\" multiple>\n     <option>1</option>\n     <option>2</option>\n     <option>3</option>\n    </select>\n    \n    <select name=\"b\">\n     <option>1</option>\n     <option>2</option>\n     <option>3</option>\n    </select>\n    \n    </form>\n    \n    \"\"\"\n            )\n        forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n        form = forms[0]\n        control = form.find_control('a')\n        self.assertTrue(control.value == [])\n        single_control = form.find_control('b')\n        self.assertTrue(single_control.value == ['1'])\n        file.seek(0)\n        forms = parse_file(file, 'http://localhost/', select_default=1,\n            backwards_compat=False)\n        form = forms[0]\n        control = form.find_control(type='select', nr=0)\n        self.assertTrue(control.value == ['1'])\n        single_control = form.find_control(type='select', nr=1)\n        self.assertTrue(single_control.value == ['1'])\n    \nParseTests().testSelectDefault()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_close_base_tag(self):\n        forms = parse_file(BytesIO(\n            '<form><textarea>\\n\\nblah\\n</textarea></form>'),\n            'http://example.com/', backwards_compat=False)\n        ctl = forms[0].find_control(type='textarea')\n        self.assertEqual(ctl.value, '\\r\\nblah\\r\\n')\n    \nParseTests().test_close_base_tag()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_embedded_newlines(self):\n        forms = parse_file(BytesIO(\n            '<form><textarea>\\n\\nspam&amp;\\neggs\\n</textarea></form>'),\n            'http://example.com/', backwards_compat=False)\n        ctl = forms[0].find_control(type='textarea')\n        self.assertEqual(ctl.value, '\\r\\nspam&\\r\\neggs\\r\\n')\n    \nParseTests().test_embedded_newlines()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_double_select(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<form>\n        <select name=\"a\">\n            <option>b</option>\n            <option>c</option>\n        </select>\n        <select name=\"a\">\n            <option>d</option>\n            <option>e</option>\n        </select>\n    </form>\n    \"\"\"\n            ), 'http://example.com/', backwards_compat=False)\n        form = forms[0]\n        self.assertEqual(len(form.controls), 2)\n        ctl = form.find_control(name='a', nr=0)\n        self.assertEqual([item.name for item in ctl.items], ['b', 'c'])\n        ctl = form.find_control(name='a', nr=1)\n        self.assertEqual([item.name for item in ctl.items], ['d', 'e'])\n    \nParseTests().test_double_select()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_empty_document(self):\n        forms = parse_file_ex(BytesIO(''), 'http://example.com/')\n        self.assertEqual(len(forms), 1)\n    \nParseTests().test_empty_document()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ParseTests(unittest.TestCase):\n    def test_missing_closing_body_tag(self):\n        forms = parse_file_ex(BytesIO('<form name=\"spam\">'), 'http://example.com/')\n        self.assertEqual(len(forms), 2)\n        self.assertEqual(forms[1].name, 'spam')\n    \nParseTests().test_missing_closing_body_tag()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef hide_deprecations():\n    warnings.filterwarnings('ignore', category=DeprecationWarning)\nclass DisabledTests(unittest.TestCase):\n    def testOptgroup(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\" name=\"myform\">\n    <select name=\"foo\" multiple>\n     <option>1</option>\n     <optgroup>\n     <option>2</option>\n     </optgroup>\n     <option>3</option>\n     <optgroup>\n     <option>4</option>\n     <option>5</option>\n     <option>6</option>\n     </optgroup>\n     <optgroup disabled>\n     <option selected>7</option>\n     <option>8</option>\n     </optgroup>\n     <option>9</option>\n     <optgroup disabled>\n     <option>10</option>\n     </optgroup>\n    </select>\n    <select name=\"bar\">\n     <option>1</option>\n     <optgroup>\n     <option>2</option>\n     </optgroup>\n     <option>3</option>\n     <optgroup>\n     <option>4</option>\n     <option>5</option>\n     <option>6</option>\n     </optgroup>\n     <optgroup disabled>\n     <option selected>7</option>\n     <option>8</option>\n     </optgroup>\n     <option>9</option>\n     <optgroup disabled>\n     <option>10</option>\n     </optgroup>\n    </select>\n    </form>\"\"\"\n            )\n        def get_control(name, file=file):\n            file.seek(0)\n            forms = parse_file(file, 'http://localhost/', backwards_compat=False)\n            form = forms[0]\n            return form.find_control(name)\n        control = get_control('foo')\n        self.assertRaises(TypeError, control.get_item_disabled)\n        hide_deprecations()\n        control.set_item_disabled(True, '2')\n        reset_deprecations()\n        self.assertEqual(str(control),\n            '<SelectControl(foo=[1, (2), 3, 4, 5, 6, (*7), (8), 9, (10)])>')\n        control = get_control('foo')\n        extra = []\n        self.assertEqual(control.value, [] + extra)\n        control.value = ['1']\n        self.assertEqual(control.value, ['1'])\n        control = get_control('foo')\n        self.assertRaises(AttributeError, setattr, control, 'value', ['8'])\n        self.assertEqual(control.value, [] + extra)\n        self.assertRaises(AttributeError, setattr, control, 'value', ['7'])\n        control.value = ['1', '3']\n        self.assertEqual(control.value, ['1', '3'])\n        control = get_control('foo')\n        self.assertRaises(AttributeError, setattr, control, 'value', ['1', '7'])\n        self.assertEqual(control.value, [] + extra)\n        control.set_all_items_disabled(False)\n        control.value = ['1', '7']\n        self.assertEqual(control.value, ['1', '7'])\n        control = get_control('foo')\n        hide_deprecations()\n        for name in (7, 8, 10):\n            self.assertTrue(control.get_item_disabled(str(name)))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.set, True, str(name))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.set, False, str(name))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.toggle, str(name))\n            self.assertTrue(str(name) not in control.value)\n        control = get_control('foo')\n        for name in (1, 2, 3, 4, 5, 6, 9):\n            self.assertTrue(not control.get_item_disabled(str(name)))\n            control.set(False, str(name))\n            self.assertTrue(str(name) not in control.value)\n            control.toggle(str(name))\n            self.assertTrue(str(name) in control.value)\n            control.set(True, str(name))\n            self.assertTrue(str(name) in control.value)\n            control.toggle(str(name))\n            self.assertTrue(str(name) not in control.value)\n        control = get_control('foo')\n        self.assertTrue(control.get_item_disabled('7'))\n        control.set_item_disabled(True, '7')\n        self.assertTrue(control.get_item_disabled('7'))\n        self.assertRaises(AttributeError, control.set, True, '7')\n        control.set_item_disabled(False, '7')\n        self.assertTrue(not control.get_item_disabled('7'))\n        control.set(True, '7')\n        control.set(False, '7')\n        control.toggle('7')\n        control.toggle('7')\n        reset_deprecations()\n        control = get_control('bar')\n        value = []\n        self.assertEqual(control.value, value)\n        self.assertEqual([ii.name for ii in control.items if ii.selected], ['7'])\n        control.value = ['2']\n        control = get_control('bar')\n        def assign_8(control=control):\n            control.value = ['8']\n        self.assertRaises(AttributeError, assign_8)\n        self.assertEqual(control.value, value)\n        def assign_7(control=control):\n            control.value = ['7']\n        self.assertRaises(AttributeError, assign_7)\n        control.set_all_items_disabled(False)\n        assign_7()\n        self.assertEqual(control.value, ['7'])\n        control = get_control('bar')\n        hide_deprecations()\n        for name in (7, 8, 10):\n            self.assertTrue(control.get_item_disabled(str(name)))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.set, True, str(name))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.set, False, str(name))\n            self.assertTrue(str(name) not in control.value)\n            self.assertRaises(AttributeError, control.toggle, str(name))\n            self.assertTrue(str(name) not in control.value)\n        control = get_control('bar')\n        for name in (1, 2, 3, 4, 5, 6, 9):\n            self.assertTrue(not control.get_item_disabled(str(name)))\n            control.set(False, str(name))\n            self.assertTrue(str(name) not in control.value)\n            control.toggle(str(name))\n            self.assertTrue(str(name) == control.value[0])\n            control.set(True, str(name))\n            self.assertTrue(str(name) == control.value[0])\n            control.toggle(str(name))\n            self.assertTrue(str(name) not in control.value)\n        control = get_control('bar')\n        self.assertTrue(control.get_item_disabled('7'))\n        control.set_item_disabled(True, '7')\n        self.assertTrue(control.get_item_disabled('7'))\n        self.assertRaises(AttributeError, control.set, True, '7')\n        self.assertEqual(control.value, value)\n        control.set_item_disabled(False, '7')\n        self.assertEqual(control.value, ['7'])\n        self.assertTrue(not control.get_item_disabled('7'))\n        control.set(True, '7')\n        control.set(False, '7')\n        control.toggle('7')\n        control.toggle('7')\n        for name in ('foo', 'bar'):\n            control = get_control(name)\n            control.set_all_items_disabled(False)\n            control.set(True, '7')\n            control.set(True, '1')\n            control.set_all_items_disabled(True)\n            self.assertRaises(AttributeError, control.set, True, '7')\n            self.assertRaises(AttributeError, control.set, True, '1')\n        reset_deprecations()\nDisabledTests().testOptgroup()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass ControlTests(unittest.TestCase):\n    def testFileControl(self):\n        c = _form_controls.FileControl('file', 'test_file', {})\n        fp = BytesIO()\n        c.add_file(fp)\n        fp2 = BytesIO()\n        c.add_file(fp2, None, 'fp2 file test')\n        self.assertTrue(str(c) ==\n            '<FileControl(test_file=<Unnamed file>, fp2 file test)>')\n        c.readonly = True\n        self.assertRaises(AttributeError, c.clear)\n        c.readonly = False\n        c.clear()\n        self.assertTrue(str(c) == '<FileControl(test_file=<No files added>)>')\n    \nControlTests().testFileControl()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass FormTests(unittest.TestCase):\n    def test_find_control(self):\n        f = BytesIO(\n            \"\"\"<form>\n        <label for=\"form.title\"> Book Title </label></td>\n        <input type=\"text\" id=\"form.title\" name=\"form.title\"\n            value=\"The Grapes of Wrath\" />\n    \n        <label for=\"form.quality\">Book Quality</label></td>\n        <select id=\"form.quality\" name=\"form.country\">\n            <option>Good</option>\n            <option>Bad</option>\n        </select>\n    \n        <label><input type=\"checkbox\" id=\"form.genre.western\" name=\"form.genre\"\n            value=\"western\" /> Western</label>\n        <label><input type=\"checkbox\" id=\"form.genre.horror\" name=\"form.genre\"\n            value=\"horror\" /> Horror</label>\n    \n        <label for=\"form.password\">Password</label>\n        <input type=\"password\" id=\"pswd1\" name=\"password\" value=\"123\" />\n        <input type=\"password\" id=\"pswd2\" name=\"password\" value=\"123\" />\n    </form>\n    \"\"\"\n            )\n        form = parse_file(f, 'http://example.com/', backwards_compat=False)[0]\n        fc = form.find_control\n        self.assertEqual(fc('form.title').id, 'form.title')\n        self.assertEqual(fc('form.title', nr=0).id, 'form.title')\n        self.assertRaises(AmbiguityError, fc, 'password')\n        self.assertEqual(fc('password', id='pswd2').id, 'pswd2')\n        self.assertEqual(fc('password', nr=0).id, 'pswd1')\n        self.assertRaises(ControlNotFoundError, fc, 'form.title', nr=1)\n        self.assertRaises(ControlNotFoundError, fc, nr=50)\n        self.assertRaises(ValueError, fc, nr=-1)\n        self.assertRaises(ControlNotFoundError, fc, label='Bananas')\n        self.assertEqual(fc(label='Title').id, 'form.title')\n        self.assertEqual(fc(label='Book Title').id, 'form.title')\n        self.assertRaises(ControlNotFoundError, fc, label=' Book Title ')\n        self.assertRaises(ControlNotFoundError, fc, label='Bananas')\n        self.assertRaises(ControlNotFoundError, fc, label='title')\n        self.assertEqual(fc(label='Book', nr=0).id, 'form.title')\n        self.assertEqual(fc(label='Book', nr=1).id, 'form.quality')\n        self.assertRaises(AmbiguityError, fc, label='Book')\n    \nFormTests().test_find_control()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass FormTests(unittest.TestCase):\n    def test_find_nameless_control(self):\n        data = \"\"\"<form>\n      <input type=\"checkbox\"/>\n      <input type=\"checkbox\" id=\"a\" onclick=\"blah()\"/>\n    </form>\n    \"\"\"\n        f = BytesIO(data)\n        form = parse_file(f, 'http://example.com/', backwards_compat=False)[0]\n        self.assertRaises(AmbiguityError, form.find_control, type='checkbox',\n            name=mechanize.Missing)\n        ctl = form.find_control(type='checkbox', name=mechanize.Missing, nr=1)\n        self.assertEqual(ctl.id, 'a')\n    \nFormTests().test_find_nameless_control()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass FormTests(unittest.TestCase):\n    def test_deselect_disabled(self):\n    \n        def get_new_form(f, compat):\n            f.seek(0)\n            form = parse_file(f, 'http://example.com/', backwards_compat=False)[0]\n            form.backwards_compat = compat\n            return form\n        f = BytesIO(\n            \"\"\"<form>\n        <input type=\"checkbox\" name=\"p\" value=\"a\" disabled checked></input>\n        <input type=\"checkbox\" name=\"p\" value=\"b\"></input>\n        <input type=\"checkbox\" name=\"p\" value=\"c\"></input>\n    </form>\n    \"\"\"\n            )\n        for compat in [False]:\n    \n            def new_form(compat=compat, f=f, get_new_form=get_new_form):\n                form = get_new_form(f, compat)\n                ctl = form.find_control('p')\n                a = ctl.get('a')\n                return ctl, a\n            ctl, a = new_form()\n            ctl.value = ['b']\n            if compat:\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', True)\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a'])\n                a.selected = False\n                ctl, a = new_form()\n                ctl.value = ['b']\n                self.assertEqual(a.selected, False)\n                self.assertEqual(ctl.value, ['b'])\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a', 'b']\n                    )\n            else:\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', True)\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a'])\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', False)\n                ctl.value = ['b']\n                self.assertEqual(a.selected, True)\n                self.assertEqual(ctl.value, ['b'])\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a', 'b']\n                    )\n        f = BytesIO(\n            \"\"\"<form>\n        <input type=\"radio\" name=\"p\" value=\"a\" disabled checked></input>\n        <input type=\"radio\" name=\"p\" value=\"b\"></input>\n        <input type=\"radio\" name=\"p\" value=\"c\"></input>\n    </form>\n    \"\"\"\n            )\n        for compat in [False]:\n    \n            def new_form(compat=compat, f=f, get_new_form=get_new_form):\n                form = get_new_form(f, compat)\n                ctl = form.find_control('p')\n                a = ctl.get('a')\n                return ctl, a\n            ctl, a = new_form()\n            ctl.value = ['b']\n            if compat:\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', True)\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a'])\n                a.selected = False\n                ctl, a = new_form()\n                ctl.value = ['b']\n                self.assertEqual(a.selected, False)\n                self.assertEqual(ctl.value, ['b'])\n                ctl, a = new_form()\n                self.assertRaises(ItemCountError, setattr, ctl, 'value', ['a', 'b']\n                    )\n            else:\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', True)\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, ctl, 'value', ['a'])\n                ctl, a = new_form()\n                self.assertRaises(AttributeError, setattr, a, 'selected', False)\n                ctl.value = ['b']\n                self.assertEqual(a.selected, False)\n                self.assertEqual(ctl.value, ['b'])\n                ctl, a = new_form()\n                self.assertRaises(ItemCountError, setattr, ctl, 'value', ['a', 'b']\n                    )\n    \nFormTests().test_deselect_disabled()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass FormTests(unittest.TestCase):\n    def test_click(self):\n        file = BytesIO(\n            \"\"\"<form action=\"abc\" name=\"myform\">\n    \n    <input type=\"submit\" name=\"foo\"></input>\n    <input type=\"submit\" name=\"bar\"></input>\n    </form>\n    \"\"\"\n            )\n        form = parse_file(file, 'http://blah/', backwards_compat=False)[0]\n        self.assertRaises(ControlNotFoundError, form.click, nr=2)\n        self.assertTrue(form.click().get_full_url() == 'http://blah/abc?foo=')\n        self.assertTrue(form.click(name='bar').get_full_url() ==\n            'http://blah/abc?bar=')\n        for method in ['GET', 'POST']:\n            file = BytesIO(\n                \"\"\"<form method=\"%s\" action=\"abc?bang=whizz#doh\" name=\"myform\">\n    \n    <input type=\"submit\" name=\"foo\"></input>\n    </form>\n    \"\"\"\n                 % method)\n            form = parse_file(file, 'http://blah/', backwards_compat=False)[0]\n            if method == 'GET':\n                url = 'http://blah/abc?foo='\n            else:\n                url = 'http://blah/abc?bang=whizz'\n            self.assertTrue(form.click().get_full_url() == url)\n    \nFormTests().test_click()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef hide_deprecations():\n    warnings.filterwarnings('ignore', category=DeprecationWarning)\nclass FormTests(unittest.TestCase):\n    def testSetValueByLabelIgnoringAmbiguity(self):\n        f = BytesIO(\n            \"\"\"<form>\n        <select multiple name=\"form.grocery\">\n            <option value=\"bread\" id=\"1\">Loaf of Bread</option>\n            <option value=\"bread\" id=\"2\">Loaf of Bread</option>\n            <option value=\"challah\">Loaf of Challah</option>\n        </select>\n        <input type=\"submit\" value=\"Submit\" />\n    </form>\n    \"\"\"\n            )\n        for kwds, backwards_compat in [({'backwards_compat': False}, False)]:\n            hide_deprecations()\n            form = parse_file(f, 'http://localhost/', **kwds)[0]\n            reset_deprecations()\n            f.seek(0)\n            c = form.find_control('form.grocery')\n            c.set_value_by_label(['Loaf of Bread', 'Loaf of Bread',\n                'Loaf of Challah'])\n            if backwards_compat:\n                self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n                    'Loaf of Challah'])\n                self.assertEqual([item.id for item in c.items if item.selected],\n                    ['1', None])\n                c.get(label='Loaf of Challah').disabled = True\n                self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n                    'Loaf of Challah'])\n            else:\n                self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n                    'Loaf of Bread', 'Loaf of Challah'])\n                self.assertEqual([item.id for item in c.items if item.selected],\n                    ['1', '2', None])\n                c.get(label='Challah').disabled = True\n                self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n                    'Loaf of Bread'])\nFormTests().testSetValueByLabelIgnoringAmbiguity()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef hide_deprecations():\n    warnings.filterwarnings('ignore', category=DeprecationWarning)\nclass FormTests(unittest.TestCase):\n    def testClearValue(self):\n        f = BytesIO(\n            \"\"\"<form>\n        <select multiple name=\"s\">\n            <option disabled selected>a</option>\n            <option selected>b</option>\n        </select>\n    </form>\n    \"\"\"\n            )\n        for kwds, backwards_compat in [({'backwards_compat': False}, False)]:\n            hide_deprecations()\n            form = parse_file(f, 'http://localhost/', **kwds)[0]\n            reset_deprecations()\n            f.seek(0)\n            cc = form.find_control('s')\n            if backwards_compat:\n                self.assertEqual(cc.value, ['a', 'b'])\n                cc.value = []\n                self.assertEqual([ii.name for ii in cc.items if ii.selected], [])\n            else:\n                self.assertEqual(cc.value, ['b'])\n                cc.value = []\n                self.assertEqual([ii.name for ii in cc.items if ii.selected], ['a']\n                    )\nFormTests().testClearValue()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef raise_deprecations():\n    try:\n        registry = _form.__warningregistry__\n    except AttributeError:\n        pass\n    else:\n        registry.clear()\n    warnings.filterwarnings('error', category=DeprecationWarning)\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\nclass FormTests(unittest.TestCase):\n    def testSearchByLabel(self):\n        f = BytesIO(\n            \"\"\"<form>\n    <table>\n      <tr>\n        <td><label for=\"form.title\">Book Title</label></td>\n        <td><input type=\"text\" id=\"form.title\" name=\"form.title\"\n                   value=\"The Grapes of Wrath\" /></tr>\n      </tr>\n      <tr>\n        <td>Quality</td>\n        <td>\n          <div>\n            <label><input type=\"radio\" id=\"form.quality.good\" name=\"form.quality\"\n                          value=\"good\" /> Good</label>\n          </div><div>\n            <label><input type=\"radio\" id=\"form.quality.indifferent\"\n                          name=\"form.quality\" value=\"indifferent\" />\n              Indifferent</label>\n          </div><div>\n            <label><input type=\"radio\" id=\"form.quality.bad\" name=\"form.quality\"\n                          value=\"bad\" /> Bad</label>\n          </div>\n        </td>\n      </tr>\n      <tr>\n        <td><label for=\"form.country\" blah=\"foo\">Country of Origin</label></td>\n        <td>\n          <select id=\"form.country\" name=\"form.country\">\n            <option value=\"albania\">Albania</option>\n            <optgroup label=\"European Union\">\n              <option label=\"GB\" value=\"EU: Great Britain\">Great Britain</option>\n            </optgroup>\n            <option value=\"USA\">United States of America</option>\n            <option value=\"zimbabwe\">Zimbabwe</option>\n          </select>\n        </td>\n      </tr>\n      <tr>\n        <td>Genre</label></td>\n        <td>\n          <div>\n            <label><input type=\"checkbox\" id=\"form.genre.western\" name=\"form.genre\"\n                          value=\"western\" /> Western</label>\n          </div><div>\n            <label><input type=\"checkbox\" id=\"form.genre.sciencefiction\"\n                          name=\"form.genre\" value=\"scifi\" />\n              Science Fiction</label>\n          </div><div>\n            <label><input type=\"checkbox\" id=\"form.genre.horror\" name=\"form.genre\"\n                          value=\"horror\" /> Horror</label>\n          </div>\n        </td>\n      </tr>\n      <tr>\n        <td><label for=\"form.password\">Password</label></td>\n        <td><input type=\"text\" id=\"form.password\" name=\"form.password\"\n                   value=\"123\" /></tr>\n      </tr>\n      <tr>\n        <td>In this grocery list of requested food items, mark the items you intend\n            to purchase:\n        </td>\n        <td>\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"1\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"2\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"3\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"challah\"/>\n            Loaf of Challah</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"eggs\"/>\n            Dozen Eggs</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"milk\"/>\n            Half-Gallon of Milk</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"milk\"/>\n            Half-Gallon of Milk</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>\n        </td>\n    </table>\n    <input type=\"submit\" value=\"Submit\" />\n    </form>\n    \"\"\"\n            )\n        form = parse_file(f, 'http://localhost/', backwards_compat=False)[0]\n        self.assertEqual(form.find_control(label='Title').value,\n            'The Grapes of Wrath')\n        self.assertEqual(form.find_control(label='Submit').value, 'Submit')\n        self.assertEqual(form.find_control(label='Country').get(label='Britain'\n            ).name, 'EU: Great Britain')\n        self.assertEqual(form.find_control(label='Origin').get(label='GB').name,\n            'EU: Great Britain')\n        self.assertEqual(form.find_control(label='Password').value, '123')\n        self.assertEqual(form.find_control(label='Title').value,\n            'The Grapes of Wrath')\n        c = form.find_control('form.grocery')\n        self.assertRaises(mechanize.AmbiguityError, c.get, label='Loaf')\n        self.assertRaises(mechanize.AmbiguityError, c.set_value_by_label, ['Loaf'])\n        c.set_value_by_label(['Loaf of Bread'])\n        self.assertEqual(c.get_value_by_label(), ['Loaf of Bread'])\n        c.set_value_by_label(['Loaf of Bread', 'Loaf of Bread', 'Loaf of Challah'])\n        self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n            'Loaf of Bread', 'Loaf of Challah'])\n        self.assertRaises(mechanize.AmbiguityError, c.get, label='Loaf of Bread')\n        self.assertEqual(c.get(label='Loaf of Bread', nr=0).selected, True)\n        self.assertEqual(c.get(label='Loaf of Bread', nr=1).selected, True)\n        self.assertEqual(c.get(label='Loaf of Bread', nr=2).selected, False)\n        self.assertEqual(c.get(label='Loaf of Challah').selected, True)\n        self.assertEqual([i.selected for i in c.get_items(label='Loaf of Bread'\n            )], [True, True, False])\n        self.assertEqual([i.selected for i in c.get_items(label=\n            'Loaf of Challah')], [True])\n        self.assertEqual([i.name for i in c.get_items(label='Loaf')], ['bread',\n            'bread', 'bread', 'challah'])\n        self.assertEqual([i.get_labels()[0].text for i in c.get_items('bread')],\n            ['Loaf of Bread', 'Loaf of Bread', 'Loaf of Bread'])\n        try:\n            for c, f in ((form.find_control('form.genre'), 'western'), (form.\n                find_control('form.country'), 'zimbabwe'), (form.find_control(\n                'form.quality'), 'good')):\n                raise_deprecations()\n                try:\n                    c.possible_items()\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.toggle_single()\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.set_single(True)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.toggle(f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.get_item_disabled(f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.set_item_disabled(True, f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.get_item_attrs(True, f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n        finally:\n            reset_deprecations()\nFormTests().testSearchByLabel()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass MoreFormTests(unittest.TestCase):\n    def test_interspersed_controls(self):\n        f = BytesIO(\n            \"\"\"<form name=\"formname\">\n        <input type=\"checkbox\" name=\"murphy\" value=\"a\"></input>\n        <input type=\"checkbox\" name=\"woof\" value=\"d\"></input>\n        <input type=\"checkbox\" name=\"murphy\" value=\"b\"></input>\n        <input type=\"checkbox\" name=\"murphy\" value=\"c\"></input>\n        <input type=\"submit\"></input>\n    </form>\n    \"\"\"\n            )\n        form = parse_file(f, 'http://blah/', backwards_compat=False)[0]\n        form['murphy'] = ['a', 'b', 'c']\n        form['woof'] = ['d']\n        self.assertEqual(form.click_pairs(), [('murphy', 'a'), ('woof', 'd'), (\n            'murphy', 'b'), ('murphy', 'c')])\n        form.method = 'POST'\n        form.enctype = 'multipart/form-data'\n        lines = [line for line in form.click_request_data()[1].split(b'\\r\\n') if\n            line and not line.startswith(b'--')]\n        self.assertEqual(lines, [\n            b'Content-Disposition: form-data; name=\"murphy\"', b'a',\n            b'Content-Disposition: form-data; name=\"woof\"', b'd',\n            b'Content-Disposition: form-data; name=\"murphy\"', b'b',\n            b'Content-Disposition: form-data; name=\"murphy\"', b'c'])\n    \nMoreFormTests().test_interspersed_controls()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass MoreFormTests(unittest.TestCase):\n    def test_label_whitespace(self):\n        f = BytesIO(\n            \"\"\"<form>\n    <select multiple name=\"eg\">\n        <option value=\"p\"> a b  c  </option>\n        <option value=\"q\">b</option>\n    </select>\n    </form>\n    \"\"\"\n            )\n        form = parse_file(f, 'http://example.com/')[0]\n        ctl = form.find_control('eg')\n        p = ctl.get('p')\n        q = ctl.get('q')\n        self.assertEqual(p.get_labels()[0].text, 'a b c')\n        self.assertEqual(q.get_labels()[0].text, 'b')\n    \nMoreFormTests().test_label_whitespace()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass MoreFormTests(unittest.TestCase):\n    def test_nameless_list_control(self):\n        for data in [\n            \"\"\"<form>\n      <input type=\"checkbox\" name=\"foo\"/>\n      <input type=\"checkbox\" name=\"bar\"/>\n      <input type=\"checkbox\" id=\"a\" onclick=\"bar()\" checked />\n    </form>\n    \"\"\"\n            ,\n            \"\"\"<form>\n      <input type=\"checkbox\" name=\"foo\"/>\n      <input type=\"checkbox\" id=\"a\" onclick=\"bar()\" checked />\n    </form>\n    \"\"\"\n            ,\n            \"\"\"<form>\n      <input type=\"checkbox\"/>\n      <input type=\"checkbox\"/>\n      <input type=\"checkbox\" id=\"a\" onclick=\"bar()\" checked />\n    </form>\n    \"\"\"\n            ]:\n            f = BytesIO(data)\n            form = parse_file(f, 'http://example.com/', backwards_compat=False)[0]\n            bar = form.find_control(type='checkbox', id='a')\n            self.assertEqual([item.name for item in bar.items], ['on'])\n            self.assertEqual(bar.value, [])\n            self.assertEqual(form.click_pairs(), [])\n    \nMoreFormTests().test_nameless_list_control()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass MoreFormTests(unittest.TestCase):\n    def test_action_with_fragment(self):\n        for method in ['GET', 'POST']:\n            data = (\n                '<form action=\"\" method=\"%s\"><input type=\"submit\" name=\"s\"/></form>'\n                 % method)\n            f = BytesIO(data)\n            form = parse_file(f, 'http://example.com/', backwards_compat=False)[0]\n            self.assertEqual(form.click().get_full_url(), 'http://example.com/' +\n                (method == 'GET' and '?s=' or ''))\n    \nMoreFormTests().test_action_with_fragment()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}, {"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass UploadTests(_testcase.TestCase):\n    def test_empty_upload(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<html>\n    <form method=\"POST\" action=\"./weird.html\" enctype=\"multipart/form-data\">\n    <input type=\"submit\" name=\"submit\"></input>\n    </form></html>\"\"\"\n            ), '.', backwards_compat=False)\n        form = forms[0]\n        data = form.click().get_data()\n        lines = data.split(b'\\r\\n')\n        self.assertTrue(lines[0].startswith(b'--'))\n        self.assertEqual(lines[1], b'Content-Disposition: form-data; name=\"submit\"'\n            )\n        self.assertEqual(lines[2], b'')\n        self.assertEqual(lines[3], b'')\n        self.assertTrue(lines[4].startswith(b'--'))\n    \nUploadTests().test_empty_upload()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}], "instruction": "Functionality: The BytesIO function is a wrapper that provides a file-like object to read and write binary data in memory. It is particularly useful when dealing with small to medium-sized data that does not require the overhead of disk I/O or when simulating file operations in memory.\n\nInputs: The function accepts a single argument 'x', which is optional and by default is an empty byte string (b''). 'x' should be a byte string or a string that will be encoded to bytes using UTF-8 encoding.\n\nOutputs: The function returns an instance of the io.BytesIO class, which can be used like a file object for reading and writing binary data. The returned object can be used in various operations such as writing data using the write() method and reading data using the read() method.", "method_code_mask": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\n\ndef parse_file_ex(file, base_uri, select_default=False, request_class=\n    mechanize.Request, encoding=None, backwards_compat=False, add_global=True):\n    raw = file.read()\n    root = content_parser(raw, transport_encoding=encoding)\n    form_encoding = find_declared_encoding(raw) or encoding\n    forms, global_form = _form.parse_forms(root, base_uri, select_default=\n        select_default, request_class=request_class, encoding=form_encoding)\n    if not add_global:\n        return list(forms)\n    return [global_form] + list(forms)\n\n\nparse_file = partial(parse_file_ex, add_global=False)\n\n\nclass UploadTests(_testcase.TestCase):\n\n    def setUp(self):\n        _testcase.TestCase.setUp(self)\n        import mechanize._form_controls as fc\n\n        def mock_choose_boundary():\n            self.boundary_count += 1\n            return str(self.boundary_count)\n        self.choose_boundary = fc.choose_boundary\n        fc.choose_boundary = mock_choose_boundary\n        self.boundary_count = 0\n\n    def tearDown(self):\n        import mechanize._form_controls as fc\n        fc.choose_boundary = self.choose_boundary\n        _testcase.TestCase.tearDown(self)\n\n    def test_choose_boundary(self):\n        bndy = _form_controls.choose_boundary()\n        ii = bndy.find('.')\n        self.assertTrue(ii < 0)\n\n    def make_form(self):\n        html = \"\"\"<form action=\"/cgi-bin/upload.cgi\" method=\"POST\" enctype=\"multipart/form-data\">\n<input type=\"file\" name=\"data\">\n<input type=\"text\" name=\"user\" value=\"nobody\">\n<br>\n<input type=\"submit\">\n</form>\n\"\"\"\n        return parse_file(BytesIO(html),\n            'http://localhost/cgi-bin/upload.cgi', backwards_compat=False)[0]\n\n    def test_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data))\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req)\n\n    def test_file_request_with_filename(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='afilename')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req, filename='afilename')\n\n    def test_multipart_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='filenamea')\n        more_data = 'rhubarb\\nrhubarb\\n'\n        data_control.add_file(BytesIO(more_data))\n        yet_more_data = 'rheum\\nrhaponicum\\n'\n        data_control.add_file(BytesIO(yet_more_data), filename='filenamec')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        self.assertMultiLineEqual(req.get_data().decode('ascii'),\n            '--1\\r\\nContent-Disposition: form-data; name=\"data\"\\r\\nContent-Type: multipart/mixed;\\r\\n    boundary=2\\r\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamea\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nblah\\nbaz\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrhubarb\\nrhubarb\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamec\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrheum\\nrhaponicum\\n\\r\\n--2--\\r\\n\\r\\n--1\\r\\nContent-Disposition: form-data; name=\"user\"\\r\\n\\r\\njohn\\r\\n--1--\\r\\n'\n            )\n\n    def test_upload_data(self):\n        form = self.make_form()\n        data = form.click().get_data()\n        self.assertTrue(data.startswith(b'--'))\n\n    def test_empty_upload(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"./weird.html\" enctype=\"multipart/form-data\">\n<input type=\"submit\" name=\"submit\"></input>\n</form></html>\"\"\"\n            ), '.', backwards_compat=False)\n        form = forms[0]\n        data = form.click().get_data()\n        lines = data.split(b'\\r\\n')\n        self.assertTrue(lines[0].startswith(b'--'))\n        self.assertEqual(lines[1],\n            b'Content-Disposition: form-data; name=\"submit\"')\n        self.assertEqual(lines[2], b'')\n        self.assertEqual(lines[3], b'')\n        self.assertTrue(lines[4].startswith(b'--'))\n\n    def test_no_files(self):\n        self.monkey_patch(_form_controls, 'choose_boundary', lambda : '123')\n        forms = parse_file_ex(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"spam\" enctype=\"multipart/form-data\">\n<INPUT type=\"file\" name=\"spam\" />\n</form></html>\"\"\"\n            ), '.')\n        form = forms[1]\n        data = form.click().get_data()\n        self.assertEqual(data,\n            b'--123\\r\\nContent-Disposition: form-data; name=\"spam\"; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\\r\\n--123--\\r\\n'\n            )\n\n\ndef BytesIO(x=b''): [MASK]\n"}
{"method_name": "raise_deprecations", "full_method_name": "raise_deprecations", "method_path": "../srcdata/Network/mechanize/test/test_form.py", "method_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef raise_deprecations():\n    try:\n        registry = _form.__warningregistry__\n    except AttributeError:\n        pass\n    else:\n        registry.clear()\n    warnings.filterwarnings('error', category=DeprecationWarning)", "test_code_list": [{"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef reset_deprecations():\n    warnings.filterwarnings('default', category=DeprecationWarning)\ndef parse_file_ex(file, base_uri, select_default=False, request_class=\n    mechanize.Request, encoding=None, backwards_compat=False, add_global=True):\n    raw = file.read()\n    root = content_parser(raw, transport_encoding=encoding)\n    form_encoding = find_declared_encoding(raw) or encoding\n    forms, global_form = _form.parse_forms(root, base_uri, select_default=\n        select_default, request_class=request_class, encoding=form_encoding)\n    if not add_global:\n        return list(forms)\n    return [global_form] + list(forms)\nparse_file = partial(parse_file_ex, add_global=False)\ndef BytesIO(x=b''):\n    if not isinstance(x, bytes):\n        x = x.encode('utf-8')\n    return io.BytesIO(x)\nclass FormTests(unittest.TestCase):\n    def testSearchByLabel(self):\n        f = BytesIO(\n            \"\"\"<form>\n    <table>\n      <tr>\n        <td><label for=\"form.title\">Book Title</label></td>\n        <td><input type=\"text\" id=\"form.title\" name=\"form.title\"\n                   value=\"The Grapes of Wrath\" /></tr>\n      </tr>\n      <tr>\n        <td>Quality</td>\n        <td>\n          <div>\n            <label><input type=\"radio\" id=\"form.quality.good\" name=\"form.quality\"\n                          value=\"good\" /> Good</label>\n          </div><div>\n            <label><input type=\"radio\" id=\"form.quality.indifferent\"\n                          name=\"form.quality\" value=\"indifferent\" />\n              Indifferent</label>\n          </div><div>\n            <label><input type=\"radio\" id=\"form.quality.bad\" name=\"form.quality\"\n                          value=\"bad\" /> Bad</label>\n          </div>\n        </td>\n      </tr>\n      <tr>\n        <td><label for=\"form.country\" blah=\"foo\">Country of Origin</label></td>\n        <td>\n          <select id=\"form.country\" name=\"form.country\">\n            <option value=\"albania\">Albania</option>\n            <optgroup label=\"European Union\">\n              <option label=\"GB\" value=\"EU: Great Britain\">Great Britain</option>\n            </optgroup>\n            <option value=\"USA\">United States of America</option>\n            <option value=\"zimbabwe\">Zimbabwe</option>\n          </select>\n        </td>\n      </tr>\n      <tr>\n        <td>Genre</label></td>\n        <td>\n          <div>\n            <label><input type=\"checkbox\" id=\"form.genre.western\" name=\"form.genre\"\n                          value=\"western\" /> Western</label>\n          </div><div>\n            <label><input type=\"checkbox\" id=\"form.genre.sciencefiction\"\n                          name=\"form.genre\" value=\"scifi\" />\n              Science Fiction</label>\n          </div><div>\n            <label><input type=\"checkbox\" id=\"form.genre.horror\" name=\"form.genre\"\n                          value=\"horror\" /> Horror</label>\n          </div>\n        </td>\n      </tr>\n      <tr>\n        <td><label for=\"form.password\">Password</label></td>\n        <td><input type=\"text\" id=\"form.password\" name=\"form.password\"\n                   value=\"123\" /></tr>\n      </tr>\n      <tr>\n        <td>In this grocery list of requested food items, mark the items you intend\n            to purchase:\n        </td>\n        <td>\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"1\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"2\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"bread\" id=\"3\"/>\n            Loaf of Bread</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"challah\"/>\n            Loaf of Challah</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"eggs\"/>\n            Dozen Eggs</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"milk\"/>\n            Half-Gallon of Milk</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"milk\"/>\n            Half-Gallon of Milk</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>&nbsp;|\n          <label><input type=\"checkbox\" name=\"form.grocery\" value=\"diapers\"/>\n            36 30lb. Diapers</label>\n        </td>\n    </table>\n    <input type=\"submit\" value=\"Submit\" />\n    </form>\n    \"\"\"\n            )\n        form = parse_file(f, 'http://localhost/', backwards_compat=False)[0]\n        self.assertEqual(form.find_control(label='Title').value,\n            'The Grapes of Wrath')\n        self.assertEqual(form.find_control(label='Submit').value, 'Submit')\n        self.assertEqual(form.find_control(label='Country').get(label='Britain'\n            ).name, 'EU: Great Britain')\n        self.assertEqual(form.find_control(label='Origin').get(label='GB').name,\n            'EU: Great Britain')\n        self.assertEqual(form.find_control(label='Password').value, '123')\n        self.assertEqual(form.find_control(label='Title').value,\n            'The Grapes of Wrath')\n        c = form.find_control('form.grocery')\n        self.assertRaises(mechanize.AmbiguityError, c.get, label='Loaf')\n        self.assertRaises(mechanize.AmbiguityError, c.set_value_by_label, ['Loaf'])\n        c.set_value_by_label(['Loaf of Bread'])\n        self.assertEqual(c.get_value_by_label(), ['Loaf of Bread'])\n        c.set_value_by_label(['Loaf of Bread', 'Loaf of Bread', 'Loaf of Challah'])\n        self.assertEqual(c.get_value_by_label(), ['Loaf of Bread',\n            'Loaf of Bread', 'Loaf of Challah'])\n        self.assertRaises(mechanize.AmbiguityError, c.get, label='Loaf of Bread')\n        self.assertEqual(c.get(label='Loaf of Bread', nr=0).selected, True)\n        self.assertEqual(c.get(label='Loaf of Bread', nr=1).selected, True)\n        self.assertEqual(c.get(label='Loaf of Bread', nr=2).selected, False)\n        self.assertEqual(c.get(label='Loaf of Challah').selected, True)\n        self.assertEqual([i.selected for i in c.get_items(label='Loaf of Bread'\n            )], [True, True, False])\n        self.assertEqual([i.selected for i in c.get_items(label=\n            'Loaf of Challah')], [True])\n        self.assertEqual([i.name for i in c.get_items(label='Loaf')], ['bread',\n            'bread', 'bread', 'challah'])\n        self.assertEqual([i.get_labels()[0].text for i in c.get_items('bread')],\n            ['Loaf of Bread', 'Loaf of Bread', 'Loaf of Bread'])\n        try:\n            for c, f in ((form.find_control('form.genre'), 'western'), (form.\n                find_control('form.country'), 'zimbabwe'), (form.find_control(\n                'form.quality'), 'good')):\n                raise_deprecations()\n                try:\n                    c.possible_items()\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.toggle_single()\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.set_single(True)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.toggle(f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.get_item_disabled(f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.set_item_disabled(True, f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n                try:\n                    c.get_item_attrs(True, f)\n                except DeprecationWarning:\n                    pass\n                else:\n                    self.fail('deprecation failed')\n        finally:\n            reset_deprecations()\nFormTests().testSearchByLabel()", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}], "instruction": "Functionality: The raise_deprecations function is designed to reset the warning registry and filter warnings to raise DeprecationWarning exceptions. This is particularly useful for testing environments where it is necessary to ensure that deprecated features are identified and addressed.\n\nInputs: This function does not take any input arguments.\n\nOutputs: This function does not return any outputs. Its primary effect is to modify the warning registry and warning filters in the environment in which it is executed.", "method_code_mask": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\n\ndef raise_deprecations(): [MASK]\n"}
{"method_name": "choose_boundary", "full_method_name": "choose_boundary", "method_path": "../srcdata/Network/mechanize/mechanize/_form_controls.py", "method_code": "from __future__ import absolute_import\nimport random\nimport re\nimport sys\nimport warnings\nfrom io import BytesIO\nfrom mimetypes import guess_type\ndef choose_boundary():\n    \"\"\"Return a string usable as a multipart boundary.\"\"\"\n    limit = (1 << 31) - 1\n    nonce = ''.join(str(random.randint(0, limit)) for i in (0, 1, 2))\n    return '-' * 27 + nonce", "test_code_list": [{"test_code": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\nclass UploadTests(_testcase.TestCase):\n    def test_choose_boundary(self):\n        bndy = choose_boundary()\n        ii = bndy.find('.')\n        self.assertTrue(ii < 0)\n    \nUploadTests().test_choose_boundary()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_form.py"}], "instruction": "Functionality: The choose_boundary function generates a unique string that can be used as a boundary in a multipart message. This is often used in HTTP requests when sending multipart/form-data. The function creates a string that starts with 27 hyphens, followed by a 3-part nonce. Each part of the nonce is a random number between 0 and 2^31 - 1, ensuring the boundary string is unique and unlikely to conflict with any data being sent in the multipart message.\n\nInputs: None\n\nOutputs: A string that functions as a boundary for multipart messages. The string will be in the format of \"-----------------------------XXXYYYZZZ\" where XXX, YYY, and ZZZ are random numbers between 0 and 2^31 - 1.", "method_code_mask": "from __future__ import absolute_import\nimport random\nimport re\nimport sys\nimport warnings\nfrom io import BytesIO\nfrom mimetypes import guess_type\n\n\ndef choose_boundary(): [MASK]\n"}
{"method_name": "join_header_words", "full_method_name": "join_header_words", "method_path": "../srcdata/Network/mechanize/mechanize/_headersutil.py", "method_code": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\ndef join_header_words(lists):\n    \"\"\"Do the inverse of the conversion done by split_header_words.\n\n    Takes a list of lists of (key, value) pairs and produces a single header\n    value.  Attribute values are quoted if needed.\n\n    >>> join_header_words([[(\"text/plain\", None), (\"charset\", \"iso-8859/1\")]])\n    'text/plain; charset=\"iso-8859/1\"'\n    >>> join_header_words([[(            \"text/plain\", None)], [(\"charset\", \"iso-8859/1\")]])\n    'text/plain, charset=\"iso-8859/1\"'\n\n    \"\"\"\n    headers = []\n    for pairs in lists:\n        attr = []\n        for k, v in pairs:\n            if v is not None:\n                if not re.search('^\\\\w+$', v):\n                    v = join_escape_re.sub('\\\\\\\\\\\\1', v)\n                    v = '\"%s\"' % v\n                if k is None:\n                    k = v\n                else:\n                    k = '%s=%s' % (k, v)\n            attr.append(k)\n        if attr:\n            headers.append('; '.join(attr))\n    return ', '.join(headers)", "test_code_list": [{"test_code": "import mechanize._headersutil\nfrom mechanize._testcase import TestCase\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize._headersutil import join_header_words\nfrom mechanize._headersutil import split_header_words\nimport traceback\nfrom io import StringIO\nimport unittest\n\nclass HeaderTests(TestCase):\n    def test_join_header_words(self):\n        from mechanize._headersutil import join_header_words\n        assert join_header_words([[('foo', None), ('bar', 'baz'), (None, 'value')]]\n            ) == 'foo; bar=baz; value'\n        assert join_header_words([[]]) == ''\n    \nHeaderTests().test_join_header_words()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_headers.py"}, {"test_code": "import mechanize._headersutil\nfrom mechanize._testcase import TestCase\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize._headersutil import join_header_words\nfrom mechanize._headersutil import split_header_words\nimport traceback\nfrom io import StringIO\nimport unittest\n\nclass HeaderTests(TestCase):\n    def test_roundtrip(self):\n        from mechanize._headersutil import split_header_words, join_header_words\n        tests = [('foo', 'foo'), ('foo=bar', 'foo=bar'), ('   foo   ', 'foo'),\n            ('foo=', 'foo=\"\"'), ('foo=bar bar=baz', 'foo=bar; bar=baz'), (\n            'foo=bar;bar=baz', 'foo=bar; bar=baz'), ('foo bar baz',\n            'foo; bar; baz'), ('foo=\"\\\\\"\" bar=\"\\\\\\\\\"', 'foo=\"\\\\\"\"; bar=\"\\\\\\\\\"'),\n            ('foo,,,bar', 'foo, bar'), ('foo=bar,bar=baz', 'foo=bar, bar=baz'),\n            ('text/html; charset=iso-8859-1', 'text/html; charset=\"iso-8859-1\"'\n            ), ('foo=\"bar\"; port=\"80,81\"; discard, bar=baz',\n            'foo=bar; port=\"80,81\"; discard, bar=baz'), (\n            'Basic realm=\"\\\\\"foo\\\\\\\\\\\\\\\\bar\\\\\"\"',\n            'Basic; realm=\"\\\\\"foo\\\\\\\\\\\\\\\\bar\\\\\"\"')]\n        for arg, expect in tests:\n            input = split_header_words([arg])\n            res = join_header_words(input)\n            assert res == expect, \"\"\"\n    When parsing: '%s'\n    Expected:     '%s'\n    Got:          '%s'\n    Input was:    '%s'\"\"\" % (\n                arg, expect, res, input)\n    \nHeaderTests().test_roundtrip()\n", "code_start": "", "test_path": "../srcdata/Network/mechanize/test/test_headers.py"}], "instruction": "Functionality: The join_header_words function is designed to reverse the process of splitting header attributes. It takes a nested list, where each inner list represents a group of (key, value) pairs. The function's goal is to concatenate these pairs into a properly formatted header string, where attribute values are quoted if necessary to ensure proper RFC compliance.\n\nInputs: \n- A list of lists, where each inner list contains tuples. Each tuple consists of two elements: a string representing the key and a value of any type (the value could be None). If the value is not None and does not match the pattern of being only composed of word characters, it will be escaped and quoted.\n\nOutputs: \n- A string that represents the concatenated header value. The keys and values are formatted into a semicolon-separated list within each group and then combined into a comma-separated list across groups. The output string is suitable for use as a header value in HTTP or MIME environments.", "method_code_mask": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\n\n\ndef join_header_words(lists): [MASK]\n"}
