{"method_name": "to_marshallable_type", "full_method_name": "to_marshallable_type", "method_path": "../srcdata/Network/flask-restful/flask_restful/fields.py", "method_code": "from calendar import timegm\nfrom decimal import Decimal as MyDecimal\nfrom decimal import ROUND_HALF_EVEN\nfrom email.utils import formatdate\nimport six\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlunparse\nfrom flask_restful import marshal\nfrom flask import url_for\nfrom flask import request\ndef to_marshallable_type(obj):\n    \"\"\"Helper for converting an object to a dictionary only if it is not\n    dictionary already or an indexable object nor a simple type\"\"\"\n    if obj is None:\n        return None\n    if hasattr(obj, '__marshallable__'):\n        return obj.__marshallable__()\n    if hasattr(obj, '__getitem__'):\n        return obj\n    return dict(obj.__dict__)", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\n\nclass FieldsTestCase(unittest.TestCase):\n    def test_to_dict(self):\n        obj = {'hey': 3}\n        self.assertEqual(obj, to_marshallable_type(obj))\n    \nFieldsTestCase().test_to_dict()\n", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}, {"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\nclass Foo(object):\n\n    def __init__(self):\n        self.hey = 3\nclass FieldsTestCase(unittest.TestCase):\n    def test_to_dict_obj(self):\n        obj = {'hey': 3}\n        self.assertEqual(obj, to_marshallable_type(Foo()))\nFieldsTestCase().test_to_dict_obj()", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}, {"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\nclass Bar(object):\n\n    def __marshallable__(self):\n        return {'hey': 3}\nclass FieldsTestCase(unittest.TestCase):\n    def test_to_dict_custom_marshal(self):\n        obj = {'hey': 3}\n        self.assertEqual(obj, to_marshallable_type(Bar()))\nFieldsTestCase().test_to_dict_custom_marshal()", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}], "instruction": "Functionality: The to_marshallable_type function is designed to convert an object to a dictionary format if the object is not already a dictionary, an indexable object, or a simple type. This is particularly useful for preparing objects to be serialized, such as when sending data over a network or storing it in a file.\n\nInputs: \n- obj: The input object that needs to be converted to a dictionary format. This object can be of any type, including custom objects, simple types (like int, float, str), or collections (like list, dict).\n\nOutputs: \n- If the input object is None, the function returns None.\n- If the object has a '__marshallable__' attribute, it calls this attribute's method and returns the result, which is expected to return a dictionary.\n- If the object supports the '__getitem__' method, which is typical for indexable objects like lists or dictionaries, it is returned as is, assuming it is already in a suitable format.\n- For all other objects, the function attempts to convert the object's attributes into a dictionary format by calling dict(obj.__dict__) and returns this dictionary.", "method_code_mask": "from calendar import timegm\nfrom decimal import Decimal as MyDecimal\nfrom decimal import ROUND_HALF_EVEN\nfrom email.utils import formatdate\nimport six\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlunparse\nfrom flask_restful import marshal\nfrom flask import url_for\nfrom flask import request\n\n\ndef to_marshallable_type(obj): [MASK]\n"}
{"method_name": "get_value", "full_method_name": "get_value", "method_path": "../srcdata/Network/flask-restful/flask_restful/fields.py", "method_code": "from calendar import timegm\nfrom decimal import Decimal as MyDecimal\nfrom decimal import ROUND_HALF_EVEN\nfrom email.utils import formatdate\nimport six\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlunparse\nfrom flask_restful import marshal\nfrom flask import url_for\nfrom flask import request\ndef is_indexable_but_not_string(obj):\n    return not hasattr(obj, 'strip') and hasattr(obj, '__iter__')\ndef _get_value_for_key(key, obj, default):\n    if is_indexable_but_not_string(obj):\n        try:\n            return obj[key]\n        except (IndexError, TypeError, KeyError):\n            pass\n    return getattr(obj, key, default)\ndef _get_value_for_keys(keys, obj, default):\n    if len(keys) == 1:\n        return _get_value_for_key(keys[0], obj, default)\n    else:\n        return _get_value_for_keys(keys[1:], _get_value_for_key(keys[0],\n            obj, default), default)\ndef get_value(key, obj, default=None):\n    \"\"\"Helper for pulling a keyed value off various types of objects\"\"\"\n    if isinstance(key, int):\n        return _get_value_for_key(key, obj, default)\n    elif callable(key):\n        return key(obj)\n    else:\n        return _get_value_for_keys(key.split('.'), obj, default)", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\n\nclass FieldsTestCase(unittest.TestCase):\n    def test_get_value(self):\n        self.assertEqual(3, get_value('hey', {'hey': 3}))\n    \nFieldsTestCase().test_get_value()\n", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}, {"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\n\nclass FieldsTestCase(unittest.TestCase):\n    def test_get_value_no_value(self):\n        self.assertEqual(None, get_value('foo', {'hey': 3}))\n    \nFieldsTestCase().test_get_value_no_value()\n", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}, {"test_code": "from decimal import Decimal\nfrom functools import partial\nimport pytz\nimport unittest\nfrom flask_restful.fields import MarshallingException\nfrom flask_restful.utils import OrderedDict\nfrom flask_restful import fields\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom flask import Flask\nfrom flask import Blueprint\nclass Foo(object):\n\n    def __init__(self):\n        self.hey = 3\nclass FieldsTestCase(unittest.TestCase):\n    def test_get_value_obj(self):\n        self.assertEqual(3, get_value('hey', Foo()))\nFieldsTestCase().test_get_value_obj()", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_fields.py"}], "instruction": "Functionality: The get_value function is designed to extract a value from an object based on a given key. It supports various types of keys, including integers, callable functions, and strings. For string keys, it can handle nested keys by splitting the key on periods and traversing the object to retrieve the value.\n\nInputs:\n1. key: A variable that serves as the identifier for the value to retrieve. It can be an integer, a callable function, or a string representing the key or a path of nested keys (in the case of a string, keys are separated by periods).\n2. obj: The object from which to retrieve the value. This object should be indexable and may contain the value corresponding to the key.\n3. default (optional): A default value to return if the key is not found in the object. If not specified, the default is `None`.\n\nOutputs:\n1. The function returns the value associated with the key in the object, or the default value if the key is not found or if an error occurs during retrieval. If the key is callable, it will return the result of calling the function with the object as its argument.", "method_code_mask": "from calendar import timegm\nfrom decimal import Decimal as MyDecimal\nfrom decimal import ROUND_HALF_EVEN\nfrom email.utils import formatdate\nimport six\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlunparse\nfrom flask_restful import marshal\nfrom flask import url_for\nfrom flask import request\n\n\ndef is_indexable_but_not_string(obj):\n    return not hasattr(obj, 'strip') and hasattr(obj, '__iter__')\n\n\ndef _get_value_for_key(key, obj, default):\n    if is_indexable_but_not_string(obj):\n        try:\n            return obj[key]\n        except (IndexError, TypeError, KeyError):\n            pass\n    return getattr(obj, key, default)\n\n\ndef _get_value_for_keys(keys, obj, default):\n    if len(keys) == 1:\n        return _get_value_for_key(keys[0], obj, default)\n    else:\n        return _get_value_for_keys(keys[1:], _get_value_for_key(keys[0],\n            obj, default), default)\n\n\ndef get_value(key, obj, default=None): [MASK]\n"}
{"method_name": "url", "full_method_name": "url", "method_path": "../srcdata/Network/flask-restful/flask_restful/inputs.py", "method_code": "from calendar import timegm\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom email.utils import parsedate_tz\nfrom email.utils import mktime_tz\nimport re\nimport aniso8601\nimport pytz\ndef url(value):\n    \"\"\"Validate a URL.\n\n    :param string value: The URL to validate\n    :returns: The URL if valid.\n    :raises: ValueError\n    \"\"\"\n    if not url_regex.search(value):\n        message = u'{0} is not a valid URL'.format(value)\n        if url_regex.search('http://' + value):\n            message += u'. Did you mean: http://{0}'.format(value)\n        raise ValueError(message)\n    return value", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nimport unittest\nimport pytz\nimport re\nimport six\nfrom flask_restful import inputs\ndef test_urls():\n    urls = ['http://www.djangoproject.com/', 'http://localhost/',\n        'http://example.com/', 'http://www.example.com/',\n        'http://www.example.com:8000/test',\n        'http://valid-with-hyphens.com/', 'http://subdomain.example.com/',\n        'http://200.8.9.10/', 'http://200.8.9.10:8000/test',\n        'http://valid-----hyphens.com/',\n        'http://example.com?something=value',\n        'http://example.com/index.php?something=value&another=value2',\n        'http://foo:bar@example.com', 'http://foo:@example.com',\n        'http://foo:@2001:db8:85a3::8a2e:370:7334',\n        'http://foo2:qd1%r@example.com']\n    for value in urls:\n        yield assert_equal, url(value), value\n\ntest_urls()\n", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_inputs.py"}], "instruction": "Functionality: The url function is designed to validate a given URL. It checks if the provided URL is valid according to a predefined regular expression. If the URL is not valid, the function raises a ValueError with a message indicating the invalid URL and, if applicable, suggests a possible correct format by prepending 'http://'. If the URL is valid, the function returns the URL.\n\nInputs: \n- value: A string representing the URL to be validated.\n\nOutputs: \n- Returns the URL as a string if it is valid.\n- Raises a ValueError with a descriptive message if the URL is not valid.", "method_code_mask": "from calendar import timegm\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom email.utils import parsedate_tz\nfrom email.utils import mktime_tz\nimport re\nimport aniso8601\nimport pytz\n\n\ndef url(value): [MASK]\n"}
{"method_name": "iso8601interval", "full_method_name": "iso8601interval", "method_path": "../srcdata/Network/flask-restful/flask_restful/inputs.py", "method_code": "from calendar import timegm\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom email.utils import parsedate_tz\nfrom email.utils import mktime_tz\nimport re\nimport aniso8601\nimport pytz\ndef iso8601interval(value, argument='argument'):\n    \"\"\"Parses ISO 8601-formatted datetime intervals into tuples of datetimes.\n\n    Accepts both a single date(time) or a full interval using either start/end\n    or start/duration notation, with the following behavior:\n\n    - Intervals are defined as inclusive start, exclusive end\n    - Single datetimes are translated into the interval spanning the\n      largest resolution not specified in the input value, up to the day.\n    - The smallest accepted resolution is 1 second.\n    - All timezones are accepted as values; returned datetimes are\n      localized to UTC. Naive inputs and date inputs will are assumed UTC.\n\n    Examples::\n\n        \"2013-01-01\" -> datetime(2013, 1, 1), datetime(2013, 1, 2)\n        \"2013-01-01T12\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)\n        \"2013-01-01/2013-02-28\" -> datetime(2013, 1, 1), datetime(2013, 2, 28)\n        \"2013-01-01/P3D\" -> datetime(2013, 1, 1), datetime(2013, 1, 4)\n        \"2013-01-01T12:00/PT30M\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)\n        \"2013-01-01T06:00/2013-01-01T12:00\" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)\n\n    :param str value: The ISO8601 date time as a string\n    :return: Two UTC datetimes, the start and the end of the specified interval\n    :rtype: A tuple (datetime, datetime)\n    :raises: ValueError, if the interval is invalid.\n    \"\"\"\n    try:\n        start, end = _parse_interval(value)\n        if end is None:\n            end = _expand_datetime(start, value)\n        start, end = _normalize_interval(start, end, value)\n    except ValueError:\n        raise ValueError(\n            'Invalid {arg}: {value}. {arg} must be a valid ISO8601 date/time interval.'\n            .format(arg=argument, value=value))\n    return start, end", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import tzinfo\nimport unittest\nimport pytz\nimport re\nimport six\nfrom flask_restful import inputs\ndef test_isointerval():\n    intervals = [('2013-01-01T12:30:00Z/P1Y2M3DT4H5M6S', (datetime(2013, 1,\n        1, 12, 30, 0, tzinfo=pytz.utc), datetime(2014, 3, 5, 16, 35, 6,\n        tzinfo=pytz.utc))), ('2013-01-01T12:30+00:00/P2D', (datetime(2013, \n        1, 1, 12, 30, 0, tzinfo=pytz.utc), datetime(2013, 1, 3, 12, 30, 0,\n        tzinfo=pytz.utc))), ('2013-01-01T15:00/P1M', (datetime(2013, 1, 1, \n        15, 0, 0, tzinfo=pytz.utc), datetime(2013, 1, 31, 15, 0, 0, tzinfo=\n        pytz.utc))), ('2013-01-01T17:00-05:00/P2W', (datetime(2013, 1, 1, \n        22, 0, 0, tzinfo=pytz.utc), datetime(2013, 1, 15, 22, 0, 0, tzinfo=\n        pytz.utc))), ('2013-01-01/P3D', (datetime(2013, 1, 1, 0, 0, 0,\n        tzinfo=pytz.utc), datetime(2013, 1, 4, 0, 0, 0, 0, tzinfo=pytz.utc)\n        )), ('2013-01-01T12:00:00Z/2013-02-01T12:00:00Z', (datetime(2013, 1,\n        1, 12, 0, 0, tzinfo=pytz.utc), datetime(2013, 2, 1, 12, 0, 0,\n        tzinfo=pytz.utc))), ('2013-01-01/2013-06-30', (datetime(2013, 1, 1,\n        tzinfo=pytz.utc), datetime(2013, 6, 30, tzinfo=pytz.utc))), (\n        '2013-02-17T12:00:00-07:00/2013-02-28T15:00:00-07:00', (datetime(\n        2013, 2, 17, 19, 0, 0, tzinfo=pytz.utc), datetime(2013, 2, 28, 22, \n        0, 0, tzinfo=pytz.utc))), ('2013-01-01T12:30:45Z', (datetime(2013, \n        1, 1, 12, 30, 45, tzinfo=pytz.utc), datetime(2013, 1, 1, 12, 30, 46,\n        tzinfo=pytz.utc))), ('2013-01-01T12:30:45+02:00', (datetime(2013, 1,\n        1, 10, 30, 45, tzinfo=pytz.utc), datetime(2013, 1, 1, 10, 30, 46,\n        tzinfo=pytz.utc))), ('2013-01-01T12:30:45', (datetime(2013, 1, 1, \n        12, 30, 45, tzinfo=pytz.utc), datetime(2013, 1, 1, 12, 30, 46,\n        tzinfo=pytz.utc))), ('2013-01-01T12:30+00:00', (datetime(2013, 1, 1,\n        12, 30, tzinfo=pytz.utc), datetime(2013, 1, 1, 12, 31, tzinfo=pytz.\n        utc))), ('2013-01-01T12:30+04:00', (datetime(2013, 1, 1, 8, 30,\n        tzinfo=pytz.utc), datetime(2013, 1, 1, 8, 31, tzinfo=pytz.utc))), (\n        '2013-01-01T12:30', (datetime(2013, 1, 1, 12, 30, tzinfo=pytz.utc),\n        datetime(2013, 1, 1, 12, 31, tzinfo=pytz.utc))), ('2013-01-01T12Z',\n        (datetime(2013, 1, 1, 12, tzinfo=pytz.utc), datetime(2013, 1, 1, 13,\n        tzinfo=pytz.utc))), ('2013-01-01T12-07:00', (datetime(2013, 1, 1, \n        19, tzinfo=pytz.utc), datetime(2013, 1, 1, 20, tzinfo=pytz.utc))),\n        ('2013-01-01T12', (datetime(2013, 1, 1, 12, tzinfo=pytz.utc),\n        datetime(2013, 1, 1, 13, tzinfo=pytz.utc))), (\n        '2013-01-01T12:00:00.0/2013-01-01T12:30:00.000000', (datetime(2013,\n        1, 1, 12, tzinfo=pytz.utc), datetime(2013, 1, 1, 12, 30, tzinfo=\n        pytz.utc)))]\n    for value, expected in intervals:\n        yield assert_equal, iso8601interval(value), expected\n\ntest_isointerval()\n", "code_start": "", "test_path": "../srcdata/Network/flask-restful/tests/test_inputs.py"}], "instruction": "Functionality: Parses ISO 8601-formatted datetime intervals into tuples of datetimes. It supports single date(time), start/end intervals, and start/duration notation. The function normalizes all timezones to UTC and assumes naive inputs are UTC.\n\nInputs: \n- value: A string representing the ISO8601 date time or interval. This can be a single datetime or a full interval using start/end or start/duration notation.\n- argument: (Optional) A string used in error messages to specify the argument name that caused an issue. Default is 'argument'.\n\nOutputs: \n- A tuple containing two datetime objects representing the start and end of the specified interval, both localized to UTC.", "method_code_mask": "from calendar import timegm\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom email.utils import parsedate_tz\nfrom email.utils import mktime_tz\nimport re\nimport aniso8601\nimport pytz\n\n\ndef iso8601interval(value, argument='argument'): [MASK]\n"}
