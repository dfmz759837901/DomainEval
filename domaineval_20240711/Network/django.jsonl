{"method_name": "captured_output", "full_method_name": "captured_output", "method_path": "../srcdata/Network/django/django/test/utils.py", "method_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n@contextmanager\ndef captured_output(stream_name):\n    \"\"\"Return a context manager used by captured_stdout/stdin/stderr\n    that temporarily replaces the sys stream *stream_name* with a StringIO.\n\n    Note: This function and the following ``captured_std*`` are copied\n          from CPython's ``test.support`` module.\"\"\"\n    orig_stdout = getattr(sys, stream_name)\n    setattr(sys, stream_name, StringIO())\n    try:\n        yield getattr(sys, stream_name)\n    finally:\n        setattr(sys, stream_name, orig_stdout)", "test_code_list": [{"test_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef captured_stdout():\n    \"\"\"Capture the output of sys.stdout:\n\n    with captured_stdout() as stdout:\n        print(\"hello\")\n    self.assertEqual(stdout.getvalue(), \"hello\n\")\n    \"\"\"\n    return captured_output('stdout')\n\ncaptured_stdout()\n", "code_start": "", "test_path": "../srcdata/Network/django/django/test/utils.py"}, {"test_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef captured_stderr():\n    \"\"\"Capture the output of sys.stderr:\n\n    with captured_stderr() as stderr:\n        print(\"hello\", file=sys.stderr)\n    self.assertEqual(stderr.getvalue(), \"hello\n\")\n    \"\"\"\n    return captured_output('stderr')\n\ncaptured_stderr()\n", "code_start": "", "test_path": "../srcdata/Network/django/django/test/utils.py"}, {"test_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef captured_stdin():\n    \"\"\"Capture the input to sys.stdin:\n\n    with captured_stdin() as stdin:\n        stdin.write('hello\n')\n        stdin.seek(0)\n        # call test code that consumes from sys.stdin\n        captured = input()\n    self.assertEqual(captured, \"hello\")\n    \"\"\"\n    return captured_output('stdin')\n\ncaptured_stdin()\n", "code_start": "", "test_path": "../srcdata/Network/django/django/test/utils.py"}], "instruction": "with captured_output('stdout') as out:\n    print(\"Hello, World!\")\n# Now the string 'Hello, World!\\n' can be retrieved from out.getvalue()", "method_code_mask": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n\n\n@contextmanager\ndef captured_output(stream_name): [MASK]\n"}
{"method_name": "split_domain_port", "full_method_name": "split_domain_port", "method_path": "../srcdata/Network/django/django/http/request.py", "method_code": "import codecs\nimport copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import RequestDataTooBig\nfrom django.core.exceptions import TooManyFieldsSent\nfrom django.core.files import uploadhandler\nfrom django.http.multipartparser import MultiPartParser\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.multipartparser import TooManyFilesSent\nfrom django.utils.datastructures import CaseInsensitiveMapping\nfrom django.utils.datastructures import ImmutableList\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\ndef split_domain_port(host):\n    \"\"\"\n    Return a (domain, port) tuple from a given host.\n\n    Returned domain is lowercased. If the host is invalid, the domain will be\n    empty.\n    \"\"\"\n    if (match := host_validation_re.fullmatch(host.lower())):\n        domain, port = match.groups(default='')\n        return domain.removesuffix('.'), port\n    return '', ''", "test_code_list": [{"test_code": "import copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import urlencode\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.files.uploadedfile import InMemoryUploadedFile\nfrom django.core.files.uploadhandler import MemoryFileUploadHandler\nfrom django.core.handlers.wsgi import LimitedStream\nfrom django.core.handlers.wsgi import WSGIRequest\nfrom django.http import HttpHeaders\nfrom django.http import HttpRequest\nfrom django.http import RawPostDataException\nfrom django.http import UnreadablePostError\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.request import split_domain_port\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.client import BOUNDARY\nfrom django.test.client import MULTIPART_CONTENT\nfrom django.test.client import FakePayload\n\nclass HostValidationTests(SimpleTestCase):\n    def test_split_domain_port(self):\n        for host, expected in [('<invalid>', ('', '')), ('<invalid>:8080', ('',\n            '')), ('example.com 8080', ('', '')), ('example.com:invalid', ('',\n            '')), ('[::1]', ('[::1]', '')), ('[::1]:8080', ('[::1]', '8080')),\n            ('[::ffff:127.0.0.1]', ('[::ffff:127.0.0.1]', '')), (\n            '[::ffff:127.0.0.1]:8080', ('[::ffff:127.0.0.1]', '8080')), (\n            '[1851:0000:3238:DEF1:0177:0000:0000:0125]', (\n            '[1851:0000:3238:def1:0177:0000:0000:0125]', '')), (\n            '[1851:0000:3238:DEF1:0177:0000:0000:0125]:8080', (\n            '[1851:0000:3238:def1:0177:0000:0000:0125]', '8080')), ('127.0.0.1',\n            ('127.0.0.1', '')), ('127.0.0.1:8080', ('127.0.0.1', '8080')), (\n            'example.com', ('example.com', '')), ('example.com:8080', (\n            'example.com', '8080')), ('example.com.', ('example.com', '')), (\n            'example.com.:8080', ('example.com', '8080')), ('xn--n28h.test', (\n            'xn--n28h.test', '')), ('xn--n28h.test:8080', ('xn--n28h.test',\n            '8080')), ('subdomain.example.com', ('subdomain.example.com', '')),\n            ('subdomain.example.com:8080', ('subdomain.example.com', '8080'))]:\n            with self.subTest(host=host):\n                self.assertEqual(split_domain_port(host), expected)\n    \nHostValidationTests().test_split_domain_port()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/requests_tests/tests.py"}], "instruction": "Functionality: This function takes a host string as input and returns a tuple containing the domain and the port. The domain part of the returned tuple is lowercased and stripped of a trailing period if present. If the input host string is not valid, the function returns an empty string for the domain.\n\nInputs: \n- host (str): A string representing the host, which includes the domain and possibly a port.\n\nOutputs:\n- (domain, port) (tuple): A tuple where the first element is the domain (str) and the second element is the port (str). The domain is lowercased and stripped of a trailing period if present. If the input host is invalid, the domain will be an empty string.", "method_code_mask": "import codecs\nimport copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import RequestDataTooBig\nfrom django.core.exceptions import TooManyFieldsSent\nfrom django.core.files import uploadhandler\nfrom django.http.multipartparser import MultiPartParser\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.multipartparser import TooManyFilesSent\nfrom django.utils.datastructures import CaseInsensitiveMapping\nfrom django.utils.datastructures import ImmutableList\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef split_domain_port(host): [MASK]\n"}
{"method_name": "get_label_module", "full_method_name": "get_label_module", "method_path": "../srcdata/Network/django/tests/runtests.py", "method_code": "import argparse\nimport atexit\nimport copy\nimport gc\nimport multiprocessing\nimport os\nimport shutil\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport warnings\nfrom pathlib import Path\nimport django\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import connection\nfrom django.db import connections\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test.runner import get_max_test_processes\nfrom django.test.runner import parallel_type\nfrom django.test.selenium import SeleniumTestCase\nfrom django.test.selenium import SeleniumTestCaseBase\nfrom django.test.utils import NullTimeKeeper\nfrom django.test.utils import TimeKeeper\nfrom django.test.utils import get_runner\nfrom django.utils.log import DEFAULT_LOGGING\nfrom django.utils.version import PY312\nfrom multiprocessing.util import _finalizer_registry\nimport selenium\ndef get_label_module(label):\n    \"\"\"Return the top-level module part for a test label.\"\"\"\n    path = Path(label)\n    if len(path.parts) == 1:\n        return label.split('.')[0]\n    if not path.exists():\n        raise RuntimeError(f'Test label path {label} does not exist')\n    path = path.resolve()\n    rel_path = path.relative_to(RUNTESTS_DIR)\n    return rel_path.parts[0]", "test_code_list": [{"test_code": "import argparse\nimport atexit\nimport copy\nimport gc\nimport multiprocessing\nimport os\nimport shutil\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport warnings\nfrom pathlib import Path\nimport django\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import connection\nfrom django.db import connections\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test.runner import get_max_test_processes\nfrom django.test.runner import parallel_type\nfrom django.test.selenium import SeleniumTestCase\nfrom django.test.selenium import SeleniumTestCaseBase\nfrom django.test.utils import NullTimeKeeper\nfrom django.test.utils import TimeKeeper\nfrom django.test.utils import get_runner\nfrom django.utils.log import DEFAULT_LOGGING\nfrom django.utils.version import PY312\nfrom multiprocessing.util import _finalizer_registry\nimport selenium\ndef get_filtered_test_modules(\n    test_labels=None):\n    if test_labels is None:\n        test_labels = []\n    label_modules = set()\n    for label in test_labels:\n        test_module = get_label_module(label)\n        label_modules.add(test_module)\n    if 'gis_tests' in label_modules and not gis_enabled:\n        print('Aborting: A GIS database backend is required to run gis_tests.')\n        sys.exit(1)\n\n    def _module_match_label(module_name, label):\n        return module_name == label or module_name.startswith(label + '.')\n    start_label = start_at or start_after\n    for test_module in get_test_modules(gis_enabled):\n        if start_label:\n            if not _module_match_label(test_module, start_label):\n                continue\n            start_label = ''\n            if not start_at:\n                assert start_after\n                continue\n        if not test_labels or any(_module_match_label(test_module,\n            label_module) for label_module in label_modules):\n            yield test_module\n\nget_filtered_test_modules()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/runtests.py"}], "instruction": "Functionality: This function is designed to parse a given test label and return the top-level module part from it. The label can be a string representing a test module, test class, or test method. If the label is a path and exists on the file system, the function will return the first part of the relative path from a predefined RUNTESTS_DIR. If the label is just a single part without any dots or if the path does not exist, it will return the label split by the first dot.\n\nInputs: \n- label (str): A string representing a test label. This could be a simple module name (like 'tests'), a module with a class (like 'tests.MyTestClass'), or a module with a class and a method (like 'tests.MyTestClass.test_method').\n\nOutputs:\n- str: The top-level module part for the given test label. If the label is a path and exists, it returns the first part of the relative path from RUNTESTS_DIR. If the label exists as a string without path or path does not exist on the file system, it returns the part before the first dot.\n\nException:\n- RuntimeError: If the given label is a path that does not exist on the file system, the function will raise a RuntimeError with the message 'Test label path {label} does not exist'.", "method_code_mask": "import argparse\nimport atexit\nimport copy\nimport gc\nimport multiprocessing\nimport os\nimport shutil\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport warnings\nfrom pathlib import Path\nimport django\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.db import connection\nfrom django.db import connections\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test.runner import get_max_test_processes\nfrom django.test.runner import parallel_type\nfrom django.test.selenium import SeleniumTestCase\nfrom django.test.selenium import SeleniumTestCaseBase\nfrom django.test.utils import NullTimeKeeper\nfrom django.test.utils import TimeKeeper\nfrom django.test.utils import get_runner\nfrom django.utils.log import DEFAULT_LOGGING\nfrom django.utils.version import PY312\nfrom multiprocessing.util import _finalizer_registry\nimport selenium\n\n\ndef get_label_module(label): [MASK]\n"}
{"method_name": "parse_header_name", "full_method_name": "HttpHeaders.parse_header_name", "method_path": "../srcdata/Network/django/django/http/request.py", "method_code": "import codecs\nimport copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import RequestDataTooBig\nfrom django.core.exceptions import TooManyFieldsSent\nfrom django.core.files import uploadhandler\nfrom django.http.multipartparser import MultiPartParser\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.multipartparser import TooManyFilesSent\nfrom django.utils.datastructures import CaseInsensitiveMapping\nfrom django.utils.datastructures import ImmutableList\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\nclass HttpHeaders(CaseInsensitiveMapping):\n    HTTP_PREFIX = 'HTTP_'\n    UNPREFIXED_HEADERS = {'CONTENT_TYPE', 'CONTENT_LENGTH'}\n\n    def __init__(self, environ):\n        headers = {}\n        for header, value in environ.items():\n            name = self.parse_header_name(header)\n            if name:\n                headers[name] = value\n        super().__init__(headers)\n\n    def __getitem__(self, key):\n        \"\"\"Allow header lookup using underscores in place of hyphens.\"\"\"\n        return super().__getitem__(key.replace('_', '-'))\n\n    @classmethod\n    def parse_header_name(cls, header):\n        if header.startswith(cls.HTTP_PREFIX):\n            header = header.removeprefix(cls.HTTP_PREFIX)\n        elif header not in cls.UNPREFIXED_HEADERS:\n            return None\n        return header.replace('_', '-').title()\n\n    @classmethod\n    def to_wsgi_name(cls, header):\n        header = header.replace('-', '_').upper()\n        if header in cls.UNPREFIXED_HEADERS:\n            return header\n        return f'{cls.HTTP_PREFIX}{header}'\n\n    @classmethod\n    def to_asgi_name(cls, header):\n        return header.replace('-', '_').upper()\n\n    @classmethod\n    def to_wsgi_names(cls, headers):\n        return {cls.to_wsgi_name(header_name): value for header_name, value in\n            headers.items()}\n\n    @classmethod\n    def to_asgi_names(cls, headers):\n        return {cls.to_asgi_name(header_name): value for header_name, value in\n            headers.items()}", "test_code_list": [{"test_code": "import copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import urlencode\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.files.uploadedfile import InMemoryUploadedFile\nfrom django.core.files.uploadhandler import MemoryFileUploadHandler\nfrom django.core.handlers.wsgi import LimitedStream\nfrom django.core.handlers.wsgi import WSGIRequest\nfrom django.http import HttpHeaders\nfrom django.http import HttpRequest\nfrom django.http import RawPostDataException\nfrom django.http import UnreadablePostError\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.request import split_domain_port\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.client import BOUNDARY\nfrom django.test.client import MULTIPART_CONTENT\nfrom django.test.client import FakePayload\n\nclass HttpHeadersTests(SimpleTestCase):\n    def test_parse_header_name(self):\n        tests = ('PATH_INFO', None), ('HTTP_ACCEPT', 'Accept'), ('HTTP_USER_AGENT',\n            'User-Agent'), ('HTTP_X_FORWARDED_PROTO', 'X-Forwarded-Proto'), (\n            'CONTENT_TYPE', 'Content-Type'), ('CONTENT_LENGTH', 'Content-Length')\n        for header, expected in tests:\n            with self.subTest(header=header):\n                self.assertEqual(HttpHeaders.parse_header_name(header), expected)\n    \nHttpHeadersTests().test_parse_header_name()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/requests_tests/tests.py"}], "instruction": "Functionality: The HttpHeaders.parse_header_name function is responsible for processing environment (environ) headers, converting them into a standardized format suitable for use within the Django framework. It specifically addresses headers that are prefixed with 'HTTP_' or are part of the UNPREFIXED_HEADERS set, converting them to a title case format with hyphens instead of underscores.\n\nInputs: \n- header: A string representing the header to be parsed. This header comes from the environ dictionary that is part of the WSGI or ASGI request.\n\nOutputs: \n- Returns a string that represents the parsed header name, converted to a standardized format with hyphens and title case. If the header is not recognized or does not meet the criteria (i.e., does not start with 'HTTP_' and is not in UNPREFIXED_HEADERS), the function returns None.", "method_code_mask": "import codecs\nimport copy\nfrom io import BytesIO\nfrom itertools import chain\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.core.exceptions import BadRequest\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import RequestDataTooBig\nfrom django.core.exceptions import TooManyFieldsSent\nfrom django.core.files import uploadhandler\nfrom django.http.multipartparser import MultiPartParser\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.http.multipartparser import TooManyFilesSent\nfrom django.utils.datastructures import CaseInsensitiveMapping\nfrom django.utils.datastructures import ImmutableList\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\nclass HttpHeaders(CaseInsensitiveMapping):\n    HTTP_PREFIX = 'HTTP_'\n    UNPREFIXED_HEADERS = {'CONTENT_TYPE', 'CONTENT_LENGTH'}\n\n    def __init__(self, environ):\n        headers = {}\n        for header, value in environ.items():\n            name = self.parse_header_name(header)\n            if name:\n                headers[name] = value\n        super().__init__(headers)\n\n    def __getitem__(self, key):\n        \"\"\"Allow header lookup using underscores in place of hyphens.\"\"\"\n        return super().__getitem__(key.replace('_', '-'))\n\n    @classmethod\n    def parse_header_name(cls, header): [MASK]\n\n    @classmethod\n    def to_wsgi_name(cls, header):\n        header = header.replace('-', '_').upper()\n        if header in cls.UNPREFIXED_HEADERS:\n            return header\n        return f'{cls.HTTP_PREFIX}{header}'\n\n    @classmethod\n    def to_asgi_name(cls, header):\n        return header.replace('-', '_').upper()\n\n    @classmethod\n    def to_wsgi_names(cls, headers):\n        return {cls.to_wsgi_name(header_name): value for header_name, value in\n            headers.items()}\n\n    @classmethod\n    def to_asgi_names(cls, headers):\n        return {cls.to_asgi_name(header_name): value for header_name, value in\n            headers.items()}\n"}
{"method_name": "mark_safe", "full_method_name": "mark_safe", "method_path": "../srcdata/Network/django/django/utils/safestring.py", "method_code": "from functools import wraps\nfrom django.utils.functional import keep_lazy\nclass SafeData:\n    __slots__ = ()\n\n    def __html__(self):\n        \"\"\"\n        Return the html representation of a string for interoperability.\n\n        This allows other template engines to understand Django's SafeData.\n        \"\"\"\n        return self\nclass SafeString(str, SafeData):\n    \"\"\"\n    A str subclass that has been specifically marked as \"safe\" for HTML output\n    purposes.\n    \"\"\"\n    __slots__ = ()\n    def __add__(self, rhs):\n        \"\"\"\n        Concatenating a safe string with another safe bytestring or\n        safe string is safe. Otherwise, the result is no longer safe.\n        \"\"\"\n        t = super().__add__(rhs)\n        if isinstance(rhs, SafeData):\n            return SafeString(t)\n        return t\n    def __str__(self):\n        return self\n@keep_lazy(SafeString)\ndef mark_safe(s):\n    \"\"\"\n    Explicitly mark a string as safe for (HTML) output purposes. The returned\n    object can be used everywhere a string is appropriate.\n    If used on a method as a decorator, mark the returned data as safe.\n    Can be called multiple times on a single string.\n    \"\"\"\n    if hasattr(s, '__html__'):\n        return s\n    if callable(s):\n        return _safety_decorator(mark_safe, s)\n    return SafeString(s)", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_format_html(self):\n        self.assertEqual(format_html('{} {} {third} {fourth}', '< Dangerous >',\n            mark_safe('<b>safe</b>'), third='< dangerous again', fourth=\n            mark_safe('<i>safe again</i>')),\n            '&lt; Dangerous &gt; <b>safe</b> &lt; dangerous again <i>safe again</i>'\n            )\n    \nTestUtilsHtml().test_format_html()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_conditional_escape(self):\n        s = '<h1>interop</h1>'\n        self.assertEqual(conditional_escape(s), '&lt;h1&gt;interop&lt;/h1&gt;')\n        self.assertEqual(conditional_escape(mark_safe(s)), s)\n        self.assertEqual(conditional_escape(lazystr(mark_safe(s))), s)\n    \nTestUtilsHtml().test_conditional_escape()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_str(self):\n        \"\"\"\n            Calling str() on a SafeString instance doesn't lose the safe status.\n            \"\"\"\n        s = mark_safe('a&b')\n        self.assertIsInstance(str(s), type(s))\n    \nSafeStringTest().test_mark_safe_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_result_implements_dunder_html(self):\n        self.assertEqual(mark_safe('a&b').__html__(), 'a&b')\n    \nSafeStringTest().test_mark_safe_result_implements_dunder_html()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_lazy_result_implements_dunder_html(self):\n        self.assertEqual(mark_safe(lazystr('a&b')).__html__(), 'a&b')\n    \nSafeStringTest().test_mark_safe_lazy_result_implements_dunder_html()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_as_decorator(self):\n        \"\"\"\n            mark_safe used as a decorator leaves the result of a function\n            unchanged.\n            \"\"\"\n    \n        def clean_string_provider():\n            return '<html><body>dummy</body></html>'\n        self.assertEqual(mark_safe(clean_string_provider)(),\n            clean_string_provider())\n    \nSafeStringTest().test_mark_safe_as_decorator()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_decorator_does_not_affect_dunder_html(self):\n        \"\"\"\n            mark_safe doesn't affect a callable that has an __html__() method.\n            \"\"\"\n    \n    \n        class SafeStringContainer:\n    \n            def __html__(self):\n                return '<html></html>'\n        self.assertIs(mark_safe(SafeStringContainer), SafeStringContainer)\n    \nSafeStringTest().test_mark_safe_decorator_does_not_affect_dunder_html()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_decorator_does_not_affect_promises(self):\n        \"\"\"\n            mark_safe doesn't affect lazy strings (Promise objects).\n            \"\"\"\n    \n        def html_str():\n            return '<html></html>'\n        lazy_str = lazy(html_str, str)()\n        self.assertEqual(mark_safe(lazy_str), html_str())\n    \nSafeStringTest().test_mark_safe_decorator_does_not_affect_promises()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "from django.template.defaultfilters import length\nfrom django.test import SimpleTestCase\nfrom django.utils.safestring import mark_safe\n\nclass FunctionTests(SimpleTestCase):\n    def test_safestring(self):\n        self.assertEqual(length(mark_safe('1234')), 4)\n    \nFunctionTests().test_safestring()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_length.py"}], "instruction": "Functionality: The mark_safe function is designed to explicitly mark a string as safe for HTML output purposes. It can be used to indicate that a given string does not need to be escaped for HTML, meaning that it can contain HTML tags without being treated as potentially harmful input. The function supports both direct string input and can also be used as a decorator for methods that return strings.\n\nInputs: The function accepts a single argument, 's', which can be a string that needs to be marked as safe or a callable method whose return value should be marked as safe.\n\nOutputs: If 's' is a string, the function returns a SafeString object, which is a subclass of str that is marked as safe for HTML output. If 's' is a callable, the function returns a wrapped version of the callable that marks its return value as safe.", "method_code_mask": "from functools import wraps\nfrom django.utils.functional import keep_lazy\n\n\nclass SafeData:\n    __slots__ = ()\n\n    def __html__(self):\n        \"\"\"\n        Return the html representation of a string for interoperability.\n\n        This allows other template engines to understand Django's SafeData.\n        \"\"\"\n        return self\n\n\nclass SafeString(str, SafeData):\n    \"\"\"\n    A str subclass that has been specifically marked as \"safe\" for HTML output\n    purposes.\n    \"\"\"\n    __slots__ = ()\n\n    def __add__(self, rhs):\n        \"\"\"\n        Concatenating a safe string with another safe bytestring or\n        safe string is safe. Otherwise, the result is no longer safe.\n        \"\"\"\n        t = super().__add__(rhs)\n        if isinstance(rhs, SafeData):\n            return SafeString(t)\n        return t\n\n    def __str__(self):\n        return self\n\n\n@keep_lazy(SafeString)\ndef mark_safe(s): [MASK]\n"}
{"method_name": "bisect_keep_left", "full_method_name": "bisect_keep_left", "method_path": "../srcdata/Network/django/django/contrib/messages/storage/cookie.py", "method_code": "import binascii\nimport json\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.http import SimpleCookie\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\ndef bisect_keep_left(a, fn):\n    \"\"\"\n    Find the index of the first element from the start of the array that\n    verifies the given condition.\n    The function is applied from the start of the array to the pivot.\n    \"\"\"\n    lo = 0\n    hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if fn(a[:mid + 1]):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo", "test_code_list": [{"test_code": "import json\nimport random\nfrom unittest import TestCase\nfrom django.conf import settings\nfrom django.contrib.messages import constants\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.crypto import get_random_string\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\n\nclass BisectTests(TestCase):\n    def test_bisect_keep_left(self):\n        self.assertEqual(bisect_keep_left([1, 1, 1], fn=lambda arr: sum(arr) !=\n            2), 2)\n        self.assertEqual(bisect_keep_left([1, 1, 1], fn=lambda arr: sum(arr) !=\n            0), 0)\n        self.assertEqual(bisect_keep_left([], fn=lambda arr: sum(arr) != 0), 0)\n    \nBisectTests().test_bisect_keep_left()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/messages_tests/test_cookie.py"}], "instruction": "Functionality: Implement a binary search function named 'bisect_keep_left' that locates the index of the first element in the array 'a' which satisfies the condition defined by the function 'fn'. The search is conducted from the beginning of the array to the pivot. The function 'fn' is applied to each segment of the array starting from the first element up to the mid-point, inclusive.\n\nInputs: \n- a: an array of elements to search through.\n- fn: a function that takes a sub-array of 'a' as input and returns a boolean value indicating whether the condition is met.\n\nOutputs:\n- Returns the index of the first element that satisfies the condition defined by 'fn'. If no element satisfies the condition, the function should return the length of the array 'a'.", "method_code_mask": "import binascii\nimport json\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.http import SimpleCookie\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\n\n\ndef bisect_keep_left(a, fn): [MASK]\n"}
{"method_name": "bisect_keep_right", "full_method_name": "bisect_keep_right", "method_path": "../srcdata/Network/django/django/contrib/messages/storage/cookie.py", "method_code": "import binascii\nimport json\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.http import SimpleCookie\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\ndef bisect_keep_right(a, fn):\n    \"\"\"\n    Find the index of the first element from the end of the array that verifies\n    the given condition.\n    The function is applied from the pivot to the end of array.\n    \"\"\"\n    lo = 0\n    hi = len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if fn(a[mid:]):\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo", "test_code_list": [{"test_code": "import json\nimport random\nfrom unittest import TestCase\nfrom django.conf import settings\nfrom django.contrib.messages import constants\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.crypto import get_random_string\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\n\nclass BisectTests(TestCase):\n    def test_bisect_keep_right(self):\n        self.assertEqual(bisect_keep_right([1, 1, 1], fn=lambda arr: sum(arr) !=\n            2), 1)\n        self.assertEqual(bisect_keep_right([1, 1, 1, 1], fn=lambda arr: sum(arr\n            ) != 2), 2)\n        self.assertEqual(bisect_keep_right([1, 1, 1, 1, 1], fn=lambda arr: sum(\n            arr) != 1), 4)\n        self.assertEqual(bisect_keep_right([], fn=lambda arr: sum(arr) != 0), 0)\n    \nBisectTests().test_bisect_keep_right()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/messages_tests/test_cookie.py"}], "instruction": "Functionality: The function \"bisect_keep_right\" is designed to find the index of the first element from the end of a list that does not satisfy a given condition. It employs a binary search mechanism to efficiently locate the index. The function iterates from the end of the array towards the beginning, making it particularly suited for scenarios where the list is expected to have a long sequence of elements that satisfy the condition before encountering the first element that does not.\n\nInputs: \n- a: A list of elements on which the condition will be checked. The elements can be of any type that the condition function can process.\n- fn: A boolean function that takes a list as an argument and returns True if the condition is met or False otherwise. This function will be applied to sublists of \"a\" starting from either the middle or the end, depending on the current search range.\n\nOutputs:\n- An integer representing the index of the first element from the end of the list that does not satisfy the condition (as determined by the \"fn\" function). If all elements satisfy the condition, the function returns the length of the list. If the list is empty, the function returns 0.", "method_code_mask": "import binascii\nimport json\nfrom django.conf import settings\nfrom django.core import signing\nfrom django.http import SimpleCookie\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\n\n\ndef bisect_keep_right(a, fn): [MASK]\n"}
{"method_name": "make_aware", "full_method_name": "make_aware", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\ndef is_aware(value):\n    \"\"\"\n    Determine if a given datetime.datetime is aware.\n\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is not None\ndef make_aware(value, timezone=None):\n    \"\"\"Make a naive datetime.datetime in a given time zone aware.\"\"\"\n    if timezone is None:\n        timezone = get_current_timezone()\n    if is_aware(value):\n        raise ValueError('make_aware expects a naive datetime, got %s' % value)\n    return value.replace(tzinfo=timezone)", "test_code_list": [{"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nEAT = timezone.get_fixed_timezone(180)\nclass TimezoneTests(SimpleTestCase):\n    def test_make_aware(self):\n        self.assertEqual(make_aware(datetime.datetime(2011, 9, 1, 13,\n            20, 30), EAT), datetime.datetime(2011, 9, 1, 13, 20, 30, tzinfo=EAT))\n        with self.assertRaises(ValueError):\n            make_aware(datetime.datetime(2011, 9, 1, 13, 20, 30,\n                tzinfo=EAT), EAT)\nTimezoneTests().test_make_aware()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}], "instruction": "Functionality: The make_aware function is designed to convert a naive datetime object (a datetime object without timezone information) into an aware datetime object (a datetime object with timezone information). This function ensures that the datetime object is associated with the specified timezone.\n\nInputs: \n- value: A naive datetime.datetime object (without timezone information).\n- timezone: An optional argument representing the timezone to which the datetime object should be converted. If not provided, the function will use the current timezone as defined in the settings.\n\nOutputs: \n- An aware datetime.datetime object with the timezone information applied. The returned datetime object will have the tzinfo attribute set to the provided or current timezone.", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\ndef is_aware(value):\n    \"\"\"\n    Determine if a given datetime.datetime is aware.\n\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is not None\n\n\ndef make_aware(value, timezone=None): [MASK]\n"}
{"method_name": "make_aware", "full_method_name": "make_aware", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n@functools.lru_cache\ndef get_default_timezone():\n    \"\"\"\n    Return the default time zone as a tzinfo instance.\n\n    This is the time zone defined by settings.TIME_ZONE.\n    \"\"\"\n    return zoneinfo.ZoneInfo(settings.TIME_ZONE)\n_active = Local()\ndef get_current_timezone():\n    \"\"\"Return the currently active time zone as a tzinfo instance.\"\"\"\n    return getattr(_active, 'value', get_default_timezone())\ndef is_aware(value):\n    \"\"\"\n    Determine if a given datetime.datetime is aware.\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is not None\ndef make_aware(value, timezone=None):\n    \"\"\"Make a naive datetime.datetime in a given time zone aware.\"\"\"\n    if timezone is None:\n        timezone = get_current_timezone()\n    if is_aware(value):\n        raise ValueError('make_aware expects a naive datetime, got %s' % value)\n    return value.replace(tzinfo=timezone)", "test_code_list": [{"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nPARIS_ZI = zoneinfo.ZoneInfo('Europe/Paris')\nclass TimezoneTests(SimpleTestCase):\n    def test_make_aware2(self):\n        CEST = datetime.timezone(datetime.timedelta(hours=2), 'CEST')\n        self.assertEqual(make_aware(datetime.datetime(2011, 9, 1, 12,\n            20, 30), PARIS_ZI), datetime.datetime(2011, 9, 1, 12, 20, 30,\n            tzinfo=CEST))\n        with self.assertRaises(ValueError):\n            make_aware(datetime.datetime(2011, 9, 1, 12, 20, 30,\n                tzinfo=PARIS_ZI), PARIS_ZI)\nTimezoneTests().test_make_aware2()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}, {"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nUTC = datetime.timezone.utc\nPARIS_ZI = zoneinfo.ZoneInfo('Europe/Paris')\nclass TimezoneTests(SimpleTestCase):\n    def test_make_aware_zoneinfo_ambiguous(self):\n        ambiguous = datetime.datetime(2015, 10, 25, 2, 30)\n        std = make_aware(ambiguous.replace(fold=1), timezone=PARIS_ZI)\n        dst = make_aware(ambiguous, timezone=PARIS_ZI)\n        self.assertEqual(std.astimezone(UTC) - dst.astimezone(UTC), datetime.\n            timedelta(hours=1))\n        self.assertEqual(std.utcoffset(), datetime.timedelta(hours=1))\n        self.assertEqual(dst.utcoffset(), datetime.timedelta(hours=2))\nTimezoneTests().test_make_aware_zoneinfo_ambiguous()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}, {"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nUTC = datetime.timezone.utc\nPARIS_ZI = zoneinfo.ZoneInfo('Europe/Paris')\nclass TimezoneTests(SimpleTestCase):\n    def test_make_aware_zoneinfo_non_existent(self):\n        non_existent = datetime.datetime(2015, 3, 29, 2, 30)\n        std = make_aware(non_existent, PARIS_ZI)\n        dst = make_aware(non_existent.replace(fold=1), PARIS_ZI)\n        self.assertEqual(std.astimezone(UTC) - dst.astimezone(UTC), datetime.\n            timedelta(hours=1))\n        self.assertEqual(std.utcoffset(), datetime.timedelta(hours=1))\n        self.assertEqual(dst.utcoffset(), datetime.timedelta(hours=2))\nTimezoneTests().test_make_aware_zoneinfo_non_existent()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}], "instruction": "Functionality: The 'make_aware' function is designed to transform a naive datetime object into an aware datetime object by associating it with a specific timezone. This ensures that the datetime object is timezone-aware and can be accurately interpreted across different regions.\n\nInputs: \n- value: A naive datetime.datetime object that does not have timezone information attached.\n- timezone (optional): A tzinfo instance that represents the timezone to make the datetime object aware with. If not provided, it defaults to the timezone defined by settings.TIME_ZONE.\n\nOutputs:\n- An aware datetime.datetime object. This object will have the timezone information attached as specified by the 'timezone' argument. If the input datetime object is already aware, a ValueError is raised to indicate that the function expects a naive datetime object.", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\n@functools.lru_cache\ndef get_default_timezone():\n    \"\"\"\n    Return the default time zone as a tzinfo instance.\n\n    This is the time zone defined by settings.TIME_ZONE.\n    \"\"\"\n    return zoneinfo.ZoneInfo(settings.TIME_ZONE)\n\n\n_active = Local()\n\n\ndef get_current_timezone():\n    \"\"\"Return the currently active time zone as a tzinfo instance.\"\"\"\n    return getattr(_active, 'value', get_default_timezone())\n\n\ndef is_aware(value):\n    \"\"\"\n    Determine if a given datetime.datetime is aware.\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is not None\n\n\ndef make_aware(value, timezone=None): [MASK]\n"}
{"method_name": "register_lookup", "full_method_name": "register_lookup", "method_path": "../srcdata/Network/django/django/test/utils.py", "method_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n@contextmanager\ndef register_lookup(field, *lookups, lookup_name=None):\n    \"\"\"\n    Context manager to temporarily register lookups on a model field using\n    lookup_name (or the lookup's lookup_name if not provided).\n    \"\"\"\n    try:\n        for lookup in lookups:\n            field.register_lookup(lookup, lookup_name)\n        yield\n    finally:\n        for lookup in lookups:\n            field._unregister_lookup(lookup, lookup_name)", "test_code_list": [{"test_code": "import time\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom django.core.exceptions import FieldError\nfrom django.db import connection\nfrom django.db import models\nfrom django.db.models.fields.related_lookups import RelatedGreaterThan\nfrom django.db.models.lookups import EndsWith\nfrom django.db.models.lookups import StartsWith\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import register_lookup\nfrom django.utils import timezone\nclass CustomEndsWith(EndsWith):\n    lookup_name = 'ew'\nclass CustomStartsWith(StartsWith):\n    lookup_name = 'sw'\nclass Div3Transform(models.Transform):\n    lookup_name = 'div3'\n    def as_sql(self, compiler, connection):\n        lhs, lhs_params = compiler.compile(self.lhs)\n        return '(%s) %%%% 3' % lhs, lhs_params\n    def as_oracle(self, compiler, connection, **extra_context):\n        lhs, lhs_params = compiler.compile(self.lhs)\n        return 'mod(%s, 3)' % lhs, lhs_params\nclass RegisterLookupTests(SimpleTestCase):\n    def test_lookup_on_transform(self):\n        transform = Div3Transform\n        with register_lookup(Div3Transform, CustomStartsWith):\n            with register_lookup(Div3Transform, CustomEndsWith):\n                self.assertEqual(transform.get_lookups(), {'sw':\n                    CustomStartsWith, 'ew': CustomEndsWith})\n            self.assertEqual(transform.get_lookups(), {'sw': CustomStartsWith})\n        self.assertEqual(transform.get_lookups(), {})\nRegisterLookupTests().test_lookup_on_transform()", "code_start": "", "test_path": "../srcdata/Network/django/tests/custom_lookups/tests.py"}], "instruction": "Functionality: The register_lookup function is designed to temporarily register one or more lookups on a model field within a given context. It allows the lookups to be used for database queries during the context's execution and ensures their removal afterward to maintain the field's original state. This is particularly useful for testing scenarios where temporary query capabilities are needed without affecting the model's permanent configuration.\n\nInputs: \n1. field: The model field on which the lookups will be registered.\n2. *lookups: Variable number of lookup objects to be registered on the field.\n3. lookup_name: Optional. The name to register the lookup under. If not provided, the default name of the lookup will be used.\n\nOutputs: \n- The function itself does not return any value. However, within the context it manages, the field will support the registered lookups for database queries. After the context exits, the field is restored to its original state, with the registered lookups removed.", "method_code_mask": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n\n\n@contextmanager\ndef register_lookup(field, *lookups, lookup_name=None): [MASK]\n"}
{"method_name": "get_version", "full_method_name": "get_version", "method_path": "../srcdata/Network/django/django/utils/version.py", "method_code": "import datetime\nimport functools\nimport os\nimport subprocess\nimport sys\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django import VERSION as version\ndef get_version(version=None):\n    \"\"\"Return a PEP 440-compliant version number from VERSION.\"\"\"\n    version = get_complete_version(version)\n    main = get_main_version(version)\n    sub = ''\n    if version[3] == 'alpha' and version[4] == 0:\n        git_changeset = get_git_changeset()\n        if git_changeset:\n            sub = '.dev%s' % git_changeset\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}\n        sub = mapping[version[3]] + str(version[4])\n    return main + sub", "test_code_list": [{"test_code": "from unittest import skipUnless\nimport django.utils.version\nfrom django import get_version\nfrom django.test import SimpleTestCase\nfrom django.utils.version import get_complete_version\nfrom django.utils.version import get_git_changeset\nfrom django.utils.version import get_version_tuple\n\nclass VersionTests(SimpleTestCase):\n    def test_development(self):\n        get_git_changeset.cache_clear()\n        ver_tuple = 1, 4, 0, 'alpha', 0\n        ver_string = get_version(ver_tuple)\n        self.assertRegex(ver_string, '1\\\\.4(\\\\.dev[0-9]+)?')\n    \nVersionTests().test_development()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/version/tests.py"}, {"test_code": "from unittest import skipUnless\nimport django.utils.version\nfrom django import get_version\nfrom django.test import SimpleTestCase\nfrom django.utils.version import get_complete_version\nfrom django.utils.version import get_git_changeset\nfrom django.utils.version import get_version_tuple\n\nclass VersionTests(SimpleTestCase):\n    def test_releases(self):\n        tuples_to_strings = ((1, 4, 0, 'alpha', 1), '1.4a1'), ((1, 4, 0, 'beta',\n            1), '1.4b1'), ((1, 4, 0, 'rc', 1), '1.4rc1'), ((1, 4, 0, 'final', 0\n            ), '1.4'), ((1, 4, 1, 'rc', 2), '1.4.1rc2'), ((1, 4, 1, 'final', 0),\n            '1.4.1')\n        for ver_tuple, ver_string in tuples_to_strings:\n            self.assertEqual(get_version(ver_tuple), ver_string)\n    \nVersionTests().test_releases()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/version/tests.py"}], "instruction": "Functionality: The get_version function is designed to return a version string that is compliant with PEP 440 standards. This version string is derived from a given version tuple, typically representing the software's major, minor, and patch levels, as well as any pre-release information.\n\nInputs: \n   - version (optional): A tuple that contains version information. If not provided, the function uses the Django framework's version tuple. The tuple structure is (major, minor, micro, releaselevel, serial), where 'releaselevel' can be 'alpha', 'beta', 'rc' (release candidate), or 'final', and 'serial' is an integer that represents the pre-release or post-release stage.\n\nOutputs:\n   - A string: A PEP 440-compliant version string. This string includes the main version parts (major, minor, micro) and, if applicable, pre-release information and a development stage identifier (e.g., .dev followed by a git changeset hash for 'alpha' with serial 0).", "method_code_mask": "import datetime\nimport functools\nimport os\nimport subprocess\nimport sys\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django import VERSION as version\n\n\ndef get_version(version=None): [MASK]\n"}
{"method_name": "get_version_tuple", "full_method_name": "get_version_tuple", "method_path": "../srcdata/Network/django/django/utils/version.py", "method_code": "import datetime\nimport functools\nimport os\nimport subprocess\nimport sys\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django import VERSION as version\ndef get_version_tuple(version):\n    \"\"\"\n    Return a tuple of version numbers (e.g. (1, 2, 3)) from the version\n    string (e.g. '1.2.3').\n    \"\"\"\n    version_numbers = []\n    for item in version_component_re.split(version):\n        if item and item != '.':\n            try:\n                component = int(item)\n            except ValueError:\n                break\n            else:\n                version_numbers.append(component)\n    return tuple(version_numbers)", "test_code_list": [{"test_code": "from unittest import skipUnless\nimport django.utils.version\nfrom django import get_version\nfrom django.test import SimpleTestCase\nfrom django.utils.version import get_complete_version\nfrom django.utils.version import get_git_changeset\nfrom django.utils.version import get_version_tuple\n\nclass VersionTests(SimpleTestCase):\n    def test_get_version_tuple(self):\n        self.assertEqual(get_version_tuple('1.2.3'), (1, 2, 3))\n        self.assertEqual(get_version_tuple('1.2.3b2'), (1, 2, 3))\n        self.assertEqual(get_version_tuple('1.2.3b2.dev0'), (1, 2, 3))\n    \nVersionTests().test_get_version_tuple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/version/tests.py"}], "instruction": "Functionality: The get_version_tuple function is designed to parse a version string and return it as a tuple of integers representing the version numbers. It will process a version string in the format '1.2.3', '2.4.6', etc., and convert it into a tuple such as (1, 2, 3), (2, 4, 6), etc. The function will ignore any non-numeric characters present after the version numbers.\n\nInputs: \n- version: A string representing the version number (e.g., '1.2.3').\n\nOutputs:\n- A tuple of integers representing the version numbers extracted from the input string. For example, if the input version is '1.2.3', the output would be (1, 2, 3).", "method_code_mask": "import datetime\nimport functools\nimport os\nimport subprocess\nimport sys\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django import VERSION as version\n\n\ndef get_version_tuple(version): [MASK]\n"}
{"method_name": "force_str", "full_method_name": "force_str", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef force_str(s, encoding='utf-8', strings_only=False, errors='strict'):\n    \"\"\"\n    Similar to smart_str(), except that lazy instances are resolved to\n    strings, rather than kept as lazy objects.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"\n    if issubclass(type(s), str):\n        return s\n    if strings_only and is_protected_type(s):\n        return s\n    try:\n        if isinstance(s, bytes):\n            s = str(s, encoding, errors)\n        else:\n            s = str(s)\n    except UnicodeDecodeError as e:\n        raise DjangoUnicodeDecodeError(*e.args) from None\n    return s", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_str_exception(self):\n        \"\"\"\n            Broken __str__ actually raises an error.\n            \"\"\"\n    \n    \n        class MyString:\n    \n            def __str__(self):\n                return b'\\xc3\\xb6\\xc3\\xa4\\xc3\\xbc'\n        with self.assertRaises(TypeError):\n            force_str(MyString())\n    \nTestEncodingUtils().test_force_str_exception()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_str_lazy(self):\n        s = SimpleLazyObject(lambda : 'x')\n        self.assertIs(type(force_str(s)), str)\n    \nTestEncodingUtils().test_force_str_lazy()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The force_str function is designed to convert various types of input, including lazy instances, into strings. It aims to handle a wide range of input types, including bytes, and ensures that the output is a string. The function is particularly useful for scenarios where strings need to be manipulated or displayed, ensuring that all input types are converted to a consistent format.\n\nInputs: \n- s: The input to be converted to a string. This could be of any type, but common types include strings (both str and bytes), numbers, and objects with a string representation.\n- encoding (optional): The encoding to use for the conversion of bytes to string. The default is 'utf-8'.\n- strings_only (optional): A boolean flag indicating whether non-string-like objects should be left alone and not converted. Default is False.\n- errors (optional): Specifies the error handling scheme to use for encoding/decoding errors. Default is 'strict'.\n\nOutputs: \n- The function returns a string representation of the input. If the input is already a string, it returns the input as is. If the input is a bytes object or any object that can be represented as a string, it converts it to a string format based on the specified encoding and error handling. If strings_only is True, non-string-like objects are returned without conversion.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef force_str(s, encoding='utf-8', strings_only=False, errors='strict'): [MASK]\n"}
{"method_name": "force_bytes", "full_method_name": "force_bytes", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):\n    \"\"\"\n    Similar to smart_bytes, except that lazy instances are resolved to\n    strings, rather than kept as lazy objects.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"\n    if isinstance(s, bytes):\n        if encoding == 'utf-8':\n            return s\n        else:\n            return s.decode('utf-8', errors).encode(encoding, errors)\n    if strings_only and is_protected_type(s):\n        return s\n    if isinstance(s, memoryview):\n        return bytes(s)\n    return str(s).encode(encoding, errors)", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_bytes_exception(self):\n        \"\"\"\n            force_bytes knows how to convert to bytes an exception\n            containing non-ASCII characters in its args.\n            \"\"\"\n        error_msg = 'This is an exception, voil\u00e0'\n        exc = ValueError(error_msg)\n        self.assertEqual(force_bytes(exc), error_msg.encode())\n        self.assertEqual(force_bytes(exc, encoding='ascii', errors='ignore'),\n            b'This is an exception, voil')\n    \nTestEncodingUtils().test_force_bytes_exception()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_bytes_strings_only(self):\n        today = datetime.date.today()\n        self.assertEqual(force_bytes(today, strings_only=True), today)\n    \nTestEncodingUtils().test_force_bytes_strings_only()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_bytes_encoding(self):\n        error_msg = 'This is an exception, voil\u00e0'.encode()\n        result = force_bytes(error_msg, encoding='ascii', errors='ignore')\n        self.assertEqual(result, b'This is an exception, voil')\n    \nTestEncodingUtils().test_force_bytes_encoding()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_force_bytes_memory_view(self):\n        data = b'abc'\n        result = force_bytes(memoryview(data))\n        self.assertIs(type(result), bytes)\n        self.assertEqual(result, data)\n    \nTestEncodingUtils().test_force_bytes_memory_view()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The force_bytes function is designed to convert input strings to bytes format, with options for encoding, handling of non-string objects, and error handling. It ensures that lazy string instances are resolved to strings rather than kept as lazy objects. The function also provides flexibility in handling memoryview objects and deciding whether to convert non-string-like objects based on the strings_only flag.\n\nInputs: \n- s: The input string or object to be converted to bytes.\n- encoding: The encoding to use for converting the string. Default is 'utf-8'.\n- strings_only: A boolean flag indicating whether to handle only string-like objects. If True, non-string-like objects are not converted. Default is False.\n- errors: The error handling scheme to use for encoding/decoding errors. Default is 'strict'.\n\nOutputs: \n- A bytes object: The function returns the input string converted to bytes based on the provided encoding and error handling scheme. If the input is already a bytes object and the encoding is 'utf-8', it returns the input directly. If strings_only is True and the input is a protected type, the input is returned without conversion.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'): [M\n    ASK]\n"}
{"method_name": "smart_bytes", "full_method_name": "smart_bytes", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):\n    \"\"\"\n    Return a bytestring version of 's', encoded as specified in 'encoding'.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"\n    if isinstance(s, Promise):\n        return s\n    return force_bytes(s, encoding, strings_only, errors)", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_smart_bytes(self):\n    \n    \n        class Test:\n    \n            def __str__(self):\n                return '\u0160\u0110\u0106\u017d\u0107\u017e\u0161\u0111'\n        lazy_func = gettext_lazy('x')\n        self.assertIs(smart_bytes(lazy_func), lazy_func)\n        self.assertEqual(smart_bytes(Test()),\n            b'\\xc5\\xa0\\xc4\\x90\\xc4\\x86\\xc5\\xbd\\xc4\\x87\\xc5\\xbe\\xc5\\xa1\\xc4\\x91')\n        self.assertEqual(smart_bytes(1), b'1')\n        self.assertEqual(smart_bytes('foo'), b'foo')\n    \nTestEncodingUtils().test_smart_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The smart_bytes function is designed to convert a given input 's' into a bytestring, encoded according to the specified 'encoding'. This function is particularly useful for handling strings and ensuring they are in the correct byte format for various operations, such as network transmission or storage. It also includes options to handle non-string objects and to specify error handling strategies.\n\nInputs:\n- s: The input object to be converted into a bytestring. This can be a string, an object with a __str__ method, or any other object that can be converted to bytes.\n- encoding (default 'utf-8'): The encoding to use for converting the input to a bytestring. This can be any valid encoding supported by Python.\n- strings_only (default False): A boolean flag that, when set to True, will prevent the function from converting non-string-like objects. This can be useful when you only want to process strings and avoid conversion of other data types.\n- errors (default 'strict'): The error handling strategy to use when encoding 's'. The options include 'strict', 'ignore', 'replace', and any other error handling strategy supported by Python's codecs module.\n\nOutputs:\n- A bytestring representation of the input 's', encoded according to the specified 'encoding' and 'errors' parameters. If 'strings_only' is True, non-string-like objects will be returned unchanged.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef smart_bytes(s, encoding='utf-8', strings_only=False, errors='strict'): [M\n    ASK]\n"}
{"method_name": "smart_str", "full_method_name": "smart_str", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef smart_str(s, encoding='utf-8', strings_only=False, errors='strict'):\n    \"\"\"\n    Return a string representing 's'. Treat bytestrings using the 'encoding'\n    codec.\n\n    If strings_only is True, don't convert (some) non-string-like objects.\n    \"\"\"\n    if isinstance(s, Promise):\n        return s\n    return force_str(s, encoding, strings_only, errors)", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_smart_str(self):\n    \n    \n        class Test:\n    \n            def __str__(self):\n                return '\u0160\u0110\u0106\u017d\u0107\u017e\u0161\u0111'\n        lazy_func = gettext_lazy('x')\n        self.assertIs(smart_str(lazy_func), lazy_func)\n        self.assertEqual(smart_str(Test()), '\u0160\u0110\u0106\u017d\u0107\u017e\u0161\u0111')\n        self.assertEqual(smart_str(1), '1')\n        self.assertEqual(smart_str('foo'), 'foo')\n    \nTestEncodingUtils().test_smart_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The smart_str function is designed to convert input data into a string representation, specifically handling bytestrings using a specified encoding codec. It can also be configured to avoid conversion of non-string-like objects based on the strings_only parameter. This function is particularly useful in ensuring compatibility and consistent representation of data across different environments, especially when dealing with encoding issues.\n\nInputs: \n1. s (Any): The input data to be converted into a string. This could be of any type, including but not limited to strings, bytes, integers, and objects.\n2. encoding (str): The encoding codec to be used for the conversion of bytestrings. The default value is 'utf-8'.\n3. strings_only (bool): A flag that, when set to True, prevents the conversion of non-string-like objects. The default is False.\n4. errors (str): Specifies the error handling scheme to use for encoding/decoding errors. The default is 'strict'.\n\nOutputs:\n1. str: A string representation of the input 's', encoded using the specified encoding codec if necessary. Non-string inputs are returned as is if strings_only is True.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef smart_str(s, encoding='utf-8', strings_only=False, errors='strict'): [MASK]\n"}
{"method_name": "get_system_encoding", "full_method_name": "get_system_encoding", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef get_system_encoding():\n    \"\"\"\n    The encoding for the character type functions. Fallback to 'ascii' if the\n    #encoding is unsupported by Python or could not be determined. See tickets\n    #10335 and #5846.\n    \"\"\"\n    try:\n        encoding = locale.getlocale()[1] or 'ascii'\n        codecs.lookup(encoding)\n    except Exception:\n        encoding = 'ascii'\n    return encoding", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_get_default_encoding(self):\n        with mock.patch('locale.getlocale', side_effect=Exception):\n            self.assertEqual(get_system_encoding(), 'ascii')\n    \nTestEncodingUtils().test_get_default_encoding()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: This function retrieves the system's locale encoding. It aims to determine the encoding used by the system for character type functions. If the system encoding is unsupported by Python or cannot be determined, the function falls back to using 'ascii' as the encoding.\n\nInputs: There are no input arguments for this function.\n\nOutputs: The function returns a string representing the encoding. This could be the system's locale encoding if it is supported by Python, or 'ascii' as a fallback.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef get_system_encoding(): [MASK]\n"}
{"method_name": "repercent_broken_unicode", "full_method_name": "repercent_broken_unicode", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef repercent_broken_unicode(path):\n    \"\"\"\n    As per RFC 3987 Section 3.2, step three of converting a URI into an IRI,\n    repercent-encode any octet produced that is not part of a strictly legal\n    UTF-8 octet sequence.\n    \"\"\"\n    changed_parts = []\n    while True:\n        try:\n            path.decode()\n        except UnicodeDecodeError as e:\n            repercent = quote(path[e.start:e.end], safe=b\"/#%[]=:;$&()+,!?*@'~\"\n                )\n            changed_parts.append(path[:e.start] + repercent.encode())\n            path = path[e.end:]\n        else:\n            return b''.join(changed_parts) + path", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_repercent_broken_unicode_recursion_error(self):\n        data = b'\\xfc' * sys.getrecursionlimit()\n        try:\n            self.assertEqual(repercent_broken_unicode(data), b'%FC' * sys.\n                getrecursionlimit())\n        except RecursionError:\n            self.fail('Unexpected RecursionError raised.')\n    \nTestEncodingUtils().test_repercent_broken_unicode_recursion_error()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestEncodingUtils(SimpleTestCase):\n    def test_repercent_broken_unicode_small_fragments(self):\n        data = b'test\\xfctest\\xfctest\\xfc'\n        decoded_paths = []\n    \n        def mock_quote(*args, **kwargs):\n            decoded_paths.append(inspect.currentframe().f_back.f_locals['path'])\n            return quote(*args, **kwargs)\n        with mock.patch('django.utils.encoding.quote', mock_quote):\n            self.assertEqual(repercent_broken_unicode(data),\n                b'test%FCtest%FCtest%FC')\n        self.assertEqual(decoded_paths, [b'test\\xfctest\\xfctest\\xfc',\n            b'test\\xfctest\\xfc', b'test\\xfc'])\n    \nTestEncodingUtils().test_repercent_broken_unicode_small_fragments()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The repercent_broken_unicode function is designed to correct improperly encoded Unicode characters in a given path string. It adheres to RFC 3987 Section 3.2, step three, for converting a URI to an IRI, focusing on repercent-encoding any byte that is not a part of a strictly legal UTF-8 octet sequence. This function is particularly useful for ensuring that paths, especially those used in web resources, are correctly encoded to avoid issues related to invalid UTF-8 sequences.\n\nInputs: \n- path: A string representing a path. This could be a file path, a URL path, or any string that may contain improperly encoded Unicode characters.\n\nOutputs:\n- The function returns a byte string. This output is a corrected version of the input path where any incorrectly encoded Unicode characters have been repercent-encoded to ensure they are legal UTF-8 octets. This is important for the proper handling and interpretation of the path by various software systems, especially those that rely on strict UTF-8 encoding.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef repercent_broken_unicode(path): [MASK]\n"}
{"method_name": "filepath_to_uri", "full_method_name": "filepath_to_uri", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef filepath_to_uri(path):\n    \"\"\"Convert a file system path to a URI portion that is suitable for\n    inclusion in a URL.\n\n    Encode certain chars that would normally be recognized as special chars\n    for URIs. Do not encode the ' character, as it is a valid character\n    within URIs. See the encodeURIComponent() JavaScript function for details.\n    \"\"\"\n    if path is None:\n        return path\n    return quote(str(path).replace('\\\\', '/'), safe=\"/~!*()'\")", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestRFC3987IEncodingUtils(unittest.TestCase):\n    def test_filepath_to_uri(self):\n        self.assertIsNone(filepath_to_uri(None))\n        self.assertEqual(filepath_to_uri('upload\\\\\u0447\u0443\u0431\u0430\u043a\u0430.mp4'),\n            'upload/%D1%87%D1%83%D0%B1%D0%B0%D0%BA%D0%B0.mp4')\n        self.assertEqual(filepath_to_uri(Path('upload/test.png')),\n            'upload/test.png')\n        self.assertEqual(filepath_to_uri(Path('upload\\\\test.png')),\n            'upload/test.png')\n    \nTestRFC3987IEncodingUtils().test_filepath_to_uri()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The function filepath_to_uri is designed to convert a given file system path into a URI portion that can be safely included in a URL. It encodes certain characters that have special meanings in URIs, ensuring they are properly represented. The function makes sure not to encode the ' character, as it is valid within URIs. The encoding logic is similar to the encodeURIComponent() function in JavaScript.\n\nInputs: \n- path: A string representing the file system path that needs to be converted. This path may contain characters that are special in URIs and must be encoded for safe inclusion in a URL.\n\nOutputs: \n- The function returns a string that represents the encoded URI portion of the input path. If the input path is None, the function will return None without any processing. The returned string is suitable for use in URLs, having all necessary characters encoded except for the ' character.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef filepath_to_uri(path): [MASK]\n"}
{"method_name": "iri_to_uri", "full_method_name": "iri_to_uri", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef iri_to_uri(iri):\n    \"\"\"\n    Convert an Internationalized Resource Identifier (IRI) portion to a URI\n    portion that is suitable for inclusion in a URL.\n\n    This is the algorithm from RFC 3987 Section 3.1, slightly simplified since\n    the input is assumed to be a string rather than an arbitrary byte stream.\n\n    Take an IRI (string or UTF-8 bytes, e.g. '/I \u2665 Django/' or\n    b'/I \u00e2\u0099\u00a5 Django/') and return a string containing the encoded\n    result with ASCII chars only (e.g. '/I%20%E2%99%A5%20Django/').\n    \"\"\"\n    if iri is None:\n        return iri\n    elif isinstance(iri, Promise):\n        iri = str(iri)\n    return quote(iri, safe=\"/#%[]=:;$&()+,!?*@'~\")", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestRFC3987IEncodingUtils(unittest.TestCase):\n    def test_complementarity(self):\n        cases = [('/blog/for/J%C3%BCrgen%20M%C3%BCnster/',\n            '/blog/for/J\u00fcrgen%20M\u00fcnster/'), ('%&', '%&'), (\n            'red&%E2%99%A5ros%#red', 'red&\u2665ros%#red'), ('/%E2%99%A5%E2%99%A5/',\n            '/\u2665\u2665/'), ('/%E2%99%A5%E2%99%A5/?utf8=%E2%9C%93', '/\u2665\u2665/?utf8=\u2713'), (\n            '/%25%20%02%7b/', '/%25%20%02%7b/'), (\n            '/%AAd%AAj%AAa%AAn%AAg%AAo%AA/', '/%AAd%AAj%AAa%AAn%AAg%AAo%AA/'),\n            ('/%E2%99%A5%E2%E2%99%A5/', '/\u2665%E2\u2665/'), (\n            '/%E2%99%A5%E2%99%E2%99%A5/', '/\u2665%E2%99\u2665/'), (\n            '/%E2%E2%99%A5%E2%99%A5%99/', '/%E2\u2665\u2665%99/'), (\n            '/%E2%99%A5%E2%99%A5/?utf8=%9C%93%E2%9C%93%9C%93',\n            '/\u2665\u2665/?utf8=%9C%93\u2713%9C%93')]\n        for uri, iri in cases:\n            with self.subTest(uri):\n                self.assertEqual(iri_to_uri(uri_to_iri(uri)), uri)\n                self.assertEqual(uri_to_iri(iri_to_uri(iri)), iri)\n    \nTestRFC3987IEncodingUtils().test_complementarity()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: The iri_to_uri function is designed to convert an Internationalized Resource Identifier (IRI) portion to a Uniform Resource Identifier (URI) portion suitable for inclusion in a URL. This conversion is necessary when dealing with strings containing non-ASCII characters to ensure they are properly encoded for URL use.\n\nInputs: \n1. iri (string or UTF-8 bytes) - This is the IRI portion that needs to be converted to a URI. It can be a string or UTF-8 encoded bytes, e.g., '/I \u2665 Django/' or b'/I \u00e2\u0099\u00a5 Django/'.\n\nOutputs: \n1. A string containing the encoded result with only ASCII characters (the URI portion). For example, the input '/I \u2665 Django/' would be converted to '/I%20%E2%99%A5%20Django/'.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef iri_to_uri(iri): [MASK]\n"}
{"method_name": "uri_to_iri", "full_method_name": "uri_to_iri", "method_path": "../srcdata/Network/django/django/utils/encoding.py", "method_code": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\ndef uri_to_iri(uri):\n    \"\"\"\n    Convert a Uniform Resource Identifier(URI) into an Internationalized\n    Resource Identifier(IRI).\n\n    This is the algorithm from RFC 3987 Section 3.2, excluding step 4.\n\n    Take an URI in ASCII bytes (e.g. '/I%20%E2%99%A5%20Django/') and return\n    a string containing the encoded result (e.g. '/I%20\u2665%20Django/').\n    \"\"\"\n    if uri is None:\n        return uri\n    uri = force_bytes(uri)\n    bits = uri.split(b'%')\n    if len(bits) == 1:\n        iri = uri\n    else:\n        parts = [bits[0]]\n        append = parts.append\n        hextobyte = _hextobyte\n        for item in bits[1:]:\n            hex = item[:2]\n            if hex in hextobyte:\n                append(hextobyte[item[:2]])\n                append(item[2:])\n            else:\n                append(b'%')\n                append(item)\n        iri = b''.join(parts)\n    return repercent_broken_unicode(iri).decode()", "test_code_list": [{"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestRFC3987IEncodingUtils(unittest.TestCase):\n    def test_uri_to_iri(self):\n        cases = [(None, None), ('/%e2%89%Ab%E2%99%a5%E2%89%aB/', '/\u226b\u2665\u226b/'), (\n            '/%E2%99%A5%E2%99%A5/?utf8=%E2%9C%93', '/\u2665\u2665/?utf8=\u2713'), (\n            '/%41%5a%6B/', '/AZk/'), ('/%25%20%02%41%7b/', '/%25%20%02A%7b/'),\n            ('/%AAd%AAj%AAa%AAn%AAg%AAo%AA/', '/%AAd%AAj%AAa%AAn%AAg%AAo%AA/'),\n            ('/%E2%99%A5%E2%E2%99%A5/', '/\u2665%E2\u2665/'), (\n            '/%E2%99%A5%E2%99%E2%99%A5/', '/\u2665%E2%99\u2665/'), (\n            '/%E2%E2%99%A5%E2%99%A5%99/', '/%E2\u2665\u2665%99/'), (\n            '/%E2%99%A5%E2%99%A5/?utf8=%9C%93%E2%9C%93%9C%93',\n            '/\u2665\u2665/?utf8=%9C%93\u2713%9C%93')]\n        for uri, iri in cases:\n            with self.subTest(uri):\n                self.assertEqual(uri_to_iri(uri), iri)\n                self.assertEqual(uri_to_iri(uri_to_iri(uri)), iri)\n    \nTestRFC3987IEncodingUtils().test_uri_to_iri()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}, {"test_code": "import datetime\nimport inspect\nimport sys\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom urllib.parse import quote_plus\nfrom django.test import SimpleTestCase\nfrom django.utils.encoding import DjangoUnicodeDecodeError\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.encoding import filepath_to_uri\nfrom django.utils.encoding import force_bytes\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import get_system_encoding\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.encoding import repercent_broken_unicode\nfrom django.utils.encoding import smart_bytes\nfrom django.utils.encoding import smart_str\nfrom django.utils.encoding import uri_to_iri\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.translation import gettext_lazy\n\nclass TestRFC3987IEncodingUtils(unittest.TestCase):\n    def test_complementarity(self):\n        cases = [('/blog/for/J%C3%BCrgen%20M%C3%BCnster/',\n            '/blog/for/J\u00fcrgen%20M\u00fcnster/'), ('%&', '%&'), (\n            'red&%E2%99%A5ros%#red', 'red&\u2665ros%#red'), ('/%E2%99%A5%E2%99%A5/',\n            '/\u2665\u2665/'), ('/%E2%99%A5%E2%99%A5/?utf8=%E2%9C%93', '/\u2665\u2665/?utf8=\u2713'), (\n            '/%25%20%02%7b/', '/%25%20%02%7b/'), (\n            '/%AAd%AAj%AAa%AAn%AAg%AAo%AA/', '/%AAd%AAj%AAa%AAn%AAg%AAo%AA/'),\n            ('/%E2%99%A5%E2%E2%99%A5/', '/\u2665%E2\u2665/'), (\n            '/%E2%99%A5%E2%99%E2%99%A5/', '/\u2665%E2%99\u2665/'), (\n            '/%E2%E2%99%A5%E2%99%A5%99/', '/%E2\u2665\u2665%99/'), (\n            '/%E2%99%A5%E2%99%A5/?utf8=%9C%93%E2%9C%93%9C%93',\n            '/\u2665\u2665/?utf8=%9C%93\u2713%9C%93')]\n        for uri, iri in cases:\n            with self.subTest(uri):\n                self.assertEqual(iri_to_uri(uri_to_iri(uri)), uri)\n                self.assertEqual(uri_to_iri(iri_to_uri(iri)), iri)\n    \nTestRFC3987IEncodingUtils().test_complementarity()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_encoding.py"}], "instruction": "Functionality: Convert a Uniform Resource Identifier (URI) into an Internationalized Resource Identifier (IRI). This function adheres to the algorithm detailed in RFC 3987 Section 3.2, excluding step 4. It receives an URI encoded in ASCII bytes (e.g., '/I%20%E2%99%A5%20Django/') and returns a string with the decoded result (e.g., '/I%20\u2665%20Django/').\n\nInputs:\n- uri: An ASCII bytes string representing the Uniform Resource Identifier to be converted.\n\nOutputs:\n- A string representing the Internationalized Resource Identifier, which is the decoded version of the provided URI.", "method_code_mask": "import codecs\nimport datetime\nimport locale\nfrom decimal import Decimal\nfrom urllib.parse import quote\nfrom django.utils.functional import Promise\n\n\ndef uri_to_iri(uri): [MASK]\n"}
{"method_name": "pbkdf2", "full_method_name": "pbkdf2", "method_path": "../srcdata/Network/django/django/utils/crypto.py", "method_code": "import hashlib\nimport hmac\nimport secrets\nfrom django.conf import settings\nfrom django.utils.encoding import force_bytes\ndef pbkdf2(password, salt, iterations, dklen=0, digest=None):\n    \"\"\"Return the hash of password using pbkdf2.\"\"\"\n    if digest is None:\n        digest = hashlib.sha256\n    dklen = dklen or None\n    password = force_bytes(password)\n    salt = force_bytes(salt)\n    return hashlib.pbkdf2_hmac(digest().name, password, salt, iterations, dklen\n        )", "test_code_list": [{"test_code": "import hashlib\nimport unittest\nfrom django.test import SimpleTestCase\nfrom django.utils.crypto import InvalidAlgorithm\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import pbkdf2\nfrom django.utils.crypto import salted_hmac\n\nclass TestUtilsCryptoPBKDF2(unittest.TestCase):\n    def test_default_hmac_alg(self):\n        kwargs = {'password': b'password', 'salt': b'salt', 'iterations': 1,\n            'dklen': 20}\n        self.assertEqual(pbkdf2(**kwargs), hashlib.pbkdf2_hmac(hash_name=\n            hashlib.sha256().name, **kwargs))\n    \nTestUtilsCryptoPBKDF2().test_default_hmac_alg()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_crypto.py"}], "instruction": "Functionality: The function to be implemented is pbkdf2, which is used for the hash of a password using the pbkdf2 algorithm. This function takes a password and enhances its security by applying a salt and multiple iterations of a hash function, making it more resistant to brute force and dictionary attacks.\n\nInputs: \n1. password: A string representing the password to be hashed.\n2. salt: A string that is randomly generated and added to the password before hashing to prevent rainbow table attacks.\n3. iterations: An integer specifying the number of times the hash function should be applied iteratively. This increases the computational cost of hashing, thus making it harder for an attacker to generate hashes.\n4. dklen: An integer representing the desired length of the derived key. If not provided, the function will use the default length.\n5. digest: A hash function from the hashlib module. If not provided, the function will default to using hashlib.sha256.\n\nOutputs:\n1. A byte string representing the hashed password after applying the pbkdf2 algorithm with the provided parameters. The length of the output will be determined by the dklen parameter or the default length of the hash function if dklen is not specified.", "method_code_mask": "import hashlib\nimport hmac\nimport secrets\nfrom django.conf import settings\nfrom django.utils.encoding import force_bytes\n\n\ndef pbkdf2(password, salt, iterations, dklen=0, digest=None): [MASK]\n"}
{"method_name": "format", "full_method_name": "format", "method_path": "../srcdata/Network/django/django/utils/numberformat.py", "method_code": "from decimal import Decimal\nfrom django.conf import settings\nfrom django.utils.safestring import mark_safe\ndef format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep=\n    '', force_grouping=False, use_l10n=None):\n    \"\"\"\n    Get a number (as a number or string), and return it as a string,\n    using formats defined as arguments:\n\n    * decimal_sep: Decimal separator symbol (for example \".\")\n    * decimal_pos: Number of decimal positions\n    * grouping: Number of digits in every group limited by thousand separator.\n        For non-uniform digit grouping, it can be a sequence with the number\n        of digit group sizes following the format used by the Python locale\n        module in locale.localeconv() LC_NUMERIC grouping (e.g. (3, 2, 0)).\n    * thousand_sep: Thousand separator symbol (for example \",\")\n    \"\"\"\n    if number is None or number == '':\n        return mark_safe(number)\n    if use_l10n is None:\n        use_l10n = True\n    use_grouping = use_l10n and settings.USE_THOUSAND_SEPARATOR\n    use_grouping = use_grouping or force_grouping\n    use_grouping = use_grouping and grouping != 0\n    if isinstance(number, int) and not use_grouping and not decimal_pos:\n        return mark_safe(number)\n    sign = ''\n    if isinstance(number, float) and 'e' in str(number).lower():\n        number = Decimal(str(number))\n    if isinstance(number, Decimal):\n        if decimal_pos is not None:\n            cutoff = Decimal('0.' + '1'.rjust(decimal_pos, '0'))\n            if abs(number) < cutoff:\n                number = Decimal('0')\n        _, digits, exponent = number.as_tuple()\n        if abs(exponent) + len(digits) > 200:\n            number = '{:e}'.format(number)\n            coefficient, exponent = number.split('e')\n            coefficient = format(coefficient, decimal_sep, decimal_pos,\n                grouping, thousand_sep, force_grouping, use_l10n)\n            return '{}e{}'.format(coefficient, exponent)\n        else:\n            str_number = '{:f}'.format(number)\n    else:\n        str_number = str(number)\n    if str_number[0] == '-':\n        sign = '-'\n        str_number = str_number[1:]\n    if '.' in str_number:\n        int_part, dec_part = str_number.split('.')\n        if decimal_pos is not None:\n            dec_part = dec_part[:decimal_pos]\n    else:\n        int_part, dec_part = str_number, ''\n    if decimal_pos is not None:\n        dec_part += '0' * (decimal_pos - len(dec_part))\n    dec_part = dec_part and decimal_sep + dec_part\n    if use_grouping:\n        try:\n            intervals = list(grouping)\n        except TypeError:\n            intervals = [grouping, 0]\n        active_interval = intervals.pop(0)\n        int_part_gd = ''\n        cnt = 0\n        for digit in int_part[::-1]:\n            if cnt and cnt == active_interval:\n                if intervals:\n                    active_interval = intervals.pop(0) or active_interval\n                int_part_gd += thousand_sep[::-1]\n                cnt = 0\n            int_part_gd += digit\n            cnt += 1\n        int_part = int_part_gd[::-1]\n    return sign + int_part + dec_part", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom sys import float_info\nfrom django.test import SimpleTestCase\nfrom django.utils.numberformat import format as format\n\nclass TestNumberFormat(SimpleTestCase):\n    def test_empty(self):\n        self.assertEqual(format('', '.'), '')\n        self.assertEqual(format(None, '.'), 'None')\n    \nTestNumberFormat().test_empty()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_numberformat.py"}], "instruction": "Functionality: The format function is designed to convert a number (given as an integer, float, or string) into a string representation using specific formatting rules provided by the user. It supports custom decimal separators, decimal places, and grouping by thousand separators, with the ability to force grouping and apply locale-specific configurations.\n\nInputs: \n- number: The number to be formatted, which can be an integer, float, or a string.\n- decimal_sep: A string representing the decimal separator symbol (e.g., \".\").\n- decimal_pos: An optional integer indicating the number of decimal places. If not provided, the function will not adjust the decimal places.\n- grouping: An integer or a sequence indicating the number of digits in every group limited by thousand separator. If set to 0, it indicates no grouping. Default is 0.\n- thousand_sep: A string for the thousand separator symbol (e.g., \",\"). Default is an empty string.\n- force_grouping: A boolean indicating whether to force grouping even if the USE_THOUSAND_SEPARATOR setting is False. Default is False.\n- use_l10n: An optional boolean specifying whether to use locale-specific configuration for formatting. Default is None, which results in using True as the default value.\n\nOutputs:\n- A string representation of the number formatted according to the specified rules. The output is safe for HTML insertion due to the use of mark_safe from django.utils.safestring.", "method_code_mask": "from decimal import Decimal\nfrom django.conf import settings\nfrom django.utils.safestring import mark_safe\n\n\ndef format(number, decimal_sep, decimal_pos=None, grouping=0, thousand_sep=\n    '', force_grouping=False, use_l10n=None): [MASK]\n"}
{"method_name": "format", "full_method_name": "format", "method_path": "../srcdata/Network/django/django/utils/dateformat.py", "method_code": "import calendar\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom email.utils import format_datetime as format_datetime_rfc5322\nfrom django.utils.dates import MONTHS\nfrom django.utils.dates import MONTHS_3\nfrom django.utils.dates import MONTHS_ALT\nfrom django.utils.dates import MONTHS_AP\nfrom django.utils.dates import WEEKDAYS\nfrom django.utils.dates import WEEKDAYS_ABBR\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import _datetime_ambiguous_or_imaginary\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import is_naive\nfrom django.utils.timezone import make_aware\nfrom django.utils.translation import gettext as _\ndef format(value, format_string):\n    \"\"\"Convenience function\"\"\"\n    df = DateFormat(value)\n    return df.format(format_string)", "test_code_list": [{"test_code": "from datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import TZ_SUPPORT\nfrom django.test.utils import requires_tz_support\nfrom django.utils import dateformat\nfrom django.utils import translation\nfrom django.utils.dateformat import format\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.timezone import make_aware\n\nclass DateFormatTests(SimpleTestCase):\n    def test_date(self):\n        d = date(2009, 5, 16)\n        self.assertEqual(date.fromtimestamp(int(format(d, 'U'))), d)\n    \nDateFormatTests().test_date()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateformat.py"}, {"test_code": "from datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import TZ_SUPPORT\nfrom django.test.utils import requires_tz_support\nfrom django.utils import dateformat\nfrom django.utils import translation\nfrom django.utils.dateformat import format\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.timezone import make_aware\n\nclass DateFormatTests(SimpleTestCase):\n    def test_epoch(self):\n        udt = datetime(1970, 1, 1, tzinfo=timezone.utc)\n        self.assertEqual(format(udt, 'U'), '0')\n    \nDateFormatTests().test_epoch()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateformat.py"}, {"test_code": "from datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import TZ_SUPPORT\nfrom django.test.utils import requires_tz_support\nfrom django.utils import dateformat\nfrom django.utils import translation\nfrom django.utils.dateformat import format\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.timezone import make_aware\n\nclass DateFormatTests(SimpleTestCase):\n    def test_invalid_time_format_specifiers(self):\n        my_birthday = date(1984, 8, 7)\n        for specifier in ['a', 'A', 'f', 'g', 'G', 'h', 'H', 'i', 'P', 's', 'u']:\n            with self.subTest(specifier=specifier):\n                msg = (\n                    f'The format for date objects may not contain time-related format specifiers (found {specifier!r}).'\n                    )\n                with self.assertRaisesMessage(TypeError, msg):\n                    format(my_birthday, specifier)\n    \nDateFormatTests().test_invalid_time_format_specifiers()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateformat.py"}, {"test_code": "from datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import TZ_SUPPORT\nfrom django.test.utils import requires_tz_support\nfrom django.utils import dateformat\nfrom django.utils import translation\nfrom django.utils.dateformat import format\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.timezone import make_aware\n\nclass DateFormatTests(SimpleTestCase):\n    @requires_tz_support\n    def test_e_format_with_named_time_zone(self):\n        dt = datetime(1970, 1, 1, tzinfo=timezone.utc)\n        self.assertEqual(format(dt, 'e'), 'UTC')\n    \nDateFormatTests().test_e_format_with_named_time_zone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateformat.py"}, {"test_code": "from datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import TZ_SUPPORT\nfrom django.test.utils import requires_tz_support\nfrom django.utils import dateformat\nfrom django.utils import translation\nfrom django.utils.dateformat import format\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.timezone import make_aware\n\nclass DateFormatTests(SimpleTestCase):\n    def test_S_format(self):\n        for expected, days in [('st', [1, 21, 31]), ('nd', [2, 22]), ('rd', [3,\n            23]), ('th', (n for n in range(4, 31) if n not in [21, 22, 23]))]:\n            for day in days:\n                dt = date(1970, 1, day)\n                with self.subTest(day=day):\n                    self.assertEqual(format(dt, 'S'), expected)\n    \nDateFormatTests().test_S_format()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateformat.py"}], "instruction": "Functionality: The format function is designed to format dates and times according to a specified format string. It utilizes a DateFormat utility class to process the input value (date or time) and apply the format string rules to generate a human-readable string representation of the date or time.\n\nInputs: \n- value: A datetime object representing the date or time that needs to be formatted. This value can be a naive or timezone-aware datetime object.\n- format_string: A string containing formatting rules that dictate how the date or time should be represented. This string can include various tokens that represent different components of the date and time, such as the day of the month, month name, year, hours, minutes, seconds, and timezone information.\n\nOutputs:\n- A string that represents the formatted date or time according to the rules specified in the format_string. The output string will include all the components of the date and time that are specified in the format_string, in the exact format and order defined by the rules. If the input value is a naive datetime object, the output will not include timezone information. If the input value is a timezone-aware datetime object, the output may include timezone information depending on the rules in the format_string.\n\nNote: The function assumes the presence of various utility functions and classes such as DateFormat, get_default_timezone, make_aware, and others, which are not provided here. These utilities are assumed to be part of the Django framework and are used to handle time zone conversions, naive datetime objects, and other date/time operations.", "method_code_mask": "import calendar\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom email.utils import format_datetime as format_datetime_rfc5322\nfrom django.utils.dates import MONTHS\nfrom django.utils.dates import MONTHS_3\nfrom django.utils.dates import MONTHS_ALT\nfrom django.utils.dates import MONTHS_AP\nfrom django.utils.dates import WEEKDAYS\nfrom django.utils.dates import WEEKDAYS_ABBR\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import _datetime_ambiguous_or_imaginary\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import is_naive\nfrom django.utils.timezone import make_aware\nfrom django.utils.translation import gettext as _\n\n\ndef format(value, format_string): [MASK]\n"}
{"method_name": "get_fixed_timezone", "full_method_name": "get_fixed_timezone", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\ndef get_fixed_timezone(offset):\n    \"\"\"Return a tzinfo instance with a fixed offset from UTC.\"\"\"\n    if isinstance(offset, timedelta):\n        offset = offset.total_seconds() // 60\n    sign = '-' if offset < 0 else '+'\n    hhmm = '%02d%02d' % divmod(abs(offset), 60)\n    name = sign + hhmm\n    return timezone(timedelta(minutes=offset), name)", "test_code_list": [{"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc2822_date_with_timezone(self):\n        \"\"\"\n            rfc2822_date() correctly formats datetime objects with tzinfo.\n            \"\"\"\n        self.assertEqual(feedgenerator.rfc2822_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0, tzinfo=get_fixed_timezone(60))),\n            'Fri, 14 Nov 2008 13:37:00 +0100')\n    \nFeedgeneratorTests().test_rfc2822_date_with_timezone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc3339_date_with_timezone(self):\n        \"\"\"\n            rfc3339_date() correctly formats datetime objects with tzinfo.\n            \"\"\"\n        self.assertEqual(feedgenerator.rfc3339_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0, tzinfo=get_fixed_timezone(120))),\n            '2008-11-14T13:37:00+02:00')\n    \nFeedgeneratorTests().test_rfc3339_date_with_timezone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DateParseTests(unittest.TestCase):\n    def test_parse_datetime(self):\n        valid_inputs = ('2012-04-23', datetime(2012, 4, 23)), (\n            '2012-04-23T09:15:00', datetime(2012, 4, 23, 9, 15)), (\n            '2012-4-9 4:8:16', datetime(2012, 4, 9, 4, 8, 16)), (\n            '2012-04-23T09:15:00Z', datetime(2012, 4, 23, 9, 15, 0, 0,\n            get_fixed_timezone(0))), ('2012-4-9 4:8:16-0320', datetime(2012, 4,\n            9, 4, 8, 16, 0, get_fixed_timezone(-200))), (\n            '2012-04-23T10:20:30.400+02:30', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(150))), ('2012-04-23T10:20:30.400+02',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(120))), (\n            '2012-04-23T10:20:30.400-02', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(-120))), ('2012-04-23T10:20:30,400-02',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(-120))), (\n            '2012-04-23T10:20:30.400 +0230', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(150))), ('2012-04-23T10:20:30,400 +00',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(0))), (\n            '2012-04-23T10:20:30   -02', datetime(2012, 4, 23, 10, 20, 30, 0,\n            get_fixed_timezone(-120)))\n        for source, expected in valid_inputs:\n            with self.subTest(source=source):\n                self.assertEqual(parse_datetime(source), expected)\n        self.assertIsNone(parse_datetime('20120423091500'))\n        with self.assertRaises(ValueError):\n            parse_datetime('2012-04-56T09:15:90')\n    \nDateParseTests().test_parse_datetime()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}], "instruction": "# Get a timezone object representing UTC+02:00 (Eastern European Time)\neastern_european_time = get_fixed_timezone(120)\n\n# Get a timezone object representing UTC-05:00 (Eastern Standard Time)\neastern_standard_time = get_fixed_timezone(-300)", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\ndef get_fixed_timezone(offset): [MASK]\n"}
{"method_name": "iter_all_python_module_files", "full_method_name": "iter_all_python_module_files", "method_path": "../srcdata/Network/django/django/utils/autoreload.py", "method_code": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n_error_files = []\n@lru_cache(maxsize=1)\ndef iter_modules_and_files(modules, extra_files):\n    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n    sys_file_paths = []\n    for module in modules:\n        if not isinstance(module, ModuleType):\n            continue\n        if module.__name__ in ('__main__', '__mp_main__'):\n            if hasattr(module, '__file__'):\n                sys_file_paths.append(module.__file__)\n            continue\n        if getattr(module, '__spec__', None) is None:\n            continue\n        spec = module.__spec__\n        if spec.has_location:\n            origin = spec.loader.archive if isinstance(spec.loader, zipimporter\n                ) else spec.origin\n            sys_file_paths.append(origin)\n    results = set()\n    for filename in itertools.chain(sys_file_paths, extra_files):\n        if not filename:\n            continue\n        path = Path(filename)\n        try:\n            if not path.exists():\n                continue\n        except ValueError as e:\n            logger.debug('\"%s\" raised when resolving path: \"%s\"', e, path)\n            continue\n        resolved_path = path.resolve().absolute()\n        results.add(resolved_path)\n    return frozenset(results)\ndef iter_all_python_module_files():\n    keys = sorted(sys.modules)\n    modules = tuple(m for m in map(sys.modules.__getitem__, keys) if not\n        isinstance(m, weakref.ProxyTypes))\n    return iter_modules_and_files(modules, frozenset(_error_files))", "test_code_list": [{"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestIterModulesAndFiles(SimpleTestCase):\n    def test_paths_are_pathlib_instances(self):\n        for filename in iter_all_python_module_files():\n            self.assertIsInstance(filename, Path)\n    \nTestIterModulesAndFiles().test_paths_are_pathlib_instances()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}], "instruction": "Functionality: Iterate through all Python module files that are currently loaded in the system, including those within zip archives and additional files specified in a private list, to return a set of absolute file paths.\n\nInputs: None. The function uses the current state of the system's loaded modules and a predefined list of extra files that need to be watched.\n\nOutputs: A frozenset containing the absolute file paths of all Python module files currently loaded and specified extra files. If a file path cannot be resolved or does not exist, it is not included in the output. The output ensures that no duplicates are present, and the set is immutable.", "method_code_mask": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n_error_files = []\n\n\n@lru_cache(maxsize=1)\ndef iter_modules_and_files(modules, extra_files):\n    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n    sys_file_paths = []\n    for module in modules:\n        if not isinstance(module, ModuleType):\n            continue\n        if module.__name__ in ('__main__', '__mp_main__'):\n            if hasattr(module, '__file__'):\n                sys_file_paths.append(module.__file__)\n            continue\n        if getattr(module, '__spec__', None) is None:\n            continue\n        spec = module.__spec__\n        if spec.has_location:\n            origin = spec.loader.archive if isinstance(spec.loader, zipimporter\n                ) else spec.origin\n            sys_file_paths.append(origin)\n    results = set()\n    for filename in itertools.chain(sys_file_paths, extra_files):\n        if not filename:\n            continue\n        path = Path(filename)\n        try:\n            if not path.exists():\n                continue\n        except ValueError as e:\n            logger.debug('\"%s\" raised when resolving path: \"%s\"', e, path)\n            continue\n        resolved_path = path.resolve().absolute()\n        results.add(resolved_path)\n    return frozenset(results)\n\n\ndef iter_all_python_module_files(): [MASK]\n"}
{"method_name": "iter_modules_and_files", "full_method_name": "iter_modules_and_files", "method_path": "../srcdata/Network/django/django/utils/autoreload.py", "method_code": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n@lru_cache(maxsize=1)\ndef iter_modules_and_files(modules, extra_files):\n    \"\"\"Iterate through all modules needed to be watched.\"\"\"\n    sys_file_paths = []\n    for module in modules:\n        if not isinstance(module, ModuleType):\n            continue\n        if module.__name__ in ('__main__', '__mp_main__'):\n            if hasattr(module, '__file__'):\n                sys_file_paths.append(module.__file__)\n            continue\n        if getattr(module, '__spec__', None) is None:\n            continue\n        spec = module.__spec__\n        if spec.has_location:\n            origin = spec.loader.archive if isinstance(spec.loader, zipimporter\n                ) else spec.origin\n            sys_file_paths.append(origin)\n    results = set()\n    for filename in itertools.chain(sys_file_paths, extra_files):\n        if not filename:\n            continue\n        path = Path(filename)\n        try:\n            if not path.exists():\n                continue\n        except ValueError as e:\n            logger.debug('\"%s\" raised when resolving path: \"%s\"', e, path)\n            continue\n        resolved_path = path.resolve().absolute()\n        results.add(resolved_path)\n    return frozenset(results)", "test_code_list": [{"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestIterModulesAndFiles(SimpleTestCase):\n    def test_module_without_spec(self):\n        module = types.ModuleType('test_module')\n        del module.__spec__\n        self.assertEqual(iter_modules_and_files((module,), frozenset\n            ()), frozenset())\n    \nTestIterModulesAndFiles().test_module_without_spec()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestIterModulesAndFiles(SimpleTestCase):\n    def test_main_module_without_file_is_not_resolved(self):\n        fake_main = types.ModuleType('__main__')\n        self.assertEqual(iter_modules_and_files((fake_main,),\n            frozenset()), frozenset())\n    \nTestIterModulesAndFiles().test_main_module_without_file_is_not_resolved()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestIterModulesAndFiles(SimpleTestCase):\n    def test_path_with_embedded_null_bytes(self):\n        for path in ('embedded_null_byte\\x00.py',\n            'di\\x00rectory/embedded_null_byte.py'):\n            with self.subTest(path=path):\n                self.assertEqual(iter_modules_and_files((),\n                    frozenset([path])), frozenset())\n    \nTestIterModulesAndFiles().test_path_with_embedded_null_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}], "instruction": "Functionality: The iter_modules_and_files function is designed to iterate through all modules and files that are required to be watched for changes. It processes a list of modules and an additional list of files, yielding a set of absolute paths to these modules and files.\n\nInputs: \n- modules: A list of objects, typically modules. This list should only contain ModuleType instances and exclude '__main__' and '__mp_main__' modules.\n- extra_files: A list of additional file paths that need to be monitored alongside the modules.\n\nOutputs:\n- A frozenset containing the absolute paths (as Path objects) to all the modules and files that are to be watched. This includes the files from the modules argument and the extra_files argument that exist in the filesystem. Paths that do not exist or cannot be resolved due to errors are excluded from the output.", "method_code_mask": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n\n\n@lru_cache(maxsize=1)\ndef iter_modules_and_files(modules, extra_files): [MASK]\n"}
{"method_name": "get_child_arguments", "full_method_name": "get_child_arguments", "method_path": "../srcdata/Network/django/django/utils/autoreload.py", "method_code": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\ndef get_child_arguments():\n    \"\"\"\n    Return the executable. This contains a workaround for Windows if the\n    executable is reported to not have the .exe extension which can cause bugs\n    on reloading.\n    \"\"\"\n    import __main__\n    py_script = Path(sys.argv[0])\n    exe_entrypoint = py_script.with_suffix('.exe')\n    args = [sys.executable] + [('-W%s' % o) for o in sys.warnoptions]\n    if sys.implementation.name in ('cpython', 'pypy'):\n        args.extend(f'-X{key}' if value is True else f'-X{key}={value}' for\n            key, value in sys._xoptions.items())\n    if getattr(__main__, '__spec__', None\n        ) is not None and not exe_entrypoint.exists():\n        spec = __main__.__spec__\n        if (spec.name == '__main__' or spec.name.endswith('.__main__')\n            ) and spec.parent:\n            name = spec.parent\n        else:\n            name = spec.name\n        args += ['-m', name]\n        args += sys.argv[1:]\n    elif not py_script.exists():\n        if exe_entrypoint.exists():\n            return [exe_entrypoint, *sys.argv[1:]]\n        script_entrypoint = py_script.with_name('%s-script.py' % py_script.name\n            )\n        if script_entrypoint.exists():\n            return [*args, script_entrypoint, *sys.argv[1:]]\n        raise RuntimeError('Script %s does not exist.' % py_script)\n    else:\n        args += sys.argv\n    return args", "test_code_list": [{"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestChildArguments(SimpleTestCase):\n    @mock.patch.dict(sys.modules, {'__main__': django.__main__})\n    @mock.patch('sys.argv', [django.__main__.__file__, 'runserver'])\n    @mock.patch('sys.warnoptions', [])\n    @mock.patch('sys._xoptions', {})\n    def test_run_as_module(self):\n        self.assertEqual(get_child_arguments(), [sys.executable,\n            '-m', 'django', 'runserver'])\n    \nTestChildArguments().test_run_as_module()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestChildArguments(SimpleTestCase):\n    @mock.patch('__main__.__spec__', None)\n    @mock.patch('sys.warnoptions', [])\n    def test_exe_fallback(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            exe_path = Path(tmpdir) / 'django-admin.exe'\n            exe_path.touch()\n            with mock.patch('sys.argv', [exe_path.with_suffix(''), 'runserver']):\n                self.assertEqual(get_child_arguments(), [exe_path,\n                    'runserver'])\n    \nTestChildArguments().test_exe_fallback()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestChildArguments(SimpleTestCase):\n    @mock.patch('sys.warnoptions', [])\n    @mock.patch.dict(sys.modules, {'__main__': django.__main__})\n    def test_use_exe_when_main_spec(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            exe_path = Path(tmpdir) / 'django-admin.exe'\n            exe_path.touch()\n            with mock.patch('sys.argv', [exe_path.with_suffix(''), 'runserver']):\n                self.assertEqual(get_child_arguments(), [exe_path,\n                    'runserver'])\n    \nTestChildArguments().test_use_exe_when_main_spec()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestChildArguments(SimpleTestCase):\n    @mock.patch('__main__.__spec__', None)\n    @mock.patch('sys.warnoptions', [])\n    @mock.patch('sys._xoptions', {})\n    def test_entrypoint_fallback(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            script_path = Path(tmpdir) / 'django-admin-script.py'\n            script_path.touch()\n            with mock.patch('sys.argv', [script_path.with_name('django-admin'),\n                'runserver']):\n                self.assertEqual(get_child_arguments(), [sys.\n                    executable, script_path, 'runserver'])\n    \nTestChildArguments().test_entrypoint_fallback()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}, {"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestChildArguments(SimpleTestCase):\n    @mock.patch('__main__.__spec__', None)\n    @mock.patch('sys.argv', ['does-not-exist', 'runserver'])\n    @mock.patch('sys.warnoptions', [])\n    def test_raises_runtimeerror(self):\n        msg = 'Script does-not-exist does not exist.'\n        with self.assertRaisesMessage(RuntimeError, msg):\n            get_child_arguments()\n    \nTestChildArguments().test_raises_runtimeerror()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}], "instruction": "Functionality: \nThe get_child_arguments function is designed to return the executable path and arguments needed for the current Python script. It includes a workaround for Windows systems where the executable might not have the .exe extension, which can cause issues during reloading. The function constructs the argument list to include the Python interpreter path, warning options, implementation-specific options, and the script path or module name to run.\n\nInputs: \nNo input parameters are required for the get_child_arguments function.\n\nOutputs: \nReturns a list of strings representing the executable path and arguments. This list includes the Python interpreter path, warning options, implementation-specific options, and the script path or module name to run. If the script does not exist, it raises a RuntimeError exception with a message indicating the script does not exist.", "method_code_mask": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n\n\ndef get_child_arguments(): [MASK]\n"}
{"method_name": "common_roots", "full_method_name": "common_roots", "method_path": "../srcdata/Network/django/django/utils/autoreload.py", "method_code": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n@lru_cache(maxsize=1)\ndef common_roots(paths):\n    \"\"\"\n    Return a tuple of common roots that are shared between the given paths.\n    File system watchers operate on directories and aren't cheap to create.\n    Try to find the minimum set of directories to watch that encompass all of\n    the files that need to be watched.\n    \"\"\"\n    path_parts = sorted([x.parts for x in paths], key=len, reverse=True)\n    tree = {}\n    for chunks in path_parts:\n        node = tree\n        for chunk in chunks:\n            node = node.setdefault(chunk, {})\n        node.clear()\n\n    def _walk(node, path):\n        for prefix, child in node.items():\n            yield from _walk(child, path + (prefix,))\n        if not node:\n            yield Path(*path)\n    return tuple(_walk(tree, ()))", "test_code_list": [{"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestCommonRoots(SimpleTestCase):\n    def test_common_roots(self):\n        paths = Path('/first/second'), Path('/first/second/third'), Path('/first/'\n            ), Path('/root/first/')\n        results = common_roots(paths)\n        self.assertCountEqual(results, [Path('/first/'), Path('/root/first/')])\n    \nTestCommonRoots().test_common_roots()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}], "instruction": "Functionality: The common_roots function takes a sequence of paths and returns a tuple of common roots that are shared between these given paths. This function aims to optimize file system watching by identifying the minimum set of directories to monitor, which encompass all of the required files to be watched. It operates by sorting the path parts in descending order of length, constructing a tree structure where each node represents a directory level, and then traversing this tree to find the common root directories.\n\nInputs: \n- paths: A list or tuple of Path objects. Each Path object represents a file system path that needs to be monitored.\n\nOutputs: \n- A tuple containing Path objects. Each Path object in the output tuple is a common root directory that is shared among the input paths. These root directories represent the minimum set of directories that need to be watched to monitor all the input paths effectively.", "method_code_mask": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n\n\n@lru_cache(maxsize=1)\ndef common_roots(paths): [MASK]\n"}
{"method_name": "sys_path_directories", "full_method_name": "sys_path_directories", "method_path": "../srcdata/Network/django/django/utils/autoreload.py", "method_code": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\ndef sys_path_directories():\n    \"\"\"\n    Yield absolute directories from sys.path, ignoring entries that don't\n    exist.\n    \"\"\"\n    for path in sys.path:\n        path = Path(path)\n        if not path.exists():\n            continue\n        resolved_path = path.resolve().absolute()\n        if resolved_path.is_file():\n            yield resolved_path.parent\n        else:\n            yield resolved_path", "test_code_list": [{"test_code": "import contextlib\nimport os\nimport py_compile\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport types\nimport weakref\nimport zipfile\nimport zoneinfo\nfrom importlib import import_module\nfrom pathlib import Path\nfrom subprocess import CompletedProcess\nfrom unittest import mock\nfrom unittest import skip\nfrom unittest import skipIf\nimport django.__main__\nfrom django.apps.registry import Apps\nfrom django.test import SimpleTestCase\nfrom django.test.utils import extend_sys_path\nfrom django.utils import autoreload\nfrom django.utils.autoreload import WatchmanUnavailable\n\nclass TestSysPathDirectories(SimpleTestCase):\n    def test_sys_paths_absolute(self):\n        paths = list(sys_path_directories())\n        self.assertTrue(all(p.is_absolute() for p in paths))\n    \nTestSysPathDirectories().test_sys_paths_absolute()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_autoreload.py"}], "instruction": "Functionality: The sys_path_directories function is designed to iterate over the directories listed in the Python system path (sys.path). It yields the absolute path for each directory, resolving any symbolic links and ignoring entries that do not exist on the filesystem. This function is particularly useful for identifying the locations of modules and packages that are accessible to the Python interpreter.\n\nInputs: This function does not require any input arguments. It utilizes the sys.path list, which is a global system variable in Python, to gather information about the directories in the system path.\n\nOutputs: The function yields an iterator of Path objects, where each object represents the absolute path of a directory found in sys.path. These paths are resolved to their absolute forms, and symbolic links are dereferenced to their target locations. Directories that are represented by files (e.g., when the path entry is a .zip or .egg file) will yield the parent directory of the file. Non-existent path entries are ignored, and will not be included in the output.", "method_code_mask": "import itertools\nimport logging\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport weakref\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom functools import wraps\nfrom pathlib import Path\nfrom types import ModuleType\nfrom zipimport import zipimporter\nimport django\nfrom django.apps import apps\nfrom django.core.signals import request_finished\nfrom django.dispatch import Signal\nfrom django.utils.functional import cached_property\nfrom django.utils.version import get_version_tuple\nimport termios\nimport __main__\nfrom django.urls import get_resolver\n\n\ndef sys_path_directories(): [MASK]\n"}
{"method_name": "rfc2822_date", "full_method_name": "rfc2822_date", "method_path": "../srcdata/Network/django/django/utils/feedgenerator.py", "method_code": "import datetime\nimport email\nimport mimetypes\nfrom io import StringIO\nfrom urllib.parse import urlparse\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.xmlutils import SimplerXMLGenerator\ndef rfc2822_date(date):\n    if not isinstance(date, datetime.datetime):\n        date = datetime.datetime.combine(date, datetime.time())\n    return email.utils.format_datetime(date)", "test_code_list": [{"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc2822_date(self):\n        \"\"\"\n            rfc2822_date() correctly formats datetime objects.\n            \"\"\"\n        self.assertEqual(rfc2822_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0)), 'Fri, 14 Nov 2008 13:37:00 -0000')\n    \nFeedgeneratorTests().test_rfc2822_date()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc2822_date_with_timezone(self):\n        \"\"\"\n            rfc2822_date() correctly formats datetime objects with tzinfo.\n            \"\"\"\n        self.assertEqual(rfc2822_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0, tzinfo=get_fixed_timezone(60))),\n            'Fri, 14 Nov 2008 13:37:00 +0100')\n    \nFeedgeneratorTests().test_rfc2822_date_with_timezone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc2822_date_without_time(self):\n        \"\"\"\n            rfc2822_date() correctly formats date objects.\n            \"\"\"\n        self.assertEqual(rfc2822_date(datetime.date(2008, 11, 14)\n            ), 'Fri, 14 Nov 2008 00:00:00 -0000')\n    \nFeedgeneratorTests().test_rfc2822_date_without_time()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}], "instruction": "Functionality: This function is designed to convert a given date or datetime object into an RFC 2822 compliant string format, which is commonly used in email headers and other internet protocols. It ensures that the date provided is formatted correctly for compatibility and standardization.\n\nInputs: \n- date (datetime.date or datetime.datetime): A date or datetime object to be converted. If the input is a datetime.date object, it will be combined with a default time at midnight to create a datetime.datetime object before conversion.\n\nOutputs:\n- str: A string representation of the input date or datetime object formatted according to RFC 2822 standards. The output string will be in the format specified by the email.utils.format_datetime method from the Python standard library.", "method_code_mask": "import datetime\nimport email\nimport mimetypes\nfrom io import StringIO\nfrom urllib.parse import urlparse\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.xmlutils import SimplerXMLGenerator\n\n\ndef rfc2822_date(date): [MASK]\n"}
{"method_name": "rfc3339_date", "full_method_name": "rfc3339_date", "method_path": "../srcdata/Network/django/django/utils/feedgenerator.py", "method_code": "import datetime\nimport email\nimport mimetypes\nfrom io import StringIO\nfrom urllib.parse import urlparse\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.xmlutils import SimplerXMLGenerator\ndef rfc3339_date(date):\n    if not isinstance(date, datetime.datetime):\n        date = datetime.datetime.combine(date, datetime.time())\n    return date.isoformat() + ('Z' if date.utcoffset() is None else '')", "test_code_list": [{"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc3339_date(self):\n        \"\"\"\n            rfc3339_date() correctly formats datetime objects.\n            \"\"\"\n        self.assertEqual(rfc3339_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0)), '2008-11-14T13:37:00Z')\n    \nFeedgeneratorTests().test_rfc3339_date()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc3339_date_with_timezone(self):\n        \"\"\"\n            rfc3339_date() correctly formats datetime objects with tzinfo.\n            \"\"\"\n        self.assertEqual(rfc3339_date(datetime.datetime(2008, 11,\n            14, 13, 37, 0, tzinfo=get_fixed_timezone(120))),\n            '2008-11-14T13:37:00+02:00')\n    \nFeedgeneratorTests().test_rfc3339_date_with_timezone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}, {"test_code": "import datetime\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils import feedgenerator\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.timezone import get_fixed_timezone\n\nclass FeedgeneratorTests(SimpleTestCase):\n    def test_rfc3339_date_without_time(self):\n        \"\"\"\n            rfc3339_date() correctly formats date objects.\n            \"\"\"\n        self.assertEqual(rfc3339_date(datetime.date(2008, 11, 14)\n            ), '2008-11-14T00:00:00Z')\n    \nFeedgeneratorTests().test_rfc3339_date_without_time()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_feedgenerator.py"}], "instruction": "Functionality: The rfc3339_date function converts a given date or datetime object into a string formatted according to RFC 3339, which is a standard for representing dates and times in a consistent, machine-readable way. This string is then returned with a timezone indicator appended to it. If the provided date does not contain time information, it is combined with a default time (midnight) before conversion.\n\nInputs: \n- date (datetime.date or datetime.datetime): The date or datetime object to be converted. If a date object is provided without time, it will be combined with a time of 00:00:00 (midnight).\n\nOutputs:\n- A string representing the date or datetime in RFC 3339 format, with a 'Z' appended if the datetime object does not specify a timezone offset, indicating UTC time. If a timezone offset is specified, it is included in the output string.", "method_code_mask": "import datetime\nimport email\nimport mimetypes\nfrom io import StringIO\nfrom urllib.parse import urlparse\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.xmlutils import SimplerXMLGenerator\n\n\ndef rfc3339_date(date): [MASK]\n"}
{"method_name": "words", "full_method_name": "words", "method_path": "../srcdata/Network/django/django/utils/lorem_ipsum.py", "method_code": "import random\ndef words(count, common=True):\n    \"\"\"\n    Return a string of `count` lorem ipsum words separated by a single space.\n\n    If `common` is True, then the first 19 words will be the standard\n    'lorem ipsum' words. Otherwise, all words will be selected randomly.\n    \"\"\"\n    word_list = list(COMMON_WORDS) if common else []\n    c = len(word_list)\n    if count > c:\n        count -= c\n        while count > 0:\n            c = min(count, len(WORDS))\n            count -= c\n            word_list += random.sample(WORDS, c)\n    else:\n        word_list = word_list[:count]\n    return ' '.join(word_list)", "test_code_list": [{"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_negative_words(self):\n        \"\"\"words(n) returns n + 19 words, even if n is negative.\"\"\"\n        self.assertEqual(words(-5),\n            'lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut'\n            )\n    \nLoremIpsumTests().test_negative_words()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}, {"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_same_or_less_common_words(self):\n        \"\"\"words(n) for n < 19.\"\"\"\n        self.assertEqual(words(7),\n            'lorem ipsum dolor sit amet consectetur adipisicing')\n    \nLoremIpsumTests().test_same_or_less_common_words()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}, {"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_common_words_in_string(self):\n        \"\"\"words(n) starts with the 19 standard lorem ipsum words for n > 19.\"\"\"\n        self.assertTrue(words(25).startswith(\n            'lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua'\n            ))\n    \nLoremIpsumTests().test_common_words_in_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}, {"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_more_words_than_common(self):\n        \"\"\"words(n) returns n words for n > 19.\"\"\"\n        self.assertEqual(len(words(25).split()), 25)\n    \nLoremIpsumTests().test_more_words_than_common()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}, {"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_common_large_number_of_words(self):\n        \"\"\"words(n) has n words when n is greater than len(WORDS).\"\"\"\n        self.assertEqual(len(words(500).split()), 500)\n    \nLoremIpsumTests().test_common_large_number_of_words()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}], "instruction": "Functionality: The function \"words\" generates a string of lorem ipsum words. It can operate in two modes: common (default) and random. In common mode, the first 19 words will be standard 'lorem ipsum' words, while in random mode, all words will be selected randomly from a predefined list. The function ensures that the output consists of a specified number of words separated by a single space.\n\nInputs: \n- count (integer): The number of lorem ipsum words to generate.\n- common (boolean, default True): A flag to determine whether to use common 'lorem ipsum' words at the beginning or to select all words randomly.\n\nOutputs:\n- A string containing the specified number of lorem ipsum words, separated by a single space.", "method_code_mask": "import random\n\n\ndef words(count, common=True): [MASK]\n"}
{"method_name": "sentence", "full_method_name": "sentence", "method_path": "../srcdata/Network/django/django/utils/lorem_ipsum.py", "method_code": "import random\ndef sentence():\n    \"\"\"\n    Return a randomly generated sentence of lorem ipsum text.\n\n    The first word is capitalized, and the sentence ends in either a period or\n    question mark. Commas are added at random.\n    \"\"\"\n    sections = [' '.join(random.sample(WORDS, random.randint(3, 12))) for i in\n        range(random.randint(1, 5))]\n    s = ', '.join(sections)\n    return '%s%s%s' % (s[0].upper(), s[1:], random.choice('?.'))", "test_code_list": [{"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_sentence_starts_with_capital(self):\n        \"\"\"A sentence starts with a capital letter.\"\"\"\n        self.assertTrue(sentence()[0].isupper())\n    \nLoremIpsumTests().test_sentence_starts_with_capital()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}], "instruction": "Functionality: The function \"sentence\" is designed to generate a random sentence using lorem ipsum text. The sentence will start with a capital letter and end with either a period or a question mark. Commas may be inserted randomly within the sentence.\n\nInputs: There are no input arguments required for this function.\n\nOutputs: The function outputs a generated sentence as a string. ", "method_code_mask": "import random\n\n\ndef sentence(): [MASK]\n"}
{"method_name": "paragraphs", "full_method_name": "paragraphs", "method_path": "../srcdata/Network/django/django/utils/lorem_ipsum.py", "method_code": "import random\ndef paragraphs(count, common=True):\n    \"\"\"\n    Return a list of paragraphs as returned by paragraph().\n\n    If `common` is True, then the first paragraph will be the standard\n    'lorem ipsum' paragraph. Otherwise, the first paragraph will be random\n    Latin text. Either way, subsequent paragraphs will be random Latin text.\n    \"\"\"\n    paras = []\n    for i in range(count):\n        if common and i == 0:\n            paras.append(COMMON_P)\n        else:\n            paras.append(paragraph())\n    return paras", "test_code_list": [{"test_code": "import unittest\nfrom unittest import mock\nfrom django.utils.lorem_ipsum import paragraph\nfrom django.utils.lorem_ipsum import paragraphs\nfrom django.utils.lorem_ipsum import sentence\nfrom django.utils.lorem_ipsum import words\n\nclass LoremIpsumTests(unittest.TestCase):\n    def test_paragraphs(self):\n        \"\"\"paragraphs(1) uses the COMMON_P paragraph.\"\"\"\n        self.assertEqual(paragraphs(1), [\n            'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'\n            ])\n    \nLoremIpsumTests().test_paragraphs()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_lorem_ipsum.py"}], "instruction": "Functionality: The paragraphs function is designed to generate a list of paragraphs, each filled with Latin text. The function allows for the inclusion of a standard 'lorem ipsum' paragraph at the beginning, depending on the input parameters. Subsequent paragraphs will be random Latin text.\n\nInputs: \n1. count (integer): The number of paragraphs to be generated.\n2. common (boolean): A flag to determine whether the first paragraph should be the standard 'lorem ipsum' text. If set to True, the first paragraph will be 'lorem ipsum'. If set to False, the first paragraph will be random Latin text, like all others.\n\nOutputs: \n1. A list of strings, where each string represents a paragraph filled with Latin text. The number of paragraphs in the list will match the value of the 'count' input parameter.", "method_code_mask": "import random\n\n\ndef paragraphs(count, common=True): [MASK]\n"}
{"method_name": "make_hashable", "full_method_name": "make_hashable", "method_path": "../srcdata/Network/django/django/utils/hashable.py", "method_code": "from collections.abc import Iterable\ndef make_hashable(value):\n    \"\"\"\n    Attempt to make value hashable or raise a TypeError if it fails.\n\n    The returned value should generate the same hash for equal values.\n    \"\"\"\n    if isinstance(value, dict):\n        return tuple([(key, make_hashable(nested_value)) for key,\n            nested_value in sorted(value.items())])\n    try:\n        hash(value)\n    except TypeError:\n        if isinstance(value, Iterable):\n            return tuple(map(make_hashable, value))\n        raise\n    return value", "test_code_list": [{"test_code": "from django.test import SimpleTestCase\nfrom django.utils.hashable import make_hashable\n\nclass TestHashable(SimpleTestCase):\n    def test_equal(self):\n        tests = ([], ()), (['a', 1], ('a', 1)), ({}, ()), ({'a'}, ('a',)), (\n            frozenset({'a'}), {'a'}), ({'a': 1, 'b': 2}, (('a', 1), ('b', 2))), ({\n            'b': 2, 'a': 1}, (('a', 1), ('b', 2))), (('a', ['b', 1]), ('a', (\n            'b', 1))), (('a', {'b': 1}), ('a', (('b', 1),)))\n        for value, expected in tests:\n            with self.subTest(value=value):\n                self.assertEqual(make_hashable(value), expected)\n    \nTestHashable().test_equal()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_hashable.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.hashable import make_hashable\n\nclass TestHashable(SimpleTestCase):\n    def test_count_equal(self):\n        tests = ({'a': 1, 'b': ['a', 1]}, (('a', 1), ('b', ('a', 1)))), ({'a': \n            1, 'b': ('a', [1, 2])}, (('a', 1), ('b', ('a', (1, 2)))))\n        for value, expected in tests:\n            with self.subTest(value=value):\n                self.assertCountEqual(make_hashable(value), expected)\n    \nTestHashable().test_count_equal()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_hashable.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.hashable import make_hashable\n\nclass TestHashable(SimpleTestCase):\n    def test_unhashable(self):\n    \n    \n        class Unhashable:\n            __hash__ = None\n        with self.assertRaisesMessage(TypeError, \"unhashable type: 'Unhashable'\"):\n            make_hashable(Unhashable())\n    \nTestHashable().test_unhashable()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_hashable.py"}], "instruction": "Functionality: The make_hashable function is designed to transform any input value into a hashable form. It ensures that equal values generate the same hash by converting unhashable types like lists or dictionaries into a hashable tuple representation. Complex structures are handled recursively. If a TypeError occurs due to an unhashable type that cannot be converted into a hashable form, the function raises this error.\n\nInputs: \n    value: The input value that needs to be made hashable. This can be any Python data type, including but not limited to dictionaries, lists, tuples, sets, and custom objects.\n\nOutputs:\n    If the input value or its nested structures can be made hashable, the function returns a version of the value in a hashable form. This could be the original value if it is already hashable (like integers, strings, tuples), or a transformed version if it is not directly hashable (like converting a dictionary into a tuple of sorted key-value pairs, or a list into a tuple). If the value or any of its nested structures cannot be made hashable, the function raises a TypeError.", "method_code_mask": "from collections.abc import Iterable\n\n\ndef make_hashable(value): [MASK]\n"}
{"method_name": "prepare_js_for_gettext", "full_method_name": "prepare_js_for_gettext", "method_path": "../srcdata/Network/django/django/utils/jslex.py", "method_code": "import re\ndef prepare_js_for_gettext(js):\n    \"\"\"\n    Convert the JavaScript source `js` into something resembling C for\n    xgettext.\n\n    What actually happens is that all the regex literals are replaced with\n    \"REGEX\".\n    \"\"\"\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for name, tok in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)", "test_code_list": [{"test_code": "from django.test import SimpleTestCase\nfrom django.utils.jslex import JsLexer\nfrom django.utils.jslex import prepare_js_for_gettext\ndef make_function():\n\n    def test_func(self):\n        self.assertEqual(prepare_js_for_gettext(js), c)\n    return test_func\n\nmake_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_jslex.py"}], "instruction": "Functionality: The function 'prepare_js_for_gettext' takes a JavaScript source code as input and converts it into a format that resembles C code for the purpose of extracting strings for translation using xgettext. This is achieved by replacing all regex literals in the code with the string \"REGEX\", escaping double quotes, and replacing backslashes in identifiers with 'U'.\n\nInputs: \n- js: A string representing the JavaScript source code that needs to be converted.\n\nOutputs:\n- A string: The modified JavaScript source code where regex literals are replaced with \"REGEX\", string literals are properly escaped, and identifiers have backslashes replaced with 'U'.", "method_code_mask": "import re\n\n\ndef prepare_js_for_gettext(js): [MASK]\n"}
{"method_name": "parse_date", "full_method_name": "parse_date", "method_path": "../srcdata/Network/django/django/utils/dateparse.py", "method_code": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\ndef parse_date(value):\n    \"\"\"Parse a string and return a datetime.date.\n\n    Raise ValueError if the input is well formatted but not a valid date.\n    Return None if the input isn't well formatted.\n    \"\"\"\n    try:\n        return datetime.date.fromisoformat(value)\n    except ValueError:\n        if (match := date_re.match(value)):\n            kw = {k: int(v) for k, v in match.groupdict().items()}\n            return datetime.date(**kw)", "test_code_list": [{"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DateParseTests(unittest.TestCase):\n    def test_parse_date(self):\n        self.assertEqual(parse_date('2012-04-23'), date(2012, 4, 23))\n        self.assertEqual(parse_date('2012-4-9'), date(2012, 4, 9))\n        if PY311:\n            self.assertEqual(parse_date('20120423'), date(2012, 4, 23))\n        self.assertIsNone(parse_date('2012423'))\n        with self.assertRaises(ValueError):\n            parse_date('2012-04-56')\n    \nDateParseTests().test_parse_date()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}], "instruction": "Functionality: The parse_date function takes a string as input and attempts to convert it into a datetime.date object. If the string is well-formatted but does not represent a valid date, a ValueError is raised. If the string is not well-formatted, the function returns None.\n\nInputs: \n- value (str): A string containing a date in a specific format.\n\nOutputs:\n- datetime.date: A date object if the input string is well-formatted and represents a valid date.\n- None: If the input string is not well-formatted.\n- ValueError: If the input string is well-formatted but does not represent a valid date.", "method_code_mask": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\n\n\ndef parse_date(value): [MASK]\n"}
{"method_name": "parse_time", "full_method_name": "parse_time", "method_path": "../srcdata/Network/django/django/utils/dateparse.py", "method_code": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\ndef parse_time(value):\n    \"\"\"Parse a string and return a datetime.time.\n\n    This function doesn't support time zone offsets.\n\n    Raise ValueError if the input is well formatted but not a valid time.\n    Return None if the input isn't well formatted, in particular if it\n    contains an offset.\n    \"\"\"\n    try:\n        return datetime.time.fromisoformat(value).replace(tzinfo=None)\n    except ValueError:\n        if (match := time_re.match(value)):\n            kw = match.groupdict()\n            kw['microsecond'] = kw['microsecond'] and kw['microsecond'].ljust(\n                6, '0')\n            kw = {k: int(v) for k, v in kw.items() if v is not None}\n            return datetime.time(**kw)", "test_code_list": [{"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DateParseTests(unittest.TestCase):\n    def test_parse_time(self):\n        self.assertEqual(parse_time('09:15:00'), time(9, 15))\n        if PY311:\n            self.assertEqual(parse_time('091500'), time(9, 15))\n        self.assertEqual(parse_time('10:10'), time(10, 10))\n        self.assertEqual(parse_time('10:20:30.400'), time(10, 20, 30, 400000))\n        self.assertEqual(parse_time('10:20:30,400'), time(10, 20, 30, 400000))\n        self.assertEqual(parse_time('4:8:16'), time(4, 8, 16))\n        self.assertEqual(parse_time('00:05:23+04:00'), time(0, 5, 23))\n        self.assertIsNone(parse_time('00:05:'))\n        self.assertIsNone(parse_time('00:05:23,'))\n        self.assertIsNone(parse_time('00:05:23+'))\n        self.assertIsNone(parse_time('00:05:23+25:00'))\n        self.assertIsNone(parse_time('4:18:101'))\n        self.assertIsNone(parse_time('91500'))\n        with self.assertRaises(ValueError):\n            parse_time('09:15:90')\n    \nDateParseTests().test_parse_time()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}], "instruction": "Functionality: The parse_time function is designed to parse a string and return a datetime.time object. This function is not capable of handling time zone offsets. It will raise a ValueError if the input string is well-formatted but does not represent a valid time. If the input string is not well-formatted, particularly if it contains a time zone offset, the function will return None.\n\nInputs: \n- A single string argument 'value' that is expected to represent a time in a format recognized by the datetime.time.fromisoformat() method or a more generic time format.\n\nOutputs:\n- A datetime.time object if the input string represents a valid time without a time zone offset.\n- None if the input string is not well-formatted or contains a time zone offset.\n- Raises ValueError if the input string is well-formatted but does not represent a valid time.", "method_code_mask": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\n\n\ndef parse_time(value): [MASK]\n"}
{"method_name": "parse_datetime", "full_method_name": "parse_datetime", "method_path": "../srcdata/Network/django/django/utils/dateparse.py", "method_code": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\ndef parse_datetime(value):\n    \"\"\"Parse a string and return a datetime.datetime.\n\n    This function supports time zone offsets. When the input contains one,\n    the output uses a timezone with a fixed offset from UTC.\n\n    Raise ValueError if the input is well formatted but not a valid datetime.\n    Return None if the input isn't well formatted.\n    \"\"\"\n    try:\n        return datetime.datetime.fromisoformat(value)\n    except ValueError:\n        if (match := datetime_re.match(value)):\n            kw = match.groupdict()\n            kw['microsecond'] = kw['microsecond'] and kw['microsecond'].ljust(\n                6, '0')\n            tzinfo = kw.pop('tzinfo')\n            if tzinfo == 'Z':\n                tzinfo = datetime.timezone.utc\n            elif tzinfo is not None:\n                offset_mins = int(tzinfo[-2:]) if len(tzinfo) > 3 else 0\n                offset = 60 * int(tzinfo[1:3]) + offset_mins\n                if tzinfo[0] == '-':\n                    offset = -offset\n                tzinfo = get_fixed_timezone(offset)\n            kw = {k: int(v) for k, v in kw.items() if v is not None}\n            return datetime.datetime(**kw, tzinfo=tzinfo)", "test_code_list": [{"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DateParseTests(unittest.TestCase):\n    def test_parse_datetime(self):\n        valid_inputs = ('2012-04-23', datetime(2012, 4, 23)), (\n            '2012-04-23T09:15:00', datetime(2012, 4, 23, 9, 15)), (\n            '2012-4-9 4:8:16', datetime(2012, 4, 9, 4, 8, 16)), (\n            '2012-04-23T09:15:00Z', datetime(2012, 4, 23, 9, 15, 0, 0,\n            get_fixed_timezone(0))), ('2012-4-9 4:8:16-0320', datetime(2012, 4,\n            9, 4, 8, 16, 0, get_fixed_timezone(-200))), (\n            '2012-04-23T10:20:30.400+02:30', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(150))), ('2012-04-23T10:20:30.400+02',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(120))), (\n            '2012-04-23T10:20:30.400-02', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(-120))), ('2012-04-23T10:20:30,400-02',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(-120))), (\n            '2012-04-23T10:20:30.400 +0230', datetime(2012, 4, 23, 10, 20, 30, \n            400000, get_fixed_timezone(150))), ('2012-04-23T10:20:30,400 +00',\n            datetime(2012, 4, 23, 10, 20, 30, 400000, get_fixed_timezone(0))), (\n            '2012-04-23T10:20:30   -02', datetime(2012, 4, 23, 10, 20, 30, 0,\n            get_fixed_timezone(-120)))\n        for source, expected in valid_inputs:\n            with self.subTest(source=source):\n                self.assertEqual(parse_datetime(source), expected)\n        self.assertIsNone(parse_datetime('20120423091500'))\n        with self.assertRaises(ValueError):\n            parse_datetime('2012-04-56T09:15:90')\n    \nDateParseTests().test_parse_datetime()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}], "instruction": "Functionality: The parse_datetime function is designed to parse a string and return a datetime.datetime object. It supports time zone offsets, converting time zones to a fixed offset from UTC when specified in the input. If the input string is not a valid datetime format, the function will return None. If the input is well formatted but represents an invalid datetime, a ValueError will be raised.\n\nInputs: \n- value: A string representing a datetime. This string may include a timezone offset.\n\nOutputs:\n- A datetime.datetime object representing the parsed date and time. If the input string contains a timezone offset, the returned datetime object will have a timezone with a fixed offset from UTC.\n- If the input string is not well formatted, the function returns None.\n- If the input string is well formatted but represents an invalid datetime, the function raises a ValueError.", "method_code_mask": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\n\n\ndef parse_datetime(value): [MASK]\n"}
{"method_name": "parse_duration", "full_method_name": "parse_duration", "method_path": "../srcdata/Network/django/django/utils/dateparse.py", "method_code": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\ndef parse_duration(value):\n    \"\"\"Parse a duration string and return a datetime.timedelta.\n\n    The preferred format for durations in Django is '%d %H:%M:%S.%f'.\n\n    Also supports ISO 8601 representation and PostgreSQL's day-time interval\n    format.\n    \"\"\"\n    match = standard_duration_re.match(value) or iso8601_duration_re.match(\n        value) or postgres_interval_re.match(value)\n    if match:\n        kw = match.groupdict()\n        sign = -1 if kw.pop('sign', '+') == '-' else 1\n        if kw.get('microseconds'):\n            kw['microseconds'] = kw['microseconds'].ljust(6, '0')\n        kw = {k: float(v.replace(',', '.')) for k, v in kw.items() if v is not\n            None}\n        days = datetime.timedelta(kw.pop('days', 0.0) or 0.0)\n        if match.re == iso8601_duration_re:\n            days *= sign\n        return days + sign * datetime.timedelta(**kw)", "test_code_list": [{"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_parse_python_format(self):\n        timedeltas = [timedelta(days=4, minutes=15, seconds=30, milliseconds=\n            100), timedelta(hours=10, minutes=15, seconds=30), timedelta(days=4,\n            minutes=15, seconds=30), timedelta(days=1, minutes=0, seconds=0),\n            timedelta(days=-4, minutes=15, seconds=30), timedelta(minutes=15,\n            seconds=30), timedelta(seconds=30)]\n        for delta in timedeltas:\n            with self.subTest(delta=delta):\n                self.assertEqual(parse_duration(format(delta)), delta)\n    \nDurationParseTests().test_parse_python_format()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_parse_postgresql_format(self):\n        test_values = ('1 day', timedelta(1)), ('-1 day', timedelta(-1)), (\n            '1 day 0:00:01', timedelta(days=1, seconds=1)), ('1 day -0:00:01',\n            timedelta(days=1, seconds=-1)), ('-1 day -0:00:01', timedelta(days=\n            -1, seconds=-1)), ('-1 day +0:00:01', timedelta(days=-1, seconds=1)), (\n            '4 days 0:15:30.1', timedelta(days=4, minutes=15, seconds=30,\n            milliseconds=100)), ('4 days 0:15:30.0001', timedelta(days=4,\n            minutes=15, seconds=30, microseconds=100)), ('-4 days -15:00:30',\n            timedelta(days=-4, hours=-15, seconds=-30))\n        for source, expected in test_values:\n            with self.subTest(source=source):\n                self.assertEqual(parse_duration(source), expected)\n    \nDurationParseTests().test_parse_postgresql_format()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_seconds(self):\n        self.assertEqual(parse_duration('30'), timedelta(seconds=30))\n    \nDurationParseTests().test_seconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_minutes_seconds(self):\n        self.assertEqual(parse_duration('15:30'), timedelta(minutes=15, seconds=30)\n            )\n        self.assertEqual(parse_duration('5:30'), timedelta(minutes=5, seconds=30))\n    \nDurationParseTests().test_minutes_seconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_hours_minutes_seconds(self):\n        self.assertEqual(parse_duration('10:15:30'), timedelta(hours=10,\n            minutes=15, seconds=30))\n        self.assertEqual(parse_duration('1:15:30'), timedelta(hours=1, minutes=\n            15, seconds=30))\n        self.assertEqual(parse_duration('100:200:300'), timedelta(hours=100,\n            minutes=200, seconds=300))\n    \nDurationParseTests().test_hours_minutes_seconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_days(self):\n        self.assertEqual(parse_duration('4 15:30'), timedelta(days=4, minutes=\n            15, seconds=30))\n        self.assertEqual(parse_duration('4 10:15:30'), timedelta(days=4, hours=\n            10, minutes=15, seconds=30))\n    \nDurationParseTests().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_fractions_of_seconds(self):\n        test_values = ('15:30.1', timedelta(minutes=15, seconds=30,\n            milliseconds=100)), ('15:30.01', timedelta(minutes=15, seconds=30,\n            milliseconds=10)), ('15:30.001', timedelta(minutes=15, seconds=30,\n            milliseconds=1)), ('15:30.0001', timedelta(minutes=15, seconds=30,\n            microseconds=100)), ('15:30.00001', timedelta(minutes=15, seconds=\n            30, microseconds=10)), ('15:30.000001', timedelta(minutes=15,\n            seconds=30, microseconds=1)), ('15:30,000001', timedelta(minutes=15,\n            seconds=30, microseconds=1))\n        for source, expected in test_values:\n            with self.subTest(source=source):\n                self.assertEqual(parse_duration(source), expected)\n    \nDurationParseTests().test_fractions_of_seconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_negative(self):\n        test_values = ('-4 15:30', timedelta(days=-4, minutes=15, seconds=30)), (\n            '-172800', timedelta(days=-2)), ('-15:30', timedelta(minutes=-15,\n            seconds=-30)), ('-1:15:30', timedelta(hours=-1, minutes=-15,\n            seconds=-30)), ('-30.1', timedelta(seconds=-30, milliseconds=-100)), (\n            '-30,1', timedelta(seconds=-30, milliseconds=-100)), ('-00:01:01',\n            timedelta(minutes=-1, seconds=-1)), ('-01:01', timedelta(seconds=-61)\n            ), ('-01:-01', None)\n        for source, expected in test_values:\n            with self.subTest(source=source):\n                self.assertEqual(parse_duration(source), expected)\n    \nDurationParseTests().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom django.utils.dateparse import parse_date\nfrom django.utils.dateparse import parse_datetime\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.dateparse import parse_time\nfrom django.utils.timezone import get_fixed_timezone\nfrom django.utils.version import PY311\n\nclass DurationParseTests(unittest.TestCase):\n    def test_iso_8601(self):\n        test_values = ('P4Y', None), ('P4M', None), ('P4W', None), ('P4D',\n            timedelta(days=4)), ('-P1D', timedelta(days=-1)), ('P0.5D',\n            timedelta(hours=12)), ('P0,5D', timedelta(hours=12)), ('-P0.5D',\n            timedelta(hours=-12)), ('-P0,5D', timedelta(hours=-12)), ('PT5H',\n            timedelta(hours=5)), ('-PT5H', timedelta(hours=-5)), ('PT5M',\n            timedelta(minutes=5)), ('-PT5M', timedelta(minutes=-5)), ('PT5S',\n            timedelta(seconds=5)), ('-PT5S', timedelta(seconds=-5)), ('PT0.000005S'\n            , timedelta(microseconds=5)), ('PT0,000005S', timedelta(microseconds=5)\n            ), ('-PT0.000005S', timedelta(microseconds=-5)), ('-PT0,000005S',\n            timedelta(microseconds=-5)), ('-P4DT1H', timedelta(days=-4, hours=-1)\n            ), ('P3(3D', None), ('PT3)3H', None), ('PT3|3M', None), ('PT3/3S', None\n            )\n        for source, expected in test_values:\n            with self.subTest(source=source):\n                self.assertEqual(parse_duration(source), expected)\n    \nDurationParseTests().test_iso_8601()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_dateparse.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_negative(self):\n        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_negative(self):\n        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)).\n            total_seconds(), duration.total_seconds())\n    \nTestParseISODurationRoundtrip().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}], "instruction": "Functionality: The function parse_duration is designed to parse a string representation of a duration and convert it into a datetime.timedelta object. It supports three formats: the preferred '%d %H:%M:%S.%f' format, the ISO 8601 representation, and PostgreSQL's day-time interval format.\n\nInputs: \n- value: A string representing a duration in one of the supported formats.\n\nOutputs: \n- A datetime.timedelta object representing the duration parsed from the input string. If the input string does not match any of the supported formats, the function may return None or raise an exception, though the exact behavior is not specified in the given code snippet.", "method_code_mask": "import datetime\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.timezone import get_fixed_timezone\n\n\ndef parse_duration(value): [MASK]\n"}
{"method_name": "parse_color_setting", "full_method_name": "parse_color_setting", "method_path": "../srcdata/Network/django/django/utils/termcolors.py", "method_code": "\ndef parse_color_setting(config_string):\n    \"\"\"Parse a DJANGO_COLORS environment variable to produce the system palette\n\n    The general form of a palette definition is:\n\n        \"palette;role=fg;role=fg/bg;role=fg,option,option;role=fg/bg,option,option\"\n\n    where:\n        palette is a named palette; one of 'light', 'dark', or 'nocolor'.\n        role is a named style used by Django\n        fg is a foreground color.\n        bg is a background color.\n        option is a display options.\n\n    Specifying a named palette is the same as manually specifying the individual\n    definitions for each role. Any individual definitions following the palette\n    definition will augment the base palette definition.\n\n    Valid roles:\n        'error', 'success', 'warning', 'notice', 'sql_field', 'sql_coltype',\n        'sql_keyword', 'sql_table', 'http_info', 'http_success',\n        'http_redirect', 'http_not_modified', 'http_bad_request',\n        'http_not_found', 'http_server_error', 'migrate_heading',\n        'migrate_label'\n\n    Valid colors:\n        'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'\n\n    Valid options:\n        'bold', 'underscore', 'blink', 'reverse', 'conceal', 'noreset'\n    \"\"\"\n    if not config_string:\n        return PALETTES[DEFAULT_PALETTE]\n    parts = config_string.lower().split(';')\n    palette = PALETTES[NOCOLOR_PALETTE].copy()\n    for part in parts:\n        if part in PALETTES:\n            palette.update(PALETTES[part])\n        elif '=' in part:\n            definition = {}\n            role, instructions = part.split('=')\n            role = role.upper()\n            styles = instructions.split(',')\n            styles.reverse()\n            colors = styles.pop().split('/')\n            colors.reverse()\n            fg = colors.pop()\n            if fg in color_names:\n                definition['fg'] = fg\n            if colors and colors[-1] in color_names:\n                definition['bg'] = colors[-1]\n            opts = tuple(s for s in styles if s in opt_dict)\n            if opts:\n                definition['opts'] = opts\n            if role in PALETTES[NOCOLOR_PALETTE] and definition:\n                palette[role] = definition\n    if palette == PALETTES[NOCOLOR_PALETTE]:\n        return None\n    return palette", "test_code_list": [{"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_empty_string(self):\n        self.assertEqual(parse_color_setting(''), PALETTES[DEFAULT_PALETTE])\n    \nTermColorTests().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_simple_palette(self):\n        self.assertEqual(parse_color_setting('light'), PALETTES[LIGHT_PALETTE])\n        self.assertEqual(parse_color_setting('dark'), PALETTES[DARK_PALETTE])\n        self.assertIsNone(parse_color_setting('nocolor'))\n    \nTermColorTests().test_simple_palette()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_fg(self):\n        self.assertEqual(parse_color_setting('error=green'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n    \nTermColorTests().test_fg()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_fg_bg(self):\n        self.assertEqual(parse_color_setting('error=green/blue'), dict(PALETTES\n            [NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue'}))\n    \nTermColorTests().test_fg_bg()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_fg_opts(self):\n        self.assertEqual(parse_color_setting('error=green,blink'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',)}))\n        self.assertEqual(parse_color_setting('error=green,bold,blink'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',\n            'bold')}))\n    \nTermColorTests().test_fg_opts()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_fg_bg_opts(self):\n        self.assertEqual(parse_color_setting('error=green/blue,blink'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue',\n            'opts': ('blink',)}))\n        self.assertEqual(parse_color_setting('error=green/blue,bold,blink'),\n            dict(PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue',\n            'opts': ('blink', 'bold')}))\n    \nTermColorTests().test_fg_bg_opts()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_override_palette(self):\n        self.assertEqual(parse_color_setting('light;error=green'), dict(\n            PALETTES[LIGHT_PALETTE], ERROR={'fg': 'green'}))\n    \nTermColorTests().test_override_palette()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_override_nocolor(self):\n        self.assertEqual(parse_color_setting('nocolor;error=green'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n    \nTermColorTests().test_override_nocolor()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_reverse_override(self):\n        self.assertEqual(parse_color_setting('error=green;light'), PALETTES[\n            LIGHT_PALETTE])\n    \nTermColorTests().test_reverse_override()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_multiple_roles(self):\n        self.assertEqual(parse_color_setting('error=green;sql_field=blue'),\n            dict(PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green'}, SQL_FIELD={\n            'fg': 'blue'}))\n    \nTermColorTests().test_multiple_roles()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_override_with_multiple_roles(self):\n        self.assertEqual(parse_color_setting('light;error=green;sql_field=blue'\n            ), dict(PALETTES[LIGHT_PALETTE], ERROR={'fg': 'green'}, SQL_FIELD={\n            'fg': 'blue'}))\n    \nTermColorTests().test_override_with_multiple_roles()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_empty_definition(self):\n        self.assertIsNone(parse_color_setting(';'))\n        self.assertEqual(parse_color_setting('light;'), PALETTES[LIGHT_PALETTE])\n        self.assertIsNone(parse_color_setting(';;;'))\n    \nTermColorTests().test_empty_definition()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_empty_options(self):\n        self.assertEqual(parse_color_setting('error=green,'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=green,,,'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=green,,blink,,'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',)}))\n    \nTermColorTests().test_empty_options()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_bad_palette(self):\n        self.assertIsNone(parse_color_setting('unknown'))\n    \nTermColorTests().test_bad_palette()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_bad_role(self):\n        self.assertIsNone(parse_color_setting('unknown='))\n        self.assertIsNone(parse_color_setting('unknown=green'))\n        self.assertEqual(parse_color_setting('unknown=green;sql_field=blue'),\n            dict(PALETTES[NOCOLOR_PALETTE], SQL_FIELD={'fg': 'blue'}))\n    \nTermColorTests().test_bad_role()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_bad_color(self):\n        self.assertIsNone(parse_color_setting('error='))\n        self.assertEqual(parse_color_setting('error=;sql_field=blue'), dict(\n            PALETTES[NOCOLOR_PALETTE], SQL_FIELD={'fg': 'blue'}))\n        self.assertIsNone(parse_color_setting('error=unknown'))\n        self.assertEqual(parse_color_setting('error=unknown;sql_field=blue'),\n            dict(PALETTES[NOCOLOR_PALETTE], SQL_FIELD={'fg': 'blue'}))\n        self.assertEqual(parse_color_setting('error=green/unknown'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=green/blue/something'),\n            dict(PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue'}))\n        self.assertEqual(parse_color_setting('error=green/blue/something,blink'\n            ), dict(PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg':\n            'blue', 'opts': ('blink',)}))\n    \nTermColorTests().test_bad_color()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_bad_option(self):\n        self.assertEqual(parse_color_setting('error=green,unknown'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=green,unknown,blink'), dict\n            (PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',)}))\n    \nTermColorTests().test_bad_option()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_role_case(self):\n        self.assertEqual(parse_color_setting('ERROR=green'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('eRrOr=green'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n    \nTermColorTests().test_role_case()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_color_case(self):\n        self.assertEqual(parse_color_setting('error=GREEN'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=GREEN/BLUE'), dict(PALETTES\n            [NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue'}))\n        self.assertEqual(parse_color_setting('error=gReEn'), dict(PALETTES[\n            NOCOLOR_PALETTE], ERROR={'fg': 'green'}))\n        self.assertEqual(parse_color_setting('error=gReEn/bLuE'), dict(PALETTES\n            [NOCOLOR_PALETTE], ERROR={'fg': 'green', 'bg': 'blue'}))\n    \nTermColorTests().test_color_case()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}, {"test_code": "import unittest\nfrom django.utils.termcolors import DARK_PALETTE\nfrom django.utils.termcolors import DEFAULT_PALETTE\nfrom django.utils.termcolors import LIGHT_PALETTE\nfrom django.utils.termcolors import NOCOLOR_PALETTE\nfrom django.utils.termcolors import PALETTES\nfrom django.utils.termcolors import colorize\nfrom django.utils.termcolors import parse_color_setting\n\nclass TermColorTests(unittest.TestCase):\n    def test_opts_case(self):\n        self.assertEqual(parse_color_setting('error=green,BLINK'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',)}))\n        self.assertEqual(parse_color_setting('error=green,bLiNk'), dict(\n            PALETTES[NOCOLOR_PALETTE], ERROR={'fg': 'green', 'opts': ('blink',)}))\n    \nTermColorTests().test_opts_case()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_termcolors.py"}], "instruction": "Functionality: This function parses a string representing color settings for a system's palette. It interprets a DJANGO_COLORS environment variable to produce a dictionary representing the system palette, which includes foreground, background colors, and display options for various system roles.\n\nInputs: \n- `config_string`: A string following the format \"palette;role=fg;role=fg/bg;role=fg,option,option;role=fg/bg,option,option\". This string contains color settings for roles, defined by foreground and background colors as well as display options. \n\nOutputs: \n- Returns a dictionary representing the system palette, where keys are role names and values are dictionaries containing 'fg' (foreground color), 'bg' (background color), and 'opts' (display options) for each role. If the resulting palette is identical to the default palette (`PALETTES[NOCOLOR_PALETTE]`), it returns None.", "method_code_mask": "def parse_color_setting(config_string): [MASK]\n"}
{"method_name": "format_html", "full_method_name": "format_html", "method_path": "../srcdata/Network/django/django/utils/html.py", "method_code": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\ndef format_html(format_string, *args, **kwargs):\n    \"\"\"\n    Similar to str.format, but pass all arguments through conditional_escape(),\n    and call mark_safe() on the result. This function should be used instead\n    of str.format or % interpolation to build up small HTML fragments.\n    \"\"\"\n    if not (args or kwargs):\n        warnings.warn(\n            'Calling format_html() without passing args or kwargs is deprecated.'\n            , RemovedInDjango60Warning)\n    args_safe = map(conditional_escape, args)\n    kwargs_safe = {k: conditional_escape(v) for k, v in kwargs.items()}\n    return mark_safe(format_string.format(*args_safe, **kwargs_safe))", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_format_html(self):\n        self.assertEqual(format_html('{} {} {third} {fourth}', '< Dangerous >',\n            mark_safe('<b>safe</b>'), third='< dangerous again', fourth=\n            mark_safe('<i>safe again</i>')),\n            '&lt; Dangerous &gt; <b>safe</b> &lt; dangerous again <i>safe again</i>'\n            )\n    \nTestUtilsHtml().test_format_html()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}], "instruction": "Functionality: The format_html function is a utility for safely formatting HTML strings with custom content. It is designed to prevent HTML injection by escaping any potentially dangerous characters in the input arguments and then marking the resulting string as safe for HTML use. This function is particularly useful for building up small HTML fragments, ensuring that any variables inserted into the string do not contain HTML entities that could be misinterpreted by the browser.\n\nInputs: \n- format_string: A string containing placeholders in the format of str.format(), which will be replaced by the corresponding arguments.\n- *args: Variable length argument list, which will be used to replace placeholders in the format_string.\n- **kwargs: Arbitrary keyword arguments, which also will be used to replace placeholders in the format_string.\n\nOutputs:\n- A string that is marked as safe for HTML use, meaning it has been escaped where necessary to prevent HTML injection, and it can be safely embedded in HTML code.", "method_code_mask": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\ndef format_html(format_string, *args, **kwargs): [MASK]\n"}
{"method_name": "json_script", "full_method_name": "json_script", "method_path": "../srcdata/Network/django/django/utils/html.py", "method_code": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\ndef json_script(value, element_id=None, encoder=None):\n    \"\"\"\n    Escape all the HTML/XML special characters with their unicode escapes, so\n    value is safe to be output anywhere except for inside a tag attribute. Wrap\n    the escaped JSON in a script tag.\n    \"\"\"\n    from django.core.serializers.json import DjangoJSONEncoder\n    json_str = json.dumps(value, cls=encoder or DjangoJSONEncoder).translate(\n        _json_script_escapes)\n    if element_id:\n        template = '<script id=\"{}\" type=\"application/json\">{}</script>'\n        args = element_id, mark_safe(json_str)\n    else:\n        template = '<script type=\"application/json\">{}</script>'\n        args = mark_safe(json_str),\n    return format_html(template, *args)", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_json_script(self):\n        tests = ('&<>',\n            '<script id=\"test_id\" type=\"application/json\">\"\\\\u0026\\\\u003C\\\\u003E\"</script>'\n            ), ({'a': '<script>test&ing</script>'},\n            '<script id=\"test_id\" type=\"application/json\">{\"a\": \"\\\\u003Cscript\\\\u003Etest\\\\u0026ing\\\\u003C/script\\\\u003E\"}</script>'\n            ), (lazystr('&<>'),\n            '<script id=\"test_id\" type=\"application/json\">\"\\\\u0026\\\\u003C\\\\u003E\"</script>'\n            ), ({'a': lazystr('<script>test&ing</script>')},\n            '<script id=\"test_id\" type=\"application/json\">{\"a\": \"\\\\u003Cscript\\\\u003Etest\\\\u0026ing\\\\u003C/script\\\\u003E\"}</script>'\n            )\n        for arg, expected in tests:\n            with self.subTest(arg=arg):\n                self.assertEqual(json_script(arg, 'test_id'), expected)\n    \nTestUtilsHtml().test_json_script()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_json_script_custom_encoder(self):\n    \n    \n        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n    \n            def encode(self, o):\n                return '{\"hello\": \"world\"}'\n        self.assertHTMLEqual(json_script({}, encoder=CustomDjangoJSONEncoder),\n            '<script type=\"application/json\">{\"hello\": \"world\"}</script>')\n    \nTestUtilsHtml().test_json_script_custom_encoder()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_json_script_without_id(self):\n        self.assertHTMLEqual(json_script({'key': 'value'}),\n            '<script type=\"application/json\">{\"key\": \"value\"}</script>')\n    \nTestUtilsHtml().test_json_script_without_id()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}], "instruction": "Functionality: Generate a script tag containing a JSON string that is safe for HTML output. The function escapes HTML/XML special characters for the provided value, converts it to a JSON string, and wraps it in a script tag. If an element_id is provided, it is used as the ID for the script tag.\n\nInputs: \n- value: The data to be converted into a JSON string and output in a script tag. This should be a data structure that can be serialized to JSON.\n- element_id: An optional ID to be given to the script tag. If provided, it must be a string.\n- encoder: An optional custom JSON encoder. If not provided, DjangoJSONEncoder from django.core.serializers.json will be used.\n\nOutputs:\n- A string containing an HTML script tag. The script tag contains the provided value serialized as a JSON object and escaped to be safe for HTML output. If element_id was provided, the script tag will have this ID.", "method_code_mask": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\ndef json_script(value, element_id=None, encoder=None): [MASK]\n"}
{"method_name": "smart_urlquote", "full_method_name": "smart_urlquote", "method_path": "../srcdata/Network/django/django/utils/html.py", "method_code": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\ndef smart_urlquote(url):\n    \"\"\"Quote a URL if it isn't already quoted.\"\"\"\n\n    def unquote_quote(segment):\n        segment = unquote(segment)\n        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + '~')\n    try:\n        scheme, netloc, path, query, fragment = urlsplit(url)\n    except ValueError:\n        return unquote_quote(url)\n    try:\n        netloc = punycode(netloc)\n    except UnicodeError:\n        return unquote_quote(url)\n    if query:\n        query_parts = [(unquote(q[0]), unquote(q[1])) for q in parse_qsl(\n            query, keep_blank_values=True)]\n        query = urlencode(query_parts)\n    path = unquote_quote(path)\n    fragment = unquote_quote(fragment)\n    return urlunsplit((scheme, netloc, path, query, fragment))", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_smart_urlquote(self):\n        items = ('http://\u00f6\u00e4\u00fc.com/', 'http://xn--4ca9at.com/'), (\n            'http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/', 'http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/'), (\n            'http://example.com/path/\u00f6\u00e4\u00fc/',\n            'http://example.com/path/%C3%B6%C3%A4%C3%BC/'), (\n            'http://example.com/%C3%B6/\u00e4/', 'http://example.com/%C3%B6/%C3%A4/'), (\n            'http://example.com/?x=1&y=2+3&z=', 'http://example.com/?x=1&y=2+3&z='\n            ), ('http://example.com/?x=<>\"\\'', 'http://example.com/?x=%3C%3E%22%27'\n            ), ('http://example.com/?q=http://example.com/?x=1%26q=django',\n            'http://example.com/?q=http%3A%2F%2Fexample.com%2F%3Fx%3D1%26q%3Ddjango'\n            ), (\n            'http://example.com/?q=http%3A%2F%2Fexample.com%2F%3Fx%3D1%26q%3Ddjango'\n            ,\n            'http://example.com/?q=http%3A%2F%2Fexample.com%2F%3Fx%3D1%26q%3Ddjango'\n            ), ('http://.www.f oo.bar/', 'http://.www.f%20oo.bar/')\n        for value, output in items:\n            with self.subTest(value=value, output=output):\n                self.assertEqual(smart_urlquote(value), output)\n    \nTestUtilsHtml().test_smart_urlquote()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}], "instruction": "Functionality: The smart_urlquote function takes a URL as input and returns a properly quoted URL. It ensures that if the input URL is not already quoted, it gets quoted according to RFC 3986 internet standard, making it safe for use in URLs. This function handles quoting of segments of the URL including the scheme, network location (netloc), path, query parameters, and fragment identifiers.\n\nInputs: \n- url: A string representing the URL to be quoted. This URL can be in any format, including those already quoted or unquoted, using Unicode or punycode for network locations.\n\nOutputs:\n- A string representing the quoted URL. If the input URL is already properly quoted, it will be returned unchanged. Otherwise, the function will return a new string where each segment of the URL is properly quoted, ensuring compatibility with URL standards.", "method_code_mask": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\ndef smart_urlquote(url): [MASK]\n"}
{"method_name": "conditional_escape", "full_method_name": "conditional_escape", "method_path": "../srcdata/Network/django/django/utils/html.py", "method_code": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\ndef conditional_escape(text):\n    \"\"\"\n    Similar to escape(), except that it doesn't operate on pre-escaped strings.\n\n    This function relies on the __html__ convention used both by Django's\n    SafeData class and by third-party libraries like markupsafe.\n    \"\"\"\n    if isinstance(text, Promise):\n        text = str(text)\n    if hasattr(text, '__html__'):\n        return text.__html__()\n    else:\n        return escape(text)", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_conditional_escape(self):\n        s = '<h1>interop</h1>'\n        self.assertEqual(conditional_escape(s), '&lt;h1&gt;interop&lt;/h1&gt;')\n        self.assertEqual(conditional_escape(mark_safe(s)), s)\n        self.assertEqual(conditional_escape(lazystr(mark_safe(s))), s)\n    \nTestUtilsHtml().test_conditional_escape()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "import os\nfrom django.contrib.auth import validators\nfrom django.contrib.auth.password_validation import CommonPasswordValidator\nfrom django.contrib.auth.password_validation import MinimumLengthValidator\nfrom django.contrib.auth.password_validation import NumericPasswordValidator\nfrom django.contrib.auth.password_validation import UserAttributeSimilarityValidator\nfrom django.contrib.auth.password_validation import get_default_password_validators\nfrom django.contrib.auth.password_validation import get_password_validators\nfrom django.contrib.auth.password_validation import password_changed\nfrom django.contrib.auth.password_validation import password_validators_help_text_html\nfrom django.contrib.auth.password_validation import password_validators_help_texts\nfrom django.contrib.auth.password_validation import validate_password\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import isolate_apps\nfrom django.utils.html import conditional_escape\n\nclass PasswordValidationTest(SimpleTestCase):\n    def test_password_validators_help_text_html_escaping(self):\n    \n    \n        class AmpersandValidator:\n    \n            def get_help_text(self):\n                return 'Must contain &'\n        help_text = password_validators_help_text_html([AmpersandValidator()])\n        self.assertEqual(help_text, '<ul><li>Must contain &amp;</li></ul>')\n        self.assertEqual(help_text, conditional_escape(help_text))\n    \nPasswordValidationTest().test_password_validators_help_text_html_escaping()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/auth_tests/test_validators.py"}], "instruction": "Functionality: The conditional_escape function is designed to escape HTML characters in a given text string, but it avoids operating on strings that are already pre-escaped. It checks if the input obeys the __html__ convention used by Django's SafeData class or by third-party libraries like markupsafe. If the input has a __html__ method, it will call that method; otherwise, it will escape the HTML characters in the input string using the escape function.\n\nInputs: \n- text: A string or an object that may or may not have a __html__ method. This could be a plain string, a SafeData object, or any other object that might implement the __html__ method.\n\nOutputs:\n- If the input text object has a __html__ method, the function returns the result of calling that method on the text object.\n- If the input text does not have a __html__ method, the function returns the result of the escape function applied to the input text, which escapes HTML characters to prevent them from being interpreted as HTML by the browser, thus enhancing security.", "method_code_mask": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\ndef conditional_escape(text): [MASK]\n"}
{"method_name": "urlize", "full_method_name": "urlize", "method_path": "../srcdata/Network/django/django/utils/html.py", "method_code": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n@keep_lazy_text\ndef urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n    return urlizer(text, trim_url_limit=trim_url_limit, nofollow=nofollow,\n        autoescape=autoescape)", "test_code_list": [{"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_urlize(self):\n        tests = ('Search for google.com/?q=! and see.',\n            'Search for <a href=\"http://google.com/?q=\">google.com/?q=</a>! and see.'\n            ), ('Search for google.com/?q=1&lt! and see.',\n            'Search for <a href=\"http://google.com/?q=1%3C\">google.com/?q=1&lt</a>! and see.'\n            ), (lazystr('Search for google.com/?q=!'),\n            'Search for <a href=\"http://google.com/?q=\">google.com/?q=</a>!'), (\n            'foo@example.com',\n            '<a href=\"mailto:foo@example.com\">foo@example.com</a>')\n        for value, output in tests:\n            with self.subTest(value=value):\n                self.assertEqual(urlize(value), output)\n    \nTestUtilsHtml().test_urlize()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}, {"test_code": "import os\nfrom datetime import datetime\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.html import json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import smart_urlquote\nfrom django.utils.html import strip_spaces_between_tags\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize\nfrom django.utils.safestring import mark_safe\n\nclass TestUtilsHtml(SimpleTestCase):\n    def test_urlize_unchanged_inputs(self):\n        tests = ('a' + '@a' * 50000 + 'a', 'a' + '.' * 1000000 + 'a', 'foo@',\n            '@foo.com', 'foo@.example.com', 'foo@localhost', 'foo@localhost.')\n        for value in tests:\n            with self.subTest(value=value):\n                self.assertEqual(urlize(value), value)\n    \nTestUtilsHtml().test_urlize_unchanged_inputs()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_html.py"}], "instruction": "Functionality: The urlize function is designed to convert plain text containing URLs into clickable links. It parses the given text, identifies URLs, and wraps them in HTML anchor tags, making them suitable for web display. The function also has options to trim long URLs, add 'nofollow' attributes to anchor tags for SEO purposes, and activate autoescaping for HTML entities.\n\nInputs: \n1. text: A string containing the plain text that may include URLs. This is the primary input for the function to process.\n2. trim_url_limit: An optional integer that defines the maximum length of the URL. If the URL is longer than this limit, it will be trimmed.\n3. nofollow: A boolean value to determine whether 'nofollow' should be added as an attribute to the anchor tags. This is useful for informing search engines not to follow the links for SEO ranking purposes.\n4. autoescape: A boolean value to enable autoescaping of HTML entities in the output text. This is a safety measure to prevent HTML injection attacks.\n\nOutputs:\n1. A string with URLs converted to clickable HTML links. The resulting string is safe for embedding in web pages, as it may include HTML tags and escaped entities, depending on the 'autoescape' parameter.", "method_code_mask": "import html\nimport json\nimport re\nimport warnings\nfrom html.parser import HTMLParser\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom django.utils.encoding import punycode\nfrom django.utils.functional import Promise\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.http import RFC3986_GENDELIMS\nfrom django.utils.http import RFC3986_SUBDELIMS\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import normalize_newlines\nfrom django.core.serializers.json import DjangoJSONEncoder\n\n\n@keep_lazy_text\ndef urlize(text, trim_url_limit=None, nofollow=False, autoescape=False): [MASK]\n"}
{"method_name": "lazy", "full_method_name": "lazy", "method_path": "../srcdata/Network/django/django/utils/functional.py", "method_code": "import copy\nimport itertools\nimport operator\nfrom functools import wraps\ndef lazy(func, *resultclasses):\n    \"\"\"\n    Turn any callable into a lazy evaluated callable. result classes or types\n    is required -- at least one is needed so that the automatic forcing of\n    the lazy evaluation code is triggered. Results are not memoized; the\n    function is evaluated on every access.\n    \"\"\"\n\n\n    class __proxy__(Promise):\n        \"\"\"\n        Encapsulate a function call and act as a proxy for methods that are\n        called on the result of that function. The function is not evaluated\n        until one of the methods on the result is called.\n        \"\"\"\n\n        def __init__(self, args, kw):\n            self._args = args\n            self._kw = kw\n\n        def __reduce__(self):\n            return _lazy_proxy_unpickle, (func, self._args, self._kw\n                ) + resultclasses\n\n        def __deepcopy__(self, memo):\n            memo[id(self)] = self\n            return self\n\n        def __cast(self):\n            return func(*self._args, **self._kw)\n\n        def __repr__(self):\n            return repr(self.__cast())\n\n        def __str__(self):\n            return str(self.__cast())\n\n        def __eq__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() == other\n\n        def __ne__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() != other\n\n        def __lt__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() < other\n\n        def __le__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() <= other\n\n        def __gt__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() > other\n\n        def __ge__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() >= other\n\n        def __hash__(self):\n            return hash(self.__cast())\n\n        def __format__(self, format_spec):\n            return format(self.__cast(), format_spec)\n\n        def __add__(self, other):\n            return self.__cast() + other\n\n        def __radd__(self, other):\n            return other + self.__cast()\n\n        def __mod__(self, other):\n            return self.__cast() % other\n\n        def __mul__(self, other):\n            return self.__cast() * other\n    for resultclass in resultclasses:\n        for type_ in resultclass.mro():\n            for method_name in type_.__dict__:\n                if hasattr(__proxy__, method_name):\n                    continue\n\n                def __wrapper__(self, *args, __method_name=method_name, **kw):\n                    result = func(*self._args, **self._kw)\n                    return getattr(result, __method_name)(*args, **kw)\n                setattr(__proxy__, method_name, __wrapper__)\n\n    @wraps(func)\n    def __wrapper__(*args, **kw):\n        return __proxy__(args, kw)\n    return __wrapper__", "test_code_list": [{"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy(self):\n        t = lazy(lambda : tuple(range(3)), list, tuple)\n        for a, b in zip(t(), range(3)):\n            self.assertEqual(a, b)\n    \nFunctionalTests().test_lazy()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_base_class(self):\n        \"\"\"lazy also finds base class methods in the proxy object\"\"\"\n    \n    \n        class Base:\n    \n            def base_method(self):\n                pass\n    \n    \n        class Klazz(Base):\n            pass\n        t = lazy(lambda : Klazz(), Klazz)()\n        self.assertIn('base_method', dir(t))\n    \nFunctionalTests().test_lazy_base_class()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_base_class_override(self):\n        \"\"\"lazy finds the correct (overridden) method implementation\"\"\"\n    \n    \n        class Base:\n    \n            def method(self):\n                return 'Base'\n    \n    \n        class Klazz(Base):\n    \n            def method(self):\n                return 'Klazz'\n        t = lazy(lambda : Klazz(), Base)()\n        self.assertEqual(t.method(), 'Klazz')\n    \nFunctionalTests().test_lazy_base_class_override()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_object_to_string(self):\n    \n    \n        class Klazz:\n    \n            def __str__(self):\n                return '\u00ce am \u0101 \u01e8l\u00e2zz.'\n    \n            def __bytes__(self):\n                return b'\\xc3\\x8e am \\xc4\\x81 binary \\xc7\\xa8l\\xc3\\xa2zz.'\n        t = lazy(lambda : Klazz(), Klazz)()\n        self.assertEqual(str(t), '\u00ce am \u0101 \u01e8l\u00e2zz.')\n        self.assertEqual(bytes(t),\n            b'\\xc3\\x8e am \\xc4\\x81 binary \\xc7\\xa8l\\xc3\\xa2zz.')\n    \nFunctionalTests().test_lazy_object_to_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_add_int(self):\n        lazy_4 = lazy(lambda : 4, int)\n        lazy_5 = lazy(lambda : 5, int)\n        self.assertEqual(4 + lazy_5(), 9)\n        self.assertEqual(lazy_4() + 5, 9)\n        self.assertEqual(lazy_4() + lazy_5(), 9)\n    \nFunctionalTests().test_lazy_add_int()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_add_list(self):\n        lazy_4 = lazy(lambda : [4], list)\n        lazy_5 = lazy(lambda : [5], list)\n        self.assertEqual([4] + lazy_5(), [4, 5])\n        self.assertEqual(lazy_4() + [5], [4, 5])\n        self.assertEqual(lazy_4() + lazy_5(), [4, 5])\n    \nFunctionalTests().test_lazy_add_list()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_add_str(self):\n        lazy_a = lazy(lambda : 'a', str)\n        lazy_b = lazy(lambda : 'b', str)\n        self.assertEqual('a' + lazy_b(), 'ab')\n        self.assertEqual(lazy_a() + 'b', 'ab')\n        self.assertEqual(lazy_a() + lazy_b(), 'ab')\n    \nFunctionalTests().test_lazy_add_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_mod_int(self):\n        lazy_4 = lazy(lambda : 4, int)\n        lazy_5 = lazy(lambda : 5, int)\n        self.assertEqual(4 % lazy_5(), 4)\n        self.assertEqual(lazy_4() % 5, 4)\n        self.assertEqual(lazy_4() % lazy_5(), 4)\n    \nFunctionalTests().test_lazy_mod_int()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_mod_str(self):\n        lazy_a = lazy(lambda : 'a%s', str)\n        lazy_b = lazy(lambda : 'b', str)\n        self.assertEqual('a%s' % lazy_b(), 'ab')\n        self.assertEqual(lazy_a() % 'b', 'ab')\n        self.assertEqual(lazy_a() % lazy_b(), 'ab')\n    \nFunctionalTests().test_lazy_mod_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_mul_list(self):\n        lazy_4 = lazy(lambda : [4], list)\n        lazy_5 = lazy(lambda : 5, int)\n        self.assertEqual([4] * lazy_5(), [4, 4, 4, 4, 4])\n        self.assertEqual(lazy_4() * 5, [4, 4, 4, 4, 4])\n        self.assertEqual(lazy_4() * lazy_5(), [4, 4, 4, 4, 4])\n    \nFunctionalTests().test_lazy_mul_list()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_mul_str(self):\n        lazy_a = lazy(lambda : 'a', str)\n        lazy_5 = lazy(lambda : 5, int)\n        self.assertEqual('a' * lazy_5(), 'aaaaa')\n        self.assertEqual(lazy_a() * 5, 'aaaaa')\n        self.assertEqual(lazy_a() * lazy_5(), 'aaaaa')\n    \nFunctionalTests().test_lazy_mul_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_equality(self):\n        \"\"\"\n            == and != work correctly for Promises.\n            \"\"\"\n        lazy_a = lazy(lambda : 4, int)\n        lazy_b = lazy(lambda : 4, int)\n        lazy_c = lazy(lambda : 5, int)\n        self.assertEqual(lazy_a(), lazy_b())\n        self.assertNotEqual(lazy_b(), lazy_c())\n    \nFunctionalTests().test_lazy_equality()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_repr_text(self):\n        original_object = 'Lazy translation text'\n        lazy_obj = lazy(lambda : original_object, str)\n        self.assertEqual(repr(original_object), repr(lazy_obj()))\n    \nFunctionalTests().test_lazy_repr_text()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_repr_int(self):\n        original_object = 15\n        lazy_obj = lazy(lambda : original_object, int)\n        self.assertEqual(repr(original_object), repr(lazy_obj()))\n    \nFunctionalTests().test_lazy_repr_int()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_repr_bytes(self):\n        original_object = b'J\\xc3\\xbcst a str\\xc3\\xadng'\n        lazy_obj = lazy(lambda : original_object, bytes)\n        self.assertEqual(repr(original_object), repr(lazy_obj()))\n    \nFunctionalTests().test_lazy_repr_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.test import SimpleTestCase\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import classproperty\nfrom django.utils.functional import lazy\nfrom django.utils.version import PY312\n\nclass FunctionalTests(SimpleTestCase):\n    def test_lazy_regular_method(self):\n        original_object = 15\n        lazy_obj = lazy(lambda : original_object, int)\n        self.assertEqual(original_object.bit_length(), lazy_obj().bit_length())\n    \nFunctionalTests().test_lazy_regular_method()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_functional.py"}, {"test_code": "from django.template import Context\nfrom django.template import Template\nfrom django.test import SimpleTestCase\nfrom django.utils import html\nfrom django.utils import translation\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.functional import lazystr\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass SafeStringTest(SimpleTestCase):\n    def test_mark_safe_decorator_does_not_affect_promises(self):\n        \"\"\"\n            mark_safe doesn't affect lazy strings (Promise objects).\n            \"\"\"\n    \n        def html_str():\n            return '<html></html>'\n        lazy_str = lazy(html_str, str)()\n        self.assertEqual(mark_safe(lazy_str), html_str())\n    \nSafeStringTest().test_mark_safe_decorator_does_not_affect_promises()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_safestring.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_AutoField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(AutoField(primary_key=True).get_prep_value(\n            lazy_func()), int)\n    \nPromiseTest().test_AutoField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_BinaryField(self):\n        lazy_func = lazy(lambda : b'', bytes)\n        self.assertIsInstance(BinaryField().get_prep_value(lazy_func()), bytes)\n    \nPromiseTest().test_BinaryField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_BooleanField(self):\n        lazy_func = lazy(lambda : True, bool)\n        self.assertIsInstance(BooleanField().get_prep_value(lazy_func()), bool)\n    \nPromiseTest().test_BooleanField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_CharField(self):\n        lazy_func = lazy(lambda : '', str)\n        self.assertIsInstance(CharField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(CharField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_CharField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_DateField(self):\n        lazy_func = lazy(lambda : datetime.date.today(), datetime.date)\n        self.assertIsInstance(DateField().get_prep_value(lazy_func()), datetime\n            .date)\n    \nPromiseTest().test_DateField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_DecimalField(self):\n        lazy_func = lazy(lambda : Decimal('1.2'), Decimal)\n        self.assertIsInstance(DecimalField().get_prep_value(lazy_func()), Decimal)\n    \nPromiseTest().test_DecimalField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_EmailField(self):\n        lazy_func = lazy(lambda : 'mailbox@domain.com', str)\n        self.assertIsInstance(EmailField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_EmailField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_FileField(self):\n        lazy_func = lazy(lambda : 'filename.ext', str)\n        self.assertIsInstance(FileField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(FileField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_FileField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_FilePathField(self):\n        lazy_func = lazy(lambda : 'tests.py', str)\n        self.assertIsInstance(FilePathField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(FilePathField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_FilePathField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_FloatField(self):\n        lazy_func = lazy(lambda : 1.2, float)\n        self.assertIsInstance(FloatField().get_prep_value(lazy_func()), float)\n    \nPromiseTest().test_FloatField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_ImageField(self):\n        lazy_func = lazy(lambda : 'filename.ext', str)\n        self.assertIsInstance(ImageField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_ImageField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_IntegerField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(IntegerField().get_prep_value(lazy_func()), int)\n    \nPromiseTest().test_IntegerField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_IPAddressField(self):\n        lazy_func = lazy(lambda : '127.0.0.1', str)\n        self.assertIsInstance(IPAddressField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(IPAddressField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_IPAddressField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_GenericIPAddressField(self):\n        lazy_func = lazy(lambda : '127.0.0.1', str)\n        self.assertIsInstance(GenericIPAddressField().get_prep_value(lazy_func(\n            )), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(GenericIPAddressField().get_prep_value(lazy_func(\n            )), str)\n    \nPromiseTest().test_GenericIPAddressField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_PositiveIntegerField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(PositiveIntegerField().get_prep_value(lazy_func()\n            ), int)\n    \nPromiseTest().test_PositiveIntegerField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_PositiveSmallIntegerField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(PositiveSmallIntegerField().get_prep_value(\n            lazy_func()), int)\n    \nPromiseTest().test_PositiveSmallIntegerField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_PositiveBigIntegerField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(PositiveBigIntegerField().get_prep_value(\n            lazy_func()), int)\n    \nPromiseTest().test_PositiveBigIntegerField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_SlugField(self):\n        lazy_func = lazy(lambda : 'slug', str)\n        self.assertIsInstance(SlugField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(SlugField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_SlugField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_SmallIntegerField(self):\n        lazy_func = lazy(lambda : 1, int)\n        self.assertIsInstance(SmallIntegerField().get_prep_value(lazy_func()), int)\n    \nPromiseTest().test_SmallIntegerField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_TextField(self):\n        lazy_func = lazy(lambda : 'Abc', str)\n        self.assertIsInstance(TextField().get_prep_value(lazy_func()), str)\n        lazy_func = lazy(lambda : 0, int)\n        self.assertIsInstance(TextField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_TextField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_TimeField(self):\n        lazy_func = lazy(lambda : datetime.datetime.now().time(), datetime.time)\n        self.assertIsInstance(TimeField().get_prep_value(lazy_func()), datetime\n            .time)\n    \nPromiseTest().test_TimeField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import datetime\nfrom decimal import Decimal\nfrom django.db.models import AutoField\nfrom django.db.models import BinaryField\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import DecimalField\nfrom django.db.models import EmailField\nfrom django.db.models import FileField\nfrom django.db.models import FilePathField\nfrom django.db.models import FloatField\nfrom django.db.models import GenericIPAddressField\nfrom django.db.models import ImageField\nfrom django.db.models import IntegerField\nfrom django.db.models import IPAddressField\nfrom django.db.models import PositiveBigIntegerField\nfrom django.db.models import PositiveIntegerField\nfrom django.db.models import PositiveSmallIntegerField\nfrom django.db.models import SlugField\nfrom django.db.models import SmallIntegerField\nfrom django.db.models import TextField\nfrom django.db.models import TimeField\nfrom django.db.models import URLField\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass PromiseTest(SimpleTestCase):\n    def test_URLField(self):\n        lazy_func = lazy(lambda : 'http://domain.com', str)\n        self.assertIsInstance(URLField().get_prep_value(lazy_func()), str)\n    \nPromiseTest().test_URLField()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/test_promises.py"}, {"test_code": "import pickle\nfrom django import forms\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.utils.functional import lazy\n\nclass GetChoicesTests(SimpleTestCase):\n    def test_lazy_strings_not_evaluated(self):\n        lazy_func = lazy(lambda x: 0 / 0, int)\n        f = models.CharField(choices=[(lazy_func('group'), [('a', 'A'), ('b',\n            'B')])])\n        self.assertEqual(f.get_choices(include_blank=True)[0], ('', '---------'))\n    \nGetChoicesTests().test_lazy_strings_not_evaluated()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_fields/tests.py"}, {"test_code": "from django.template.defaultfilters import escapejs_filter\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\n\nclass FunctionTests(SimpleTestCase):\n    def test_lazy_string(self):\n        append_script = lazy(lambda string: '<script>this</script>' + string, str)\n        self.assertEqual(escapejs_filter(append_script(\n            'whitespace: \\r\\n\\t\\x0b\\x0c\\x08')),\n            '\\\\u003Cscript\\\\u003Ethis\\\\u003C/script\\\\u003Ewhitespace: \\\\u000D\\\\u000A\\\\u0009\\\\u000B\\\\u000C\\\\u0008'\n            )\n    \nFunctionTests().test_lazy_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_escapejs.py"}, {"test_code": "from django.template.defaultfilters import escape\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import Promise\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\n\nclass EscapeTests(SimpleTestCase):\n    def test_escape_lazy_string(self):\n        add_html = lazy(lambda string: string + 'special characters > here', str)\n        escaped = escape(add_html('<some html & '))\n        self.assertIsInstance(escaped, Promise)\n        self.assertEqual(escaped,\n            '&lt;some html &amp; special characters &gt; here')\n    \nEscapeTests().test_escape_lazy_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_escape.py"}, {"test_code": "from django.template.defaultfilters import urlize\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\n\nclass FunctionTests(SimpleTestCase):\n    def test_lazystring(self):\n        prepend_www = lazy(lambda url: 'www.' + url, str)\n        self.assertEqual(urlize(prepend_www('google.com')),\n            '<a href=\"http://www.google.com\" rel=\"nofollow\">www.google.com</a>')\n    \nFunctionTests().test_lazystring()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_urlize.py"}, {"test_code": "from django.template.defaultfilters import slugify\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\n\nclass FunctionTests(SimpleTestCase):\n    def test_slugify_lazy_string(self):\n        lazy_str = lazy(lambda string: string, str)\n        self.assertEqual(slugify(lazy_str(\n            ' Jack & Jill like numbers 1,2,3 and 4 and silly characters ?%.$!/'\n            )), 'jack-jill-like-numbers-123-and-4-and-silly-characters')\n    \nFunctionTests().test_slugify_lazy_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_slugify.py"}], "instruction": "Functionality: The lazy function is designed to convert any given callable into a lazy evaluated callable. It allows for the deferred execution of the function until one of its result methods is called. This is particularly useful for optimizing performance in scenarios where the function's output might not be immediately required, or when the function is computationally expensive.\n\nInputs: The lazy function takes the following inputs:\n1. func: The function to be lazily evaluated.\n2. resultclasses: A tuple of classes/types that the result of the function will be cast to. At least one result class or type is required to trigger the lazy evaluation mechanism.\n\nOutputs: The lazy function returns a wrapped version of the input function that acts as a proxy for the actual function call. When this wrapped function is invoked, it returns a special __proxy__ object. This object encapsulates the function call and does not evaluate the function immediately. Instead, it evaluates the function when any of the methods of the result are accessed. The result of the function call is then cast to one of the provided resultclasses.\n\nExample Usage: Suppose we have a function that performs an expensive computation, such as calculating the Fibonacci sequence for a given number. By applying the lazy decorator to this function, we can postpone the actual computation until we need to access the result, potentially saving resources if the result is never needed.", "method_code_mask": "import copy\nimport itertools\nimport operator\nfrom functools import wraps\n\n\ndef lazy(func, *resultclasses): [MASK]\n"}
{"method_name": "urlencode", "full_method_name": "urlencode", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef urlencode(query, doseq=False):\n    \"\"\"\n    A version of Python's urllib.parse.urlencode() function that can operate on\n    MultiValueDict and non-string values.\n    \"\"\"\n    if isinstance(query, MultiValueDict):\n        query = query.lists()\n    elif hasattr(query, 'items'):\n        query = query.items()\n    query_params = []\n    for key, value in query:\n        if value is None:\n            raise TypeError(\n                \"Cannot encode None for key '%s' in a query string. Did you mean to pass an empty string or omit the value?\"\n                 % key)\n        elif not doseq or isinstance(value, (str, bytes)):\n            query_val = value\n        else:\n            try:\n                itr = iter(value)\n            except TypeError:\n                query_val = value\n            else:\n                query_val = []\n                for item in itr:\n                    if item is None:\n                        raise TypeError(\n                            \"Cannot encode None for key '%s' in a query string. Did you mean to pass an empty string or omit the value?\"\n                             % key)\n                    elif not isinstance(item, bytes):\n                        item = str(item)\n                    query_val.append(item)\n        query_params.append((key, query_val))\n    return original_urlencode(query_params, doseq)", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_tuples(self):\n        self.assertEqual(urlencode((('a', 1), ('b', 2), ('c', 3))), 'a=1&b=2&c=3')\n    \nURLEncodeTests().test_tuples()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict(self):\n        result = urlencode({'a': 1, 'b': 2, 'c': 3})\n        self.assertEqual(result, 'a=1&b=2&c=3')\n    \nURLEncodeTests().test_dict()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_containing_sequence_not_doseq(self):\n        self.assertEqual(urlencode({'a': [1, 2]}, doseq=False), 'a=%5B1%2C+2%5D')\n    \nURLEncodeTests().test_dict_containing_sequence_not_doseq()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_containing_tuple_not_doseq(self):\n        self.assertEqual(urlencode({'a': (1, 2)}, doseq=False), 'a=%281%2C+2%29')\n    \nURLEncodeTests().test_dict_containing_tuple_not_doseq()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_custom_iterable_not_doseq(self):\n    \n    \n        class IterableWithStr:\n    \n            def __str__(self):\n                return 'custom'\n    \n            def __iter__(self):\n                yield from range(0, 3)\n        self.assertEqual(urlencode({'a': IterableWithStr()}, doseq=False),\n            'a=custom')\n    \nURLEncodeTests().test_custom_iterable_not_doseq()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_containing_sequence_doseq(self):\n        self.assertEqual(urlencode({'a': [1, 2]}, doseq=True), 'a=1&a=2')\n    \nURLEncodeTests().test_dict_containing_sequence_doseq()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_containing_empty_sequence_doseq(self):\n        self.assertEqual(urlencode({'a': []}, doseq=True), '')\n    \nURLEncodeTests().test_dict_containing_empty_sequence_doseq()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_multivaluedict(self):\n        result = urlencode(MultiValueDict({'name': ['Adrian', 'Simon'],\n            'position': ['Developer']}), doseq=True)\n        self.assertEqual(result, 'name=Adrian&name=Simon&position=Developer')\n    \nURLEncodeTests().test_multivaluedict()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_with_bytes_values(self):\n        self.assertEqual(urlencode({'a': b'abc'}, doseq=True), 'a=abc')\n    \nURLEncodeTests().test_dict_with_bytes_values()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_with_sequence_of_bytes(self):\n        self.assertEqual(urlencode({'a': [b'spam', b'eggs', b'bacon']}, doseq=\n            True), 'a=spam&a=eggs&a=bacon')\n    \nURLEncodeTests().test_dict_with_sequence_of_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_dict_with_bytearray(self):\n        self.assertEqual(urlencode({'a': bytearray(range(2))}, doseq=True),\n            'a=0&a=1')\n    \nURLEncodeTests().test_dict_with_bytearray()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLEncodeTests(SimpleTestCase):\n    def test_generator(self):\n        self.assertEqual(urlencode({'a': range(2)}, doseq=True), 'a=0&a=1')\n        self.assertEqual(urlencode({'a': range(2)}, doseq=False),\n            'a=range%280%2C+2%29')\n    \nURLEncodeTests().test_generator()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The urlencode function is a custom version of Python's urllib.parse.urlencode() designed to handle MultiValueDict inputs and non-string values. It encodes query parameters for URL usage, ensuring that characters that have special meanings in URLs are properly encoded.\n\nInputs:\n- query: This can be a MultiValueDict, a dictionary, or an iterable of key-value pairs. If it's a MultiValueDict, the function will convert it to a list of lists before processing. If it's a dictionary or any other iterable of key-value pairs, it will iterate over these items.\n- doseq: A boolean flag that determines how the function handles sequences in the query. If doseq is True, sequences or iterables (except strings) are used as sequences of items to be included in the output with the same key. If False, sequences are joined into a single value.\n\nOutputs:\n- The function returns a URL encoded string suitable for inclusion in a URL. This string contains query parameters in the format used in HTTP GET requests, where keys and values are properly encoded for URL transmission.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef urlencode(query, doseq=False): [MASK]\n"}
{"method_name": "int_to_base36", "full_method_name": "int_to_base36", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef int_to_base36(i):\n    \"\"\"Convert an integer to a base36 string.\"\"\"\n    char_set = '0123456789abcdefghijklmnopqrstuvwxyz'\n    if i < 0:\n        raise ValueError('Negative base36 conversion input.')\n    if i < 36:\n        return char_set[i]\n    b36 = ''\n    while i != 0:\n        i, n = divmod(i, 36)\n        b36 = char_set[n] + b36\n    return b36", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_roundtrip(self):\n        for n in [0, 1, 1000, 1000000]:\n            self.assertEqual(n, base36_to_int(int_to_base36(n)))\n    \nBase36IntTests().test_roundtrip()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_negative_input(self):\n        with self.assertRaisesMessage(ValueError,\n            'Negative base36 conversion input.'):\n            int_to_base36(-1)\n    \nBase36IntTests().test_negative_input()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_to_base36_errors(self):\n        for n in ['1', 'foo', {(1): 2}, (1, 2, 3), 3.141]:\n            with self.assertRaises(TypeError):\n                int_to_base36(n)\n    \nBase36IntTests().test_to_base36_errors()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_values(self):\n        for n, b36 in [(0, '0'), (1, '1'), (42, '16'), (818469960, 'django')]:\n            self.assertEqual(int_to_base36(n), b36)\n            self.assertEqual(base36_to_int(b36), n)\n    \nBase36IntTests().test_values()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The function int_to_base36(i) is designed to convert an integer to a string that represents the number in base36. Base36 uses digits 0-9 and letters a-z (all lowercase) where 'a' represents 10, 'b' represents 11, and so on up to 'z' representing 35.\n\nInputs: \n- i: An integer to be converted to a base36 string. The integer must be non-negative, as negative numbers are not supported by this function.\n\nOutputs: \n- A string that represents the input integer in base36. The string will consist of characters from the set '0123456789abcdefghijklmnopqrstuvwxyz' and will not contain any leading '0's unless the input integer is 0 itself.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef int_to_base36(i): [MASK]\n"}
{"method_name": "base36_to_int", "full_method_name": "base36_to_int", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef base36_to_int(s):\n    \"\"\"\n    Convert a base 36 string to an int. Raise ValueError if the input won't fit\n    into an int.\n    \"\"\"\n    if len(s) > 13:\n        raise ValueError('Base36 input too large')\n    return int(s, 36)", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_roundtrip(self):\n        for n in [0, 1, 1000, 1000000]:\n            self.assertEqual(n, base36_to_int(int_to_base36(n)))\n    \nBase36IntTests().test_roundtrip()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_invalid_literal(self):\n        for n in ['#', ' ']:\n            with self.assertRaisesMessage(ValueError, \n                \"invalid literal for int() with base 36: '%s'\" % n):\n                base36_to_int(n)\n    \nBase36IntTests().test_invalid_literal()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_input_too_large(self):\n        with self.assertRaisesMessage(ValueError, 'Base36 input too large'):\n            base36_to_int('1' * 14)\n    \nBase36IntTests().test_input_too_large()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_to_int_errors(self):\n        for n in [123, {(1): 2}, (1, 2, 3), 3.141]:\n            with self.assertRaises(TypeError):\n                base36_to_int(n)\n    \nBase36IntTests().test_to_int_errors()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass Base36IntTests(SimpleTestCase):\n    def test_values(self):\n        for n, b36 in [(0, '0'), (1, '1'), (42, '16'), (818469960, 'django')]:\n            self.assertEqual(int_to_base36(n), b36)\n            self.assertEqual(base36_to_int(b36), n)\n    \nBase36IntTests().test_values()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: Convert a base 36 string to an integer. The function will raise a ValueError if the input string represents a number that is too large to fit into a standard integer.\n\nInputs: \n- s: A string representing a number in base 36. The string should only contain digits (0-9) and letters (a-z) where letters represent values 10-35.\n\nOutputs:\n- An integer that is the decimal equivalent of the base 36 string input. If the input string is too large to be represented as an integer, the function will raise a ValueError.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef base36_to_int(s): [MASK]\n"}
{"method_name": "url_has_allowed_host_and_scheme", "full_method_name": "url_has_allowed_host_and_scheme", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False):\n    \"\"\"\n    Return ``True`` if the url uses an allowed host and a safe scheme.\n\n    Always return ``False`` on an empty url.\n\n    If ``require_https`` is ``True``, only 'https' will be considered a valid\n    scheme, as opposed to 'http' and 'https' with the default, ``False``.\n\n    Note: \"True\" doesn't entail that a URL is \"safe\". It may still be e.g.\n    quoted incorrectly. Ensure to also use django.utils.encoding.iri_to_uri()\n    on the path component of untrusted URLs.\n    \"\"\"\n    if url is not None:\n        url = url.strip()\n    if not url:\n        return False\n    if allowed_hosts is None:\n        allowed_hosts = set()\n    elif isinstance(allowed_hosts, str):\n        allowed_hosts = {allowed_hosts}\n    return _url_has_allowed_host_and_scheme(url, allowed_hosts,\n        require_https=require_https) and _url_has_allowed_host_and_scheme(url\n        .replace('\\\\', '/'), allowed_hosts, require_https=require_https)", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_good_urls(self):\n        good_urls = ('/view/?param=http://example.com',\n            '/view/?param=https://example.com', '/view?param=ftp://example.com',\n            'view/?param=//example.com', 'https://testserver/',\n            'HTTPS://testserver/', '//testserver/',\n            'http://testserver/confirm?email=me@example.com',\n            '/url%20with%20spaces/', 'path/http:2222222222')\n        for good_url in good_urls:\n            with self.subTest(url=good_url):\n                self.assertIs(url_has_allowed_host_and_scheme(good_url,\n                    allowed_hosts={'otherserver', 'testserver'}), True)\n    \nURLHasAllowedHostAndSchemeTests().test_good_urls()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_basic_auth(self):\n        self.assertIs(url_has_allowed_host_and_scheme(\n            'http://user:pass@testserver/', allowed_hosts={\n            'user:pass@testserver'}), True)\n    \nURLHasAllowedHostAndSchemeTests().test_basic_auth()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_no_allowed_hosts(self):\n        self.assertIs(url_has_allowed_host_and_scheme('/confirm/me@example.com',\n            allowed_hosts=None), True)\n        self.assertIs(url_has_allowed_host_and_scheme(\n            'http://testserver\\\\@example.com', allowed_hosts=None), False)\n    \nURLHasAllowedHostAndSchemeTests().test_no_allowed_hosts()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_allowed_hosts_str(self):\n        self.assertIs(url_has_allowed_host_and_scheme('http://good.com/good',\n            allowed_hosts='good.com'), True)\n        self.assertIs(url_has_allowed_host_and_scheme('http://good.co/evil',\n            allowed_hosts='good.com'), False)\n    \nURLHasAllowedHostAndSchemeTests().test_allowed_hosts_str()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_secure_param_https_urls(self):\n        secure_urls = ('https://example.com/p', 'HTTPS://example.com/p',\n            '/view/?param=http://example.com')\n        for url in secure_urls:\n            with self.subTest(url=url):\n                self.assertIs(url_has_allowed_host_and_scheme(url,\n                    allowed_hosts={'example.com'}, require_https=True), True)\n    \nURLHasAllowedHostAndSchemeTests().test_secure_param_https_urls()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLHasAllowedHostAndSchemeTests(unittest.TestCase):\n    def test_secure_param_non_https_urls(self):\n        insecure_urls = ('http://example.com/p', 'ftp://example.com/p',\n            '//example.com/p')\n        for url in insecure_urls:\n            with self.subTest(url=url):\n                self.assertIs(url_has_allowed_host_and_scheme(url,\n                    allowed_hosts={'example.com'}, require_https=True), False)\n    \nURLHasAllowedHostAndSchemeTests().test_secure_param_non_https_urls()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The function 'url_has_allowed_host_and_scheme' checks if a given URL uses an allowed host and a safe scheme. It supports 'http' and 'https' by default, but can be restricted to only 'https' if required. An empty URL will always return False. Note that a 'True' result does not guarantee the URL is safe; it may still have incorrectly quoted components.\n\nInputs: \n- url: The URL to be checked. It should be a string.\n- allowed_hosts: A list or set of hosts that are allowed for the URL. It should be either None, a string, or a collection of strings.\n- require_https: A boolean flag that, if True, restricts the allowed scheme to 'https' only.\n\nOutputs:\n- A boolean value indicating whether the URL uses an allowed host and a safe scheme. True if the URL is valid according to the allowed hosts and scheme requirements; False otherwise.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef url_has_allowed_host_and_scheme(url, allowed_hosts, require_https=False): [\n    MASK]\n"}
{"method_name": "urlsafe_base64_decode", "full_method_name": "urlsafe_base64_decode", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef urlsafe_base64_decode(s):\n    \"\"\"\n    Decode a base64 encoded string. Add back any trailing equal signs that\n    might have been stripped.\n    \"\"\"\n    s = s.encode()\n    try:\n        return base64.urlsafe_b64decode(s.ljust(len(s) + len(s) % 4, b'='))\n    except (LookupError, BinasciiError) as e:\n        raise ValueError(e)", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass URLSafeBase64Tests(unittest.TestCase):\n    def test_roundtrip(self):\n        bytestring = b'foo'\n        encoded = urlsafe_base64_encode(bytestring)\n        decoded = urlsafe_base64_decode(encoded)\n        self.assertEqual(bytestring, decoded)\n    \nURLSafeBase64Tests().test_roundtrip()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The function urlsafe_base64_decode is designed to decode a base64 encoded string. It ensures that any trailing equal signs, which may have been removed, are added back to accurately decode the string. This function is essential for reversing the encoding process of strings that have been encoded to be URL-safe.\n\nInputs: \n- s: A single argument of type string. This string should be base64 encoded and potentially stripped of trailing equal signs. It is the encoded string that the function aims to decode.\n\nOutputs: \n- The function returns the decoded bytes of the input string. If the input string is not a valid base64 encoded string or if there are any errors during the decoding process, the function will raise a ValueError with a detailed error message.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef urlsafe_base64_decode(s): [MASK]\n"}
{"method_name": "is_same_domain", "full_method_name": "is_same_domain", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef is_same_domain(host, pattern):\n    \"\"\"\n    Return ``True`` if the host is either an exact match or a match\n    to the wildcard pattern.\n\n    Any pattern beginning with a period matches a domain and all of its\n    subdomains. (e.g. ``.example.com`` matches ``example.com`` and\n    ``foo.example.com``). Anything else is an exact string match.\n    \"\"\"\n    if not pattern:\n        return False\n    pattern = pattern.lower()\n    return pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]\n        ) or pattern == host", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass IsSameDomainTests(unittest.TestCase):\n    def test_good(self):\n        for pair in (('example.com', 'example.com'), ('example.com',\n            '.example.com'), ('foo.example.com', '.example.com'), (\n            'example.com:8888', 'example.com:8888'), ('example.com:8888',\n            '.example.com:8888'), ('foo.example.com:8888', '.example.com:8888')):\n            self.assertIs(is_same_domain(*pair), True)\n    \nIsSameDomainTests().test_good()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass IsSameDomainTests(unittest.TestCase):\n    def test_bad(self):\n        for pair in (('example2.com', 'example.com'), ('foo.example.com',\n            'example.com'), ('example.com:9999', 'example.com:8888'), (\n            'foo.example.com:8888', '')):\n            self.assertIs(is_same_domain(*pair), False)\n    \nIsSameDomainTests().test_bad()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The is_same_domain function checks if a given host matches a domain pattern. It supports both exact matches and wildcard matches. For wildcard patterns starting with a period, it verifies if the host is a subdomain or an exact match (ignoring the leading period). For all other patterns, it checks for an exact string match.\n\nInputs: \n- host: A string representing the host to be checked.\n- pattern: A string representing the domain pattern to match against the host. This can be an exact domain or a wildcard pattern starting with a period.\n\nOutputs: \n- Returns True if the host matches the domain pattern. Otherwise, returns False.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef is_same_domain(host, pattern): [MASK]\n"}
{"method_name": "parse_etags", "full_method_name": "parse_etags", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef parse_etags(etag_str):\n    \"\"\"\n    Parse a string of ETags given in an If-None-Match or If-Match header as\n    defined by RFC 9110. Return a list of quoted ETags, or ['*'] if all ETags\n    should be matched.\n    \"\"\"\n    if etag_str.strip() == '*':\n        return ['*']\n    else:\n        etag_matches = (ETAG_MATCH.match(etag.strip()) for etag in etag_str\n            .split(','))\n        return [match[1] for match in etag_matches if match]", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ETagProcessingTests(unittest.TestCase):\n    def test_parsing(self):\n        self.assertEqual(parse_etags('\"\" ,  \"etag\", \"e\\\\\\\\tag\", W/\"weak\"'), [\n            '\"\"', '\"etag\"', '\"e\\\\\\\\tag\"', 'W/\"weak\"'])\n        self.assertEqual(parse_etags('*'), ['*'])\n        self.assertEqual(parse_etags('\"etag\", \"e\\\\\"t\\\\\"ag\"'), ['\"etag\"'])\n    \nETagProcessingTests().test_parsing()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The function parse_etags is designed to process a string containing ETags as provided in If-None-Match or If-Match HTTP headers, as described by RFC 9110. It is tasked with returning a list of quoted ETags extracted from the input string. In cases where the input string is a wildcard (*), the function should return a list containing only the wildcard character, indicating that all ETags should be matched.\n\nInputs: \n- etag_str: A string representing a list of ETags. The string is typically found within HTTP headers and can contain multiple ETags separated by commas. It may also contain wildcards.\n\nOutputs: \n- A list of strings, where each string is a quoted ETag extracted from the input. If the input string contains a wildcard (*), the output will be a list containing only the wildcard character as a string, i.e., ['*'].", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef parse_etags(etag_str): [MASK]\n"}
{"method_name": "quote_etag", "full_method_name": "quote_etag", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef quote_etag(etag_str):\n    \"\"\"\n    If the provided string is already a quoted ETag, return it. Otherwise, wrap\n    the string in quotes, making it a strong ETag.\n    \"\"\"\n    if ETAG_MATCH.match(etag_str):\n        return etag_str\n    else:\n        return '\"%s\"' % etag_str", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ETagProcessingTests(unittest.TestCase):\n    def test_quoting(self):\n        self.assertEqual(quote_etag('etag'), '\"etag\"')\n        self.assertEqual(quote_etag('\"etag\"'), '\"etag\"')\n        self.assertEqual(quote_etag('W/\"etag\"'), 'W/\"etag\"')\n    \nETagProcessingTests().test_quoting()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The quote_etag function modifies a given ETag string. If the input string is already formatted as a quoted ETag, the function returns the string unchanged. Otherwise, it wraps the input string in double quotes, transforming it into a strong ETag format. This is typically used in HTTP headers for caching purposes.\n\nInputs: \n- etag_str: A string representing the ETag. The ETag may or may not be already in a quoted format.\n\nOutputs:\n- A string: The function returns the original ETag string if it is already quoted. If not, it returns the ETag string enclosed in double quotes.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef quote_etag(etag_str): [MASK]\n"}
{"method_name": "parse_http_date", "full_method_name": "parse_http_date", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef parse_http_date(date):\n    \"\"\"\n    Parse a date format as specified by HTTP RFC 9110 Section 5.6.7.\n\n    The three formats allowed by the RFC are accepted, even if only the first\n    one is still in widespread use.\n\n    Return an integer expressed in seconds since the epoch, in UTC.\n    \"\"\"\n    for regex in (RFC1123_DATE, RFC850_DATE, ASCTIME_DATE):\n        m = regex.match(date)\n        if m is not None:\n            break\n    else:\n        raise ValueError('%r is not in a valid HTTP date format' % date)\n    try:\n        year = int(m['year'])\n        if year < 100:\n            current_year = datetime.now(tz=timezone.utc).year\n            current_century = current_year - current_year % 100\n            if year - current_year % 100 > 50:\n                year += current_century - 100\n            else:\n                year += current_century\n        month = MONTHS.index(m['mon'].lower()) + 1\n        day = int(m['day'])\n        hour = int(m['hour'])\n        min = int(m['min'])\n        sec = int(m['sec'])\n        result = datetime(year, month, day, hour, min, sec, tzinfo=timezone.utc\n            )\n        return int(result.timestamp())\n    except Exception as exc:\n        raise ValueError('%r is not a valid date' % date) from exc", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass HttpDateProcessingTests(unittest.TestCase):\n    def test_parsing_rfc1123(self):\n        parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n        self.assertEqual(datetime.fromtimestamp(parsed, timezone.utc), datetime\n            (1994, 11, 6, 8, 49, 37, tzinfo=timezone.utc))\n    \nHttpDateProcessingTests().test_parsing_rfc1123()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass HttpDateProcessingTests(unittest.TestCase):\n    def test_parsing_asctime(self):\n        parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n        self.assertEqual(datetime.fromtimestamp(parsed, timezone.utc), datetime\n            (1994, 11, 6, 8, 49, 37, tzinfo=timezone.utc))\n    \nHttpDateProcessingTests().test_parsing_asctime()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass HttpDateProcessingTests(unittest.TestCase):\n    def test_parsing_asctime_nonascii_digits(self):\n        \"\"\"Non-ASCII unicode decimals raise an error.\"\"\"\n        with self.assertRaises(ValueError):\n            parse_http_date('Sun Nov  6 08:49:37 \uff11\uff19\uff19\uff14')\n        with self.assertRaises(ValueError):\n            parse_http_date('Sun Nov \uff11\uff12 08:49:37 1994')\n    \nHttpDateProcessingTests().test_parsing_asctime_nonascii_digits()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass HttpDateProcessingTests(unittest.TestCase):\n    def test_parsing_year_less_than_70(self):\n        parsed = parse_http_date('Sun Nov  6 08:49:37 0037')\n        self.assertEqual(datetime.fromtimestamp(parsed, timezone.utc), datetime\n            (2037, 11, 6, 8, 49, 37, tzinfo=timezone.utc))\n    \nHttpDateProcessingTests().test_parsing_year_less_than_70()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The parse_http_date function is designed to parse dates formatted according to the HTTP RFC 9110 Section 5.6.7. It accepts three formats specified by the RFC, with priority given to the first format which is most commonly used. The function returns a timestamp in seconds since the epoch, expressed in UTC.\n\nInputs: \n- date (str): A string containing a date in one of the formats accepted by HTTP RFC 9110 Section 5.6.7.\n\nOutputs:\n- int: An integer representing the timestamp in seconds since the epoch, adjusted to UTC. If the input date string does not match any of the accepted formats, the function raises a ValueError with a descriptive message.\n\nNotes:\n- The function uses regular expressions to match the input date string against the accepted formats.\n- For years represented with fewer than four digits, the function infers the century based on the current year.\n- The function relies on datetime and timezone objects from the datetime module to calculate the timestamp.\n- If any exception occurs during the parsing process, a ValueError is raised with a message indicating the input is not a valid date.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef parse_http_date(date): [MASK]\n"}
{"method_name": "escape_leading_slashes", "full_method_name": "escape_leading_slashes", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef escape_leading_slashes(url):\n    \"\"\"\n    If redirecting to an absolute path (two leading slashes), a slash must be\n    escaped to prevent browsers from handling the path as schemaless and\n    redirecting to another host.\n    \"\"\"\n    if url.startswith('//'):\n        url = '/%2F{}'.format(url.removeprefix('//'))\n    return url", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass EscapeLeadingSlashesTests(unittest.TestCase):\n    def test(self):\n        tests = ('//example.com', '/%2Fexample.com'), ('//', '/%2F')\n        for url, expected in tests:\n            with self.subTest(url=url):\n                self.assertEqual(escape_leading_slashes(url), expected)\n    \nEscapeLeadingSlashesTests().test()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The function 'escape_leading_slashes' modifies a given URL by escaping the leading slashes if the URL starts with two slashes. This is necessary to prevent browsers from misinterpreting the path and attempting to redirect to another host. The function ensures that absolute paths are correctly handled by browsers.\n\nInputs: \n- url: A string representing the URL that may or may not start with two leading slashes. This URL could be any valid string that conforms to URL standards, possibly including query parameters and anchors.\n\nOutputs:\n- A string representing the modified URL where leading slashes (if present) have been escaped with '%2F'. The output is guaranteed to be a valid URL with the necessary escaping applied to handle absolute paths appropriately.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef escape_leading_slashes(url): [MASK]\n"}
{"method_name": "parse_header_parameters", "full_method_name": "parse_header_parameters", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef parse_header_parameters(line):\n    \"\"\"\n    Parse a Content-type like header.\n    Return the main content-type and a dictionary of options.\n    \"\"\"\n    parts = _parseparam(';' + line)\n    key = parts.__next__().lower()\n    pdict = {}\n    for p in parts:\n        i = p.find('=')\n        if i >= 0:\n            has_encoding = False\n            name = p[:i].strip().lower()\n            if name.endswith('*'):\n                name = name[:-1]\n                if p.count(\"'\") == 2:\n                    has_encoding = True\n            value = p[i + 1:].strip()\n            if len(value) >= 2 and value[0] == value[-1] == '\"':\n                value = value[1:-1]\n                value = value.replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"')\n            if has_encoding:\n                encoding, lang, value = value.split(\"'\")\n                value = unquote(value, encoding=encoding)\n            pdict[name] = value\n    return key, pdict", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ParseHeaderParameterTests(unittest.TestCase):\n    def test_basic(self):\n        tests = [('text/plain', ('text/plain', {})), (\n            'text/vnd.just.made.this.up ; ', ('text/vnd.just.made.this.up', {})\n            ), ('text/plain;charset=us-ascii', ('text/plain', {'charset':\n            'us-ascii'})), ('text/plain ; charset=\"us-ascii\"', ('text/plain', {\n            'charset': 'us-ascii'})), (\n            'text/plain ; charset=\"us-ascii\"; another=opt', ('text/plain', {\n            'charset': 'us-ascii', 'another': 'opt'})), (\n            'attachment; filename=\"silly.txt\"', ('attachment', {'filename':\n            'silly.txt'})), ('attachment; filename=\"strange;name\"', (\n            'attachment', {'filename': 'strange;name'})), (\n            'attachment; filename=\"strange;name\";size=123;', ('attachment', {\n            'filename': 'strange;name', 'size': '123'})), (\n            'form-data; name=\"files\"; filename=\"fo\\\\\"o;bar\"', ('form-data', {\n            'name': 'files', 'filename': 'fo\"o;bar'}))]\n        for header, expected in tests:\n            with self.subTest(header=header):\n                self.assertEqual(parse_header_parameters(header), expected)\n    \nParseHeaderParameterTests().test_basic()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ParseHeaderParameterTests(unittest.TestCase):\n    def test_rfc2231_parsing(self):\n        test_data = (\n            \"Content-Type: application/x-stuff; title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A\"\n            , 'This is ***fun***'), (\n            \"Content-Type: application/x-stuff; title*=UTF-8''foo-%c3%a4.html\",\n            'foo-\u00e4.html'), (\n            \"Content-Type: application/x-stuff; title*=iso-8859-1''foo-%E4.html\",\n            'foo-\u00e4.html')\n        for raw_line, expected_title in test_data:\n            parsed = parse_header_parameters(raw_line)\n            self.assertEqual(parsed[1]['title'], expected_title)\n    \nParseHeaderParameterTests().test_rfc2231_parsing()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}, {"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ParseHeaderParameterTests(unittest.TestCase):\n    def test_rfc2231_wrong_title(self):\n        \"\"\"\n            Test wrongly formatted RFC 2231 headers (missing double single quotes).\n            Parsing should not crash (#24209).\n            \"\"\"\n        test_data = (\n            \"Content-Type: application/x-stuff; title*='This%20is%20%2A%2A%2Afun%2A%2A%2A\"\n            , \"'This%20is%20%2A%2A%2Afun%2A%2A%2A\"), (\n            \"Content-Type: application/x-stuff; title*='foo.html\", \"'foo.html\"), (\n            'Content-Type: application/x-stuff; title*=bar.html', 'bar.html')\n        for raw_line, expected_title in test_data:\n            parsed = parse_header_parameters(raw_line)\n            self.assertEqual(parsed[1]['title'], expected_title)\n    \nParseHeaderParameterTests().test_rfc2231_wrong_title()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The parse_header_parameters function is designed to parse a Content-type like header from a given string. It extracts the main content-type and a dictionary of options that are present in the header. The function is specifically useful for processing headers in email messages or HTTP requests where content types and their parameters are specified.\n\nInputs: \n- line (str): A string representing the header that needs to be parsed. The header should follow the format of a Content-type header, potentially containing multiple parameters after the main content type.\n\nOutputs: \n- A tuple is returned by the function:\n  - The first element is a string representing the main content type found in the header, converted to lowercase.\n  - The second element is a dictionary containing the parameters found in the header. The keys of the dictionary are the parameter names (in lowercase) and the values are the corresponding parameter values. The function handles quoted strings, character encoding, and language tags as specified in the header parameters.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef parse_header_parameters(line): [MASK]\n"}
{"method_name": "content_disposition_header", "full_method_name": "content_disposition_header", "method_path": "../srcdata/Network/django/django/utils/http.py", "method_code": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\ndef content_disposition_header(as_attachment, filename):\n    \"\"\"\n    Construct a Content-Disposition HTTP header value from the given filename\n    as specified by RFC 6266.\n    \"\"\"\n    if filename:\n        disposition = 'attachment' if as_attachment else 'inline'\n        try:\n            filename.encode('ascii')\n            file_expr = 'filename=\"{}\"'.format(filename.replace('\\\\',\n                '\\\\\\\\').replace('\"', '\\\\\"'))\n        except UnicodeEncodeError:\n            file_expr = \"filename*=utf-8''{}\".format(quote(filename))\n        return f'{disposition}; {file_expr}'\n    elif as_attachment:\n        return 'attachment'\n    else:\n        return None", "test_code_list": [{"test_code": "import platform\nimport unittest\nfrom datetime import datetime\nfrom datetime import timezone\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.http import base36_to_int\nfrom django.utils.http import content_disposition_header\nfrom django.utils.http import escape_leading_slashes\nfrom django.utils.http import http_date\nfrom django.utils.http import int_to_base36\nfrom django.utils.http import is_same_domain\nfrom django.utils.http import parse_etags\nfrom django.utils.http import parse_header_parameters\nfrom django.utils.http import parse_http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.http import url_has_allowed_host_and_scheme\nfrom django.utils.http import urlencode\nfrom django.utils.http import urlsafe_base64_decode\nfrom django.utils.http import urlsafe_base64_encode\n\nclass ContentDispositionHeaderTests(unittest.TestCase):\n    def test_basic(self):\n        tests = ((False, None), None), ((False, 'example'),\n            'inline; filename=\"example\"'), ((True, None), 'attachment'), ((True,\n            'example'), 'attachment; filename=\"example\"'), ((True,\n            '\"example\" file\\\\name'),\n            'attachment; filename=\"\\\\\"example\\\\\" file\\\\\\\\name\"'), ((True,\n            'esp\u00e9cimen'), \"attachment; filename*=utf-8''esp%C3%A9cimen\"), ((\n            True, '\"esp\u00e9cimen\" filename'),\n            \"attachment; filename*=utf-8''%22esp%C3%A9cimen%22%20filename\")\n        for (is_attachment, filename), expected in tests:\n            with self.subTest(is_attachment=is_attachment, filename=filename):\n                self.assertEqual(content_disposition_header(is_attachment,\n                    filename), expected)\n    \nContentDispositionHeaderTests().test_basic()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_http.py"}], "instruction": "Functionality: The content_disposition_header function constructs a Content-Disposition HTTP header value. This header specifies how the content is intended to be handled by the receiving application, whether it should be rendered inline in the browser or downloaded as an attachment. The function adheres to the guidelines set by RFC 6266 for creating the header.\n\nInputs: \n1. as_attachment: A boolean value indicating whether the content should be treated as an attachment or rendered inline.\n2. filename: A string representing the name of the file associated with the content. This can be an empty string if no filename is provided.\n\nOutputs:\n1. A string representing the Content-Disposition header value. If the filename is provided, the header includes the disposition type ('attachment' or 'inline') and the filename encoded according to RFC 6266 rules. If no filename is provided and as_attachment is True, the header value is 'attachment'. If no filename is provided and as_attachment is False, the function returns None, indicating no Content-Disposition header should be sent.", "method_code_mask": "import base64\nimport re\nimport unicodedata\nfrom binascii import Error as BinasciiError\nfrom datetime import datetime\nfrom datetime import timezone\nfrom email.utils import formatdate\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode as original_urlencode\nfrom urllib.parse import urlsplit\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef content_disposition_header(as_attachment, filename): [MASK]\n"}
{"method_name": "smart_split", "full_method_name": "smart_split", "method_path": "../srcdata/Network/django/django/utils/text.py", "method_code": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\nsmart_split_re = _lazy_re_compile(\n    \"\"\"\n    ((?:\n        [^\\\\s'\"]*\n        (?:\n            (?:\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\" | '(?:[^'\\\\\\\\]|\\\\\\\\.)*')\n            [^\\\\s'\"]*\n        )+\n    ) | \\\\S+)\n\"\"\"\n    , re.VERBOSE)\ndef smart_split(text):\n    \"\"\"\n    Generator that splits a string by spaces, leaving quoted phrases together.\n    Supports both single and double quotes, and supports escaping quotes with\n    backslashes. In the output, strings will keep their initial and trailing\n    quote marks and escaped quotes will remain escaped (the results can then\n    be further processed with unescape_string_literal()).\n    >>> list(smart_split(r'This is \"a person\\\\'s\" test.'))\n    ['This', 'is', '\"a person\\\\\\\\\\\\'s\"', 'test.']\n    >>> list(smart_split(r\"Another 'person\\\\'s' test.\"))\n    ['Another', \"'person\\\\\\\\'s'\", 'test.']\n    >>> list(smart_split(r'A \"\\\\\"funky\\\\\" style\" test.'))\n    ['A', '\"\\\\\\\\\"funky\\\\\\\\\" style\"', 'test.']\n    \"\"\"\n    for bit in smart_split_re.finditer(str(text)):\n        yield bit[0]", "test_code_list": [{"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_smart_split(self):\n        testdata = [('This is \"a person\" test.', ['This', 'is', '\"a person\"',\n            'test.']), ('This is \"a person\\'s\" test.', ['This', 'is',\n            '\"a person\\'s\"', 'test.']), ('This is \"a person\\\\\"s\" test.', [\n            'This', 'is', '\"a person\\\\\"s\"', 'test.']), ('\"a \\'one', ['\"a',\n            \"'one\"]), (\"all friends' tests\", ['all', \"friends'\", 'tests']), (\n            'url search_page words=\"something else\"', ['url', 'search_page',\n            'words=\"something else\"']), (\n            \"url search_page words='something else'\", ['url', 'search_page',\n            \"words='something else'\"]), (\n            'url search_page words \"something else\"', ['url', 'search_page',\n            'words', '\"something else\"']), (\n            'url search_page words-\"something else\"', ['url', 'search_page',\n            'words-\"something else\"']), ('url search_page words=hello', ['url',\n            'search_page', 'words=hello']), (\n            'url search_page words=\"something else', ['url', 'search_page',\n            'words=\"something', 'else']), (\"cut:','|cut:' '\", [\n            \"cut:','|cut:' '\"]), (lazystr('a b c d'), ['a', 'b', 'c', 'd'])]\n        for test, expected in testdata:\n            with self.subTest(value=test):\n                self.assertEqual(list(smart_split(test)), expected)\n    \nTestUtilsText().test_smart_split()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}], "instruction": "Functionality: The smart_split function is a generator that divides a string into substrings by spaces, ensuring that quoted phrases remain intact. It supports both single and double quotes and allows for the escaping of quotes with backslashes. The output includes strings with their initial and trailing quote marks preserved, and escaped quotes are not altered, providing an opportunity for further processing, such as unescaping string literals.\n\nInputs: \n- text: A string that needs to be split into substrings. This string can contain spaces, single quotes, double quotes, and escaped quotes.\n\nOutputs:\n- A generator that yields substrings from the input string. Each yielded value is a substring that either consists of a quoted phrase, including the surrounding quotes and any escaped quotes within, or a sequence of unquoted text. The substrings will be returned in the order they appear in the input string.", "method_code_mask": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\nsmart_split_re = _lazy_re_compile(\n    \"\"\"\n    ((?:\n        [^\\\\s'\"]*\n        (?:\n            (?:\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\" | '(?:[^'\\\\\\\\]|\\\\\\\\.)*')\n            [^\\\\s'\"]*\n        )+\n    ) | \\\\S+)\n\"\"\"\n    , re.VERBOSE)\n\n\ndef smart_split(text): [MASK]\n"}
{"method_name": "phone2numeric", "full_method_name": "phone2numeric", "method_path": "../srcdata/Network/django/django/utils/text.py", "method_code": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n@keep_lazy_text\ndef phone2numeric(phone):\n    \"\"\"Convert a phone number with letters into its numeric equivalent.\"\"\"\n    char2number = {'a': '2', 'b': '2', 'c': '2', 'd': '3', 'e': '3', 'f':\n        '3', 'g': '4', 'h': '4', 'i': '4', 'j': '5', 'k': '5', 'l': '5',\n        'm': '6', 'n': '6', 'o': '6', 'p': '7', 'q': '7', 'r': '7', 's':\n        '7', 't': '8', 'u': '8', 'v': '8', 'w': '9', 'x': '9', 'y': '9',\n        'z': '9'}\n    return ''.join(char2number.get(c, c) for c in phone.lower())", "test_code_list": [{"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_phone2numeric(self):\n        numeric = phone2numeric('0800 flowers')\n        self.assertEqual(numeric, '0800 3569377')\n        lazy_numeric = lazystr(phone2numeric('0800 flowers'))\n        self.assertEqual(lazy_numeric, '0800 3569377')\n    \nTestUtilsText().test_phone2numeric()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}], "instruction": "Functionality: The function 'phone2numeric' is designed to convert a given phone number, which may contain letters, into its numeric equivalent according to the standard layout of telephone keypads.\n\nInputs: \n- phone: A string representing the phone number, which may include letters (a-z) alongside digits. The phone number will only contain valid lowercase alphabetic characters and digits. The length of the string will be between 1 and 1000 characters.\n\nOutputs:\n- A string where all alphabetic characters in the input have been replaced by their corresponding numeric key values on a standard telephone keypad. For example, 'a', 'b', or 'c' should be replaced by '2', 'd', 'e', or 'f' by '3', and so on. If the input string contains only digits, it should be returned unchanged.", "method_code_mask": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n\n\n@keep_lazy_text\ndef phone2numeric(phone): [MASK]\n"}
{"method_name": "slugify", "full_method_name": "slugify", "method_path": "../srcdata/Network/django/django/utils/text.py", "method_code": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n@keep_lazy_text\ndef slugify(value, allow_unicode=False):\n    \"\"\"\n    Convert to ASCII if 'allow_unicode' is False. Convert spaces or repeated\n    dashes to single dashes. Remove characters that aren't alphanumerics,\n    underscores, or hyphens. Convert to lowercase. Also strip leading and\n    trailing whitespace, dashes, and underscores.\n    \"\"\"\n    value = str(value)\n    if allow_unicode:\n        value = unicodedata.normalize('NFKC', value)\n    else:\n        value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore'\n            ).decode('ascii')\n    value = re.sub('[^\\\\w\\\\s-]', '', value.lower())\n    return re.sub('[-\\\\s]+', '-', value).strip('-_')", "test_code_list": [{"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_slugify(self):\n        items = ('Hello, World!', 'hello-world', False), ('spam & eggs',\n            'spam-eggs', False), (' multiple---dash and  space ',\n            'multiple-dash-and-space', False), (\"\"\"\t whitespace-in-value \n    \"\"\",\n            'whitespace-in-value', False), ('underscore_in-value',\n            'underscore_in-value', False), ('__strip__underscore-value___',\n            'strip__underscore-value', False), ('--strip-dash-value---',\n            'strip-dash-value', False), ('__strip-mixed-value---',\n            'strip-mixed-value', False), ('_ -strip-mixed-value _-',\n            'strip-mixed-value', False), ('spam & \u0131\u00e7\u00fc\u015f', 'spam-\u0131\u00e7\u00fc\u015f', True), (\n            'foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True), ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar',\n            True), ('\u4f60\u597d', '\u4f60\u597d', True), ('\u0130stanbul', 'istanbul', True)\n        for value, output, is_unicode in items:\n            with self.subTest(value=value):\n                self.assertEqual(slugify(value, allow_unicode=is_unicode),\n                    output)\n        with self.subTest('intern'):\n            self.assertEqual(sys.intern(slugify('a')), 'a')\n    \nTestUtilsText().test_slugify()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}], "instruction": "Functionality: The slugify function takes a string and processes it to create a URL-friendly version, known as a slug. This involves converting the string to ASCII (or normalizing Unicode characters if allowed), removing any characters that are not alphanumeric, underscores, or hyphens, converting all characters to lowercase, and replacing spaces or multiple dashes with single dashes. Leading and trailing whitespace, dashes, and underscores are also stripped from the final result.\n\nInputs: \n1. value (str): The input string to be slugified.\n2. allow_unicode (bool): A flag to indicate whether Unicode characters should be allowed in the slug. If False, the function will convert the string to ASCII; if True, it will normalize Unicode characters.\n\nOutputs:\n1. str: A URL-friendly version of the input string, adhering to the rules mentioned in the functionality description. This output string is known as a 'slug'.", "method_code_mask": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n\n\n@keep_lazy_text\ndef slugify(value, allow_unicode=False): [MASK]\n"}
{"method_name": "unescape_string_literal", "full_method_name": "unescape_string_literal", "method_path": "../srcdata/Network/django/django/utils/text.py", "method_code": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n@keep_lazy_text\ndef unescape_string_literal(s):\n    \"\"\"\n    Convert quoted string literals to unquoted strings with escaped quotes and\n    backslashes unquoted::\n\n        >>> unescape_string_literal('\"abc\"')\n        'abc'\n        >>> unescape_string_literal(\"'abc'\")\n        'abc'\n        >>> unescape_string_literal('\"a \\\\\"bc\\\\\"\"')\n        'a \"bc\"'\n        >>> unescape_string_literal(\"'\\\\'ab\\\\' c'\")\n        \"'ab' c\"\n    \"\"\"\n    if not s or s[0] not in '\"\\'' or s[-1] != s[0]:\n        raise ValueError('Not a string literal: %r' % s)\n    quote = s[0]\n    return s[1:-1].replace('\\\\%s' % quote, quote).replace('\\\\\\\\', '\\\\')", "test_code_list": [{"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_unescape_string_literal(self):\n        items = [('\"abc\"', 'abc'), (\"'abc'\", 'abc'), ('\"a \"bc\"\"', 'a \"bc\"'), (\n            \"''ab' c'\", \"'ab' c\")]\n        for value, output in items:\n            with self.subTest(value=value):\n                self.assertEqual(unescape_string_literal(value), output)\n                self.assertEqual(unescape_string_literal(lazystr(value)),\n                    output)\n    \nTestUtilsText().test_unescape_string_literal()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}, {"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_unescape_string_literal_invalid_value(self):\n        items = ['', 'abc', '\\'abc\"']\n        for item in items:\n            msg = f'Not a string literal: {item!r}'\n            with self.assertRaisesMessage(ValueError, msg):\n                unescape_string_literal(item)\n    \nTestUtilsText().test_unescape_string_literal_invalid_value()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}], "instruction": "Functionality: The function unescape_string_literal is designed to convert quoted string literals into unquoted strings, unescaping any escaped quotes and backslashes within the string. It processes both single and double-quoted strings, removing the outer quotes and replacing escaped quotes and backslashes with their unescaped versions.\n\nInputs: \n- s: A string literal enclosed in either single or double quotes. The string literal must start and end with the same quote character (either ' or \").\n\nOutputs: \n- A string: The processed string with outer quotes removed and all escaped characters (quotes and backslashes) unescaped. If the input string is not a valid string literal (does not start and end with the same quote character or is empty), the function will raise a ValueError.", "method_code_mask": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n\n\n@keep_lazy_text\ndef unescape_string_literal(s): [MASK]\n"}
{"method_name": "get_valid_filename", "full_method_name": "get_valid_filename", "method_path": "../srcdata/Network/django/django/utils/text.py", "method_code": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n@keep_lazy_text\ndef get_valid_filename(name):\n    \"\"\"\n    Return the given string converted to a string that can be used for a clean\n    filename. Remove leading and trailing spaces; convert other spaces to\n    underscores; and remove anything that is not an alphanumeric, dash,\n    underscore, or dot.\n    >>> get_valid_filename(\"john's portrait in 2004.jpg\")\n    'johns_portrait_in_2004.jpg'\n    \"\"\"\n    s = str(name).strip().replace(' ', '_')\n    s = re.sub('(?u)[^-\\\\w.]', '', s)\n    if s in {'', '.', '..'}:\n        raise SuspiciousFileOperation(\n            \"Could not derive file name from '%s'\" % name)\n    return s", "test_code_list": [{"test_code": "import json\nimport sys\nfrom unittest.mock import patch\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.test import SimpleTestCase\nfrom django.utils import text\nfrom django.utils.functional import lazystr\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import override\n\nclass TestUtilsText(SimpleTestCase):\n    def test_get_valid_filename(self):\n        filename = \"^&'@{}[],$=!-#()%+~_123.txt\"\n        self.assertEqual(get_valid_filename(filename), '-_123.txt')\n        self.assertEqual(get_valid_filename(lazystr(filename)), '-_123.txt')\n        msg = \"Could not derive file name from '???'\"\n        with self.assertRaisesMessage(SuspiciousFileOperation, msg):\n            get_valid_filename('???')\n        msg = \"Could not derive file name from '$.$.$'\"\n        with self.assertRaisesMessage(SuspiciousFileOperation, msg):\n            get_valid_filename('$.$.$')\n    \nTestUtilsText().test_get_valid_filename()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_text.py"}], "instruction": "Functionality: The get_valid_filename function is designed to sanitize a given string to be used as a safe and clean filename. It performs several operations on the input string: trims leading and trailing spaces, replaces inner spaces with underscores, and removes any characters that are not alphanumeric, dashes, underscores, or dots.\n\nInputs: \n- name: A string representing the name that needs to be sanitized for use as a filename. The input can contain various characters, including spaces and special symbols.\n\nOutputs: \n- A string that is safe and clean for use as a filename. The output will not contain leading or trailing spaces, inner spaces will be replaced with underscores, and any characters not allowed in filenames (excluding alphanumeric characters, dashes, underscores, or dots) will be removed. If the sanitized filename results in an empty string or '.', '..', which are forbidden, the function will raise a SuspiciousFileOperation exception with a descriptive message.\n\nExample usage:\n>>> get_valid_filename(\"john's portrait in 2004.jpg\")\n'johns_portrait_in_2004.jpg'", "method_code_mask": "import gzip\nimport re\nimport secrets\nimport unicodedata\nfrom collections import deque\nfrom gzip import GzipFile\nfrom gzip import compress as gzip_compress\nfrom html import escape\nfrom html.parser import HTMLParser\nfrom io import BytesIO\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils.functional import SimpleLazyObject\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import pgettext\n\n\n@keep_lazy_text\ndef get_valid_filename(name): [MASK]\n"}
{"method_name": "is_valid_ipv6_address", "full_method_name": "is_valid_ipv6_address", "method_path": "../srcdata/Network/django/django/utils/ipv6.py", "method_code": "import ipaddress\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\ndef is_valid_ipv6_address(ip_str):\n    \"\"\"\n    Return whether or not the `ip_str` string is a valid IPv6 address.\n    \"\"\"\n    try:\n        ipaddress.IPv6Address(ip_str)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_validates_correct_plain_address(self):\n        self.assertTrue(is_valid_ipv6_address('fe80::223:6cff:fe8a:2e8a'))\n        self.assertTrue(is_valid_ipv6_address('2a02::223:6cff:fe8a:2e8a'))\n        self.assertTrue(is_valid_ipv6_address('1::2:3:4:5:6:7'))\n        self.assertTrue(is_valid_ipv6_address('::'))\n        self.assertTrue(is_valid_ipv6_address('::a'))\n        self.assertTrue(is_valid_ipv6_address('2::'))\n    \nTestUtilsIPv6().test_validates_correct_plain_address()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}, {"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_validates_correct_with_v4mapping(self):\n        self.assertTrue(is_valid_ipv6_address('::ffff:254.42.16.14'))\n        self.assertTrue(is_valid_ipv6_address('::ffff:0a0a:0a0a'))\n    \nTestUtilsIPv6().test_validates_correct_with_v4mapping()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}, {"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_validates_incorrect_plain_address(self):\n        self.assertFalse(is_valid_ipv6_address('foo'))\n        self.assertFalse(is_valid_ipv6_address('127.0.0.1'))\n        self.assertFalse(is_valid_ipv6_address('12345::'))\n        self.assertFalse(is_valid_ipv6_address('1::2:3::4'))\n        self.assertFalse(is_valid_ipv6_address('1::zzz'))\n        self.assertFalse(is_valid_ipv6_address('1::2:3:4:5:6:7:8'))\n        self.assertFalse(is_valid_ipv6_address('1:2'))\n        self.assertFalse(is_valid_ipv6_address('1:::2'))\n        self.assertFalse(is_valid_ipv6_address('fe80::223: 6cff:fe8a:2e8a'))\n        self.assertFalse(is_valid_ipv6_address('2a02::223:6cff :fe8a:2e8a'))\n    \nTestUtilsIPv6().test_validates_incorrect_plain_address()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}, {"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_validates_incorrect_with_v4mapping(self):\n        self.assertFalse(is_valid_ipv6_address('::ffff:999.42.16.14'))\n        self.assertFalse(is_valid_ipv6_address('::ffff:zzzz:0a0a'))\n        self.assertTrue(is_valid_ipv6_address('::254.42.16.14'))\n        self.assertTrue(is_valid_ipv6_address('::0a0a:0a0a'))\n        self.assertFalse(is_valid_ipv6_address('::999.42.16.14'))\n        self.assertFalse(is_valid_ipv6_address('::zzzz:0a0a'))\n    \nTestUtilsIPv6().test_validates_incorrect_with_v4mapping()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}], "instruction": "Functionality: This function checks if a given string is a valid IPv6 address.\nInputs: A single string argument `ip_str`, which represents the IP address to be validated.\nOutputs: A boolean value indicating whether `ip_str` is a valid IPv6 address. The function returns True if `ip_str` is a valid IPv6 address; otherwise, it returns False.", "method_code_mask": "import ipaddress\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\n\n\ndef is_valid_ipv6_address(ip_str): [MASK]\n"}
{"method_name": "clean_ipv6_address", "full_method_name": "clean_ipv6_address", "method_path": "../srcdata/Network/django/django/utils/ipv6.py", "method_code": "import ipaddress\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\ndef clean_ipv6_address(ip_str, unpack_ipv4=False, error_message=_(\n    'This is not a valid IPv6 address.')):\n    \"\"\"\n    Clean an IPv6 address string.\n\n    Raise ValidationError if the address is invalid.\n\n    Replace the longest continuous zero-sequence with \"::\", remove leading\n    zeroes, and make sure all hextets are lowercase.\n\n    Args:\n        ip_str: A valid IPv6 address.\n        unpack_ipv4: if an IPv4-mapped address is found,\n        return the plain IPv4 address (default=False).\n        error_message: An error message used in the ValidationError.\n\n    Return a compressed IPv6 address or the same value.\n    \"\"\"\n    try:\n        addr = ipaddress.IPv6Address(int(ipaddress.IPv6Address(ip_str)))\n    except ValueError:\n        raise ValidationError(error_message, code='invalid', params={\n            'protocol': _('IPv6')})\n    if unpack_ipv4 and addr.ipv4_mapped:\n        return str(addr.ipv4_mapped)\n    elif addr.ipv4_mapped:\n        return '::ffff:%s' % str(addr.ipv4_mapped)\n    return str(addr)", "test_code_list": [{"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_cleans_plain_address(self):\n        self.assertEqual(clean_ipv6_address('DEAD::0:BEEF'), 'dead::beef')\n        self.assertEqual(clean_ipv6_address('2001:000:a:0000:0:fe:fe:beef'),\n            '2001:0:a::fe:fe:beef')\n        self.assertEqual(clean_ipv6_address('2001::a:0000:0:fe:fe:beef'),\n            '2001:0:a::fe:fe:beef')\n    \nTestUtilsIPv6().test_cleans_plain_address()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}, {"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_cleans_with_v4_mapping(self):\n        self.assertEqual(clean_ipv6_address('::ffff:0a0a:0a0a'),\n            '::ffff:10.10.10.10')\n        self.assertEqual(clean_ipv6_address('::ffff:1234:1234'),\n            '::ffff:18.52.18.52')\n        self.assertEqual(clean_ipv6_address('::ffff:18.52.18.52'),\n            '::ffff:18.52.18.52')\n        self.assertEqual(clean_ipv6_address('::ffff:0.52.18.52'),\n            '::ffff:0.52.18.52')\n        self.assertEqual(clean_ipv6_address('::ffff:0.0.0.0'), '::ffff:0.0.0.0')\n    \nTestUtilsIPv6().test_cleans_with_v4_mapping()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}, {"test_code": "import unittest\nfrom django.utils.ipv6 import clean_ipv6_address\nfrom django.utils.ipv6 import is_valid_ipv6_address\n\nclass TestUtilsIPv6(unittest.TestCase):\n    def test_unpacks_ipv4(self):\n        self.assertEqual(clean_ipv6_address('::ffff:0a0a:0a0a', unpack_ipv4=\n            True), '10.10.10.10')\n        self.assertEqual(clean_ipv6_address('::ffff:1234:1234', unpack_ipv4=\n            True), '18.52.18.52')\n        self.assertEqual(clean_ipv6_address('::ffff:18.52.18.52', unpack_ipv4=\n            True), '18.52.18.52')\n    \nTestUtilsIPv6().test_unpacks_ipv4()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_ipv6.py"}], "instruction": "Functionality: This function takes an IPv6 address as a string, checks its validity, and formats it according to standard IPv6 address conventions. It can optionally unpack IPv4-mapped addresses into plain IPv4 addresses.\n\nInputs:\n    ip_str: A string representing an IPv6 address. This is the address to be validated and formatted.\n    unpack_ipv4: A boolean indicating whether to convert IPv4-mapped addresses into plain IPv4 addresses (default is False).\n    error_message: A string that specifies the error message to be raised if the input address is invalid. The default is 'This is not a valid IPv6 address.'\n\nOutputs:\n    A string representing the compressed IPv6 address if unpack_ipv4 is False, or the plain IPv4 address if an IPv4-mapped address is found and unpack_ipv4 is True. If the input is not a valid IPv6 address, the function raises a ValidationError with the specified error message.", "method_code_mask": "import ipaddress\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\n\n\ndef clean_ipv6_address(ip_str, unpack_ipv4=False, error_message=_(\n    'This is not a valid IPv6 address.')): [MASK]\n"}
{"method_name": "safe_join", "full_method_name": "safe_join", "method_path": "../srcdata/Network/django/django/utils/_os.py", "method_code": "import os\nimport tempfile\nfrom os.path import abspath\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import normcase\nfrom os.path import sep\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\ndef safe_join(base, *paths):\n    \"\"\"\n    Join one or more path components to the base path component intelligently.\n    Return a normalized, absolute version of the final path.\n\n    Raise SuspiciousFileOperation if the final path isn't located inside of the\n    base path component.\n    \"\"\"\n    final_path = abspath(join(base, *paths))\n    base_path = abspath(base)\n    if not normcase(final_path).startswith(normcase(base_path + sep)\n        ) and normcase(final_path) != normcase(base_path) and dirname(normcase\n        (base_path)) != normcase(base_path):\n        raise SuspiciousFileOperation(\n            'The joined path ({}) is located outside of the base path component ({})'\n            .format(final_path, base_path))\n    return final_path", "test_code_list": [{"test_code": "import os\nimport unittest\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils._os import safe_join\nfrom django.utils._os import to_path\n\nclass SafeJoinTests(unittest.TestCase):\n    def test_base_path_ends_with_sep(self):\n        drive, path = os.path.splitdrive(safe_join('/abc/', 'abc'))\n        self.assertEqual(path, '{0}abc{0}abc'.format(os.path.sep))\n    \nSafeJoinTests().test_base_path_ends_with_sep()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_os_utils.py"}, {"test_code": "import os\nimport unittest\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils._os import safe_join\nfrom django.utils._os import to_path\n\nclass SafeJoinTests(unittest.TestCase):\n    def test_root_path(self):\n        drive, path = os.path.splitdrive(safe_join('/', 'path'))\n        self.assertEqual(path, '{}path'.format(os.path.sep))\n        drive, path = os.path.splitdrive(safe_join('/', ''))\n        self.assertEqual(path, os.path.sep)\n    \nSafeJoinTests().test_root_path()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_os_utils.py"}, {"test_code": "import os\nimport unittest\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils._os import safe_join\nfrom django.utils._os import to_path\n\nclass SafeJoinTests(unittest.TestCase):\n    def test_parent_path(self):\n        with self.assertRaises(SuspiciousFileOperation):\n            safe_join('/abc/', '../def')\n    \nSafeJoinTests().test_parent_path()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_os_utils.py"}], "instruction": "Functionality: The safe_join function is designed to join one or more path components to a base path component in a secure manner. It returns a normalized, absolute version of the final path. However, if the final path is not located inside the base path component, it raises a SuspiciousFileOperation exception, ensuring that the function doesn't allow paths to escape the designated base directory.\n\nInputs: The function takes a base path as the first argument and an arbitrary number of additional path components that should be joined to the base path.\n\nOutputs: The function returns a string representing the normalized, absolute path if the final path is within the base path component. If the final path is outside of the base path, the function raises a SuspiciousFileOperation exception with a message detailing the final path and the base path.", "method_code_mask": "import os\nimport tempfile\nfrom os.path import abspath\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import normcase\nfrom os.path import sep\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\n\n\ndef safe_join(base, *paths): [MASK]\n"}
{"method_name": "to_path", "full_method_name": "to_path", "method_path": "../srcdata/Network/django/django/utils/_os.py", "method_code": "import os\nimport tempfile\nfrom os.path import abspath\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import normcase\nfrom os.path import sep\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\ndef to_path(value):\n    \"\"\"Convert value to a pathlib.Path instance, if not already a Path.\"\"\"\n    if isinstance(value, Path):\n        return value\n    elif not isinstance(value, str):\n        raise TypeError('Invalid path type: %s' % type(value).__name__)\n    return Path(value)", "test_code_list": [{"test_code": "import os\nimport unittest\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils._os import safe_join\nfrom django.utils._os import to_path\n\nclass ToPathTests(unittest.TestCase):\n    def test_to_path(self):\n        for path in ('/tmp/some_file.txt', Path('/tmp/some_file.txt')):\n            with self.subTest(path):\n                self.assertEqual(to_path(path), Path('/tmp/some_file.txt'))\n    \nToPathTests().test_to_path()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_os_utils.py"}, {"test_code": "import os\nimport unittest\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\nfrom django.utils._os import safe_join\nfrom django.utils._os import to_path\n\nclass ToPathTests(unittest.TestCase):\n    def test_to_path_invalid_value(self):\n        with self.assertRaises(TypeError):\n            to_path(42)\n    \nToPathTests().test_to_path_invalid_value()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_os_utils.py"}], "instruction": "Functionality: The to_path function is designed to convert the given input value to a pathlib.Path instance. If the input is already an instance of Path, it will be returned as is. If the input is of a different type that is not a string, a TypeError will be raised indicating that the path type is invalid.\n\nInputs: \n- value: The value to be converted to a pathlib.Path instance. This input can either be a string representing a path or an instance of pathlib.Path.\n\nOutputs:\n- If the input 'value' is already a pathlib.Path instance, the function returns the input as is.\n- If the input 'value' is a string, the function converts it into a pathlib.Path instance and returns the result.\n- If the input 'value' is neither a string nor a pathlib.Path instance, the function raises a TypeError with a message indicating the invalid path type.", "method_code_mask": "import os\nimport tempfile\nfrom os.path import abspath\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import normcase\nfrom os.path import sep\nfrom pathlib import Path\nfrom django.core.exceptions import SuspiciousFileOperation\n\n\ndef to_path(value): [MASK]\n"}
{"method_name": "activate", "full_method_name": "activate", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\ndef activate(timezone):\n    \"\"\"\n    Set the time zone for the current thread.\n\n    The ``timezone`` argument must be an instance of a tzinfo subclass or a\n    time zone name.\n    \"\"\"\n    if isinstance(timezone, tzinfo):\n        _active.value = timezone\n    elif isinstance(timezone, str):\n        _active.value = zoneinfo.ZoneInfo(timezone)\n    else:\n        raise ValueError('Invalid timezone: %r' % timezone)", "test_code_list": [{"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\n\nclass TimezoneTests(SimpleTestCase):\n    def test_activate_invalid_timezone(self):\n        with self.assertRaisesMessage(ValueError, 'Invalid timezone: None'):\n            activate(None)\n    \nTimezoneTests().test_activate_invalid_timezone()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}], "instruction": "Functionality: The 'activate' function sets the time zone for the current thread. It accepts a timezone as an argument which can either be an instance of a tzinfo subclass or a string representing a time zone name. The function then assigns the provided timezone to the current thread's active timezone.\n\nInputs: \n- timezone: This is the main input to the function. It can either be an instance of a tzinfo subclass or a string representing the name of a timezone. If the input is not an instance of tzinfo or a string, the function will raise a ValueError.\n\nOutputs:\n- The function does not return any value but sets the internal state of the thread's active timezone.", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\ndef activate(timezone): [MASK]\n"}
{"method_name": "make_naive", "full_method_name": "make_naive", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\ndef is_naive(value):\n    \"\"\"\n    Determine if a given datetime.datetime is naive.\n\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is None\ndef make_naive(value, timezone=None):\n    \"\"\"Make an aware datetime.datetime naive in a given time zone.\"\"\"\n    if timezone is None:\n        timezone = get_current_timezone()\n    if is_naive(value):\n        raise ValueError('make_naive() cannot be applied to a naive datetime')\n    return value.astimezone(timezone).replace(tzinfo=None)", "test_code_list": [{"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nICT = timezone.get_fixed_timezone(420)\nEAT = timezone.get_fixed_timezone(180)\nclass TimezoneTests(SimpleTestCase):\n    def test_make_naive(self):\n        self.assertEqual(make_naive(datetime.datetime(2011, 9, 1, 13,\n            20, 30, tzinfo=EAT), EAT), datetime.datetime(2011, 9, 1, 13, 20, 30))\n        self.assertEqual(make_naive(datetime.datetime(2011, 9, 1, 17,\n            20, 30, tzinfo=ICT), EAT), datetime.datetime(2011, 9, 1, 13, 20, 30))\n        with self.assertRaisesMessage(ValueError,\n            'make_naive() cannot be applied to a naive datetime'):\n            make_naive(datetime.datetime(2011, 9, 1, 13, 20, 30), EAT)\nTimezoneTests().test_make_naive()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}], "instruction": "Functionality: The function 'make_naive' is designed to convert an aware datetime object to a naive datetime object in a specific timezone. It ensures that the timezone information is removed from the datetime object, effectively making it naive.\n\nInputs: \n- value: A datetime object that is aware (i.e., it has timezone information).\n- timezone (optional): A timezone object or name to which the aware datetime object will be converted before making it naive. If not provided, it will use the current timezone as defined in the settings.\n\nOutputs: \n- A naive datetime object, which is the input aware datetime object converted to the specified timezone and stripped of its timezone information.", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\ndef is_naive(value):\n    \"\"\"\n    Determine if a given datetime.datetime is naive.\n\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is None\n\n\ndef make_naive(value, timezone=None): [MASK]\n"}
{"method_name": "make_naive", "full_method_name": "make_naive", "method_path": "../srcdata/Network/django/django/utils/timezone.py", "method_code": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n@functools.lru_cache\ndef get_default_timezone():\n    \"\"\"\n    Return the default time zone as a tzinfo instance.\n\n    This is the time zone defined by settings.TIME_ZONE.\n    \"\"\"\n    return zoneinfo.ZoneInfo(settings.TIME_ZONE)\n_active = Local()\ndef get_current_timezone():\n    \"\"\"Return the currently active time zone as a tzinfo instance.\"\"\"\n    return getattr(_active, 'value', get_default_timezone())\ndef is_naive(value):\n    \"\"\"\n    Determine if a given datetime.datetime is naive.\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is None\ndef make_naive(value, timezone=None):\n    \"\"\"Make an aware datetime.datetime naive in a given time zone.\"\"\"\n    if timezone is None:\n        timezone = get_current_timezone()\n    if is_naive(value):\n        raise ValueError('make_naive() cannot be applied to a naive datetime')\n    return value.astimezone(timezone).replace(tzinfo=None)", "test_code_list": [{"test_code": "import datetime\nimport zoneinfo\nfrom unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils import timezone\nPARIS_ZI = zoneinfo.ZoneInfo('Europe/Paris')\nclass TimezoneTests(SimpleTestCase):\n    def test_make_naive_zoneinfo(self):\n        self.assertEqual(make_naive(datetime.datetime(2011, 9, 1, 12,\n            20, 30, tzinfo=PARIS_ZI), PARIS_ZI), datetime.datetime(2011, 9, 1,\n            12, 20, 30))\n        self.assertEqual(make_naive(datetime.datetime(2011, 9, 1, 12,\n            20, 30, fold=1, tzinfo=PARIS_ZI), PARIS_ZI), datetime.datetime(2011,\n            9, 1, 12, 20, 30, fold=1))\nTimezoneTests().test_make_naive_zoneinfo()", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_timezone.py"}], "instruction": "Functionality: The make_naive function is designed to convert an aware datetime object (i.e., a datetime object that is timezone-aware) to a naive datetime object (i.e., a datetime object without timezone information) in a specified time zone. If no time zone is provided, it defaults to the application's default time zone.\n\nInputs: \n1. value: A datetime.datetime object that is timezone-aware. (The function will raise a ValueError if the datetime object is naive.)\n2. timezone (optional): A datetime.tzinfo object representing the time zone to which the aware datetime object will be converted before becoming naive. If not provided, the function will use the default time zone as defined in your application's settings.\n\nOutputs:\n1. A datetime.datetime object that is naive, representing the same point in time as the input aware datetime object but in the specified or default time zone and without timezone information.", "method_code_mask": "import functools\nimport zoneinfo\nfrom contextlib import ContextDecorator\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom datetime import tzinfo\nfrom asgiref.local import Local\nfrom django.conf import settings\n\n\n@functools.lru_cache\ndef get_default_timezone():\n    \"\"\"\n    Return the default time zone as a tzinfo instance.\n\n    This is the time zone defined by settings.TIME_ZONE.\n    \"\"\"\n    return zoneinfo.ZoneInfo(settings.TIME_ZONE)\n\n\n_active = Local()\n\n\ndef get_current_timezone():\n    \"\"\"Return the currently active time zone as a tzinfo instance.\"\"\"\n    return getattr(_active, 'value', get_default_timezone())\n\n\ndef is_naive(value):\n    \"\"\"\n    Determine if a given datetime.datetime is naive.\n    The concept is defined in Python's docs:\n    https://docs.python.org/library/datetime.html#datetime.tzinfo\n    Assuming value.tzinfo is either None or a proper datetime.tzinfo,\n    value.utcoffset() implements the appropriate logic.\n    \"\"\"\n    return value.utcoffset() is None\n\n\ndef make_naive(value, timezone=None): [MASK]\n"}
{"method_name": "duration_string", "full_method_name": "duration_string", "method_path": "../srcdata/Network/django/django/utils/duration.py", "method_code": "import datetime\ndef duration_string(duration):\n    \"\"\"Version of str(timedelta) which is not English specific.\"\"\"\n    days, hours, minutes, seconds, microseconds = _get_duration_components(\n        duration)\n    string = '{:02d}:{:02d}:{:02d}'.format(hours, minutes, seconds)\n    if days:\n        string = '{} '.format(days) + string\n    if microseconds:\n        string += '.{:06d}'.format(microseconds)\n    return string", "test_code_list": [{"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestDurationString(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_string(duration), '01:03:05')\n    \nTestDurationString().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestDurationString(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_string(duration), '1 01:03:05')\n    \nTestDurationString().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestDurationString(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(duration_string(duration), '01:03:05.012345')\n    \nTestDurationString().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestDurationString(unittest.TestCase):\n    def test_negative(self):\n        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_string(duration), '-1 01:03:05')\n    \nTestDurationString().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseDurationRoundtrip(unittest.TestCase):\n    def test_negative(self):\n        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_string(duration)), duration)\n    \nTestParseDurationRoundtrip().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}], "instruction": "Functionality: Convert a datetime.timedelta object into a human-readable string format that represents the duration. The string will include days (if any), hours, minutes, seconds, and microseconds (if any), in a non-English specific format.\n\nInputs: \n- duration (datetime.timedelta): A timedelta object that represents the duration to be converted into a string.\n\nOutputs:\n- A string representing the duration in the format '{days}:{hours}:{minutes}:{seconds}.{microseconds}' if microseconds are present, otherwise '{days}:{hours}:{minutes}:{seconds}'. If there are no days, the string will start with the hours component.", "method_code_mask": "import datetime\n\n\ndef duration_string(duration): [MASK]\n"}
{"method_name": "duration_iso_string", "full_method_name": "duration_iso_string", "method_path": "../srcdata/Network/django/django/utils/duration.py", "method_code": "import datetime\ndef duration_iso_string(duration):\n    if duration < datetime.timedelta(0):\n        sign = '-'\n        duration *= -1\n    else:\n        sign = ''\n    days, hours, minutes, seconds, microseconds = _get_duration_components(\n        duration)\n    ms = '.{:06d}'.format(microseconds) if microseconds else ''\n    return '{}P{}DT{:02d}H{:02d}M{:02d}{}S'.format(sign, days, hours,\n        minutes, seconds, ms)", "test_code_list": [{"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestISODurationString(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_iso_string(duration), 'P0DT01H03M05S')\n    \nTestISODurationString().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestISODurationString(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_iso_string(duration), 'P1DT01H03M05S')\n    \nTestISODurationString().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestISODurationString(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(duration_iso_string(duration), 'P0DT01H03M05.012345S')\n    \nTestISODurationString().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestISODurationString(unittest.TestCase):\n    def test_negative(self):\n        duration = -1 * datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(duration_iso_string(duration), '-P1DT01H03M05S')\n    \nTestISODurationString().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_simple(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_simple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_days(self):\n        duration = datetime.timedelta(days=1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_days()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_microseconds(self):\n        duration = datetime.timedelta(hours=1, minutes=3, seconds=5,\n            microseconds=12345)\n        self.assertEqual(parse_duration(duration_iso_string(duration)), duration)\n    \nTestParseISODurationRoundtrip().test_microseconds()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}, {"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestParseISODurationRoundtrip(unittest.TestCase):\n    def test_negative(self):\n        duration = datetime.timedelta(days=-1, hours=1, minutes=3, seconds=5)\n        self.assertEqual(parse_duration(duration_iso_string(duration)).\n            total_seconds(), duration.total_seconds())\n    \nTestParseISODurationRoundtrip().test_negative()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}], "instruction": "Functionality: The function 'duration_iso_string' is designed to convert a Python timedelta object into an ISO 8601 duration format string. This conversion is useful for representing time durations in a universally accepted and standardized format. The function supports both positive and negative durations.\n\nInputs: \n1. duration: A Python timedelta object that represents the duration to be converted. This object can hold the difference between two datetime objects or represent a duration in days, seconds, and microseconds.\n\nOutputs:\n1. A string: The function returns a string formatted according to ISO 8601 standards, which indicates the duration in a format that includes days, hours, minutes, seconds, and optionally microseconds. If the input duration is negative, the returned string will begin with a negative sign ('-') to denote this.", "method_code_mask": "import datetime\n\n\ndef duration_iso_string(duration): [MASK]\n"}
{"method_name": "duration_microseconds", "full_method_name": "duration_microseconds", "method_path": "../srcdata/Network/django/django/utils/duration.py", "method_code": "import datetime\ndef duration_microseconds(delta):\n    return (24 * 60 * 60 * delta.days + delta.seconds\n        ) * 1000000 + delta.microseconds", "test_code_list": [{"test_code": "import datetime\nimport unittest\nfrom django.utils.dateparse import parse_duration\nfrom django.utils.duration import duration_iso_string\nfrom django.utils.duration import duration_microseconds\nfrom django.utils.duration import duration_string\n\nclass TestDurationMicroseconds(unittest.TestCase):\n    def test(self):\n        deltas = [datetime.timedelta.max, datetime.timedelta.min, datetime.\n            timedelta.resolution, -datetime.timedelta.resolution, datetime.\n            timedelta(microseconds=8999999999999999)]\n        for delta in deltas:\n            with self.subTest(delta=delta):\n                self.assertEqual(datetime.timedelta(microseconds=\n                    duration_microseconds(delta)), delta)\n    \nTestDurationMicroseconds().test()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/utils_tests/test_duration.py"}], "instruction": "Functionality: The duration_microseconds function calculates the total duration in microseconds given a datetime.timedelta object. It takes into account the days, seconds, and microseconds components of the timedelta object, converting the entire duration into microseconds.\n\nInputs: \n    delta: A datetime.timedelta object. This object represents a duration, the difference between two dates or times. It includes components for days, seconds, and microseconds, which will be converted into a total duration in microseconds.\n\nOutputs: \n    The function returns the total duration in microseconds as a long integer. This total is calculated by converting the days and seconds components of the timedelta object into microseconds and adding this to the microseconds component of the timedelta object.", "method_code_mask": "import datetime\n\n\ndef duration_microseconds(delta): [MASK]\n"}
{"method_name": "is_pickable", "full_method_name": "is_pickable", "method_path": "../srcdata/Network/django/django/test/testcases.py", "method_code": "import difflib\nimport json\nimport logging\nimport pickle\nimport posixpath\nimport sys\nimport threading\nimport unittest\nfrom collections import Counter\nfrom contextlib import contextmanager\nfrom copy import copy\nfrom copy import deepcopy\nfrom difflib import get_close_matches\nfrom functools import wraps\nfrom unittest import mock\nfrom unittest.suite import _DebugResult\nfrom unittest.util import safe_repr\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom urllib.request import url2pathname\nfrom asgiref.sync import async_to_sync\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import locks\nfrom django.core.handlers.wsgi import WSGIHandler\nfrom django.core.handlers.wsgi import get_path_info\nfrom django.core.management import call_command\nfrom django.core.management.color import no_style\nfrom django.core.management.sql import emit_post_migrate_signal\nfrom django.core.servers.basehttp import ThreadedWSGIServer\nfrom django.core.servers.basehttp import WSGIRequestHandler\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db import transaction\nfrom django.db.backends.base.base import NO_DB_ALIAS\nfrom django.db.backends.base.base import BaseDatabaseWrapper\nfrom django.forms.fields import CharField\nfrom django.http import QueryDict\nfrom django.http.request import split_domain_port\nfrom django.http.request import validate_host\nfrom django.test.client import AsyncClient\nfrom django.test.client import Client\nfrom django.test.html import HTMLParseError\nfrom django.test.html import parse_html\nfrom django.test.signals import template_rendered\nfrom django.test.utils import CaptureQueriesContext\nfrom django.test.utils import ContextList\nfrom django.test.utils import compare_xml\nfrom django.test.utils import modify_settings\nfrom django.test.utils import override_settings\nfrom django.utils.functional import classproperty\nfrom django.utils.version import PY311\nfrom django.views.static import serve\nfrom django.http import Http404\ndef is_pickable(obj):\n    \"\"\"\n    Returns true if the object can be dumped and loaded through the pickle\n    module.\n    \"\"\"\n    try:\n        pickle.loads(pickle.dumps(obj))\n    except (AttributeError, TypeError, pickle.PickleError):\n        return False\n    return True", "test_code_list": [{"test_code": "import pickle\nfrom functools import wraps\nfrom django.db import IntegrityError\nfrom django.db import connections\nfrom django.db import transaction\nfrom django.test import TestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.testcases import DatabaseOperationForbidden\nfrom django.test.testcases import SimpleTestCase\nfrom django.test.testcases import TestData\nclass UnpicklableObject:\n\n    def __getstate__(self):\n        raise pickle.PickleError('cannot be pickled for testing reasons')\nclass TestSimpleTestCase(SimpleTestCase):\n    def test_is_picklable_with_non_picklable_object(self):\n        unpicklable_obj = UnpicklableObject()\n        self.assertEqual(is_pickable(unpicklable_obj), False)\nTestSimpleTestCase().test_is_picklable_with_non_picklable_object()", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_utils/test_testcase.py"}], "instruction": "Functionality: The is_pickable function is designed to determine whether a given object can be serialized and deserialized using the Python pickle module. This is useful for checking if an object is suitable for storage or transmission over the network.\n\nInputs: \n- obj: The object to be tested for pickle compatibility. This can be any Python object, such as lists, dictionaries, custom classes, etc.\n\nOutputs:\n- A boolean value indicating whether the object is pickable. True if the object can be pickled and unpickled without raising an exception, False otherwise.", "method_code_mask": "import difflib\nimport json\nimport logging\nimport pickle\nimport posixpath\nimport sys\nimport threading\nimport unittest\nfrom collections import Counter\nfrom contextlib import contextmanager\nfrom copy import copy\nfrom copy import deepcopy\nfrom difflib import get_close_matches\nfrom functools import wraps\nfrom unittest import mock\nfrom unittest.suite import _DebugResult\nfrom unittest.util import safe_repr\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import unquote\nfrom urllib.parse import urlencode\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nfrom urllib.parse import urlsplit\nfrom urllib.parse import urlunsplit\nfrom urllib.request import url2pathname\nfrom asgiref.sync import async_to_sync\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import locks\nfrom django.core.handlers.wsgi import WSGIHandler\nfrom django.core.handlers.wsgi import get_path_info\nfrom django.core.management import call_command\nfrom django.core.management.color import no_style\nfrom django.core.management.sql import emit_post_migrate_signal\nfrom django.core.servers.basehttp import ThreadedWSGIServer\nfrom django.core.servers.basehttp import WSGIRequestHandler\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db import transaction\nfrom django.db.backends.base.base import NO_DB_ALIAS\nfrom django.db.backends.base.base import BaseDatabaseWrapper\nfrom django.forms.fields import CharField\nfrom django.http import QueryDict\nfrom django.http.request import split_domain_port\nfrom django.http.request import validate_host\nfrom django.test.client import AsyncClient\nfrom django.test.client import Client\nfrom django.test.html import HTMLParseError\nfrom django.test.html import parse_html\nfrom django.test.signals import template_rendered\nfrom django.test.utils import CaptureQueriesContext\nfrom django.test.utils import ContextList\nfrom django.test.utils import compare_xml\nfrom django.test.utils import modify_settings\nfrom django.test.utils import override_settings\nfrom django.utils.functional import classproperty\nfrom django.utils.version import PY311\nfrom django.views.static import serve\nfrom django.http import Http404\n\n\ndef is_pickable(obj): [MASK]\n"}
{"method_name": "get_finder", "full_method_name": "get_finder", "method_path": "../srcdata/Network/django/django/contrib/staticfiles/finders.py", "method_code": "import functools\nimport os\nimport warnings\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.contrib.staticfiles import utils\nfrom django.core.checks import Error\nfrom django.core.checks import Warning\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.files.storage import FileSystemStorage\nfrom django.core.files.storage import Storage\nfrom django.core.files.storage import default_storage\nfrom django.utils._os import safe_join\nfrom django.utils.functional import LazyObject\nfrom django.utils.functional import empty\nfrom django.utils.module_loading import import_string\nclass BaseFinder:\n    \"\"\"\n    A base file finder to be used for custom staticfiles finder classes.\n    \"\"\"\n\n    def check(self, **kwargs):\n        raise NotImplementedError(\n            'subclasses may provide a check() method to verify the finder is configured correctly.'\n            )\n\n    def _check_deprecated_find_param(self, **kwargs):\n        return _check_deprecated_find_param(class_name=self.__class__.\n            __qualname__, **kwargs)\n\n    def find(self, path, find_all=False, **kwargs):\n        \"\"\"\n        Given a relative file path, find an absolute file path.\n\n        If the ``find_all`` parameter is False (default) return only the first\n        found file path; if True, return a list of all found files paths.\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseFinder must provide a find() method')\n\n    def list(self, ignore_patterns):\n        \"\"\"\n        Given an optional list of paths to ignore, return a two item iterable\n        consisting of the relative path and storage instance.\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseFinder must provide a list() method')\n@functools.cache\ndef get_finder(import_path):\n    \"\"\"\n    Import the staticfiles finder class described by import_path, where\n    import_path is the full Python path to the class.\n    \"\"\"\n    Finder = import_string(import_path)\n    if not issubclass(Finder, BaseFinder):\n        raise ImproperlyConfigured('Finder \"%s\" is not a subclass of \"%s\"' %\n            (Finder, BaseFinder))\n    return Finder()", "test_code_list": [{"test_code": "import os\nfrom django.conf import settings\nfrom django.contrib.staticfiles import finders\nfrom django.contrib.staticfiles import storage\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\n\nclass TestMiscFinder(SimpleTestCase):\n    def test_get_finder_bad_classname(self):\n        with self.assertRaises(ImportError):\n            get_finder('django.contrib.staticfiles.finders.FooBarFinder')\n    \nTestMiscFinder().test_get_finder_bad_classname()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/staticfiles_tests/test_finders.py"}, {"test_code": "import os\nfrom django.conf import settings\nfrom django.contrib.staticfiles import finders\nfrom django.contrib.staticfiles import storage\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\n\nclass TestMiscFinder(SimpleTestCase):\n    def test_get_finder_bad_module(self):\n        with self.assertRaises(ImportError):\n            get_finder('foo.bar.FooBarFinder')\n    \nTestMiscFinder().test_get_finder_bad_module()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/staticfiles_tests/test_finders.py"}], "instruction": "Functionality: The get_finder function is designed to import and return a staticfiles finder class based on the provided import path. This path indicates the full Python path to the class that is expected to be a subclass of the BaseFinder class. The function ensures that the returned class is indeed a subclass of BaseFinder and raises an ImproperlyConfigured exception if this is not the case.\n\nInputs: \n- import_path (str): A string representing the full Python path to the class that implements the staticfiles finder. This path should lead to a class that is a subclass of BaseFinder.\n\nOutputs:\n- Finder (class): The class object corresponding to the import_path provided, which must be a subclass of BaseFinder. This class is returned and is ready to be instantiated for use in finding static files within a Django project.", "method_code_mask": "import functools\nimport os\nimport warnings\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.contrib.staticfiles import utils\nfrom django.core.checks import Error\nfrom django.core.checks import Warning\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.files.storage import FileSystemStorage\nfrom django.core.files.storage import Storage\nfrom django.core.files.storage import default_storage\nfrom django.utils._os import safe_join\nfrom django.utils.functional import LazyObject\nfrom django.utils.functional import empty\nfrom django.utils.module_loading import import_string\n\n\nclass BaseFinder:\n    \"\"\"\n    A base file finder to be used for custom staticfiles finder classes.\n    \"\"\"\n\n    def check(self, **kwargs):\n        raise NotImplementedError(\n            'subclasses may provide a check() method to verify the finder is configured correctly.'\n            )\n\n    def _check_deprecated_find_param(self, **kwargs):\n        return _check_deprecated_find_param(class_name=self.__class__.\n            __qualname__, **kwargs)\n\n    def find(self, path, find_all=False, **kwargs):\n        \"\"\"\n        Given a relative file path, find an absolute file path.\n\n        If the ``find_all`` parameter is False (default) return only the first\n        found file path; if True, return a list of all found files paths.\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseFinder must provide a find() method')\n\n    def list(self, ignore_patterns):\n        \"\"\"\n        Given an optional list of paths to ignore, return a two item iterable\n        consisting of the relative path and storage instance.\n        \"\"\"\n        raise NotImplementedError(\n            'subclasses of BaseFinder must provide a list() method')\n\n\n@functools.cache\ndef get_finder(import_path): [MASK]\n"}
{"method_name": "simplify_regex", "full_method_name": "simplify_regex", "method_path": "../srcdata/Network/django/django/contrib/admindocs/views.py", "method_code": "import inspect\nfrom importlib import import_module\nfrom inspect import cleandoc\nfrom pathlib import Path\nfrom django.apps import apps\nfrom django.contrib import admin\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.admindocs import utils\nfrom django.contrib.admindocs.utils import remove_non_capturing_groups\nfrom django.contrib.admindocs.utils import replace_metacharacters\nfrom django.contrib.admindocs.utils import replace_named_groups\nfrom django.contrib.admindocs.utils import replace_unnamed_groups\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.db import models\nfrom django.http import Http404\nfrom django.template.engine import Engine\nfrom django.urls import get_mod_func\nfrom django.urls import get_resolver\nfrom django.urls import get_urlconf\nfrom django.utils._os import safe_join\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import cached_property\nfrom django.utils.inspect import func_accepts_kwargs\nfrom django.utils.inspect import func_accepts_var_args\nfrom django.utils.inspect import get_func_full_args\nfrom django.utils.inspect import method_has_no_args\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import TemplateView\ndef simplify_regex(pattern):\n    \"\"\"\n    Clean up urlpattern regexes into something more readable by humans. For\n    example, turn \"^(?P<sport_slug>\\\\w+)/athletes/(?P<athlete_slug>\\\\w+)/$\"\n    into \"/<sport_slug>/athletes/<athlete_slug>/\".\n    \"\"\"\n    pattern = remove_non_capturing_groups(pattern)\n    pattern = replace_named_groups(pattern)\n    pattern = replace_unnamed_groups(pattern)\n    pattern = replace_metacharacters(pattern)\n    if not pattern.startswith('/'):\n        pattern = '/' + pattern\n    return pattern", "test_code_list": [{"test_code": "import sys\nimport unittest\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admindocs import utils\nfrom django.contrib.admindocs import views\nfrom django.contrib.admindocs.views import get_return_data_type\nfrom django.contrib.admindocs.views import simplify_regex\nfrom django.db import models\nfrom django.db.models import fields\nfrom django.test import SimpleTestCase\nfrom django.test import modify_settings\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.urls import include\nfrom django.urls import path\nfrom django.urls import reverse\nfrom django.utils.functional import SimpleLazyObject\n\nclass AdminDocViewFunctionsTests(SimpleTestCase):\n    def test_simplify_regex(self):\n        tests = ('^(?P<a>\\\\w+)/b/(?P<c>\\\\w+)/$', '/<a>/b/<c>/'), (\n            '^(?P<a>\\\\w+)/b/(?P<c>\\\\w+)$', '/<a>/b/<c>'), (\n            '^(?P<a>\\\\w+)/b/(?P<c>\\\\w+)', '/<a>/b/<c>'), ('^(?P<a>\\\\w+)/b/(\\\\w+)$',\n            '/<a>/b/<var>'), ('^(?P<a>\\\\w+)/b/(\\\\w+)', '/<a>/b/<var>'), (\n            '^(?P<a>\\\\w+)/b/((x|y)\\\\w+)$', '/<a>/b/<var>'), (\n            '^(?P<a>\\\\w+)/b/((x|y)\\\\w+)', '/<a>/b/<var>'), (\n            '^(?P<a>(x|y))/b/(?P<c>\\\\w+)$', '/<a>/b/<c>'), (\n            '^(?P<a>(x|y))/b/(?P<c>\\\\w+)', '/<a>/b/<c>'), (\n            '^(?P<a>(x|y))/b/(?P<c>\\\\w+)ab', '/<a>/b/<c>ab'), (\n            '^(?P<a>(x|y)(\\\\(|\\\\)))/b/(?P<c>\\\\w+)ab', '/<a>/b/<c>ab'), (\n            '^a(?:\\\\w+)b', '/ab'), ('^a(?:(x|y))', '/a'), ('^(?:\\\\w+(?:\\\\w+))a',\n            '/a'), ('^a(?:\\\\w+)/b(?:\\\\w+)', '/a/b'), (\n            '(?P<a>\\\\w+)/b/(?:\\\\w+)c(?:\\\\w+)', '/<a>/b/c'), (\n            '(?P<a>\\\\w+)/b/(\\\\w+)/(?:\\\\w+)c(?:\\\\w+)', '/<a>/b/<var>/c'), ('^a',\n            '/a'), ('^^a', '/a'), ('^^^a', '/a'), ('a$', '/a'), ('a$$', '/a'), (\n            'a$$$', '/a'), ('a?', '/a'), ('a??', '/a'), ('a???', '/a'), ('a*', '/a'\n            ), ('a**', '/a'), ('a***', '/a'), ('a+', '/a'), ('a++', '/a'), ('a+++',\n            '/a'), ('\\\\Aa', '/a'), ('\\\\A\\\\Aa', '/a'), ('\\\\A\\\\A\\\\Aa', '/a'), ('a\\\\Z'\n            , '/a'), ('a\\\\Z\\\\Z', '/a'), ('a\\\\Z\\\\Z\\\\Z', '/a'), ('\\\\ba', '/a'), (\n            '\\\\b\\\\ba', '/a'), ('\\\\b\\\\b\\\\ba', '/a'), ('a\\\\B', '/a'), ('a\\\\B\\\\B',\n            '/a'), ('a\\\\B\\\\B\\\\B', '/a'), ('^a/?$', '/a/'), ('\\\\Aa\\\\Z', '/a'), (\n            '\\\\ba\\\\B', '/a'), ('\\\\^a', '/^a'), ('\\\\\\\\^a', '/\\\\\\\\a'), ('\\\\\\\\\\\\^a',\n            '/\\\\\\\\^a'), ('\\\\\\\\\\\\\\\\^a', '/\\\\\\\\\\\\\\\\a'), ('\\\\\\\\\\\\\\\\\\\\^a',\n            '/\\\\\\\\\\\\\\\\^a'), ('a\\\\$', '/a$'), ('a\\\\\\\\$', '/a\\\\\\\\'), ('a\\\\\\\\\\\\$',\n            '/a\\\\\\\\$'), ('a\\\\\\\\\\\\\\\\$', '/a\\\\\\\\\\\\\\\\'), ('a\\\\\\\\\\\\\\\\\\\\$',\n            '/a\\\\\\\\\\\\\\\\$'), ('a\\\\?', '/a?'), ('a\\\\\\\\?', '/a\\\\\\\\'), ('a\\\\\\\\\\\\?',\n            '/a\\\\\\\\?'), ('a\\\\\\\\\\\\\\\\?', '/a\\\\\\\\\\\\\\\\'), ('a\\\\\\\\\\\\\\\\\\\\?',\n            '/a\\\\\\\\\\\\\\\\?'), ('a\\\\*', '/a*'), ('a\\\\\\\\*', '/a\\\\\\\\'), ('a\\\\\\\\\\\\*',\n            '/a\\\\\\\\*'), ('a\\\\\\\\\\\\\\\\*', '/a\\\\\\\\\\\\\\\\'), ('a\\\\\\\\\\\\\\\\\\\\*',\n            '/a\\\\\\\\\\\\\\\\*'), ('a\\\\+', '/a+'), ('a\\\\\\\\+', '/a\\\\\\\\'), ('a\\\\\\\\\\\\+',\n            '/a\\\\\\\\+'), ('a\\\\\\\\\\\\\\\\+', '/a\\\\\\\\\\\\\\\\'), ('a\\\\\\\\\\\\\\\\\\\\+',\n            '/a\\\\\\\\\\\\\\\\+'), ('\\\\\\\\Aa', '/\\\\Aa'), ('\\\\\\\\\\\\Aa', '/\\\\\\\\a'), (\n            '\\\\\\\\\\\\\\\\Aa', '/\\\\\\\\\\\\Aa'), ('\\\\\\\\\\\\\\\\\\\\Aa', '/\\\\\\\\\\\\\\\\a'), (\n            '\\\\\\\\\\\\\\\\\\\\\\\\Aa', '/\\\\\\\\\\\\\\\\\\\\Aa'), ('a\\\\\\\\Z', '/a\\\\Z'), ('a\\\\\\\\\\\\Z',\n            '/a\\\\\\\\'), ('a\\\\\\\\\\\\\\\\Z', '/a\\\\\\\\\\\\Z'), ('a\\\\\\\\\\\\\\\\\\\\Z', '/a\\\\\\\\\\\\\\\\'\n            ), ('a\\\\\\\\\\\\\\\\\\\\\\\\Z', '/a\\\\\\\\\\\\\\\\\\\\Z'), ('^a\\\\?$', '/a?'), ('^a\\\\\\\\?$',\n            '/a\\\\\\\\'), ('^a\\\\\\\\\\\\?$', '/a\\\\\\\\?'), ('^a\\\\\\\\\\\\\\\\?$', '/a\\\\\\\\\\\\\\\\'), (\n            '^a\\\\\\\\\\\\\\\\\\\\?$', '/a\\\\\\\\\\\\\\\\?'), ('^a\\\\?\\\\$', '/a?$'), ('^a\\\\\\\\?\\\\\\\\$'\n            , '/a\\\\\\\\\\\\\\\\'), ('^a\\\\\\\\\\\\?\\\\\\\\\\\\$', '/a\\\\\\\\?\\\\\\\\$'), (\n            '^a\\\\\\\\\\\\\\\\?\\\\\\\\\\\\\\\\$', '/a\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'), (\n            '^a\\\\\\\\\\\\\\\\\\\\?\\\\\\\\\\\\\\\\\\\\$', '/a\\\\\\\\\\\\\\\\?\\\\\\\\\\\\\\\\$'), (\n            '^\\\\b(?P<slug>\\\\w+)\\\\B/(\\\\w+)?', '/<slug>/<var>'), (\n            '^\\\\A(?P<slug>\\\\w+)\\\\Z', '/<slug>')\n        for pattern, output in tests:\n            with self.subTest(pattern=pattern):\n                self.assertEqual(simplify_regex(pattern), output)\n    \nAdminDocViewFunctionsTests().test_simplify_regex()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_docs/test_views.py"}], "instruction": "Functionality: The function 'simplify_regex' is designed to clean up and simplify regular expressions that are used in URL patterns, making them more readable and understandable for humans. It processes the input regular expression by removing non-capturing groups, replacing named and unnamed groups with more understandable placeholders, and replacing metacharacters, ensuring the pattern starts with a forward slash if it doesn't already.\n\nInputs: \n- pattern: A string representing a regular expression used in URL patterns. This pattern should be compatible with Python's regular expression syntax and is intended to match specific URL formats.\n\nOutputs: \n- A string representing the simplified version of the input regular expression. The output will be a human-readable format of the URL pattern, where named and unnamed groups are substituted with placeholders like '<group_name>', and metacharacters are replaced with their plain text equivalents. The output pattern is guaranteed to start with a forward slash if it wasn't already the case.", "method_code_mask": "import inspect\nfrom importlib import import_module\nfrom inspect import cleandoc\nfrom pathlib import Path\nfrom django.apps import apps\nfrom django.contrib import admin\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.admindocs import utils\nfrom django.contrib.admindocs.utils import remove_non_capturing_groups\nfrom django.contrib.admindocs.utils import replace_metacharacters\nfrom django.contrib.admindocs.utils import replace_named_groups\nfrom django.contrib.admindocs.utils import replace_unnamed_groups\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.db import models\nfrom django.http import Http404\nfrom django.template.engine import Engine\nfrom django.urls import get_mod_func\nfrom django.urls import get_resolver\nfrom django.urls import get_urlconf\nfrom django.utils._os import safe_join\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import cached_property\nfrom django.utils.inspect import func_accepts_kwargs\nfrom django.utils.inspect import func_accepts_var_args\nfrom django.utils.inspect import get_func_full_args\nfrom django.utils.inspect import method_has_no_args\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import TemplateView\n\n\ndef simplify_regex(pattern): [MASK]\n"}
{"method_name": "dependency_ordered", "full_method_name": "dependency_ordered", "method_path": "../srcdata/Network/django/django/test/utils.py", "method_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef dependency_ordered(test_databases, dependencies):\n    \"\"\"\n    Reorder test_databases into an order that honors the dependencies\n    described in TEST[DEPENDENCIES].\n    \"\"\"\n    ordered_test_databases = []\n    resolved_databases = set()\n    dependencies_map = {}\n    for sig, (_, aliases) in test_databases:\n        all_deps = set()\n        for alias in aliases:\n            all_deps.update(dependencies.get(alias, []))\n        if not all_deps.isdisjoint(aliases):\n            raise ImproperlyConfigured(\n                'Circular dependency: databases %r depend on each other, but are aliases.'\n                 % aliases)\n        dependencies_map[sig] = all_deps\n    while test_databases:\n        changed = False\n        deferred = []\n        for signature, (db_name, aliases) in test_databases:\n            if dependencies_map[signature].issubset(resolved_databases):\n                resolved_databases.update(aliases)\n                ordered_test_databases.append((signature, (db_name, aliases)))\n                changed = True\n            else:\n                deferred.append((signature, (db_name, aliases)))\n        if not changed:\n            raise ImproperlyConfigured(\n                'Circular dependency in TEST[DEPENDENCIES]')\n        test_databases = deferred\n    return ordered_test_databases", "test_code_list": [{"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass DependencyOrderingTests(unittest.TestCase):\n    def test_simple_dependencies(self):\n        raw = [('s1', ('s1_db', ['alpha'])), ('s2', ('s2_db', ['bravo'])), (\n            's3', ('s3_db', ['charlie']))]\n        dependencies = {'alpha': ['charlie'], 'bravo': ['charlie']}\n        ordered = dependency_ordered(raw, dependencies=dependencies)\n        ordered_sigs = [sig for sig, value in ordered]\n        self.assertIn('s1', ordered_sigs)\n        self.assertIn('s2', ordered_sigs)\n        self.assertIn('s3', ordered_sigs)\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))\n    \nDependencyOrderingTests().test_simple_dependencies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}, {"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass DependencyOrderingTests(unittest.TestCase):\n    def test_chained_dependencies(self):\n        raw = [('s1', ('s1_db', ['alpha'])), ('s2', ('s2_db', ['bravo'])), (\n            's3', ('s3_db', ['charlie']))]\n        dependencies = {'alpha': ['bravo'], 'bravo': ['charlie']}\n        ordered = dependency_ordered(raw, dependencies=dependencies)\n        ordered_sigs = [sig for sig, value in ordered]\n        self.assertIn('s1', ordered_sigs)\n        self.assertIn('s2', ordered_sigs)\n        self.assertIn('s3', ordered_sigs)\n        self.assertLess(ordered_sigs.index('s2'), ordered_sigs.index('s1'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))\n    \nDependencyOrderingTests().test_chained_dependencies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}, {"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass DependencyOrderingTests(unittest.TestCase):\n    def test_multiple_dependencies(self):\n        raw = [('s1', ('s1_db', ['alpha'])), ('s2', ('s2_db', ['bravo'])), (\n            's3', ('s3_db', ['charlie'])), ('s4', ('s4_db', ['delta']))]\n        dependencies = {'alpha': ['bravo', 'delta'], 'bravo': ['charlie'],\n            'delta': ['charlie']}\n        ordered = dependency_ordered(raw, dependencies=dependencies)\n        ordered_sigs = [sig for sig, aliases in ordered]\n        self.assertIn('s1', ordered_sigs)\n        self.assertIn('s2', ordered_sigs)\n        self.assertIn('s3', ordered_sigs)\n        self.assertIn('s4', ordered_sigs)\n        self.assertLess(ordered_sigs.index('s2'), ordered_sigs.index('s1'))\n        self.assertLess(ordered_sigs.index('s4'), ordered_sigs.index('s1'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s2'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s4'))\n        self.assertLess(ordered_sigs.index('s3'), ordered_sigs.index('s1'))\n    \nDependencyOrderingTests().test_multiple_dependencies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}, {"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass DependencyOrderingTests(unittest.TestCase):\n    def test_circular_dependencies(self):\n        raw = [('s1', ('s1_db', ['alpha'])), ('s2', ('s2_db', ['bravo']))]\n        dependencies = {'bravo': ['alpha'], 'alpha': ['bravo']}\n        with self.assertRaises(ImproperlyConfigured):\n            dependency_ordered(raw, dependencies=dependencies)\n    \nDependencyOrderingTests().test_circular_dependencies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}, {"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass DependencyOrderingTests(unittest.TestCase):\n    def test_own_alias_dependency(self):\n        raw = [('s1', ('s1_db', ['alpha', 'bravo']))]\n        dependencies = {'alpha': ['bravo']}\n        with self.assertRaises(ImproperlyConfigured):\n            dependency_ordered(raw, dependencies=dependencies)\n        raw = [('s1', ('s1_db', ['bravo', 'alpha']))]\n        with self.assertRaises(ImproperlyConfigured):\n            dependency_ordered(raw, dependencies=dependencies)\n    \nDependencyOrderingTests().test_own_alias_dependency()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}], "instruction": "Functionality: The dependency_ordered function is designed to reorder a list of test databases based on their dependencies, ensuring that each database is tested after the databases it depends on. This function ensures that the order of testing respects the dependencies defined in the TEST[DEPENDENCIES] configuration, preventing testing conflicts and ensuring a logical testing sequence.\n\nInputs: \n- test_databases: A list of tuples where each tuple represents an element in the test database. Each tuple contains a signature and a tuple with the database name and a list of aliases.\n- dependencies: A dictionary where the keys are database aliases and the values are lists of other database aliases that the key database depends on.\n\nOutputs:\n- ordered_test_databases: A list of tuples representing the test databases reordered to respect the dependency relationships defined. Each tuple contains a signature and a tuple with the database name and a list of aliases. This output list ensures that no database is tested before any of its dependencies.", "method_code_mask": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n\n\ndef dependency_ordered(test_databases, dependencies): [MASK]\n"}
{"method_name": "get_unique_databases_and_mirrors", "full_method_name": "get_unique_databases_and_mirrors", "method_path": "../srcdata/Network/django/django/test/utils.py", "method_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef get_unique_databases_and_mirrors(aliases=None):\n    \"\"\"\n    Figure out which databases actually need to be created.\n\n    Deduplicate entries in DATABASES that correspond the same database or are\n    configured as test mirrors.\n\n    Return two values:\n    - test_databases: ordered mapping of signatures to (name, list of aliases)\n                      where all aliases share the same underlying database.\n    - mirrored_aliases: mapping of mirror aliases to original aliases.\n    \"\"\"\n    if aliases is None:\n        aliases = connections\n    mirrored_aliases = {}\n    test_databases = {}\n    dependencies = {}\n    default_sig = connections[DEFAULT_DB_ALIAS].creation.test_db_signature()\n    for alias in connections:\n        connection = connections[alias]\n        test_settings = connection.settings_dict['TEST']\n        if test_settings['MIRROR']:\n            mirrored_aliases[alias] = test_settings['MIRROR']\n        elif alias in aliases:\n            item = test_databases.setdefault(connection.creation.\n                test_db_signature(), (connection.settings_dict['NAME'], []))\n            if alias == DEFAULT_DB_ALIAS:\n                item[1].insert(0, alias)\n            else:\n                item[1].append(alias)\n            if 'DEPENDENCIES' in test_settings:\n                dependencies[alias] = test_settings['DEPENDENCIES']\n            elif alias != DEFAULT_DB_ALIAS and connection.creation.test_db_signature(\n                ) != default_sig:\n                dependencies[alias] = test_settings.get('DEPENDENCIES', [\n                    DEFAULT_DB_ALIAS])\n    test_databases = dict(dependency_ordered(test_databases.items(),\n        dependencies))\n    return test_databases, mirrored_aliases", "test_code_list": [{"test_code": "import collections.abc\nimport multiprocessing\nimport os\nimport sys\nimport unittest\nfrom unittest import mock\nfrom django import db\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.management import call_command\nfrom django.core.management.base import CommandError\nfrom django.core.management.base import SystemCheckError\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.runner import DiscoverRunner\nfrom django.test.runner import Shuffler\nfrom django.test.runner import _init_worker\nfrom django.test.runner import reorder_test_bin\nfrom django.test.runner import reorder_tests\nfrom django.test.runner import shuffle_tests\nfrom django.test.testcases import connections_support_transactions\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import dependency_ordered\nfrom django.test.utils import get_unique_databases_and_mirrors\nfrom django.test.utils import iter_test_cases\nfrom django.utils.version import PY312\n\nclass SetupDatabasesTests(unittest.TestCase):\n    def test_setup_test_database_aliases(self):\n        \"\"\"\n            The default database must be the first because data migrations\n            use the default alias by default.\n            \"\"\"\n        tested_connections = db.ConnectionHandler({'other': {'ENGINE':\n            'django.db.backends.dummy', 'NAME': 'dbname'}, 'default': {'ENGINE':\n            'django.db.backends.dummy', 'NAME': 'dbname'}})\n        with mock.patch('django.test.utils.connections', new=tested_connections):\n            test_databases, _ = get_unique_databases_and_mirrors()\n            self.assertEqual(test_databases, {('', '',\n                'django.db.backends.dummy', 'test_dbname'): ('dbname', [\n                'default', 'other'])})\n    \nSetupDatabasesTests().test_setup_test_database_aliases()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/tests.py"}], "instruction": "Functionality: The get_unique_databases_and_mirrors function is designed to identify and manage unique database configurations and their mirrors from Django's DATABASES settings. It deduplicates entries that correspond to the same underlying database or are configured as test mirrors, returning a mapping of unique databases and their aliases, as well as a mapping of mirrored aliases to their original databases.\n\nInputs: \n- aliases: (Optional) A list or dictionary of database aliases. If None, it defaults to considering all connections managed by Django.\n\nOutputs: \n- test_databases: An ordered mapping where keys are signatures representing unique database configurations, and values are tuples containing the database name and a list of aliases that share the same underlying database.\n- mirrored_aliases: A dictionary mapping mirror aliases to their original aliases, indicating which databases are mirrors of others.", "method_code_mask": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n\n\ndef get_unique_databases_and_mirrors(aliases=None): [MASK]\n"}
{"method_name": "_hash_text", "full_method_name": "Shuffler._hash_text", "method_path": "../srcdata/Network/django/django/test/runner.py", "method_code": "import argparse\nimport ctypes\nimport faulthandler\nimport hashlib\nimport io\nimport itertools\nimport logging\nimport multiprocessing\nimport os\nimport pickle\nimport random\nimport sys\nimport textwrap\nimport unittest\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom io import StringIO\nimport sqlparse\nimport django\nfrom django.core.management import call_command\nfrom django.db import connections\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test.utils import NullTimeKeeper\nfrom django.test.utils import TimeKeeper\nfrom django.test.utils import iter_test_cases\nfrom django.test.utils import setup_databases as _setup_databases\nfrom django.test.utils import setup_test_environment\nfrom django.test.utils import teardown_databases as _teardown_databases\nfrom django.test.utils import teardown_test_environment\nfrom django.utils.datastructures import OrderedSet\nfrom django.utils.version import PY312\nimport pdb\nclass Shuffler:\n    \"\"\"\n    This class implements shuffling with a special consistency property.\n    Consistency means that, for a given seed and key function, if two sets of\n    items are shuffled, the resulting order will agree on the intersection of\n    the two sets. For example, if items are removed from an original set, the\n    shuffled order for the new set will be the shuffled order of the original\n    set restricted to the smaller set.\n    \"\"\"\n    hash_algorithm = 'md5'\n\n    @classmethod\n    def _hash_text(cls, text):\n        h = hashlib.new(cls.hash_algorithm, usedforsecurity=False)\n        h.update(text.encode('utf-8'))\n        return h.hexdigest()\n\n    def __init__(self, seed=None):\n        if seed is None:\n            seed = random.randint(0, 10 ** 10 - 1)\n            seed_source = 'generated'\n        else:\n            seed_source = 'given'\n        self.seed = seed\n        self.seed_source = seed_source\n\n    @property\n    def seed_display(self):\n        return f'{self.seed!r} ({self.seed_source})'\n\n    def _hash_item(self, item, key):\n        text = '{}{}'.format(self.seed, key(item))\n        return self._hash_text(text)\n\n    def shuffle(self, items, key):\n        \"\"\"\n        Return a new list of the items in a shuffled order.\n\n        The `key` is a function that accepts an item in `items` and returns\n        a string unique for that item that can be viewed as a string id. The\n        order of the return value is deterministic. It depends on the seed\n        and key function but not on the original order.\n        \"\"\"\n        hashes = {}\n        for item in items:\n            hashed = self._hash_item(item, key)\n            if hashed in hashes:\n                msg = 'item {!r} has same hash {!r} as item {!r}'.format(item,\n                    hashed, hashes[hashed])\n                raise RuntimeError(msg)\n            hashes[hashed] = item\n        return [hashes[hashed] for hashed in sorted(hashes)]", "test_code_list": [{"test_code": "from unittest import mock\nfrom django.test import SimpleTestCase\nfrom django.test.runner import Shuffler\n\nclass ShufflerTests(SimpleTestCase):\n    def test_hash_text(self):\n        actual = Shuffler._hash_text('abcd')\n        self.assertEqual(actual, 'e2fc714c4727ee9395f324cd2e7f331f')\n    \nShufflerTests().test_hash_text()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner/test_shuffler.py"}], "instruction": "Functionality: The Shuffler._hash_text function generates a hash value for a given text input using the MD5 hashing algorithm. This is part of a shuffling mechanism designed to ensure consistency in the order of items when shuffling multiple sets of items with the same seed and key function.\n\nInputs: \n- text: A string for which the hash value is to be generated.\n\nOutputs: \n- A string representing the hexadecimal digest of the hash value. This is generated by encoding the input text in UTF-8, hashing it using the MD5 algorithm, and then returning the hexadecimal representation of the hash.", "method_code_mask": "import argparse\nimport ctypes\nimport faulthandler\nimport hashlib\nimport io\nimport itertools\nimport logging\nimport multiprocessing\nimport os\nimport pickle\nimport random\nimport sys\nimport textwrap\nimport unittest\nfrom collections import defaultdict\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom io import StringIO\nimport sqlparse\nimport django\nfrom django.core.management import call_command\nfrom django.db import connections\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test.utils import NullTimeKeeper\nfrom django.test.utils import TimeKeeper\nfrom django.test.utils import iter_test_cases\nfrom django.test.utils import setup_databases as _setup_databases\nfrom django.test.utils import setup_test_environment\nfrom django.test.utils import teardown_databases as _teardown_databases\nfrom django.test.utils import teardown_test_environment\nfrom django.utils.datastructures import OrderedSet\nfrom django.utils.version import PY312\nimport pdb\n\n\nclass Shuffler:\n    \"\"\"\n    This class implements shuffling with a special consistency property.\n    Consistency means that, for a given seed and key function, if two sets of\n    items are shuffled, the resulting order will agree on the intersection of\n    the two sets. For example, if items are removed from an original set, the\n    shuffled order for the new set will be the shuffled order of the original\n    set restricted to the smaller set.\n    \"\"\"\n    hash_algorithm = 'md5'\n\n    @classmethod\n    def _hash_text(cls, text): [MASK]\n\n    def __init__(self, seed=None):\n        if seed is None:\n            seed = random.randint(0, 10 ** 10 - 1)\n            seed_source = 'generated'\n        else:\n            seed_source = 'given'\n        self.seed = seed\n        self.seed_source = seed_source\n\n    @property\n    def seed_display(self):\n        return f'{self.seed!r} ({self.seed_source})'\n\n    def _hash_item(self, item, key):\n        text = '{}{}'.format(self.seed, key(item))\n        return self._hash_text(text)\n\n    def shuffle(self, items, key):\n        \"\"\"\n        Return a new list of the items in a shuffled order.\n\n        The `key` is a function that accepts an item in `items` and returns\n        a string unique for that item that can be viewed as a string id. The\n        order of the return value is deterministic. It depends on the seed\n        and key function but not on the original order.\n        \"\"\"\n        hashes = {}\n        for item in items:\n            hashed = self._hash_item(item, key)\n            if hashed in hashes:\n                msg = 'item {!r} has same hash {!r} as item {!r}'.format(item,\n                    hashed, hashes[hashed])\n                raise RuntimeError(msg)\n            hashes[hashed] = item\n        return [hashes[hashed] for hashed in sorted(hashes)]\n"}
{"method_name": "truncate_name", "full_method_name": "truncate_name", "method_path": "../srcdata/Network/django/django/db/backends/utils.py", "method_code": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\ndef truncate_name(identifier, length=None, hash_len=4):\n    \"\"\"\n    Shorten an SQL identifier to a repeatable mangled version with the given\n    length.\n\n    If a quote stripped name contains a namespace, e.g. USERNAME\".\"TABLE,\n    truncate the table portion only.\n    \"\"\"\n    namespace, name = split_identifier(identifier)\n    if length is None or len(name) <= length:\n        return identifier\n    digest = names_digest(name, length=hash_len)\n    return '%s%s%s' % ('%s\".\"' % namespace if namespace else '', name[:\n        length - hash_len], digest)", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom decimal import Rounded\nfrom django.db import NotSupportedError\nfrom django.db import connection\nfrom django.db.backends.utils import format_number\nfrom django.db.backends.utils import split_identifier\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import truncate_name\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipIfDBFeature\nfrom django.test import skipUnlessDBFeature\n\nclass TestUtils(SimpleTestCase):\n    def test_truncate_name(self):\n        self.assertEqual(truncate_name('some_table', 10), 'some_table')\n        self.assertEqual(truncate_name('some_long_table', 10), 'some_la38a')\n        self.assertEqual(truncate_name('some_long_table', 10, 3), 'some_loa38')\n        self.assertEqual(truncate_name('some_long_table'), 'some_long_table')\n        self.assertEqual(truncate_name('username\".\"some_table', 10),\n            'username\".\"some_table')\n        self.assertEqual(truncate_name('username\".\"some_long_table', 10),\n            'username\".\"some_la38a')\n        self.assertEqual(truncate_name('username\".\"some_long_table', 10, 3),\n            'username\".\"some_loa38')\n    \nTestUtils().test_truncate_name()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/test_utils.py"}], "instruction": "Functionality: The truncate_name function shortens an SQL identifier to a repeatable mangled version with a given length. If the length of the identifier exceeds the specified length, it truncates the table portion of the name and appends a hash to ensure uniqueness. The function supports identifiers that contain namespaces, such as \"USERNAME\".\"TABLE\", by truncating only the table portion.\n\nInputs:\n- identifier: A string representing the original SQL identifier to be truncated. It can contain a namespace, e.g., \"USERNAME\".\"TABLE\".\n- length: An optional integer specifying the maximum length of the truncated identifier, including the namespace and hash. If length is None or the original identifier's length is less than or equal to length, the identifier is not truncated.\n- hash_len: An optional integer specifying the length of the hash to be appended when the identifier is truncated. The default value is 4.\n\nOutputs:\n- Returns a string representing the truncated identifier. This string will be the original identifier if it does not exceed the length, or a truncated version with the hash appended if it does. If the identifier contains a namespace, the namespace will be preserved, and only the table portion will be truncated.", "method_code_mask": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\n\n\ndef truncate_name(identifier, length=None, hash_len=4): [MASK]\n"}
{"method_name": "get_warning_for_invalid_pattern", "full_method_name": "get_warning_for_invalid_pattern", "method_path": "../srcdata/Network/django/django/core/checks/urls.py", "method_code": "import inspect\nfrom collections import Counter\nfrom django.conf import settings\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.urls import get_resolver\ndef get_warning_for_invalid_pattern(pattern):\n    \"\"\"\n    Return a list containing a warning that the pattern is invalid.\n\n    describe_pattern() cannot be used here, because we cannot rely on the\n    urlpattern having regex or name attributes.\n    \"\"\"\n    if isinstance(pattern, str):\n        hint = (\n            \"Try removing the string '{}'. The list of urlpatterns should not have a prefix string as the first element.\"\n            .format(pattern))\n    elif isinstance(pattern, tuple):\n        hint = 'Try using path() instead of a tuple.'\n    else:\n        hint = None\n    return [Error(\n        'Your URL pattern {!r} is invalid. Ensure that urlpatterns is a list of path() and/or re_path() instances.'\n        .format(pattern), hint=hint, id='urls.E004')]", "test_code_list": [{"test_code": "from django.conf import settings\nfrom django.core.checks.messages import Error\nfrom django.core.checks.messages import Warning\nfrom django.core.checks.urls import E006\nfrom django.core.checks.urls import check_url_config\nfrom django.core.checks.urls import check_url_namespaces_unique\nfrom django.core.checks.urls import check_url_settings\nfrom django.core.checks.urls import get_warning_for_invalid_pattern\nfrom django.test import SimpleTestCase\nfrom django.test.utils import override_settings\n\nclass CheckUrlConfigTests(SimpleTestCase):\n    def test_get_warning_for_invalid_pattern_string(self):\n        warning = get_warning_for_invalid_pattern('')[0]\n        self.assertEqual(warning.hint,\n            \"Try removing the string ''. The list of urlpatterns should not have a prefix string as the first element.\"\n            )\n    \nCheckUrlConfigTests().test_get_warning_for_invalid_pattern_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/check_framework/test_urls.py"}, {"test_code": "from django.conf import settings\nfrom django.core.checks.messages import Error\nfrom django.core.checks.messages import Warning\nfrom django.core.checks.urls import E006\nfrom django.core.checks.urls import check_url_config\nfrom django.core.checks.urls import check_url_namespaces_unique\nfrom django.core.checks.urls import check_url_settings\nfrom django.core.checks.urls import get_warning_for_invalid_pattern\nfrom django.test import SimpleTestCase\nfrom django.test.utils import override_settings\n\nclass CheckUrlConfigTests(SimpleTestCase):\n    def test_get_warning_for_invalid_pattern_tuple(self):\n        warning = get_warning_for_invalid_pattern(('^$', lambda x: x))[0]\n        self.assertEqual(warning.hint, 'Try using path() instead of a tuple.')\n    \nCheckUrlConfigTests().test_get_warning_for_invalid_pattern_tuple()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/check_framework/test_urls.py"}, {"test_code": "from django.conf import settings\nfrom django.core.checks.messages import Error\nfrom django.core.checks.messages import Warning\nfrom django.core.checks.urls import E006\nfrom django.core.checks.urls import check_url_config\nfrom django.core.checks.urls import check_url_namespaces_unique\nfrom django.core.checks.urls import check_url_settings\nfrom django.core.checks.urls import get_warning_for_invalid_pattern\nfrom django.test import SimpleTestCase\nfrom django.test.utils import override_settings\n\nclass CheckUrlConfigTests(SimpleTestCase):\n    def test_get_warning_for_invalid_pattern_other(self):\n        warning = get_warning_for_invalid_pattern(object())[0]\n        self.assertIsNone(warning.hint)\n    \nCheckUrlConfigTests().test_get_warning_for_invalid_pattern_other()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/check_framework/test_urls.py"}], "instruction": "Functionality: The get_warning_for_invalid_pattern function is designed to validate URL patterns in Django projects. It checks whether a given pattern is invalid based on predefined criteria and returns a warning if the pattern does not meet the requirements.\n\nInputs: The function takes a single argument, pattern, which represents the URL pattern to be validated. The pattern can be a string, tuple, or any other type that may be used in Django's urlpatterns.\n\nOutputs: The function returns a list containing a single Error object. This object holds a warning message that indicates the pattern is invalid and provides hints on how to correct it, formatted as follows:\n    - The warning message: \"Your URL pattern {!r} is invalid. Ensure that urlpatterns is a list of path() and/or re_path() instances.\"\n    - The hint message: This depends on the type of the pattern. For a string pattern, the hint suggests removing the string. For a tuple pattern, it suggests using path() instead. If the pattern is of any other type, the hint is None.\n\nThe id of the error is 'urls.E004', which is a standard Django error ID for URL configuration issues.", "method_code_mask": "import inspect\nfrom collections import Counter\nfrom django.conf import settings\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.urls import get_resolver\n\n\ndef get_warning_for_invalid_pattern(pattern): [MASK]\n"}
{"method_name": "get_random_secret_key", "full_method_name": "get_random_secret_key", "method_path": "../srcdata/Network/django/django/core/management/utils.py", "method_code": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\ndef get_random_secret_key():\n    \"\"\"\n    Return a 50 character random string usable as a SECRET_KEY setting value.\n    \"\"\"\n    chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'\n    return get_random_string(50, chars)", "test_code_list": [{"test_code": "import os\nfrom argparse import ArgumentDefaultsHelpFormatter\nfrom io import StringIO\nfrom unittest import mock\nfrom django.apps import apps\nfrom django.core import management\nfrom django.core.checks import Tags\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import find_commands\nfrom django.core.management.utils import find_command\nfrom django.core.management.utils import get_random_secret_key\nfrom django.core.management.utils import is_ignored_path\nfrom django.core.management.utils import normalize_path_patterns\nfrom django.core.management.utils import popen_wrapper\nfrom django.db import connection\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import extend_sys_path\nfrom django.utils import translation\n\nclass UtilsTests(SimpleTestCase):\n    def test_get_random_secret_key(self):\n        key = get_random_secret_key()\n        self.assertEqual(len(key), 50)\n        for char in key:\n            self.assertIn(char,\n                'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)')\n    \nUtilsTests().test_get_random_secret_key()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/user_commands/tests.py"}], "instruction": "Functionality: The function get_random_secret_key is designed to generate a random string specifically for use as a SECRET_KEY setting value in Django settings. This string is crucial for maintaining the security of Django applications by ensuring that cryptographic functions and session management remain secure.\n\nInputs: There are no input arguments for this function. It does not require any external input to generate the 50-character random string.\n\nOutputs: The function returns a single output, which is a 50-character string comprised of a specific set of characters including lowercase letters, digits, and a variety of special characters. This output is intended to be used directly as a SECRET_KEY value for Django settings.", "method_code_mask": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\n\n\ndef get_random_secret_key(): [MASK]\n"}
{"method_name": "get_field_names_from_opts", "full_method_name": "get_field_names_from_opts", "method_path": "../srcdata/Network/django/django/db/models/sql/query.py", "method_code": "import copy\nimport difflib\nimport functools\nimport sys\nfrom collections import Counter\nfrom collections import namedtuple\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom itertools import chain\nfrom itertools import count\nfrom itertools import product\nfrom string import ascii_uppercase\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import FieldError\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import NotSupportedError\nfrom django.db import connections\nfrom django.db.models.aggregates import Count\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.expressions import BaseExpression\nfrom django.db.models.expressions import Col\nfrom django.db.models.expressions import Exists\nfrom django.db.models.expressions import F\nfrom django.db.models.expressions import OuterRef\nfrom django.db.models.expressions import RawSQL\nfrom django.db.models.expressions import Ref\nfrom django.db.models.expressions import ResolvedOuterRef\nfrom django.db.models.expressions import Value\nfrom django.db.models.fields import Field\nfrom django.db.models.fields.related_lookups import MultiColSource\nfrom django.db.models.lookups import Lookup\nfrom django.db.models.query_utils import Q\nfrom django.db.models.query_utils import check_rel_lookup_compatibility\nfrom django.db.models.query_utils import refs_expression\nfrom django.db.models.sql.constants import INNER\nfrom django.db.models.sql.constants import LOUTER\nfrom django.db.models.sql.constants import ORDER_DIR\nfrom django.db.models.sql.constants import SINGLE\nfrom django.db.models.sql.datastructures import BaseTable\nfrom django.db.models.sql.datastructures import Empty\nfrom django.db.models.sql.datastructures import Join\nfrom django.db.models.sql.datastructures import MultiJoin\nfrom django.db.models.sql.where import AND\nfrom django.db.models.sql.where import OR\nfrom django.db.models.sql.where import ExtraWhere\nfrom django.db.models.sql.where import NothingNode\nfrom django.db.models.sql.where import WhereNode\nfrom django.utils.functional import cached_property\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.tree import Node\nfrom django.db.models.query import QuerySet\nfrom django.db.models.sql.subqueries import AggregateQuery\ndef get_field_names_from_opts(opts):\n    if opts is None:\n        return set()\n    return set(chain.from_iterable((f.name, f.attname) if f.concrete else (\n        f.name,) for f in opts.get_fields()))", "test_code_list": [{"test_code": "from datetime import datetime\nfrom django.core.exceptions import FieldError\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connection\nfrom django.db.models import BooleanField\nfrom django.db.models import CharField\nfrom django.db.models import F\nfrom django.db.models import Q\nfrom django.db.models.expressions import Col\nfrom django.db.models.expressions import Exists\nfrom django.db.models.expressions import ExpressionWrapper\nfrom django.db.models.expressions import Func\nfrom django.db.models.expressions import RawSQL\nfrom django.db.models.expressions import Value\nfrom django.db.models.fields.related_lookups import RelatedIsNull\nfrom django.db.models.functions import Lower\nfrom django.db.models.lookups import Exact\nfrom django.db.models.lookups import GreaterThan\nfrom django.db.models.lookups import IsNull\nfrom django.db.models.lookups import LessThan\nfrom django.db.models.sql.constants import SINGLE\nfrom django.db.models.sql.query import JoinPromoter\nfrom django.db.models.sql.query import Query\nfrom django.db.models.sql.query import get_field_names_from_opts\nfrom django.db.models.sql.where import AND\nfrom django.db.models.sql.where import OR\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import skipUnlessDBFeature\nfrom django.test.utils import register_lookup\n\nclass TestQueryNoModel(TestCase):\n    def test_get_field_names_from_opts(self):\n        self.assertEqual(get_field_names_from_opts(None), set())\n    \nTestQueryNoModel().test_get_field_names_from_opts()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/queries/test_query.py"}], "instruction": "Functionality: The function 'get_field_names_from_opts' is designed to extract and return the names of all fields from the provided Django model options. It accounts for concrete fields by including both their name and attname, while for non-concrete fields, it only includes the name.\n\nInputs: \n- opts: A Python object representing the options of a Django model. This object contains information about the model's fields and other related properties.\n\nOutputs: \n- A set of strings representing the names of all fields associated with the provided model options. This includes the names of all fields as well as the attname for concrete fields.", "method_code_mask": "import copy\nimport difflib\nimport functools\nimport sys\nfrom collections import Counter\nfrom collections import namedtuple\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom itertools import chain\nfrom itertools import count\nfrom itertools import product\nfrom string import ascii_uppercase\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import FieldError\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import NotSupportedError\nfrom django.db import connections\nfrom django.db.models.aggregates import Count\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.expressions import BaseExpression\nfrom django.db.models.expressions import Col\nfrom django.db.models.expressions import Exists\nfrom django.db.models.expressions import F\nfrom django.db.models.expressions import OuterRef\nfrom django.db.models.expressions import RawSQL\nfrom django.db.models.expressions import Ref\nfrom django.db.models.expressions import ResolvedOuterRef\nfrom django.db.models.expressions import Value\nfrom django.db.models.fields import Field\nfrom django.db.models.fields.related_lookups import MultiColSource\nfrom django.db.models.lookups import Lookup\nfrom django.db.models.query_utils import Q\nfrom django.db.models.query_utils import check_rel_lookup_compatibility\nfrom django.db.models.query_utils import refs_expression\nfrom django.db.models.sql.constants import INNER\nfrom django.db.models.sql.constants import LOUTER\nfrom django.db.models.sql.constants import ORDER_DIR\nfrom django.db.models.sql.constants import SINGLE\nfrom django.db.models.sql.datastructures import BaseTable\nfrom django.db.models.sql.datastructures import Empty\nfrom django.db.models.sql.datastructures import Join\nfrom django.db.models.sql.datastructures import MultiJoin\nfrom django.db.models.sql.where import AND\nfrom django.db.models.sql.where import OR\nfrom django.db.models.sql.where import ExtraWhere\nfrom django.db.models.sql.where import NothingNode\nfrom django.db.models.sql.where import WhereNode\nfrom django.utils.functional import cached_property\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.tree import Node\nfrom django.db.models.query import QuerySet\nfrom django.db.models.sql.subqueries import AggregateQuery\n\n\ndef get_field_names_from_opts(opts): [MASK]\n"}
{"method_name": "popen_wrapper", "full_method_name": "popen_wrapper", "method_path": "../srcdata/Network/django/django/core/management/utils.py", "method_code": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\ndef popen_wrapper(args, stdout_encoding='utf-8'):\n    \"\"\"\n    Friendly wrapper around Popen.\n\n    Return stdout output, stderr output, and OS status code.\n    \"\"\"\n    try:\n        p = run(args, capture_output=True, close_fds=os.name != 'nt')\n    except OSError as err:\n        raise CommandError('Error executing %s' % args[0]) from err\n    return p.stdout.decode(stdout_encoding), p.stderr.decode(\n        DEFAULT_LOCALE_ENCODING, errors='replace'), p.returncode", "test_code_list": [{"test_code": "import os\nfrom argparse import ArgumentDefaultsHelpFormatter\nfrom io import StringIO\nfrom unittest import mock\nfrom django.apps import apps\nfrom django.core import management\nfrom django.core.checks import Tags\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import find_commands\nfrom django.core.management.utils import find_command\nfrom django.core.management.utils import get_random_secret_key\nfrom django.core.management.utils import is_ignored_path\nfrom django.core.management.utils import normalize_path_patterns\nfrom django.core.management.utils import popen_wrapper\nfrom django.db import connection\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import extend_sys_path\nfrom django.utils import translation\n\nclass UtilsTests(SimpleTestCase):\n    def test_no_existent_external_program(self):\n        msg = 'Error executing a_42_command_that_doesnt_exist_42'\n        with self.assertRaisesMessage(CommandError, msg):\n            popen_wrapper(['a_42_command_that_doesnt_exist_42'])\n    \nUtilsTests().test_no_existent_external_program()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/user_commands/tests.py"}], "instruction": "Functionality: The popen_wrapper function is designed to provide a simplified interface for the subprocess.run() functionality in Python. It executes a given command (args) and captures the standard output (stdout), standard error (stderr), and the return code from the operating system. The function is robust against OSError exceptions, ensuring graceful error handling, and decodes the captured output streams for easier manipulation.\n\nInputs: \n1. args (list of strings): A list of strings that represents the command to be executed and its arguments. This is the primary input that defines what command the function will execute.\n2. stdout_encoding (string, optional): The encoding for decoding the standard output stream. It defaults to 'utf-8' if not provided.\n\nOutputs: \n1. stdout (string): The standard output stream of the executed command, decoded using the specified stdout_encoding.\n2. stderr (string): The standard error stream of the executed command, decoded using the system's default locale encoding with 'replace' mode for error handling.\n3. returncode (integer): The return code from the operating system, indicating the status of the command execution. A zero return code generally signifies success.", "method_code_mask": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\n\n\ndef popen_wrapper(args, stdout_encoding='utf-8'): [MASK]\n"}
{"method_name": "is_ignored_path", "full_method_name": "is_ignored_path", "method_path": "../srcdata/Network/django/django/core/management/utils.py", "method_code": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\ndef is_ignored_path(path, ignore_patterns):\n    \"\"\"\n    Check if the given path should be ignored or not based on matching\n    one of the glob style `ignore_patterns`.\n    \"\"\"\n    path = Path(path)\n\n    def ignore(pattern):\n        return fnmatch.fnmatchcase(path.name, pattern) or fnmatch.fnmatchcase(\n            str(path), pattern)\n    return any(ignore(pattern) for pattern in normalize_path_patterns(\n        ignore_patterns))", "test_code_list": [{"test_code": "import os\nfrom argparse import ArgumentDefaultsHelpFormatter\nfrom io import StringIO\nfrom unittest import mock\nfrom django.apps import apps\nfrom django.core import management\nfrom django.core.checks import Tags\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import find_commands\nfrom django.core.management.utils import find_command\nfrom django.core.management.utils import get_random_secret_key\nfrom django.core.management.utils import is_ignored_path\nfrom django.core.management.utils import normalize_path_patterns\nfrom django.core.management.utils import popen_wrapper\nfrom django.db import connection\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import extend_sys_path\nfrom django.utils import translation\n\nclass UtilsTests(SimpleTestCase):\n    def test_is_ignored_path_true(self):\n        patterns = ['foo/bar/baz'], ['baz'], ['foo/bar/baz'], ['*/baz'], ['*'], [\n            'b?z'], ['[abc]az'], ['*/ba[!z]/baz']\n        for ignore_patterns in patterns:\n            with self.subTest(ignore_patterns=ignore_patterns):\n                self.assertIs(is_ignored_path('foo/bar/baz', ignore_patterns=\n                    ignore_patterns), True)\n    \nUtilsTests().test_is_ignored_path_true()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/user_commands/tests.py"}, {"test_code": "import os\nfrom argparse import ArgumentDefaultsHelpFormatter\nfrom io import StringIO\nfrom unittest import mock\nfrom django.apps import apps\nfrom django.core import management\nfrom django.core.checks import Tags\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import find_commands\nfrom django.core.management.utils import find_command\nfrom django.core.management.utils import get_random_secret_key\nfrom django.core.management.utils import is_ignored_path\nfrom django.core.management.utils import normalize_path_patterns\nfrom django.core.management.utils import popen_wrapper\nfrom django.db import connection\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import extend_sys_path\nfrom django.utils import translation\n\nclass UtilsTests(SimpleTestCase):\n    def test_is_ignored_path_false(self):\n        self.assertIs(is_ignored_path('foo/bar/baz', ignore_patterns=[\n            'foo/bar/bat', 'bar', 'flub/blub']), False)\n    \nUtilsTests().test_is_ignored_path_false()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/user_commands/tests.py"}], "instruction": "Functionality: The is_ignored_path function determines whether a given file path should be ignored based on a set of ignore patterns. It uses glob-style pattern matching to compare the file path against each pattern in the ignore list. If the file path matches any of the patterns, the function returns True, indicating that the file should be ignored. Otherwise, it returns False.\n\nInputs: \n- path (str): The file path to be checked.\n- ignore_patterns (list): A list of glob-style patterns used to match against the file path.\n\nOutputs:\n- (bool): True if the file path matches any of the ignore patterns and should be ignored, False otherwise.", "method_code_mask": "import fnmatch\nimport os\nimport shutil\nimport subprocess\nfrom pathlib import Path\nfrom subprocess import run\nfrom django.apps import apps as installed_apps\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import DEFAULT_LOCALE_ENCODING\n\n\ndef is_ignored_path(path, ignore_patterns): [MASK]\n"}
{"method_name": "_unmask_cipher_token", "full_method_name": "_unmask_cipher_token", "method_path": "../srcdata/Network/django/django/middleware/csrf.py", "method_code": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\ndef _unmask_cipher_token(token):\n    \"\"\"\n    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length\n    CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt\n    the second half to produce the original secret.\n    \"\"\"\n    mask = token[:CSRF_SECRET_LENGTH]\n    token = token[CSRF_SECRET_LENGTH:]\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask)\n        )\n    return ''.join(chars[x - y] for x, y in pairs)", "test_code_list": [{"test_code": "import re\nfrom django.conf import settings\nfrom django.contrib.sessions.backends.cache import SessionStore\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import UnreadablePostError\nfrom django.middleware.csrf import CSRF_ALLOWED_CHARS\nfrom django.middleware.csrf import CSRF_SECRET_LENGTH\nfrom django.middleware.csrf import CSRF_SESSION_KEY\nfrom django.middleware.csrf import CSRF_TOKEN_LENGTH\nfrom django.middleware.csrf import REASON_BAD_ORIGIN\nfrom django.middleware.csrf import REASON_CSRF_TOKEN_MISSING\nfrom django.middleware.csrf import REASON_NO_CSRF_COOKIE\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import InvalidTokenFormat\nfrom django.middleware.csrf import RejectRequest\nfrom django.middleware.csrf import _check_token_format\nfrom django.middleware.csrf import _does_token_match\nfrom django.middleware.csrf import _mask_cipher_secret\nfrom django.middleware.csrf import _unmask_cipher_token\nfrom django.middleware.csrf import get_token\nfrom django.middleware.csrf import rotate_token\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import requires_csrf_token\nMASKED_TEST_SECRET2 = (\n    '2JgchWvM1tpxT2lfz9aydoXW9yT1DN3NdLiejYxOOlzzV4nhBbYqmqZYbAV3V5Bf')\nMASKED_TEST_SECRET1 = (\n    '1bcdefghij2bcdefghij3bcdefghij4bcdefghij5bcdefghij6bcdefghijABCD')\nTEST_SECRET = 'lcccccccX2kcccccccY2jcccccccssIC'\nclass CsrfFunctionTestMixin:\n    def assertMaskedSecretCorrect(self, masked_secret, secret):\n        \"\"\"Test that a string is a valid masked version of a secret.\"\"\"\n        self.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)\n        self.assertEqual(len(secret), CSRF_SECRET_LENGTH)\n        self.assertTrue(set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)\n            ), msg=f'invalid characters in {masked_secret!r}')\n        actual = _unmask_cipher_token(masked_secret)\n        self.assertEqual(actual, secret)\nclass CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):\n    def test_unmask_cipher_token(self):\n        cases = [(TEST_SECRET, MASKED_TEST_SECRET1), (TEST_SECRET,\n            MASKED_TEST_SECRET2), (32 * 'a',\n            'vFioG3XOLyGyGsPRFyB9iYUs341ufzIEvFioG3XOLyGyGsPRFyB9iYUs341ufzIE'),\n            (32 * 'a', 64 * 'a'), (32 * 'a', 64 * 'b'), (32 * 'b', 32 * 'a' +\n            32 * 'b'), (32 * 'b', 32 * 'b' + 32 * 'c'), (32 * 'c', 32 * 'a' +\n            32 * 'c')]\n        for secret, masked_secret in cases:\n            with self.subTest(masked_secret=masked_secret):\n                actual = _unmask_cipher_token(masked_secret)\n                self.assertEqual(actual, secret)\nCsrfFunctionTests().test_unmask_cipher_token()", "code_start": "", "test_path": "../srcdata/Network/django/tests/csrf_tests/tests.py"}, {"test_code": "import re\nfrom django.conf import settings\nfrom django.contrib.sessions.backends.cache import SessionStore\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import UnreadablePostError\nfrom django.middleware.csrf import CSRF_ALLOWED_CHARS\nfrom django.middleware.csrf import CSRF_SECRET_LENGTH\nfrom django.middleware.csrf import CSRF_SESSION_KEY\nfrom django.middleware.csrf import CSRF_TOKEN_LENGTH\nfrom django.middleware.csrf import REASON_BAD_ORIGIN\nfrom django.middleware.csrf import REASON_CSRF_TOKEN_MISSING\nfrom django.middleware.csrf import REASON_NO_CSRF_COOKIE\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import InvalidTokenFormat\nfrom django.middleware.csrf import RejectRequest\nfrom django.middleware.csrf import _check_token_format\nfrom django.middleware.csrf import _does_token_match\nfrom django.middleware.csrf import _mask_cipher_secret\nfrom django.middleware.csrf import _unmask_cipher_token\nfrom django.middleware.csrf import get_token\nfrom django.middleware.csrf import rotate_token\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import requires_csrf_token\nMASKED_TEST_SECRET2 = (\n    '2JgchWvM1tpxT2lfz9aydoXW9yT1DN3NdLiejYxOOlzzV4nhBbYqmqZYbAV3V5Bf')\nTEST_SECRET = 'lcccccccX2kcccccccY2jcccccccssIC'\nMASKED_TEST_SECRET1 = (\n    '1bcdefghij2bcdefghij3bcdefghij4bcdefghij5bcdefghij6bcdefghijABCD')\nclass CsrfFunctionTestMixin:\n    def assertMaskedSecretCorrect(self, masked_secret, secret):\n        \"\"\"Test that a string is a valid masked version of a secret.\"\"\"\n        self.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)\n        self.assertEqual(len(secret), CSRF_SECRET_LENGTH)\n        self.assertTrue(set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)\n            ), msg=f'invalid characters in {masked_secret!r}')\n        actual = _unmask_cipher_token(masked_secret)\n        self.assertEqual(actual, secret)\nclass CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):\n    def test_does_token_match(self):\n        cases = [((MASKED_TEST_SECRET1, TEST_SECRET), True), ((\n            MASKED_TEST_SECRET2, TEST_SECRET), True), ((64 * 'a',\n            _unmask_cipher_token(64 * 'a')), True), ((TEST_SECRET, TEST_SECRET),\n            True), ((32 * 'a', 32 * 'a'), True), ((32 * 'a', TEST_SECRET),\n            False), ((64 * 'a', TEST_SECRET), False)]\n        for (token, secret), expected in cases:\n            with self.subTest(token=token, secret=secret):\n                actual = _does_token_match(token, secret)\n                self.assertIs(actual, expected)\nCsrfFunctionTests().test_does_token_match()", "code_start": "", "test_path": "../srcdata/Network/django/tests/csrf_tests/tests.py"}], "instruction": "Functionality: The _unmask_cipher_token function is designed to decrypt a given token by using the first half of the token as a mask to decrypt the second half. It assumes that the input token is a string consisting of characters allowed by CSRF_ALLOWED_CHARS, has a length of CSRF_TOKEN_LENGTH, and that its first half is a mask. The function performs a character-by-character decryption by subtracting the index of each character in the mask from the index of the corresponding character in the second half of the token, and then maps the result back to a character in CSRF_ALLOWED_CHARS to produce the original secret.\n\nInputs: \n- token: A string that is to be decrypted. It is assumed to be a token of a specific length and format, with the first half serving as a mask for the decryption of the second half.\n\nOutputs:\n- A string representing the decrypted original secret. This output is derived from applying the decryption algorithm to the second half of the input token using the first half as a mask.", "method_code_mask": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef _unmask_cipher_token(token): [MASK]\n"}
{"method_name": "_mask_cipher_secret", "full_method_name": "_mask_cipher_secret", "method_path": "../srcdata/Network/django/django/middleware/csrf.py", "method_code": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\ndef _mask_cipher_secret(secret):\n    \"\"\"\n    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a\n    token by adding a mask and applying it to the secret.\n    \"\"\"\n    mask = _get_new_csrf_string()\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in\n        mask))\n    cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)\n    return mask + cipher", "test_code_list": [{"test_code": "import re\nfrom django.conf import settings\nfrom django.contrib.sessions.backends.cache import SessionStore\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import UnreadablePostError\nfrom django.middleware.csrf import CSRF_ALLOWED_CHARS\nfrom django.middleware.csrf import CSRF_SECRET_LENGTH\nfrom django.middleware.csrf import CSRF_SESSION_KEY\nfrom django.middleware.csrf import CSRF_TOKEN_LENGTH\nfrom django.middleware.csrf import REASON_BAD_ORIGIN\nfrom django.middleware.csrf import REASON_CSRF_TOKEN_MISSING\nfrom django.middleware.csrf import REASON_NO_CSRF_COOKIE\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import InvalidTokenFormat\nfrom django.middleware.csrf import RejectRequest\nfrom django.middleware.csrf import _check_token_format\nfrom django.middleware.csrf import _does_token_match\nfrom django.middleware.csrf import _mask_cipher_secret\nfrom django.middleware.csrf import _unmask_cipher_token\nfrom django.middleware.csrf import get_token\nfrom django.middleware.csrf import rotate_token\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import requires_csrf_token\nTEST_SECRET = 'lcccccccX2kcccccccY2jcccccccssIC'\nclass CsrfFunctionTestMixin:\n    def assertMaskedSecretCorrect(self, masked_secret, secret):\n        \"\"\"Test that a string is a valid masked version of a secret.\"\"\"\n        self.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)\n        self.assertEqual(len(secret), CSRF_SECRET_LENGTH)\n        self.assertTrue(set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)\n            ), msg=f'invalid characters in {masked_secret!r}')\n        actual = _unmask_cipher_token(masked_secret)\n        self.assertEqual(actual, secret)\nclass CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):\n    def test_mask_cipher_secret(self):\n        cases = [32 * 'a', TEST_SECRET, 'da4SrUiHJYoJ0HYQ0vcgisoIuFOxx4ER']\n        for secret in cases:\n            with self.subTest(secret=secret):\n                masked = _mask_cipher_secret(secret)\n                self.assertMaskedSecretCorrect(masked, secret)\nCsrfFunctionTests().test_mask_cipher_secret()", "code_start": "", "test_path": "../srcdata/Network/django/tests/csrf_tests/tests.py"}], "instruction": "Functionality: The function _mask_cipher_secret is designed to take a secret string as input and generate a token by applying a mask to the secret. The masking process involves adding a randomly generated mask to each character of the secret string based on their index positions within the CSRF_ALLOWED_CHARS string. The result is a cipher that combines the masked secret and the mask itself.\n\nInputs: \n- secret (str): A string of characters that are allowed by CSRF_ALLOWED_CHARS, which is used as the input secret to be masked.\n\nOutputs:\n- token (str): A string that represents the masked secret concatenated with the mask, where the masking is applied character by character from the input secret based on their respective index positions within the CSRF_ALLOWED_CHARS string.", "method_code_mask": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef _mask_cipher_secret(secret): [MASK]\n"}
{"method_name": "_check_token_format", "full_method_name": "_check_token_format", "method_path": "../srcdata/Network/django/django/middleware/csrf.py", "method_code": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\ndef _check_token_format(token):\n    \"\"\"\n    Raise an InvalidTokenFormat error if the token has an invalid length or\n    characters that aren't allowed. The token argument can be a CSRF cookie\n    secret or non-cookie CSRF token, and either masked or unmasked.\n    \"\"\"\n    if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):\n        raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)\n    if invalid_token_chars_re.search(token):\n        raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)", "test_code_list": [{"test_code": "import re\nfrom django.conf import settings\nfrom django.contrib.sessions.backends.cache import SessionStore\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import UnreadablePostError\nfrom django.middleware.csrf import CSRF_ALLOWED_CHARS\nfrom django.middleware.csrf import CSRF_SECRET_LENGTH\nfrom django.middleware.csrf import CSRF_SESSION_KEY\nfrom django.middleware.csrf import CSRF_TOKEN_LENGTH\nfrom django.middleware.csrf import REASON_BAD_ORIGIN\nfrom django.middleware.csrf import REASON_CSRF_TOKEN_MISSING\nfrom django.middleware.csrf import REASON_NO_CSRF_COOKIE\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import InvalidTokenFormat\nfrom django.middleware.csrf import RejectRequest\nfrom django.middleware.csrf import _check_token_format\nfrom django.middleware.csrf import _does_token_match\nfrom django.middleware.csrf import _mask_cipher_secret\nfrom django.middleware.csrf import _unmask_cipher_token\nfrom django.middleware.csrf import get_token\nfrom django.middleware.csrf import rotate_token\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import requires_csrf_token\nMASKED_TEST_SECRET1 = (\n    '1bcdefghij2bcdefghij3bcdefghij4bcdefghij5bcdefghij6bcdefghijABCD')\nTEST_SECRET = 'lcccccccX2kcccccccY2jcccccccssIC'\nclass CsrfFunctionTestMixin:\n    def assertMaskedSecretCorrect(self, masked_secret, secret):\n        \"\"\"Test that a string is a valid masked version of a secret.\"\"\"\n        self.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)\n        self.assertEqual(len(secret), CSRF_SECRET_LENGTH)\n        self.assertTrue(set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)\n            ), msg=f'invalid characters in {masked_secret!r}')\n        actual = _unmask_cipher_token(masked_secret)\n        self.assertEqual(actual, secret)\nclass CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):\n    def test_check_token_format_valid(self):\n        cases = [TEST_SECRET, MASKED_TEST_SECRET1, 64 * 'a']\n        for token in cases:\n            with self.subTest(token=token):\n                actual = _check_token_format(token)\n                self.assertIsNone(actual)\nCsrfFunctionTests().test_check_token_format_valid()", "code_start": "", "test_path": "../srcdata/Network/django/tests/csrf_tests/tests.py"}, {"test_code": "import re\nfrom django.conf import settings\nfrom django.contrib.sessions.backends.cache import SessionStore\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import UnreadablePostError\nfrom django.middleware.csrf import CSRF_ALLOWED_CHARS\nfrom django.middleware.csrf import CSRF_SECRET_LENGTH\nfrom django.middleware.csrf import CSRF_SESSION_KEY\nfrom django.middleware.csrf import CSRF_TOKEN_LENGTH\nfrom django.middleware.csrf import REASON_BAD_ORIGIN\nfrom django.middleware.csrf import REASON_CSRF_TOKEN_MISSING\nfrom django.middleware.csrf import REASON_NO_CSRF_COOKIE\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import InvalidTokenFormat\nfrom django.middleware.csrf import RejectRequest\nfrom django.middleware.csrf import _check_token_format\nfrom django.middleware.csrf import _does_token_match\nfrom django.middleware.csrf import _mask_cipher_secret\nfrom django.middleware.csrf import _unmask_cipher_token\nfrom django.middleware.csrf import get_token\nfrom django.middleware.csrf import rotate_token\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import requires_csrf_token\nclass CsrfFunctionTestMixin:\n\n    def assertMaskedSecretCorrect(self, masked_secret, secret):\n        \"\"\"Test that a string is a valid masked version of a secret.\"\"\"\n        self.assertEqual(len(masked_secret), CSRF_TOKEN_LENGTH)\n        self.assertEqual(len(secret), CSRF_SECRET_LENGTH)\n        self.assertTrue(set(masked_secret).issubset(set(CSRF_ALLOWED_CHARS)\n            ), msg=f'invalid characters in {masked_secret!r}')\n        actual = _unmask_cipher_token(masked_secret)\n        self.assertEqual(actual, secret)\n\nclass CsrfFunctionTests(CsrfFunctionTestMixin, SimpleTestCase):\n    def test_check_token_format_invalid(self):\n        cases = [(64 * '*', 'has invalid characters'), (16 * 'a',\n            'has incorrect length')]\n        for token, expected_message in cases:\n            with self.subTest(token=token):\n                with self.assertRaisesMessage(InvalidTokenFormat, expected_message\n                    ):\n                    _check_token_format(token)\n    \nCsrfFunctionTests().test_check_token_format_invalid()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/csrf_tests/tests.py"}], "instruction": "Functionality: The _check_token_format function is responsible for validating the format of a token used in CSRF protection mechanisms. It checks whether the token has a valid length and contains only allowed characters. The function is designed to handle both masked and unmasked CSRF tokens, as well as CSRF cookie secrets.\n\nInputs: \n- token (str): The token to be checked. It can be either a CSRF cookie secret or a non-cookie CSRF token.\n\nOutputs: \n- None: The function does not return any value. Instead, it raises an InvalidTokenFormat exception if the token's length is incorrect or if it contains disallowed characters.\n\nException(s):\n- InvalidTokenFormat(REASON_INCORRECT_LENGTH): Raised when the token's length does not match the predefined lengths for CSRF tokens or secrets.\n- InvalidTokenFormat(REASON_INVALID_CHARACTERS): Raised when the token contains characters that are not allowed.\n\nAdditional Information:\n- The function uses constants CSRF_TOKEN_LENGTH and CSRF_SECRET_LENGTH to determine the valid lengths for tokens and secrets, respectively.\n- The invalid_token_chars_re is a regular expression used to search for disallowed characters within the token.", "method_code_mask": "import logging\nimport string\nfrom collections import defaultdict\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import HttpHeaders\nfrom django.http import UnreadablePostError\nfrom django.urls import get_callable\nfrom django.utils.cache import patch_vary_headers\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.deprecation import MiddlewareMixin\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_same_domain\nfrom django.utils.log import log_response\nfrom django.utils.regex_helper import _lazy_re_compile\n\n\ndef _check_token_format(token): [MASK]\n"}
{"method_name": "csrf_exempt", "full_method_name": "csrf_exempt", "method_path": "../srcdata/Network/django/django/views/decorators/csrf.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import get_token\nfrom django.utils.decorators import decorator_from_middleware\ndef csrf_exempt(view_func):\n    \"\"\"Mark a view function as being exempt from the CSRF view protection.\"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            return await view_func(request, *args, **kwargs)\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            return view_func(request, *args, **kwargs)\n    _view_wrapper.csrf_exempt = True\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.conf import settings\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.csrf import requires_csrf_token\n\nclass CsrfExemptTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = csrf_exempt(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nCsrfExemptTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_csrf.py"}], "instruction": "Functionality: The csrf_exempt function is used to mark a view function as exempt from the CSRF (Cross-Site Request Forgery) view protection in Django. It allows specific views to bypass the CSRF middleware, which checks for a valid CSRF token in POST requests.\n\nInputs: \n- view_func: A function representing a Django view that is to be exempted from CSRF protection. This function takes a request object and any additional arguments and keyword arguments.\n\nOutputs:\n- The csrf_exempt function returns a wrapped version of the input view_func, which bypasses the CSRF protection when called. The wrapped function will have the attribute csrf_exempt set to True, indicating that CSRF checks should be skipped for this particular view.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.middleware.csrf import get_token\nfrom django.utils.decorators import decorator_from_middleware\n\n\ndef csrf_exempt(view_func): [MASK]\n"}
{"method_name": "sanitize_address", "full_method_name": "sanitize_address", "method_path": "../srcdata/Network/django/django/core/mail/message.py", "method_code": "import mimetypes\nfrom collections import namedtuple\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator\nfrom email import message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address\nfrom email.headerregistry import parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr\nfrom email.utils import formatdate\nfrom email.utils import getaddresses\nfrom email.utils import make_msgid\nfrom io import BytesIO\nfrom io import StringIO\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import punycode\nfrom django.core.mail import get_connection\ndef sanitize_address(addr, encoding):\n    \"\"\"\n    Format a pair of (name, address) or an email address string.\n    \"\"\"\n    address = None\n    if not isinstance(addr, tuple):\n        addr = force_str(addr)\n        try:\n            token, rest = parser.get_mailbox(addr)\n        except (HeaderParseError, ValueError, IndexError):\n            raise ValueError('Invalid address \"%s\"' % addr)\n        else:\n            if rest:\n                raise ValueError(\n                    'Invalid address; only %s could be parsed from \"%s\"' %\n                    (token, addr))\n            nm = token.display_name or ''\n            localpart = token.local_part\n            domain = token.domain or ''\n    else:\n        nm, address = addr\n        if '@' not in address:\n            raise ValueError(f'Invalid address \"{address}\"')\n        localpart, domain = address.rsplit('@', 1)\n    address_parts = nm + localpart + domain\n    if '\\n' in address_parts or '\\r' in address_parts:\n        raise ValueError(\n            'Invalid address; address parts cannot contain newlines.')\n    try:\n        nm.encode('ascii')\n        nm = Header(nm).encode()\n    except UnicodeEncodeError:\n        nm = Header(nm, encoding).encode()\n    try:\n        localpart.encode('ascii')\n    except UnicodeEncodeError:\n        localpart = Header(localpart, encoding).encode()\n    domain = punycode(domain)\n    parsed_address = Address(username=localpart, domain=domain)\n    return formataddr((nm, parsed_address.addr_spec))", "test_code_list": [{"test_code": "import mimetypes\nimport os\nimport shutil\nimport socket\nimport sys\nimport tempfile\nfrom email import charset\nfrom email import message_from_binary_file\nfrom email import message_from_bytes\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom email.utils import parseaddr\nfrom io import StringIO\nfrom pathlib import Path\nfrom smtplib import SMTP\nfrom smtplib import SMTPException\nfrom ssl import SSLError\nfrom unittest import mock\nfrom unittest import skipUnless\nfrom django.core import mail\nfrom django.core.mail import DNS_NAME\nfrom django.core.mail import EmailMessage\nfrom django.core.mail import EmailMultiAlternatives\nfrom django.core.mail import mail_admins\nfrom django.core.mail import mail_managers\nfrom django.core.mail import send_mail\nfrom django.core.mail import send_mass_mail\nfrom django.core.mail.backends import console\nfrom django.core.mail.backends import dummy\nfrom django.core.mail.backends import filebased\nfrom django.core.mail.backends import locmem\nfrom django.core.mail.backends import smtp\nfrom django.core.mail.message import BadHeaderError\nfrom django.core.mail.message import sanitize_address\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import requires_tz_support\nfrom django.utils.translation import gettext_lazy\nclass HeadersCheckMixin:\n\n    def assertMessageHasHeaders(self, message, headers):\n        \"\"\"\n        Asserts that the `message` has all `headers`.\n\n        message: can be an instance of an email.Message subclass or a string\n                 with the contents of an email message.\n        headers: should be a set of (header-name, header-value) tuples.\n        \"\"\"\n        if isinstance(message, bytes):\n            message = message_from_bytes(message)\n        msg_headers = set(message.items())\n        self.assertTrue(headers.issubset(msg_headers), msg=\n            'Message is missing the following headers: %s' % (headers -\n            msg_headers))\n\nclass MailTests(HeadersCheckMixin, SimpleTestCase):\n    def test_sanitize_address_header_injection(self):\n        msg = 'Invalid address; address parts cannot contain newlines.'\n        tests = ['Name\\nInjection <to@example.com>', ('Name\\nInjection',\n            'to@xample.com'), \"\"\"Name <to\n    injection@example.com>\"\"\", ('Name',\n            \"\"\"to\n    injection@example.com\"\"\")]\n        for email_address in tests:\n            with self.subTest(email_address=email_address):\n                with self.assertRaisesMessage(ValueError, msg):\n                    sanitize_address(email_address, encoding='utf-8')\n    \nMailTests().test_sanitize_address_header_injection()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/mail/tests.py"}], "instruction": "Functionality: The sanitize_address function is designed to format and validate an email address or a tuple containing a name and an email address. It ensures the address is in a standard format, free of newlines, and properly encoded. The function also punycodes the domain to handle internationalized domain names.\n\nInputs: \n- addr: A string representing an email address or a tuple where the first element is a name (string) and the second element is an email address (string).\n- encoding: A string specifying the encoding to be used for non-ASCII characters.\n\nOutputs:\n- A string representing the formatted email address. If a name is provided, it will be included in the format \"Name <email@example.com>\". The name and local part of the email address will be encoded according to the specified encoding, and the domain will be punycoded to handle international characters.", "method_code_mask": "import mimetypes\nfrom collections import namedtuple\nfrom email import charset as Charset\nfrom email import encoders as Encoders\nfrom email import generator\nfrom email import message_from_string\nfrom email.errors import HeaderParseError\nfrom email.header import Header\nfrom email.headerregistry import Address\nfrom email.headerregistry import parser\nfrom email.message import Message\nfrom email.mime.base import MIMEBase\nfrom email.mime.message import MIMEMessage\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom email.utils import formataddr\nfrom email.utils import formatdate\nfrom email.utils import getaddresses\nfrom email.utils import make_msgid\nfrom io import BytesIO\nfrom io import StringIO\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.mail.utils import DNS_NAME\nfrom django.utils.encoding import force_str\nfrom django.utils.encoding import punycode\nfrom django.core.mail import get_connection\n\n\ndef sanitize_address(addr, encoding): [MASK]\n"}
{"method_name": "make_style", "full_method_name": "make_style", "method_path": "../srcdata/Network/django/django/core/management/color.py", "method_code": "import functools\nimport os\nimport sys\nfrom django.utils import termcolors\nimport colorama\nclass Style:\n    pass\ndef make_style(config_string=''):\n    \"\"\"\n    Create a Style object from the given config_string.\n    If config_string is empty django.utils.termcolors.DEFAULT_PALETTE is used.\n    \"\"\"\n    style = Style()\n    color_settings = termcolors.parse_color_setting(config_string)\n    for role in termcolors.PALETTES[termcolors.NOCOLOR_PALETTE]:\n        if color_settings:\n            format = color_settings.get(role, {})\n            style_func = termcolors.make_style(**format)\n        else:\n            def style_func(x):\n                return x\n        setattr(style, role, style_func)\n    style.ERROR_OUTPUT = style.ERROR\n    return style", "test_code_list": [{"test_code": "import logging\nfrom contextlib import contextmanager\nfrom io import StringIO\nfrom unittest import mock\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import DisallowedHost\nfrom django.core.exceptions import PermissionDenied\nfrom django.core.exceptions import SuspiciousOperation\nfrom django.core.files.temp import NamedTemporaryFile\nfrom django.core.management import color\nfrom django.http.multipartparser import MultiPartParserError\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import LoggingCaptureMixin\nfrom django.utils.log import DEFAULT_LOGGING\nfrom django.utils.log import AdminEmailHandler\nfrom django.utils.log import CallbackFilter\nfrom django.utils.log import RequireDebugFalse\nfrom django.utils.log import RequireDebugTrue\nfrom django.utils.log import ServerFormatter\nfrom django.views.debug import ExceptionReporter\nfrom django import setup\n\nclass LogFormattersTests(SimpleTestCase):\n    def test_server_formatter_styles(self):\n        color_style = make_style('')\n        formatter = ServerFormatter()\n        formatter.style = color_style\n        log_msg = 'log message'\n        status_code_styles = [(200, 'HTTP_SUCCESS'), (100, 'HTTP_INFO'), (304,\n            'HTTP_NOT_MODIFIED'), (300, 'HTTP_REDIRECT'), (404,\n            'HTTP_NOT_FOUND'), (400, 'HTTP_BAD_REQUEST'), (500,\n            'HTTP_SERVER_ERROR')]\n        for status_code, style in status_code_styles:\n            record = logging.makeLogRecord({'msg': log_msg, 'status_code':\n                status_code})\n            self.assertEqual(formatter.format(record), getattr(color_style,\n                style)(log_msg))\n        record = logging.makeLogRecord({'msg': log_msg})\n        self.assertEqual(formatter.format(record), log_msg)\n    \nLogFormattersTests().test_server_formatter_styles()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/logging_tests/tests.py"}, {"test_code": "import os\nimport re\nimport shutil\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nimport unittest\nfrom io import StringIO\nfrom unittest import mock\nfrom django import conf\nfrom django import get_version\nfrom django.conf import settings\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import call_command\nfrom django.core.management import color\nfrom django.core.management import execute_from_command_line\nfrom django.core.management.commands.loaddata import Command as LoaddataCommand\nfrom django.core.management.commands.runserver import Command as RunserverCommand\nfrom django.core.management.commands.testserver import Command as TestserverCommand\nfrom django.db import ConnectionHandler\nfrom django.db import connection\nfrom django.db.migrations.recorder import MigrationRecorder\nfrom django.test import LiveServerTestCase\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import captured_stdout\nfrom django.urls import path\nfrom django.views.static import serve\nclass AdminScriptTestCase(SimpleTestCase):\n\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.addCleanup(tmpdir.cleanup)\n        self.test_dir = os.path.realpath(os.path.join(tmpdir.name,\n            'test_project'))\n        os.mkdir(self.test_dir)\n\n    def write_settings(self, filename, apps=None, is_dir=False, sdict=None,\n        extra=None):\n        if is_dir:\n            settings_dir = os.path.join(self.test_dir, filename)\n            os.mkdir(settings_dir)\n            settings_file_path = os.path.join(settings_dir, '__init__.py')\n        else:\n            settings_file_path = os.path.join(self.test_dir, filename)\n        with open(settings_file_path, 'w') as settings_file:\n            settings_file.write(\n                \"\"\"# Settings file automatically generated by admin_scripts test case\n\"\"\"\n                )\n            if extra:\n                settings_file.write('%s\\n' % extra)\n            exports = ['DATABASES', 'DEFAULT_AUTO_FIELD', 'ROOT_URLCONF',\n                'SECRET_KEY', 'USE_TZ']\n            for s in exports:\n                if hasattr(settings, s):\n                    o = getattr(settings, s)\n                    if not isinstance(o, (dict, tuple, list)):\n                        o = \"'%s'\" % o\n                    settings_file.write('%s = %s\\n' % (s, o))\n            if apps is None:\n                apps = ['django.contrib.auth',\n                    'django.contrib.contenttypes', 'admin_scripts']\n            settings_file.write('INSTALLED_APPS = %s\\n' % apps)\n            if sdict:\n                for k, v in sdict.items():\n                    settings_file.write('%s = %s\\n' % (k, v))\n\n    def _ext_backend_paths(self):\n        \"\"\"\n        Returns the paths for any external backend packages.\n        \"\"\"\n        paths = []\n        for backend in settings.DATABASES.values():\n            package = backend['ENGINE'].split('.')[0]\n            if package != 'django':\n                backend_pkg = __import__(package)\n                backend_dir = os.path.dirname(backend_pkg.__file__)\n                paths.append(os.path.dirname(backend_dir))\n        return paths\n\n    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n        base_dir = os.path.dirname(self.test_dir)\n        tests_dir = os.path.dirname(os.path.dirname(__file__))\n        django_dir = os.path.dirname(tests_dir)\n        ext_backend_base_dirs = self._ext_backend_paths()\n        test_environ = os.environ.copy()\n        if settings_file:\n            test_environ['DJANGO_SETTINGS_MODULE'] = settings_file\n        elif 'DJANGO_SETTINGS_MODULE' in test_environ:\n            del test_environ['DJANGO_SETTINGS_MODULE']\n        python_path = [base_dir, django_dir, tests_dir]\n        python_path.extend(ext_backend_base_dirs)\n        test_environ['PYTHONPATH'] = os.pathsep.join(python_path)\n        test_environ['PYTHONWARNINGS'] = ''\n        p = subprocess.run([sys.executable, *args], capture_output=True,\n            cwd=self.test_dir, env=test_environ, text=True, umask=umask)\n        return p.stdout, p.stderr\n\n    def run_django_admin(self, args, settings_file=None, umask=-1):\n        return self.run_test(['-m', 'django', *args], settings_file, umask=\n            umask)\n\n    def run_manage(self, args, settings_file=None, manage_py=None):\n        template_manage_py = os.path.join(os.path.dirname(__file__), manage_py\n            ) if manage_py else os.path.join(os.path.dirname(conf.__file__),\n            'project_template', 'manage.py-tpl')\n        test_manage_py = os.path.join(self.test_dir, 'manage.py')\n        shutil.copyfile(template_manage_py, test_manage_py)\n        with open(test_manage_py) as fp:\n            manage_py_contents = fp.read()\n        manage_py_contents = manage_py_contents.replace('{{ project_name }}',\n            'test_project')\n        with open(test_manage_py, 'w') as fp:\n            fp.write(manage_py_contents)\n        return self.run_test(['./manage.py', *args], settings_file)\n\n    def assertNoOutput(self, stream):\n        \"\"\"Utility assertion: assert that the given stream is empty\"\"\"\n        self.assertEqual(len(stream), 0, \n            \"Stream should be empty: actually contains '%s'\" % stream)\n\n    def assertOutput(self, stream, msg, regex=False):\n        \"\"\"Utility assertion: assert that the given message exists in the output\"\"\"\n        if regex:\n            self.assertIsNotNone(re.search(msg, stream), \n                \"'%s' does not match actual output text '%s'\" % (msg, stream))\n        else:\n            self.assertIn(msg, stream, \n                \"'%s' does not match actual output text '%s'\" % (msg, stream))\n\n    def assertNotInOutput(self, stream, msg):\n        \"\"\"Utility assertion: assert that the given message doesn't exist in the output\"\"\"\n        self.assertNotIn(msg, stream, \n            \"'%s' matches actual output text '%s'\" % (msg, stream))\n\nclass CommandTypes(AdminScriptTestCase):\n    def test_color_style(self):\n        style = color.no_style()\n        self.assertEqual(style.ERROR('Hello, world!'), 'Hello, world!')\n        style = make_style('nocolor')\n        self.assertEqual(style.ERROR('Hello, world!'), 'Hello, world!')\n        style = make_style('dark')\n        self.assertIn('Hello, world!', style.ERROR('Hello, world!'))\n        self.assertNotEqual(style.ERROR('Hello, world!'), 'Hello, world!')\n        style = make_style('')\n        self.assertIn('Hello, world!', style.ERROR('Hello, world!'))\n        self.assertNotEqual(style.ERROR('Hello, world!'), 'Hello, world!')\n    \nCommandTypes().test_color_style()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_scripts/tests.py"}], "instruction": "Functionality: The make_style function creates a Style object based on the provided configuration string. If no configuration string is provided, it uses Django's default palette. The function interprets the configuration string, assigns color settings to various roles, and creates style functions for these roles.\n\nInputs: \n- config_string (str): A string representing the configuration for the style settings. This string should be formatted according to Django's termcolors module conventions. If it is an empty string, Django's DEFAULT_PALETTE will be used.\n\nOutputs: \n- Style Object: A Style object with various style functions attached to it for different roles. Each role has a corresponding style function that can be used to format text output based on the configuration string. The ERROR_OUTPUT attribute is also defined, which is an alias for the ERROR style function.", "method_code_mask": "import functools\nimport os\nimport sys\nfrom django.utils import termcolors\nimport colorama\n\n\nclass Style:\n    pass\n\n\ndef make_style(config_string=''): [MASK]\n"}
{"method_name": "split_identifier", "full_method_name": "split_identifier", "method_path": "../srcdata/Network/django/django/db/backends/utils.py", "method_code": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\ndef split_identifier(identifier):\n    \"\"\"\n    Split an SQL identifier into a two element tuple of (namespace, name).\n\n    The identifier could be a table, column, or sequence name might be prefixed\n    by a namespace.\n    \"\"\"\n    try:\n        namespace, name = identifier.split('\".\"')\n    except ValueError:\n        namespace, name = '', identifier\n    return namespace.strip('\"'), name.strip('\"')", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom decimal import Rounded\nfrom django.db import NotSupportedError\nfrom django.db import connection\nfrom django.db.backends.utils import format_number\nfrom django.db.backends.utils import split_identifier\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import truncate_name\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipIfDBFeature\nfrom django.test import skipUnlessDBFeature\n\nclass TestUtils(SimpleTestCase):\n    def test_split_identifier(self):\n        self.assertEqual(split_identifier('some_table'), ('', 'some_table'))\n        self.assertEqual(split_identifier('\"some_table\"'), ('', 'some_table'))\n        self.assertEqual(split_identifier('namespace\".\"some_table'), (\n            'namespace', 'some_table'))\n        self.assertEqual(split_identifier('\"namespace\".\"some_table\"'), (\n            'namespace', 'some_table'))\n    \nTestUtils().test_split_identifier()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/test_utils.py"}], "instruction": "Functionality: The function \"split_identifier\" is designed to split an SQL identifier into a two-element tuple. The SQL identifier can be a table name, column name, or sequence name and might be prefixed by a namespace. The function will parse the identifier and return it as a tuple where the first element is the namespace (if present) and the second element is the name of the table, column, or sequence.\n\nInputs: \n- identifier: A string representing an SQL identifier. This could be a simple name or a fully qualified name with a namespace.\n\nOutputs: \n- A tuple of two strings. The first string is the namespace (which might be an empty string if no namespace is present) and the second string is the name of the table, column, or sequence. Both elements of the tuple will have leading and trailing double quotes removed.", "method_code_mask": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\n\n\ndef split_identifier(identifier): [MASK]\n"}
{"method_name": "format_number", "full_method_name": "format_number", "method_path": "../srcdata/Network/django/django/db/backends/utils.py", "method_code": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\ndef format_number(value, max_digits, decimal_places):\n    \"\"\"\n    Format a number into a string with the requisite number of digits and\n    decimal places.\n    \"\"\"\n    if value is None:\n        return None\n    context = decimal.getcontext().copy()\n    if max_digits is not None:\n        context.prec = max_digits\n    if decimal_places is not None:\n        value = value.quantize(decimal.Decimal(1).scaleb(-decimal_places),\n            context=context)\n    else:\n        context.traps[decimal.Rounded] = 1\n        value = context.create_decimal(value)\n    return '{:f}'.format(value)", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom decimal import Rounded\nfrom django.db import NotSupportedError\nfrom django.db import connection\nfrom django.db.backends.utils import format_number\nfrom django.db.backends.utils import split_identifier\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import truncate_name\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipIfDBFeature\nfrom django.test import skipUnlessDBFeature\n\nclass TestUtils(SimpleTestCase):\n    def test_format_number(self):\n    \n        def equal(value, max_d, places, result):\n            self.assertEqual(format_number(Decimal(value), max_d, places), result)\n        equal('0', 12, 3, '0.000')\n        equal('0', 12, 8, '0.00000000')\n        equal('1', 12, 9, '1.000000000')\n        equal('0.00000000', 12, 8, '0.00000000')\n        equal('0.000000004', 12, 8, '0.00000000')\n        equal('0.000000008', 12, 8, '0.00000001')\n        equal('0.000000000000000000999', 10, 8, '0.00000000')\n        equal('0.1234567890', 12, 10, '0.1234567890')\n        equal('0.1234567890', 12, 9, '0.123456789')\n        equal('0.1234567890', 12, 8, '0.12345679')\n        equal('0.1234567890', 12, 5, '0.12346')\n        equal('0.1234567890', 12, 3, '0.123')\n        equal('0.1234567890', 12, 1, '0.1')\n        equal('0.1234567890', 12, 0, '0')\n        equal('0.1234567890', None, 0, '0')\n        equal('1234567890.1234567890', None, 0, '1234567890')\n        equal('1234567890.1234567890', None, 2, '1234567890.12')\n        equal('0.1234', 5, None, '0.1234')\n        equal('123.12', 5, None, '123.12')\n        with self.assertRaises(Rounded):\n            equal('0.1234567890', 5, None, '0.12346')\n        with self.assertRaises(Rounded):\n            equal('1234567890.1234', 5, None, '1234600000')\n    \nTestUtils().test_format_number()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/test_utils.py"}], "instruction": "Functionality: The function 'format_number' is designed to format a numerical value into a string representation according to the specified maximum number of digits and decimal places. It handles cases where the input value is None and applies the necessary decimal context for precision control.\n\nInputs: \n- value: A numerical value, represented as a decimal.Decimal instance, which is to be formatted.\n- max_digits: An integer specifying the maximum number of digits allowed in the formatted number. If set to None, the precision is not limited.\n- decimal_places: An integer indicating the number of decimal places. If set to None, the function will not truncate or round the number.\n\nOutputs:\n- The function returns a string representation of the numerical value formatted according to the 'max_digits' and 'decimal_places' parameters. If the input 'value' is None, the function returns None.\n\nExample usage is not provided as part of the instruction, but interviewees should write test cases within their implementation to verify the correctness of their function.", "method_code_mask": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\n\n\ndef format_number(value, max_digits, decimal_places): [MASK]\n"}
{"method_name": "split_tzname_delta", "full_method_name": "split_tzname_delta", "method_path": "../srcdata/Network/django/django/db/backends/utils.py", "method_code": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\ndef split_tzname_delta(tzname):\n    \"\"\"\n    Split a time zone name into a 3-tuple of (name, sign, offset).\n    \"\"\"\n    for sign in ['+', '-']:\n        if sign in tzname:\n            name, offset = tzname.rsplit(sign, 1)\n            if offset and parse_time(offset):\n                if ':' not in offset:\n                    offset = f'{offset}:00'\n                return name, sign, offset\n    return tzname, None, None", "test_code_list": [{"test_code": "from decimal import Decimal\nfrom decimal import Rounded\nfrom django.db import NotSupportedError\nfrom django.db import connection\nfrom django.db.backends.utils import format_number\nfrom django.db.backends.utils import split_identifier\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import truncate_name\nfrom django.test import SimpleTestCase\nfrom django.test import TransactionTestCase\nfrom django.test import skipIfDBFeature\nfrom django.test import skipUnlessDBFeature\n\nclass TestUtils(SimpleTestCase):\n    def test_split_tzname_delta(self):\n        tests = [('Asia/Ust+Nera', ('Asia/Ust+Nera', None, None)), (\n            'Asia/Ust-Nera', ('Asia/Ust-Nera', None, None)), (\n            'Asia/Ust+Nera-02:00', ('Asia/Ust+Nera', '-', '02:00')), (\n            'Asia/Ust-Nera+05:00', ('Asia/Ust-Nera', '+', '05:00')), (\n            'America/Coral_Harbour-01:00', ('America/Coral_Harbour', '-',\n            '01:00')), ('America/Coral_Harbour+02:30', ('America/Coral_Harbour',\n            '+', '02:30')), ('UTC+15:00', ('UTC', '+', '15:00')), ('UTC-04:43',\n            ('UTC', '-', '04:43')), ('UTC', ('UTC', None, None)), ('UTC+1', (\n            'UTC+1', None, None))]\n        for tzname, expected in tests:\n            with self.subTest(tzname=tzname):\n                self.assertEqual(split_tzname_delta(tzname), expected)\n    \nTestUtils().test_split_tzname_delta()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/test_utils.py"}], "instruction": "Functionality: The function 'split_tzname_delta' is designed to take a time zone name as an input and decompose it into a 3-tuple structure containing the time zone name, time zone sign (indicating the direction from UTC), and the time zone offset from UTC.\n\nInputs: \n- tzname: str - This is a string representing a time zone, which might include an offset from UTC denoted by a '+' or '-' sign.\n\nOutputs:\n- tuple - A 3-tuple is returned containing:\n  - name: str - The name of the time zone without the offset part.\n  - sign: str or None - The sign ('+' or '-') indicating the direction of the offset from UTC. If no sign is found, it returns None.\n  - offset: str or None - The offset from UTC in the format of hours:minutes. If no offset is found, it returns None.", "method_code_mask": "import datetime\nimport decimal\nimport functools\nimport logging\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom hashlib import md5\nfrom django.apps import apps\nfrom django.db import NotSupportedError\nfrom django.utils.dateparse import parse_time\n\n\ndef split_tzname_delta(tzname): [MASK]\n"}
{"method_name": "_sqlite_date_trunc", "full_method_name": "_sqlite_date_trunc", "method_path": "../srcdata/Network/django/django/db/backends/sqlite3/_functions.py", "method_code": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\ndef _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):\n    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n    if dt is None:\n        return None\n    if lookup_type == 'year':\n        return f'{dt.year:04d}-01-01'\n    elif lookup_type == 'quarter':\n        month_in_quarter = dt.month - (dt.month - 1) % 3\n        return f'{dt.year:04d}-{month_in_quarter:02d}-01'\n    elif lookup_type == 'month':\n        return f'{dt.year:04d}-{dt.month:02d}-01'\n    elif lookup_type == 'week':\n        dt -= timedelta(days=dt.weekday())\n        return f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d}'\n    elif lookup_type == 'day':\n        return f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d}'\n    raise ValueError(f'Unsupported lookup type: {lookup_type!r}')", "test_code_list": [{"test_code": "from django.db.backends.sqlite3._functions import _sqlite_date_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_datetime_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_time_trunc\nfrom django.test import SimpleTestCase\n\nclass FunctionTests(SimpleTestCase):\n    def test_sqlite_date_trunc(self):\n        msg = \"Unsupported lookup type: 'unknown-lookup'\"\n        with self.assertRaisesMessage(ValueError, msg):\n            _sqlite_date_trunc('unknown-lookup', '2005-08-11', None, None)\n    \nFunctionTests().test_sqlite_date_trunc()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/sqlite/test_functions.py"}], "instruction": "Functionality: The _sqlite_date_trunc function is designed to truncate a given datetime object to the start of the specified date part. This function is particularly useful for database operations where date and time need to be handled in a standardized manner for queries and reporting.\n\nInputs: \n- lookup_type: A string that specifies the part of the date to truncate to. Supported values are 'year', 'quarter', 'month', 'week', and 'day'.\n- dt: A datetime object to be truncated.\n- tzname: A string representing the timezone name associated with the datetime object.\n- conn_tzname: A string representing the timezone name of the database connection.\n\nOutputs: \n- If the input datetime object is valid, the function returns a string formatted as 'YYYY-MM-DD' representing the truncated date. The format of the string depends on the lookup_type argument.\n- For 'year', the output string will be in the format 'YYYY-01-01'.\n- For 'quarter', the output string will be in the format 'YYYY-MM-01', where MM is the first month of the quarter.\n- For 'month', the output string will be in the format 'YYYY-MM-01'.\n- For 'week', the output string will be in the format 'YYYY-MM-DD', where the date is the first day of the week (Monday).\n- For 'day', the output string will be in the format 'YYYY-MM-DD'.\n- If the input datetime object is None or an invalid datetime, the function returns None.\n- If the lookup_type is unsupported, the function raises a ValueError with a message indicating the unsupported type.", "method_code_mask": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\n\n\ndef _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname): [MASK]\n"}
{"method_name": "_sqlite_datetime_trunc", "full_method_name": "_sqlite_datetime_trunc", "method_path": "../srcdata/Network/django/django/db/backends/sqlite3/_functions.py", "method_code": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\ndef _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):\n    dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n    if dt is None:\n        return None\n    if lookup_type == 'year':\n        return f'{dt.year:04d}-01-01 00:00:00'\n    elif lookup_type == 'quarter':\n        month_in_quarter = dt.month - (dt.month - 1) % 3\n        return f'{dt.year:04d}-{month_in_quarter:02d}-01 00:00:00'\n    elif lookup_type == 'month':\n        return f'{dt.year:04d}-{dt.month:02d}-01 00:00:00'\n    elif lookup_type == 'week':\n        dt -= timedelta(days=dt.weekday())\n        return f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d} 00:00:00'\n    elif lookup_type == 'day':\n        return f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d} 00:00:00'\n    elif lookup_type == 'hour':\n        return f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d} {dt.hour:02d}:00:00'\n    elif lookup_type == 'minute':\n        return (\n            f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d} {dt.hour:02d}:{dt.minute:02d}:00'\n            )\n    elif lookup_type == 'second':\n        return (\n            f'{dt.year:04d}-{dt.month:02d}-{dt.day:02d} {dt.hour:02d}:{dt.minute:02d}:{dt.second:02d}'\n            )\n    raise ValueError(f'Unsupported lookup type: {lookup_type!r}')", "test_code_list": [{"test_code": "from django.db.backends.sqlite3._functions import _sqlite_date_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_datetime_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_time_trunc\nfrom django.test import SimpleTestCase\n\nclass FunctionTests(SimpleTestCase):\n    def test_sqlite_datetime_trunc(self):\n        msg = \"Unsupported lookup type: 'unknown-lookup'\"\n        with self.assertRaisesMessage(ValueError, msg):\n            _sqlite_datetime_trunc('unknown-lookup', '2005-08-11 1:00:00', None,\n                None)\n    \nFunctionTests().test_sqlite_datetime_trunc()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/sqlite/test_functions.py"}], "instruction": "Functionality: The _sqlite_datetime_trunc function is designed to truncate a given datetime object to a specified level of precision. It supports truncation to the year, quarter, month, week, day, hour, minute, and second.\n\nInputs: \n1. lookup_type (str): A string indicating the level of precision to truncate the datetime to. Valid values are 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', and 'second'.\n2. dt (datetime): The datetime object to be truncated.\n3. tzname: The timezone name of the provided datetime object.\n4. conn_tzname: The timezone name of the connection context. This is used to adjust the datetime object to the correct timezone before truncation.\n\nOutputs:\n1. str: A string representation of the truncated datetime object. The format of the output string depends on the lookup_type. For example, if lookup_type is 'year', the output will be in the format 'YYYY-01-01 00:00:00'. If the provided lookup_type is not one of the valid values, the function will raise a ValueError with an error message.\n\nNote: If the input datetime object (dt) is None, the function will return None.", "method_code_mask": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\n\n\ndef _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname): [MASK]\n"}
{"method_name": "_sqlite_time_trunc", "full_method_name": "_sqlite_time_trunc", "method_path": "../srcdata/Network/django/django/db/backends/sqlite3/_functions.py", "method_code": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\ndef _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):\n    if dt is None:\n        return None\n    dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)\n    if dt_parsed is None:\n        try:\n            dt = typecast_time(dt)\n        except (ValueError, TypeError):\n            return None\n    else:\n        dt = dt_parsed\n    if lookup_type == 'hour':\n        return f'{dt.hour:02d}:00:00'\n    elif lookup_type == 'minute':\n        return f'{dt.hour:02d}:{dt.minute:02d}:00'\n    elif lookup_type == 'second':\n        return f'{dt.hour:02d}:{dt.minute:02d}:{dt.second:02d}'\n    raise ValueError(f'Unsupported lookup type: {lookup_type!r}')", "test_code_list": [{"test_code": "from django.db.backends.sqlite3._functions import _sqlite_date_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_datetime_trunc\nfrom django.db.backends.sqlite3._functions import _sqlite_time_trunc\nfrom django.test import SimpleTestCase\n\nclass FunctionTests(SimpleTestCase):\n    def test_sqlite_time_trunc(self):\n        msg = \"Unsupported lookup type: 'unknown-lookup'\"\n        with self.assertRaisesMessage(ValueError, msg):\n            _sqlite_time_trunc('unknown-lookup', '2005-08-11 1:00:00', None, None)\n    \nFunctionTests().test_sqlite_time_trunc()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/backends/sqlite/test_functions.py"}], "instruction": "Functionality: The _sqlite_time_trunc function is designed to truncate a given datetime object to a specific granularity level (hour, minute, or second) as specified by the lookup_type parameter. This is particularly useful for time aggregation or time-based filtering in database queries. The function supports handling of timezone-aware datetimes and can adjust the output according to the timezone information provided.\n\nInputs: \n- lookup_type: A string indicating the level of granularity to truncate the datetime to. Valid values are 'hour', 'minute', 'second'.\n- dt: A string representing a datetime value that needs to be truncated. This string should be in a format that can be parsed by the _sqlite_datetime_parse function or be recognized by the typecast_time function.\n- tzname: A string representing the timezone name associated with the datetime. This is useful when the datetime is timezone-aware and needs to be adjusted for the specified timezone.\n- conn_tzname: A string representing the timezone name of the connection's timezone. This is used for adjusting the datetime value to the connection's timezone before truncation.\n\nOutputs:\n- Returns a string representing the truncated datetime in the format 'HH:MM:SS' according to the lookup_type parameter. For example, if lookup_type is 'hour', the function returns a string in the format 'HH:00:00'.\n- Returns None if the input datetime string (dt) is None, if the parsing of the datetime fails, or if an unsupported lookup_type is provided.\n\nNote: The function uses several helper functions and modules, including _sqlite_datetime_parse, typecast_time, and timezone-related utilities from Django, to handle datetime parsing, timezone adjustments, and error handling. It is designed to work within a Django database backend context.", "method_code_mask": "import functools\nimport random\nimport statistics\nimport zoneinfo\nfrom datetime import timedelta\nfrom hashlib import md5\nfrom hashlib import sha1\nfrom hashlib import sha224\nfrom hashlib import sha256\nfrom hashlib import sha384\nfrom hashlib import sha512\nfrom math import acos\nfrom math import asin\nfrom math import atan\nfrom math import atan2\nfrom math import ceil\nfrom math import cos\nfrom math import degrees\nfrom math import exp\nfrom math import floor\nfrom math import fmod\nfrom math import log\nfrom math import pi\nfrom math import radians\nfrom math import sin\nfrom math import sqrt\nfrom math import tan\nfrom re import search as re_search\nfrom django.db.backends.utils import split_tzname_delta\nfrom django.db.backends.utils import typecast_time\nfrom django.db.backends.utils import typecast_timestamp\nfrom django.utils import timezone\nfrom django.utils.duration import duration_microseconds\n\n\ndef _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname): [MASK]\n"}
{"method_name": "display", "full_method_name": "display", "method_path": "../srcdata/Network/django/django/contrib/admin/decorators.py", "method_code": "from django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.admin.sites import site as default_site\ndef display(function=None, *, boolean=None, ordering=None, description=None,\n    empty_value=None):\n    \"\"\"\n    Conveniently add attributes to a display function::\n\n        @admin.display(\n            boolean=True,\n            ordering='-publish_date',\n            description='Is Published?',\n        )\n        def is_published(self, obj):\n            return obj.publish_date is not None\n\n    This is equivalent to setting some attributes (with the original, longer\n    names) on the function directly::\n\n        def is_published(self, obj):\n            return obj.publish_date is not None\n        is_published.boolean = True\n        is_published.admin_order_field = '-publish_date'\n        is_published.short_description = 'Is Published?'\n    \"\"\"\n\n    def decorator(func):\n        if boolean is not None and empty_value is not None:\n            raise ValueError(\n                'The boolean and empty_value arguments to the @display decorator are mutually exclusive.'\n                )\n        if boolean is not None:\n            func.boolean = boolean\n        if ordering is not None:\n            func.admin_order_field = ordering\n        if description is not None:\n            func.short_description = description\n        if empty_value is not None:\n            func.empty_value_display = empty_value\n        return func\n    if function is None:\n        return decorator\n    else:\n        return decorator(function)", "test_code_list": [{"test_code": "import datetime\nimport os\nimport re\nimport unittest\nimport zoneinfo\nfrom unittest import mock\nfrom urllib.parse import parse_qsl\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlsplit\nfrom django import forms\nfrom django.contrib import admin\nfrom django.contrib.admin import AdminSite\nfrom django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.helpers import ACTION_CHECKBOX_NAME\nfrom django.contrib.admin.options import TO_FIELD_VAR\nfrom django.contrib.admin.templatetags.admin_urls import add_preserved_filters\nfrom django.contrib.admin.tests import AdminSeleniumTestCase\nfrom django.contrib.admin.utils import quote\nfrom django.contrib.admin.views.main import IS_POPUP_VAR\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.contrib.auth import get_permission_codename\nfrom django.core import mail\nfrom django.core.checks import Error\nfrom django.core.files import temp as tempfile\nfrom django.db import connection\nfrom django.forms.utils import ErrorList\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import TestCase\nfrom django.test import ignore_warnings\nfrom django.test import modify_settings\nfrom django.test import override_settings\nfrom django.test import skipUnlessDBFeature\nfrom django.test.utils import override_script_prefix\nfrom django.urls import NoReverseMatch\nfrom django.urls import resolve\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import translation\nfrom django.utils.cache import get_max_age\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import escape\nfrom django.utils.http import urlencode\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver import ActionChains\nfrom selenium.webdriver.support.ui import Select\n@override_settings(ROOT_URLCONF='admin_views.urls', USE_I18N=True,\n    LANGUAGE_CODE='en')\nclass AdminViewBasicTestCase(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.superuser = User.objects.create_superuser(username='super',\n            password='secret', email='super@example.com')\n        cls.s1 = Section.objects.create(name='Test section')\n        cls.a1 = Article.objects.create(content='<p>Middle content</p>',\n            date=datetime.datetime(2008, 3, 18, 11, 54, 58), section=cls.s1,\n            title='Article 1')\n        cls.a2 = Article.objects.create(content='<p>Oldest content</p>',\n            date=datetime.datetime(2000, 3, 18, 11, 54, 58), section=cls.s1,\n            title='Article 2')\n        cls.a3 = Article.objects.create(content='<p>Newest content</p>',\n            date=datetime.datetime(2009, 3, 18, 11, 54, 58), section=cls.s1)\n        cls.p1 = PrePopulatedPost.objects.create(title='A Long Title',\n            published=True, slug='a-long-title')\n        cls.color1 = Color.objects.create(value='Red', warm=True)\n        cls.color2 = Color.objects.create(value='Orange', warm=True)\n        cls.color3 = Color.objects.create(value='Blue', warm=False)\n        cls.color4 = Color.objects.create(value='Green', warm=False)\n        cls.fab1 = Fabric.objects.create(surface='x')\n        cls.fab2 = Fabric.objects.create(surface='y')\n        cls.fab3 = Fabric.objects.create(surface='plain')\n        cls.b1 = Book.objects.create(name='Book 1')\n        cls.b2 = Book.objects.create(name='Book 2')\n        cls.pro1 = Promo.objects.create(name='Promo 1', book=cls.b1)\n        cls.pro1 = Promo.objects.create(name='Promo 2', book=cls.b2)\n        cls.chap1 = Chapter.objects.create(title='Chapter 1', content=\n            '[ insert contents here ]', book=cls.b1)\n        cls.chap2 = Chapter.objects.create(title='Chapter 2', content=\n            '[ insert contents here ]', book=cls.b1)\n        cls.chap3 = Chapter.objects.create(title='Chapter 1', content=\n            '[ insert contents here ]', book=cls.b2)\n        cls.chap4 = Chapter.objects.create(title='Chapter 2', content=\n            '[ insert contents here ]', book=cls.b2)\n        cls.cx1 = ChapterXtra1.objects.create(chap=cls.chap1, xtra=\n            'ChapterXtra1 1')\n        cls.cx2 = ChapterXtra1.objects.create(chap=cls.chap3, xtra=\n            'ChapterXtra1 2')\n        Actor.objects.create(name='Palin', age=27)\n        cls.inline_post_data = {'name': 'Test section',\n            'article_set-TOTAL_FORMS': '6', 'article_set-INITIAL_FORMS':\n            '3', 'article_set-MAX_NUM_FORMS': '0', 'article_set-0-id': cls.\n            a1.pk, 'article_set-0-title':\n            'Norske bostaver \u00e6\u00f8\u00e5 skaper problemer', 'article_set-0-content':\n            '&lt;p&gt;Middle content&lt;/p&gt;', 'article_set-0-date_0':\n            '2008-03-18', 'article_set-0-date_1': '11:54:58',\n            'article_set-0-section': cls.s1.pk, 'article_set-1-id': cls.a2.\n            pk, 'article_set-1-title': 'Need a title.',\n            'article_set-1-content': '&lt;p&gt;Oldest content&lt;/p&gt;',\n            'article_set-1-date_0': '2000-03-18', 'article_set-1-date_1':\n            '11:54:58', 'article_set-2-id': cls.a3.pk,\n            'article_set-2-title': 'Need a title.', 'article_set-2-content':\n            '&lt;p&gt;Newest content&lt;/p&gt;', 'article_set-2-date_0':\n            '2009-03-18', 'article_set-2-date_1': '11:54:58',\n            'article_set-3-id': '', 'article_set-3-title': '',\n            'article_set-3-content': '', 'article_set-3-date_0': '',\n            'article_set-3-date_1': '', 'article_set-4-id': '',\n            'article_set-4-title': '', 'article_set-4-content': '',\n            'article_set-4-date_0': '', 'article_set-4-date_1': '',\n            'article_set-5-id': '', 'article_set-5-title': '',\n            'article_set-5-content': '', 'article_set-5-date_0': '',\n            'article_set-5-date_1': ''}\n\n    def setUp(self):\n        self.client.force_login(self.superuser)\n\n    def assertContentBefore(self, response, text1, text2, failing_msg=None):\n        \"\"\"\n        Testing utility asserting that text1 appears before text2 in response\n        content.\n        \"\"\"\n        self.assertEqual(response.status_code, 200)\n        self.assertLess(response.content.index(text1.encode()), response.\n            content.index(text2.encode()), (failing_msg or '') +\n            '\\nResponse:\\n' + response.content.decode(response.charset))\n\nclass AdminViewBasicTest(AdminViewBasicTestCase):\n    def test_display_decorator_with_boolean_and_empty_value(self):\n        msg = (\n            'The boolean and empty_value arguments to the @display decorator are mutually exclusive.'\n            )\n        with self.assertRaisesMessage(ValueError, msg):\n    \n    \n            class BookAdmin(admin.ModelAdmin):\n    \n                @display(boolean=True, empty_value='(Missing)')\n                def is_published(self, obj):\n                    return obj.publish_date is not None\n    \nAdminViewBasicTest().test_display_decorator_with_boolean_and_empty_value()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_views/tests.py"}], "instruction": "Functionality: This is a decorator function used to modify the behavior of a display function in Django's admin interface. It is specifically designed to enhance the display of model fields or custom logic in the list display of the Django admin. The decorator can set attributes such as boolean display, ordering, description, and empty value display for the decorated function.\n\nInputs:\n- function (optional): The function to be decorated. If not provided, the decorator assumes it will be passed later.\n- boolean (optional): A Boolean value indicating if the column should be displayed as a boolean (checkmark or x icon).\n- ordering (optional): A string indicating the field name to use for ordering, prefixed with '-' for descending order.\n- description (optional): A string describing the column, used for the column header in the admin interface.\n- empty_value (optional): A string to display when the value of the column is empty or None.\n\nOutputs:\n- The decorated function with the specified attributes set. The decorator modifies the function in place, setting the 'boolean', 'admin_order_field', 'short_description', and 'empty_value_display' attributes as provided in the input.\n\nNote: The boolean and empty_value arguments cannot be used simultaneously; using both will raise a ValueError.\n\nExample usage:\nUse the @display decorator on a function to describe how it should be displayed in the Django admin interface. For instance, to display a function as a boolean column with a specific ordering and a custom empty value:\n@display(boolean=True, ordering='-publish_date', empty_value='Not Published')\ndef is_published(self, obj):\n    return obj.publish_date is not None", "method_code_mask": "from django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.admin.sites import site as default_site\n\n\ndef display(function=None, *, boolean=None, ordering=None, description=None,\n    empty_value=None): [MASK]\n"}
{"method_name": "flatten", "full_method_name": "flatten", "method_path": "../srcdata/Network/django/django/contrib/admin/utils.py", "method_code": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\ndef flatten(fields):\n    \"\"\"\n    Return a list which is a single level of flattening of the original list.\n    \"\"\"\n    flat = []\n    for field in fields:\n        if isinstance(field, (list, tuple)):\n            flat.extend(field)\n        else:\n            flat.append(field)\n    return flat", "test_code_list": [{"test_code": "from datetime import datetime\nfrom decimal import Decimal\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin import helpers\nfrom django.contrib.admin.utils import NestedObjects\nfrom django.contrib.admin.utils import display_for_field\nfrom django.contrib.admin.utils import display_for_value\nfrom django.contrib.admin.utils import flatten\nfrom django.contrib.admin.utils import flatten_fieldsets\nfrom django.contrib.admin.utils import help_text_for_field\nfrom django.contrib.admin.utils import label_for_field\nfrom django.contrib.admin.utils import lookup_field\nfrom django.contrib.admin.utils import quote\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils.formats import localize\nfrom django.utils.safestring import mark_safe\n\nclass UtilsTests(SimpleTestCase):\n    def test_flatten(self):\n        flat_all = ['url', 'title', 'content', 'sites']\n        inputs = ((), []), (('url', 'title', ('content', 'sites')), flat_all), ((\n            'url', 'title', 'content', 'sites'), flat_all), ((('url', 'title'),\n            ('content', 'sites')), flat_all)\n        for orig, expected in inputs:\n            self.assertEqual(flatten(orig), expected)\n    \nUtilsTests().test_flatten()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_utils/tests.py"}], "instruction": "Functionality: The function 'flatten' takes a list that may contain nested lists or tuples at any level of depth. It flattens the list by one level, meaning that any lists or tuples within the original list will be reduced by one level of nesting, with their elements being added directly to the parent list. The function does not flatten recursively; it only reduces the depth by one level.\n\nInputs: \n- fields: A list potentially containing nested lists or tuples at any level of depth. Elements within the list could be of any data type, including but not limited to integers, strings, and other lists or tuples.\n\nOutputs:\n- A list which is a single level of flattening of the original list 'fields'. This means that any lists or tuples within the 'fields' list will be unpacked by one level, and their elements will be added to the output list. Elements that are not lists or tuples in the original 'fields' list will remain unchanged in the output list.", "method_code_mask": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\n\n\ndef flatten(fields): [MASK]\n"}
{"method_name": "flatten_fieldsets", "full_method_name": "flatten_fieldsets", "method_path": "../srcdata/Network/django/django/contrib/admin/utils.py", "method_code": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\ndef flatten_fieldsets(fieldsets):\n    \"\"\"Return a list of field names from an admin fieldsets structure.\"\"\"\n    field_names = []\n    for name, opts in fieldsets:\n        field_names.extend(flatten(opts['fields']))\n    return field_names", "test_code_list": [{"test_code": "from datetime import datetime\nfrom decimal import Decimal\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin import helpers\nfrom django.contrib.admin.utils import NestedObjects\nfrom django.contrib.admin.utils import display_for_field\nfrom django.contrib.admin.utils import display_for_value\nfrom django.contrib.admin.utils import flatten\nfrom django.contrib.admin.utils import flatten_fieldsets\nfrom django.contrib.admin.utils import help_text_for_field\nfrom django.contrib.admin.utils import label_for_field\nfrom django.contrib.admin.utils import lookup_field\nfrom django.contrib.admin.utils import quote\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils.formats import localize\nfrom django.utils.safestring import mark_safe\n\nclass UtilsTests(SimpleTestCase):\n    def test_flatten_fieldsets(self):\n        \"\"\"\n            Regression test for #18051\n            \"\"\"\n        fieldsets = (None, {'fields': ('url', 'title', ('content', 'sites'))}),\n        self.assertEqual(flatten_fieldsets(fieldsets), ['url', 'title',\n            'content', 'sites'])\n        fieldsets = (None, {'fields': ('url', 'title', ['content', 'sites'])}),\n        self.assertEqual(flatten_fieldsets(fieldsets), ['url', 'title',\n            'content', 'sites'])\n    \nUtilsTests().test_flatten_fieldsets()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_utils/tests.py"}], "instruction": "Functionality: The flatten_fieldsets function is designed to process an admin fieldsets structure, which is typically a list of tuples. Each tuple represents a fieldset and consists of a name (which can be ignored for the purpose of this function) and a dictionary containing field options. The function's primary task is to traverse this structure and return a flattened list of all field names that are contained within the fieldsets.\n\nInputs: \n- fieldsets: This is the input parameter to the function. It is a list of tuples, where each tuple consists of two elements: a name (string) and a dictionary of options. The options dictionary contains a key 'fields', which is a list of field names (strings).\n\nOutputs:\n- The function returns a list of strings. Each string in this list represents the name of a field that was contained within the input fieldsets structure. The list is flattened, which means that any nested field names are also included as individual elements in the output list.", "method_code_mask": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\n\n\ndef flatten_fieldsets(fieldsets): [MASK]\n"}
{"method_name": "build_q_object_from_lookup_parameters", "full_method_name": "build_q_object_from_lookup_parameters", "method_path": "../srcdata/Network/django/django/contrib/admin/utils.py", "method_code": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\ndef build_q_object_from_lookup_parameters(parameters):\n    q_object = models.Q()\n    for param, param_item_list in parameters.items():\n        q_object &= reduce(or_, (models.Q((param, item)) for item in\n            param_item_list))\n    return q_object", "test_code_list": [{"test_code": "from datetime import datetime\nfrom decimal import Decimal\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin import helpers\nfrom django.contrib.admin.utils import NestedObjects\nfrom django.contrib.admin.utils import display_for_field\nfrom django.contrib.admin.utils import display_for_value\nfrom django.contrib.admin.utils import flatten\nfrom django.contrib.admin.utils import flatten_fieldsets\nfrom django.contrib.admin.utils import help_text_for_field\nfrom django.contrib.admin.utils import label_for_field\nfrom django.contrib.admin.utils import lookup_field\nfrom django.contrib.admin.utils import quote\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils.formats import localize\nfrom django.utils.safestring import mark_safe\n\nclass UtilsTests(SimpleTestCase):\n    def test_build_q_object_from_lookup_parameters(self):\n        parameters = {'title__in': [['Article 1', 'Article 2']], 'hist__iexact':\n            ['history'], 'site__pk': [1, 2]}\n        q_obj = build_q_object_from_lookup_parameters(parameters)\n        self.assertEqual(q_obj, models.Q(title__in=['Article 1', 'Article 2']) &\n            models.Q(hist__iexact='history') & (models.Q(site__pk=1) | models.Q\n            (site__pk=2)))\n    \nUtilsTests().test_build_q_object_from_lookup_parameters()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_utils/tests.py"}], "instruction": "Functionality: \nThe function build_q_object_from_lookup_parameters constructs a Django Q object from a given dictionary of parameters and their corresponding lists of items. This Q object is used to create complex database queries that can perform logical OR operations between items of the same parameter, and logical AND operations between different parameters. This function is particularly useful for creating advanced search queries that are based on multiple parameters and items.\n\nInputs:\nparameters: A dictionary where keys are lookup parameters (such as model fields) and values are lists of items that the keys should match. For example, {'field1': ['item1', 'item2'], 'field2': ['item3']} would create a Q object that matches either 'item1' or 'item2' in 'field1' and matches 'item3' in 'field2'.\n\nOutputs:\nA Django Q object that encapsulates the combined query based on the input parameters. This Q object can then be used in a filter or other query to retrieve matching records from the database.", "method_code_mask": "import datetime\nimport decimal\nimport json\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import or_\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.validators import EMPTY_VALUES\nfrom django.db import models\nfrom django.db import router\nfrom django.db.models.constants import LOOKUP_SEP\nfrom django.db.models.deletion import Collector\nfrom django.forms.utils import pretty_name\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils import formats\nfrom django.utils import timezone\nfrom django.utils.hashable import make_hashable\nfrom django.utils.html import format_html\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.text import capfirst\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import override as translation_override\nfrom django.contrib.admin.templatetags.admin_list import _boolean_icon\n\n\ndef build_q_object_from_lookup_parameters(parameters): [MASK]\n"}
{"method_name": "flatatt", "full_method_name": "flatatt", "method_path": "../srcdata/Network/django/django/forms/utils.py", "method_code": "import json\nfrom collections import UserList\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.forms.renderers import get_default_renderer\nfrom django.utils import timezone\nfrom django.utils.html import escape\nfrom django.utils.html import format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\ndef flatatt(attrs):\n    \"\"\"\n    Convert a dictionary of attributes to a single string.\n    The returned string will contain a leading space followed by key=\"value\",\n    XML-style pairs. In the case of a boolean value, the key will appear\n    without a value. It is assumed that the keys do not need to be\n    XML-escaped. If the passed dictionary is empty, then return an empty\n    string.\n\n    The result is passed through 'mark_safe' (by way of 'format_html_join').\n    \"\"\"\n    key_value_attrs = []\n    boolean_attrs = []\n    for attr, value in attrs.items():\n        if isinstance(value, bool):\n            if value:\n                boolean_attrs.append((attr,))\n        elif value is not None:\n            key_value_attrs.append((attr, value))\n    return format_html_join('', ' {}=\"{}\"', sorted(key_value_attrs)\n        ) + format_html_join('', ' {}', sorted(boolean_attrs))", "test_code_list": [{"test_code": "import copy\nimport json\nfrom django.core.exceptions import ValidationError\nfrom django.forms.utils import ErrorDict\nfrom django.forms.utils import ErrorList\nfrom django.forms.utils import RenderableMixin\nfrom django.forms.utils import flatatt\nfrom django.forms.utils import pretty_name\nfrom django.test import SimpleTestCase\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass FormsUtilsTestCase(SimpleTestCase):\n    def test_flatatt(self):\n        self.assertEqual(flatatt({'id': 'header'}), ' id=\"header\"')\n        self.assertEqual(flatatt({'class': 'news', 'title': 'Read this'}),\n            ' class=\"news\" title=\"Read this\"')\n        self.assertEqual(flatatt({'class': 'news', 'title': 'Read this',\n            'required': 'required'}),\n            ' class=\"news\" required=\"required\" title=\"Read this\"')\n        self.assertEqual(flatatt({'class': 'news', 'title': 'Read this',\n            'required': True}), ' class=\"news\" title=\"Read this\" required')\n        self.assertEqual(flatatt({'class': 'news', 'title': 'Read this',\n            'required': False}), ' class=\"news\" title=\"Read this\"')\n        self.assertEqual(flatatt({'class': None}), '')\n        self.assertEqual(flatatt({}), '')\n    \nFormsUtilsTestCase().test_flatatt()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/forms_tests/tests/test_utils.py"}, {"test_code": "import copy\nimport json\nfrom django.core.exceptions import ValidationError\nfrom django.forms.utils import ErrorDict\nfrom django.forms.utils import ErrorList\nfrom django.forms.utils import RenderableMixin\nfrom django.forms.utils import flatatt\nfrom django.forms.utils import pretty_name\nfrom django.test import SimpleTestCase\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass FormsUtilsTestCase(SimpleTestCase):\n    def test_flatatt_no_side_effects(self):\n        \"\"\"\n            flatatt() does not modify the dict passed in.\n            \"\"\"\n        attrs = {'foo': 'bar', 'true': True, 'false': False}\n        attrs_copy = copy.copy(attrs)\n        self.assertEqual(attrs, attrs_copy)\n        first_run = flatatt(attrs)\n        self.assertEqual(attrs, attrs_copy)\n        self.assertEqual(first_run, ' foo=\"bar\" true')\n        second_run = flatatt(attrs)\n        self.assertEqual(attrs, attrs_copy)\n        self.assertEqual(first_run, second_run)\n    \nFormsUtilsTestCase().test_flatatt_no_side_effects()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/forms_tests/tests/test_utils.py"}], "instruction": "Functionality: The function 'flatatt' is designed to convert a dictionary of attributes into a single, formatted string. This string will consist of key=\"value\" pairs in an XML-like format. For boolean values, only the key will be presented without a value. If the input dictionary is empty, the function should return an empty string. The output string is marked as safe for HTML usage.\n\nInputs: \n- attrs: A dictionary where keys are attribute names and values are their corresponding values. Values can be of any type but the function specifically handles boolean values differently.\n\nOutputs: \n- A string formatted with XML-style key-value pairs. Boolean attributes will be listed without values. If the input dictionary is empty, an empty string is returned. The output string is marked as safe for HTML usage.", "method_code_mask": "import json\nfrom collections import UserList\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.forms.renderers import get_default_renderer\nfrom django.utils import timezone\nfrom django.utils.html import escape\nfrom django.utils.html import format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\n\n\ndef flatatt(attrs): [MASK]\n"}
{"method_name": "pretty_name", "full_method_name": "pretty_name", "method_path": "../srcdata/Network/django/django/forms/utils.py", "method_code": "import json\nfrom collections import UserList\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.forms.renderers import get_default_renderer\nfrom django.utils import timezone\nfrom django.utils.html import escape\nfrom django.utils.html import format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\ndef pretty_name(name):\n    \"\"\"Convert 'first_name' to 'First name'.\"\"\"\n    if not name:\n        return ''\n    return name.replace('_', ' ').capitalize()", "test_code_list": [{"test_code": "import copy\nimport json\nfrom django.core.exceptions import ValidationError\nfrom django.forms.utils import ErrorDict\nfrom django.forms.utils import ErrorList\nfrom django.forms.utils import RenderableMixin\nfrom django.forms.utils import flatatt\nfrom django.forms.utils import pretty_name\nfrom django.test import SimpleTestCase\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy\n\nclass FormsUtilsTestCase(SimpleTestCase):\n    def test_pretty_name(self):\n        self.assertEqual(pretty_name('john_doe'), 'John doe')\n        self.assertEqual(pretty_name(None), '')\n        self.assertEqual(pretty_name(''), '')\n    \nFormsUtilsTestCase().test_pretty_name()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/forms_tests/tests/test_utils.py"}], "instruction": "Functionality: The function 'pretty_name' is designed to convert a given string from snake_case format to a human-readable format. Specifically, it replaces underscores (_) with spaces and capitalizes the first letter of the resulting string.\n\nInputs: \n- name (str): A string in snake_case format that needs to be converted to a human-readable format.\n\nOutputs:\n- str: The input string is transformed by replacing underscores with spaces and capitalizing the first letter of the resulting string. If the input string is empty, the function returns an empty string.", "method_code_mask": "import json\nfrom collections import UserList\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.forms.renderers import get_default_renderer\nfrom django.utils import timezone\nfrom django.utils.html import escape\nfrom django.utils.html import format_html_join\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\n\n\ndef pretty_name(name): [MASK]\n"}
{"method_name": "merge", "full_method_name": "Media.merge", "method_path": "../srcdata/Network/django/django/forms/widgets.py", "method_code": "import copy\nimport datetime\nimport warnings\nfrom collections import defaultdict\nfrom graphlib import CycleError\nfrom graphlib import TopologicalSorter\nfrom itertools import chain\nfrom django.forms.utils import to_current_timezone\nfrom django.templatetags.static import static\nfrom django.utils import formats\nfrom django.utils.dates import MONTHS\nfrom django.utils.formats import get_format\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\n@html_safe\nclass Media:\n\n    def __init__(self, media=None, css=None, js=None):\n        if media is not None:\n            css = getattr(media, 'css', {})\n            js = getattr(media, 'js', [])\n        else:\n            if css is None:\n                css = {}\n            if js is None:\n                js = []\n        self._css_lists = [css]\n        self._js_lists = [js]\n\n    def __repr__(self):\n        return 'Media(css=%r, js=%r)' % (self._css, self._js)\n\n    def __str__(self):\n        return self.render()\n\n    @property\n    def _css(self):\n        css = defaultdict(list)\n        for css_list in self._css_lists:\n            for medium, sublist in css_list.items():\n                css[medium].append(sublist)\n        return {medium: self.merge(*lists) for medium, lists in css.items()}\n\n    @property\n    def _js(self):\n        return self.merge(*self._js_lists)\n\n    def render(self):\n        return mark_safe('\\n'.join(chain.from_iterable(getattr(self, \n            'render_' + name)() for name in MEDIA_TYPES)))\n\n    def render_js(self):\n        return [(path.__html__() if hasattr(path, '__html__') else\n            format_html('<script src=\"{}\"></script>', self.absolute_path(\n            path))) for path in self._js]\n\n    def render_css(self):\n        media = sorted(self._css)\n        return chain.from_iterable([(path.__html__() if hasattr(path,\n            '__html__') else format_html(\n            '<link href=\"{}\" media=\"{}\" rel=\"stylesheet\">', self.\n            absolute_path(path), medium)) for path in self._css[medium]] for\n            medium in media)\n\n    def absolute_path(self, path):\n        \"\"\"\n        Given a relative or absolute path to a static asset, return an absolute\n        path. An absolute path will be returned unchanged while a relative path\n        will be passed to django.templatetags.static.static().\n        \"\"\"\n        if path.startswith(('http://', 'https://', '/')):\n            return path\n        return static(path)\n\n    def __getitem__(self, name):\n        \"\"\"Return a Media object that only contains media of the given type.\"\"\"\n        if name in MEDIA_TYPES:\n            return Media(**{str(name): getattr(self, '_' + name)})\n        raise KeyError('Unknown media type \"%s\"' % name)\n\n    @staticmethod\n    def merge(*lists):\n        \"\"\"\n        Merge lists while trying to keep the relative order of the elements.\n        Warn if the lists have the same elements in a different relative order.\n\n        For static assets it can be important to have them included in the DOM\n        in a certain order. In JavaScript you may not be able to reference a\n        global or in CSS you might want to override a style.\n        \"\"\"\n        ts = TopologicalSorter()\n        for head, *tail in filter(None, lists):\n            ts.add(head)\n            for item in tail:\n                if head != item:\n                    ts.add(item, head)\n                head = item\n        try:\n            return list(ts.static_order())\n        except CycleError:\n            warnings.warn(\n                'Detected duplicate Media files in an opposite order: {}'.\n                format(', '.join(repr(list_) for list_ in lists)),\n                MediaOrderConflictWarning)\n            return list(dict.fromkeys(chain.from_iterable(filter(None, lists)))\n                )\n\n    def __add__(self, other):\n        combined = Media()\n        combined._css_lists = self._css_lists[:]\n        combined._js_lists = self._js_lists[:]\n        for item in other._css_lists:\n            if item and item not in self._css_lists:\n                combined._css_lists.append(item)\n        for item in other._js_lists:\n            if item and item not in self._js_lists:\n                combined._js_lists.append(item)\n        return combined", "test_code_list": [{"test_code": "from django.forms import CharField\nfrom django.forms import Form\nfrom django.forms import Media\nfrom django.forms import MultiWidget\nfrom django.forms import TextInput\nfrom django.template import Context\nfrom django.template import Template\nfrom django.templatetags.static import static\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\n\nclass FormsMediaTestCase(SimpleTestCase):\n    def test_merge(self):\n        test_values = (([1, 2], [3, 4]), [1, 3, 2, 4]), (([1, 2], [2, 3]), [1, \n            2, 3]), (([2, 3], [1, 2]), [1, 2, 3]), (([1, 3], [2, 3]), [1, 2, 3]), (\n            ([1, 2], [1, 3]), [1, 2, 3]), (([1, 2], [3, 2]), [1, 3, 2]), (([1, \n            2], [1, 2]), [1, 2]), ([[1, 2], [1, 3], [2, 3], [5, 7], [5, 6], [6,\n            7, 9], [8, 9]], [1, 5, 8, 2, 6, 3, 7, 9]), ((), []), (([1, 2],), [1, 2]\n            )\n        for lists, expected in test_values:\n            with self.subTest(lists=lists):\n                self.assertEqual(Media.merge(*lists), expected)\n    \nFormsMediaTestCase().test_merge()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/forms_tests/tests/test_media.py"}, {"test_code": "from django.forms import CharField\nfrom django.forms import Form\nfrom django.forms import Media\nfrom django.forms import MultiWidget\nfrom django.forms import TextInput\nfrom django.template import Context\nfrom django.template import Template\nfrom django.templatetags.static import static\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\n\nclass FormsMediaTestCase(SimpleTestCase):\n    def test_merge_warning(self):\n        msg = 'Detected duplicate Media files in an opposite order: [1, 2], [2, 1]'\n        with self.assertWarnsMessage(RuntimeWarning, msg):\n            self.assertEqual(Media.merge([1, 2], [2, 1], None), [1, 2])\n    \nFormsMediaTestCase().test_merge_warning()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/forms_tests/tests/test_media.py"}], "instruction": "Functionality: The Media.merge function is a static method designed to merge multiple lists while attempting to maintain the relative order of the elements. It uses a topological sort to ensure that the order of elements, which is crucial for static assets like CSS and JavaScript where dependency and override order matters, is preserved. If the lists contain the same elements in a different relative order, it will issue a warning.\n\nInputs: \n- *lists: A variable number of list arguments consisting of elements that need to be merged.\n\nOutputs: \n- A list containing all elements from the input lists, merged in such a way that the relative order is preserved as much as possible. If a cycle is detected during the topological sort (indicating conflicting orders), the function will return a list with unique elements while preserving the original insertion order, and a warning will be issued.", "method_code_mask": "import copy\nimport datetime\nimport warnings\nfrom collections import defaultdict\nfrom graphlib import CycleError\nfrom graphlib import TopologicalSorter\nfrom itertools import chain\nfrom django.forms.utils import to_current_timezone\nfrom django.templatetags.static import static\nfrom django.utils import formats\nfrom django.utils.dates import MONTHS\nfrom django.utils.formats import get_format\nfrom django.utils.html import format_html\nfrom django.utils.html import html_safe\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _\n\n\n@html_safe\nclass Media:\n\n    def __init__(self, media=None, css=None, js=None):\n        if media is not None:\n            css = getattr(media, 'css', {})\n            js = getattr(media, 'js', [])\n        else:\n            if css is None:\n                css = {}\n            if js is None:\n                js = []\n        self._css_lists = [css]\n        self._js_lists = [js]\n\n    def __repr__(self):\n        return 'Media(css=%r, js=%r)' % (self._css, self._js)\n\n    def __str__(self):\n        return self.render()\n\n    @property\n    def _css(self):\n        css = defaultdict(list)\n        for css_list in self._css_lists:\n            for medium, sublist in css_list.items():\n                css[medium].append(sublist)\n        return {medium: self.merge(*lists) for medium, lists in css.items()}\n\n    @property\n    def _js(self):\n        return self.merge(*self._js_lists)\n\n    def render(self):\n        return mark_safe('\\n'.join(chain.from_iterable(getattr(self, \n            'render_' + name)() for name in MEDIA_TYPES)))\n\n    def render_js(self):\n        return [(path.__html__() if hasattr(path, '__html__') else\n            format_html('<script src=\"{}\"></script>', self.absolute_path(\n            path))) for path in self._js]\n\n    def render_css(self):\n        media = sorted(self._css)\n        return chain.from_iterable([(path.__html__() if hasattr(path,\n            '__html__') else format_html(\n            '<link href=\"{}\" media=\"{}\" rel=\"stylesheet\">', self.\n            absolute_path(path), medium)) for path in self._css[medium]] for\n            medium in media)\n\n    def absolute_path(self, path):\n        \"\"\"\n        Given a relative or absolute path to a static asset, return an absolute\n        path. An absolute path will be returned unchanged while a relative path\n        will be passed to django.templatetags.static.static().\n        \"\"\"\n        if path.startswith(('http://', 'https://', '/')):\n            return path\n        return static(path)\n\n    def __getitem__(self, name):\n        \"\"\"Return a Media object that only contains media of the given type.\"\"\"\n        if name in MEDIA_TYPES:\n            return Media(**{str(name): getattr(self, '_' + name)})\n        raise KeyError('Unknown media type \"%s\"' % name)\n\n    @staticmethod\n    def merge(*lists): [MASK]\n\n    def __add__(self, other):\n        combined = Media()\n        combined._css_lists = self._css_lists[:]\n        combined._js_lists = self._js_lists[:]\n        for item in other._css_lists:\n            if item and item not in self._css_lists:\n                combined._css_lists.append(item)\n        for item in other._js_lists:\n            if item and item not in self._js_lists:\n                combined._js_lists.append(item)\n        return combined\n"}
{"method_name": "resolve_url", "full_method_name": "resolve_url", "method_path": "../srcdata/Network/django/django/shortcuts.py", "method_code": "from django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.template import loader\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils.functional import Promise\ndef resolve_url(to, *args, **kwargs):\n    \"\"\"\n    Return a URL appropriate for the arguments passed.\n\n    The arguments could be:\n\n        * A model: the model's `get_absolute_url()` function will be called.\n\n        * A view name, possibly with arguments: `urls.reverse()` will be used\n          to reverse-resolve the name.\n\n        * A URL, which will be returned as-is.\n    \"\"\"\n    if hasattr(to, 'get_absolute_url'):\n        return to.get_absolute_url()\n    if isinstance(to, Promise):\n        to = str(to)\n    if isinstance(to, str) and to.startswith(('./', '../')):\n        return to\n    try:\n        return reverse(to, args=args, kwargs=kwargs)\n    except NoReverseMatch:\n        if callable(to):\n            raise\n        if '/' not in to and '.' not in to:\n            raise\n    return to", "test_code_list": [{"test_code": "from django.shortcuts import resolve_url\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse_lazy\n\nclass ResolveUrlTests(SimpleTestCase):\n    def test_relative_path(self):\n        \"\"\"\n            Passing a relative URL path to resolve_url() results in the same url.\n            \"\"\"\n        self.assertEqual('../', resolve_url('../'))\n        self.assertEqual('../relative/', resolve_url('../relative/'))\n        self.assertEqual('./', resolve_url('./'))\n        self.assertEqual('./relative/', resolve_url('./relative/'))\n    \nResolveUrlTests().test_relative_path()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/resolve_url/tests.py"}], "instruction": "Functionality: The resolve_url function is designed to return a URL based on the input argument. It supports models, view names, and direct URL strings. The function will call the model's get_absolute_url() method if a model is passed, use Django's urls.reverse() for view names, and return the URL as-is if a direct URL string is provided.\nInputs: \n- to: An argument that can be a model, a view name, a callable, or a URL string. \n- *args: Positional arguments that can be passed to reverse() if 'to' is a view name.\n- **kwargs: Keyword arguments that can be passed to reverse() if 'to' is a view name.\nOutputs:\n- Returns a URL string based on the input argument. If 'to' is a model, it returns the URL from the model's get_absolute_url() method. If 'to' is a view name, it returns the URL from reverse(). If 'to' is a URL string, it returns the string as-is. If 'to' is a callable, it raises the exception that the callable raised. If 'to' is a string that does not contain a slash ('/') or a period ('.'), and is not a valid view name, it returns 'to' as-is.", "method_code_mask": "from django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.template import loader\nfrom django.urls import NoReverseMatch\nfrom django.urls import reverse\nfrom django.utils.functional import Promise\n\n\ndef resolve_url(to, *args, **kwargs): [MASK]\n"}
{"method_name": "supports_color", "full_method_name": "supports_color", "method_path": "../srcdata/Network/django/django/core/management/color.py", "method_code": "import functools\nimport os\nimport sys\nfrom django.utils import termcolors\nimport colorama\ndef supports_color():\n    \"\"\"\n    Return True if the running system's terminal supports color,\n    and False otherwise.\n    \"\"\"\n\n    def vt_codes_enabled_in_windows_registry():\n        \"\"\"\n        Check the Windows Registry to see if VT code handling has been enabled\n        by default, see https://superuser.com/a/1300251/447564.\n        \"\"\"\n        try:\n            import winreg\n        except ImportError:\n            return False\n        else:\n            try:\n                reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Console')\n                reg_key_value, _ = winreg.QueryValueEx(reg_key,\n                    'VirtualTerminalLevel')\n            except FileNotFoundError:\n                return False\n            else:\n                return reg_key_value == 1\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()\n    return is_a_tty and (sys.platform != 'win32' or HAS_COLORAMA and\n        getattr(colorama, 'fixed_windows_console', False) or 'ANSICON' in\n        os.environ or 'WT_SESSION' in os.environ or os.environ.get(\n        'TERM_PROGRAM') == 'vscode' or vt_codes_enabled_in_windows_registry())", "test_code_list": [{"test_code": "import os\nimport re\nimport shutil\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nimport unittest\nfrom io import StringIO\nfrom unittest import mock\nfrom django import conf\nfrom django import get_version\nfrom django.conf import settings\nfrom django.core.management import BaseCommand\nfrom django.core.management import CommandError\nfrom django.core.management import call_command\nfrom django.core.management import color\nfrom django.core.management import execute_from_command_line\nfrom django.core.management.commands.loaddata import Command as LoaddataCommand\nfrom django.core.management.commands.runserver import Command as RunserverCommand\nfrom django.core.management.commands.testserver import Command as TestserverCommand\nfrom django.db import ConnectionHandler\nfrom django.db import connection\nfrom django.db.migrations.recorder import MigrationRecorder\nfrom django.test import LiveServerTestCase\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import captured_stderr\nfrom django.test.utils import captured_stdout\nfrom django.urls import path\nfrom django.views.static import serve\nclass ColorCommand(BaseCommand):\n    requires_system_checks = []\n\n    def handle(self, *args, **options):\n        self.stdout.write('Hello, world!', self.style.ERROR)\n        self.stderr.write('Hello, world!', self.style.ERROR)\nclass AdminScriptTestCase(SimpleTestCase):\n    def setUp(self):\n        tmpdir = tempfile.TemporaryDirectory()\n        self.addCleanup(tmpdir.cleanup)\n        self.test_dir = os.path.realpath(os.path.join(tmpdir.name,\n            'test_project'))\n        os.mkdir(self.test_dir)\n    def write_settings(self, filename, apps=None, is_dir=False, sdict=None,\n        extra=None):\n        if is_dir:\n            settings_dir = os.path.join(self.test_dir, filename)\n            os.mkdir(settings_dir)\n            settings_file_path = os.path.join(settings_dir, '__init__.py')\n        else:\n            settings_file_path = os.path.join(self.test_dir, filename)\n        with open(settings_file_path, 'w') as settings_file:\n            settings_file.write(\n                \"\"\"# Settings file automatically generated by admin_scripts test case\n\"\"\"\n                )\n            if extra:\n                settings_file.write('%s\\n' % extra)\n            exports = ['DATABASES', 'DEFAULT_AUTO_FIELD', 'ROOT_URLCONF',\n                'SECRET_KEY', 'USE_TZ']\n            for s in exports:\n                if hasattr(settings, s):\n                    o = getattr(settings, s)\n                    if not isinstance(o, (dict, tuple, list)):\n                        o = \"'%s'\" % o\n                    settings_file.write('%s = %s\\n' % (s, o))\n            if apps is None:\n                apps = ['django.contrib.auth',\n                    'django.contrib.contenttypes', 'admin_scripts']\n            settings_file.write('INSTALLED_APPS = %s\\n' % apps)\n            if sdict:\n                for k, v in sdict.items():\n                    settings_file.write('%s = %s\\n' % (k, v))\n    def _ext_backend_paths(self):\n        \"\"\"\n        Returns the paths for any external backend packages.\n        \"\"\"\n        paths = []\n        for backend in settings.DATABASES.values():\n            package = backend['ENGINE'].split('.')[0]\n            if package != 'django':\n                backend_pkg = __import__(package)\n                backend_dir = os.path.dirname(backend_pkg.__file__)\n                paths.append(os.path.dirname(backend_dir))\n        return paths\n    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n        base_dir = os.path.dirname(self.test_dir)\n        tests_dir = os.path.dirname(os.path.dirname(__file__))\n        django_dir = os.path.dirname(tests_dir)\n        ext_backend_base_dirs = self._ext_backend_paths()\n        test_environ = os.environ.copy()\n        if settings_file:\n            test_environ['DJANGO_SETTINGS_MODULE'] = settings_file\n        elif 'DJANGO_SETTINGS_MODULE' in test_environ:\n            del test_environ['DJANGO_SETTINGS_MODULE']\n        python_path = [base_dir, django_dir, tests_dir]\n        python_path.extend(ext_backend_base_dirs)\n        test_environ['PYTHONPATH'] = os.pathsep.join(python_path)\n        test_environ['PYTHONWARNINGS'] = ''\n        p = subprocess.run([sys.executable, *args], capture_output=True,\n            cwd=self.test_dir, env=test_environ, text=True, umask=umask)\n        return p.stdout, p.stderr\n    def run_django_admin(self, args, settings_file=None, umask=-1):\n        return self.run_test(['-m', 'django', *args], settings_file, umask=\n            umask)\n    def run_manage(self, args, settings_file=None, manage_py=None):\n        template_manage_py = os.path.join(os.path.dirname(__file__), manage_py\n            ) if manage_py else os.path.join(os.path.dirname(conf.__file__),\n            'project_template', 'manage.py-tpl')\n        test_manage_py = os.path.join(self.test_dir, 'manage.py')\n        shutil.copyfile(template_manage_py, test_manage_py)\n        with open(test_manage_py) as fp:\n            manage_py_contents = fp.read()\n        manage_py_contents = manage_py_contents.replace('{{ project_name }}',\n            'test_project')\n        with open(test_manage_py, 'w') as fp:\n            fp.write(manage_py_contents)\n        return self.run_test(['./manage.py', *args], settings_file)\n    def assertNoOutput(self, stream):\n        \"\"\"Utility assertion: assert that the given stream is empty\"\"\"\n        self.assertEqual(len(stream), 0,\n            \"Stream should be empty: actually contains '%s'\" % stream)\n    def assertOutput(self, stream, msg, regex=False):\n        \"\"\"Utility assertion: assert that the given message exists in the output\"\"\"\n        if regex:\n            self.assertIsNotNone(re.search(msg, stream),\n                \"'%s' does not match actual output text '%s'\" % (msg, stream))\n        else:\n            self.assertIn(msg, stream,\n                \"'%s' does not match actual output text '%s'\" % (msg, stream))\n    def assertNotInOutput(self, stream, msg):\n        \"\"\"Utility assertion: assert that the given message doesn't exist in the output\"\"\"\n        self.assertNotIn(msg, stream,\n            \"'%s' matches actual output text '%s'\" % (msg, stream))\nclass CommandTypes(AdminScriptTestCase):\n    def test_command_color(self):\n        out = StringIO()\n        err = StringIO()\n        command = ColorCommand(stdout=out, stderr=err)\n        call_command(command)\n        if supports_color():\n            self.assertIn('Hello, world!\\n', out.getvalue())\n            self.assertIn('Hello, world!\\n', err.getvalue())\n            self.assertNotEqual(out.getvalue(), 'Hello, world!\\n')\n            self.assertNotEqual(err.getvalue(), 'Hello, world!\\n')\n        else:\n            self.assertEqual(out.getvalue(), 'Hello, world!\\n')\n            self.assertEqual(err.getvalue(), 'Hello, world!\\n')\nCommandTypes().test_command_color()", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_scripts/tests.py"}], "instruction": "Functionality: The supports_color function determines if the current terminal or console supports color output. This is particularly useful for applications that want to display colored text, ensuring that the output will be correctly rendered in the environment it is running.\n\nInputs: The function does not take any arguments. It relies on environment variables, system attributes, and external library statuses to determine color support.\n\nOutputs: The function returns a boolean value; True if the terminal or console supports color output, and False otherwise.", "method_code_mask": "import functools\nimport os\nimport sys\nfrom django.utils import termcolors\nimport colorama\n\n\ndef supports_color(): [MASK]\n"}
{"method_name": "static", "full_method_name": "static", "method_path": "../srcdata/Network/django/django/conf/urls/static.py", "method_code": "import re\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.urls import re_path\nfrom django.views.static import serve\ndef static(prefix, view=serve, **kwargs):\n    \"\"\"\n    Return a URL pattern for serving files in debug mode.\n\n    from django.conf import settings\n    from django.conf.urls.static import static\n\n    urlpatterns = [\n        # ... the rest of your URLconf goes here ...\n    ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n    \"\"\"\n    if not prefix:\n        raise ImproperlyConfigured('Empty static prefix not permitted')\n    elif not settings.DEBUG or urlsplit(prefix).netloc:\n        return []\n    return [re_path('^%s(?P<path>.*)$' % re.escape(prefix.lstrip('/')),\n        view, kwargs=kwargs)]", "test_code_list": [{"test_code": "import mimetypes\nimport unittest\nfrom os import path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom django.conf.urls.static import static\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import FileResponse\nfrom django.http import HttpResponseNotModified\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.http import http_date\nfrom django.views.static import directory_index\nfrom django.views.static import was_modified_since\nfrom django.views.static import Path\n@override_settings(DEBUG=True, ROOT_URLCONF='view_tests.urls')\nclass StaticTests(SimpleTestCase):\n    \"\"\"Tests django views in django/views/static.py\"\"\"\n    prefix = 'site_media'\n\n    def test_serve(self):\n        \"\"\"The static view can serve static media\"\"\"\n        media_files = ['file.txt', 'file.txt.gz', '%2F.txt']\n        for filename in media_files:\n            response = self.client.get('/%s/%s' % (self.prefix, quote(\n                filename)))\n            response_content = b''.join(response)\n            file_path = path.join(media_dir, filename)\n            with open(file_path, 'rb') as fp:\n                self.assertEqual(fp.read(), response_content)\n            self.assertEqual(len(response_content), int(response.headers[\n                'Content-Length']))\n            self.assertEqual(mimetypes.guess_type(file_path)[1], response.\n                get('Content-Encoding', None))\n\n    def test_chunked(self):\n        \"\"\"The static view should stream files in chunks to avoid large memory usage\"\"\"\n        response = self.client.get('/%s/%s' % (self.prefix, 'long-line.txt'))\n        response_iterator = iter(response)\n        first_chunk = next(response_iterator)\n        self.assertEqual(len(first_chunk), FileResponse.block_size)\n        second_chunk = next(response_iterator)\n        response.close()\n        self.assertEqual(len(second_chunk.strip()), 1449)\n\n    def test_unknown_mime_type(self):\n        response = self.client.get('/%s/file.unknown' % self.prefix)\n        self.assertEqual('application/octet-stream', response.headers[\n            'Content-Type'])\n        response.close()\n\n    def test_copes_with_empty_path_component(self):\n        file_name = 'file.txt'\n        response = self.client.get('/%s//%s' % (self.prefix, file_name))\n        response_content = b''.join(response)\n        with open(path.join(media_dir, file_name), 'rb') as fp:\n            self.assertEqual(fp.read(), response_content)\n\n    def test_is_modified_since(self):\n        file_name = 'file.txt'\n        response = self.client.get('/%s/%s' % (self.prefix, file_name),\n            headers={'if-modified-since': 'Thu, 1 Jan 1970 00:00:00 GMT'})\n        response_content = b''.join(response)\n        with open(path.join(media_dir, file_name), 'rb') as fp:\n            self.assertEqual(fp.read(), response_content)\n\n    def test_not_modified_since(self):\n        file_name = 'file.txt'\n        response = self.client.get('/%s/%s' % (self.prefix, file_name),\n            headers={'if-modified-since': 'Mon, 18 Jan 2038 05:14:07 GMT'})\n        self.assertIsInstance(response, HttpResponseNotModified)\n\n    def test_invalid_if_modified_since(self):\n        \"\"\"Handle bogus If-Modified-Since values gracefully\n\n        Assume that a file is modified since an invalid timestamp as per RFC\n        9110 Section 13.1.3.\n        \"\"\"\n        file_name = 'file.txt'\n        invalid_date = 'Mon, 28 May 999999999999 28:25:26 GMT'\n        response = self.client.get('/%s/%s' % (self.prefix, file_name),\n            headers={'if-modified-since': invalid_date})\n        response_content = b''.join(response)\n        with open(path.join(media_dir, file_name), 'rb') as fp:\n            self.assertEqual(fp.read(), response_content)\n        self.assertEqual(len(response_content), int(response.headers[\n            'Content-Length']))\n\n    def test_invalid_if_modified_since2(self):\n        \"\"\"Handle even more bogus If-Modified-Since values gracefully\n\n        Assume that a file is modified since an invalid timestamp as per RFC\n        9110 Section 13.1.3.\n        \"\"\"\n        file_name = 'file.txt'\n        invalid_date = ': 1291108438, Wed, 20 Oct 2010 14:05:00 GMT'\n        response = self.client.get('/%s/%s' % (self.prefix, file_name),\n            headers={'if-modified-since': invalid_date})\n        response_content = b''.join(response)\n        with open(path.join(media_dir, file_name), 'rb') as fp:\n            self.assertEqual(fp.read(), response_content)\n        self.assertEqual(len(response_content), int(response.headers[\n            'Content-Length']))\n\n    def test_404(self):\n        response = self.client.get('/%s/nonexistent_resource' % self.prefix)\n        self.assertEqual(404, response.status_code)\n\n    def test_index(self):\n        response = self.client.get('/%s/' % self.prefix)\n        self.assertContains(response, 'Index of ./')\n        self.assertIn('subdir/', response.context['file_list'])\n\n    def test_index_subdir(self):\n        response = self.client.get('/%s/subdir/' % self.prefix)\n        self.assertContains(response, 'Index of subdir/')\n        self.assertEqual(response.context['file_list'], ['visible'])\n\n    @override_settings(TEMPLATES=[{'BACKEND':\n        'django.template.backends.django.DjangoTemplates', 'OPTIONS': {\n        'loaders': [('django.template.loaders.locmem.Loader', {\n        'static/directory_index.html': 'Test index'})]}}])\n    def test_index_custom_template(self):\n        response = self.client.get('/%s/' % self.prefix)\n        self.assertEqual(response.content, b'Test index')\n\n    def test_template_encoding(self):\n        \"\"\"\n        The template is loaded directly, not via a template loader, and should\n        be opened as utf-8 charset as is the default specified on template\n        engines.\n        \"\"\"\n        from django.views.static import Path\n        with mock.patch.object(Path, 'open') as m:\n            directory_index(mock.MagicMock(), mock.MagicMock())\n            m.assert_called_once_with(encoding='utf-8')\n\nclass StaticHelperTest(StaticTests):\n    def test_empty_prefix(self):\n        with self.assertRaisesMessage(ImproperlyConfigured,\n            'Empty static prefix not permitted'):\n            static('')\n    \nStaticHelperTest().test_empty_prefix()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/view_tests/tests/test_static.py"}], "instruction": "Functionality: The static function is designed to facilitate the serving of static files, such as media or images, during the development phase when Django's debug mode is enabled. This function generates URL patterns that are used to serve static files from a specified document root.\n\nInputs:\n- prefix: A string representing the URL prefix for the static files. This prefix will be prepended to the path of each file. It is essential to specify a non-empty prefix as empty prefixes are not allowed and will raise an ImproperlyConfigured exception.\n- view: A view function used to serve the files. By default, this function uses the Django's serve function, which is responsible for serving files.\n- **kwargs: Additional keyword arguments that can be passed to the view function. These arguments can be used to configure the behavior of the view, such as specifying authentication requirements or additional options.\n\nOutputs:\n- The static function returns a list containing a URL pattern that maps to the specified view function. This URL pattern is used by Django to route requests for static files to the correct view. If the prefix is empty or if the application is not in debug mode or the URL prefix contains a network location component, the function will return an empty list, indicating that no URL pattern for static file serving should be included in the application's URL patterns.", "method_code_mask": "import re\nfrom urllib.parse import urlsplit\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.urls import re_path\nfrom django.views.static import serve\n\n\ndef static(prefix, view=serve, **kwargs): [MASK]\n"}
{"method_name": "was_modified_since", "full_method_name": "was_modified_since", "method_path": "../srcdata/Network/django/django/views/static.py", "method_code": "import mimetypes\nimport posixpath\nfrom pathlib import Path\nfrom django.http import FileResponse\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.template import Context\nfrom django.template import Engine\nfrom django.template import TemplateDoesNotExist\nfrom django.template import loader\nfrom django.utils._os import safe_join\nfrom django.utils.http import http_date\nfrom django.utils.http import parse_http_date\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\ndef was_modified_since(header=None, mtime=0):\n    \"\"\"\n    Was something modified since the user last downloaded it?\n\n    header\n      This is the value of the If-Modified-Since header.  If this is None,\n      I'll just return True.\n\n    mtime\n      This is the modification time of the item we're talking about.\n    \"\"\"\n    try:\n        if header is None:\n            raise ValueError\n        header_mtime = parse_http_date(header)\n        if int(mtime) > header_mtime:\n            raise ValueError\n    except (ValueError, OverflowError):\n        return True\n    return False", "test_code_list": [{"test_code": "import mimetypes\nimport unittest\nfrom os import path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom django.conf.urls.static import static\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import FileResponse\nfrom django.http import HttpResponseNotModified\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.http import http_date\nfrom django.views.static import directory_index\nfrom django.views.static import was_modified_since\nfrom django.views.static import Path\n\nclass StaticUtilsTests(unittest.TestCase):\n    def test_was_modified_since_fp(self):\n        \"\"\"\n            A floating point mtime does not disturb was_modified_since (#18675).\n            \"\"\"\n        mtime = 1343416141.107817\n        header = http_date(mtime)\n        self.assertFalse(was_modified_since(header, mtime))\n    \nStaticUtilsTests().test_was_modified_since_fp()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/view_tests/tests/test_static.py"}, {"test_code": "import mimetypes\nimport unittest\nfrom os import path\nfrom unittest import mock\nfrom urllib.parse import quote\nfrom django.conf.urls.static import static\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.http import FileResponse\nfrom django.http import HttpResponseNotModified\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.utils.http import http_date\nfrom django.views.static import directory_index\nfrom django.views.static import was_modified_since\nfrom django.views.static import Path\n\nclass StaticUtilsTests(unittest.TestCase):\n    def test_was_modified_since_empty_string(self):\n        self.assertTrue(was_modified_since(header='', mtime=1))\n    \nStaticUtilsTests().test_was_modified_since_empty_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/view_tests/tests/test_static.py"}], "instruction": "Functionality: The was_modified_since function checks if a resource has been modified since the last time the user accessed it. It does this by comparing the provided modification time (mtime) of the resource to the If-Modified-Since header value received from the user's request. If the resource has been modified, or if the header is not provided, the function returns True. Otherwise, it returns False.\n\nInputs:\n- header: A string representing the value of the If-Modified-Since header in the user's request. If None, the function assumes the resource has been modified.\n- mtime: An integer representing the modification time of the resource in question. If the mtime is greater than the time represented by the If-Modified-Since header, the resource is considered to have been modified.\n\nOutputs:\n- A boolean value indicating whether the resource has been modified since the last access:\n  - True if the resource was modified or the header is not provided.\n  - False if the resource was not modified since the time indicated by the header.", "method_code_mask": "import mimetypes\nimport posixpath\nfrom pathlib import Path\nfrom django.http import FileResponse\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.template import Context\nfrom django.template import Engine\nfrom django.template import TemplateDoesNotExist\nfrom django.template import loader\nfrom django.utils._os import safe_join\nfrom django.utils.http import http_date\nfrom django.utils.http import parse_http_date\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import gettext_lazy\n\n\ndef was_modified_since(header=None, mtime=0): [MASK]\n"}
{"method_name": "sanitize_strftime_format", "full_method_name": "sanitize_strftime_format", "method_path": "../srcdata/Network/django/django/utils/formats.py", "method_code": "import datetime\nimport decimal\nimport functools\nimport re\nimport unicodedata\nfrom importlib import import_module\nfrom django.conf import settings\nfrom django.utils import dateformat\nfrom django.utils import numberformat\nfrom django.utils.functional import lazy\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import get_language\nfrom django.utils.translation import to_locale\n@functools.lru_cache\ndef sanitize_strftime_format(fmt):\n    \"\"\"\n    Ensure that certain specifiers are correctly padded with leading zeros.\n\n    For years < 1000 specifiers %C, %F, %G, and %Y don't work as expected for\n    strftime provided by glibc on Linux as they don't pad the year or century\n    with leading zeros. Support for specifying the padding explicitly is\n    available, however, which can be used to fix this issue.\n\n    FreeBSD, macOS, and Windows do not support explicitly specifying the\n    padding, but return four digit years (with leading zeros) as expected.\n\n    This function checks whether the %Y produces a correctly padded string and,\n    if not, makes the following substitutions:\n\n    - %C \u2192 %02C\n    - %F \u2192 %010F\n    - %G \u2192 %04G\n    - %Y \u2192 %04Y\n\n    See https://bugs.python.org/issue13305 for more details.\n    \"\"\"\n    if datetime.date(1, 1, 1).strftime('%Y') == '0001':\n        return fmt\n    mapping = {'C': 2, 'F': 10, 'G': 4, 'Y': 4}\n    return re.sub('((?:^|[^%])(?:%%)*)%([CFGY])', lambda m: '%s%%0%s%s' % (\n        m[1], mapping[m[2]], m[2]), fmt)", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport gettext as gettext_module\nimport os\nimport pickle\nimport re\nimport tempfile\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest import mock\nfrom asgiref.local import Local\nfrom django import forms\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.template import Context\nfrom django.template import Template\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils import translation\nfrom django.utils.formats import date_format\nfrom django.utils.formats import get_format\nfrom django.utils.formats import iter_format_modules\nfrom django.utils.formats import localize\nfrom django.utils.formats import localize_input\nfrom django.utils.formats import reset_format_cache\nfrom django.utils.formats import sanitize_separators\nfrom django.utils.formats import sanitize_strftime_format\nfrom django.utils.formats import time_format\nfrom django.utils.numberformat import format as nformat\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import activate\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import deactivate\nfrom django.utils.translation import get_language\nfrom django.utils.translation import get_language_bidi\nfrom django.utils.translation import get_language_from_request\nfrom django.utils.translation import get_language_info\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import ngettext_lazy\nfrom django.utils.translation import npgettext\nfrom django.utils.translation import npgettext_lazy\nfrom django.utils.translation import pgettext\nfrom django.utils.translation import round_away_from_one\nfrom django.utils.translation import to_language\nfrom django.utils.translation import to_locale\nfrom django.utils.translation import trans_null\nfrom django.utils.translation import trans_real\nfrom django.utils.translation.reloader import translation_file_changed\nfrom django.utils.translation.reloader import watch_for_translation_changes\nfrom django.utils.formats import _format_cache\n\nclass FormattingTests(SimpleTestCase):\n    def test_sanitize_strftime_format(self):\n        for year in (1, 99, 999, 1000):\n            dt = datetime.date(year, 1, 1)\n            for fmt, expected in [('%C', '%02d' % (year // 100)), ('%F', \n                '%04d-01-01' % year), ('%G', '%04d' % year), ('%Y', '%04d' % year)\n                ]:\n                with self.subTest(year=year, fmt=fmt):\n                    fmt = sanitize_strftime_format(fmt)\n                    self.assertEqual(dt.strftime(fmt), expected)\n    \nFormattingTests().test_sanitize_strftime_format()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/i18n/tests.py"}, {"test_code": "import datetime\nimport decimal\nimport gettext as gettext_module\nimport os\nimport pickle\nimport re\nimport tempfile\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest import mock\nfrom asgiref.local import Local\nfrom django import forms\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.template import Context\nfrom django.template import Template\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils import translation\nfrom django.utils.formats import date_format\nfrom django.utils.formats import get_format\nfrom django.utils.formats import iter_format_modules\nfrom django.utils.formats import localize\nfrom django.utils.formats import localize_input\nfrom django.utils.formats import reset_format_cache\nfrom django.utils.formats import sanitize_separators\nfrom django.utils.formats import sanitize_strftime_format\nfrom django.utils.formats import time_format\nfrom django.utils.numberformat import format as nformat\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import activate\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import deactivate\nfrom django.utils.translation import get_language\nfrom django.utils.translation import get_language_bidi\nfrom django.utils.translation import get_language_from_request\nfrom django.utils.translation import get_language_info\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import ngettext_lazy\nfrom django.utils.translation import npgettext\nfrom django.utils.translation import npgettext_lazy\nfrom django.utils.translation import pgettext\nfrom django.utils.translation import round_away_from_one\nfrom django.utils.translation import to_language\nfrom django.utils.translation import to_locale\nfrom django.utils.translation import trans_null\nfrom django.utils.translation import trans_real\nfrom django.utils.translation.reloader import translation_file_changed\nfrom django.utils.translation.reloader import watch_for_translation_changes\nfrom django.utils.formats import _format_cache\n\nclass FormattingTests(SimpleTestCase):\n    def test_sanitize_strftime_format_with_escaped_percent(self):\n        dt = datetime.date(1, 1, 1)\n        for fmt, expected in [('%%C', '%C'), ('%%F', '%F'), ('%%G', '%G'), (\n            '%%Y', '%Y'), ('%%%%C', '%%C'), ('%%%%F', '%%F'), ('%%%%G', '%%G'),\n            ('%%%%Y', '%%Y')]:\n            with self.subTest(fmt=fmt):\n                fmt = sanitize_strftime_format(fmt)\n                self.assertEqual(dt.strftime(fmt), expected)\n        for year in (1, 99, 999, 1000):\n            dt = datetime.date(year, 1, 1)\n            for fmt, expected in [('%%%C', '%%%02d' % (year // 100)), ('%%%F', \n                '%%%04d-01-01' % year), ('%%%G', '%%%04d' % year), ('%%%Y', \n                '%%%04d' % year), ('%%%%%C', '%%%%%02d' % (year // 100)), (\n                '%%%%%F', '%%%%%04d-01-01' % year), ('%%%%%G', '%%%%%04d' %\n                year), ('%%%%%Y', '%%%%%04d' % year)]:\n                with self.subTest(year=year, fmt=fmt):\n                    fmt = sanitize_strftime_format(fmt)\n                    self.assertEqual(dt.strftime(fmt), expected)\n    \nFormattingTests().test_sanitize_strftime_format_with_escaped_percent()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/i18n/tests.py"}], "instruction": "Functionality: The sanitize_strftime_format function is designed to ensure that certain date format specifiers are correctly padded with leading zeros when formatting dates in strings. This is particularly useful for handling years less than 1000 on systems where the strftime function from the glibc library on Linux does not apply leading zero padding to these specifiers. The function checks if the strftime function returns a correctly padded year for the date '0001'. If padding is not applied, it makes substitutions to ensure that %C, %F, %G, and %Y specifiers are padded with zeros.\n\nInputs: \n- fmt: A string representing the date format that needs to be sanitized. This string should contain placeholders for date and time elements that are to be formatted, such as '%Y' for the year, '%m' for the month, etc.\n\nOutputs:\n- A string: If the input format string does not require padding adjustments, the original format string is returned. If adjustments are necessary, the function returns a new format string with the required padding applied to the '%C', '%F', '%G', and '%Y' specifiers. The substitutions are as follows:\n  - '%C' is replaced with '%02C'\n  - '%F' is replaced with '%010F'\n  - '%G' is replaced with '%04G'\n  - '%Y' is replaced with '%04Y'", "method_code_mask": "import datetime\nimport decimal\nimport functools\nimport re\nimport unicodedata\nfrom importlib import import_module\nfrom django.conf import settings\nfrom django.utils import dateformat\nfrom django.utils import numberformat\nfrom django.utils.functional import lazy\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import get_language\nfrom django.utils.translation import to_locale\n\n\n@functools.lru_cache\ndef sanitize_strftime_format(fmt): [MASK]\n"}
{"method_name": "parse_accept_lang_header", "full_method_name": "parse_accept_lang_header", "method_path": "../srcdata/Network/django/django/utils/translation/trans_real.py", "method_code": "import functools\nimport gettext as gettext_module\nimport os\nimport re\nimport sys\nimport warnings\nfrom asgiref.local import Local\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.core.exceptions import AppRegistryNotReady\nfrom django.core.signals import setting_changed\nfrom django.dispatch import receiver\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\naccept_language_re = _lazy_re_compile(\n    \"\"\"\n        # \"en\", \"en-au\", \"x-y-z\", \"es-419\", \"*\"\n        ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\\\\*)\n        # Optional \"q=1.00\", \"q=0.8\"\n        (?:\\\\s*;\\\\s*q=(0(?:\\\\.[0-9]{,3})?|1(?:\\\\.0{,3})?))?\n        # Multiple accepts per header.\n        (?:\\\\s*,\\\\s*|$)\n    \"\"\"\n    , re.VERBOSE)\n@functools.lru_cache(maxsize=1000)\ndef _parse_accept_lang_header(lang_string):\n    \"\"\"\n    Parse the lang_string, which is the body of an HTTP Accept-Language\n    header, and return a tuple of (lang, q-value), ordered by 'q' values.\n    Return an empty tuple if there are any format errors in lang_string.\n    \"\"\"\n    result = []\n    pieces = accept_language_re.split(lang_string.lower())\n    if pieces[-1]:\n        return ()\n    for i in range(0, len(pieces) - 1, 3):\n        first, lang, priority = pieces[i:i + 3]\n        if first:\n            return ()\n        if priority:\n            priority = float(priority)\n        else:\n            priority = 1.0\n        result.append((lang, priority))\n    result.sort(key=lambda k: k[1], reverse=True)\n    return tuple(result)\nACCEPT_LANGUAGE_HEADER_MAX_LENGTH = 500\ndef parse_accept_lang_header(lang_string):\n    \"\"\"\n    Parse the value of the Accept-Language header up to a maximum length.\n    The value of the header is truncated to a maximum length to avoid potential\n    denial of service and memory exhaustion attacks. Excessive memory could be\n    used if the raw value is very large as it would be cached due to the use of\n    functools.lru_cache() to avoid repetitive parsing of common header values.\n    \"\"\"\n    if len(lang_string) <= ACCEPT_LANGUAGE_HEADER_MAX_LENGTH:\n        return _parse_accept_lang_header(lang_string)\n    if (index := lang_string.rfind(',', 0, ACCEPT_LANGUAGE_HEADER_MAX_LENGTH)\n        ) > 0:\n        return _parse_accept_lang_header(lang_string[:index])\n    return ()", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport gettext as gettext_module\nimport os\nimport pickle\nimport re\nimport tempfile\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest import mock\nfrom asgiref.local import Local\nfrom django import forms\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.template import Context\nfrom django.template import Template\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils import translation\nfrom django.utils.formats import date_format\nfrom django.utils.formats import get_format\nfrom django.utils.formats import iter_format_modules\nfrom django.utils.formats import localize\nfrom django.utils.formats import localize_input\nfrom django.utils.formats import reset_format_cache\nfrom django.utils.formats import sanitize_separators\nfrom django.utils.formats import sanitize_strftime_format\nfrom django.utils.formats import time_format\nfrom django.utils.numberformat import format as nformat\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import activate\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import deactivate\nfrom django.utils.translation import get_language\nfrom django.utils.translation import get_language_bidi\nfrom django.utils.translation import get_language_from_request\nfrom django.utils.translation import get_language_info\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import ngettext_lazy\nfrom django.utils.translation import npgettext\nfrom django.utils.translation import npgettext_lazy\nfrom django.utils.translation import pgettext\nfrom django.utils.translation import round_away_from_one\nfrom django.utils.translation import to_language\nfrom django.utils.translation import to_locale\nfrom django.utils.translation import trans_null\nfrom django.utils.translation import trans_real\nfrom django.utils.translation.reloader import translation_file_changed\nfrom django.utils.translation.reloader import watch_for_translation_changes\nfrom django.utils.formats import _format_cache\n\nclass MiscTests(SimpleTestCase):\n    def test_parse_spec_http_header(self):\n        \"\"\"\n            Testing HTTP header parsing. First, we test that we can parse the\n            values according to the spec (and that we extract all the pieces in\n            the right order).\n            \"\"\"\n        tests = [('de', [('de', 1.0)]), ('en-AU', [('en-au', 1.0)]), ('es-419',\n            [('es-419', 1.0)]), ('*;q=1.00', [('*', 1.0)]), ('en-AU;q=0.123', [\n            ('en-au', 0.123)]), ('en-au;q=0.5', [('en-au', 0.5)]), (\n            'en-au;q=1.0', [('en-au', 1.0)]), ('da, en-gb;q=0.25, en;q=0.5', [(\n            'da', 1.0), ('en', 0.5), ('en-gb', 0.25)]), ('en-au-xx', [(\n            'en-au-xx', 1.0)]), (\n            'de,en-au;q=0.75,en-us;q=0.5,en;q=0.25,es;q=0.125,fa;q=0.125', [(\n            'de', 1.0), ('en-au', 0.75), ('en-us', 0.5), ('en', 0.25), ('es', \n            0.125), ('fa', 0.125)]), ('*', [('*', 1.0)]), ('de;q=0.', [('de', \n            0.0)]), ('en; q=1,', [('en', 1.0)]), ('en; q=1.0, * ; q=0.5', [(\n            'en', 1.0), ('*', 0.5)]), ('en' + '-x' * 20, [(\n            'en-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x', 1.0)]), (', '.join([\n            'en; q=1.0'] * 20), [('en', 1.0)] * 20), ('en-gb;q=1.0000', []), (\n            'en;q=0.1234', []), ('en;q=.2', []), ('abcdefghi-au', []), ('**', [\n            ]), ('en,,gb', []), ('en-au;q=0.1.0', []), ('X' * 97 + 'Z,en', []),\n            ('da, en-gb;q=0.8, en;q=0.7,#', []), ('de;q=2.0', []), ('de;q=0.a',\n            []), ('12-345', []), ('', []), ('en;q=1e0', []), ('en-au;q=\uff11.\uff10', []\n            ), ('xxxxxxxx' + '-xxxxxxxx' * 500, []), (', '.join(['en; q=1.0'] *\n            500), [('en', 1.0)] * 45)]\n        for value, expected in tests:\n            with self.subTest(value=value):\n                self.assertEqual(parse_accept_lang_header(value),\n                    tuple(expected))\n    \nMiscTests().test_parse_spec_http_header()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/i18n/tests.py"}], "instruction": "Functionality: The parse_accept_lang_header function is designed to parse the body of an HTTP Accept-Language header, extracting language preferences and their associated quality ('q') values. It returns a tuple of (lang, q-value) pairs, ordered by 'q' values in descending order. If the input string exceeds a predefined maximum length, it will be truncated to avoid potential denial of service and memory exhaustion attacks. In cases where the input string contains format errors, an empty tuple is returned.\n\nInputs: \n- lang_string: A string representing the body of an HTTP Accept-Language header. This string contains language preferences and their quality values.\n\nOutputs:\n- A tuple of tuples, where each inner tuple contains a language code (lang) and its associated quality value (q-value), sorted in descending order by the q-value. An empty tuple is returned if there are any format errors in the lang_string.", "method_code_mask": "import functools\nimport gettext as gettext_module\nimport os\nimport re\nimport sys\nimport warnings\nfrom asgiref.local import Local\nfrom django.apps import apps\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.core.exceptions import AppRegistryNotReady\nfrom django.core.signals import setting_changed\nfrom django.dispatch import receiver\nfrom django.utils.regex_helper import _lazy_re_compile\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\naccept_language_re = _lazy_re_compile(\n    \"\"\"\n        # \"en\", \"en-au\", \"x-y-z\", \"es-419\", \"*\"\n        ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\\\\*)\n        # Optional \"q=1.00\", \"q=0.8\"\n        (?:\\\\s*;\\\\s*q=(0(?:\\\\.[0-9]{,3})?|1(?:\\\\.0{,3})?))?\n        # Multiple accepts per header.\n        (?:\\\\s*,\\\\s*|$)\n    \"\"\"\n    , re.VERBOSE)\n\n\n@functools.lru_cache(maxsize=1000)\ndef _parse_accept_lang_header(lang_string):\n    \"\"\"\n    Parse the lang_string, which is the body of an HTTP Accept-Language\n    header, and return a tuple of (lang, q-value), ordered by 'q' values.\n    Return an empty tuple if there are any format errors in lang_string.\n    \"\"\"\n    result = []\n    pieces = accept_language_re.split(lang_string.lower())\n    if pieces[-1]:\n        return ()\n    for i in range(0, len(pieces) - 1, 3):\n        first, lang, priority = pieces[i:i + 3]\n        if first:\n            return ()\n        if priority:\n            priority = float(priority)\n        else:\n            priority = 1.0\n        result.append((lang, priority))\n    result.sort(key=lambda k: k[1], reverse=True)\n    return tuple(result)\n\n\nACCEPT_LANGUAGE_HEADER_MAX_LENGTH = 500\n\n\ndef parse_accept_lang_header(lang_string): [MASK]\n"}
{"method_name": "translation_file_changed", "full_method_name": "translation_file_changed", "method_path": "../srcdata/Network/django/django/utils/translation/reloader.py", "method_code": "from pathlib import Path\nfrom asgiref.local import Local\nfrom django.apps import apps\nfrom django.utils.autoreload import is_django_module\nfrom django.conf import settings\nimport gettext\nfrom django.utils.translation import trans_real\ndef translation_file_changed(sender, file_path, **kwargs):\n    \"\"\"Clear the internal translations cache if a .mo file is modified.\"\"\"\n    if file_path.suffix == '.mo':\n        import gettext\n        from django.utils.translation import trans_real\n        gettext._translations = {}\n        trans_real._translations = {}\n        trans_real._default = None\n        trans_real._active = Local()\n        return True", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport gettext as gettext_module\nimport os\nimport pickle\nimport re\nimport tempfile\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest import mock\nfrom asgiref.local import Local\nfrom django import forms\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.template import Context\nfrom django.template import Template\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils import translation\nfrom django.utils.formats import date_format\nfrom django.utils.formats import get_format\nfrom django.utils.formats import iter_format_modules\nfrom django.utils.formats import localize\nfrom django.utils.formats import localize_input\nfrom django.utils.formats import reset_format_cache\nfrom django.utils.formats import sanitize_separators\nfrom django.utils.formats import sanitize_strftime_format\nfrom django.utils.formats import time_format\nfrom django.utils.numberformat import format as nformat\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import activate\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import deactivate\nfrom django.utils.translation import get_language\nfrom django.utils.translation import get_language_bidi\nfrom django.utils.translation import get_language_from_request\nfrom django.utils.translation import get_language_info\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import ngettext_lazy\nfrom django.utils.translation import npgettext\nfrom django.utils.translation import npgettext_lazy\nfrom django.utils.translation import pgettext\nfrom django.utils.translation import round_away_from_one\nfrom django.utils.translation import to_language\nfrom django.utils.translation import to_locale\nfrom django.utils.translation import trans_null\nfrom django.utils.translation import trans_real\nfrom django.utils.translation.reloader import translation_file_changed\nfrom django.utils.translation.reloader import watch_for_translation_changes\nfrom django.utils.formats import _format_cache\n\nclass TranslationFileChangedTests(SimpleTestCase):\n    def test_ignores_non_mo_files(self):\n        gettext_module._translations = {'foo': 'bar'}\n        path = Path('test.py')\n        self.assertIsNone(translation_file_changed(None, path))\n        self.assertEqual(gettext_module._translations, {'foo': 'bar'})\n    \nTranslationFileChangedTests().test_ignores_non_mo_files()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/i18n/tests.py"}, {"test_code": "import datetime\nimport decimal\nimport gettext as gettext_module\nimport os\nimport pickle\nimport re\nimport tempfile\nfrom contextlib import contextmanager\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest import mock\nfrom asgiref.local import Local\nfrom django import forms\nfrom django.apps import AppConfig\nfrom django.conf import settings\nfrom django.conf.locale import LANG_INFO\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.template import Context\nfrom django.template import Template\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.utils import translation\nfrom django.utils.formats import date_format\nfrom django.utils.formats import get_format\nfrom django.utils.formats import iter_format_modules\nfrom django.utils.formats import localize\nfrom django.utils.formats import localize_input\nfrom django.utils.formats import reset_format_cache\nfrom django.utils.formats import sanitize_separators\nfrom django.utils.formats import sanitize_strftime_format\nfrom django.utils.formats import time_format\nfrom django.utils.numberformat import format as nformat\nfrom django.utils.safestring import SafeString\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import activate\nfrom django.utils.translation import check_for_language\nfrom django.utils.translation import deactivate\nfrom django.utils.translation import get_language\nfrom django.utils.translation import get_language_bidi\nfrom django.utils.translation import get_language_from_request\nfrom django.utils.translation import get_language_info\nfrom django.utils.translation import gettext\nfrom django.utils.translation import gettext_lazy\nfrom django.utils.translation import ngettext\nfrom django.utils.translation import ngettext_lazy\nfrom django.utils.translation import npgettext\nfrom django.utils.translation import npgettext_lazy\nfrom django.utils.translation import pgettext\nfrom django.utils.translation import round_away_from_one\nfrom django.utils.translation import to_language\nfrom django.utils.translation import to_locale\nfrom django.utils.translation import trans_null\nfrom django.utils.translation import trans_real\nfrom django.utils.translation.reloader import translation_file_changed\nfrom django.utils.translation.reloader import watch_for_translation_changes\nfrom django.utils.formats import _format_cache\n\nclass TranslationFileChangedTests(SimpleTestCase):\n    def test_resets_cache_with_mo_files(self):\n        gettext_module._translations = {'foo': 'bar'}\n        trans_real._translations = {'foo': 'bar'}\n        trans_real._default = 1\n        trans_real._active = False\n        path = Path('test.mo')\n        self.assertIs(translation_file_changed(None, path), True)\n        self.assertEqual(gettext_module._translations, {})\n        self.assertEqual(trans_real._translations, {})\n        self.assertIsNone(trans_real._default)\n        self.assertIsInstance(trans_real._active, Local)\n    \nTranslationFileChangedTests().test_resets_cache_with_mo_files()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/i18n/tests.py"}], "instruction": "Functionality: The function \"translation_file_changed\" is designed to clear the internal translations cache when a .mo file (used for storing translations in the gettext framework) is modified. This is crucial for ensuring that the latest translations are loaded and used by the application.\n\nInputs: The function takes two mandatory arguments and any number of keyword arguments (kwargs). The 'sender' argument is typically the process that triggered the event (not used in the function). The 'file_path' is a Path object representing the path of the .mo file that has been modified.\n\nOutputs: If the 'file_path' corresponds to a .mo file, the function will clear the internal translations cache and return True, indicating that the cache was cleared. If the 'file_path' does not correspond to a .mo file, the function will not perform any action and will implicitly return None.\n\nNote: This function uses Django's translation utilities and assumes that it is being used within a Django project. The purpose of clearing the cache is to ensure that the application uses the latest translations after a .mo file has been updated.", "method_code_mask": "from pathlib import Path\nfrom asgiref.local import Local\nfrom django.apps import apps\nfrom django.utils.autoreload import is_django_module\nfrom django.conf import settings\nimport gettext\nfrom django.utils.translation import trans_real\n\n\ndef translation_file_changed(sender, file_path, **kwargs): [MASK]\n"}
{"method_name": "_property_resolver", "full_method_name": "_property_resolver", "method_path": "../srcdata/Network/django/django/template/defaultfilters.py", "method_code": "import random as random_module\nimport re\nimport types\nfrom decimal import ROUND_HALF_UP\nfrom decimal import Context\nfrom decimal import Decimal\nfrom decimal import InvalidOperation\nfrom decimal import getcontext\nfrom functools import wraps\nfrom inspect import unwrap\nfrom operator import itemgetter\nfrom pprint import pformat\nfrom urllib.parse import quote\nfrom django.utils import formats\nfrom django.utils.dateformat import format\nfrom django.utils.dateformat import time_format\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import avoid_wrapping\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import json_script as _json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize as _urlize\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import Truncator\nfrom django.utils.text import normalize_newlines\nfrom django.utils.text import phone2numeric\nfrom django.utils.text import slugify as _slugify\nfrom django.utils.text import wrap\nfrom django.utils.timesince import timesince\nfrom django.utils.timesince import timeuntil\nfrom django.utils.translation import gettext\nfrom django.utils.translation import ngettext\ndef _property_resolver(arg):\n    \"\"\"\n    When arg is convertible to float, behave like operator.itemgetter(arg)\n    Otherwise, chain __getitem__() and getattr().\n\n    >>> _property_resolver(1)('abc')\n    'b'\n    >>> _property_resolver('1')('abc')\n    Traceback (most recent call last):\n    ...\n    TypeError: string indices must be integers\n    >>> class Foo:\n    ...     a = 42\n    ...     b = 3.14\n    ...     c = 'Hey!'\n    >>> _property_resolver('b')(Foo())\n    3.14\n    \"\"\"\n    try:\n        float(arg)\n    except ValueError:\n        if VARIABLE_ATTRIBUTE_SEPARATOR + '_' in arg or arg[0] == '_':\n            raise AttributeError('Access to private variables is forbidden.')\n        parts = arg.split(VARIABLE_ATTRIBUTE_SEPARATOR)\n\n        def resolve(value):\n            for part in parts:\n                try:\n                    value = value[part]\n                except (AttributeError, IndexError, KeyError, TypeError,\n                    ValueError):\n                    value = getattr(value, part)\n            return value\n        return resolve\n    else:\n        return itemgetter(arg)", "test_code_list": [{"test_code": "from django.template.defaultfilters import _property_resolver\nfrom django.template.defaultfilters import dictsort\nfrom django.test import SimpleTestCase\nclass User:\n    password = 'abc'\n    _private = 'private'\n\n    @property\n    def test_property(self):\n        return 'cde'\n\n    def test_method(self):\n        \"\"\"This is just a test method.\"\"\"\nclass FunctionTests(SimpleTestCase):\n    def test_property_resolver(self):\n        user = User()\n        dict_data = {'a': {'b1': {'c': 'result1'}, 'b2': user, 'b3': {'0':\n            'result2'}, 'b4': [0, 1, 2]}}\n        list_data = ['a', 'b', 'c']\n        tests = [('a.b1.c', dict_data, 'result1'), ('a.b2.password', dict_data,\n            'abc'), ('a.b2.test_property', dict_data, 'cde'), (\n            'a.b2.test_method', dict_data, user.test_method), ('a.b3.0',\n            dict_data, 'result2'), (0, list_data, 'a')]\n        for arg, data, expected_value in tests:\n            with self.subTest(arg=arg):\n                self.assertEqual(_property_resolver(arg)(data), expected_value)\n        fail_tests = [('a.b1.d', dict_data, AttributeError), ('a.b2.password.0',\n            dict_data, AttributeError), ('a.b2._private', dict_data,\n            AttributeError), ('a.b4.0', dict_data, AttributeError), ('a',\n            list_data, AttributeError), ('0', list_data, TypeError), (4,\n            list_data, IndexError)]\n        for arg, data, expected_exception in fail_tests:\n            with self.subTest(arg=arg):\n                with self.assertRaises(expected_exception):\n                    _property_resolver(arg)(data)\nFunctionTests().test_property_resolver()", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_tests/filter_tests/test_dictsort.py"}], "instruction": "Functionality: The _property_resolver function is designed to resolve properties of an object either by index or attribute access, depending on the type of the provided argument. When the argument can be converted to a float, the function behaves like operator.itemgetter(arg), meaning it will attempt to retrieve an item from the object using the argument as an index. If this conversion fails, the function will attempt to access the properties of the object by chaining __getitem__() and getattr() calls based on the parts of the argument, treating it as a path to the desired property.\nInputs: \n- arg: A string or numeric value that serves as the key or path to the desired property of an object. This can be a simple property name, an index, or a path separated by a VARIABLE_ATTRIBUTE_SEPARATOR (not explicitly defined in the provided code, but contextually it seems to be '__').\nOutputs:\n- A function that, when called with an object, will resolve the property specified by 'arg' from that object. This resolved value will be returned by the function.\nNote: Access to private variables (those starting with an underscore) is forbidden and will raise an AttributeError.", "method_code_mask": "import random as random_module\nimport re\nimport types\nfrom decimal import ROUND_HALF_UP\nfrom decimal import Context\nfrom decimal import Decimal\nfrom decimal import InvalidOperation\nfrom decimal import getcontext\nfrom functools import wraps\nfrom inspect import unwrap\nfrom operator import itemgetter\nfrom pprint import pformat\nfrom urllib.parse import quote\nfrom django.utils import formats\nfrom django.utils.dateformat import format\nfrom django.utils.dateformat import time_format\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import avoid_wrapping\nfrom django.utils.html import conditional_escape\nfrom django.utils.html import escape\nfrom django.utils.html import escapejs\nfrom django.utils.html import json_script as _json_script\nfrom django.utils.html import linebreaks\nfrom django.utils.html import strip_tags\nfrom django.utils.html import urlize as _urlize\nfrom django.utils.safestring import SafeData\nfrom django.utils.safestring import mark_safe\nfrom django.utils.text import Truncator\nfrom django.utils.text import normalize_newlines\nfrom django.utils.text import phone2numeric\nfrom django.utils.text import slugify as _slugify\nfrom django.utils.text import wrap\nfrom django.utils.timesince import timesince\nfrom django.utils.timesince import timeuntil\nfrom django.utils.translation import gettext\nfrom django.utils.translation import ngettext\n\n\ndef _property_resolver(arg): [MASK]\n"}
{"method_name": "add_domain", "full_method_name": "add_domain", "method_path": "../srcdata/Network/django/django/contrib/syndication/views.py", "method_code": "from inspect import getattr_static\nfrom inspect import unwrap\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.template import TemplateDoesNotExist\nfrom django.template import loader\nfrom django.utils import feedgenerator\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import escape\nfrom django.utils.http import http_date\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import is_naive\nfrom django.utils.timezone import make_aware\nfrom django.utils.translation import get_language\ndef add_domain(domain, url, secure=False):\n    protocol = 'https' if secure else 'http'\n    if url.startswith('//'):\n        url = '%s:%s' % (protocol, url)\n    elif not url.startswith(('http://', 'https://', 'mailto:')):\n        url = iri_to_uri('%s://%s%s' % (protocol, domain, url))\n    return url", "test_code_list": [{"test_code": "import datetime\nfrom xml.dom import minidom\nfrom django.contrib.syndication import views\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.templatetags.static import static\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import requires_tz_support\nfrom django.urls import reverse\nfrom django.urls import reverse_lazy\nfrom django.utils import timezone\nfrom django.utils.feedgenerator import Atom1Feed\nfrom django.utils.feedgenerator import Rss201rev2Feed\nfrom django.utils.feedgenerator import SyndicationFeed\nfrom django.utils.feedgenerator import rfc2822_date\nfrom django.utils.feedgenerator import rfc3339_date\nclass FeedTestCase(TestCase):\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.e1 = Entry.objects.create(title='My first entry', updated=\n            datetime.datetime(1980, 1, 1, 12, 30), published=datetime.\n            datetime(1986, 9, 25, 20, 15, 0))\n        cls.e2 = Entry.objects.create(title='My second entry', updated=\n            datetime.datetime(2008, 1, 2, 12, 30), published=datetime.\n            datetime(2006, 3, 17, 18, 0))\n        cls.e3 = Entry.objects.create(title='My third entry', updated=\n            datetime.datetime(2008, 1, 2, 13, 30), published=datetime.\n            datetime(2005, 6, 14, 10, 45))\n        cls.e4 = Entry.objects.create(title='A & B < C > D', updated=\n            datetime.datetime(2008, 1, 3, 13, 30), published=datetime.\n            datetime(2005, 11, 25, 12, 11, 23))\n        cls.e5 = Entry.objects.create(title='My last entry', updated=\n            datetime.datetime(2013, 1, 20, 0, 0), published=datetime.\n            datetime(2013, 3, 25, 20, 0))\n        cls.a1 = Article.objects.create(title='My first article', entry=cls\n            .e1, updated=datetime.datetime(1986, 11, 21, 9, 12, 18),\n            published=datetime.datetime(1986, 10, 21, 9, 12, 18))\n\n    def assertChildNodes(self, elem, expected):\n        actual = {n.nodeName for n in elem.childNodes}\n        expected = set(expected)\n        self.assertEqual(actual, expected)\n\n    def assertChildNodeContent(self, elem, expected):\n        for k, v in expected.items():\n            self.assertEqual(elem.getElementsByTagName(k)[0].firstChild.\n                wholeText, v)\n\n    def assertCategories(self, elem, expected):\n        self.assertEqual({i.firstChild.wholeText for i in elem.childNodes if\n            i.nodeName == 'category'}, set(expected))\n\nclass SyndicationFeedTest(FeedTestCase):\n    def test_add_domain(self):\n        \"\"\"\n            add_domain() prefixes domains onto the correct URLs.\n            \"\"\"\n        prefix_domain_mapping = (('example.com', '/foo/?arg=value'),\n            'http://example.com/foo/?arg=value'), (('example.com',\n            '/foo/?arg=value', True), 'https://example.com/foo/?arg=value'), ((\n            'example.com', 'http://djangoproject.com/doc/'),\n            'http://djangoproject.com/doc/'), (('example.com',\n            'https://djangoproject.com/doc/'), 'https://djangoproject.com/doc/'), (\n            ('example.com', 'mailto:uhoh@djangoproject.com'),\n            'mailto:uhoh@djangoproject.com'), (('example.com',\n            '//example.com/foo/?arg=value'), 'http://example.com/foo/?arg=value')\n        for prefix in prefix_domain_mapping:\n            with self.subTest(prefix=prefix):\n                self.assertEqual(add_domain(*prefix[0]), prefix[1])\n    \nSyndicationFeedTest().test_add_domain()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/syndication_tests/tests.py"}], "instruction": "Functionality: The function 'add_domain' is designed to prepend a domain and protocol to a URL. If the URL starts with 'http://', 'https://', or 'mailto:', or with '//' - it will be returned as is, except if it starts with '//' it will add the protocol. If the URL doesn't start with any of the mentioned prefixes, the function will prepend the provided domain and protocol to the URL.\n\nInputs: \n1. domain (str) - The domain that will be prepended to the URL if the URL does not start with 'http://', 'https://', or 'mailto:'. \n2. url (str) - The URL that might be prefixed with the domain.\n3. secure (bool) - A boolean indicating if the URL should be HTTPS ('https://') or HTTP ('http://'). The default value is False, which means the URL will be prefixed with 'http://'.\n\nOutputs: \n1. url (str) - The URL after being processed by the function. It will retain its original form if it starts with 'http://', 'https://', or 'mailto:', or will have the domain and protocol prepended to it otherwise.", "method_code_mask": "from inspect import getattr_static\nfrom inspect import unwrap\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.http import Http404\nfrom django.http import HttpResponse\nfrom django.template import TemplateDoesNotExist\nfrom django.template import loader\nfrom django.utils import feedgenerator\nfrom django.utils.encoding import iri_to_uri\nfrom django.utils.html import escape\nfrom django.utils.http import http_date\nfrom django.utils.timezone import get_default_timezone\nfrom django.utils.timezone import is_naive\nfrom django.utils.timezone import make_aware\nfrom django.utils.translation import get_language\n\n\ndef add_domain(domain, url, secure=False): [MASK]\n"}
{"method_name": "make_password", "full_method_name": "make_password", "method_path": "../srcdata/Network/django/django/contrib/auth/hashers.py", "method_code": "import base64\nimport binascii\nimport functools\nimport hashlib\nimport importlib\nimport math\nimport warnings\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import setting_changed\nfrom django.dispatch import receiver\nfrom django.utils.crypto import RANDOM_STRING_CHARS\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.crypto import pbkdf2\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext_noop as _\ndef make_password(password, salt=None, hasher='default'):\n    \"\"\"\n    Turn a plain-text password into a hash for database storage\n\n    Same as encode() but generate a new random salt. If password is None then\n    return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,\n    which disallows logins. Additional random string reduces chances of gaining\n    access to staff or superuser accounts. See ticket #20079 for more info.\n    \"\"\"\n    if password is None:\n        return UNUSABLE_PASSWORD_PREFIX + get_random_string(\n            UNUSABLE_PASSWORD_SUFFIX_LENGTH)\n    if not isinstance(password, (bytes, str)):\n        raise TypeError('Password must be a string or bytes, got %s.' %\n            type(password).__qualname__)\n    hasher = get_hasher(hasher)\n    salt = salt or hasher.salt()\n    return hasher.encode(password, salt)", "test_code_list": [{"test_code": "from unittest import mock\nfrom unittest import skipUnless\nfrom django.conf.global_settings import PASSWORD_HASHERS\nfrom django.contrib.auth.hashers import UNUSABLE_PASSWORD_PREFIX\nfrom django.contrib.auth.hashers import UNUSABLE_PASSWORD_SUFFIX_LENGTH\nfrom django.contrib.auth.hashers import BasePasswordHasher\nfrom django.contrib.auth.hashers import BCryptPasswordHasher\nfrom django.contrib.auth.hashers import BCryptSHA256PasswordHasher\nfrom django.contrib.auth.hashers import MD5PasswordHasher\nfrom django.contrib.auth.hashers import PBKDF2PasswordHasher\nfrom django.contrib.auth.hashers import PBKDF2SHA1PasswordHasher\nfrom django.contrib.auth.hashers import ScryptPasswordHasher\nfrom django.contrib.auth.hashers import check_password\nfrom django.contrib.auth.hashers import get_hasher\nfrom django.contrib.auth.hashers import identify_hasher\nfrom django.contrib.auth.hashers import is_password_usable\nfrom django.contrib.auth.hashers import make_password\nfrom django.test import SimpleTestCase\nfrom django.test.utils import override_settings\nimport bcrypt\nimport hashlib\n\nclass TestUtilsHashPass(SimpleTestCase):\n    def test_invalid_password(self):\n        msg = 'Password must be a string or bytes, got int.'\n        with self.assertRaisesMessage(TypeError, msg):\n            make_password(1)\n    \nTestUtilsHashPass().test_invalid_password()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/auth_tests/test_hashers.py"}], "instruction": "Functionality: The make_password function is designed to securely hash a plain-text password for storage in a database. It can also generate a random salt if none is provided. If the input password is None, the function generates a string that disallows logins, ensuring the security of staff or superuser accounts.\n\nInputs: \n1. password: A string or bytes object representing the plain-text password to be hashed. If None, the function generates an unusable password.\n2. salt: An optional string or bytes object used as salt for the hashing process. If not provided, a random salt is generated.\n3. hasher: A string indicating the hashing algorithm to be used. The default is 'default', which uses the system's default hashing algorithm.\n\nOutputs:\n1. A string representing the hashed password, encoded with the provided salt and using the specified hashing algorithm. If the password input is None, the function returns a string that prevents login attempts.", "method_code_mask": "import base64\nimport binascii\nimport functools\nimport hashlib\nimport importlib\nimport math\nimport warnings\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import setting_changed\nfrom django.dispatch import receiver\nfrom django.utils.crypto import RANDOM_STRING_CHARS\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import get_random_string\nfrom django.utils.crypto import pbkdf2\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext_noop as _\n\n\ndef make_password(password, salt=None, hasher='default'): [MASK]\n"}
{"method_name": "get_password_validators", "full_method_name": "get_password_validators", "method_path": "../srcdata/Network/django/django/contrib/auth/password_validation.py", "method_code": "import functools\nimport gzip\nimport re\nfrom difflib import SequenceMatcher\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import lazy\nfrom django.utils.html import format_html\nfrom django.utils.html import format_html_join\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import ngettext\ndef get_password_validators(validator_config):\n    validators = []\n    for validator in validator_config:\n        try:\n            klass = import_string(validator['NAME'])\n        except ImportError:\n            msg = (\n                'The module in NAME could not be imported: %s. Check your AUTH_PASSWORD_VALIDATORS setting.'\n                )\n            raise ImproperlyConfigured(msg % validator['NAME'])\n        validators.append(klass(**validator.get('OPTIONS', {})))\n    return validators", "test_code_list": [{"test_code": "import os\nfrom django.contrib.auth import validators\nfrom django.contrib.auth.password_validation import CommonPasswordValidator\nfrom django.contrib.auth.password_validation import MinimumLengthValidator\nfrom django.contrib.auth.password_validation import NumericPasswordValidator\nfrom django.contrib.auth.password_validation import UserAttributeSimilarityValidator\nfrom django.contrib.auth.password_validation import get_default_password_validators\nfrom django.contrib.auth.password_validation import get_password_validators\nfrom django.contrib.auth.password_validation import password_changed\nfrom django.contrib.auth.password_validation import password_validators_help_text_html\nfrom django.contrib.auth.password_validation import password_validators_help_texts\nfrom django.contrib.auth.password_validation import validate_password\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import isolate_apps\nfrom django.utils.html import conditional_escape\n\nclass PasswordValidationTest(SimpleTestCase):\n    def test_get_password_validators_custom(self):\n        validator_config = [{'NAME':\n            'django.contrib.auth.password_validation.CommonPasswordValidator'}]\n        validators = get_password_validators(validator_config)\n        self.assertEqual(len(validators), 1)\n        self.assertEqual(validators[0].__class__.__name__,\n            'CommonPasswordValidator')\n        self.assertEqual(get_password_validators([]), [])\n    \nPasswordValidationTest().test_get_password_validators_custom()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/auth_tests/test_validators.py"}], "instruction": "Functionality: This function is designed to instantiate and return a list of password validator objects based on the provided configuration. Each validator is expected to conform to a specific set of rules defined in the 'NAME' key of each dictionary within the validator_config list. These validators are typically used within Django's password validation mechanism to ensure that user passwords meet certain criteria.\n\nInputs:\n- validator_config: A list of dictionaries, where each dictionary contains at least a 'NAME' key that represents the path to the validator class in a string format. These dictionaries may also contain an 'OPTIONS' key, which is a dictionary of options to be passed to the validator's constructor.\n\nOutputs:\n- A list of instantiated validator objects. Each object in the list corresponds to one of the configurations provided in the validator_config list. These validator objects can then be used to validate passwords according to the rules defined in their respective classes.", "method_code_mask": "import functools\nimport gzip\nimport re\nfrom difflib import SequenceMatcher\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import lazy\nfrom django.utils.html import format_html\nfrom django.utils.html import format_html_join\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import ngettext\n\n\ndef get_password_validators(validator_config): [MASK]\n"}
{"method_name": "password_changed", "full_method_name": "password_changed", "method_path": "../srcdata/Network/django/django/contrib/auth/password_validation.py", "method_code": "import functools\nimport gzip\nimport re\nfrom difflib import SequenceMatcher\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import lazy\nfrom django.utils.html import format_html\nfrom django.utils.html import format_html_join\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import ngettext\ndef password_changed(password, user=None, password_validators=None):\n    \"\"\"\n    Inform all validators that have implemented a password_changed() method\n    that the password has been changed.\n    \"\"\"\n    if password_validators is None:\n        password_validators = get_default_password_validators()\n    for validator in password_validators:\n        password_changed = getattr(validator, 'password_changed', lambda *a:\n            None)\n        password_changed(password, user)", "test_code_list": [{"test_code": "import os\nfrom django.contrib.auth import validators\nfrom django.contrib.auth.password_validation import CommonPasswordValidator\nfrom django.contrib.auth.password_validation import MinimumLengthValidator\nfrom django.contrib.auth.password_validation import NumericPasswordValidator\nfrom django.contrib.auth.password_validation import UserAttributeSimilarityValidator\nfrom django.contrib.auth.password_validation import get_default_password_validators\nfrom django.contrib.auth.password_validation import get_password_validators\nfrom django.contrib.auth.password_validation import password_changed\nfrom django.contrib.auth.password_validation import password_validators_help_text_html\nfrom django.contrib.auth.password_validation import password_validators_help_texts\nfrom django.contrib.auth.password_validation import validate_password\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import isolate_apps\nfrom django.utils.html import conditional_escape\n\nclass PasswordValidationTest(SimpleTestCase):\n    def test_password_changed_with_custom_validator(self):\n    \n    \n        class Validator:\n    \n            def password_changed(self, password, user):\n                self.password = password\n                self.user = user\n        user = object()\n        validator = Validator()\n        password_changed('password', user=user, password_validators=(validator,))\n        self.assertIs(validator.user, user)\n        self.assertEqual(validator.password, 'password')\n    \nPasswordValidationTest().test_password_changed_with_custom_validator()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/auth_tests/test_validators.py"}], "instruction": "Functionality: This function is designed to notify all password validators, which have implemented a 'password_changed()' method, that a password has been changed. It iterates over a list of password validators and calls the 'password_changed()' method on each, passing the new password and the user object as arguments.\n\nInputs: \n- password (str): The new password that has been changed.\n- user (object, optional): The user object for whom the password has been changed. Default is None.\n- password_validators (list, optional): A list of password validator objects. If not provided, it defaults to 'get_default_password_validators()' which retrieves the default validators configured in the settings.\n\nOutputs:\n- None: This function does not return any value. It only triggers the 'password_changed()' method on each password validator.", "method_code_mask": "import functools\nimport gzip\nimport re\nfrom difflib import SequenceMatcher\nfrom pathlib import Path\nfrom django.conf import settings\nfrom django.core.exceptions import FieldDoesNotExist\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ValidationError\nfrom django.utils.functional import cached_property\nfrom django.utils.functional import lazy\nfrom django.utils.html import format_html\nfrom django.utils.html import format_html_join\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext as _\nfrom django.utils.translation import ngettext\n\n\ndef password_changed(password, user=None, password_validators=None): [MASK]\n"}
{"method_name": "permission_required", "full_method_name": "permission_required", "method_path": "../srcdata/Network/django/django/contrib/auth/decorators.py", "method_code": "import asyncio\nfrom functools import wraps\nfrom urllib.parse import urlsplit\nfrom asgiref.sync import async_to_sync\nfrom asgiref.sync import sync_to_async\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.core.exceptions import PermissionDenied\nfrom django.shortcuts import resolve_url\ndef permission_required(perm, login_url=None, raise_exception=False):\n    \"\"\"\n    Decorator for views that checks whether a user has a particular permission\n    enabled, redirecting to the log-in page if necessary.\n    If the raise_exception parameter is given the PermissionDenied exception\n    is raised.\n    \"\"\"\n    if isinstance(perm, str):\n        perms = perm,\n    else:\n        perms = perm\n\n    def decorator(view_func):\n        if asyncio.iscoroutinefunction(view_func):\n\n            async def check_perms(user):\n                if await sync_to_async(user.has_perms)(perms):\n                    return True\n                if raise_exception:\n                    raise PermissionDenied\n                return False\n        else:\n\n            def check_perms(user):\n                if user.has_perms(perms):\n                    return True\n                if raise_exception:\n                    raise PermissionDenied\n                return False\n        return user_passes_test(check_perms, login_url=login_url)(view_func)\n    return decorator", "test_code_list": [{"test_code": "from asyncio import iscoroutinefunction\nfrom asgiref.sync import sync_to_async\nfrom django.conf import settings\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.core.exceptions import PermissionDenied\nfrom django.http import HttpResponse\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.client import RequestFactory\n\nclass PermissionsRequiredDecoratorTest(TestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = permission_required([])(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nPermissionsRequiredDecoratorTest().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/auth_tests/test_decorators.py"}], "instruction": "Functionality: The permission_required function is a decorator for views in a Django application. Its purpose is to ensure that a user has the required permissions to access a specific view. If the user does not have the necessary permissions, the function either redirects the user to a login page or raises a PermissionDenied exception, depending on the value of the raise_exception parameter. This decorator supports both synchronous and asynchronous views.\n\nInputs: \n- perm: A string or tuple of strings representing the permission(s) required to access the view. Each permission should be in the format \"app_label.codename\".\n- login_url: An optional string representing the URL to which the user should be redirected if they do not have the required permissions. If not provided, Django's default LOGIN_URL setting is used.\n- raise_exception: A boolean indicating whether to raise a PermissionDenied exception if the user lacks the necessary permissions. If set to False, the user is redirected to the login page instead.\n\nOutputs:\n- The permission_required function itself returns a decorator that modifies the behavior of a view function. When applied to a view, it either allows the view to proceed or handles the lack of permissions by redirecting or raising an exception, depending on the provided parameters.", "method_code_mask": "import asyncio\nfrom functools import wraps\nfrom urllib.parse import urlsplit\nfrom asgiref.sync import async_to_sync\nfrom asgiref.sync import sync_to_async\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.core.exceptions import PermissionDenied\nfrom django.shortcuts import resolve_url\n\n\ndef permission_required(perm, login_url=None, raise_exception=False): [MASK]\n"}
{"method_name": "vary_on_headers", "full_method_name": "vary_on_headers", "method_path": "../srcdata/Network/django/django/views/decorators/vary.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.utils.cache import patch_vary_headers\ndef vary_on_headers(*headers):\n    \"\"\"\n    A view decorator that adds the specified headers to the Vary header of the\n    response. Usage:\n\n       @vary_on_headers('Cookie', 'Accept-language')\n       def index(request):\n           ...\n\n    Note that the header names are not case-sensitive.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            async def _view_wrapper(request, *args, **kwargs):\n                response = await func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n        else:\n\n            def _view_wrapper(request, *args, **kwargs):\n                response = func(request, *args, **kwargs)\n                patch_vary_headers(response, headers)\n                return response\n        return wraps(func)(_view_wrapper)\n    return decorator", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass VaryOnHeadersTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = vary_on_headers()(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nVaryOnHeadersTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_vary.py"}], "instruction": "Functionality: The vary_on_headers function is a decorator designed to modify the 'Vary' header of HTTP responses in Django applications. It adds specified headers to the 'Vary' header, enabling the response to vary based on the request's characteristics. This function is useful for caching mechanisms, as it informs intermediate caches about the headers that influence the response content.\n\nInputs: \n- *headers: A variable-length argument list consisting of header names that should be included in the 'Vary' header of the response. The names are case-insensitive.\n\nOutputs: \n- The vary_on_headers function returns a decorator, which in turn wraps around the original view function (func). The decorator modifies the behavior of func by adding headers to the 'Vary' header of the response generated by func. The decorator is designed to work with both synchronous and asynchronous view functions.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.utils.cache import patch_vary_headers\n\n\ndef vary_on_headers(*headers): [MASK]\n"}
{"method_name": "cache_control", "full_method_name": "cache_control", "method_path": "../srcdata/Network/django/django/views/decorators/cache.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\ndef cache_control(**kwargs):\n\n    def _cache_controller(viewfunc):\n        if iscoroutinefunction(viewfunc):\n\n            async def _view_wrapper(request, *args, **kw):\n                _check_request(request, 'cache_control')\n                response = await viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n        else:\n\n            def _view_wrapper(request, *args, **kw):\n                _check_request(request, 'cache_control')\n                response = viewfunc(request, *args, **kw)\n                patch_cache_control(response, **kwargs)\n                return response\n        return wraps(viewfunc)(_view_wrapper)\n    return _cache_controller", "test_code_list": [{"test_code": "from unittest import mock\nfrom asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\n\nclass CacheControlDecoratorTest(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = cache_control()(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nCacheControlDecoratorTest().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_cache.py"}], "instruction": "Functionality: The cache_control function is a decorator for view functions in Django that modifies HTTP cache control headers in the response. It allows for fine-grained control over caching behavior for different views by setting various cache-control directives.\n\nInputs: \n- **kwargs**: Variable-length keyword arguments representing cache control directives. Common directives include 'max_age', 's_maxage', 'no_cache', 'no_store', 'must_revalidate', 'proxy_revalidate', 'public', 'private', 'no_transform', 'only_if_cached', etc. These directives are used to configure the cache behavior of the response.\n\nOutputs: \n- The function returns a decorator (_cache_controller) that wraps the original view function (viewfunc). When the wrapped view function is called, the decorator modifies the cache-control headers of the HTTP response before returning the response. The wrapper function (_view_wrapper) handles both synchronous and asynchronous view functions, ensuring that the cache directives are applied correctly to the response before it is sent to the client.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\n\n\ndef cache_control(**kwargs): [MASK]\n"}
{"method_name": "method_decorator", "full_method_name": "method_decorator", "method_path": "../srcdata/Network/django/django/utils/decorators.py", "method_code": "from functools import partial\nfrom functools import update_wrapper\nfrom functools import wraps\nfrom asgiref.sync import iscoroutinefunction\ndef method_decorator(decorator, name=''):\n    \"\"\"\n    Convert a function decorator into a method decorator\n    \"\"\"\n\n    def _dec(obj):\n        if not isinstance(obj, type):\n            return _multi_decorate(decorator, obj)\n        if not (name and hasattr(obj, name)):\n            raise ValueError(\n                \"The keyword argument `name` must be the name of a method of the decorated class: %s. Got '%s' instead.\"\n                 % (obj, name))\n        method = getattr(obj, name)\n        if not callable(method):\n            raise TypeError(\n                \"Cannot decorate '%s' as it isn't a callable attribute of %s (%s).\"\n                 % (name, obj, method))\n        _wrapper = _multi_decorate(decorator, method)\n        setattr(obj, name, _wrapper)\n        return obj\n    if not hasattr(decorator, '__iter__'):\n        update_wrapper(_dec, decorator)\n    obj = decorator if hasattr(decorator, '__name__') else decorator.__class__\n    _dec.__name__ = 'method_decorator(%s)' % obj.__name__\n    return _dec", "test_code_list": [{"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_new_attribute(self):\n        \"\"\"A decorator that sets a new attribute on the method.\"\"\"\n    \n        def decorate(func):\n            func.x = 1\n            return func\n    \n    \n        class MyClass:\n    \n            @method_decorator(decorate)\n            def method(self):\n                return True\n        obj = MyClass()\n        self.assertEqual(obj.method.x, 1)\n        self.assertIs(obj.method(), True)\n    \nMethodDecoratorTests().test_new_attribute()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\ndef myattr2_dec(func):\n\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    wrapper.myattr2 = True\n    return wrapper\nmyattr2_dec_m = method_decorator(myattr2_dec)\ndef myattr_dec(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    wrapper.myattr = True\n    return wrapper\nmyattr_dec_m = method_decorator(myattr_dec)\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_bad_iterable(self):\n        decorators = {myattr_dec_m, myattr2_dec_m}\n        msg = \"'set' object is not subscriptable\"\n        with self.assertRaisesMessage(TypeError, msg):\n            @method_decorator(decorators, 'method')\n            class TestIterable:\n                def method(self):\n                    \"\"\"A method\"\"\"\n                    pass\nMethodDecoratorTests().test_bad_iterable()", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\nclass ClsDec:\n\n    def __init__(self, myattr):\n        self.myattr = myattr\n\n    def __call__(self, f):\n\n        def wrapper():\n            return f() and self.myattr\n        return update_wrapper(wrapper, f)\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_argumented(self):\n        class Test:\n            @method_decorator(ClsDec(False))\n            def method(self):\n                return True\n        self.assertIs(Test().method(), False)\nMethodDecoratorTests().test_argumented()", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_descriptors(self):\n    \n        def original_dec(wrapped):\n    \n            def _wrapped(arg):\n                return wrapped(arg)\n            return _wrapped\n        method_dec = method_decorator(original_dec)\n    \n    \n        class bound_wrapper:\n    \n            def __init__(self, wrapped):\n                self.wrapped = wrapped\n                self.__name__ = wrapped.__name__\n    \n            def __call__(self, arg):\n                return self.wrapped(arg)\n    \n            def __get__(self, instance, cls=None):\n                return self\n    \n    \n        class descriptor_wrapper:\n    \n            def __init__(self, wrapped):\n                self.wrapped = wrapped\n                self.__name__ = wrapped.__name__\n    \n            def __get__(self, instance, cls=None):\n                return bound_wrapper(self.wrapped.__get__(instance, cls))\n    \n    \n        class Test:\n    \n            @method_dec\n            @descriptor_wrapper\n            def method(self, arg):\n                return arg\n        self.assertEqual(Test().method(1), 1)\n    \nMethodDecoratorTests().test_descriptors()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_class_decoration(self):\n        \"\"\"\n            @method_decorator can be used to decorate a class and its methods.\n            \"\"\"\n    \n        def deco(func):\n    \n            def _wrapper(*args, **kwargs):\n                return True\n            return _wrapper\n    \n    \n        @method_decorator(deco, name='method')\n        class Test:\n    \n            def method(self):\n                return False\n        self.assertTrue(Test().method())\n    \nMethodDecoratorTests().test_class_decoration()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_tuple_of_decorators(self):\n        \"\"\"\n            @method_decorator can accept a tuple of decorators.\n            \"\"\"\n    \n        def add_question_mark(func):\n    \n            def _wrapper(*args, **kwargs):\n                return func(*args, **kwargs) + '?'\n            return _wrapper\n    \n        def add_exclamation_mark(func):\n    \n            def _wrapper(*args, **kwargs):\n                return func(*args, **kwargs) + '!'\n            return _wrapper\n        decorators = add_exclamation_mark, add_question_mark\n    \n    \n        @method_decorator(decorators, name='method')\n        class TestFirst:\n    \n            def method(self):\n                return 'hello world'\n    \n    \n        class TestSecond:\n    \n            @method_decorator(decorators)\n            def method(self):\n                return 'hello world'\n        self.assertEqual(TestFirst().method(), 'hello world?!')\n        self.assertEqual(TestSecond().method(), 'hello world?!')\n    \nMethodDecoratorTests().test_tuple_of_decorators()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_invalid_non_callable_attribute_decoration(self):\n        \"\"\"\n            @method_decorator on a non-callable attribute raises an error.\n            \"\"\"\n        msg = (\n            \"Cannot decorate 'prop' as it isn't a callable attribute of <class 'Test'> (1)\"\n            )\n        with self.assertRaisesMessage(TypeError, msg):\n    \n    \n            @method_decorator(lambda : None, name='prop')\n            class Test:\n                prop = 1\n    \n                @classmethod\n                def __module__(cls):\n                    return 'tests'\n    \nMethodDecoratorTests().test_invalid_non_callable_attribute_decoration()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}, {"test_code": "from functools import update_wrapper\nfrom functools import wraps\nfrom unittest import TestCase\nfrom django.contrib.admin.views.decorators import staff_member_required\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.decorators import permission_required\nfrom django.contrib.auth.decorators import user_passes_test\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import keep_lazy\nfrom django.utils.functional import keep_lazy_text\nfrom django.utils.functional import lazy\nfrom django.utils.safestring import mark_safe\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import require_GET\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_POST\nfrom django.views.decorators.http import require_safe\nfrom django.views.decorators.vary import vary_on_cookie\nfrom django.views.decorators.vary import vary_on_headers\n\nclass MethodDecoratorTests(SimpleTestCase):\n    def test_invalid_method_name_to_decorate(self):\n        \"\"\"\n            @method_decorator on a nonexistent method raises an error.\n            \"\"\"\n        msg = (\n            \"The keyword argument `name` must be the name of a method of the decorated class: <class 'Test'>. Got 'nonexistent_method' instead\"\n            )\n        with self.assertRaisesMessage(ValueError, msg):\n    \n    \n            @method_decorator(lambda : None, name='nonexistent_method')\n            class Test:\n    \n                @classmethod\n                def __module__(cls):\n                    return 'tests'\n    \nMethodDecoratorTests().test_invalid_method_name_to_decorate()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/tests.py"}], "instruction": "Functionality: The method_decorator function is designed to convert a function decorator into a method decorator. It allows decorators, which are typically used for functions, to be applied to methods of classes in Python.\n\nInputs: \n1. decorator: The input decorator is a function that is used to modify the behavior of another function or method. It can be a simple function or a class.\n2. name (optional): This argument is a string specifying the name of the method to be decorated. If provided, the decorator will be applied to that specific method of the class being decorated.\n\nOutputs:\nThis function does not return a value in the conventional sense. Instead, it modifies the class in place by decorating the specified method (identified by 'name') with the provided decorator function. The output is reflected in the modified behavior of the method within the class.", "method_code_mask": "from functools import partial\nfrom functools import update_wrapper\nfrom functools import wraps\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef method_decorator(decorator, name=''): [MASK]\n"}
{"method_name": "never_cache", "full_method_name": "never_cache", "method_path": "../srcdata/Network/django/django/views/decorators/cache.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\ndef never_cache(view_func):\n    \"\"\"\n    Decorator that adds headers to a response so that it will never be cached.\n    \"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, 'never_cache')\n            response = await view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            _check_request(request, 'never_cache')\n            response = view_func(request, *args, **kwargs)\n            add_never_cache_headers(response)\n            return response\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from unittest import mock\nfrom asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom django.views.decorators.cache import never_cache\n\nclass NeverCacheDecoratorTest(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = never_cache(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nNeverCacheDecoratorTest().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_cache.py"}], "instruction": "Functionality: The never_cache function is a decorator designed to ensure that the HTTP response from a view function is never cached. This is accomplished by adding specific headers to the response that indicate to any caching mechanisms that the response should not be cached under any circumstances. This decorator is particularly useful for dynamic content that must always be served fresh from the origin server, without relying on potentially outdated cached copies.\n\nInputs: The never_cache function takes a single argument, which is the view_func. The view_func is the function to which the decorator is being applied. This function is expected to be a view function in a Django application, which would normally return an HTTP response.\n\nOutputs: The output of the never_cache function is a wrapped version of the view_func. When this wrapped function is called, it will execute the original view_func and then modify the resulting HTTP response by adding 'never-cache' headers to it. The modified response is then returned to the caller. The decorator ensures that the modified response will not be cached by any caching mechanisms, including those at the web browser, proxy servers, or any level of the network infrastructure.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.middleware.cache import CacheMiddleware\nfrom django.utils.cache import add_never_cache_headers\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.decorators import decorator_from_middleware_with_args\n\n\ndef never_cache(view_func): [MASK]\n"}
{"method_name": "no_append_slash", "full_method_name": "no_append_slash", "method_path": "../srcdata/Network/django/django/views/decorators/common.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\ndef no_append_slash(view_func):\n    \"\"\"\n    Mark a view function as excluded from CommonMiddleware's APPEND_SLASH\n    redirection.\n    \"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(request, *args, **kwargs):\n            return await view_func(request, *args, **kwargs)\n    else:\n\n        def _view_wrapper(request, *args, **kwargs):\n            return view_func(request, *args, **kwargs)\n    _view_wrapper.should_append_slash = False\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.common import no_append_slash\n\nclass NoAppendSlashTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = no_append_slash(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nNoAppendSlashTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_common.py"}], "instruction": "Functionality: The no_append_slash function is a decorator designed to mark view functions in a web framework, indicating that they should not be subject to the CommonMiddleware's APPEND_SLASH redirection feature. When this decorator is applied to a view function, any requests made to that view will not be redirected by appending a trailing slash, even if the framework's settings suggest it should.\n\nInputs: This function does not take any arguments when called. Instead, it is used as a decorator by placing it directly above the definition of the view function it is meant to affect. The target view function (view_func) is the implicit input, which can be either a synchronous or an asynchronous function.\n\nOutputs: The no_append_slash function returns a wrapped version of the original view function. This wrapped function has an added attribute, should_append_slash, set to False, which tells the CommonMiddleware not to perform APPEND_SLASH redirection for this view. The wrapped function preserves the original view function's name, docstring, and annotations by using the functools.wraps decorator, ensuring that the modified function behaves identically to the original one, except for the exclusion from the APPEND_SLASH behavior.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef no_append_slash(view_func): [MASK]\n"}
{"method_name": "require_http_methods", "full_method_name": "require_http_methods", "method_path": "../srcdata/Network/django/django/views/decorators/http.py", "method_code": "import datetime\nfrom functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.http import HttpResponseNotAllowed\nfrom django.middleware.http import ConditionalGetMiddleware\nfrom django.utils import timezone\nfrom django.utils.cache import get_conditional_response\nfrom django.utils.decorators import decorator_from_middleware\nfrom django.utils.http import http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.log import log_response\ndef require_http_methods(request_method_list):\n    \"\"\"\n    Decorator to make a view only accept particular request methods.  Usage::\n\n        @require_http_methods([\"GET\", \"POST\"])\n        def my_view(request):\n            # I can assume now that only GET or POST requests make it this far\n            # ...\n\n    Note that request methods should be in uppercase.\n    \"\"\"\n\n    def decorator(func):\n        if iscoroutinefunction(func):\n\n            @wraps(func)\n            async def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response('Method Not Allowed (%s): %s', request.\n                        method, request.path, response=response, request=\n                        request)\n                    return response\n                return await func(request, *args, **kwargs)\n        else:\n\n            @wraps(func)\n            def inner(request, *args, **kwargs):\n                if request.method not in request_method_list:\n                    response = HttpResponseNotAllowed(request_method_list)\n                    log_response('Method Not Allowed (%s): %s', request.\n                        method, request.path, response=response, request=\n                        request)\n                    return response\n                return func(request, *args, **kwargs)\n        return inner\n    return decorator", "test_code_list": [{"test_code": "import datetime\nfrom asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.http import condition\nfrom django.views.decorators.http import conditional_page\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.http import require_safe\n\nclass RequireHttpMethodsTest(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = require_http_methods(['GET'])(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nRequireHttpMethodsTest().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_http.py"}], "instruction": "Functionality: The require_http_methods function is a decorator designed to restrict a view function to only accept specific HTTP request methods. It checks if the incoming request's method is in the provided list of allowed methods. If the method is not allowed, it returns an HttpResponseNotAllowed response with the list of allowed methods. If the method is allowed, it passes the request to the wrapped view function.\n\nInputs: \n    request_method_list: A list of strings representing the allowed HTTP methods (e.g., [\"GET\", \"POST\"]). The methods should be uppercase.\n\nOutputs:\n    decorator: A decorator function that can be applied to a view function. This decorator will enforce the restriction of HTTP methods for the view. If the incoming request method is not in the request_method_list, it returns an HttpResponseNotAllowed immediately. Otherwise, it calls the wrapped view function with the request.", "method_code_mask": "import datetime\nfrom functools import wraps\nfrom asgiref.sync import iscoroutinefunction\nfrom django.http import HttpResponseNotAllowed\nfrom django.middleware.http import ConditionalGetMiddleware\nfrom django.utils import timezone\nfrom django.utils.cache import get_conditional_response\nfrom django.utils.decorators import decorator_from_middleware\nfrom django.utils.http import http_date\nfrom django.utils.http import quote_etag\nfrom django.utils.log import log_response\n\n\ndef require_http_methods(request_method_list): [MASK]\n"}
{"method_name": "xframe_options_deny", "full_method_name": "xframe_options_deny", "method_path": "../srcdata/Network/django/django/views/decorators/clickjacking.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\ndef xframe_options_deny(view_func):\n    \"\"\"\n    Modify a view function so its response has the X-Frame-Options HTTP\n    header set to 'DENY' as long as the response doesn't already have that\n    header set. Usage:\n\n    @xframe_options_deny\n    def some_view(request):\n        ...\n    \"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            if response.get('X-Frame-Options') is None:\n                response['X-Frame-Options'] = 'DENY'\n            return response\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            if response.get('X-Frame-Options') is None:\n                response['X-Frame-Options'] = 'DENY'\n            return response\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.middleware.clickjacking import XFrameOptionsMiddleware\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.clickjacking import xframe_options_deny\nfrom django.views.decorators.clickjacking import xframe_options_exempt\nfrom django.views.decorators.clickjacking import xframe_options_sameorigin\n\nclass XFrameOptionsDenyTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = xframe_options_deny(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nXFrameOptionsDenyTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_clickjacking.py"}], "instruction": "Functionality: The xframe_options_deny function is a decorator for modifying view functions to ensure that the HTTP response contains the X-Frame-Options header set to 'DENY'. This is intended to prevent the response from being loaded within an iframe on another site, a measure against clickjacking attacks. The decorator checks if the response already contains the X-Frame-Options header before setting it to 'DENY'.\n\nInputs: The decorator takes no explicit input arguments. However, it is applied to view functions, which typically take at least one argument (request) and may take additional arguments based on the application's needs.\n\nOutputs: The decorator returns a wrapped view function (_view_wrapper) that, when called, checks if the 'X-Frame-Options' header is already present in the response. If not, it adds the header with the value 'DENY' and returns the response. The decorator ensures that the wrapped function maintains the original function's name and docstring.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef xframe_options_deny(view_func): [MASK]\n"}
{"method_name": "xframe_options_sameorigin", "full_method_name": "xframe_options_sameorigin", "method_path": "../srcdata/Network/django/django/views/decorators/clickjacking.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\ndef xframe_options_sameorigin(view_func):\n    \"\"\"\n    Modify a view function so its response has the X-Frame-Options HTTP\n    header set to 'SAMEORIGIN' as long as the response doesn't already have\n    that header set. Usage:\n\n    @xframe_options_sameorigin\n    def some_view(request):\n        ...\n    \"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            if response.get('X-Frame-Options') is None:\n                response['X-Frame-Options'] = 'SAMEORIGIN'\n            return response\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            if response.get('X-Frame-Options') is None:\n                response['X-Frame-Options'] = 'SAMEORIGIN'\n            return response\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.middleware.clickjacking import XFrameOptionsMiddleware\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.clickjacking import xframe_options_deny\nfrom django.views.decorators.clickjacking import xframe_options_exempt\nfrom django.views.decorators.clickjacking import xframe_options_sameorigin\n\nclass XFrameOptionsSameoriginTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = xframe_options_sameorigin(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nXFrameOptionsSameoriginTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_clickjacking.py"}], "instruction": "Functionality: The xframe_options_sameorigin function is a decorator that modifies a view function in a web application. It ensures that the HTTP response includes the X-Frame-Options header set to 'SAMEORIGIN'. This header is used to indicate whether or not a browser should be allowed to render a page in a frame or iframe. The decorator only sets the header if it has not already been set in the response.\n\nInputs: The function takes a single argument, which is the view function (view_func) that it will wrap. This view function is typically a function in a web application framework that generates a response to a request.\n\nOutputs: The function returns a wrapped version of the view function. The wrapped function will add the 'X-Frame-Options' header with the value 'SAMEORIGIN' to the response if the header is not already present. The wrapped function maintains the original functionality of the view function and passes all other parameters to the view function as expected.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef xframe_options_sameorigin(view_func): [MASK]\n"}
{"method_name": "xframe_options_exempt", "full_method_name": "xframe_options_exempt", "method_path": "../srcdata/Network/django/django/views/decorators/clickjacking.py", "method_code": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\ndef xframe_options_exempt(view_func):\n    \"\"\"\n    Modify a view function by setting a response variable that instructs\n    XFrameOptionsMiddleware to NOT set the X-Frame-Options HTTP header. Usage:\n\n    @xframe_options_exempt\n    def some_view(request):\n        ...\n    \"\"\"\n    if iscoroutinefunction(view_func):\n\n        async def _view_wrapper(*args, **kwargs):\n            response = await view_func(*args, **kwargs)\n            response.xframe_options_exempt = True\n            return response\n    else:\n\n        def _view_wrapper(*args, **kwargs):\n            response = view_func(*args, **kwargs)\n            response.xframe_options_exempt = True\n            return response\n    return wraps(view_func)(_view_wrapper)", "test_code_list": [{"test_code": "from asgiref.sync import iscoroutinefunction\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.middleware.clickjacking import XFrameOptionsMiddleware\nfrom django.test import SimpleTestCase\nfrom django.views.decorators.clickjacking import xframe_options_deny\nfrom django.views.decorators.clickjacking import xframe_options_exempt\nfrom django.views.decorators.clickjacking import xframe_options_sameorigin\n\nclass XFrameOptionsExemptTests(SimpleTestCase):\n    def test_wrapped_sync_function_is_not_coroutine_function(self):\n    \n        def sync_view(request):\n            return HttpResponse()\n        wrapped_view = xframe_options_exempt(sync_view)\n        self.assertIs(iscoroutinefunction(wrapped_view), False)\n    \nXFrameOptionsExemptTests().test_wrapped_sync_function_is_not_coroutine_function()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/decorators/test_clickjacking.py"}], "instruction": "Functionality: The xframe_options_exempt function is a decorator designed to modify a view function in a way that instructs the XFrameOptionsMiddleware to NOT set the X-Frame-Options HTTP header. This is useful for allowing pages to be displayed within a frame or iframe, bypassing the default X-Frame-Options that might prevent framing.\n\nInputs: This function takes a single input argument: 'view_func', which represents the view function that you want to modify. 'view_func' is a callable function or method that typically accepts request objects and returns a response.\n\nOutputs: The function returns a wrapped function ('_view_wrapper') that, when called, executes the 'view_func', marks the response with an 'xframe_options_exempt' attribute set to True, and then returns the response. If the 'view_func' is an asynchronous function, an asynchronous wrapper is returned; if it is a synchronous function, a synchronous wrapper is returned. In both cases, the 'xframe_options_exempt' attribute signals that the X-Frame-Options middleware should not set the X-Frame-Options header for this particular response.", "method_code_mask": "from functools import wraps\nfrom asgiref.sync import iscoroutinefunction\n\n\ndef xframe_options_exempt(view_func): [MASK]\n"}
{"method_name": "parse_cookie", "full_method_name": "parse_cookie", "method_path": "../srcdata/Network/django/django/http/cookie.py", "method_code": "from http import cookies\ndef parse_cookie(cookie):\n    \"\"\"\n    Return a dictionary parsed from a `Cookie:` header string.\n    \"\"\"\n    cookiedict = {}\n    for chunk in cookie.split(';'):\n        if '=' in chunk:\n            key, val = chunk.split('=', 1)\n        else:\n            key, val = '', chunk\n        key, val = key.strip(), val.strip()\n        if key or val:\n            cookiedict[key] = cookies._unquote(val)\n    return cookiedict", "test_code_list": [{"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_decode(self):\n        \"\"\"Semicolons and commas are decoded.\"\"\"\n        c = SimpleCookie()\n        c['test'] = 'An,awkward;value'\n        c2 = SimpleCookie()\n        c2.load(c.output()[12:])\n        self.assertEqual(c['test'].value, c2['test'].value)\n        c3 = parse_cookie(c.output()[12:])\n        self.assertEqual(c['test'].value, c3['test'])\n    \nCookieTests().test_decode()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}, {"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_nonstandard_keys(self):\n        \"\"\"\n            A single non-standard cookie name doesn't affect all cookies (#13007).\n            \"\"\"\n        self.assertIn('good_cookie', parse_cookie('good_cookie=yes;bad:cookie=yes')\n            )\n    \nCookieTests().test_nonstandard_keys()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}, {"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_repeated_nonstandard_keys(self):\n        \"\"\"\n            A repeated non-standard name doesn't affect all cookies (#15852).\n            \"\"\"\n        self.assertIn('good_cookie', parse_cookie('a:=b; a:=c; good_cookie=yes'))\n    \nCookieTests().test_repeated_nonstandard_keys()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}, {"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_python_cookies(self):\n        \"\"\"\n            Test cases copied from Python's Lib/test/test_http_cookies.py\n            \"\"\"\n        self.assertEqual(parse_cookie('chips=ahoy; vienna=finger'), {'chips':\n            'ahoy', 'vienna': 'finger'})\n        self.assertEqual(parse_cookie(\n            'keebler=\"E=mc2; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\"'), {'keebler':\n            '\"E=mc2', 'L': '\\\\\"Loves\\\\\"', 'fudge': '\\\\012', '': '\"'})\n        self.assertEqual(parse_cookie('keebler=E=mc2'), {'keebler': 'E=mc2'})\n        self.assertEqual(parse_cookie('key:term=value:term'), {'key:term':\n            'value:term'})\n        self.assertEqual(parse_cookie('a=b; c=[; d=r; f=h'), {'a': 'b', 'c':\n            '[', 'd': 'r', 'f': 'h'})\n    \nCookieTests().test_python_cookies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}, {"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_cookie_edgecases(self):\n        self.assertEqual(parse_cookie('a=b; Domain=example.com'), {'a': 'b',\n            'Domain': 'example.com'})\n        self.assertEqual(parse_cookie('a=b; h=i; a=c'), {'a': 'c', 'h': 'i'})\n    \nCookieTests().test_cookie_edgecases()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}, {"test_code": "import copy\nimport json\nimport os\nimport pickle\nimport unittest\nimport uuid\nfrom django.core.exceptions import DisallowedRedirect\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.core.signals import request_finished\nfrom django.db import close_old_connections\nfrom django.http import BadHeaderError\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotAllowed\nfrom django.http import HttpResponseNotModified\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.http import JsonResponse\nfrom django.http import QueryDict\nfrom django.http import SimpleCookie\nfrom django.http import StreamingHttpResponse\nfrom django.http import parse_cookie\nfrom django.test import SimpleTestCase\nfrom django.utils.functional import lazystr\n\nclass CookieTests(unittest.TestCase):\n    def test_invalid_cookies(self):\n        \"\"\"\n            Cookie strings that go against RFC 6265 but browsers will send if set\n            via document.cookie.\n            \"\"\"\n        self.assertIn('django_language', parse_cookie(\n            'abc=def; unnamed; django_language=en'))\n        self.assertEqual(parse_cookie('a=b; \"; c=d'), {'a': 'b', '': '\"', 'c': 'd'}\n            )\n        self.assertEqual(parse_cookie('a b c=d e = f; gh=i'), {'a b c':\n            'd e = f', 'gh': 'i'})\n        self.assertEqual(parse_cookie('a   b,c<>@:/[]?{}=d  \"  =e,f g'), {\n            'a   b,c<>@:/[]?{}': 'd  \"  =e,f g'})\n        self.assertEqual(parse_cookie('saint=Andr\u00e9 Bessette'), {'saint':\n            'Andr\u00e9 Bessette'})\n        self.assertEqual(parse_cookie('  =  b  ;  ;  =  ;   c  =  ;  '), {'':\n            'b', 'c': ''})\n    \nCookieTests().test_invalid_cookies()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/httpwrappers/tests.py"}], "instruction": "Functionality: The function parse_cookie is designed to parse a 'Cookie:' header string and return a dictionary where the keys are the cookie names and the values are the corresponding cookie values. It splits the cookie string by ';' to separate different cookies, and then by '=' to separate the names and values of each cookie.\n\nInputs: A single string argument 'cookie' which represents the 'Cookie:' header string.\n\nOutputs: A dictionary where each key is a cookie name (string) and each value is the corresponding cookie value (string). The values are unquoted using the _unquote method from the http.cookies module.", "method_code_mask": "from http import cookies\n\n\ndef parse_cookie(cookie): [MASK]\n"}
{"method_name": "register", "full_method_name": "register", "method_path": "../srcdata/Network/django/django/contrib/admin/decorators.py", "method_code": "from django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.admin.sites import site as default_site\ndef register(*models, site=None):\n    \"\"\"\n    Register the given model(s) classes and wrapped ModelAdmin class with\n    admin site:\n\n    @register(Author)\n    class AuthorAdmin(admin.ModelAdmin):\n        pass\n\n    The `site` kwarg is an admin site to use instead of the default admin site.\n    \"\"\"\n    from django.contrib.admin import ModelAdmin\n    from django.contrib.admin.sites import AdminSite\n    from django.contrib.admin.sites import site as default_site\n\n    def _model_admin_wrapper(admin_class):\n        if not models:\n            raise ValueError('At least one model must be passed to register.')\n        admin_site = site or default_site\n        if not isinstance(admin_site, AdminSite):\n            raise ValueError('site must subclass AdminSite')\n        if not issubclass(admin_class, ModelAdmin):\n            raise ValueError('Wrapped class must subclass ModelAdmin.')\n        admin_site.register(models, admin_class=admin_class)\n        return admin_class\n    return _model_admin_wrapper", "test_code_list": [{"test_code": "from django.contrib import admin\nfrom django.contrib.admin.decorators import register\nfrom django.contrib.admin.sites import site\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.test import SimpleTestCase\nclass NameAdmin(admin.ModelAdmin):\n    list_display = ['name']\n    save_on_top = True\nclass TestRegistrationDecorator(SimpleTestCase):\n    def test_empty_models_list_registration_fails(self):\n        with self.assertRaisesMessage(ValueError,\n            'At least one model must be passed to register.'):\n            register()(NameAdmin)\nTestRegistrationDecorator().test_empty_models_list_registration_fails()", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_registration/tests.py"}], "instruction": "@register(Author)\nclass AuthorAdmin(ModelAdmin):\n    pass", "method_code_mask": "from django.contrib.admin import ModelAdmin\nfrom django.contrib.admin.sites import AdminSite\nfrom django.contrib.admin.sites import site as default_site\n\n\ndef register(*models, site=None): [MASK]\n"}
{"method_name": "url_params_from_lookup_dict", "full_method_name": "url_params_from_lookup_dict", "method_path": "../srcdata/Network/django/django/contrib/admin/widgets.py", "method_code": "import copy\nimport json\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import URLValidator\nfrom django.db.models import CASCADE\nfrom django.db.models import UUIDField\nfrom django.urls import reverse\nfrom django.urls.exceptions import NoReverseMatch\nfrom django.utils.html import smart_urlquote\nfrom django.utils.http import urlencode\nfrom django.utils.text import Truncator\nfrom django.utils.translation import get_language\nfrom django.utils.translation import gettext as _\nfrom django.contrib.admin.views.main import TO_FIELD_VAR\nfrom django.contrib.admin.views.main import IS_POPUP_VAR\ndef url_params_from_lookup_dict(lookups):\n    \"\"\"\n    Convert the type of lookups specified in a ForeignKey limit_choices_to\n    attribute to a dictionary of query parameters\n    \"\"\"\n    params = {}\n    if lookups and hasattr(lookups, 'items'):\n        for k, v in lookups.items():\n            if callable(v):\n                v = v()\n            if isinstance(v, (tuple, list)):\n                v = ','.join(str(x) for x in v)\n            elif isinstance(v, bool):\n                v = ('0', '1')[v]\n            else:\n                v = str(v)\n            params[k] = v\n    return params", "test_code_list": [{"test_code": "import gettext\nimport os\nimport re\nimport zoneinfo\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom importlib import import_module\nfrom unittest import skipUnless\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin import widgets\nfrom django.contrib.admin.tests import AdminSeleniumTestCase\nfrom django.core.files.storage import default_storage\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import ForeignKey\nfrom django.db.models import ManyToManyField\nfrom django.db.models import UUIDField\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import ignore_warnings\nfrom django.test import override_settings\nfrom django.test.utils import requires_tz_support\nfrom django.urls import reverse\nfrom django.utils import translation\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver import ActionChains\nfrom selenium.webdriver.support.ui import Select\nclass TestDataMixin:\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.superuser = User.objects.create_superuser(username='super',\n            password='secret', email=None)\n        cls.u2 = User.objects.create_user(username='testser', password='secret'\n            )\n        Car.objects.create(owner=cls.superuser, make='Volkswagen', model=\n            'Passat')\n        Car.objects.create(owner=cls.u2, make='BMW', model='M3')\n\nclass AdminForeignKeyRawIdWidget(TestDataMixin, TestCase):\n    def test_url_params_from_lookup_dict_any_iterable(self):\n        lookup1 = url_params_from_lookup_dict({'color__in': ('red',\n            'blue')})\n        lookup2 = url_params_from_lookup_dict({'color__in': ['red',\n            'blue']})\n        self.assertEqual(lookup1, {'color__in': 'red,blue'})\n        self.assertEqual(lookup1, lookup2)\n    \nAdminForeignKeyRawIdWidget().test_url_params_from_lookup_dict_any_iterable()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_widgets/tests.py"}, {"test_code": "import gettext\nimport os\nimport re\nimport zoneinfo\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom importlib import import_module\nfrom unittest import skipUnless\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin import widgets\nfrom django.contrib.admin.tests import AdminSeleniumTestCase\nfrom django.core.files.storage import default_storage\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.db.models import CharField\nfrom django.db.models import DateField\nfrom django.db.models import DateTimeField\nfrom django.db.models import ForeignKey\nfrom django.db.models import ManyToManyField\nfrom django.db.models import UUIDField\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import ignore_warnings\nfrom django.test import override_settings\nfrom django.test.utils import requires_tz_support\nfrom django.urls import reverse\nfrom django.utils import translation\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver import ActionChains\nfrom selenium.webdriver.support.ui import Select\nclass TestDataMixin:\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.superuser = User.objects.create_superuser(username='super',\n            password='secret', email=None)\n        cls.u2 = User.objects.create_user(username='testser', password='secret'\n            )\n        Car.objects.create(owner=cls.superuser, make='Volkswagen', model=\n            'Passat')\n        Car.objects.create(owner=cls.u2, make='BMW', model='M3')\n\nclass AdminForeignKeyRawIdWidget(TestDataMixin, TestCase):\n    def test_url_params_from_lookup_dict_callable(self):\n    \n        def my_callable():\n            return 'works'\n        lookup1 = url_params_from_lookup_dict({'myfield': my_callable})\n        lookup2 = url_params_from_lookup_dict({'myfield': my_callable()})\n        self.assertEqual(lookup1, lookup2)\n    \nAdminForeignKeyRawIdWidget().test_url_params_from_lookup_dict_callable()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/admin_widgets/tests.py"}], "instruction": "Functionality: The function 'url_params_from_lookup_dict' is designed to convert the type of lookups specified in a ForeignKey limit_choices_to attribute into a dictionary of query parameters. This is useful for generating URLs that include filters based on the provided lookups.\n\nInputs: \n- lookups (dict): A dictionary where keys are field names and values are conditions that are either a callable, a tuple, a list, a boolean, or any other object that can be converted to a string. The lookups are typically used in ForeignKey limit_choices_to attributes.\n\nOutputs:\n- params (dict): A dictionary of query parameters. Each key in the dictionary corresponds to a field name from the input 'lookups', and the value is the string representation of the lookup value, which can be a single value or a comma-separated list of values if the original value was a list or tuple.", "method_code_mask": "import copy\nimport json\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.validators import URLValidator\nfrom django.db.models import CASCADE\nfrom django.db.models import UUIDField\nfrom django.urls import reverse\nfrom django.urls.exceptions import NoReverseMatch\nfrom django.utils.html import smart_urlquote\nfrom django.utils.http import urlencode\nfrom django.utils.text import Truncator\nfrom django.utils.translation import get_language\nfrom django.utils.translation import gettext as _\nfrom django.contrib.admin.views.main import TO_FIELD_VAR\nfrom django.contrib.admin.views.main import IS_POPUP_VAR\n\n\ndef url_params_from_lookup_dict(lookups): [MASK]\n"}
{"method_name": "make_template_fragment_key", "full_method_name": "make_template_fragment_key", "method_path": "../srcdata/Network/django/django/core/cache/utils.py", "method_code": "from hashlib import md5\ndef make_template_fragment_key(fragment_name, vary_on=None):\n    hasher = md5(usedforsecurity=False)\n    if vary_on is not None:\n        for arg in vary_on:\n            hasher.update(str(arg).encode())\n            hasher.update(b':')\n    return TEMPLATE_FRAGMENT_KEY_TEMPLATE % (fragment_name, hasher.hexdigest())", "test_code_list": [{"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_without_vary_on(self):\n        key = make_template_fragment_key('a.fragment')\n        self.assertEqual(key,\n            'template.cache.a.fragment.d41d8cd98f00b204e9800998ecf8427e')\n    \nTestMakeTemplateFragmentKey().test_without_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_with_one_vary_on(self):\n        key = make_template_fragment_key('foo', ['abc'])\n        self.assertEqual(key, 'template.cache.foo.493e283d571a73056196f1a68efd0f66'\n            )\n    \nTestMakeTemplateFragmentKey().test_with_one_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_with_many_vary_on(self):\n        key = make_template_fragment_key('bar', ['abc', 'def'])\n        self.assertEqual(key, 'template.cache.bar.17c1a507a0cb58384f4c639067a93520'\n            )\n    \nTestMakeTemplateFragmentKey().test_with_many_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_proper_escaping(self):\n        key = make_template_fragment_key('spam', ['abc:def%'])\n        self.assertEqual(key,\n            'template.cache.spam.06c8ae8e8c430b69fb0a6443504153dc')\n    \nTestMakeTemplateFragmentKey().test_proper_escaping()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_with_ints_vary_on(self):\n        key = make_template_fragment_key('foo', [1, 2, 3, 4, 5])\n        self.assertEqual(key, 'template.cache.foo.7ae8fd2e0d25d651c683bdeebdb29461'\n            )\n    \nTestMakeTemplateFragmentKey().test_with_ints_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_with_unicode_vary_on(self):\n        key = make_template_fragment_key('foo', ['42\u00ba', '\ud83d\ude00'])\n        self.assertEqual(key, 'template.cache.foo.7ced1c94e543668590ba39b3c08b0237'\n            )\n    \nTestMakeTemplateFragmentKey().test_with_unicode_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}, {"test_code": "import copy\nimport io\nimport os\nimport pickle\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport threading\nimport time\nimport unittest\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest import skipIf\nfrom django.conf import settings\nfrom django.core import management\nfrom django.core import signals\nfrom django.core.cache import DEFAULT_CACHE_ALIAS\nfrom django.core.cache import CacheHandler\nfrom django.core.cache import CacheKeyWarning\nfrom django.core.cache import InvalidCacheKey\nfrom django.core.cache import cache\nfrom django.core.cache import caches\nfrom django.core.cache.backends.base import InvalidCacheBackendError\nfrom django.core.cache.backends.redis import RedisCacheClient\nfrom django.core.cache.utils import make_template_fragment_key\nfrom django.db import close_old_connections\nfrom django.db import connection\nfrom django.db import connections\nfrom django.db.backends.utils import CursorWrapper\nfrom django.http import HttpRequest\nfrom django.http import HttpResponse\nfrom django.http import HttpResponseNotModified\nfrom django.http import StreamingHttpResponse\nfrom django.middleware.cache import CacheMiddleware\nfrom django.middleware.cache import FetchFromCacheMiddleware\nfrom django.middleware.cache import UpdateCacheMiddleware\nfrom django.middleware.csrf import CsrfViewMiddleware\nfrom django.template import engines\nfrom django.template.context_processors import csrf\nfrom django.template.response import TemplateResponse\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import TransactionTestCase\nfrom django.test import override_settings\nfrom django.test.signals import setting_changed\nfrom django.test.utils import CaptureQueriesContext\nfrom django.utils import timezone\nfrom django.utils import translation\nfrom django.utils.cache import get_cache_key\nfrom django.utils.cache import learn_cache_key\nfrom django.utils.cache import patch_cache_control\nfrom django.utils.cache import patch_vary_headers\nfrom django.views.decorators.cache import cache_control\nfrom django.views.decorators.cache import cache_page\nfrom zlib import compress\nfrom zlib import decompress\n\nclass TestMakeTemplateFragmentKey(SimpleTestCase):\n    def test_long_vary_on(self):\n        key = make_template_fragment_key('foo', ['x' * 10000])\n        self.assertEqual(key, 'template.cache.foo.3670b349b5124aa56bdb50678b02b23a'\n            )\n    \nTestMakeTemplateFragmentKey().test_long_vary_on()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/cache/tests.py"}], "instruction": "Functionality: The function 'make_template_fragment_key' is designed to generate a unique key for a template fragment. It concatenates the fragment name with a hash of the items in 'vary_on' if provided, and returns this concatenated string as the key. The hash is generated using the MD5 algorithm. The purpose is to create a unique identifier for caching template fragments in a way that reflects any variables that might affect the rendering of the fragment.\n\nInputs: \n1. fragment_name (str): A string representing the name of the template fragment.\n2. vary_on (list, optional): A list of variables that affect the rendering of the template fragment. If not provided, it defaults to None.\n\nOutputs: \n1. (str): A string that is a unique key for the template fragment. This string is created by concatenating the 'fragment_name' with the MD5 hash digest of the 'vary_on' variables if they are provided. The hash digest is obtained by updating the hasher with each argument in 'vary_on' and then converting the final digest to a hexadecimal format.", "method_code_mask": "from hashlib import md5\n\n\ndef make_template_fragment_key(fragment_name, vary_on=None): [MASK]\n"}
{"method_name": "select_template", "full_method_name": "select_template", "method_path": "../srcdata/Network/django/django/template/loader.py", "method_code": "\ndef select_template(template_name_list, using=None):\n    \"\"\"\n    Load and return a template for one of the given names.\n\n    Try names in order and return the first template found.\n\n    Raise TemplateDoesNotExist if no such template exists.\n    \"\"\"\n    if isinstance(template_name_list, str):\n        raise TypeError(\n            'select_template() takes an iterable of template names but got a string: %r. Use get_template() if you want to load a single template by name.'\n             % template_name_list)\n    chain = []\n    engines = _engine_list(using)\n    for template_name in template_name_list:\n        for engine in engines:\n            try:\n                return engine.get_template(template_name)\n            except TemplateDoesNotExist as e:\n                chain.append(e)\n    if template_name_list:\n        raise TemplateDoesNotExist(', '.join(template_name_list), chain=chain)\n    else:\n        raise TemplateDoesNotExist('No template names provided')", "test_code_list": [{"test_code": "from django.template import TemplateDoesNotExist\nfrom django.template.loader import get_template\nfrom django.template.loader import render_to_string\nfrom django.template.loader import select_template\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.client import RequestFactory\n\nclass TemplateLoaderTests(SimpleTestCase):\n    def test_select_template_string(self):\n        with self.assertRaisesMessage(TypeError,\n            \"select_template() takes an iterable of template names but got a string: 'template_loader/hello.html'. Use get_template() if you want to load a single template by name.\"\n            ):\n            select_template('template_loader/hello.html')\n    \nTemplateLoaderTests().test_select_template_string()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/template_loader/tests.py"}], "instruction": "Functionality: The select_template function is responsible for loading and returning a template based on one of the given names in the input list. It tries the names in the order provided and returns the first template it finds. If no template exists for any of the given names, it raises a TemplateDoesNotExist exception.\n\nInputs: \n- template_name_list: A list of template names (strings) to be attempted sequentially for loading.\n- using (optional): A parameter that can be used to specify a particular template engine or engines. If not provided, it will use the default engines.\n\nOutputs:\n- The function returns a template object corresponding to the first template found among the provided names.\n\nIn case of failure:\n- If no template is found for any of the provided names, the function raises a TemplateDoesNotExist exception, listing all attempted names.\n- If the template_name_list is empty or no names are provided, a TemplateDoesNotExist exception is raised with a message indicating that no template names were provided.\n- If the template_name_list is provided as a string instead of an iterable list, a TypeError is raised, suggesting the use of get_template() for loading a single template by name.", "method_code_mask": "def select_template(template_name_list, using=None): [MASK]\n"}
{"method_name": "tag", "full_method_name": "tag", "method_path": "../srcdata/Network/django/django/test/utils.py", "method_code": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\ndef tag(*tags):\n    \"\"\"Decorator to add tags to a test class or method.\"\"\"\n\n    def decorator(obj):\n        if hasattr(obj, 'tags'):\n            obj.tags = obj.tags.union(tags)\n        else:\n            setattr(obj, 'tags', set(tags))\n        return obj\n    return decorator", "test_code_list": [{"test_code": "from unittest import TestCase\nfrom django.test import tag\n\nclass TaggedTestCase(TestCase):\n    @tag('fast')\n    def test_single_tag(self):\n        self.assertEqual(1, 1)\n    \nTaggedTestCase().test_single_tag()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner_apps/tagged/tests.py"}, {"test_code": "from unittest import TestCase\nfrom django.test import tag\n\nclass TaggedTestCase(TestCase):\n    @tag('fast', 'core')\n    def test_multiple_tags(self):\n        self.assertEqual(1, 1)\n    \nTaggedTestCase().test_multiple_tags()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/test_runner_apps/tagged/tests.py"}], "instruction": "Functionality: The tag function is a decorator that adds tags to a Django test class or method, which can be used for test categorization and filtering in test runners.\n\nInputs: \n- tags (Tuple[str]): A variable number of string arguments representing the tags to be added to the test class or method. Each tag is a string identifier.\n\nOutputs: \n- The decorator returns the original object (test class or method) with an added 'tags' attribute, which is a set containing all the tags associated with that object. If the object already has a 'tags' attribute, the new tags are merged with the existing ones; otherwise, a new 'tags' attribute is created.", "method_code_mask": "import collections\nimport gc\nimport logging\nimport os\nimport re\nimport sys\nimport time\nimport warnings\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import StringIO\nfrom itertools import chain\nfrom types import SimpleNamespace\nfrom unittest import TestCase\nfrom unittest import skipIf\nfrom unittest import skipUnless\nfrom xml.dom.minidom import Node\nfrom xml.dom.minidom import parseString\nfrom asgiref.sync import iscoroutinefunction\nfrom django.apps import apps\nfrom django.apps.registry import Apps\nfrom django.conf import UserSettingsHolder\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.signals import request_started\nfrom django.core.signals import setting_changed\nfrom django.db import DEFAULT_DB_ALIAS\nfrom django.db import connections\nfrom django.db import reset_queries\nfrom django.db.models.options import Options\nfrom django.template import Template\nfrom django.test.signals import template_rendered\nfrom django.urls import get_script_prefix\nfrom django.urls import set_script_prefix\nfrom django.utils.translation import deactivate\nimport jinja2\nfrom django.test import SimpleTestCase\nfrom django.core.checks.registry import registry\n\n\ndef tag(*tags): [MASK]\n"}
{"method_name": "get_callable", "full_method_name": "get_callable", "method_path": "../srcdata/Network/django/django/urls/utils.py", "method_code": "import functools\nfrom importlib import import_module\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.utils.module_loading import module_has_submodule\n@functools.cache\ndef get_callable(lookup_view):\n    \"\"\"\n    Return a callable corresponding to lookup_view.\n    * If lookup_view is already a callable, return it.\n    * If lookup_view is a string import path that can be resolved to a callable,\n      import that callable and return it, otherwise raise an exception\n      (ImportError or ViewDoesNotExist).\n    \"\"\"\n    if callable(lookup_view):\n        return lookup_view\n    if not isinstance(lookup_view, str):\n        raise ViewDoesNotExist(\n            \"'%s' is not a callable or a dot-notation path\" % lookup_view)\n    mod_name, func_name = get_mod_func(lookup_view)\n    if not func_name:\n        raise ImportError(\n            \"Could not import '%s'. The path must be fully qualified.\" %\n            lookup_view)\n    try:\n        mod = import_module(mod_name)\n    except ImportError:\n        parentmod, submod = get_mod_func(mod_name)\n        if submod and not module_has_submodule(import_module(parentmod), submod\n            ):\n            raise ViewDoesNotExist(\n                \"Could not import '%s'. Parent module %s does not exist.\" %\n                (lookup_view, mod_name))\n        else:\n            raise\n    else:\n        try:\n            view_func = getattr(mod, func_name)\n        except AttributeError:\n            raise ViewDoesNotExist(\n                \"Could not import '%s'. View does not exist in module %s.\" %\n                (lookup_view, mod_name))\n        else:\n            if not callable(view_func):\n                raise ViewDoesNotExist(\n                    \"Could not import '%s.%s'. View is not callable.\" % (\n                    mod_name, func_name))\n            return view_func", "test_code_list": [{"test_code": "import pickle\nimport sys\nimport threading\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.http import HttpRequest\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import override_script_prefix\nfrom django.urls import NoReverseMatch\nfrom django.urls import Resolver404\nfrom django.urls import ResolverMatch\nfrom django.urls import URLPattern\nfrom django.urls import URLResolver\nfrom django.urls import get_callable\nfrom django.urls import get_resolver\nfrom django.urls import get_urlconf\nfrom django.urls import include\nfrom django.urls import path\nfrom django.urls import re_path\nfrom django.urls import resolve\nfrom django.urls import reverse\nfrom django.urls import reverse_lazy\nfrom django.urls.resolvers import RegexPattern\n\nclass ViewLoadingTests(SimpleTestCase):\n    def test_non_string_value(self):\n        msg = \"'1' is not a callable or a dot-notation path\"\n        with self.assertRaisesMessage(ViewDoesNotExist, msg):\n            get_callable(1)\n    \nViewLoadingTests().test_non_string_value()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/urlpatterns_reverse/tests.py"}, {"test_code": "import pickle\nimport sys\nimport threading\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.http import HttpRequest\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import override_script_prefix\nfrom django.urls import NoReverseMatch\nfrom django.urls import Resolver404\nfrom django.urls import ResolverMatch\nfrom django.urls import URLPattern\nfrom django.urls import URLResolver\nfrom django.urls import get_callable\nfrom django.urls import get_resolver\nfrom django.urls import get_urlconf\nfrom django.urls import include\nfrom django.urls import path\nfrom django.urls import re_path\nfrom django.urls import resolve\nfrom django.urls import reverse\nfrom django.urls import reverse_lazy\nfrom django.urls.resolvers import RegexPattern\n\nclass ViewLoadingTests(SimpleTestCase):\n    def test_string_without_dot(self):\n        msg = \"Could not import 'test'. The path must be fully qualified.\"\n        with self.assertRaisesMessage(ImportError, msg):\n            get_callable('test')\n    \nViewLoadingTests().test_string_without_dot()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/urlpatterns_reverse/tests.py"}, {"test_code": "import pickle\nimport sys\nimport threading\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.http import HttpRequest\nfrom django.http import HttpResponsePermanentRedirect\nfrom django.http import HttpResponseRedirect\nfrom django.shortcuts import redirect\nfrom django.test import RequestFactory\nfrom django.test import SimpleTestCase\nfrom django.test import TestCase\nfrom django.test import override_settings\nfrom django.test.utils import override_script_prefix\nfrom django.urls import NoReverseMatch\nfrom django.urls import Resolver404\nfrom django.urls import ResolverMatch\nfrom django.urls import URLPattern\nfrom django.urls import URLResolver\nfrom django.urls import get_callable\nfrom django.urls import get_resolver\nfrom django.urls import get_urlconf\nfrom django.urls import include\nfrom django.urls import path\nfrom django.urls import re_path\nfrom django.urls import resolve\nfrom django.urls import reverse\nfrom django.urls import reverse_lazy\nfrom django.urls.resolvers import RegexPattern\n\nclass ViewLoadingTests(SimpleTestCase):\n    def test_module_does_not_exist(self):\n        with self.assertRaisesMessage(ImportError, \"No module named 'foo'\"):\n            get_callable('foo.bar')\n    \nViewLoadingTests().test_module_does_not_exist()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/urlpatterns_reverse/tests.py"}], "instruction": "Functionality: The get_callable function is designed to return a callable object (such as a function or a method) based on the input provided. It is capable of handling direct callable objects or strings representing the dotted path to the callable within a module. If the input is not a callable or a valid dotted path, relevant exceptions are raised.\n\nInputs:\n- lookup_view: This can either be a callable object (e.g., a function) or a string representing the dotted path to a callable within a module. If a string is provided, it must be in the format that allows for clear identification of the module and the callable function or method within that module.\n\nOutputs:\n- If the input is already a callable, the same callable object is returned.\n- If the input is a string that can be resolved to a callable, the function imports the callable by the provided string and returns it.\n- In case of an input that is not a callable and does not represent a valid dotted path to a callable, the function will raise exceptions (either ImportError or ViewDoesNotExist) with appropriate error messages.", "method_code_mask": "import functools\nfrom importlib import import_module\nfrom django.core.exceptions import ViewDoesNotExist\nfrom django.utils.module_loading import module_has_submodule\n\n\n@functools.cache\ndef get_callable(lookup_view): [MASK]\n"}
{"method_name": "create_namedtuple_class", "full_method_name": "create_namedtuple_class", "method_path": "../srcdata/Network/django/django/db/models/utils.py", "method_code": "import functools\nfrom collections import namedtuple\n@functools.lru_cache\ndef create_namedtuple_class(*names):\n\n    def __reduce__(self):\n        return unpickle_named_row, (names, tuple(self))\n    return type('Row', (namedtuple('Row', names),), {'__reduce__':\n        __reduce__, '__slots__': ()})", "test_code_list": [{"test_code": "from django.db.models.utils import create_namedtuple_class\nfrom django.test import SimpleTestCase\n\nclass NamedTupleClassTests(SimpleTestCase):\n    def test_immutability(self):\n        row_class = create_namedtuple_class('field1', 'field2')\n        row = row_class('value1', 'value2')\n        with self.assertRaises(AttributeError):\n            row.field3 = 'value3'\n    \nNamedTupleClassTests().test_immutability()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/model_utils/tests.py"}], "instruction": "Functionality: The create_namedtuple_class function is designed to generate a new class that inherits from the namedtuple 'Row'. This class will have the specified field names provided as input, and it includes custom functionality to support pickling, ensuring that the object state can be serialized and deserialized efficiently. The function utilizes the functools.lru_cache decorator to cache the results, preventing the recreation of the same class for the same set of field names, thus improving performance.\n\nInputs: The function accepts a variable number of arguments (*names), where each argument represents a field name. These field names are used to define the structure of the namedtuple class that will be created. The field names should be unique and descriptive of the data that will be stored in each field.\n\nOutputs: The function returns a new class that is a subclass of namedtuple('Row', names). This custom class has an additional method, __reduce__, which supports the pickling and unpickling process. The created class allows for the creation of objects that can be indexed by field name as well as by position, offering flexibility in accessing the data. The caching mechanism ensures that if the same class is requested again with the same set of field names, the cached version is returned, avoiding unnecessary computation.", "method_code_mask": "import functools\nfrom collections import namedtuple\n\n\n@functools.lru_cache\ndef create_namedtuple_class(*names): [MASK]\n"}
{"method_name": "b62_encode", "full_method_name": "b62_encode", "method_path": "../srcdata/Network/django/django/core/signing.py", "method_code": "import base64\nimport datetime\nimport json\nimport time\nimport zlib\nfrom django.conf import settings\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import salted_hmac\nfrom django.utils.encoding import force_bytes\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nBASE62_ALPHABET = (\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')\ndef b62_encode(s):\n    if s == 0:\n        return '0'\n    sign = '-' if s < 0 else ''\n    s = abs(s)\n    encoded = ''\n    while s > 0:\n        s, remainder = divmod(s, 62)\n        encoded = BASE62_ALPHABET[remainder] + encoded\n    return sign + encoded", "test_code_list": [{"test_code": "import datetime\nfrom django.core import signing\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import freeze_time\nfrom django.utils.crypto import InvalidAlgorithm\n\nclass TestBase62(SimpleTestCase):\n    def test_base62(self):\n        tests = [-10 ** 10, 10 ** 10, 1620378259, *range(-100, 100)]\n        for i in tests:\n            self.assertEqual(i, signing.b62_decode(b62_encode(i)))\n    \nTestBase62().test_base62()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/signing/tests.py"}], "instruction": "Functionality: The function b62_encode is designed to convert a given integer into a base62 encoded string. Base62 encoding uses digits (0-9), uppercase letters (A-Z), and lowercase letters (a-z) to represent numbers in a compact form. The function handles both positive and negative integers and represents negative numbers with a '-' sign at the beginning of the encoded string.\n\nInputs: \n- s: An integer to be encoded into a base62 string.\n\nOutputs: \n- A string that represents the base62 encoded value of the input integer. For instance, if the input integer is 1234, the function should return a string that is the base62 encoded equivalent of 1234. If the input integer is -567, the function should return a string that represents the base62 encoded equivalent of -567, with a '-' sign at the beginning.", "method_code_mask": "import base64\nimport datetime\nimport json\nimport time\nimport zlib\nfrom django.conf import settings\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import salted_hmac\nfrom django.utils.encoding import force_bytes\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nBASE62_ALPHABET = (\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')\n\n\ndef b62_encode(s): [MASK]\n"}
{"method_name": "b62_decode", "full_method_name": "b62_decode", "method_path": "../srcdata/Network/django/django/core/signing.py", "method_code": "import base64\nimport datetime\nimport json\nimport time\nimport zlib\nfrom django.conf import settings\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import salted_hmac\nfrom django.utils.encoding import force_bytes\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nBASE62_ALPHABET = (\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')\ndef b62_decode(s):\n    if s == '0':\n        return 0\n    sign = 1\n    if s[0] == '-':\n        s = s[1:]\n        sign = -1\n    decoded = 0\n    for digit in s:\n        decoded = decoded * 62 + BASE62_ALPHABET.index(digit)\n    return sign * decoded", "test_code_list": [{"test_code": "import datetime\nfrom django.core import signing\nfrom django.test import SimpleTestCase\nfrom django.test import override_settings\nfrom django.test.utils import freeze_time\nfrom django.utils.crypto import InvalidAlgorithm\n\nclass TestBase62(SimpleTestCase):\n    def test_base62(self):\n        tests = [-10 ** 10, 10 ** 10, 1620378259, *range(-100, 100)]\n        for i in tests:\n            self.assertEqual(i, b62_decode(signing.b62_encode(i)))\n    \nTestBase62().test_base62()\n", "code_start": "", "test_path": "../srcdata/Network/django/tests/signing/tests.py"}], "instruction": "Functionality: The b62_decode function is designed to decode a base62 encoded string into its original integer value. Base62 encoding uses a combination of digits (0-9), uppercase letters (A-Z), and lowercase letters (a-z) to represent numbers more compactly than standard decimal representation.\n\nInputs: \n- The function takes a single argument, 's', which is a string representing the base62 encoded number. The string may include a '-' sign at the beginning to indicate a negative number.\n\nOutputs:\n- The function returns an integer, which is the decoded value of the base62 encoded string. If the input string is '0', the function will return 0. If the input string starts with a '-', the returned integer will be negative.", "method_code_mask": "import base64\nimport datetime\nimport json\nimport time\nimport zlib\nfrom django.conf import settings\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.crypto import salted_hmac\nfrom django.utils.encoding import force_bytes\nfrom django.utils.module_loading import import_string\nfrom django.utils.regex_helper import _lazy_re_compile\nBASE62_ALPHABET = (\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')\n\n\ndef b62_decode(s): [MASK]\n"}
