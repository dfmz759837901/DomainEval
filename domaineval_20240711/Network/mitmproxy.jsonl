{"method_name": "_name_to_keyval", "full_method_name": "_name_to_keyval", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/certs.py", "method_code": "import contextlib\nimport datetime\nimport ipaddress\nimport os\nimport sys\nimport warnings\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import cast\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Union\nimport OpenSSL\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs12\nfrom cryptography.x509 import ExtendedKeyUsageOID\nfrom cryptography.x509 import NameOID\ndef _name_to_keyval(name: x509.Name) ->list[tuple[str, str]]:\n    parts = []\n    for attr in name:\n        k = attr.rfc4514_string().partition('=')[0]\n        v = cast(str, attr.value)\n        parts.append((k, v))\n    return parts", "test_code_list": [{"test_code": "import ipaddress\nimport os\nfrom datetime import datetime\nfrom datetime import timezone\nfrom pathlib import Path\nimport pytest\nfrom cryptography import x509\nfrom cryptography.x509 import NameOID\n\nclass TestCert():\n    def test_multi_valued_rdns(self):\n        subject = x509.Name([x509.RelativeDistinguishedName([x509.NameAttribute\n            (NameOID.TITLE, 'Test'), x509.NameAttribute(NameOID.COMMON_NAME,\n            'Multivalue'), x509.NameAttribute(NameOID.SURNAME, 'RDNs'), x509.\n            NameAttribute(NameOID.ORGANIZATION_NAME, 'TSLA')]), x509.\n            RelativeDistinguishedName([x509.NameAttribute(NameOID.\n            ORGANIZATION_NAME, 'PyCA')])])\n        expected = [('2.5.4.12', 'Test'), ('CN', 'Multivalue'), ('2.5.4.4',\n            'RDNs'), ('O', 'TSLA'), ('O', 'PyCA')]\n        assert _name_to_keyval(subject) == expected\n    \nTestCert().test_multi_valued_rdns()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/test_certs.py"}], "instruction": "Functionality: The _name_to_keyval function is designed to convert a given x509.Name object into a list of tuples, where each tuple contains a key-value pair representing the attributes of the x509.Name. This function is particularly useful in cryptography and security contexts where x509 certificates are used for secure communications. \n\nInputs: \n- name: An x509.Name object, which is a part of the cryptography module in Python. It represents a collection of attributes that define the subject or entity of an X.509 certificate.\n\nOutputs:\n- A list of tuples, where each tuple consists of two elements:\n  - The first element (k) is a string representing the attribute name (key) as derived from the rfc4514_string() method of the attribute.\n  - The second element (v) is the string representation of the attribute value.", "method_code_mask": "import contextlib\nimport datetime\nimport ipaddress\nimport os\nimport sys\nimport warnings\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import cast\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Union\nimport OpenSSL\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs12\nfrom cryptography.x509 import ExtendedKeyUsageOID\nfrom cryptography.x509 import NameOID\n\n\ndef _name_to_keyval(name: x509.Name) ->list[tuple[str, str]]: [MASK]\n"}
{"method_name": "shorten_message", "full_method_name": "shorten_message", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/tools/console/statusbar.py", "method_code": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom functools import lru_cache\n@lru_cache\ndef shorten_message(msg: (tuple[str, str] | str), max_width: int) ->list[tuple\n    [str, str]]:\n    \"\"\"\n    Shorten message so that it fits into a single line in the statusbar.\n    \"\"\"\n    if isinstance(msg, tuple):\n        disp_attr, msg_text = msg\n    elif isinstance(msg, str):\n        msg_text = msg\n        disp_attr = ''\n    else:\n        raise AssertionError(f'Unexpected message type: {type(msg)}')\n    msg_end = '\u2026'\n    prompt = '(more in eventlog)'\n    msg_lines = msg_text.split('\\n')\n    first_line = msg_lines[0]\n    if len(msg_lines) > 1:\n        line_length = len(first_line) + len(prompt)\n    else:\n        line_length = len(first_line)\n    if line_length > max_width:\n        shortening_index = max(0, max_width - len(prompt) - len(msg_end))\n        first_line = first_line[:shortening_index] + msg_end\n    elif len(msg_lines) == 1:\n        prompt = ''\n    return [(disp_attr, first_line), ('warn', prompt)]", "test_code_list": [{"test_code": "import pytest\ndef test_shorten_message_narrow():\n    shorten_msg = shorten_message('error', max_width=4)\n    assert shorten_msg == [('', '\u2026'), ('warn', '(more in eventlog)')]\n\ntest_shorten_message_narrow()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/tools/console/test_statusbar.py"}], "instruction": "Functionality: The function 'shorten_message' is designed to reduce the length of a given message so that it fits within a specified maximum width, suitable for display in a status bar. It supports input in the form of a tuple containing display attributes and a message, or a simple string. If the message exceeds the maximum width, it is truncated and ends with '\u2026', and a prompt is added to indicate that the full message can be found in the event log.\n\nInputs: \n- msg: A message to be shortened. It can be provided as a tuple where the first element is a string of display attributes and the second element is the message text, or it can be directly provided as a string.\n- max_width: An integer representing the maximum width allowed for the message to fit into the status bar.\n\nOutputs:\n- A list containing tuples. Each tuple represents a line of the shortened message with its display attributes. The first tuple contains the display attributes (from the input or an empty string if the input was a plain string) and the shortened message line. The second tuple, if applicable, contains a warning attribute ('warn') and a prompt that indicates there is more text available in the event log. This prompt is only present if the original message was truncated or if there were multiple lines in the original message.", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom functools import lru_cache\n\n\n@lru_cache\ndef shorten_message(msg: (tuple[str, str] | str), max_width: int) ->list[tuple\n    [str, str]]: [MASK]\n"}
{"method_name": "is_valid_host", "full_method_name": "is_valid_host", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/check.py", "method_code": "import ipaddress\nimport re\nfrom typing import AnyStr\n_label_valid = re.compile(b'[A-Z\\\\d\\\\-_]{1,63}$', re.IGNORECASE)\ndef is_valid_host(host: AnyStr) ->bool:\n    \"\"\"\n    Checks if the passed bytes are a valid DNS hostname or an IPv4/IPv6 address.\n    \"\"\"\n    if isinstance(host, str):\n        try:\n            host_bytes = host.encode('idna')\n        except UnicodeError:\n            return False\n    else:\n        host_bytes = host\n    try:\n        host_bytes.decode('idna')\n    except ValueError:\n        return False\n    if len(host_bytes) > 255:\n        return False\n    if host_bytes and host_bytes.endswith(b'.'):\n        host_bytes = host_bytes[:-1]\n    if all(_label_valid.match(x) for x in host_bytes.split(b'.')):\n        return True\n    try:\n        ipaddress.ip_address(host_bytes.decode('idna'))\n        return True\n    except ValueError:\n        return False", "test_code_list": [{"test_code": "def test_is_valid_host():\n    assert not is_valid_host(b'')\n    assert not is_valid_host(b'xn--ke.ws')\n    assert is_valid_host(b'one.two')\n    assert not is_valid_host(b'one' * 255)\n    assert is_valid_host(b'one.two.')\n    assert is_valid_host(b'one_two')\n    assert is_valid_host(b'::1')\n    assert is_valid_host(b'127.0.0.1')\n    assert is_valid_host(b'2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n    assert is_valid_host(b'2001:db8:85a3:0:0:8a2e:370:7334')\n    assert is_valid_host(b'2001:db8:85a3::8a2e:370:7334')\n    assert not is_valid_host(b'2001:db8::85a3::7334')\n    assert is_valid_host(\n        b'2001-db8-85a3-8d3-1319-8a2e-370-7348.ipv6-literal.net')\n    assert is_valid_host(b'example.tl')\n    assert is_valid_host(b'example.tld')\n    assert is_valid_host(b'example.' + b'x' * 63)\n    assert not is_valid_host(b'example.' + b'x' * 64)\n    assert not is_valid_host(b'ex@mple')\n    assert not is_valid_host(b'ex@mple.com')\n    assert not is_valid_host(b'example..com')\n    assert not is_valid_host(b'.example.com')\n    assert not is_valid_host(b'@.example.com')\n    assert not is_valid_host(b'!.example.com')\n    assert not is_valid_host(b'.tld')\n    assert is_valid_host(b'x' * 1 + b'.tld')\n    assert is_valid_host(b'x' * 30 + b'.tld')\n    assert not is_valid_host(b'x' * 64 + b'.tld')\n    assert is_valid_host(b'x' * 1 + b'.example.tld')\n    assert is_valid_host(b'x' * 30 + b'.example.tld')\n    assert not is_valid_host(b'x' * 64 + b'.example.tld')\n    assert is_valid_host(b'_example')\n    assert is_valid_host(b'_example_')\n    assert is_valid_host(b'example_')\n    assert is_valid_host(b'_a.example.tld')\n    assert is_valid_host(b'a_.example.tld')\n    assert is_valid_host(b'_a_.example.tld')\n    assert is_valid_host(b'-example')\n    assert is_valid_host(b'-example_')\n    assert is_valid_host(b'example-')\n    assert is_valid_host(b'-a.example.tld')\n    assert is_valid_host(b'a-.example.tld')\n    assert is_valid_host(b'-a-.example.tld')\n    assert is_valid_host(b'api-.example.com')\n    assert is_valid_host(b'__a.example-site.com')\n    assert is_valid_host(b'_-a.example-site.com')\n    assert is_valid_host(b'_a_.example-site.com')\n    assert is_valid_host(b'-a-.example-site.com')\n    assert is_valid_host(b'api-.a.example.com')\n    assert is_valid_host(b'api-._a.example.com')\n    assert is_valid_host(b'api-.a_.example.com')\n    assert is_valid_host(b'api-.ab.example.com')\n    assert is_valid_host('example.tld')\n    assert not is_valid_host('foo..bar')\n\ntest_is_valid_host()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/test_check.py"}], "instruction": "Functionality: The function is_valid_host checks whether the provided host parameter is a valid DNS hostname or an IPv4/IPv6 address. It encodes the input string into bytes for validation and ensures it meets DNS hostname rules or is a valid IP address.\n\nInputs: \n- host: AnyStr\n  A string or bytes that represents a potential DNS hostname or IP address to be validated.\n\nOutputs:\n- bool\n  True if the host is a valid DNS hostname or an IPv4/IPv6 address, False otherwise.", "method_code_mask": "import ipaddress\nimport re\nfrom typing import AnyStr\n_label_valid = re.compile(b'[A-Z\\\\d\\\\-_]{1,63}$', re.IGNORECASE)\n\n\ndef is_valid_host(host: AnyStr) ->bool: [MASK]\n"}
{"method_name": "unparse", "full_method_name": "unparse", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)\ndef unparse(scheme: str, host: str, port: int, path: str='') ->str:\n    \"\"\"\n    Returns a URL string, constructed from the specified components.\n    Args:\n        All args must be str.\n    \"\"\"\n    if path == '*':\n        path = ''\n    authority = hostport(scheme, host, port)\n    return f'{scheme}://{authority}{path}'", "test_code_list": [{"test_code": "from typing import AnyStr\nimport pytest\ndef test_unparse():\n    assert unparse('http', 'foo.com', 99, '') == 'http://foo.com:99'\n    assert unparse('http', 'foo.com', 80, '/bar') == 'http://foo.com/bar'\n    assert unparse('https', 'foo.com', 80, '') == 'https://foo.com:80'\n    assert unparse('https', 'foo.com', 443, '') == 'https://foo.com'\n    assert unparse('https', 'foo.com', 443, '*') == 'https://foo.com'\n\ntest_unparse()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_url.py"}], "instruction": "Functionality: Constructs a URL string from given components.\nInputs: \n- scheme: A string representing the URL scheme (e.g., \"http\", \"https\").\n- host: A string representing the host component of the URL.\n- port: An integer representing the port number.\n- path: An optional string representing the path component of the URL (default is an empty string).\n\nOutputs:\n- A string representing the constructed URL. The function ensures that the port is included in the URL only if it does not match the default port for the given scheme. If the path is set to \"*\", it is treated as an empty string.", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\n\n\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)\n\n\ndef unparse(scheme: str, host: str, port: int, path: str='') ->str: [MASK]\n"}
{"method_name": "decode", "full_method_name": "decode", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef decode(s):\n    \"\"\"\n    Takes a urlencoded string and returns a list of surrogate-escaped (key, value) tuples.\n    \"\"\"\n    return urllib.parse.parse_qsl(s, keep_blank_values=True, errors=\n        'surrogateescape')", "test_code_list": [{"test_code": "from typing import AnyStr\nimport pytest\nsurrogates = (bytes(range(0, 126)) + bytes(range(127, 256))).decode('utf8',\n    'surrogateescape')\ndef test_decode():\n    s = 'one=two&three=four'\n    assert len(decode(s)) == 2\n    assert decode(surrogates)\ntest_decode()", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_url.py"}], "instruction": "decoded = decode('name=John%20Doe&age=30&country=US')\nprint(decoded)\n# Output would be something like: [('name', 'John Doe'), ('age', '30'), ('country', 'US')]", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef decode(s): [MASK]\n"}
{"method_name": "hostport", "full_method_name": "hostport", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)", "test_code_list": [{"test_code": "from typing import AnyStr\nimport pytest\ndef test_hostport():\n    assert hostport(b'https', b'foo.com', 8080) == b'foo.com:8080'\n\ntest_hostport()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_url.py"}], "instruction": "Functionality: The function 'hostport' is designed to return the host component of a URL with a port specification if the port does not match the default port for the given scheme. It takes into account the scheme, host, and port to determine if the port number needs to be appended to the host.\n\nInputs: \n- scheme: The scheme part of the URL, which can be either a string or bytes. This is used to determine the default port associated with the scheme (i.e., 'http' or 'https').\n- host: The host component of the URL, which can be either a string or bytes.\n- port: An integer representing the port number. This is compared against the default port for the scheme to determine if it should be included in the output.\n\nOutputs:\n- A string or bytes representation of the host component, potentially with the port number appended to it. The output's type will match the type of the 'host' input. The port is only included if it is not the default port for the scheme.", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\n\n\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr: [MASK]\n"}
{"method_name": "get_by_shortcut", "full_method_name": "get_by_shortcut", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/user_agents.py", "method_code": "UASTRINGS = [('android', 'a',\n    'Mozilla/5.0 (Linux; U; Android 4.1.1; en-gb; Nexus 7 Build/JRO03D) AFL/01.04.02'\n    ), ('blackberry', 'l',\n    'Mozilla/5.0 (BlackBerry; U; BlackBerry 9900; en) AppleWebKit/534.11+ (KHTML, like Gecko) Version/7.1.0.346 Mobile Safari/534.11+'\n    ), ('bingbot', 'b',\n    'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)'\n    ), ('chrome', 'c',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1'\n    ), ('firefox', 'f',\n    'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:14.0) Gecko/20120405 Firefox/14.0a1'\n    ), ('googlebot', 'g',\n    'Googlebot/2.1 (+http://www.googlebot.com/bot.html)'), ('ie9', 'i',\n    'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)'), ('ipad',\n    'p',\n    'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'\n    ), ('iphone', 'h',\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 4_2_1 like Mac OS X) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148a Safari/6533.18.5'\n    ), ('safari', 's',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10'\n    )]\ndef get_by_shortcut(s):\n    \"\"\"\n    Retrieve a user agent entry by shortcut.\n    \"\"\"\n    for i in UASTRINGS:\n        if s == i[1]:\n            return i", "test_code_list": [{"test_code": "def test_get_shortcut():\n    assert get_by_shortcut('c')[0] == 'chrome'\n    assert not get_by_shortcut('_')\n\ntest_get_shortcut()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_user_agents.py"}], "instruction": "Functionality: The get_by_shortcut function is designed to locate and return a specific user agent entry from a predefined list, UASTRINGS, based on a provided shortcut. Each entry in UASTRINGS consists of a platform name, a shortcut, and a user agent string. The function searches for the given shortcut within the entries and returns the entire entry if the shortcut is found.\n\nInputs: \n- s: A string representing the shortcut used to identify the desired user agent entry. This string is case-sensitive and must match exactly one of the shortcuts defined within the UASTRINGS list.\n\nOutputs:\n- If the shortcut matches one of the entries in UASTRINGS, the function returns a tuple containing the platform name, the shortcut, and the user agent string.\n- If the shortcut does not match any entries, the function returns None.", "method_code_mask": "UASTRINGS = [('android', 'a',\n    'Mozilla/5.0 (Linux; U; Android 4.1.1; en-gb; Nexus 7 Build/JRO03D) AFL/01.04.02'\n    ), ('blackberry', 'l',\n    'Mozilla/5.0 (BlackBerry; U; BlackBerry 9900; en) AppleWebKit/534.11+ (KHTML, like Gecko) Version/7.1.0.346 Mobile Safari/534.11+'\n    ), ('bingbot', 'b',\n    'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)'\n    ), ('chrome', 'c',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1'\n    ), ('firefox', 'f',\n    'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:14.0) Gecko/20120405 Firefox/14.0a1'\n    ), ('googlebot', 'g',\n    'Googlebot/2.1 (+http://www.googlebot.com/bot.html)'), ('ie9', 'i',\n    'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)'), ('ipad',\n    'p',\n    'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'\n    ), ('iphone', 'h',\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 4_2_1 like Mac OS X) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148a Safari/6533.18.5'\n    ), ('safari', 's',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10'\n    )]\n\n\ndef get_by_shortcut(s): [MASK]\n"}
{"method_name": "_read_quoted_string", "full_method_name": "_read_quoted_string", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/cookies.py", "method_code": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1", "test_code_list": [{"test_code": "import time\nfrom unittest import mock\nimport pytest\ndef test_read_quoted_string():\n    tokens = [[('\"foo\" x', 0), ('foo', 5)], [('\"f\\\\oo\" x', 0), ('foo', 6)],\n        [('\"f\\\\\\\\o\" x', 0), ('f\\\\o', 6)], [('\"f\\\\\\\\\" x', 0), ('f' + '\\\\', 5\n        )], [('\"fo\\\\\"\" x', 0), ('fo\"', 6)], [('\"foo\" x', 7), ('', 8)]]\n    for q, a in tokens:\n        assert _read_quoted_string(*q) == a\n\ntest_read_quoted_string()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_cookies.py"}], "instruction": "Functionality: The function '_read_quoted_string' is designed to parse a quoted string from a given string 's', starting from the index 'start'. It adheres to a loose super-set of quoted string specifications, allowing backslashes for escaping characters within the string, which ensures compatibility with various quoted string interpretations. The function continues to read characters until it encounters the closing quote or the end of the string.\n\nInputs: \n- s: A string from which the quoted string will be read.\n- start: An integer representing the offset to the first quote of the string to be read.\n\nOutputs: \n- A tuple where the first element is the extracted quoted string (without the surrounding quotes) and the second element is the index in 's' immediately after the closing quote.", "method_code_mask": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\n\n\ndef _read_quoted_string(s, start): [MASK]\n"}
{"method_name": "_read_cookie_pairs", "full_method_name": "_read_cookie_pairs", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/cookies.py", "method_code": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1\ndef _read_value(s, start, delims):\n    \"\"\"\n    Reads a value - the RHS of a token/value pair in a cookie.\n    \"\"\"\n    if start >= len(s):\n        return '', start\n    elif s[start] == '\"':\n        return _read_quoted_string(s, start)\n    else:\n        return _read_until(s, start, delims)\ndef _read_until(s, start, term):\n    \"\"\"\n    Read until one of the characters in term is reached.\n    \"\"\"\n    if start == len(s):\n        return '', start + 1\n    for i in range(start, len(s)):\n        if s[i] in term:\n            return s[start:i], i\n    return s[start:i + 1], i + 1\ndef _read_key(s, start, delims=';='):\n    \"\"\"\n    Read a key - the LHS of a token/value pair in a cookie.\n    \"\"\"\n    return _read_until(s, start, delims)\ndef _read_cookie_pairs(s, off=0):\n    \"\"\"\n    Read pairs of lhs=rhs values from Cookie headers.\n    off: start offset\n    \"\"\"\n    pairs = []\n    while True:\n        lhs, off = _read_key(s, off)\n        lhs = lhs.lstrip()\n        rhs = ''\n        if off < len(s) and s[off] == '=':\n            rhs, off = _read_value(s, off + 1, ';')\n        if rhs or lhs:\n            pairs.append([lhs, rhs])\n        off += 1\n        if not off < len(s):\n            break\n    return pairs, off", "test_code_list": [{"test_code": "import time\nfrom unittest import mock\nimport pytest\ndef test_read_cookie_pairs():\n    vals = [['=uno', [['', 'uno']]], ['one', [['one', '']]], ['one=two', [[\n        'one', 'two']]], ['one=', [['one', '']]], ['one=\"two\"', [['one',\n        'two']]], ['one=\"two\"; three=four', [['one', 'two'], ['three',\n        'four']]], ['one=\"two\"; three=four; five', [['one', 'two'], [\n        'three', 'four'], ['five', '']]], ['one=\"\\\\\"two\"; three=four', [[\n        'one', '\"two'], ['three', 'four']]]]\n    for s, lst in vals:\n        ret, off = _read_cookie_pairs(s)\n        assert ret == lst\n\ntest_read_cookie_pairs()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/test_cookies.py"}], "instruction": "Functionality: The function _read_cookie_pairs is designed to parse string representations of HTTP Cookie headers into a list of key-value pairs. It reads through the string, identifies key-value pairs, and handles both quoted and unquoted values, including proper escaping of characters within quoted strings.\n\nInputs: \n- s: A string representing the Cookie header to be parsed.\n- off: An integer offset where the parsing should start from within the string. The default value is 0.\n\nOutputs:\n- pairs: A list of lists, where each inner list contains two strings. The first string is the key (left-hand side), and the second string is the value (right-hand side) from the Cookie header.\n- off: An integer representing the final offset in the string after parsing. This indicates the position just after the last parsed character.", "method_code_mask": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\n\n\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1\n\n\ndef _read_value(s, start, delims):\n    \"\"\"\n    Reads a value - the RHS of a token/value pair in a cookie.\n    \"\"\"\n    if start >= len(s):\n        return '', start\n    elif s[start] == '\"':\n        return _read_quoted_string(s, start)\n    else:\n        return _read_until(s, start, delims)\n\n\ndef _read_until(s, start, term):\n    \"\"\"\n    Read until one of the characters in term is reached.\n    \"\"\"\n    if start == len(s):\n        return '', start + 1\n    for i in range(start, len(s)):\n        if s[i] in term:\n            return s[start:i], i\n    return s[start:i + 1], i + 1\n\n\ndef _read_key(s, start, delims=';='):\n    \"\"\"\n    Read a key - the LHS of a token/value pair in a cookie.\n    \"\"\"\n    return _read_until(s, start, delims)\n\n\ndef _read_cookie_pairs(s, off=0): [MASK]\n"}
{"method_name": "_read_response_line", "full_method_name": "_read_response_line", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/http1/read.py", "method_code": "import re\nimport time\nfrom collections.abc import Iterable\ndef raise_if_http_version_unknown(http_version: bytes) ->None:\n    if not re.match(b'^HTTP/\\\\d\\\\.\\\\d$', http_version):\n        raise ValueError(f'Unknown HTTP version: {http_version!r}')\ndef _read_response_line(line: bytes) ->tuple[bytes, int, bytes]:\n    try:\n        parts = line.split(None, 2)\n        if len(parts) == 2:\n            parts.append(b'')\n        http_version, status_code_str, reason = parts\n        status_code = int(status_code_str)\n        raise_if_http_version_unknown(http_version)\n    except ValueError as e:\n        raise ValueError(f'Bad HTTP response line: {line!r}') from e\n    return http_version, status_code, reason", "test_code_list": [{"test_code": "import pytest\ndef test_read_response_line():\n\n    def t(b):\n        return _read_response_line(b)\n    assert t(b'HTTP/1.1 200 OK') == (b'HTTP/1.1', 200, b'OK')\n    assert t(b'HTTP/1.1 200') == (b'HTTP/1.1', 200, b'')\n    assert t(b'HTTP/1.1 200 Non-Autoris\\xc3\\xa9') == (b'HTTP/1.1', 200,\n        b'Non-Autoris\\xc3\\xa9')\n    with pytest.raises(ValueError):\n        assert t(b'HTTP/1.1')\n    with pytest.raises(ValueError):\n        t(b'HTTP/1.1 OK OK')\n    with pytest.raises(ValueError):\n        t(b'WTF/1.1 200 OK')\n    with pytest.raises(ValueError):\n        t(b'')\n\ntest_read_response_line()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/http/http1/test_read.py"}], "instruction": "Functionality: The _read_response_line function is designed to parse a single line from an HTTP response message. It expects the line to follow the format of an HTTP response status line, which includes the HTTP version, the status code, and an optional reason phrase, all separated by spaces. The function aims to extract these components and validate the HTTP version.\n\nInputs: \n- line: A bytes object representing the HTTP response line that needs to be parsed. The line should start with the HTTP version followed by the status code and an optional reason phrase.\n\nOutputs:\n- http_version: A bytes object containing the HTTP version from the input line.\n- status_code: An integer representing the status code from the input line.\n- reason: A bytes object containing the reason phrase from the input line, if present. If no reason phrase is found, it returns an empty bytes object.\n\nThe function performs the following steps:\n1. Splits the input line into parts based on spaces, allowing for a maximum of two splits to ensure that the HTTP version, status code, and reason phrase are correctly identified.\n2. If the line contains only two parts, it adds an empty bytes object as the reason phrase.\n3. Attempts to convert the status code string into an integer.\n4. Validates the HTTP version using the raise_if_http_version_unknown function, which raises a ValueError if the version does not match the expected format.\n5. Returns the extracted HTTP version, status code, and reason phrase as a tuple.\n\nIf the input line does not conform to the expected format, the function will raise a ValueError with a descriptive message.", "method_code_mask": "import re\nimport time\nfrom collections.abc import Iterable\n\n\ndef raise_if_http_version_unknown(http_version: bytes) ->None:\n    if not re.match(b'^HTTP/\\\\d\\\\.\\\\d$', http_version):\n        raise ValueError(f'Unknown HTTP version: {http_version!r}')\n\n\ndef _read_response_line(line: bytes) ->tuple[bytes, int, bytes]: [MASK]\n"}
{"method_name": "unpack", "full_method_name": "unpack", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/dns/domain_names.py", "method_code": "import struct\nfrom typing import Optional\ndef _unpack_label_into(labels: list[str], buffer: bytes, offset: int) ->int:\n    size, = _LABEL_SIZE.unpack_from(buffer, offset)\n    if size >= 64:\n        raise struct.error(f'unpack encountered a label of length {size}')\n    elif size == 0:\n        return _LABEL_SIZE.size\n    else:\n        offset += _LABEL_SIZE.size\n        end_label = offset + size\n        if len(buffer) < end_label:\n            raise struct.error(\n                f'unpack requires a label buffer of {size} bytes')\n        try:\n            labels.append(buffer[offset:end_label].decode('idna'))\n        except UnicodeDecodeError:\n            raise struct.error(\n                f'unpack encountered an illegal characters at offset {offset}')\n        return _LABEL_SIZE.size + size\n_POINTER_INDICATOR = 192\n_LABEL_SIZE = struct.Struct('!B')\ndef unpack_from(buffer: bytes, offset: int) ->tuple[str, int]:\n    \"\"\"Converts RDATA into a domain name without pointer compression from a given offset and also returns the binary size.\"\"\"\n    labels: list[str] = []\n    while True:\n        size, = _LABEL_SIZE.unpack_from(buffer, offset)\n        if size & _POINTER_INDICATOR == _POINTER_INDICATOR:\n            raise struct.error(\n                f'unpack encountered a pointer which is not supported in RDATA'\n                )\n        else:\n            offset += _unpack_label_into(labels, buffer, offset)\n            if size == 0:\n                break\n    return '.'.join(labels), offset\ndef unpack(buffer: bytes) ->str:\n    \"\"\"Converts RDATA into a domain name without pointer compression.\"\"\"\n    name, length = unpack_from(buffer, 0)\n    if length != len(buffer):\n        raise struct.error(f'unpack requires a buffer of {length} bytes')\n    return name", "test_code_list": [{"test_code": "import re\nimport struct\nimport pytest\ndef test_unpack():\n    assert unpack(b'\\x03www\\x07example\\x03org\\x00'\n        ) == 'www.example.org'\n    with pytest.raises(struct.error, match=re.escape(\n        'unpack requires a buffer of 17 bytes')):\n        unpack(b'\\x03www\\x07example\\x03org\\x00\\xff')\n    with pytest.raises(struct.error, match=re.escape(\n        'unpack encountered a pointer which is not supported in RDATA')):\n        unpack(b'\\x03www\\x07example\\x03org\\xc0\\x00')\n    with pytest.raises(struct.error, match=re.escape(\n        'unpack requires a label buffer of 10 bytes')):\n        unpack(b'\\n')\n    with pytest.raises(struct.error, match=re.escape(\n        'unpack encountered a label of length 64')):\n        unpack(b'@' + b'a' * 64 + b'\\x00')\n    with pytest.raises(struct.error, match=re.escape(\n        'unpack encountered an illegal characters at offset 1')):\n        unpack(b'\\x03\\xff\\xff\\xff\\x00')\n\ntest_unpack()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/dns/test_domain_names.py"}], "instruction": "Functionality: The function 'unpack' is designed to convert Resource Data (RDATA) into a domain name without using pointer compression. This function reads a byte buffer from the beginning and returns the domain name as a string. It ensures that the entire buffer is used for the conversion and does not support pointer compression, which is a technique used in DNS to reduce the size of domain name records.\n\nInputs: \n- buffer: A bytes object containing the RDATA to be converted into a domain name.\n\nOutputs: \n- A string representing the domain name unpacked from the provided RDATA. If the length of the buffer does not match the required size for the unpacking process, a struct.error is raised.\n\nNote: The function does not support pointers, a common feature in DNS for compressing domain names, and thus is expected to work only with fully expanded domain names.", "method_code_mask": "import struct\nfrom typing import Optional\n\n\ndef _unpack_label_into(labels: list[str], buffer: bytes, offset: int) ->int:\n    size, = _LABEL_SIZE.unpack_from(buffer, offset)\n    if size >= 64:\n        raise struct.error(f'unpack encountered a label of length {size}')\n    elif size == 0:\n        return _LABEL_SIZE.size\n    else:\n        offset += _LABEL_SIZE.size\n        end_label = offset + size\n        if len(buffer) < end_label:\n            raise struct.error(\n                f'unpack requires a label buffer of {size} bytes')\n        try:\n            labels.append(buffer[offset:end_label].decode('idna'))\n        except UnicodeDecodeError:\n            raise struct.error(\n                f'unpack encountered an illegal characters at offset {offset}')\n        return _LABEL_SIZE.size + size\n\n\n_POINTER_INDICATOR = 192\n_LABEL_SIZE = struct.Struct('!B')\n\n\ndef unpack_from(buffer: bytes, offset: int) ->tuple[str, int]:\n    \"\"\"Converts RDATA into a domain name without pointer compression from a given offset and also returns the binary size.\"\"\"\n    labels: list[str] = []\n    while True:\n        size, = _LABEL_SIZE.unpack_from(buffer, offset)\n        if size & _POINTER_INDICATOR == _POINTER_INDICATOR:\n            raise struct.error(\n                f'unpack encountered a pointer which is not supported in RDATA'\n                )\n        else:\n            offset += _unpack_label_into(labels, buffer, offset)\n            if size == 0:\n                break\n    return '.'.join(labels), offset\n\n\ndef unpack(buffer: bytes) ->str: [MASK]\n"}
{"method_name": "pack", "full_method_name": "pack", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/dns/domain_names.py", "method_code": "import struct\nfrom typing import Optional\n_LABEL_SIZE = struct.Struct('!B')\ndef pack(name: str) ->bytes:\n    \"\"\"Converts a domain name into RDATA without pointer compression.\"\"\"\n    buffer = bytearray()\n    if len(name) > 0:\n        for part in name.split('.'):\n            label = part.encode('idna')\n            size = len(label)\n            if size == 0:\n                raise ValueError(f\"domain name '{name}' contains empty labels\")\n            if size >= 64:\n                raise ValueError(\n                    f\"encoded label '{part}' of domain name '{name}' is too long ({size} bytes)\"\n                    )\n            buffer.extend(_LABEL_SIZE.pack(size))\n            buffer.extend(label)\n    buffer.extend(_LABEL_SIZE.pack(0))\n    return bytes(buffer)", "test_code_list": [{"test_code": "import re\nimport struct\nimport pytest\ndef test_pack():\n    assert pack('') == b'\\x00'\n    with pytest.raises(ValueError, match=re.escape(\n        \"domain name 'hello..world' contains empty labels\")):\n        pack('hello..world')\n    label = 'a' * 64\n    name = f'www.{label}.com'\n    with pytest.raises(ValueError, match='label too long'):\n        pack(name)\n    assert pack('www.example.org'\n        ) == b'\\x03www\\x07example\\x03org\\x00'\n\ntest_pack()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/net/dns/test_domain_names.py"}], "instruction": "Functionality: The function 'pack' is responsible for converting a domain name into Resource Data (RDATA) format without using pointer compression. This process involves splitting the domain name into its components, encoding each part, and packing the lengths and the encoded parts into a byte format suitable for DNS messages.\n\nInputs: The function takes a single argument:\n- name: A string representing the domain name to be packed. The domain name must not contain empty labels and each label must not exceed 63 bytes when encoded.\n\nOutputs: The function returns a bytes object:\n- Returns a bytes object containing the packed domain name. This output is suitable for use in DNS messages or other contexts where domain names are sent as binary data. If the domain name contains invalid parts (empty labels or labels longer than 63 bytes), the function will raise a ValueError with an appropriate error message.", "method_code_mask": "import struct\nfrom typing import Optional\n_LABEL_SIZE = struct.Struct('!B')\n\n\ndef pack(name: str) ->bytes: [MASK]\n"}
{"method_name": "format_timestamp", "full_method_name": "format_timestamp", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef format_timestamp(s):\n    s = time.localtime(s)\n    d = datetime.datetime.fromtimestamp(time.mktime(s))\n    return d.strftime('%Y-%m-%d %H:%M:%S')", "test_code_list": [{"test_code": "import time\nimport pytest\ndef test_format_timestamp():\n    assert format_timestamp(time.time())\n\ntest_format_timestamp()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_human.py"}], "instruction": "Functionality: The function 'format_timestamp' is designed to convert a given timestamp into a human-readable format. It takes a timestamp (typically a value representing the number of seconds since the Unix epoch, 1970-01-01 00:00:00 UTC) and converts it into a string representing the date and time in the format 'YYYY-MM-DD HH:MM:SS'. The function first converts the timestamp into a local time using the 'time.localtime' function, then it uses the 'datetime.datetime.fromtimestamp' method to create a datetime object from the timestamp, and finally, it formats this datetime object into the specified format using 'datetime.strftime'.\n\nInputs: The function expects a single argument 's', which is a numerical value representing a timestamp.\n\nOutputs: The function returns a string in the format 'YYYY-MM-DD HH:MM:SS' representing the date and time corresponding to the input timestamp 's'.", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef format_timestamp(s): [MASK]\n"}
{"method_name": "format_timestamp_with_milli", "full_method_name": "format_timestamp_with_milli", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef format_timestamp_with_milli(s):\n    d = datetime.datetime.fromtimestamp(s)\n    return d.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]", "test_code_list": [{"test_code": "import time\nimport pytest\ndef test_format_timestamp_with_milli():\n    assert format_timestamp_with_milli(time.time())\n\ntest_format_timestamp_with_milli()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_human.py"}], "instruction": "Functionality: The function 'format_timestamp_with_milli' is designed to convert a given timestamp into a human-readable format, including milliseconds. It takes a timestamp as input, converts it into a datetime object, and then formats this datetime object into a string that represents the date and time in the format 'YYYY-MM-DD HH:MM:SS.milliseconds'. The milliseconds are represented with three digits precision.\n\nInputs: \n- s: A floating-point number representing the timestamp in seconds since the Unix epoch (1970-01-01 00:00:00 UTC). This is the only input to the function.\n\nOutputs: \n- A string: The output is a string representing the formatted date and time, including milliseconds. The format will be 'YYYY-MM-DD HH:MM:SS.milliseconds', where milliseconds are represented by three digits.", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef format_timestamp_with_milli(s): [MASK]\n"}
{"method_name": "pretty_size", "full_method_name": "pretty_size", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef pretty_size(size: int) ->str:\n    \"\"\"Convert a number of bytes into a human-readable string.\n\n    len(return value) <= 5 always holds true.\n    \"\"\"\n    s: float = size\n    if s < 1024:\n        return f'{s}b'\n    for suffix in ['k', 'm', 'g', 't']:\n        s /= 1024\n        if s < 99.95:\n            return f'{s:.1f}{suffix}'\n        if s < 1024 or suffix == 't':\n            return f'{s:.0f}{suffix}'\n    raise AssertionError", "test_code_list": [{"test_code": "import time\nimport pytest\ndef test_pretty_size():\n    assert pretty_size(0) == '0b'\n    assert pretty_size(100) == '100b'\n    assert pretty_size(1024) == '1.0k'\n    assert pretty_size(1024 + 512) == '1.5k'\n    assert pretty_size(1024 * 1024) == '1.0m'\n    assert pretty_size(10 * 1024 * 1024) == '10.0m'\n    assert pretty_size(100 * 1024 * 1024) == '100m'\n\ntest_pretty_size()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_human.py"}], "instruction": "Functionality: \nThe function 'pretty_size' takes a number of bytes as input and converts it into a human-readable string, abbreviating the size with standard binary unit prefixes (k for kilobytes, m for megabytes, g for gigabytes, t for terabytes), and rounding the result to fit within 5 characters. It ensures that the returned string's length is always less than or equal to 5.\n\nInputs: \nsize: int\nThe size in bytes to be converted. It is a non-negative integer.\n\nOutputs: \nstr\nThe human-readable representation of the size, which includes the size value rounded to fit within 5 characters and a suffix ('b' for bytes, 'k' for kilobytes, 'm' for megabytes, 'g' for gigabytes, 't' for terabytes).", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef pretty_size(size: int) ->str: [MASK]\n"}
{"method_name": "typespec_to_str", "full_method_name": "typespec_to_str", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/typecheck.py", "method_code": "import typing\nfrom collections import abc\ndef typespec_to_str(typespec: typing.Any) ->str:\n    if typespec in (str, int, float, bool):\n        t = typespec.__name__\n    elif typespec == typing.Optional[str]:\n        t = 'optional str'\n    elif typespec in (typing.Sequence[str], abc.Sequence[str]):\n        t = 'sequence of str'\n    elif typespec == typing.Optional[int]:\n        t = 'optional int'\n    else:\n        raise NotImplementedError\n    return t", "test_code_list": [{"test_code": "import io\nimport typing\nfrom collections.abc import Sequence\nfrom typing import Any\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nimport pytest\ndef test_typesec_to_str():\n    assert typespec_to_str(str) == 'str'\n    assert typespec_to_str(Sequence[str]) == 'sequence of str'\n    assert typespec_to_str(Optional[str]) == 'optional str'\n    assert typespec_to_str(Optional[int]) == 'optional int'\n    with pytest.raises(NotImplementedError):\n        typespec_to_str(dict)\n\ntest_typesec_to_str()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_typecheck.py"}], "instruction": "Functionality: The function 'typespec_to_str' is designed to take a type specification as an input and convert it into a human-readable string format. This functionality is particularly useful for debugging and logging purposes, as it can translate complex type hints into understandable strings.\n\nInputs: The input to the function is a single argument 'typespec', which can be of any type. This argument represents the type specification that needs to be converted into a string format. The function is designed to handle basic Python data types, sequences of strings, and optional types.\n\nOutputs: The function returns a string that represents the human-readable format of the input type specification. For example, if the input 'typespec' is the data type 'str', the function will return the string 'str'. If the input 'typespec' is 'typing.Optional[str]', the function will return 'optional str', and so on. If the input type specification is not recognized by the function, it will raise a 'NotImplementedError'.", "method_code_mask": "import typing\nfrom collections import abc\n\n\ndef typespec_to_str(typespec: typing.Any) ->str: [MASK]\n"}
{"method_name": "bytes_to_escaped_str", "full_method_name": "bytes_to_escaped_str", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef bytes_to_escaped_str(data: bytes, keep_spacing: bool=False,\n    escape_single_quotes: bool=False) ->str:\n    \"\"\"\n    Take bytes and return a safe string that can be displayed to the user.\n\n    Single quotes are always escaped, double quotes are never escaped:\n        \"'\" + bytes_to_escaped_str(...) + \"'\"\n    gives a valid Python string.\n\n    Args:\n        keep_spacing: If True, tabs and newlines will not be escaped.\n    \"\"\"\n    if not isinstance(data, bytes):\n        raise ValueError(\n            f'data must be bytes, but is {data.__class__.__name__}')\n    ret = repr(b'\"' + data).lstrip('b')[2:-1]\n    if not escape_single_quotes:\n        ret = re.sub(\"(?<!\\\\\\\\)(\\\\\\\\\\\\\\\\)*\\\\\\\\'\", lambda m: (m.group(1) or\n            '') + \"'\", ret)\n    if keep_spacing:\n        ret = re.sub('(?<!\\\\\\\\)(\\\\\\\\\\\\\\\\)*\\\\\\\\([nrt])', lambda m: (m.group(\n            1) or '') + dict(n='\\n', r='\\r', t='\\t')[m.group(2)], ret)\n    return ret", "test_code_list": [{"test_code": "import pytest\ndef test_bytes_to_escaped_str():\n    assert bytes_to_escaped_str(b'foo') == 'foo'\n    assert bytes_to_escaped_str(b'\\x08') == '\\\\x08'\n    assert bytes_to_escaped_str(b'&!?=\\\\)') == '&!?=\\\\\\\\)'\n    assert bytes_to_escaped_str(b'\\xc3\\xbc') == '\\\\xc3\\\\xbc'\n    assert bytes_to_escaped_str(b\"'\") == \"'\"\n    assert bytes_to_escaped_str(b'\"') == '\"'\n    assert bytes_to_escaped_str(b\"'\", escape_single_quotes=True\n        ) == \"\\\\'\"\n    assert bytes_to_escaped_str(b'\"', escape_single_quotes=True\n        ) == '\"'\n    assert bytes_to_escaped_str(b'\\r\\n\\t') == '\\\\r\\\\n\\\\t'\n    assert bytes_to_escaped_str(b'\\r\\n\\t', True) == '\\r\\n\\t'\n    assert bytes_to_escaped_str(b'\\n', True) == '\\n'\n    assert bytes_to_escaped_str(b'\\\\n', True) == '\\\\ \\\\ n'.replace(' '\n        , '')\n    assert bytes_to_escaped_str(b'\\\\\\n', True) == '\\\\ \\\\ \\n'.replace(\n        ' ', '')\n    assert bytes_to_escaped_str(b'\\\\\\\\n', True\n        ) == '\\\\ \\\\ \\\\ \\\\ n'.replace(' ', '')\n    with pytest.raises(ValueError):\n        bytes_to_escaped_str('such unicode')\n\ntest_bytes_to_escaped_str()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_strutils.py"}], "instruction": "Functionality: The function bytes_to_escaped_str takes a bytes object and converts it into a safe string representation that can be displayed to the user. This function ensures that the output string can be safely embedded in a Python string by always escaping single quotes, while never escaping double quotes. The output string is designed to be enclosed in single quotes to form a valid Python string. Additionally, the function provides options to control whether spacing characters like tabs and newlines are preserved or escaped.\n\nInputs: \n- data: A bytes object representing the data to be converted into a safe string.\n- keep_spacing: A boolean flag indicating whether spacing characters (tabs, newlines) should be preserved in their original form (True) or escaped (False). Default is False.\n- escape_single_quotes: A boolean flag indicating whether single quotes should be escaped in the output string. Default is False.\n\nOutputs:\n- A string representation of the input bytes, formatted in a way that it can be safely embedded into a Python string literal. The string will have single quotes escaped if escape_single_quotes is True, and will preserve or escape spacing characters based on the keep_spacing flag.", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef bytes_to_escaped_str(data: bytes, keep_spacing: bool=False,\n    escape_single_quotes: bool=False) ->str: [MASK]\n"}
{"method_name": "escaped_str_to_bytes", "full_method_name": "escaped_str_to_bytes", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef escaped_str_to_bytes(data: str) ->bytes:\n    \"\"\"\n    Take an escaped string and return the unescaped bytes equivalent.\n\n    Raises:\n        ValueError, if the escape sequence is invalid.\n    \"\"\"\n    if not isinstance(data, str):\n        raise ValueError(f'data must be str, but is {data.__class__.__name__}')\n    return codecs.escape_decode(data)[0]", "test_code_list": [{"test_code": "import pytest\ndef test_escaped_str_to_bytes():\n    assert escaped_str_to_bytes('foo') == b'foo'\n    assert escaped_str_to_bytes('\\x08') == b'\\x08'\n    assert escaped_str_to_bytes('&!?=\\\\\\\\)') == b'&!?=\\\\)'\n    assert escaped_str_to_bytes('\\\\x08') == b'\\x08'\n    assert escaped_str_to_bytes('&!?=\\\\\\\\)') == b'&!?=\\\\)'\n    assert escaped_str_to_bytes('\u00fc') == b'\\xc3\\xbc'\n    with pytest.raises(ValueError):\n        escaped_str_to_bytes(b'very byte')\n\ntest_escaped_str_to_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_strutils.py"}], "instruction": "Functionality: The function \"escaped_str_to_bytes\" is designed to convert a given escaped string into its unescaped bytes representation. It handles various escape sequences, providing a direct conversion to the corresponding byte sequence. The function throws a ValueError if the input is not a string or if the escape sequence is invalid.\n\nInputs: \n- data: A string (str) that contains an escaped sequence. The input must be of type str; otherwise, a ValueError is raised.\n\nOutputs:\n- Returns a bytes object that represents the unescaped version of the input string. The returned bytes are the direct result of decoding the escape sequences within the input string. If the escape sequence is invalid, a ValueError is raised.", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef escaped_str_to_bytes(data: str) ->bytes: [MASK]\n"}
{"method_name": "is_mostly_bin", "full_method_name": "is_mostly_bin", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef is_mostly_bin(s: bytes) ->bool:\n    if not s or len(s) == 0:\n        return False\n    return sum(i < 9 or 13 < i < 32 or 126 < i for i in s[:100]) / len(s[:100]\n        ) > 0.3", "test_code_list": [{"test_code": "import pytest\ndef test_is_mostly_bin():\n    assert not is_mostly_bin(b'foo\\xff')\n    assert is_mostly_bin(b'foo' + b'\\xff' * 10)\n    assert not is_mostly_bin('')\n\ntest_is_mostly_bin()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_strutils.py"}], "instruction": "Functionality: The function 'is_mostly_bin' is designed to determine whether a given byte string is mostly composed of binary data. This is achieved by analyzing the first 100 bytes of the input and checking if more than 30% of these bytes fall within the range of non-printable characters. In computing, non-printable characters typically include control characters, which are not meant for human readability.\n\nInputs: The input to this function is a byte string (s), which is a sequence of bytes that can represent any kind of data, including text, images, or binary files. The function is capable of handling byte strings of any length, but it only analyzes the first 100 bytes for efficiency and to provide a quick indication of whether the data might be binary.\n\nOutputs: The function returns a boolean value. It returns 'True' if the input byte string is considered to be mostly binary, based on the criteria that more than 30% of the first 100 bytes are non-printable characters. Otherwise, it returns 'False'. This output can be used to filter data or to determine how to handle the data differently, depending on its expected content type.", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef is_mostly_bin(s: bytes) ->bool: [MASK]\n"}
{"method_name": "is_xml", "full_method_name": "is_xml", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef is_xml(s: bytes) ->bool:\n    for char in s:\n        if char in (9, 10, 32):\n            continue\n        return char == 60\n    return False", "test_code_list": [{"test_code": "import pytest\ndef test_is_xml():\n    assert not is_xml(b'')\n    assert not is_xml(b'foo')\n    assert is_xml(b'<foo')\n    assert is_xml(b'  \\n<foo')\n\ntest_is_xml()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_strutils.py"}], "instruction": ">>> is_xml(b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<root>\\n<item>text</item>\\n</root>')\nTrue\n>>> is_xml(b'Not an XML')\nFalse", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef is_xml(s: bytes) ->bool: [MASK]\n"}
{"method_name": "clean_hanging_newline", "full_method_name": "clean_hanging_newline", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef clean_hanging_newline(t):\n    \"\"\"\n    Many editors will silently add a newline to the final line of a\n    document (I'm looking at you, Vim). This function fixes this common\n    problem at the risk of removing a hanging newline in the rare cases\n    where the user actually intends it.\n    \"\"\"\n    if t and t[-1] == '\\n':\n        return t[:-1]\n    return t", "test_code_list": [{"test_code": "import pytest\ndef test_clean_hanging_newline():\n    s = 'foo\\n'\n    assert clean_hanging_newline(s) == 'foo'\n    assert clean_hanging_newline('foo') == 'foo'\n\ntest_clean_hanging_newline()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/utils/test_strutils.py"}], "instruction": "Functionality: The clean_hanging_newline function is designed to address a common issue where text editors, such as Vim, may add an unnecessary newline character at the end of a document. This function checks if the given string (t) ends with a newline character. If it does, the function removes this trailing newline character to clean up the text. However, if the string does not end with a newline, the function returns the string as it is, ensuring that no intended newline is removed.\n\nInputs: The function takes a single input argument, t, which is expected to be a string. This string could represent any text, including code, documents, or data, and may potentially end with a newline character.\n\nOutputs: The function returns a string. If the input string ends with a newline character, it returns the input string with the trailing newline removed. If the input string does not end with a newline character, it returns the input string unchanged.", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef clean_hanging_newline(t): [MASK]\n"}
{"method_name": "domain_match", "full_method_name": "domain_match", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/addons/stickycookie.py", "method_code": "import collections\nfrom http import cookiejar\nfrom typing import Optional\ndef domain_match(a: str, b: str) ->bool:\n    if cookiejar.domain_match(a, b):\n        return True\n    elif cookiejar.domain_match(a, b.strip('.')):\n        return True\n    return False", "test_code_list": [{"test_code": "import pytest\ndef test_domain_match():\n    assert domain_match('www.google.com', '.google.com')\n    assert domain_match('google.com', '.google.com')\n\ntest_domain_match()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/addons/test_stickycookie.py"}], "instruction": "Functionality: The domain_match function is designed to determine if two domain strings, a and b, match according to a set of rules similar to those used for cookies in HTTP. This is useful for scenarios where domain matching rules need to be applied, such as in web development or network communication. The function uses an internal mechanism that considers various cases, including exact matches and matches with or without a trailing dot.\n\nInputs: \n- a: A string representing the first domain to compare. This could be a fully qualified domain name (FQDN) or a domain name without a trailing dot.\n- b: A string representing the second domain to compare. This could also be an FQDN or a domain name without a trailing dot.\n\nOutputs: \n- A boolean value indicating whether the two domains match according to the defined rules. Returns True if the domains match, and False otherwise.", "method_code_mask": "import collections\nfrom http import cookiejar\nfrom typing import Optional\n\n\ndef domain_match(a: str, b: str) ->bool: [MASK]\n"}
{"method_name": "format_graphql", "full_method_name": "format_graphql", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/contentviews/graphql.py", "method_code": "import json\nfrom typing import Any\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)", "test_code_list": [{"test_code": "def test_format_graphql():\n    assert format_graphql({'query': 'query P { \\\\n }'})\n\ntest_format_graphql()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/contentviews/test_graphql.py"}], "instruction": "Functionality: The function 'format_graphql' is designed to format GraphQL queries by wrapping them into a standardized structure. This structure includes a header, which is a JSON representation of the input data with a placeholder for the query field, and the actual GraphQL query itself. The goal is to ensure that the GraphQL queries are presented in a consistent and readable format.\n\nInputs: \n- data: A dictionary containing a 'query' key with the GraphQL query as a string value, and any other relevant key-value pairs. The query is a string representing a GraphQL query.\n\nOutputs:\n- A string that consists of two parts: \n  1. A JSON-formatted header, where the 'query' field is replaced with '...', and all other fields are left intact. This header is indented for better readability.\n  2. The original GraphQL query, placed after a separator '---'. \n\nThe returned string combines the JSON-formatted header and the original GraphQL query, separated by '---\\n'. The header is formatted with an indentation of 2 spaces for better readability.", "method_code_mask": "import json\nfrom typing import Any\n\n\ndef format_graphql(data): [MASK]\n"}
{"method_name": "format_query_list", "full_method_name": "format_query_list", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/contentviews/graphql.py", "method_code": "import json\nfrom typing import Any\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)\ndef format_query_list(data: list[Any]):\n    num_queries = len(data) - 1\n    result = ''\n    for i, op in enumerate(data):\n        result += f'--- {i}/{num_queries}\\n'\n        result += format_graphql(op)\n    return result", "test_code_list": [{"test_code": "def test_format_query_list():\n    assert format_query_list([{'query': 'query P { \\\\n }'}])\n\ntest_format_query_list()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/test/mitmproxy/contentviews/test_graphql.py"}], "instruction": "Functionality: The format_query_list function takes a list of dictionaries, where each dictionary contains data for a GraphQL query. It formats each query into a human-readable string that includes a header with the query data (with the actual query string replaced by '...') and the query string itself. The function then concatenates all formatted queries into a single string, separated by a delimiter, and returns this string.\n\nInputs: \n- data: A list of dictionaries. Each dictionary represents data for a GraphQL query and includes at least the 'query' key with the query string as its value.\n\nOutputs:\n- A string that includes all the formatted queries concatenated together. Each formatted query is prefixed with a delimiter indicating its position in the list and followed by the formatted header and query string.", "method_code_mask": "import json\nfrom typing import Any\n\n\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)\n\n\ndef format_query_list(data: list[Any]): [MASK]\n"}
{"method_name": "randomString", "full_method_name": "randomString", "method_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/proxyauth_selenium.py", "method_code": "import abc\nimport logging\nimport random\nimport string\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom selenium import webdriver\ndef randomString(string_length=10):\n    \"\"\"Generate a random string of fixed length\"\"\"\n    letters = string.ascii_lowercase\n    return ''.join(random.choice(letters) for i in range(string_length))", "test_code_list": [{"test_code": "from unittest import mock\nfrom unittest.mock import MagicMock\nimport pytest\n\nclass TestRandomString():\n    def test_random_string(self):\n        res = randomString()\n        assert isinstance(res, str)\n        assert len(res) == 10\n        res_5 = randomString(5)\n        assert isinstance(res_5, str)\n        assert len(res_5) == 5\n    \nTestRandomString().test_random_string()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/test_proxyauth_selenium.py"}], "instruction": "Functionality: The function 'randomString' is designed to generate a random string of a specified length. It uses the python random and string modules to create a string comprised of lowercase letters from the English alphabet. The function aims to provide a simple and effective way to generate random strings, which can be useful for various applications such as testing, generating temporary passwords, or creating unique identifiers.\n\nInputs: \n1. string_length (optional): This is an integer argument that specifies the length of the string to be generated. If no argument is provided, the function defaults to generating a string of length 10.\n\nOutputs: \n1. A string of the specified length composed of random lowercase letters from the English alphabet. If the string_length argument is not provided, a string of length 10 will be returned.", "method_code_mask": "import abc\nimport logging\nimport random\nimport string\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom selenium import webdriver\n\n\ndef randomString(string_length=10): [MASK]\n"}
{"method_name": "default", "full_method_name": "SetEncoder.default", "method_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/urlindex.py", "method_code": "import abc\nimport datetime\nimport json\nimport logging\nfrom pathlib import Path\nclass SetEncoder(json.JSONEncoder):\n\n    def default(self, obj):\n        if isinstance(obj, set):\n            return list(obj)\n        return json.JSONEncoder.default(self, obj)", "test_code_list": [{"test_code": "import json\nfrom json import JSONDecodeError\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest.mock import patch\n\nclass TestSetEncoder():\n    def test_set_encoder_set(self):\n        test_set = {'foo', 'bar', '42'}\n        result = SetEncoder.default(SetEncoder(), test_set)\n        assert isinstance(result, list)\n        assert 'foo' in result\n        assert 'bar' in result\n        assert '42' in result\n    \nTestSetEncoder().test_set_encoder_set()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/test_urlindex.py"}, {"test_code": "import json\nfrom json import JSONDecodeError\nfrom pathlib import Path\nfrom unittest import mock\nfrom unittest.mock import patch\n\nclass TestSetEncoder():\n    def test_set_encoder_str(self):\n        test_str = 'test'\n        try:\n            SetEncoder.default(SetEncoder(), test_str)\n        except TypeError:\n            assert True\n        else:\n            assert False\n    \nTestSetEncoder().test_set_encoder_str()\n", "code_start": "", "test_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/test_urlindex.py"}], "instruction": "Functionality: The SetEncoder.default function is designed to handle the serialization of set objects in JSON format. It is a part of the SetEncoder class, which extends the functionality of json.JSONEncoder. The main goal of this function is to convert set objects into a JSON-compatible format. This is achieved by transforming the set into a list, which can then be correctly serialized by JSON.\n\nInputs: The function takes a single argument, 'obj'. This argument is the object that needs to be encoded. It is the responsibility of the function to check if 'obj' is an instance of a set. If 'obj' is not a set, the function should delegate the encoding to the superclass implementation (i.e., json.JSONEncoder.default).\n\nOutputs: The function should return a list if 'obj' is a set, which represents the serialized form of the set. If 'obj' is not a set, the function should return the result of calling the superclass's default method, effectively delegating the encoding process to the superclass for other types of objects.", "method_code_mask": "import abc\nimport datetime\nimport json\nimport logging\nfrom pathlib import Path\n\n\nclass SetEncoder(json.JSONEncoder):\n\n    def default(self, obj): [MASK]\n"}
