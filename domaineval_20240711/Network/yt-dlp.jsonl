{"method_name": "timeconvert", "full_method_name": "timeconvert", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_timeconvert(self):\n        self.assertTrue(timeconvert('') is None)\n        self.assertTrue(timeconvert('bougrg') is None)\n    \nTestUtil().test_timeconvert()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function timeconvert is designed to parse and convert time strings formatted according to RFC 2822 standards into system timestamp values. This function is particularly useful for converting human-readable or network-transmitted time strings into a format that can be easily processed by the system.\n\nInputs: \n- timestr: A string representing a date and time as defined by RFC 2822. This string must conform to the RFC 2822 format, which includes the date, time, and timezone, and may come from sources such as email headers.\n\nOutputs:\n- timestamp: A floating-point number representing the system timestamp. This timestamp is based on the internal system clock and can be used for various time-related operations within the system. If the input string does not conform to the expected RFC 2822 format or cannot be parsed, the function will return None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef timeconvert(timestr): [MASK]\n"}
{"method_name": "sanitize_filename", "full_method_name": "sanitize_filename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass NO_DEFAULT:\n    pass\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    @param restricted   Use a stricter subset of allowed characters\n    @param is_id        Whether this is an ID that should be kept unchanged if possible.\n                        If unset, yt-dlp's new sanitization rules are in effect\n    \"\"\"\n    if s == '':\n        return ''\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        elif not restricted and char == '\\n':\n            return '\\x00 '\n        elif is_id is NO_DEFAULT and not restricted and char in '\"*:<>?|/\\\\':\n            return {'/': '\u29f8', '\\\\': '\u29f9'}.get(char, chr(ord(char) + 65248))\n        elif char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else \"'\"\n        elif char == ':':\n            return '\\x00_\\x00-' if restricted else '\\x00 \\x00-'\n        elif char in '\\\\/|*<>':\n            return '\\x00_'\n        if restricted and (char in \"!&'()[]{}$;`^,#\" or char.isspace() or\n            ord(char) > 127):\n            return '' if unicodedata.category(char)[0] in 'CM' else '\\x00_'\n        return char\n    if restricted and (is_id is NO_DEFAULT or not is_id):\n        s = unicodedata.normalize('NFKC', s)\n    s = re.sub('[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if is_id is NO_DEFAULT:\n        result = re.sub('(\\\\0.)(?:(?=\\\\1)..)+', '\\\\1', result)\n        STRIP_RE = '(?:\\\\0.|[ _-])*'\n        result = re.sub(f'^\\x00.{STRIP_RE}|{STRIP_RE}\\x00.$', '', result)\n    result = result.replace('\\x00', '') or '_'\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_sanitize_filename(self):\n        self.assertEqual(sanitize_filename(''), '')\n        self.assertEqual(sanitize_filename('abc'), 'abc')\n        self.assertEqual(sanitize_filename('abc_d-e'), 'abc_d-e')\n        self.assertEqual(sanitize_filename('123'), '123')\n        self.assertEqual('abc\u29f8de', sanitize_filename('abc/de'))\n        self.assertFalse('/' in sanitize_filename('abc/de///'))\n        self.assertEqual('abc_de', sanitize_filename('abc/<>\\\\*|de', is_id=False))\n        self.assertEqual('xxx', sanitize_filename('xxx/<>\\\\*|', is_id=False))\n        self.assertEqual('yes no', sanitize_filename('yes? no', is_id=False))\n        self.assertEqual('this - that', sanitize_filename('this: that', is_id=\n            False))\n        self.assertEqual(sanitize_filename('AT&T'), 'AT&T')\n        aumlaut = '\u00e4'\n        self.assertEqual(sanitize_filename(aumlaut), aumlaut)\n        tests = '\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430'\n        self.assertEqual(sanitize_filename(tests), tests)\n        self.assertEqual(sanitize_filename('New World record at 0:12:34'),\n            'New World record at 0_12_34')\n        self.assertEqual(sanitize_filename('--gasdgf'), '--gasdgf')\n        self.assertEqual(sanitize_filename('--gasdgf', is_id=True), '--gasdgf')\n        self.assertEqual(sanitize_filename('--gasdgf', is_id=False), '_-gasdgf')\n        self.assertEqual(sanitize_filename('.gasdgf'), '.gasdgf')\n        self.assertEqual(sanitize_filename('.gasdgf', is_id=True), '.gasdgf')\n        self.assertEqual(sanitize_filename('.gasdgf', is_id=False), 'gasdgf')\n        forbidden = '\"\\x00\\\\/'\n        for fc in forbidden:\n            for fbc in forbidden:\n                self.assertTrue(fbc not in sanitize_filename(fc))\n    \nTestUtil().test_sanitize_filename()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Sanitizes a string to ensure it is suitable for use in filenames by removing or replacing characters that are not allowed or could cause issues on various filesystems.\n\nInputs: \n1. s (str): The string to be sanitized.\n2. restricted (bool): Optional parameter to specify whether a stricter subset of allowed characters should be used. Default is False.\n3. is_id (NO_DEFAULT or bool): Optional parameter to indicate if the string is an ID that should be kept unchanged if possible. By default, it is set to NO_DEFAULT, which means yt-dlp's new sanitization rules are in effect.\n\nOutputs:\n1. str: The sanitized string, suitable for use in filenames, based on the input parameters and the sanitization rules applied.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass NO_DEFAULT:\n    pass\n\n\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT): [MASK]\n"}
{"method_name": "sanitize_filename", "full_method_name": "sanitize_filename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nACCENT_CHARS = dict(zip(\n    '\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n    itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'],\n    'UUUUUY', ['TH', 'ss'], 'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'],\n    'uuuuuy', ['th'], 'y')))\nclass NO_DEFAULT:\n    pass\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    @param restricted   Use a stricter subset of allowed characters\n    @param is_id        Whether this is an ID that should be kept unchanged if possible.\n                        If unset, yt-dlp's new sanitization rules are in effect\n    \"\"\"\n    if s == '':\n        return ''\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        elif not restricted and char == '\\n':\n            return '\\x00 '\n        elif is_id is NO_DEFAULT and not restricted and char in '\"*:<>?|/\\\\':\n            return {'/': '\u29f8', '\\\\': '\u29f9'}.get(char, chr(ord(char) + 65248))\n        elif char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else \"'\"\n        elif char == ':':\n            return '\\x00_\\x00-' if restricted else '\\x00 \\x00-'\n        elif char in '\\\\/|*<>':\n            return '\\x00_'\n        if restricted and (char in \"!&'()[]{}$;`^,#\" or char.isspace() or\n            ord(char) > 127):\n            return '' if unicodedata.category(char)[0] in 'CM' else '\\x00_'\n        return char\n    if restricted and (is_id is NO_DEFAULT or not is_id):\n        s = unicodedata.normalize('NFKC', s)\n    s = re.sub('[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if is_id is NO_DEFAULT:\n        result = re.sub('(\\\\0.)(?:(?=\\\\1)..)+', '\\\\1', result)\n        STRIP_RE = '(?:\\\\0.|[ _-])*'\n        result = re.sub(f'^\\x00.{STRIP_RE}|{STRIP_RE}\\x00.$', '', result)\n    result = result.replace('\\x00', '') or '_'\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_sanitize_filename_restricted(self):\n        self.assertEqual(sanitize_filename('abc', restricted=True), 'abc')\n        self.assertEqual(sanitize_filename('abc_d-e', restricted=True), 'abc_d-e')\n        self.assertEqual(sanitize_filename('123', restricted=True), '123')\n        self.assertEqual('abc_de', sanitize_filename('abc/de', restricted=True))\n        self.assertFalse('/' in sanitize_filename('abc/de///', restricted=True))\n        self.assertEqual('abc_de', sanitize_filename('abc/<>\\\\*|de', restricted\n            =True))\n        self.assertEqual('xxx', sanitize_filename('xxx/<>\\\\*|', restricted=True))\n        self.assertEqual('yes_no', sanitize_filename('yes? no', restricted=True))\n        self.assertEqual('this_-_that', sanitize_filename('this: that',\n            restricted=True))\n        tests = 'a\u00e4b\u4e2d\u56fd\u7684c'\n        self.assertEqual(sanitize_filename(tests, restricted=True), 'aab_c')\n        self.assertTrue(sanitize_filename('\u00f6', restricted=True) != '')\n        forbidden = '\"\\x00\\\\/&!: \\'\\t\\n()[]{}$;`^,#'\n        for fc in forbidden:\n            for fbc in forbidden:\n                self.assertTrue(fbc not in sanitize_filename(fc, restricted=True))\n        self.assertEqual(sanitize_filename('\u5927\u58f0\u5e26 - Song', restricted=True), 'Song')\n        self.assertEqual(sanitize_filename('\u603b\u7edf: Speech', restricted=True), 'Speech'\n            )\n        self.assertTrue(sanitize_filename('-', restricted=True) != '')\n        self.assertTrue(sanitize_filename(':', restricted=True) != '')\n        self.assertEqual(sanitize_filename(\n            '\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n            restricted=True),\n            'AAAAAAAECEEEEIIIIDNOOOOOOOOEUUUUUYTHssaaaaaaaeceeeeiiiionooooooooeuuuuuythy'\n            )\n    \nTestUtil().test_sanitize_filename_restricted()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_sanitize_ids(self):\n        self.assertEqual(sanitize_filename('_n_cd26wFpw', is_id=True),\n            '_n_cd26wFpw')\n        self.assertEqual(sanitize_filename('_BD_eEpuzXw', is_id=True),\n            '_BD_eEpuzXw')\n        self.assertEqual(sanitize_filename('N0Y__7-UOdI', is_id=True),\n            'N0Y__7-UOdI')\n    \nTestUtil().test_sanitize_ids()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The sanitize_filename function cleans a given string so it can be safely used as part of a filename. It removes or replaces characters that are not allowed or could cause issues in file systems.\n\nInputs: \n- s: A string that needs to be sanitized for use as a filename.\n- restricted: A boolean flag indicating whether to use a stricter subset of allowed characters (default is False).\n- is_id: A flag that indicates if the sanitized string is an ID that should be kept unchanged if possible. If NO_DEFAULT, yt-dlp's new sanitization rules are in effect (default is NO_DEFAULT).\n\nOutputs:\n- A sanitized string suitable for use as part of a filename. This string has characters replaced or removed according to the specified restrictions and rules.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nACCENT_CHARS = dict(zip(\n    '\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n    itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'],\n    'UUUUUY', ['TH', 'ss'], 'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'],\n    'uuuuuy', ['th'], 'y')))\n\n\nclass NO_DEFAULT:\n    pass\n\n\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT): [MASK]\n"}
{"method_name": "sanitize_url", "full_method_name": "sanitize_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef sanitize_url(url, *, scheme='http'):\n    if url is None:\n        return\n    elif url.startswith('//'):\n        return f'{scheme}:{url}'\n    COMMON_TYPOS = ('^httpss://', 'https://'), ('^rmtp([es]?)://', 'rtmp\\\\1://'\n        )\n    for mistake, fixup in COMMON_TYPOS:\n        if re.match(mistake, url):\n            return re.sub(mistake, fixup, url)\n    return url", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_sanitize_url(self):\n        self.assertEqual(sanitize_url('//foo.bar'), 'http://foo.bar')\n        self.assertEqual(sanitize_url('httpss://foo.bar'), 'https://foo.bar')\n        self.assertEqual(sanitize_url('rmtps://foo.bar'), 'rtmps://foo.bar')\n        self.assertEqual(sanitize_url('https://foo.bar'), 'https://foo.bar')\n        self.assertEqual(sanitize_url('foo bar'), 'foo bar')\n    \nTestUtil().test_sanitize_url()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The sanitize_url function is designed to clean and correct URLs. It aims to address common issues such as missing schemes, common typographical errors, and other potential inconsistencies.\n\nInputs: \n- url (str): The URL that needs to be sanitized.\n- scheme (str, optional): The default scheme ('http' by default) to be prepended to URLs that lack a scheme.\n\nOutputs:\n- str: The sanitized URL, where any common errors or missing parts have been corrected. If the input URL is None, the function returns None as well.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef sanitize_url(url, *, scheme='http'): [MASK]\n"}
{"method_name": "remove_quotes", "full_method_name": "remove_quotes", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\"):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_remove_quotes(self):\n        self.assertEqual(remove_quotes(None), None)\n        self.assertEqual(remove_quotes('\"'), '\"')\n        self.assertEqual(remove_quotes(\"'\"), \"'\")\n        self.assertEqual(remove_quotes(';'), ';')\n        self.assertEqual(remove_quotes('\";'), '\";')\n        self.assertEqual(remove_quotes('\"\"'), '')\n        self.assertEqual(remove_quotes('\";\"'), ';')\n    \nTestUtil().test_remove_quotes()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The remove_quotes function takes a string as input and checks if the string starts and ends with either single or double quotes. If it does, the function returns the string without the surrounding quotes. If the string is None or its length is less than 2, or it doesn't start and end with quotes, the function returns the string as is.\n\nInputs: \n- s: A string that may or may not be surrounded by single or double quotes.\n\nOutputs: \n- Returns the modified string with the surrounding quotes removed if they were present, or the original string if it was not surrounded by quotes, was None, or was shorter than 2 characters in length.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef remove_quotes(s): [MASK]\n"}
{"method_name": "orderedSet", "full_method_name": "orderedSet", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef orderedSet(iterable, *, lazy=False):\n    \"\"\"Remove all duplicates from the input iterable\"\"\"\n\n    def _iter():\n        seen = []\n        for x in iterable:\n            if x not in seen:\n                seen.append(x)\n                yield x\n    return _iter() if lazy else list(_iter())", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_ordered_set(self):\n        self.assertEqual(orderedSet([1, 1, 2, 3, 4, 4, 5, 6, 7, 3, 5]), [1, 2, \n            3, 4, 5, 6, 7])\n        self.assertEqual(orderedSet([]), [])\n        self.assertEqual(orderedSet([1]), [1])\n        self.assertEqual(orderedSet([135, 1, 1, 1]), [135, 1])\n    \nTestUtil().test_ordered_set()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The orderedSet function is designed to remove all duplicates from the input iterable while preserving the original order of the elements. It supports both eager and lazy evaluation depending on the value of the 'lazy' keyword argument.\n\nInputs: \n1. iterable: This is the input iterable (e.g., list, tuple, set) from which duplicates need to be removed. The elements of the iterable can be of any hashable type.\n2. lazy (optional): This is a keyword-only argument that determines whether the function should return a generator (if True) or a list (if False). The default value is False, meaning the function will return a list by default.\n\nOutputs:\n1. If 'lazy' is False (default), the function returns a list with duplicates removed and the original order preserved.\n2. If 'lazy' is True, the function returns a generator that lazily evaluates the input iterable, yielding elements one by one without duplicates, preserving the original order.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef orderedSet(iterable, *, lazy=False): [MASK]\n"}
{"method_name": "date_from_str", "full_method_name": "date_from_str", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)\ndef date_from_str(date_str, format='%Y%m%d', strict=False):\n    \"\"\"\n    Return a date object from a string using datetime_from_str\n    @param strict  Restrict allowed patterns to \"YYYYMMDD\" and\n                   (now|today|yesterday)(-\\\\d+(day|week|month|year)s?)?\n    \"\"\"\n    if strict and not re.fullmatch(\n        '\\\\d{8}|(now|today|yesterday)(-\\\\d+(day|week|month|year)s?)?', date_str\n        ):\n        raise ValueError(f'Invalid date format \"{date_str}\"')\n    return datetime_from_str(date_str, precision='microsecond', format=format\n        ).date()", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_date_from_str(self):\n        self.assertEqual(date_from_str('yesterday'), date_from_str('now-1day'))\n        self.assertEqual(date_from_str('now+7day'), date_from_str('now+1week'))\n        self.assertEqual(date_from_str('now+14day'), date_from_str('now+2week'))\n        self.assertEqual(date_from_str('20200229+365day'), date_from_str(\n            '20200229+1year'))\n        self.assertEqual(date_from_str('20210131+28day'), date_from_str(\n            '20210131+1month'))\n    \nTestUtil().test_date_from_str()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The date_from_str function is designed to parse a string and return a date object. This function supports various date formats and can handle relative dates (e.g., \"yesterday\", \"now\", \"today\"), as well as increment or decrement dates by specified time periods.\n\nInputs: \n- date_str (str): The string representation of the date to be converted. This can be in various formats as specified in the function's docstring, including relative terms like \"yesterday\", \"today\", and \"now\", and specific dates in the format provided by the format parameter.\n- format (str): A string specifying the strftime format to use when converting the date_str. This is used to parse specific date formats (default is '%Y%m%d', which corresponds to 'YYYYMMDD').\n- strict (bool): A boolean indicating whether to enforce strict pattern matching for the date string. If strict is True, the function will only accept date strings in the \"YYYYMMDD\" format or relative terms with optional time increments (default is False).\n\nOutputs: \n- A date object: The function returns a date object that represents the date parsed from the input string. The returned date object will be in the local timezone, unless it is derived from a relative term or a specific date with a given format.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\n\n\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\n\n\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)\n\n\ndef date_from_str(date_str, format='%Y%m%d', strict=False): [MASK]\n"}
{"method_name": "datetime_from_str", "full_method_name": "datetime_from_str", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_datetime_from_str(self):\n        self.assertEqual(datetime_from_str('yesterday', precision='day'),\n            datetime_from_str('now-1day', precision='auto'))\n        self.assertEqual(datetime_from_str('now+7day', precision='day'),\n            datetime_from_str('now+1week', precision='auto'))\n        self.assertEqual(datetime_from_str('now+14day', precision='day'),\n            datetime_from_str('now+2week', precision='auto'))\n        self.assertEqual(datetime_from_str('20200229+365day', precision='day'),\n            datetime_from_str('20200229+1year', precision='auto'))\n        self.assertEqual(datetime_from_str('20210131+28day', precision='day'),\n            datetime_from_str('20210131+1month', precision='auto'))\n        self.assertEqual(datetime_from_str('20210131+59day', precision='day'),\n            datetime_from_str('20210131+2month', precision='auto'))\n        self.assertEqual(datetime_from_str('now+1day', precision='hour'),\n            datetime_from_str('now+24hours', precision='auto'))\n        self.assertEqual(datetime_from_str('now+23hours', precision='hour'),\n            datetime_from_str('now+23hours', precision='auto'))\n    \nTestUtil().test_datetime_from_str()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The datetime_from_str function takes a string representing a date and time and converts it into a datetime object. It supports various formats and can adjust the precision of the datetime object based on input parameters.\n\nInputs: \n- date_str: A string representing a date and time. The supported formats include 'now', 'today', 'yesterday', or a date string in the specified format (e.g., '20230101').\n- precision: A string that specifies the precision of the returned datetime object. It can be 'microsecond', 'second', 'minute', 'hour', 'day', 'auto'. If 'auto' is provided, the function will round the datetime object to the unit provided in date_str (if applicable).\n- format: A string that specifies the strftime format of the date string when it is not one of the predefined keywords ('now', 'today', 'yesterday').\n\nOutputs:\n- A datetime object representing the provided date and time string. The precision of the datetime object will be adjusted according to the 'precision' parameter. If 'auto' precision is used and applicable units are provided in the 'date_str', the datetime object will be rounded to those units.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\n\n\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\n\n\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'): [MASK]\n"}
{"method_name": "unsmuggle_url", "full_method_name": "unsmuggle_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_smuggle_url(self):\n        data = {'\u00f6': '\u00f6', 'abc': [3]}\n        url = 'https://foo.bar/baz?x=y#a'\n        smug_url = smuggle_url(url, data)\n        unsmug_url, unsmug_data = unsmuggle_url(smug_url)\n        self.assertEqual(url, unsmug_url)\n        self.assertEqual(data, unsmug_data)\n        res_url, res_data = unsmuggle_url(url)\n        self.assertEqual(res_url, url)\n        self.assertEqual(res_data, None)\n        smug_url = smuggle_url(url, {'a': 'b'})\n        smug_smug_url = smuggle_url(smug_url, {'c': 'd'})\n        res_url, res_data = unsmuggle_url(smug_smug_url)\n        self.assertEqual(res_url, url)\n        self.assertEqual(res_data, {'a': 'b', 'c': 'd'})\n    \nTestUtil().test_smuggle_url()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The unsmuggle_url function is designed to extract and decode any additional data that was previously smuggled into a URL using the smuggle_url function. It is capable of returning the original URL and the smuggled data as a dictionary.\n\nInputs: \n- smug_url: A string representing the URL that may contain smuggled data. This is the URL potentially modified by the smuggle_url function.\n- default: An optional argument. If provided, it should be a dictionary that will be returned as the data part if no smuggled data is found in the URL. If not provided, None is assumed.\n\nOutputs:\n- A tuple containing two elements:\n    1. The original URL from which any smuggled data has been removed.\n    2. A dictionary containing the smuggled data, if any. If no data is found, the default argument is returned or None if default is not provided.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\n\n\ndef unsmuggle_url(smug_url, default=None): [MASK]\n"}
{"method_name": "smuggle_url", "full_method_name": "smuggle_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_smuggle_url(self):\n        data = {'\u00f6': '\u00f6', 'abc': [3]}\n        url = 'https://foo.bar/baz?x=y#a'\n        smug_url = smuggle_url(url, data)\n        unsmug_url, unsmug_data = unsmuggle_url(smug_url)\n        self.assertEqual(url, unsmug_url)\n        self.assertEqual(data, unsmug_data)\n        res_url, res_data = unsmuggle_url(url)\n        self.assertEqual(res_url, url)\n        self.assertEqual(res_data, None)\n        smug_url = smuggle_url(url, {'a': 'b'})\n        smug_smug_url = smuggle_url(smug_url, {'c': 'd'})\n        res_url, res_data = unsmuggle_url(smug_smug_url)\n        self.assertEqual(res_url, url)\n        self.assertEqual(res_data, {'a': 'b', 'c': 'd'})\n    \nTestUtil().test_smuggle_url()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function 'smuggle_url' is designed to encode additional data into a URL for internal use. It takes a URL and a data dictionary as inputs, then encodes the data dictionary into a URL-friendly format and appends it to the URL so that it can be smuggled through the URL and retrieved later.\n\nInputs: \n- url: A string representing the base URL. This URL will be used as the basis for the smuggled URL.\n- data: A dictionary containing the data to be smuggled. The keys and values of this dictionary should be serializable to JSON.\n\nOutputs:\n- A string representing the smuggled URL. This URL will contain the original URL and the encoded data in the query string. The data is encoded in a way that it can be extracted using the 'unsmuggle_url' function. The smuggled URL may look something like this: 'http://example.com?__youtubedl_smuggle=eyJhIjogYXN0aW9uIn0='.\n\nExample usage:\n- smuggle_url('http://example.com', {'key': 'value'})\n  This will return a string that represents the smuggled URL like 'http://example.com#__youtubedl_smuggle=eyJrZXkiOiAidmFsdWUifQ=='.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef smuggle_url(url, data): [MASK]\n"}
{"method_name": "float_or_none", "full_method_name": "float_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except (ValueError, TypeError):\n        return default", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_float_or_none(self):\n        self.assertEqual(float_or_none('42.42'), 42.42)\n        self.assertEqual(float_or_none('42'), 42.0)\n        self.assertEqual(float_or_none(''), None)\n        self.assertEqual(float_or_none(None), None)\n        self.assertEqual(float_or_none([]), None)\n        self.assertEqual(float_or_none(set()), None)\n    \nTestUtil().test_float_or_none()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Converts a given input to a float or returns a default value if the conversion fails.\nInputs: \n- v: The value to be converted to a float. It can be of any type that can potentially be cast to a float.\n- scale: A multiplier to scale the float value after conversion. Default is 1.\n- invscale: An inverse multiplier to scale the float value after conversion. Default is 1.\n- default: The default value to return if the conversion fails. Default is None.\nOutputs:\n- Returns the converted float value after applying scale and invscale, or the default value if the conversion fails.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None): [MASK]\n"}
{"method_name": "int_or_none", "full_method_name": "int_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_int_or_none(self):\n        self.assertEqual(int_or_none('42'), 42)\n        self.assertEqual(int_or_none(''), None)\n        self.assertEqual(int_or_none(None), None)\n        self.assertEqual(int_or_none([]), None)\n        self.assertEqual(int_or_none(set()), None)\n    \nTestUtil().test_int_or_none()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The int_or_none function is designed to convert a given value to an integer, applying a scale factor and handling exceptions gracefully. It also supports retrieving an attribute from the input object if specified. If the conversion fails due to a ValueError, TypeError, or OverflowError, the function returns a default value.\n\nInputs: \n- v: The value to be converted to an integer. This can be a number, a string that represents a number, or an object from which an attribute will be extracted.\n- scale: A scaling factor to apply to the integer conversion, by default it is set to 1. This is useful for converting a value to a different unit.\n- default: The default value to return if the conversion to integer fails. By default, this is None.\n- get_attr: A string specifying the name of an attribute to retrieve from the input object 'v'. If 'v' is an object and 'get_attr' is provided, the function will attempt to retrieve the attribute with 'get_attr' from 'v' before attempting conversion.\n- invscale: An inverse scaling factor to apply to the integer conversion, by default it is set to 1. This can be used in combination with 'scale' for adjusting the conversion.\n\nOutputs:\n- The function returns an integer representation of the input value 'v', after applying the scale and invscale factors. If the conversion fails, it returns the 'default' value.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1): [MASK]\n"}
{"method_name": "str_to_int", "full_method_name": "str_to_int", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_str_to_int(self):\n        self.assertEqual(str_to_int('123,456'), 123456)\n        self.assertEqual(str_to_int('123.456'), 123456)\n        self.assertEqual(str_to_int(523), 523)\n        self.assertEqual(str_to_int('noninteger'), None)\n        self.assertEqual(str_to_int([]), None)\n    \nTestUtil().test_str_to_int()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Convert a string to an integer in a relaxed manner, handling common non-numeric characters.\nInputs: \n    - int_str: The string that represents an integer. This can be an integer (which will be returned directly) or a string that might contain non-numeric characters such as commas, dots, or plus signs.\nOutputs: \n    - An integer representation of the input string after removing non-numeric characters. If the input cannot be converted to an integer due to invalid format or type, or if the input is None, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\n\n\ndef str_to_int(int_str): [MASK]\n"}
{"method_name": "url_basename", "full_method_name": "url_basename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef url_basename(url):\n    path = urllib.parse.urlparse(url).path\n    return path.strip('/').split('/')[-1]", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_url_basename(self):\n        self.assertEqual(url_basename('http://foo.de/'), '')\n        self.assertEqual(url_basename('http://foo.de/bar/baz'), 'baz')\n        self.assertEqual(url_basename('http://foo.de/bar/baz?x=y'), 'baz')\n        self.assertEqual(url_basename('http://foo.de/bar/baz#x=y'), 'baz')\n        self.assertEqual(url_basename('http://foo.de/bar/baz/'), 'baz')\n        self.assertEqual(url_basename(\n            'http://media.w3.org/2010/05/sintel/trailer.mp4'), 'trailer.mp4')\n    \nTestUtil().test_url_basename()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The url_basename function is designed to extract the base name of a given URL. The base name is the last part of the URL path after stripping any leading slashes. This function is useful for identifying the name of a resource at the end of a URL.\n\nInputs: \n- url (str): A string representing the URL from which the base name will be extracted. The URL can be in any format, but it should contain a valid path component.\n\nOutputs: \n- The function returns a string representing the base name of the URL path. If the URL path is empty or does not have a name component, the function will return an empty string.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef url_basename(url): [MASK]\n"}
{"method_name": "urljoin", "full_method_name": "urljoin", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode()\n    if not isinstance(path, str) or not path:\n        return None\n    if re.match('^(?:[a-zA-Z][a-zA-Z0-9+-.]*:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode()\n    if not isinstance(base, str) or not re.match('^(?:https?:)?//', base):\n        return None\n    return urllib.parse.urljoin(base, path)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_urljoin(self):\n        self.assertEqual(urljoin('http://foo.de/', '/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin(b'http://foo.de/', '/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de/', b'/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin(b'http://foo.de/', b'/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('//foo.de/', '/a/b/c.txt'), '//foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de/', 'a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de', '/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de', 'a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de/', 'http://foo.de/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de/', '//foo.de/a/b/c.txt'),\n            '//foo.de/a/b/c.txt')\n        self.assertEqual(urljoin(None, 'http://foo.de/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin(None, '//foo.de/a/b/c.txt'), '//foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('', 'http://foo.de/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin(['foobar'], 'http://foo.de/a/b/c.txt'),\n            'http://foo.de/a/b/c.txt')\n        self.assertEqual(urljoin('http://foo.de/', None), None)\n        self.assertEqual(urljoin('http://foo.de/', ''), None)\n        self.assertEqual(urljoin('http://foo.de/', ['foobar']), None)\n        self.assertEqual(urljoin('http://foo.de/a/b/c.txt', '.././../d.txt'),\n            'http://foo.de/d.txt')\n        self.assertEqual(urljoin('http://foo.de/a/b/c.txt', 'rtmp://foo.de'),\n            'rtmp://foo.de')\n        self.assertEqual(urljoin(None, 'rtmp://foo.de'), 'rtmp://foo.de')\n    \nTestUtil().test_urljoin()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The urljoin function is designed to concatenate a base URL and a relative path to create a complete URL. It ensures that if the relative path is already a complete URL (identified by the presence of a scheme like 'http://' or 'https://'), it returns the path as is. If the base URL is not provided or is invalid (it must start with 'http://' or 'https://'), the function returns None. The function also handles cases where the input arguments are not strings or are empty, again returning None in these scenarios. It uses Python's urllib.parse.urljoin method under the hood to perform the concatenation.\n\nInputs:\n- base: A string representing the base URL. The base URL must start with 'http://' or 'https://'.\n- path: A string representing the relative path to be appended to the base URL. This can be a relative path or a complete URL.\n\nOutputs:\n- If path is already a complete URL, the function returns the path as is.\n- If base is a valid URL and path is a relative path, the function returns a complete URL by concatenating base and path.\n- If either base or path is not a string, is empty, or if base is not a valid URL (does not start with 'http://' or 'https://'), the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef urljoin(base, path): [MASK]\n"}
{"method_name": "url_or_none", "full_method_name": "url_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef url_or_none(url):\n    if not url or not isinstance(url, str):\n        return None\n    url = url.strip()\n    return url if re.match(\n        '^(?:(?:https?|rt(?:m(?:pt?[es]?|fp)|sp[su]?)|mms|ftps?):)?//', url\n        ) else None", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_url_or_none(self):\n        self.assertEqual(url_or_none(None), None)\n        self.assertEqual(url_or_none(''), None)\n        self.assertEqual(url_or_none('foo'), None)\n        self.assertEqual(url_or_none('http://foo.de'), 'http://foo.de')\n        self.assertEqual(url_or_none('https://foo.de'), 'https://foo.de')\n        self.assertEqual(url_or_none('http$://foo.de'), None)\n        self.assertEqual(url_or_none('http://foo.de'), 'http://foo.de')\n        self.assertEqual(url_or_none('//foo.de'), '//foo.de')\n        self.assertEqual(url_or_none('s3://foo.de'), None)\n        self.assertEqual(url_or_none('rtmpte://foo.de'), 'rtmpte://foo.de')\n        self.assertEqual(url_or_none('mms://foo.de'), 'mms://foo.de')\n        self.assertEqual(url_or_none('rtspu://foo.de'), 'rtspu://foo.de')\n        self.assertEqual(url_or_none('ftps://foo.de'), 'ftps://foo.de')\n    \nTestUtil().test_url_or_none()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function 'url_or_none' is designed to validate the format of a given URL string. It checks whether the input is a valid URL or not, based on a regular expression that looks for common URL formats. It supports various URL protocols such as HTTP, HTTPS, RTMP, RTMPT, RTMPTS, RTMTPS, MMS, FTPS, and ensures that the URL string contains a protocol indicator followed by '://'. If the input is a valid URL, it returns the URL; otherwise, it returns None.\n\nInputs: \n- url: A string representing a URL to be validated. The function expects the input to be a string. If the input is not a string or is an empty string, the function will return None.\n\nOutputs:\n- Returns the input URL if it is a valid URL based on the regular expression check.\n- Returns None if the input is not a string, is an empty string, or does not match the regular expression for a valid URL format.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef url_or_none(url): [MASK]\n"}
{"method_name": "parse_age_limit", "full_method_name": "parse_age_limit", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nTV_PARENTAL_GUIDELINES = {'TV-Y': 0, 'TV-Y7': 7, 'TV-G': 0, 'TV-PG': 0,\n    'TV-14': 14, 'TV-MA': 17}\nUS_RATINGS = {'G': 0, 'PG': 10, 'PG-13': 13, 'R': 16, 'NC': 18}\ndef parse_age_limit(s):\n    if type(s) is int:\n        return s if 0 <= s <= 21 else None\n    elif not isinstance(s, str):\n        return None\n    m = re.match('^(?P<age>\\\\d{1,2})\\\\+?$', s)\n    if m:\n        return int(m.group('age'))\n    s = s.upper()\n    if s in US_RATINGS:\n        return US_RATINGS[s]\n    m = re.match('^TV[_-]?({})$'.format('|'.join(k[3:] for k in\n        TV_PARENTAL_GUIDELINES)), s)\n    if m:\n        return TV_PARENTAL_GUIDELINES['TV-' + m.group(1)]\n    return None", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_age_limit(self):\n        self.assertEqual(parse_age_limit(None), None)\n        self.assertEqual(parse_age_limit(False), None)\n        self.assertEqual(parse_age_limit('invalid'), None)\n        self.assertEqual(parse_age_limit(0), 0)\n        self.assertEqual(parse_age_limit(18), 18)\n        self.assertEqual(parse_age_limit(21), 21)\n        self.assertEqual(parse_age_limit(22), None)\n        self.assertEqual(parse_age_limit('18'), 18)\n        self.assertEqual(parse_age_limit('18+'), 18)\n        self.assertEqual(parse_age_limit('PG-13'), 13)\n        self.assertEqual(parse_age_limit('TV-14'), 14)\n        self.assertEqual(parse_age_limit('TV-MA'), 17)\n        self.assertEqual(parse_age_limit('TV14'), 14)\n        self.assertEqual(parse_age_limit('TV_G'), 0)\n    \nTestUtil().test_parse_age_limit()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function parse_age_limit is designed to interpret and return the age limit based on various input formats. It supports age limits provided as integers, strings in the format of 'XX+' where XX is the age limit, and recognized rating abbreviations from the TV Parental Guidelines and US Movie Ratings.\n\nInputs: The function takes a single argument 's' which can be an integer, a string representing the age limit in the format 'XX+', or a rating abbreviation string.\n\nOutputs: The function returns an integer representing the age limit if the input is valid. If the input is an integer between 0 and 21, it returns the same integer. If the input is a string, it parses it according to the rules described and returns the corresponding age limit as an integer. If the input is invalid (i.e., not in the specified formats or out of the valid range), the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nTV_PARENTAL_GUIDELINES = {'TV-Y': 0, 'TV-Y7': 7, 'TV-G': 0, 'TV-PG': 0,\n    'TV-14': 14, 'TV-MA': 17}\nUS_RATINGS = {'G': 0, 'PG': 10, 'PG-13': 13, 'R': 16, 'NC': 18}\n\n\ndef parse_age_limit(s): [MASK]\n"}
{"method_name": "parse_duration", "full_method_name": "parse_duration", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_duration(s):\n    if not isinstance(s, str):\n        return None\n    s = s.strip()\n    if not s:\n        return None\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(\n        \"\"\"(?x)\n            (?P<before_secs>\n                (?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?\n            (?P<secs>(?(before_secs)[0-9]{1,2}|[0-9]+))\n            (?P<ms>[.:][0-9]+)?Z?$\n        \"\"\"\n        , s)\n    if m:\n        days, hours, mins, secs, ms = m.group('days', 'hours', 'mins',\n            'secs', 'ms')\n    else:\n        m = re.match(\n            \"\"\"(?ix)(?:P?\n                (?:\n                    [0-9]+\\\\s*y(?:ears?)?,?\\\\s*\n                )?\n                (?:\n                    [0-9]+\\\\s*m(?:onths?)?,?\\\\s*\n                )?\n                (?:\n                    [0-9]+\\\\s*w(?:eeks?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<days>[0-9]+)\\\\s*d(?:ays?)?,?\\\\s*\n                )?\n                T)?\n                (?:\n                    (?P<hours>[0-9]+)\\\\s*h(?:(?:ou)?rs?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<mins>[0-9]+)\\\\s*m(?:in(?:ute)?s?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<secs>[0-9]+)(?P<ms>\\\\.[0-9]+)?\\\\s*s(?:ec(?:ond)?s?)?\\\\s*\n                )?Z?$\"\"\"\n            , s)\n        if m:\n            days, hours, mins, secs, ms = m.groups()\n        else:\n            m = re.match(\n                '(?i)(?:(?P<hours>[0-9.]+)\\\\s*(?:hours?)|(?P<mins>[0-9.]+)\\\\s*(?:mins?\\\\.?|minutes?)\\\\s*)Z?$'\n                , s)\n            if m:\n                hours, mins = m.groups()\n            else:\n                return None\n    if ms:\n        ms = ms.replace(':', '.')\n    return sum(float(part or 0) * mult for part, mult in ((days, 86400), (\n        hours, 3600), (mins, 60), (secs, 1), (ms, 1)))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_duration(self):\n        self.assertEqual(parse_duration(None), None)\n        self.assertEqual(parse_duration(False), None)\n        self.assertEqual(parse_duration('invalid'), None)\n        self.assertEqual(parse_duration('1'), 1)\n        self.assertEqual(parse_duration('1337:12'), 80232)\n        self.assertEqual(parse_duration('9:12:43'), 33163)\n        self.assertEqual(parse_duration('12:00'), 720)\n        self.assertEqual(parse_duration('00:01:01'), 61)\n        self.assertEqual(parse_duration('x:y'), None)\n        self.assertEqual(parse_duration('3h11m53s'), 11513)\n        self.assertEqual(parse_duration('3h 11m 53s'), 11513)\n        self.assertEqual(parse_duration('3 hours 11 minutes 53 seconds'), 11513)\n        self.assertEqual(parse_duration('3 hours 11 mins 53 secs'), 11513)\n        self.assertEqual(parse_duration('3 hours, 11 minutes, 53 seconds'), 11513)\n        self.assertEqual(parse_duration('3 hours, 11 mins, 53 secs'), 11513)\n        self.assertEqual(parse_duration('62m45s'), 3765)\n        self.assertEqual(parse_duration('6m59s'), 419)\n        self.assertEqual(parse_duration('49s'), 49)\n        self.assertEqual(parse_duration('0h0m0s'), 0)\n        self.assertEqual(parse_duration('0m0s'), 0)\n        self.assertEqual(parse_duration('0s'), 0)\n        self.assertEqual(parse_duration('01:02:03.05'), 3723.05)\n        self.assertEqual(parse_duration('T30M38S'), 1838)\n        self.assertEqual(parse_duration('5 s'), 5)\n        self.assertEqual(parse_duration('3 min'), 180)\n        self.assertEqual(parse_duration('2.5 hours'), 9000)\n        self.assertEqual(parse_duration('02:03:04'), 7384)\n        self.assertEqual(parse_duration('01:02:03:04'), 93784)\n        self.assertEqual(parse_duration('1 hour 3 minutes'), 3780)\n        self.assertEqual(parse_duration('87 Min.'), 5220)\n        self.assertEqual(parse_duration('PT1H0.040S'), 3600.04)\n        self.assertEqual(parse_duration('PT00H03M30SZ'), 210)\n        self.assertEqual(parse_duration('P0Y0M0DT0H4M20.880S'), 260.88)\n        self.assertEqual(parse_duration('01:02:03:050'), 3723.05)\n        self.assertEqual(parse_duration('103:050'), 103.05)\n        self.assertEqual(parse_duration('1HR 3MIN'), 3780)\n        self.assertEqual(parse_duration('2hrs 3mins'), 7380)\n    \nTestUtil().test_parse_duration()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The parse_duration function is designed to interpret strings representing durations and convert them into their equivalent total seconds as a float. It supports various formats including ISO 8601 (e.g., \"PnDTnHnMnS\"), military time (e.g., \"n:n:nZ\"), and common language descriptions (e.g., \"n hours\", \"n mins\", \"n days\"). If the input string cannot be parsed into a valid duration, the function returns None.\n\nInputs: \n- s: A string representing a duration. The string can include days, hours, minutes, seconds, and milliseconds in various formats supported by the function.\n\nOutputs: \n- The function returns a float representing the total number of seconds for the duration if parsing is successful. If the input string is not a valid duration format or if the input is not a string, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_duration(s): [MASK]\n"}
{"method_name": "fix_xml_ampersands", "full_method_name": "fix_xml_ampersands", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef fix_xml_ampersands(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return re.sub(\n        '&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)',\n        '&amp;', xml_str)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_fix_xml_ampersands(self):\n        self.assertEqual(fix_xml_ampersands('\"&x=y&z=a'), '\"&amp;x=y&amp;z=a')\n        self.assertEqual(fix_xml_ampersands('\"&amp;x=y&wrong;&z=a'),\n            '\"&amp;x=y&amp;wrong;&amp;z=a')\n        self.assertEqual(fix_xml_ampersands('&amp;&apos;&gt;&lt;&quot;'),\n            '&amp;&apos;&gt;&lt;&quot;')\n        self.assertEqual(fix_xml_ampersands('&#1234;&#x1abC;'), '&#1234;&#x1abC;')\n        self.assertEqual(fix_xml_ampersands('&#&#'), '&amp;#&amp;#')\n    \nTestUtil().test_fix_xml_ampersands()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: This function takes an XML string as input and returns a new XML string where all occurrences of '&' that are not part of predefined XML entities are replaced by '&amp;'. This is to ensure that the XML remains well-formed, as '&' can cause parsing issues if not properly escaped.\n\nInputs: \n- xml_str (str): A string containing XML data.\n\nOutputs: \n- A string with '&' replaced by '&amp;' where necessary to ensure proper XML formatting.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef fix_xml_ampersands(xml_str): [MASK]\n"}
{"method_name": "read_batch_urls", "full_method_name": "read_batch_urls", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef read_batch_urls(batch_fd):\n\n    def fixup(url):\n        if not isinstance(url, str):\n            url = url.decode('utf-8', 'replace')\n        BOM_UTF8 = '\u00ef\u00bb\u00bf', '\\ufeff'\n        for bom in BOM_UTF8:\n            if url.startswith(bom):\n                url = url[len(bom):]\n        url = url.lstrip()\n        if not url or url.startswith(('#', ';', ']')):\n            return False\n        return re.split('\\\\s#', url, maxsplit=1)[0].rstrip()\n    with contextlib.closing(batch_fd) as fd:\n        return [url for url in map(fixup, fd) if url]", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_read_batch_urls(self):\n        f = io.StringIO(\n            '\u00ef\u00bb\u00bf foo\\n            bar\\r\\n            baz\\n            # More after this line\\r\\n            ; or after this\\n            bam'\n            )\n        self.assertEqual(read_batch_urls(f), ['foo', 'bar', 'baz', 'bam'])\n    \nTestUtil().test_read_batch_urls()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The read_batch_urls function is designed to process a file descriptor (batch_fd) that contains a batch of URLs. Each URL in the file is cleaned and standardized before being added to the final list. The function handles encoding issues, removes any leading white spaces, skips invalid entries, and extracts the URL part before any comment symbol (#). It ensures that only valid and properly formatted URLs are returned.\n\nInputs: \n- batch_fd: A file descriptor representing a file containing a batch of URLs. The file is expected to be in text format with one URL per line.\n\nOutputs: \n- A list of cleaned and properly formatted URLs extracted from the file descriptor. URLs that are empty, start with specific characters (e.g., '#', ';', ']'), or are otherwise invalid are excluded from the list. Each URL in the output list is a string.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef read_batch_urls(batch_fd): [MASK]\n"}
{"method_name": "multipart_encode", "full_method_name": "multipart_encode", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef _multipart_encode_impl(data, boundary):\n    content_type = f'multipart/form-data; boundary={boundary}'\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, str):\n            k = k.encode()\n        if isinstance(v, str):\n            v = v.encode()\n        content = (b'Content-Disposition: form-data; name=\"' + k +\n            b'\"\\r\\n\\r\\n' + v + b'\\r\\n')\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n    return out, content_type\ndef multipart_encode(data, boundary=None):\n    \"\"\"\n    Encode a dict to RFC 7578-compliant form-data\n    data:\n        A dict where keys and values can be either Unicode or bytes-like\n        objects.\n    boundary:\n        If specified a Unicode object, it's used as the boundary. Otherwise\n        a random boundary is generated.\n    Reference: https://tools.ietf.org/html/rfc7578\n    \"\"\"\n    has_specified_boundary = boundary is not None\n    while True:\n        if boundary is None:\n            boundary = '---------------' + str(random.randrange(268435455,\n                4294967295))\n        try:\n            out, content_type = _multipart_encode_impl(data, boundary)\n            break\n        except ValueError:\n            if has_specified_boundary:\n                raise\n            boundary = None\n    return out, content_type", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_multipart_encode(self):\n        self.assertEqual(multipart_encode({b'field': b'value'}, boundary=\n            'AAAAAA')[0],\n            b'--AAAAAA\\r\\nContent-Disposition: form-data; name=\"field\"\\r\\n\\r\\nvalue\\r\\n--AAAAAA--\\r\\n'\n            )\n        self.assertEqual(multipart_encode({'\u6b04\u4f4d'.encode(): '\u503c'.encode()},\n            boundary='AAAAAA')[0],\n            b'--AAAAAA\\r\\nContent-Disposition: form-data; name=\"\\xe6\\xac\\x84\\xe4\\xbd\\x8d\"\\r\\n\\r\\n\\xe5\\x80\\xbc\\r\\n--AAAAAA--\\r\\n'\n            )\n        self.assertRaises(ValueError, multipart_encode, {b'field': b'value'},\n            boundary='value')\n    \nTestUtil().test_multipart_encode()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The multipart_encode function takes a dictionary of data and an optional boundary string to encode the data into a multipart/form-data format, compliant with RFC 7578. This is commonly used for sending data, including files, over HTTP. The function generates a random boundary if not provided and ensures that the boundary does not overlap with any of the data.\n\nInputs:\n- data: A dictionary where keys and values can be either Unicode strings or bytes-like objects. This is the data to be encoded.\n- boundary: An optional Unicode string that acts as the boundary in the multipart/form-data structure. If not provided, the function will generate a random boundary.\n\nOutputs:\n- out: A bytes-like object containing the encoded form data ready to be transmitted, e.g., in an HTTP POST request.\n- content_type: A string representing the content type of the data, including the boundary used, in the format 'multipart/form-data; boundary={boundary}'.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef _multipart_encode_impl(data, boundary):\n    content_type = f'multipart/form-data; boundary={boundary}'\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, str):\n            k = k.encode()\n        if isinstance(v, str):\n            v = v.encode()\n        content = (b'Content-Disposition: form-data; name=\"' + k +\n            b'\"\\r\\n\\r\\n' + v + b'\\r\\n')\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n    return out, content_type\n\n\ndef multipart_encode(data, boundary=None): [MASK]\n"}
{"method_name": "merge_dicts", "full_method_name": "merge_dicts", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef merge_dicts(*dicts):\n    merged = {}\n    for a_dict in dicts:\n        for k, v in a_dict.items():\n            if v is not None and k not in merged or isinstance(v, str\n                ) and merged[k] == '':\n                merged[k] = v\n    return merged", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_merge_dicts(self):\n        self.assertEqual(merge_dicts({'a': 1}, {'b': 2}), {'a': 1, 'b': 2})\n        self.assertEqual(merge_dicts({'a': 1}, {'a': 2}), {'a': 1})\n        self.assertEqual(merge_dicts({'a': 1}, {'a': None}), {'a': 1})\n        self.assertEqual(merge_dicts({'a': 1}, {'a': ''}), {'a': 1})\n        self.assertEqual(merge_dicts({'a': 1}, {}), {'a': 1})\n        self.assertEqual(merge_dicts({'a': None}, {'a': 1}), {'a': 1})\n        self.assertEqual(merge_dicts({'a': ''}, {'a': 1}), {'a': ''})\n        self.assertEqual(merge_dicts({'a': ''}, {'a': 'abc'}), {'a': 'abc'})\n        self.assertEqual(merge_dicts({'a': None}, {'a': ''}, {'a': 'abc'}), {\n            'a': 'abc'})\n    \nTestUtil().test_merge_dicts()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The merge_dicts function is designed to merge multiple dictionaries into a single dictionary. It iterates over each dictionary provided as an argument and adds its key-value pairs to the resulting dictionary. If there are duplicate keys, the function will only keep the value from the first dictionary where the value is not None, or if the value is a string and the existing value for that key is an empty string, it will be updated with the non-empty string value.\nInputs: The function accepts any number of dictionary arguments. Each argument should be a dictionary object.\nOutputs: The function returns a single dictionary that is a merge of all input dictionaries based on the rules described in the functionality section. If no arguments are provided, the function will return an empty dictionary.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef merge_dicts(*dicts): [MASK]\n"}
{"method_name": "parse_iso8601", "full_method_name": "parse_iso8601", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass NO_DEFAULT:\n    pass\nTIMEZONE_NAMES = {'UT': 0, 'UTC': 0, 'GMT': 0, 'Z': 0, 'AST': -4, 'ADT': -3,\n    'EST': -5, 'EDT': -4, 'CST': -6, 'CDT': -5, 'MST': -7, 'MDT': -6, 'PST':\n    -8, 'PDT': -7}\ndef extract_timezone(date_str, default=None):\n    m = re.search(\n        \"\"\"(?x)\n            ^.{8,}?                                              # >=8 char non-TZ prefix, if present\n            (?P<tz>Z|                                            # just the UTC Z, or\n                (?:(?<=.\\\\b\\\\d{4}|\\\\b\\\\d{2}:\\\\d\\\\d)|                   # preceded by 4 digits or hh:mm or\n                   (?<!.\\\\b[a-zA-Z]{3}|[a-zA-Z]{4}|..\\\\b\\\\d\\\\d))     # not preceded by 3 alpha word or >= 4 alpha or 2 digits\n                   [ ]?                                          # optional space\n                (?P<sign>\\\\+|-)                                   # +/-\n                (?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})       # hh[:]mm\n            $)\n        \"\"\"\n        , date_str)\n    timezone = None\n    if not m:\n        m = re.search('\\\\d{1,2}:\\\\d{1,2}(?:\\\\.\\\\d+)?(?P<tz>\\\\s*[A-Z]+)$',\n            date_str)\n        timezone = TIMEZONE_NAMES.get(m and m.group('tz').strip())\n        if timezone is not None:\n            date_str = date_str[:-len(m.group('tz'))]\n            timezone = dt.timedelta(hours=timezone)\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if m.group('sign'):\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = dt.timedelta(hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    if timezone is None and default is not NO_DEFAULT:\n        timezone = default or dt.timedelta()\n    return timezone, date_str\ndef parse_iso8601(date_str, delimiter='T', timezone=None):\n    \"\"\" Return a UNIX timestamp from the given date \"\"\"\n    if date_str is None:\n        return None\n    date_str = re.sub('\\\\.[0-9]+', '', date_str)\n    timezone, date_str = extract_timezone(date_str, timezone)\n    with contextlib.suppress(ValueError, TypeError):\n        date_format = f'%Y-%m-%d{delimiter}%H:%M:%S'\n        dt_ = dt.datetime.strptime(date_str, date_format) - timezone\n        return calendar.timegm(dt_.timetuple())", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_iso8601(self):\n        self.assertEqual(parse_iso8601('2014-03-23T23:04:26+0100'), 1395612266)\n        self.assertEqual(parse_iso8601('2014-03-23T23:04:26-07:00'), 1395641066)\n        self.assertEqual(parse_iso8601('2014-03-23T23:04:26', timezone=dt.\n            timedelta(hours=-7)), 1395641066)\n        self.assertEqual(parse_iso8601('2014-03-23T23:04:26', timezone=\n            NO_DEFAULT), None)\n        self.assertEqual(parse_iso8601('2014-03-23T23:04:26-07:00', timezone=dt\n            .timedelta(hours=-10)), 1395641066)\n        self.assertEqual(parse_iso8601('2014-03-23T22:04:26+0000'), 1395612266)\n        self.assertEqual(parse_iso8601('2014-03-23T22:04:26Z'), 1395612266)\n        self.assertEqual(parse_iso8601('2014-03-23T22:04:26.1234Z'), 1395612266)\n        self.assertEqual(parse_iso8601('2015-09-29T08:27:31.727'), 1443515251)\n        self.assertEqual(parse_iso8601('2015-09-29T08-27-31.727'), None)\n    \nTestUtil().test_parse_iso8601()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The parse_iso8601 function is designed to convert ISO 8601 formatted date strings into UNIX timestamps. It first removes any decimal fractions of seconds, then parses the date string, considering the specified delimiter and timezone.\n\nInputs: \n1. date_str (str): A string representing a date and time in ISO 8601 format.\n2. delimiter (str, optional): A string that is expected to be present in the date_str between the date and time components. Defaults to 'T'.\n3. timezone (datetime.timedelta, optional): A datetime.timedelta representing the timezone offset to apply. If not provided, it will attempt to extract the timezone from the date string.\n\nOutputs:\n1. timestamp (int or None): Returns the UNIX timestamp corresponding to the provided date string. If the input date_str is None, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass NO_DEFAULT:\n    pass\n\n\nTIMEZONE_NAMES = {'UT': 0, 'UTC': 0, 'GMT': 0, 'Z': 0, 'AST': -4, 'ADT': -3,\n    'EST': -5, 'EDT': -4, 'CST': -6, 'CDT': -5, 'MST': -7, 'MDT': -6, 'PST':\n    -8, 'PDT': -7}\n\n\ndef extract_timezone(date_str, default=None):\n    m = re.search(\n        \"\"\"(?x)\n            ^.{8,}?                                              # >=8 char non-TZ prefix, if present\n            (?P<tz>Z|                                            # just the UTC Z, or\n                (?:(?<=.\\\\b\\\\d{4}|\\\\b\\\\d{2}:\\\\d\\\\d)|                   # preceded by 4 digits or hh:mm or\n                   (?<!.\\\\b[a-zA-Z]{3}|[a-zA-Z]{4}|..\\\\b\\\\d\\\\d))     # not preceded by 3 alpha word or >= 4 alpha or 2 digits\n                   [ ]?                                          # optional space\n                (?P<sign>\\\\+|-)                                   # +/-\n                (?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})       # hh[:]mm\n            $)\n        \"\"\"\n        , date_str)\n    timezone = None\n    if not m:\n        m = re.search('\\\\d{1,2}:\\\\d{1,2}(?:\\\\.\\\\d+)?(?P<tz>\\\\s*[A-Z]+)$',\n            date_str)\n        timezone = TIMEZONE_NAMES.get(m and m.group('tz').strip())\n        if timezone is not None:\n            date_str = date_str[:-len(m.group('tz'))]\n            timezone = dt.timedelta(hours=timezone)\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if m.group('sign'):\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = dt.timedelta(hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    if timezone is None and default is not NO_DEFAULT:\n        timezone = default or dt.timedelta()\n    return timezone, date_str\n\n\ndef parse_iso8601(date_str, delimiter='T', timezone=None): [MASK]\n"}
{"method_name": "strip_jsonp", "full_method_name": "strip_jsonp", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef strip_jsonp(code):\n    return re.sub(\n        \"\"\"(?sx)^\n            (?:window\\\\.)?(?P<func_name>[a-zA-Z0-9_.$]*)\n            (?:\\\\s*&&\\\\s*(?P=func_name))?\n            \\\\s*\\\\(\\\\s*(?P<callback_data>.*)\\\\);?\n            \\\\s*?(?://[^\\\\n]*)*$\"\"\"\n        , '\\\\g<callback_data>', code)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_strip_jsonp(self):\n        stripped = strip_jsonp('cb ([ {\"id\":\"532cb\",\\n\\n\\n\"x\":\\n3}\\n]\\n);')\n        d = json.loads(stripped)\n        self.assertEqual(d, [{'id': '532cb', 'x': 3}])\n        stripped = strip_jsonp('parseMetadata({\"STATUS\":\"OK\"})\\n\\n\\n//epc')\n        d = json.loads(stripped)\n        self.assertEqual(d, {'STATUS': 'OK'})\n        stripped = strip_jsonp('ps.embedHandler({\"status\": \"success\"});')\n        d = json.loads(stripped)\n        self.assertEqual(d, {'status': 'success'})\n        stripped = strip_jsonp('window.cb && window.cb({\"status\": \"success\"});')\n        d = json.loads(stripped)\n        self.assertEqual(d, {'status': 'success'})\n        stripped = strip_jsonp('window.cb && cb({\"status\": \"success\"});')\n        d = json.loads(stripped)\n        self.assertEqual(d, {'status': 'success'})\n        stripped = strip_jsonp('({\"status\": \"success\"});')\n        d = json.loads(stripped)\n        self.assertEqual(d, {'status': 'success'})\n    \nTestUtil().test_strip_jsonp()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The strip_jsonp function is designed to parse and extract JSON data from a JSONP (JSON with padding) string. JSONP is a method of embedding JSON data within a webpage, often used in cross-origin requests. This function removes the surrounding JavaScript function call and padding, leaving only the JSON data.\n\nInputs: \n- code: A string representing the JSONP code. The JSONP code will have a format similar to: \"function_name(data);\", where \"function_name\" is a JavaScript function name and \"data\" is the JSON data.\n\nOutputs:\n- The function returns a string that contains only the JSON data extracted from the JSONP code. The returned string will not include any surrounding JavaScript function calls or padding. The JSON data will be in a format that can be directly parsed by JSON parsing functions.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef strip_jsonp(code): [MASK]\n"}
{"method_name": "uppercase_escape", "full_method_name": "uppercase_escape", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef uppercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub('\\\\\\\\U[0-9a-fA-F]{8}', lambda m: unicode_escape(m.group(0\n        ))[0], s)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_uppercase_escape(self):\n        self.assertEqual(uppercase_escape('a\u00e4'), 'a\u00e4')\n        self.assertEqual(uppercase_escape('\\\\U0001d550'), '\ud835\udd50')\n    \nTestUtil().test_uppercase_escape()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The uppercase_escape function is designed to process a string input, specifically looking for Unicode escape sequences that are indicated by the pattern '\\\\U[0-9a-fA-F]{8}'. When it encounters such a pattern, it decodes the Unicode escape sequence using the 'unicode_escape' codec and then returns the uppercase version of the decoded character. This function is particularly useful for manipulating and normalizing strings that contain Unicode escape sequences, converting them into their corresponding uppercase Unicode characters.\n\nInputs: \n- s (str): A string that may contain Unicode escape sequences. The string is expected to be a valid Python string that can contain raw Unicode escape sequences in the format '\\\\U[0-9a-fA-F]{8}'.\n\nOutputs: \n- (str): The function returns a string where all Unicode escape sequences matching '\\\\U[0-9a-fA-F]{8}' have been decoded using the 'unicode_escape' codec and then converted to uppercase. The resulting string will have these sequences replaced with their uppercase Unicode characters, facilitating the handling and display of Unicode texts in a uniform and uppercase format.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef uppercase_escape(s): [MASK]\n"}
{"method_name": "lowercase_escape", "full_method_name": "lowercase_escape", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef lowercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub('\\\\\\\\u[0-9a-fA-F]{4}', lambda m: unicode_escape(m.group(0\n        ))[0], s)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_lowercase_escape(self):\n        self.assertEqual(lowercase_escape('a\u00e4'), 'a\u00e4')\n        self.assertEqual(lowercase_escape('\\\\u0026'), '&')\n    \nTestUtil().test_lowercase_escape()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function 'lowercase_escape' is designed to process a given string 's'. It specifically targets unicode escape sequences in the format '\\\\uXXXX', where 'XXXX' represents a 4-digit hexadecimal number that corresponds to a Unicode character. The function decodes these escape sequences using the 'unicode_escape' codec, and then converts the resulting characters to lowercase if they are uppercase letters. This operation is useful for normalizing Unicode characters in strings for case-insensitive comparisons or processing.\n\nInputs: \n- s (str): A string potentially containing unicode escape sequences in the format '\\\\uXXXX'.\n\nOutputs: \n- str: The input string 's' with all unicode escape sequences decoded to their corresponding Unicode characters and any uppercase letters resulting from the decoding process converted to lowercase.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef lowercase_escape(s): [MASK]\n"}
{"method_name": "limit_length", "full_method_name": "limit_length", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_limit_length(self):\n        self.assertEqual(limit_length(None, 12), None)\n        self.assertEqual(limit_length('foo', 12), 'foo')\n        self.assertTrue(limit_length('foo bar baz asd', 12).startswith('foo bar'))\n        self.assertTrue('...' in limit_length('foo bar baz asd', 12))\n    \nTestUtil().test_limit_length()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The limit_length function is designed to truncate a string to a specified length and append ellipses if the original string exceeds the length limit. It ensures that the string does not surpass the given length, making it useful for displaying previews of long strings or for formatting purposes.\n\nInputs:\n- s: A string to be truncated. This is the input string that may be longer than the desired length.\n- length: An integer representing the maximum allowed length of the string. If the input string s is longer than this specified length, it will be truncated.\n\nOutputs:\n- The function returns a string that is either the original string if it is shorter than or equal to the specified length, or a truncated version of the string with ellipses appended if the original string exceeds the length limit. If the input string s is None, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef limit_length(s, length): [MASK]\n"}
{"method_name": "month_by_name", "full_method_name": "month_by_name", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nENGLISH_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May',\n    'June', 'July', 'August', 'September', 'October', 'November', 'December']\nMONTH_NAMES = {'en': ENGLISH_MONTH_NAMES, 'fr': ['janvier', 'f\u00e9vrier',\n    'mars', 'avril', 'mai', 'juin', 'juillet', 'ao\u00fbt', 'septembre',\n    'octobre', 'novembre', 'd\u00e9cembre'], 'pl': ['stycznia', 'lutego',\n    'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'wrze\u015bnia',\n    'pa\u017adziernika', 'listopada', 'grudnia']}\ndef month_by_name(name, lang='en'):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n    month_names = MONTH_NAMES.get(lang, MONTH_NAMES['en'])\n    try:\n        return month_names.index(name) + 1\n    except ValueError:\n        return None", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_month_by_name(self):\n        self.assertEqual(month_by_name(None), None)\n        self.assertEqual(month_by_name('December', 'en'), 12)\n        self.assertEqual(month_by_name('d\u00e9cembre', 'fr'), 12)\n        self.assertEqual(month_by_name('December'), 12)\n        self.assertEqual(month_by_name('d\u00e9cembre'), None)\n        self.assertEqual(month_by_name('Unknown', 'unknown'), None)\n    \nTestUtil().test_month_by_name()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function 'month_by_name' is designed to return the numerical representation of a month given its name, with support for multiple languages. It takes a month name and a language code as input, and outputs the month number (1-12) if the name is found in the specified language's month names list. If the name is not found, it returns None.\n\nInputs: \n1. name (str): The name of the month in string format. The input name is case-sensitive and should match exactly with the names in the internal list.\n2. lang (str, optional): A two-letter language code (default is 'en' for English). The function supports English ('en'), French ('fr'), and Polish ('pl').\n\nOutputs:\n- If the month name is found for the specified language, the function returns the month number as an integer (1 for January, 2 for February, etc.).\n- If the month name is not found, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nENGLISH_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May',\n    'June', 'July', 'August', 'September', 'October', 'November', 'December']\nMONTH_NAMES = {'en': ENGLISH_MONTH_NAMES, 'fr': ['janvier', 'f\u00e9vrier',\n    'mars', 'avril', 'mai', 'juin', 'juillet', 'ao\u00fbt', 'septembre',\n    'octobre', 'novembre', 'd\u00e9cembre'], 'pl': ['stycznia', 'lutego',\n    'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'wrze\u015bnia',\n    'pa\u017adziernika', 'listopada', 'grudnia']}\n\n\ndef month_by_name(name, lang='en'): [MASK]\n"}
{"method_name": "normalize_url", "full_method_name": "normalize_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/networking.py", "method_code": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    return urllib.parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\ndef normalize_url(url):\n    \"\"\"Normalize URL as suggested by RFC 3986\"\"\"\n    url_parsed = urllib.parse.urlparse(url)\n    return url_parsed._replace(netloc=url_parsed.netloc.encode('idna').\n        decode('ascii'), path=escape_rfc3986(remove_dot_segments(url_parsed\n        .path)), params=escape_rfc3986(url_parsed.params), query=\n        escape_rfc3986(url_parsed.query), fragment=escape_rfc3986(\n        url_parsed.fragment)).geturl()", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_normalize_url(self):\n        self.assertEqual(normalize_url(\n            'http://wowza.imust.org/srv/vod/telemb/new/UPLOAD/UPLOAD/20224_IncendieHavre\u0301_FD.mp4'\n            ),\n            'http://wowza.imust.org/srv/vod/telemb/new/UPLOAD/UPLOAD/20224_IncendieHavre%CC%81_FD.mp4'\n            )\n        self.assertEqual(normalize_url(\n            'http://www.ardmediathek.de/tv/Sturm-der-Liebe/Folge-2036-Zu-Mann-und-Frau-erkl\u00e4rt/Das-Erste/Video?documentId=22673108&bcastId=5290'\n            ),\n            'http://www.ardmediathek.de/tv/Sturm-der-Liebe/Folge-2036-Zu-Mann-und-Frau-erkl%C3%A4rt/Das-Erste/Video?documentId=22673108&bcastId=5290'\n            )\n        self.assertEqual(normalize_url('http://\u0442\u0435\u0441\u0442.\u0440\u0444/\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442'),\n            'http://xn--e1aybc.xn--p1ai/%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82'\n            )\n        self.assertEqual(normalize_url('http://\u0442\u0435\u0441\u0442.\u0440\u0444/\u0430\u0431\u0432?\u0430\u0431\u0432=\u0430\u0431\u0432#\u0430\u0431\u0432'),\n            'http://xn--e1aybc.xn--p1ai/%D0%B0%D0%B1%D0%B2?%D0%B0%D0%B1%D0%B2=%D0%B0%D0%B1%D0%B2#%D0%B0%D0%B1%D0%B2'\n            )\n        self.assertEqual(normalize_url('http://vimeo.com/56015672#at=0'),\n            'http://vimeo.com/56015672#at=0')\n        self.assertEqual(normalize_url(\n            'http://www.example.com/../a/b/../c/./d.html'),\n            'http://www.example.com/a/c/d.html')\n    \nTestUtil().test_normalize_url()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The 'normalize_url' function aims to normalize a given URL string according to the guidelines presented in RFC 3986. This normalization process includes converting the network location ('netloc') using the IDNA (Internationalized Domain Names in Applications) encoding, removing dot segments ('.' and '..') from the path, and escaping all non-ASCII characters in the path, parameters, query, and fragment components of the URL.\n\nInputs: \n- url: A string representing a URL that needs to be normalized. The URL may contain various components like scheme, netloc, path, parameters, query, and fragment.\n\nOutputs: \n- A string representing the normalized URL. The normalized URL will have its 'netloc' component encoded using IDNA, its 'path' component free of dot segments and with non-ASCII characters escaped, and all non-ASCII characters in 'params', 'query', and 'fragment' components escaped as well. The output is formatted such that it adheres to the standards defined in RFC 3986.", "method_code_mask": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\n\n\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)\n\n\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    return urllib.parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\n\n\ndef normalize_url(url): [MASK]\n"}
{"method_name": "remove_dot_segments", "full_method_name": "remove_dot_segments", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/networking.py", "method_code": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_remove_dot_segments(self):\n        self.assertEqual(remove_dot_segments('/a/b/c/./../../g'), '/a/g')\n        self.assertEqual(remove_dot_segments('mid/content=5/../6'), 'mid/6')\n        self.assertEqual(remove_dot_segments('/ad/../cd'), '/cd')\n        self.assertEqual(remove_dot_segments('/ad/../cd/'), '/cd/')\n        self.assertEqual(remove_dot_segments('/..'), '/')\n        self.assertEqual(remove_dot_segments('/./'), '/')\n        self.assertEqual(remove_dot_segments('/./a'), '/a')\n        self.assertEqual(remove_dot_segments(\n            '/abc/./.././d/././e/.././f/./../../ghi'), '/ghi')\n        self.assertEqual(remove_dot_segments('/'), '/')\n        self.assertEqual(remove_dot_segments('/t'), '/t')\n        self.assertEqual(remove_dot_segments('t'), 't')\n        self.assertEqual(remove_dot_segments(''), '')\n        self.assertEqual(remove_dot_segments('/../a/b/c'), '/a/b/c')\n        self.assertEqual(remove_dot_segments('../a'), 'a')\n        self.assertEqual(remove_dot_segments('./a'), 'a')\n        self.assertEqual(remove_dot_segments('.'), '')\n        self.assertEqual(remove_dot_segments('////'), '////')\n    \nTestUtil().test_remove_dot_segments()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function remove_dot_segments takes a URL path and normalizes it by removing dot segments ('.') and double-dot segments ('..') that are used for navigating the directory structure. It processes the input path by splitting it into segments and reconstructs the path while ignoring '.' segments, removing '..' segments by popping the last segment from the output, and properly handling leading and trailing slashes.\n\nInputs: \n- path: a string representing a URL path that may contain '.' and '..' segments.\n\nOutputs: \n- A string representing the normalized URL path after removing dot segments. If the input path starts with a slash and has no preceding segments, the output path will start with an empty string segment. If the input path ends with a '.' or '..' segment, the output path will end with an empty string segment.", "method_code_mask": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\n\n\ndef remove_dot_segments(path): [MASK]\n"}
{"method_name": "js_to_json", "full_method_name": "js_to_json", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef js_to_json(code, vars={}, *, strict=False):\n    STRING_QUOTES = '\\'\"`'\n    STRING_RE = '|'.join(f'{q}(?:\\\\\\\\.|[^\\\\\\\\{q}])*{q}' for q in STRING_QUOTES)\n    COMMENT_RE = '/\\\\*(?:(?!\\\\*/).)*?\\\\*/|//[^\\\\n]*\\\\n'\n    SKIP_RE = f'\\\\s*(?:{COMMENT_RE})?\\\\s*'\n    INTEGER_TABLE = (f'(?s)^(0[xX][0-9a-fA-F]+){SKIP_RE}:?$', 16), (\n        f'(?s)^(0+[0-7]+){SKIP_RE}:?$', 8)\n\n    def process_escape(match):\n        JSON_PASSTHROUGH_ESCAPES = '\"\\\\bfnrtu'\n        escape = match.group(1) or match.group(2)\n        return (f'\\\\{escape}' if escape in JSON_PASSTHROUGH_ESCAPES else \n            '\\\\u00' if escape == 'x' else '' if escape == '\\n' else escape)\n\n    def template_substitute(match):\n        evaluated = js_to_json(match.group(1), vars, strict=strict)\n        if evaluated[0] == '\"':\n            return json.loads(evaluated)\n        return evaluated\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v in ('undefined', 'void 0'):\n            return 'null'\n        elif v.startswith(('/*', '//', '!')) or v == ',':\n            return ''\n        if v[0] in STRING_QUOTES:\n            v = re.sub('(?s)\\\\${([^}]+)}', template_substitute, v[1:-1]) if v[0\n                ] == '`' else v[1:-1]\n            escaped = re.sub('(?s)(\")|\\\\\\\\(.)', process_escape, v)\n            return f'\"{escaped}\"'\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return f'\"{i}\":' if v.endswith(':') else str(i)\n        if v in vars:\n            try:\n                if not strict:\n                    json.loads(vars[v])\n            except json.JSONDecodeError:\n                return json.dumps(vars[v])\n            else:\n                return vars[v]\n        if not strict:\n            return f'\"{v}\"'\n        raise ValueError(f'Unknown value: {v}')\n\n    def create_map(mobj):\n        return json.dumps(dict(json.loads(js_to_json(mobj.group(1) or '[]',\n            vars=vars))))\n    code = re.sub('(?:new\\\\s+)?Array\\\\((.*?)\\\\)', '[\\\\g<1>]', code)\n    code = re.sub('new Map\\\\((\\\\[.*?\\\\])?\\\\)', create_map, code)\n    if not strict:\n        code = re.sub(f'new Date\\\\(({STRING_RE})\\\\)', '\\\\g<1>', code)\n        code = re.sub('new \\\\w+\\\\((.*?)\\\\)', lambda m: json.dumps(m.group(0\n            )), code)\n        code = re.sub('parseInt\\\\([^\\\\d]+(\\\\d+)[^\\\\d]+\\\\)', '\\\\1', code)\n        code = re.sub(\n            '\\\\(function\\\\([^)]*\\\\)\\\\s*\\\\{[^}]*\\\\}\\\\s*\\\\)\\\\s*\\\\(\\\\s*([\"\\\\\\'][^)]*[\"\\\\\\'])\\\\s*\\\\)'\n            , '\\\\1', code)\n    return re.sub(\n        f\"\"\"(?sx)\n        {STRING_RE}|\n        {COMMENT_RE}|,(?={SKIP_RE}[\\\\]}}])|\n        void\\\\s0|(?:(?<![0-9])[eE]|[a-df-zA-DF-Z_$])[.a-zA-Z_$0-9]*|\n        \\\\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{SKIP_RE}:)?|\n        [0-9]+(?={SKIP_RE}:)|\n        !+\n        \"\"\"\n        , fix_kv, code)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_vars_strings(self):\n        self.assertDictEqual(json.loads(js_to_json(\n            \"\"\"{\n                        'null': a,\n                        'nullStr': b,\n                        'true': c,\n                        'trueStr': d,\n                        'false': e,\n                        'falseStr': f,\n                        'unresolvedVar': g,\n                    }\"\"\"\n            , {'a': 'null', 'b': '\"null\"', 'c': 'true', 'd': '\"true\"', 'e':\n            'false', 'f': '\"false\"', 'g': 'var'})), {'null': None, 'nullStr':\n            'null', 'true': True, 'trueStr': 'true', 'false': False, 'falseStr':\n            'false', 'unresolvedVar': 'var'})\n        self.assertDictEqual(json.loads(js_to_json(\n            \"\"\"{\n                        'int': a,\n                        'intStr': b,\n                        'float': c,\n                        'floatStr': d,\n                    }\"\"\"\n            , {'a': '123', 'b': '\"123\"', 'c': '1.23', 'd': '\"1.23\"'})), {'int':\n            123, 'intStr': '123', 'float': 1.23, 'floatStr': '1.23'})\n        self.assertDictEqual(json.loads(js_to_json(\n            \"\"\"{\n                        'object': a,\n                        'objectStr': b,\n                        'array': c,\n                        'arrayStr': d,\n                    }\"\"\"\n            , {'a': '{}', 'b': '\"{}\"', 'c': '[]', 'd': '\"[]\"'})), {'object': {},\n            'objectStr': '{}', 'array': [], 'arrayStr': '[]'})\n    \nTestUtil().test_js_to_json_vars_strings()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_realworld(self):\n        inp = \"\"\"{\n                'clip':{'provider':'pseudo'}\n            }\"\"\"\n        self.assertEqual(js_to_json(inp),\n            \"\"\"{\n                \"clip\":{\"provider\":\"pseudo\"}\n            }\"\"\")\n        json.loads(js_to_json(inp))\n        inp = \"\"\"{\n                'playlist':[{'controls':{'all':null}}]\n            }\"\"\"\n        self.assertEqual(js_to_json(inp),\n            \"\"\"{\n                \"playlist\":[{\"controls\":{\"all\":null}}]\n            }\"\"\")\n        inp = '\"The CW\\\\\\'s \\\\\\'Crazy Ex-Girlfriend\\\\\\'\"'\n        self.assertEqual(js_to_json(inp), '\"The CW\\'s \\'Crazy Ex-Girlfriend\\'\"')\n        inp = (\n            '\"SAND Number: SAND 2013-7800P\\\\nPresenter: Tom Russo\\\\nHabanero Software Training - Xyce Software\\\\nXyce, Sandia\\\\u0027s\"'\n            )\n        json_code = js_to_json(inp)\n        self.assertEqual(json.loads(json_code), json.loads(inp))\n        inp = \"\"\"{\n                0:{src:'skipped', type: 'application/dash+xml'},\n                1:{src:'skipped', type: 'application/vnd.apple.mpegURL'},\n            }\"\"\"\n        self.assertEqual(js_to_json(inp),\n            \"\"\"{\n                \"0\":{\"src\":\"skipped\", \"type\": \"application/dash+xml\"},\n                \"1\":{\"src\":\"skipped\", \"type\": \"application/vnd.apple.mpegURL\"}\n            }\"\"\"\n            )\n        inp = '{\"foo\":101}'\n        self.assertEqual(js_to_json(inp), '{\"foo\":101}')\n        inp = '{\"duration\": \"00:01:07\"}'\n        self.assertEqual(js_to_json(inp), '{\"duration\": \"00:01:07\"}')\n        inp = (\n            '{segments: [{\"offset\":-3.885780586188048e-16,\"duration\":39.75000000000001}]}'\n            )\n        self.assertEqual(js_to_json(inp),\n            '{\"segments\": [{\"offset\":-3.885780586188048e-16,\"duration\":39.75000000000001}]}'\n            )\n    \nTestUtil().test_js_to_json_realworld()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_edgecases(self):\n        on = js_to_json('{abc_def:\\'1\\\\\\'\\\\\\\\2\\\\\\\\\\\\\\'3\"4\\'}')\n        self.assertEqual(json.loads(on), {'abc_def': '1\\'\\\\2\\\\\\'3\"4'})\n        on = js_to_json('{\"abc\": true}')\n        self.assertEqual(json.loads(on), {'abc': True})\n        on = js_to_json(\n            \"\"\"{\n                \"x\": 1,\n                y: \"a\",\n                z: some.code\n            }\"\"\"\n            )\n        d = json.loads(on)\n        self.assertEqual(d['x'], 1)\n        self.assertEqual(d['y'], 'a')\n        on = js_to_json(\n            \"\"\"{\n                a: !0,\n                b: !1,\n                c: !!0,\n                d: !!42.42,\n                e: !!![],\n                f: !\"abc\",\n                g: !\"\",\n                !42: 42\n            }\"\"\"\n            )\n        self.assertEqual(json.loads(on), {'a': 0, 'b': 1, 'c': 0, 'd': 42.42,\n            'e': [], 'f': 'abc', 'g': '', '42': 42})\n        on = js_to_json('[\"abc\", \"def\",]')\n        self.assertEqual(json.loads(on), ['abc', 'def'])\n        on = js_to_json(\n            '[/*comment\\n*/\"abc\"/*comment\\n*/,/*comment\\n*/\"def\",/*comment\\n*/]')\n        self.assertEqual(json.loads(on), ['abc', 'def'])\n        on = js_to_json(\n            '[//comment\\n\"abc\" //comment\\n,//comment\\n\"def\",//comment\\n]')\n        self.assertEqual(json.loads(on), ['abc', 'def'])\n        on = js_to_json('{\"abc\": \"def\",}')\n        self.assertEqual(json.loads(on), {'abc': 'def'})\n        on = js_to_json(\n            \"\"\"{/*comment\n    */\"abc\"/*comment\n    */:/*comment\n    */\"def\"/*comment\n    */,/*comment\n    */}\"\"\"\n            )\n        self.assertEqual(json.loads(on), {'abc': 'def'})\n        on = js_to_json('{ 0: /* \" \\n */ \",]\" , }')\n        self.assertEqual(json.loads(on), {'0': ',]'})\n        on = js_to_json('{ /*comment\\n*/0/*comment\\n*/: /* \" \\n */ \",]\" , }')\n        self.assertEqual(json.loads(on), {'0': ',]'})\n        on = js_to_json('{ 0: // comment\\n1 }')\n        self.assertEqual(json.loads(on), {'0': 1})\n        on = js_to_json('[\"<p>x<\\\\/p>\"]')\n        self.assertEqual(json.loads(on), ['<p>x</p>'])\n        on = js_to_json('[\"\\\\xaa\"]')\n        self.assertEqual(json.loads(on), ['\u00aa'])\n        on = js_to_json(\"['a\\\\\\nb']\")\n        self.assertEqual(json.loads(on), ['ab'])\n        on = js_to_json(\n            \"/*comment\\n*/[/*comment\\n*/'a\\\\\\nb'/*comment\\n*/]/*comment\\n*/\")\n        self.assertEqual(json.loads(on), ['ab'])\n        on = js_to_json('{0xff:0xff}')\n        self.assertEqual(json.loads(on), {'255': 255})\n        on = js_to_json(\n            '{/*comment\\n*/0xff/*comment\\n*/:/*comment\\n*/0xff/*comment\\n*/}')\n        self.assertEqual(json.loads(on), {'255': 255})\n        on = js_to_json('{077:077}')\n        self.assertEqual(json.loads(on), {'63': 63})\n        on = js_to_json(\n            '{/*comment\\n*/077/*comment\\n*/:/*comment\\n*/077/*comment\\n*/}')\n        self.assertEqual(json.loads(on), {'63': 63})\n        on = js_to_json('{42:42}')\n        self.assertEqual(json.loads(on), {'42': 42})\n        on = js_to_json(\n            '{/*comment\\n*/42/*comment\\n*/:/*comment\\n*/42/*comment\\n*/}')\n        self.assertEqual(json.loads(on), {'42': 42})\n        on = js_to_json('{42:4.2e1}')\n        self.assertEqual(json.loads(on), {'42': 42.0})\n        on = js_to_json('{ \"0x40\": \"0x40\" }')\n        self.assertEqual(json.loads(on), {'0x40': '0x40'})\n        on = js_to_json('{ \"040\": \"040\" }')\n        self.assertEqual(json.loads(on), {'040': '040'})\n        on = js_to_json('[1,//{},\\n2]')\n        self.assertEqual(json.loads(on), [1, 2])\n        on = js_to_json('\"\\\\^\\\\$\\\\#\"')\n        self.assertEqual(json.loads(on), '^$#', msg=\n            'Unnecessary escapes should be stripped')\n        on = js_to_json('\\'\"\\\\\"\"\\'')\n        self.assertEqual(json.loads(on), '\"\"\"', msg=\n            'Unnecessary quote escape should be escaped')\n        on = js_to_json('[new Date(\"spam\"), \\'(\"eggs\")\\']')\n        self.assertEqual(json.loads(on), ['spam', '(\"eggs\")'], msg=\n            'Date regex should match a single string')\n    \nTestUtil().test_js_to_json_edgecases()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_malformed(self):\n        self.assertEqual(js_to_json('42a1'), '42\"a1\"')\n        self.assertEqual(js_to_json('42a-1'), '42\"a\"-1')\n    \nTestUtil().test_js_to_json_malformed()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_template_literal(self):\n        self.assertEqual(js_to_json('`Hello ${name}`', {'name': '\"world\"'}),\n            '\"Hello world\"')\n        self.assertEqual(js_to_json('`${name}${name}`', {'name': '\"X\"'}), '\"XX\"')\n        self.assertEqual(js_to_json('`${name}${name}`', {'name': '5'}), '\"55\"')\n        self.assertEqual(js_to_json('`${name}\"${name}\"`', {'name': '5'}),\n            '\"5\\\\\"5\\\\\"\"')\n        self.assertEqual(js_to_json('`${name}`', {}), '\"name\"')\n    \nTestUtil().test_js_to_json_template_literal()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}, {"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_js_to_json_common_constructors(self):\n        self.assertEqual(json.loads(js_to_json('new Map([[\"a\", 5]])')), {'a': 5})\n        self.assertEqual(json.loads(js_to_json('Array(5, 10)')), [5, 10])\n        self.assertEqual(json.loads(js_to_json('new Array(15,5)')), [15, 5])\n        self.assertEqual(json.loads(js_to_json(\n            'new Map([Array(5, 10),new Array(15,5)])')), {'5': 10, '15': 5})\n        self.assertEqual(json.loads(js_to_json('new Date(\"123\")')), '123')\n        self.assertEqual(json.loads(js_to_json(\"new Date('2023-10-19')\")),\n            '2023-10-19')\n    \nTestUtil().test_js_to_json_common_constructors()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Convert a JavaScript code snippet into a JSON representation that can be parsed by Python's json module. This involves handling various JavaScript constructs such as strings, numbers, booleans, null, arrays, objects, and template literals, and converting them into their equivalent JSON representations. It also allows substitution of predefined variables using the vars parameter.\n\nInputs: \n1. code (str): A string containing the JavaScript code to be converted to JSON.\n2. vars (dict, optional): A dictionary containing variable names as keys and their corresponding values. Used for substitution in the code during conversion.\n3. strict (bool, optional): A boolean flag that, when set to True, raises an exception if an unknown value is encountered during conversion. If False, unknown values are quoted and included in the output.\n\nOutputs:\n1. json_str (str): A string that represents the input JavaScript code in JSON format, which can be parsed using Python's json module.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef js_to_json(code, vars={}, *, strict=False): [MASK]\n"}
{"method_name": "clean_html", "full_method_name": "clean_html", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert isinstance(s, str)\n    return re.sub('&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n    if html is None:\n        return html\n    html = re.sub('\\\\s+', ' ', html)\n    html = re.sub('(?u)\\\\s?<\\\\s?br\\\\s?/?\\\\s?>\\\\s?', '\\n', html)\n    html = re.sub('(?u)<\\\\s?/\\\\s?p\\\\s?>\\\\s?<\\\\s?p[^>]*>', '\\n', html)\n    html = re.sub('<.*?>', '', html)\n    html = unescapeHTML(html)\n    return html.strip()", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_clean_html(self):\n        self.assertEqual(clean_html('a:\\nb'), 'a: b')\n        self.assertEqual(clean_html('a:\\n   \"b\"'), 'a: \"b\"')\n        self.assertEqual(clean_html('a<br>\\xa0b'), 'a\\nb')\n    \nTestUtil().test_clean_html()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The clean_html function takes an HTML snippet as input and cleans it into a readable string. It removes unnecessary spaces, replaces HTML line break tags with newlines, replaces paragraph tags with newlines, removes all other HTML tags, and unescapes HTML entities.\n\nInputs: \n- html: A string representing an HTML snippet. If None is provided, the function returns None without performing any operations.\n\nOutputs:\n- A string that is the cleaned, readable version of the input HTML snippet. If the input is None, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert isinstance(s, str)\n    return re.sub('&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\n\n\ndef clean_html(html): [MASK]\n"}
{"method_name": "intlist_to_bytes", "full_method_name": "intlist_to_bytes", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    return struct.pack('%dB' % len(xs), *xs)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_intlist_to_bytes(self):\n        self.assertEqual(intlist_to_bytes([0, 1, 127, 128, 255]),\n            b'\\x00\\x01\\x7f\\x80\\xff')\n    \nTestUtil().test_intlist_to_bytes()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function 'intlist_to_bytes' takes a list of integers as input and converts it into a bytes object. Each integer in the list should ideally represent a byte (values from 0 to 255). The function uses the 'struct' module to pack the integers into the byte format.\n\nInputs: \n- xs: A list of integers (list). The list should only contain integers that represent byte values, i.e., integers in the range 0-255.\n\nOutputs: \n- The function returns a bytes object. This bytes object is the result of packing the integers from the input list according to the 'struct' module's format for bytes. If the input list is empty, the function should return an empty bytes object (b'').", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef intlist_to_bytes(xs): [MASK]\n"}
{"method_name": "parse_filesize", "full_method_name": "parse_filesize", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\ndef parse_filesize(s):\n    if s is None:\n        return None\n    _UNIT_TABLE = {'B': 1, 'b': 1, 'bytes': 1, 'KiB': 1024, 'KB': 1000,\n        'kB': 1024, 'Kb': 1000, 'kb': 1000, 'kilobytes': 1000, 'kibibytes':\n        1024, 'MiB': 1024 ** 2, 'MB': 1000 ** 2, 'mB': 1024 ** 2, 'Mb':\n        1000 ** 2, 'mb': 1000 ** 2, 'megabytes': 1000 ** 2, 'mebibytes':\n        1024 ** 2, 'GiB': 1024 ** 3, 'GB': 1000 ** 3, 'gB': 1024 ** 3, 'Gb':\n        1000 ** 3, 'gb': 1000 ** 3, 'gigabytes': 1000 ** 3, 'gibibytes':\n        1024 ** 3, 'TiB': 1024 ** 4, 'TB': 1000 ** 4, 'tB': 1024 ** 4, 'Tb':\n        1000 ** 4, 'tb': 1000 ** 4, 'terabytes': 1000 ** 4, 'tebibytes':\n        1024 ** 4, 'PiB': 1024 ** 5, 'PB': 1000 ** 5, 'pB': 1024 ** 5, 'Pb':\n        1000 ** 5, 'pb': 1000 ** 5, 'petabytes': 1000 ** 5, 'pebibytes':\n        1024 ** 5, 'EiB': 1024 ** 6, 'EB': 1000 ** 6, 'eB': 1024 ** 6, 'Eb':\n        1000 ** 6, 'eb': 1000 ** 6, 'exabytes': 1000 ** 6, 'exbibytes':\n        1024 ** 6, 'ZiB': 1024 ** 7, 'ZB': 1000 ** 7, 'zB': 1024 ** 7, 'Zb':\n        1000 ** 7, 'zb': 1000 ** 7, 'zettabytes': 1000 ** 7, 'zebibytes':\n        1024 ** 7, 'YiB': 1024 ** 8, 'YB': 1000 ** 8, 'yB': 1024 ** 8, 'Yb':\n        1000 ** 8, 'yb': 1000 ** 8, 'yottabytes': 1000 ** 8, 'yobibytes':\n        1024 ** 8}\n    return lookup_unit_table(_UNIT_TABLE, s)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_filesize(self):\n        self.assertEqual(parse_filesize(None), None)\n        self.assertEqual(parse_filesize(''), None)\n        self.assertEqual(parse_filesize('91 B'), 91)\n        self.assertEqual(parse_filesize('foobar'), None)\n        self.assertEqual(parse_filesize('2 MiB'), 2097152)\n        self.assertEqual(parse_filesize('5 GB'), 5000000000)\n        self.assertEqual(parse_filesize('1.2Tb'), 1200000000000)\n        self.assertEqual(parse_filesize('1.2tb'), 1200000000000)\n        self.assertEqual(parse_filesize('1,24 KB'), 1240)\n        self.assertEqual(parse_filesize('1,24 kb'), 1240)\n        self.assertEqual(parse_filesize('8.5 megabytes'), 8500000)\n    \nTestUtil().test_parse_filesize()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The parse_filesize function is designed to convert a string representing a file size into its corresponding integer value in bytes. It supports a variety of units, including bytes (B), kilobytes (KB, kB), megabytes (MB, MB), gigabytes (GB, GB), and larger units up to yottabytes (YB, YB), in both binary (using 'i' prefix, such as MiB for mebibytes) and decimal (no prefix) forms. The function ignores any non-numeric and non-unit characters in the input string and applies strict rules for decimal point representation (using a period) and unit separation (using a space).\n\nInputs: A string s representing a file size with a numeric value and a unit. The string can be in the format \"number unit\", \"number.unit unit\", \"number,unit unit\", or \"number.unitunit\", with the last two formats only considered valid if strict parsing is not enforced.\n\nOutputs: An integer representing the file size in bytes. If the input string is None or does not match any valid format, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\n\n\ndef parse_filesize(s): [MASK]\n"}
{"method_name": "parse_count", "full_method_name": "parse_count", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\ndef parse_count(s):\n    if s is None:\n        return None\n    s = re.sub('^[^\\\\d]+\\\\s', '', s).strip()\n    if re.match('^[\\\\d,.]+$', s):\n        return str_to_int(s)\n    _UNIT_TABLE = {'k': 1000, 'K': 1000, 'm': 1000 ** 2, 'M': 1000 ** 2,\n        'kk': 1000 ** 2, 'KK': 1000 ** 2, 'b': 1000 ** 3, 'B': 1000 ** 3}\n    ret = lookup_unit_table(_UNIT_TABLE, s)\n    if ret is not None:\n        return ret\n    mobj = re.match('([\\\\d,.]+)(?:$|\\\\s)', s)\n    if mobj:\n        return str_to_int(mobj.group(1))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_count(self):\n        self.assertEqual(parse_count(None), None)\n        self.assertEqual(parse_count(''), None)\n        self.assertEqual(parse_count('0'), 0)\n        self.assertEqual(parse_count('1000'), 1000)\n        self.assertEqual(parse_count('1.000'), 1000)\n        self.assertEqual(parse_count('1.1k'), 1100)\n        self.assertEqual(parse_count('1.1 k'), 1100)\n        self.assertEqual(parse_count('1,1 k'), 1100)\n        self.assertEqual(parse_count('1.1kk'), 1100000)\n        self.assertEqual(parse_count('1.1kk '), 1100000)\n        self.assertEqual(parse_count('1,1kk'), 1100000)\n        self.assertEqual(parse_count('100 views'), 100)\n        self.assertEqual(parse_count('1,100 views'), 1100)\n        self.assertEqual(parse_count('1.1kk views'), 1100000)\n        self.assertEqual(parse_count('10M views'), 10000000)\n        self.assertEqual(parse_count('has 10M views'), 10000000)\n    \nTestUtil().test_parse_count()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The parse_count function is designed to parse and return an integer value from a given string input. It is capable of handling strings that may contain non-numeric characters before the numeric part and can interpret various units (like 'k' for thousand, 'm' for million, etc.) to scale the numeric value accordingly.\n\nInputs: \n- s (str): A string that potentially contains a numeric value possibly followed by a unit indicator (e.g., '1.2k', '3m', '4,500').\n\nOutputs: \n- int or None: The function returns an integer representation of the numeric value found in the input string, scaled according to the unit provided (if any). If the input is 'None' or contains no recognizable numeric value or unit, the function returns 'None'.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)\n\n\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\n\n\ndef parse_count(s): [MASK]\n"}
{"method_name": "parse_resolution", "full_method_name": "parse_resolution", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_resolution(s, *, lenient=False):\n    if s is None:\n        return {}\n    if lenient:\n        mobj = re.search('(?P<w>\\\\d+)\\\\s*[xX\u00d7,]\\\\s*(?P<h>\\\\d+)', s)\n    else:\n        mobj = re.search(\n            '(?<![a-zA-Z0-9])(?P<w>\\\\d+)\\\\s*[xX\u00d7,]\\\\s*(?P<h>\\\\d+)(?![a-zA-Z0-9])'\n            , s)\n    if mobj:\n        return {'width': int(mobj.group('w')), 'height': int(mobj.group('h'))}\n    mobj = re.search('(?<![a-zA-Z0-9])(\\\\d+)[pPiI](?![a-zA-Z0-9])', s)\n    if mobj:\n        return {'height': int(mobj.group(1))}\n    mobj = re.search('\\\\b([48])[kK]\\\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1)) * 540}\n    return {}", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_resolution(self):\n        self.assertEqual(parse_resolution(None), {})\n        self.assertEqual(parse_resolution(''), {})\n        self.assertEqual(parse_resolution(' 1920x1080'), {'width': 1920,\n            'height': 1080})\n        self.assertEqual(parse_resolution('1920\u00d71080 '), {'width': 1920,\n            'height': 1080})\n        self.assertEqual(parse_resolution('1920 x 1080'), {'width': 1920,\n            'height': 1080})\n        self.assertEqual(parse_resolution('720p'), {'height': 720})\n        self.assertEqual(parse_resolution('4k'), {'height': 2160})\n        self.assertEqual(parse_resolution('8K'), {'height': 4320})\n        self.assertEqual(parse_resolution('pre_1920x1080_post'), {'width': 1920,\n            'height': 1080})\n        self.assertEqual(parse_resolution('ep1x2'), {})\n        self.assertEqual(parse_resolution('1920, 1080'), {'width': 1920,\n            'height': 1080})\n    \nTestUtil().test_parse_resolution()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The parse_resolution function is designed to interpret strings that represent screen resolutions and to convert them into a dictionary format that can be easily used in software applications. This function will accept a string input and attempt to extract width and height values from it, based on common resolution notation patterns. Additionally, it can handle lenient or strict parsing based on the lenient parameter.\n\nInputs: \n- s (str): A string representing screen resolution. This can be in various formats, such as \"1920x1080\", \"1080p\", or \"8k\".\n- lenient (bool): A boolean flag that determines the parsing behavior. If True, the function will attempt to parse the resolution in a lenient manner, allowing for more flexible input formats. If False, the parsing will be strict, expecting only specific formats (e.g., \"1080p\", \"1920x1080\").\n\nOutputs:\n- A dictionary containing:\n    - 'width' (int): The width of the screen resolution, or None if it cannot be determined.\n    - 'height' (int): The height of the screen resolution, or None if it cannot be determined.\nIf the input string does not conform to any known resolution format, the function will return an empty dictionary.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_resolution(s, *, lenient=False): [MASK]\n"}
{"method_name": "parse_bitrate", "full_method_name": "parse_bitrate", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_bitrate(s):\n    if not isinstance(s, str):\n        return\n    mobj = re.search('\\\\b(\\\\d+)\\\\s*kbps', s)\n    if mobj:\n        return int(mobj.group(1))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_bitrate(self):\n        self.assertEqual(parse_bitrate(None), None)\n        self.assertEqual(parse_bitrate(''), None)\n        self.assertEqual(parse_bitrate('300kbps'), 300)\n        self.assertEqual(parse_bitrate('1500kbps'), 1500)\n        self.assertEqual(parse_bitrate('300 kbps'), 300)\n    \nTestUtil().test_parse_bitrate()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function parse_bitrate should parse a string for a bitrate value. It should recognize a number followed by 'kbps' and return that number as an integer. If the input is not a string or does not contain a valid bitrate, the function should return None.\n\nInputs: \n- s (str): A string that might contain a bitrate value.\n\nOutputs: \n- int: The bitrate value in Kbps if found, or None if no valid bitrate was found or the input is not a string.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_bitrate(s): [MASK]\n"}
{"method_name": "age_restricted", "full_method_name": "age_restricted", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef age_restricted(content_limit, age_limit):\n    \"\"\" Returns True iff the content should be blocked \"\"\"\n    if age_limit is None:\n        return False\n    if content_limit is None:\n        return False\n    return age_limit < content_limit", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_age_restricted(self):\n        self.assertFalse(age_restricted(None, 10))\n        self.assertFalse(age_restricted(1, None))\n        self.assertFalse(age_restricted(8, 10))\n        self.assertTrue(age_restricted(18, 14))\n        self.assertFalse(age_restricted(18, 18))\n    \nTestUtil().test_age_restricted()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function age_restricted determines whether content should be blocked based on the given content age limit and the user's age. It returns True if the user's age is less than the content's age limit, indicating that the content should be restricted for the user. Otherwise, it returns False.\n\nInputs: \n- content_limit: An integer representing the minimum age required to access the content. If None, it indicates that there is no age restriction on the content.\n- age_limit: An integer representing the age of the user. If None, it indicates that the user's age is unknown.\n\nOutputs:\n- A boolean value indicating whether the content should be blocked for the user. True if the user's age is less than the content's age limit, False otherwise.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef age_restricted(content_limit, age_limit): [MASK]\n"}
{"method_name": "is_html", "full_method_name": "is_html", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\ndef is_html(first_bytes):\n    \"\"\" Detect whether a file contains HTML by examining its first bytes. \"\"\"\n    encoding = 'utf-8'\n    for bom, enc in BOMS:\n        while first_bytes.startswith(bom):\n            encoding, first_bytes = enc, first_bytes[len(bom):]\n    return re.match('^\\\\s*<', first_bytes.decode(encoding, 'replace'))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_is_html(self):\n        self.assertFalse(is_html(b'IDC<html'))\n        self.assertTrue(is_html(b'<!DOCTYPE foo>\\xaaa'))\n        self.assertTrue(is_html(b'\\xef\\xbb\\xbf<!DOCTYPE foo>\\xaaa'))\n        self.assertTrue(is_html(b'\\xff\\xfe<\\x00h\\x00t\\x00m\\x00l\\x00>\\x00\\xe4\\x00'))\n        self.assertTrue(is_html(b'\\xfe\\xff\\x00<\\x00h\\x00t\\x00m\\x00l\\x00>\\x00\\xe4'))\n        self.assertTrue(is_html(\n            b'\\x00\\x00\\xfe\\xff\\x00\\x00\\x00<\\x00\\x00\\x00h\\x00\\x00\\x00t\\x00\\x00\\x00m\\x00\\x00\\x00l\\x00\\x00\\x00>\\x00\\x00\\x00\\xe4'\n            ))\n        self.assertTrue(is_html(\n            b'\\xff\\xfe\\x00\\x00<\\x00\\x00\\x00h\\x00\\x00\\x00t\\x00\\x00\\x00m\\x00\\x00\\x00l\\x00\\x00\\x00>\\x00\\x00\\x00\\xe4\\x00\\x00\\x00'\n            ))\n    \nTestUtil().test_is_html()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The is_html function is intended to determine whether a file contains HTML content. This is achieved by examining the first few bytes of the file to check for the presence of HTML tags.\n\nInputs: The function takes a single argument:\n- first_bytes: A bytes object that represents the first few bytes of a file. This argument is expected to contain enough information to identify the file type, typically the first 512 bytes or so.\n\nOutputs: The function returns a boolean value:\n- True: If the content represented by first_bytes is determined to be HTML.\n- False: If the content represented by first_bytes is not determined to be HTML.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\n\n\ndef is_html(first_bytes): [MASK]\n"}
{"method_name": "parse_dfxp_time_expr", "full_method_name": "parse_dfxp_time_expr", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef parse_dfxp_time_expr(time_expr):\n    if not time_expr:\n        return\n    mobj = re.match(f'^(?P<time_offset>{NUMBER_RE})s?$', time_expr)\n    if mobj:\n        return float(mobj.group('time_offset'))\n    mobj = re.match('^(\\\\d+):(\\\\d\\\\d):(\\\\d\\\\d(?:(?:\\\\.|:)\\\\d+)?)$', time_expr)\n    if mobj:\n        return 3600 * int(mobj.group(1)) + 60 * int(mobj.group(2)) + float(mobj\n            .group(3).replace(':', '.'))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_parse_dfxp_time_expr(self):\n        self.assertEqual(parse_dfxp_time_expr(None), None)\n        self.assertEqual(parse_dfxp_time_expr(''), None)\n        self.assertEqual(parse_dfxp_time_expr('0.1'), 0.1)\n        self.assertEqual(parse_dfxp_time_expr('0.1s'), 0.1)\n        self.assertEqual(parse_dfxp_time_expr('00:00:01'), 1.0)\n        self.assertEqual(parse_dfxp_time_expr('00:00:01.100'), 1.1)\n        self.assertEqual(parse_dfxp_time_expr('00:00:01:100'), 1.1)\n    \nTestUtil().test_parse_dfxp_time_expr()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The function parse_dfxp_time_expr is designed to parse time expressions found in DFXP (Dublin Core XML Profile) files, converting them into a float representing the time in seconds. It supports parsing simple time offsets and full time expressions in the format of hours:minutes:seconds.\n\nInputs: \n- time_expr: A string representing the time expression. It can be a simple time offset (e.g., \"3s\", \"4.5\") or a full time expression (e.g., \"01:30:45\", \"01:30:45.5\").\n\nOutputs: \n- If the time expression is a simple offset, the function returns a float representing the time in seconds.\n- If the time expression is a full time format, the function returns the total time in seconds, calculated as hours * 3600 + minutes * 60 + seconds.\n- If the input string is empty or does not match the expected formats, the function returns None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef parse_dfxp_time_expr(time_expr): [MASK]\n"}
{"method_name": "cli_option", "full_method_name": "cli_option", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef cli_option(params, command_option, param, separator=None):\n    param = params.get(param)\n    return [] if param is None else [command_option, str(param)\n        ] if separator is None else [f'{command_option}{separator}{param}']", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_cli_option(self):\n        self.assertEqual(cli_option({'proxy': '127.0.0.1:3128'}, '--proxy',\n            'proxy'), ['--proxy', '127.0.0.1:3128'])\n        self.assertEqual(cli_option({'proxy': None}, '--proxy', 'proxy'), [])\n        self.assertEqual(cli_option({}, '--proxy', 'proxy'), [])\n        self.assertEqual(cli_option({'retries': 10}, '--retries', 'retries'), [\n            '--retries', '10'])\n    \nTestUtil().test_cli_option()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The cli_option function is designed to format command-line options based on given parameters. It takes parameters and generates a list representing a command-line option with its respective value if the parameter exists. If a separator is provided, it concatenates the command option and the parameter value using the separator.\n\nInputs:\n1. params: A dictionary containing the parameters and their associated values. The key is the parameter name, and its value is the parameter's value.\n2. command_option: A string representing the command-line option to be formatted (e.g., \"--option\").\n3. param: A string representing the parameter name to look up in the params dictionary.\n4. separator: An optional string to be used as a separator between the command_option and the value of the parameter. If None, it returns the option and the value as separate strings.\n\nOutputs:\nThe function returns a list. If the parameter is found in the dictionary and a separator is not provided, it returns a list containing the command_option string and the string representation of the parameter value. If a separator is provided, it returns a single-element list where the element is a string concatenating the command_option and the parameter value with the separator in between. If the parameter is not found in the dictionary, it returns an empty list.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef cli_option(params, command_option, param, separator=None): [MASK]\n"}
{"method_name": "ohdave_rsa_encrypt", "full_method_name": "ohdave_rsa_encrypt", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef ohdave_rsa_encrypt(data, exponent, modulus):\n    \"\"\"\n    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/\n\n    Input:\n        data: data to encrypt, bytes-like object\n        exponent, modulus: parameter e and N of RSA algorithm, both integer\n    Output: hex string of encrypted data\n\n    Limitation: supports one block encryption only\n    \"\"\"\n    payload = int(binascii.hexlify(data[::-1]), 16)\n    encrypted = pow(payload, exponent, modulus)\n    return f'{encrypted:x}'", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_ohdave_rsa_encrypt(self):\n        N = (\n            8983556970082806072261113298370959076142893170423488416059191100210358114802049032983889493302173157165863643606239492524847800665553743035328512591065037\n            )\n        e = 65537\n        self.assertEqual(ohdave_rsa_encrypt(b'aa111222', e, N),\n            '726664bd9a23fd0c70f9f1b84aab5e3905ce1e45a584e9cbcf9bcc7510338fc1986d6c599ff990d923aa43c51c0d9013cd572e13bc58f4ae48f2ed8c0b0ba881'\n            )\n    \nTestUtil().test_ohdave_rsa_encrypt()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The ohdave_rsa_encrypt function implements OHDave's RSA encryption algorithm to encrypt a given data. The function takes the data, an exponent, and a modulus as inputs, and returns the encrypted data as a hexadecimal string. It supports encryption of a single block of data only.\n\nInputs: \n    - data: The data to be encrypted, provided as a bytes-like object.\n    - exponent: The exponent (e) used in the RSA algorithm, provided as an integer.\n    - modulus: The modulus (N) used in the RSA algorithm, also provided as an integer.\n\nOutputs:\n    - A hexadecimal string representing the encrypted data.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef ohdave_rsa_encrypt(data, exponent, modulus): [MASK]\n"}
{"method_name": "pkcs1pad", "full_method_name": "pkcs1pad", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef pkcs1pad(data, length):\n    \"\"\"\n    Padding input data with PKCS#1 scheme\n\n    @param {int[]} data        input data\n    @param {int}   length      target length\n    @returns {int[]}           padded data\n    \"\"\"\n    if len(data) > length - 11:\n        raise ValueError('Input data too long for PKCS#1 padding')\n    pseudo_random = [random.randint(0, 254) for _ in range(length - len(\n        data) - 3)]\n    return [0, 2, *pseudo_random, 0, *data]", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_pkcs1pad(self):\n        data = [1, 2, 3]\n        padded_data = pkcs1pad(data, 32)\n        self.assertEqual(padded_data[:2], [0, 2])\n        self.assertEqual(padded_data[28:], [0, 1, 2, 3])\n        self.assertRaises(ValueError, pkcs1pad, data, 8)\n    \nTestUtil().test_pkcs1pad()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The pkcs1pad function is designed to pad an input data array with a padding scheme conforming to the PKCS#1 standard. This padding is necessary to adjust the input data to a specified length, typically for cryptographic operations. The function ensures that the data is properly padded without altering its original content, following the PKCS#1 padding rules.\n\nInputs: \n- data (int[]): The input data array that needs to be padded. This array consists of integers that represent the original data bytes.\n- length (int): The target length to which the data array should be padded. This is an integer value that specifies the desired length of the padded data.\n\nOutputs: \n- padded_data (int[]): The function returns a new data array that has been padded to the specified length. The padding is done by inserting a series of pseudo-random non-zero bytes between two zero bytes at the beginning of the data array, as required by the PKCS#1 padding scheme. The padded data array is returned as a list of integers, where each integer represents a byte in the array.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef pkcs1pad(data, length): [MASK]\n"}
{"method_name": "encode_base_n", "full_method_name": "encode_base_n", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef _base_n_table(n, table):\n    if not table and not n:\n        raise ValueError('Either table or n must be specified')\n    table = (table or\n        '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')[:n]\n    if n and n != len(table):\n        raise ValueError(f'base {n} exceeds table length {len(table)}')\n    return table\ndef encode_base_n(num, n=None, table=None):\n    \"\"\"Convert given int to a base-n string\"\"\"\n    table = _base_n_table(n, table)\n    if not num:\n        return table[0]\n    result, base = '', len(table)\n    while num:\n        result = table[num % base] + result\n        num = num // base\n    return result", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_encode_base_n(self):\n        self.assertEqual(encode_base_n(0, 30), '0')\n        self.assertEqual(encode_base_n(80, 30), '2k')\n        custom_table = '9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA'\n        self.assertEqual(encode_base_n(0, 30, custom_table), '9')\n        self.assertEqual(encode_base_n(80, 30, custom_table), '7P')\n        self.assertRaises(ValueError, encode_base_n, 0, 70)\n        self.assertRaises(ValueError, encode_base_n, 0, 60, custom_table)\n    \nTestUtil().test_encode_base_n()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The encode_base_n function is designed to convert a given integer number into a string representation using a specified base-n notation. The function supports customizing the numeral system by either specifying the base 'n' or providing a 'table' of characters to use for the conversion.\n\nInputs: \n- num: An integer number to be converted.\n- n (optional): The base of the numeral system for the conversion. If not provided, the table must be specified.\n- table (optional): A string representing the characters to be used for the conversion. If not provided, the function uses a default table containing digits 0-9 and letters a-z and A-Z up to the specified base.\n\nOutputs:\n- A string representing the given integer number in the specified base-n notation.\n  \nNote: At least one of 'n' or 'table' must be specified. If 'n' is provided, the length of 'table' must match 'n'.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef _base_n_table(n, table):\n    if not table and not n:\n        raise ValueError('Either table or n must be specified')\n    table = (table or\n        '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')[:n]\n    if n and n != len(table):\n        raise ValueError(f'base {n} exceeds table length {len(table)}')\n    return table\n\n\ndef encode_base_n(num, n=None, table=None): [MASK]\n"}
{"method_name": "caesar", "full_method_name": "caesar", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_caesar(self):\n        self.assertEqual(caesar('ace', 'abcdef', 2), 'cea')\n        self.assertEqual(caesar('cea', 'abcdef', -2), 'ace')\n        self.assertEqual(caesar('ace', 'abcdef', -2), 'eac')\n        self.assertEqual(caesar('eac', 'abcdef', 2), 'ace')\n        self.assertEqual(caesar('ace', 'abcdef', 0), 'ace')\n        self.assertEqual(caesar('xyz', 'abcdef', 2), 'xyz')\n        self.assertEqual(caesar('abc', 'acegik', 2), 'ebg')\n        self.assertEqual(caesar('ebg', 'acegik', -2), 'abc')\n    \nTestUtil().test_caesar()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The caesar function implements a Caesar cipher, which is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down or up the alphabet. The function takes a string, an alphabet string, and an integer as inputs, and returns the encrypted string based on the Caesar cipher algorithm.\n\nInputs: \n1. s (str): The original string to be encrypted.\n2. alphabet (str): The alphabet string which serves as the base for the encryption. This can be any sequence of characters, not limited to lowercase or uppercase English letters.\n3. shift (int): The number of positions by which letters are shifted. Positive values shift to the right, while negative values shift to the left.\n\nOutputs: \n1. (str): The encrypted string resulting from applying the Caesar cipher using the specified shift on the input string. Characters not found in the alphabet string are left unchanged.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef caesar(s, alphabet, shift): [MASK]\n"}
{"method_name": "rot47", "full_method_name": "rot47", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)\ndef rot47(s):\n    return caesar(s,\n        '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\n        , 47)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_rot47(self):\n        self.assertEqual(rot47('yt-dlp'), 'JE\\\\5=A')\n        self.assertEqual(rot47('YT-DLP'), '*%\\\\s{!')\n    \nTestUtil().test_rot47()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The rot47 function is a simple text encryption method that performs a Caesar cipher shift on a given string. The function shifts each character in the input string 47 positions over a specific alphabet which includes ASCII printable characters. Characters not included in the alphabet are not modified. This function effectively encodes and decodes a string by performing the same operation.\n\nInputs: \n- s (str): A string to be encoded or decoded using the rot47 cipher.\n\nOutputs:\n- str: The encoded or decoded string resulting from applying the rot47 cipher.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)\n\n\ndef rot47(s): [MASK]\n"}
{"method_name": "iri_to_uri", "full_method_name": "iri_to_uri", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef iri_to_uri(iri):\n    \"\"\"\n    Converts an IRI (Internationalized Resource Identifier, allowing Unicode characters) to a URI (Uniform Resource Identifier, ASCII-only).\n\n    The function doesn't add an additional layer of escaping; e.g., it doesn't escape `%3C` as `%253C`. Instead, it percent-escapes characters with an underlying UTF-8 encoding *besides* those already escaped, leaving the URI intact.\n    \"\"\"\n    iri_parts = urllib.parse.urlparse(iri)\n    if '[' in iri_parts.netloc:\n        raise ValueError('IPv6 URIs are not, yet, supported.')\n    net_location = ''\n    if iri_parts.username:\n        net_location += urllib.parse.quote(iri_parts.username, safe=\n            \"!$%&'()*+,~\")\n        if iri_parts.password is not None:\n            net_location += ':' + urllib.parse.quote(iri_parts.password,\n                safe=\"!$%&'()*+,~\")\n        net_location += '@'\n    net_location += iri_parts.hostname.encode('idna').decode()\n    if iri_parts.port is not None and iri_parts.port != 80:\n        net_location += ':' + str(iri_parts.port)\n    return urllib.parse.urlunparse((iri_parts.scheme, net_location, urllib.\n        parse.quote_plus(iri_parts.path, safe=\"!$%&'()*+,/:;=@|~\"), urllib.\n        parse.quote_plus(iri_parts.params, safe=\"!$%&'()*+,/:;=@|~\"),\n        urllib.parse.quote_plus(iri_parts.query, safe=\n        \"!$%&'()*+,/:;=?@{|}~\"), urllib.parse.quote_plus(iri_parts.fragment,\n        safe=\"!#$%&'()*+,/:;=?@{|}~\")))", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_iri_to_uri(self):\n        self.assertEqual(iri_to_uri(\n            'https://www.google.com/search?q=foo&ie=utf-8&oe=utf-8&client=firefox-b'\n            ),\n            'https://www.google.com/search?q=foo&ie=utf-8&oe=utf-8&client=firefox-b'\n            )\n        self.assertEqual(iri_to_uri(\n            'https://www.google.com/search?q=K\u00e4seso\u00dfenr\u00fchrl\u00f6ffel'),\n            'https://www.google.com/search?q=K%C3%A4seso%C3%9Fenr%C3%BChrl%C3%B6ffel'\n            )\n        self.assertEqual(iri_to_uri(\n            'https://www.google.com/search?q=lt<+gt>+eq%3D+amp%26+percent%25+hash%23+colon%3A+tilde~#trash=?&garbage=#'\n            ),\n            'https://www.google.com/search?q=lt%3C+gt%3E+eq%3D+amp%26+percent%25+hash%23+colon%3A+tilde~#trash=?&garbage=#'\n            )\n        self.assertEqual(iri_to_uri('http://\u043f\u0440\u0430\u0432\u043e\u0437\u0430\u0449\u0438\u0442\u043038.\u0440\u0444/category/news/'),\n            'http://xn--38-6kcaak9aj5chl4a3g.xn--p1ai/category/news/')\n        self.assertEqual(iri_to_uri(\n            'http://www.\u043f\u0440\u0430\u0432\u043e\u0437\u0430\u0449\u0438\u0442\u043038.\u0440\u0444/category/news/'),\n            'http://www.xn--38-6kcaak9aj5chl4a3g.xn--p1ai/category/news/')\n        self.assertEqual(iri_to_uri('https://i\u2764.ws/emojidomain/\ud83d\udc4d\ud83d\udc4f\ud83e\udd1d\ud83d\udcaa'),\n            'https://xn--i-7iq.ws/emojidomain/%F0%9F%91%8D%F0%9F%91%8F%F0%9F%A4%9D%F0%9F%92%AA'\n            )\n        self.assertEqual(iri_to_uri('http://\u65e5\u672c\u8a9e.jp/'), 'http://xn--wgv71a119e.jp/')\n        self.assertEqual(iri_to_uri('http://\u5bfc\u822a.\u4e2d\u56fd/'),\n            'http://xn--fet810g.xn--fiqs8s/')\n    \nTestUtil().test_iri_to_uri()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Converts an IRI (Internationalized Resource Identifier, allowing Unicode characters) to a URI (Uniform Resource Identifier, ASCII-only). The conversion includes percent-escaping characters with an underlying UTF-8 encoding, except for those already escaped, and encoding the hostname in IDNA (Internationalized Domain Name in Applications) format.\n\nInputs: \n- iri (str): The IRI to be converted. It can contain Unicode characters and should be a valid IRI string.\n\nOutputs: \n- uri (str): The converted ASCII-only URI string. The returned URI will have all non-ASCII characters and special characters properly percent-encoded.\n\nRaises:\n- ValueError: If the IRI contains an IPv6 address, since IPv6 URIs are not supported by this function.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef iri_to_uri(iri): [MASK]\n"}
{"method_name": "clean_podcast_url", "full_method_name": "clean_podcast_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef clean_podcast_url(url):\n    url = re.sub(\n        \"\"\"(?x)\n        (?:\n            (?:\n                chtbl\\\\.com/track|\n                media\\\\.blubrry\\\\.com| # https://create.blubrry.com/resources/podcast-media-download-statistics/getting-started/\n                play\\\\.podtrac\\\\.com|\n                chrt\\\\.fm/track|\n                mgln\\\\.ai/e\n            )(?:/[^/.]+)?|\n            (?:dts|www)\\\\.podtrac\\\\.com/(?:pts/)?redirect\\\\.[0-9a-z]{3,4}| # http://analytics.podtrac.com/how-to-measure\n            flex\\\\.acast\\\\.com|\n            pd(?:\n                cn\\\\.co| # https://podcorn.com/analytics-prefix/\n                st\\\\.fm # https://podsights.com/docs/\n            )/e|\n            [0-9]\\\\.gum\\\\.fm|\n            pscrb\\\\.fm/rss/p\n        )/\"\"\"\n        , '', url)\n    return re.sub('^\\\\w+://(\\\\w+://)', '\\\\1', url)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_clean_podcast_url(self):\n        self.assertEqual(clean_podcast_url(\n            'https://www.podtrac.com/pts/redirect.mp3/chtbl.com/track/5899E/traffic.megaphone.fm/HSW7835899191.mp3'\n            ), 'https://traffic.megaphone.fm/HSW7835899191.mp3')\n        self.assertEqual(clean_podcast_url(\n            'https://play.podtrac.com/npr-344098539/edge1.pod.npr.org/anon.npr-podcasts/podcast/npr/waitwait/2020/10/20201003_waitwait_wwdtmpodcast201003-015621a5-f035-4eca-a9a1-7c118d90bc3c.mp3'\n            ),\n            'https://edge1.pod.npr.org/anon.npr-podcasts/podcast/npr/waitwait/2020/10/20201003_waitwait_wwdtmpodcast201003-015621a5-f035-4eca-a9a1-7c118d90bc3c.mp3'\n            )\n        self.assertEqual(clean_podcast_url(\n            'https://pdst.fm/e/2.gum.fm/chtbl.com/track/chrt.fm/track/34D33/pscrb.fm/rss/p/traffic.megaphone.fm/ITLLC7765286967.mp3?updated=1687282661'\n            ),\n            'https://traffic.megaphone.fm/ITLLC7765286967.mp3?updated=1687282661')\n        self.assertEqual(clean_podcast_url(\n            'https://pdst.fm/e/https://mgln.ai/e/441/www.buzzsprout.com/1121972/13019085-ep-252-the-deep-life-stack.mp3'\n            ),\n            'https://www.buzzsprout.com/1121972/13019085-ep-252-the-deep-life-stack.mp3'\n            )\n    \nTestUtil().test_clean_podcast_url()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The clean_podcast_url function takes a podcast URL as input and cleans it by removing specific tracking prefixes and redundant protocol parts. This is done to ensure that the URL is in a standardized format, making it easier to handle and process for further operations.\n\nInputs: \n- url: A string representing the podcast URL that might contain various tracking prefixes and redundant protocol parts.\n\nOutputs:\n- A string representing the cleaned podcast URL, with tracking prefixes removed and redundant protocol parts standardized.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef clean_podcast_url(url): [MASK]\n"}
{"method_name": "hide_login_info", "full_method_name": "Config.hide_login_info", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass Config:\n    own_args = None\n    parsed_args = None\n    filename = None\n    __initialized = False\n\n    def __init__(self, parser, label=None):\n        self.parser, self.label = parser, label\n        self._loaded_paths, self.configs = set(), []\n\n    def init(self, args=None, filename=None):\n        assert not self.__initialized\n        self.own_args, self.filename = args, filename\n        return self.load_configs()\n\n    def load_configs(self):\n        directory = ''\n        if self.filename:\n            location = os.path.realpath(self.filename)\n            directory = os.path.dirname(location)\n            if location in self._loaded_paths:\n                return False\n            self._loaded_paths.add(location)\n        self.__initialized = True\n        opts, _ = self.parser.parse_known_args(self.own_args)\n        self.parsed_args = self.own_args\n        for location in (opts.config_locations or []):\n            if location == '-':\n                if location in self._loaded_paths:\n                    continue\n                self._loaded_paths.add(location)\n                self.append_config(shlex.split(read_stdin('options'),\n                    comments=True), label='stdin')\n                continue\n            location = os.path.join(directory, expand_path(location))\n            if os.path.isdir(location):\n                location = os.path.join(location, 'yt-dlp.conf')\n            if not os.path.exists(location):\n                self.parser.error(f'config location {location} does not exist')\n            self.append_config(self.read_file(location), location)\n        return True\n\n    def __str__(self):\n        label = join_nonempty(self.label, 'config', f'\"{self.filename}\"' if\n            self.filename else '', delim=' ')\n        return join_nonempty(self.own_args is not None and\n            f'{label[0].upper()}{label[1:]}: {self.hide_login_info(self.own_args)}'\n            , *(f'\\n{c}'.replace('\\n', '\\n| ')[1:] for c in self.configs),\n            delim='\\n')\n\n    @staticmethod\n    def read_file(filename, default=[]):\n        try:\n            optionf = open(filename, 'rb')\n        except OSError:\n            return default\n        try:\n            enc, skip = determine_file_encoding(optionf.read(512))\n            optionf.seek(skip, io.SEEK_SET)\n        except OSError:\n            enc = None\n        try:\n            contents = optionf.read().decode(enc or preferredencoding())\n            res = shlex.split(contents, comments=True)\n        except Exception as err:\n            raise ValueError(f'Unable to parse \"{filename}\": {err}')\n        finally:\n            optionf.close()\n        return res\n\n    @staticmethod\n    def hide_login_info(opts):\n        PRIVATE_OPTS = {'-p', '--password', '-u', '--username',\n            '--video-password', '--ap-password', '--ap-username'}\n        eqre = re.compile('^(?P<key>' + '|'.join(re.escape(po) for po in\n            PRIVATE_OPTS) + ')=.+$')\n\n        def _scrub_eq(o):\n            m = eqre.match(o)\n            if m:\n                return m.group('key') + '=PRIVATE'\n            else:\n                return o\n        opts = list(map(_scrub_eq, opts))\n        for idx, opt in enumerate(opts):\n            if opt in PRIVATE_OPTS and idx + 1 < len(opts):\n                opts[idx + 1] = 'PRIVATE'\n        return opts\n\n    def append_config(self, *args, label=None):\n        config = type(self)(self.parser, label)\n        config._loaded_paths = self._loaded_paths\n        if config.init(*args):\n            self.configs.append(config)\n\n    @property\n    def all_args(self):\n        for config in reversed(self.configs):\n            yield from config.all_args\n        yield from (self.parsed_args or [])\n\n    def parse_known_args(self, **kwargs):\n        return self.parser.parse_known_args(self.all_args, **kwargs)\n\n    def parse_args(self):\n        return self.parser.parse_args(self.all_args)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_hide_login_info(self):\n        self.assertEqual(Config.hide_login_info(['-u', 'foo', '-p', 'bar']), [\n            '-u', 'PRIVATE', '-p', 'PRIVATE'])\n        self.assertEqual(Config.hide_login_info(['-u']), ['-u'])\n        self.assertEqual(Config.hide_login_info(['-u', 'foo', '-u', 'bar']), [\n            '-u', 'PRIVATE', '-u', 'PRIVATE'])\n        self.assertEqual(Config.hide_login_info(['--username=foo']), [\n            '--username=PRIVATE'])\n    \nTestUtil().test_hide_login_info()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The Config.hide_login_info function is designed to mask sensitive login information present in the command-line options provided to the application. It targets options related to usernames and passwords, replacing any detected values with the string 'PRIVATE' to ensure privacy and security.\n\nInputs: \n- opts: A list of strings representing command-line options and their arguments. This list could include sensitive information such as usernames and passwords.\n\nOutputs:\n- A modified list of strings where any values that correspond to private login information options ('-p', '--password', '-u', '--username', '--video-password', '--ap-password', '--ap-username') have been replaced with the string 'PRIVATE'. This sanitized list maintains the structure and order of the original list but protects any sensitive data that might have been included.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass Config:\n    own_args = None\n    parsed_args = None\n    filename = None\n    __initialized = False\n\n    def __init__(self, parser, label=None):\n        self.parser, self.label = parser, label\n        self._loaded_paths, self.configs = set(), []\n\n    def init(self, args=None, filename=None):\n        assert not self.__initialized\n        self.own_args, self.filename = args, filename\n        return self.load_configs()\n\n    def load_configs(self):\n        directory = ''\n        if self.filename:\n            location = os.path.realpath(self.filename)\n            directory = os.path.dirname(location)\n            if location in self._loaded_paths:\n                return False\n            self._loaded_paths.add(location)\n        self.__initialized = True\n        opts, _ = self.parser.parse_known_args(self.own_args)\n        self.parsed_args = self.own_args\n        for location in (opts.config_locations or []):\n            if location == '-':\n                if location in self._loaded_paths:\n                    continue\n                self._loaded_paths.add(location)\n                self.append_config(shlex.split(read_stdin('options'),\n                    comments=True), label='stdin')\n                continue\n            location = os.path.join(directory, expand_path(location))\n            if os.path.isdir(location):\n                location = os.path.join(location, 'yt-dlp.conf')\n            if not os.path.exists(location):\n                self.parser.error(f'config location {location} does not exist')\n            self.append_config(self.read_file(location), location)\n        return True\n\n    def __str__(self):\n        label = join_nonempty(self.label, 'config', f'\"{self.filename}\"' if\n            self.filename else '', delim=' ')\n        return join_nonempty(self.own_args is not None and\n            f'{label[0].upper()}{label[1:]}: {self.hide_login_info(self.own_args)}'\n            , *(f'\\n{c}'.replace('\\n', '\\n| ')[1:] for c in self.configs),\n            delim='\\n')\n\n    @staticmethod\n    def read_file(filename, default=[]):\n        try:\n            optionf = open(filename, 'rb')\n        except OSError:\n            return default\n        try:\n            enc, skip = determine_file_encoding(optionf.read(512))\n            optionf.seek(skip, io.SEEK_SET)\n        except OSError:\n            enc = None\n        try:\n            contents = optionf.read().decode(enc or preferredencoding())\n            res = shlex.split(contents, comments=True)\n        except Exception as err:\n            raise ValueError(f'Unable to parse \"{filename}\": {err}')\n        finally:\n            optionf.close()\n        return res\n\n    @staticmethod\n    def hide_login_info(opts): [MASK]\n\n    def append_config(self, *args, label=None):\n        config = type(self)(self.parser, label)\n        config._loaded_paths = self._loaded_paths\n        if config.init(*args):\n            self.configs.append(config)\n\n    @property\n    def all_args(self):\n        for config in reversed(self.configs):\n            yield from config.all_args\n        yield from (self.parsed_args or [])\n\n    def parse_known_args(self, **kwargs):\n        return self.parser.parse_known_args(self.all_args, **kwargs)\n\n    def parse_args(self):\n        return self.parser.parse_args(self.all_args)\n"}
{"method_name": "determine_file_encoding", "full_method_name": "determine_file_encoding", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\ndef determine_file_encoding(data):\n    \"\"\"\n    Detect the text encoding used\n    @returns (encoding, bytes to skip)\n    \"\"\"\n    for bom, enc in BOMS:\n        if data.startswith(bom):\n            return enc, len(bom)\n    data = data.replace(b'\\x00', b'')\n    mobj = re.match(b'(?m)^#\\\\s*coding\\\\s*:\\\\s*(\\\\S+)\\\\s*$', data)\n    return mobj.group(1).decode() if mobj else None, 0", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_determine_file_encoding(self):\n        self.assertEqual(determine_file_encoding(b''), (None, 0))\n        self.assertEqual(determine_file_encoding(\n            b'--verbose -x --audio-format mkv\\n'), (None, 0))\n        self.assertEqual(determine_file_encoding(b'\\xef\\xbb\\xbf'), ('utf-8', 3))\n        self.assertEqual(determine_file_encoding(b'\\x00\\x00\\xfe\\xff'), (\n            'utf-32-be', 4))\n        self.assertEqual(determine_file_encoding(b'\\xff\\xfe'), ('utf-16-le', 2))\n        self.assertEqual(determine_file_encoding(\n            b'\\xff\\xfe# coding: utf-8\\n--verbose'), ('utf-16-le', 2))\n        self.assertEqual(determine_file_encoding(b'# coding: utf-8\\n--verbose'),\n            ('utf-8', 0))\n        self.assertEqual(determine_file_encoding(\n            b'# coding: someencodinghere-12345\\n--verbose'), (\n            'someencodinghere-12345', 0))\n        self.assertEqual(determine_file_encoding(b'#coding:utf-8\\n--verbose'),\n            ('utf-8', 0))\n        self.assertEqual(determine_file_encoding(\n            b'#  coding:   utf-8   \\r\\n--verbose'), ('utf-8', 0))\n        self.assertEqual(determine_file_encoding('# coding: utf-32-be'.encode(\n            'utf-32-be')), ('utf-32-be', 0))\n        self.assertEqual(determine_file_encoding('# coding: utf-16-le'.encode(\n            'utf-16-le')), ('utf-16-le', 0))\n    \nTestUtil().test_determine_file_encoding()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The determine_file_encoding function is designed to detect the text encoding of a file based on the byte order mark (BOM) and the presence of a coding declaration within the file's data. It supports various encodings, including UTF-8, UTF-16, and UTF-32 in both big-endian and little-endian formats.\n\nInputs: The function accepts a single argument:\n- data: A byte string representing the content of a file. This data is analyzed to determine the file's encoding.\n\nOutputs: The function returns a tuple containing two elements:\n- encoding: A string representing the detected text encoding of the file. If the encoding cannot be determined, None is returned.\n- bytes_to_skip: An integer representing the number of bytes that should be skipped at the beginning of the file if a byte order mark (BOM) is present. This value is 0 if no BOM is found.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\n\n\ndef determine_file_encoding(data): [MASK]\n"}
{"method_name": "try_call", "full_method_name": "try_call", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef try_call(*funcs, expected_type=None, args=[], kwargs={}):\n    for f in funcs:\n        try:\n            val = f(*args, **kwargs)\n        except (AttributeError, KeyError, TypeError, IndexError, ValueError,\n            ZeroDivisionError):\n            pass\n        else:\n            if expected_type is None or isinstance(val, expected_type):\n                return val", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_try_call(self):\n    \n        def total(*x, **kwargs):\n            return sum(x) + sum(kwargs.values())\n        self.assertEqual(try_call(None), None, msg='not a fn should give None')\n        self.assertEqual(try_call(lambda : 1), 1, msg=\n            'int fn with no expected_type should give int')\n        self.assertEqual(try_call(lambda : 1, expected_type=int), 1, msg=\n            'int fn with expected_type int should give int')\n        self.assertEqual(try_call(lambda : 1, expected_type=dict), None, msg=\n            'int fn with wrong expected_type should give None')\n        self.assertEqual(try_call(total, args=(0, 1, 0), expected_type=int), 1,\n            msg='fn should accept arglist')\n        self.assertEqual(try_call(total, kwargs={'a': 0, 'b': 1, 'c': 0},\n            expected_type=int), 1, msg='fn should accept kwargs')\n        self.assertEqual(try_call(lambda : 1, expected_type=dict), None, msg=\n            'int fn with no expected_type should give None')\n        self.assertEqual(try_call(lambda x: {}, total, args=(42,),\n            expected_type=int), 42, msg=\n            'expect first int result with expected_type int')\n    \nTestUtil().test_try_call()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: The try_call function aims to execute multiple functions one by one with provided arguments and keyword arguments. It is designed to handle common exceptions that may occur during function execution. If a function executes successfully and returns a value that matches the expected type (if provided), the function will return this value. If no function execution is successful or if the return type does not match the expected type, the function will return None.\n\nInputs: \n- *funcs: This is a variable number of function objects to be called in sequence.\n- expected_type: This is an optional parameter. It is the type of the value that the function expects to return. If None, any type is accepted.\n- args: This is a list of positional arguments to be passed to each function.\n- kwargs: This is a dictionary of keyword arguments to be passed to each function.\n\nOutputs: \n- The function returns the value returned by the first function that executes successfully and matches the expected type (if provided). If no function execution is successful or if the return type does not match the expected type, the function will return None.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef try_call(*funcs, expected_type=None, args=[], kwargs={}): [MASK]\n"}
{"method_name": "extract_basic_auth", "full_method_name": "extract_basic_auth", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef extract_basic_auth(url):\n    parts = urllib.parse.urlsplit(url)\n    if parts.username is None:\n        return url, None\n    url = urllib.parse.urlunsplit(parts._replace(netloc=parts.hostname if \n        parts.port is None else f'{parts.hostname}:{parts.port}'))\n    auth_payload = base64.b64encode('{}:{}'.format(parts.username, parts.\n        password or '').encode())\n    return url, f'Basic {auth_payload.decode()}'", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport warnings\nimport datetime as dt\nimport contextlib\nimport io\nimport itertools\nimport json\nimport subprocess\nimport xml.etree.ElementTree\n\nclass TestUtil(unittest.TestCase):\n    def test_extract_basic_auth(self):\n        assert extract_basic_auth('http://:foo.bar') == ('http://:foo.bar', None)\n        assert extract_basic_auth('http://foo.bar') == ('http://foo.bar', None)\n        assert extract_basic_auth('http://@foo.bar') == ('http://foo.bar',\n            'Basic Og==')\n        assert extract_basic_auth('http://:pass@foo.bar') == ('http://foo.bar',\n            'Basic OnBhc3M=')\n        assert extract_basic_auth('http://user:@foo.bar') == ('http://foo.bar',\n            'Basic dXNlcjo=')\n        assert extract_basic_auth('http://user:pass@foo.bar') == ('http://foo.bar',\n            'Basic dXNlcjpwYXNz')\n    \nTestUtil().test_extract_basic_auth()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_utils.py"}], "instruction": "Functionality: Extracts basic authentication information from a given URL and encodes it into a Base64 string. The function first parses the URL to extract the username and password, if present. It then reconstructs the URL without the authentication information and encodes the username and password into a Base64 string, prefixed with 'Basic ', which can be used for HTTP Basic Authentication.\n\nInputs: \n    url (str): A string representing the URL which may contain basic authentication information in the format 'http://username:password@hostname:port/path'.\n\nOutputs:\n    A tuple containing:\n        url (str): The URL with the basic authentication information removed.\n        auth_header (str or None): A string representing the HTTP Basic Authentication header value, in the format 'Basic base64_encoded_string', or None if no authentication information was present in the URL.", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef extract_basic_auth(url): [MASK]\n"}
{"method_name": "_get_linux_desktop_environment", "full_method_name": "_get_linux_desktop_environment", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/cookies.py", "method_code": "import base64\nimport collections\nimport contextlib\nimport datetime as dt\nimport functools\nimport glob\nimport hashlib\nimport http.cookiejar\nimport http.cookies\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport urllib.request\nfrom enum import Enum\nfrom enum import auto\nimport ctypes\nimport ctypes.wintypes\nclass _LinuxDesktopEnvironment(Enum):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.h\n    DesktopEnvironment\n    \"\"\"\n    OTHER = auto()\n    CINNAMON = auto()\n    DEEPIN = auto()\n    GNOME = auto()\n    KDE3 = auto()\n    KDE4 = auto()\n    KDE5 = auto()\n    KDE6 = auto()\n    PANTHEON = auto()\n    UKUI = auto()\n    UNITY = auto()\n    XFCE = auto()\n    LXQT = auto()\ndef _get_linux_desktop_environment(env, logger):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.cc\n    GetDesktopEnvironment\n    \"\"\"\n    xdg_current_desktop = env.get('XDG_CURRENT_DESKTOP', None)\n    desktop_session = env.get('DESKTOP_SESSION', None)\n    if xdg_current_desktop is not None:\n        for part in map(str.strip, xdg_current_desktop.split(':')):\n            if part == 'Unity':\n                if (desktop_session is not None and 'gnome-fallback' in\n                    desktop_session):\n                    return _LinuxDesktopEnvironment.GNOME\n                else:\n                    return _LinuxDesktopEnvironment.UNITY\n            elif part == 'Deepin':\n                return _LinuxDesktopEnvironment.DEEPIN\n            elif part == 'GNOME':\n                return _LinuxDesktopEnvironment.GNOME\n            elif part == 'X-Cinnamon':\n                return _LinuxDesktopEnvironment.CINNAMON\n            elif part == 'KDE':\n                kde_version = env.get('KDE_SESSION_VERSION', None)\n                if kde_version == '5':\n                    return _LinuxDesktopEnvironment.KDE5\n                elif kde_version == '6':\n                    return _LinuxDesktopEnvironment.KDE6\n                elif kde_version == '4':\n                    return _LinuxDesktopEnvironment.KDE4\n                else:\n                    logger.info(\n                        f'unknown KDE version: \"{kde_version}\". Assuming KDE4')\n                    return _LinuxDesktopEnvironment.KDE4\n            elif part == 'Pantheon':\n                return _LinuxDesktopEnvironment.PANTHEON\n            elif part == 'XFCE':\n                return _LinuxDesktopEnvironment.XFCE\n            elif part == 'UKUI':\n                return _LinuxDesktopEnvironment.UKUI\n            elif part == 'LXQt':\n                return _LinuxDesktopEnvironment.LXQT\n        logger.info(\n            f'XDG_CURRENT_DESKTOP is set to an unknown value: \"{xdg_current_desktop}\"'\n            )\n    elif desktop_session is not None:\n        if desktop_session == 'deepin':\n            return _LinuxDesktopEnvironment.DEEPIN\n        elif desktop_session in ('mate', 'gnome'):\n            return _LinuxDesktopEnvironment.GNOME\n        elif desktop_session in ('kde4', 'kde-plasma'):\n            return _LinuxDesktopEnvironment.KDE4\n        elif desktop_session == 'kde':\n            if 'KDE_SESSION_VERSION' in env:\n                return _LinuxDesktopEnvironment.KDE4\n            else:\n                return _LinuxDesktopEnvironment.KDE3\n        elif 'xfce' in desktop_session or desktop_session == 'xubuntu':\n            return _LinuxDesktopEnvironment.XFCE\n        elif desktop_session == 'ukui':\n            return _LinuxDesktopEnvironment.UKUI\n        else:\n            logger.info(\n                f'DESKTOP_SESSION is set to an unknown value: \"{desktop_session}\"'\n                )\n    elif 'GNOME_DESKTOP_SESSION_ID' in env:\n        return _LinuxDesktopEnvironment.GNOME\n    elif 'KDE_FULL_SESSION' in env:\n        if 'KDE_SESSION_VERSION' in env:\n            return _LinuxDesktopEnvironment.KDE4\n        else:\n            return _LinuxDesktopEnvironment.KDE3\n    return _LinuxDesktopEnvironment.OTHER", "test_code_list": [{"test_code": "import datetime as dt\nimport unittest\nclass Logger:\n\n    def debug(self, message, *args, **kwargs):\n        print(f'[verbose] {message}')\n\n    def info(self, message, *args, **kwargs):\n        print(message)\n\n    def warning(self, message, *args, **kwargs):\n        self.error(message)\n\n    def error(self, message, *args, **kwargs):\n        raise Exception(message)\nclass TestCookies(unittest.TestCase):\n    def test_get_desktop_environment(self):\n        \"\"\" based on https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util_unittest.cc \"\"\"\n        test_cases = [({}, _LinuxDesktopEnvironment.OTHER), ({'DESKTOP_SESSION':\n            'my_custom_de'}, _LinuxDesktopEnvironment.OTHER), ({\n            'XDG_CURRENT_DESKTOP': 'my_custom_de'}, _LinuxDesktopEnvironment.\n            OTHER), ({'DESKTOP_SESSION': 'gnome'}, _LinuxDesktopEnvironment.\n            GNOME), ({'DESKTOP_SESSION': 'mate'}, _LinuxDesktopEnvironment.\n            GNOME), ({'DESKTOP_SESSION': 'kde4'}, _LinuxDesktopEnvironment.KDE4\n            ), ({'DESKTOP_SESSION': 'kde'}, _LinuxDesktopEnvironment.KDE3), ({\n            'DESKTOP_SESSION': 'xfce'}, _LinuxDesktopEnvironment.XFCE), ({\n            'GNOME_DESKTOP_SESSION_ID': 1}, _LinuxDesktopEnvironment.GNOME), ({\n            'KDE_FULL_SESSION': 1}, _LinuxDesktopEnvironment.KDE3), ({\n            'KDE_FULL_SESSION': 1, 'DESKTOP_SESSION': 'kde4'},\n            _LinuxDesktopEnvironment.KDE4), ({'XDG_CURRENT_DESKTOP':\n            'X-Cinnamon'}, _LinuxDesktopEnvironment.CINNAMON), ({\n            'XDG_CURRENT_DESKTOP': 'Deepin'}, _LinuxDesktopEnvironment.DEEPIN),\n            ({'XDG_CURRENT_DESKTOP': 'GNOME'}, _LinuxDesktopEnvironment.GNOME),\n            ({'XDG_CURRENT_DESKTOP': 'GNOME:GNOME-Classic'},\n            _LinuxDesktopEnvironment.GNOME), ({'XDG_CURRENT_DESKTOP':\n            'GNOME : GNOME-Classic'}, _LinuxDesktopEnvironment.GNOME), ({\n            'XDG_CURRENT_DESKTOP': 'ubuntu:GNOME'}, _LinuxDesktopEnvironment.\n            GNOME), ({'XDG_CURRENT_DESKTOP': 'Unity', 'DESKTOP_SESSION':\n            'gnome-fallback'}, _LinuxDesktopEnvironment.GNOME), ({\n            'XDG_CURRENT_DESKTOP': 'KDE', 'KDE_SESSION_VERSION': '5'},\n            _LinuxDesktopEnvironment.KDE5), ({'XDG_CURRENT_DESKTOP': 'KDE',\n            'KDE_SESSION_VERSION': '6'}, _LinuxDesktopEnvironment.KDE6), ({\n            'XDG_CURRENT_DESKTOP': 'KDE'}, _LinuxDesktopEnvironment.KDE4), ({\n            'XDG_CURRENT_DESKTOP': 'Pantheon'}, _LinuxDesktopEnvironment.\n            PANTHEON), ({'XDG_CURRENT_DESKTOP': 'UKUI'},\n            _LinuxDesktopEnvironment.UKUI), ({'XDG_CURRENT_DESKTOP': 'Unity'},\n            _LinuxDesktopEnvironment.UNITY), ({'XDG_CURRENT_DESKTOP':\n            'Unity:Unity7'}, _LinuxDesktopEnvironment.UNITY), ({\n            'XDG_CURRENT_DESKTOP': 'Unity:Unity8'}, _LinuxDesktopEnvironment.UNITY)\n            ]\n        for env, expected_desktop_environment in test_cases:\n            self.assertEqual(_get_linux_desktop_environment(env, Logger()),\n                expected_desktop_environment)\nTestCookies().test_get_desktop_environment()", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_cookies.py"}], "instruction": "Functionality: The function _get_linux_desktop_environment is designed to determine the current Linux desktop environment based on the environment variables of the system. It checks for specific patterns in the environment variables to identify the desktop environment such as GNOME, KDE, Unity, and others.\n\nInputs: \n1. env: A dictionary representing the environment variables of the system.\n2. logger: An object used for logging messages when an unknown value is encountered in the environment variables.\n\nOutputs:\nThe function returns an enumeration value from the _LinuxDesktopEnvironment class, representing the detected desktop environment. If the environment cannot be determined, it returns _LinuxDesktopEnvironment.OTHER.", "method_code_mask": "import base64\nimport collections\nimport contextlib\nimport datetime as dt\nimport functools\nimport glob\nimport hashlib\nimport http.cookiejar\nimport http.cookies\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport urllib.request\nfrom enum import Enum\nfrom enum import auto\nimport ctypes\nimport ctypes.wintypes\n\n\nclass _LinuxDesktopEnvironment(Enum):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.h\n    DesktopEnvironment\n    \"\"\"\n    OTHER = auto()\n    CINNAMON = auto()\n    DEEPIN = auto()\n    GNOME = auto()\n    KDE3 = auto()\n    KDE4 = auto()\n    KDE5 = auto()\n    KDE6 = auto()\n    PANTHEON = auto()\n    UKUI = auto()\n    UNITY = auto()\n    XFCE = auto()\n    LXQT = auto()\n\n\ndef _get_linux_desktop_environment(env, logger): [MASK]\n"}
{"method_name": "_make_result", "full_method_name": "_make_result", "method_path": "../srcdata/Network/yt-dlp/test/test_YoutubeDL.py", "method_code": "import os\nimport sys\nimport unittest\nfrom unittest.mock import patch\nimport contextlib\nimport copy\nimport json\nfrom http.cookiejar import Cookie\ndef _make_result(formats, **kwargs):\n    res = {'formats': formats, 'id': 'testid', 'title': 'testttitle',\n        'extractor': 'testex', 'extractor_key': 'TestEx', 'webpage_url':\n        'http://example.com/watch?v=shenanigans'}\n    res.update(**kwargs)\n    return res", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nfrom unittest.mock import patch\nimport contextlib\nimport copy\nimport json\nfrom http.cookiejar import Cookie\n\nclass TestFormatSelection(unittest.TestCase):\n    def test_youtube_format_selection(self):\n        return\n        order = ['38', '37', '46', '22', '45', '35', '44', '18', '34', '43',\n            '6', '5', '17', '36', '13', '96', '95', '94', '93', '92', '132',\n            '151', '85', '84', '102', '83', '101', '82', '100', '137', '248',\n            '136', '247', '135', '246', '245', '244', '134', '243', '133',\n            '242', '160', '141', '172', '140', '171', '139']\n    \n        def format_info(f_id):\n            info = YoutubeIE._formats[f_id].copy()\n            if 'acodec' in info and 'vcodec' not in info:\n                info['vcodec'] = 'none'\n            elif 'vcodec' in info and 'acodec' not in info:\n                info['acodec'] = 'none'\n            info['format_id'] = f_id\n            info['url'] = 'url:' + f_id\n            return info\n        formats_order = [format_info(f_id) for f_id in order]\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo+bestaudio'})\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '248+172')\n        self.assertEqual(downloaded['ext'], 'mp4')\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo[height>=999999]+bestaudio/best'})\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], '38')\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': 'bestvideo/best,bestaudio'})\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137', '141'])\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=mp4],bestvideo[ext=webm])+bestaudio'})\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['137+141', '248+141'])\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format':\n            '(bestvideo[ext=mp4],bestvideo[ext=webm])[height<=720]+bestaudio'})\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['136+141', '247+141'])\n        info_dict = _make_result(list(formats_order), extractor='youtube')\n        ydl = YDL({'format': '(bestvideo[ext=none]/bestvideo[ext=webm])+bestaudio'}\n            )\n        ydl.sort_formats(info_dict)\n        ydl.process_ie_result(info_dict)\n        downloaded_ids = [info['format_id'] for info in ydl.downloaded_info_dicts]\n        self.assertEqual(downloaded_ids, ['248+141'])\n        for f1, f2 in zip(formats_order, formats_order[1:]):\n            info_dict = _make_result([f1, f2], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            ydl.sort_formats(info_dict)\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])\n            info_dict = _make_result([f2, f1], extractor='youtube')\n            ydl = YDL({'format': 'best/bestvideo'})\n            ydl.sort_formats(info_dict)\n            ydl.process_ie_result(info_dict)\n            downloaded = ydl.downloaded_info_dicts[0]\n            self.assertEqual(downloaded['format_id'], f1['format_id'])\n    \nTestFormatSelection().test_youtube_format_selection()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_YoutubeDL.py"}], "instruction": "Functionality: The _make_result function is designed to create a standardized result dictionary used for testing and data handling in a software testing environment. This function generates a dictionary that contains predefined keys and values, with the flexibility to add or override values using keyword arguments.\n\nInputs: \n- formats: A list of dictionaries, each representing a specific format for the content. These dictionaries should contain information such as the format's ID, URL, or any other relevant data points.\n- **kwargs: This represents additional keyword arguments that can be passed to the function to add new key-value pairs to the dictionary or to override the default values of keys such as 'id', 'title', 'extractor', 'extractor_key', and 'webpage_url'.\n\nOutputs:\n- The function returns a dictionary that includes the 'formats' list and the key-value pairs defined by the default settings or overridden/added by the **kwargs parameter. The dictionary will have keys such as 'formats', 'id', 'title', 'extractor', 'extractor_key', and 'webpage_url', with their respective values.", "method_code_mask": "import os\nimport sys\nimport unittest\nfrom unittest.mock import patch\nimport contextlib\nimport copy\nimport json\nfrom http.cookiejar import Cookie\n\n\ndef _make_result(formats, **kwargs): [MASK]\n"}
{"method_name": "pad_block", "full_method_name": "pad_block", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/aes.py", "method_code": "import base64\nfrom math import ceil\nBLOCK_SIZE_BYTES = 16\ndef pad_block(block, padding_mode):\n    \"\"\"\n    Pad a block with the given padding mode\n    @param {int[]} block        block to pad\n    @param padding_mode         padding mode\n    \"\"\"\n    padding_size = BLOCK_SIZE_BYTES - len(block)\n    PADDING_BYTE = {'pkcs7': padding_size, 'iso7816': 0, 'whitespace': 32,\n        'zero': 0}\n    if padding_size < 0:\n        raise ValueError('Block size exceeded')\n    elif padding_mode not in PADDING_BYTE:\n        raise NotImplementedError(\n            f'Padding mode {padding_mode} is not implemented')\n    if padding_mode == 'iso7816' and padding_size:\n        block = [*block, 128]\n        padding_size -= 1\n    return block + [PADDING_BYTE[padding_mode]] * padding_size", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport base64\n\nclass TestAES(unittest.TestCase):\n    def test_pad_block(self):\n        block = [33, 160, 67, 255]\n        self.assertEqual(pad_block(block, 'pkcs7'), [*block, 12, 12, 12, 12, 12,\n            12, 12, 12, 12, 12, 12, 12])\n        self.assertEqual(pad_block(block, 'iso7816'), [*block, 128, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0])\n        self.assertEqual(pad_block(block, 'whitespace'), [*block, 32, 32, 32, \n            32, 32, 32, 32, 32, 32, 32, 32, 32])\n        self.assertEqual(pad_block(block, 'zero'), [*block, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0])\n        block = list(range(16))\n        for mode in ('pkcs7', 'iso7816', 'whitespace', 'zero'):\n            self.assertEqual(pad_block(block, mode), block, mode)\n    \nTestAES().test_pad_block()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_aes.py"}], "instruction": "Functionality: Pads a block of data to a specific block size using different padding modes.\nInputs: \n- block: A list of integers representing the block to be padded. The length of the block should not exceed the block size defined by BLOCK_SIZE_BYTES.\n- padding_mode: A string specifying the padding mode to be used. The padding modes available are 'pkcs7', 'iso7816', 'whitespace', and 'zero'.\nOutputs: \n- A list of integers representing the padded block. The length of the output block will be equal to BLOCK_SIZE_BYTES.\n- If the block size is exceeded or an unsupported padding mode is provided, the function will raise an exception.", "method_code_mask": "import base64\nfrom math import ceil\nBLOCK_SIZE_BYTES = 16\n\n\ndef pad_block(block, padding_mode): [MASK]\n"}
{"method_name": "expect_warnings", "full_method_name": "expect_warnings", "method_path": "../srcdata/Network/yt-dlp/test/helper.py", "method_code": "import errno\nimport hashlib\nimport json\nimport os.path\nimport re\nimport ssl\nimport sys\nimport types\nimport pytest\ndef expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w, *args, **kwargs):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w, *args, **kwargs)\n    ydl.report_warning = _report_warning", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport collections\nimport hashlib\nimport json\ndef generator():\n\n    def test_template(self):\n        if self.COMPLETED_TESTS.get(tname):\n            return\n        self.COMPLETED_TESTS[tname] = True\n        ie = yt_dlp.extractor.get_info_extractor(test_case['name'])()\n        other_ies = [get_info_extractor(ie_key)() for ie_key in test_case.\n            get('add_ie', [])]\n        is_playlist = any(k.startswith('playlist') for k in test_case)\n        test_cases = test_case.get('playlist', [] if is_playlist else [\n            test_case])\n\n        def print_skipping(reason):\n            print('Skipping {}: {}'.format(test_case['name'], reason))\n            self.skipTest(reason)\n        if not ie.working():\n            print_skipping('IE marked as not _WORKING')\n        for tc in test_cases:\n            if tc.get('expected_exception'):\n                continue\n            info_dict = tc.get('info_dict', {})\n            params = tc.get('params', {})\n            if not info_dict.get('id'):\n                raise Exception(\n                    f'Test {tname} definition incorrect - \"id\" key is not present'\n                    )\n            elif not info_dict.get('ext') and info_dict.get('_type', 'video'\n                ) == 'video':\n                if params.get('skip_download') and params.get(\n                    'ignore_no_formats_error'):\n                    continue\n                raise Exception(\n                    f'Test {tname} definition incorrect - \"ext\" key must be present to define the output file'\n                    )\n        if 'skip' in test_case:\n            print_skipping(test_case['skip'])\n        for other_ie in other_ies:\n            if not other_ie.working():\n                print_skipping(\n                    f'test depends on {other_ie.ie_key()}IE, marked as not WORKING'\n                    )\n        params = get_params(test_case.get('params', {}))\n        params['outtmpl'] = tname + '_' + params['outtmpl']\n        if is_playlist and 'playlist' not in test_case:\n            params.setdefault('extract_flat', 'in_playlist')\n            params.setdefault('playlistend', test_case.get(\n                'playlist_mincount', test_case.get('playlist_count', -2) + 1))\n            params.setdefault('skip_download', True)\n        ydl = YoutubeDL(params, auto_init=False)\n        ydl.add_default_info_extractors()\n        finished_hook_called = set()\n\n        def _hook(status):\n            if status['status'] == 'finished':\n                finished_hook_called.add(status['filename'])\n        ydl.add_progress_hook(_hook)\n        expect_warnings(ydl, test_case.get('expected_warnings', []))\n\n        def get_tc_filename(tc):\n            return ydl.prepare_filename(dict(tc.get('info_dict', {})))\n        res_dict = None\n\n        def match_exception(err):\n            expected_exception = test_case.get('expected_exception')\n            if not expected_exception:\n                return False\n            if err.__class__.__name__ == expected_exception:\n                return True\n            return any(exc.__class__.__name__ == expected_exception for exc in\n                err.exc_info)\n\n        def try_rm_tcs_files(tcs=None):\n            if tcs is None:\n                tcs = test_cases\n            for tc in tcs:\n                tc_filename = get_tc_filename(tc)\n                try_rm(tc_filename)\n                try_rm(tc_filename + '.part')\n                try_rm(os.path.splitext(tc_filename)[0] + '.info.json')\n        try_rm_tcs_files()\n        try:\n            try_num = 1\n            while True:\n                try:\n                    res_dict = ydl.extract_info(test_case['url'],\n                        force_generic_extractor=params.get(\n                        'force_generic_extractor', False))\n                except (DownloadError, ExtractorError) as err:\n                    if not isinstance(err.exc_info[1], (TransportError,\n                        UnavailableVideoError)) or isinstance(err.exc_info[\n                        1], HTTPError) and err.exc_info[1].status == 503:\n                        if match_exception(err):\n                            return\n                        err.msg = f\"{getattr(err, 'msg', err)} ({tname})\"\n                        raise\n                    if try_num == RETRIES:\n                        raise\n                    print(f'Retrying: {try_num} failed tries\\n\\n##########\\n\\n'\n                        )\n                    try_num += 1\n                except YoutubeDLError as err:\n                    if match_exception(err):\n                        return\n                    raise\n                else:\n                    break\n            if is_playlist:\n                self.assertTrue(res_dict['_type'] in ['playlist',\n                    'multi_video'])\n                self.assertTrue('entries' in res_dict)\n                expect_info_dict(self, res_dict, test_case.get('info_dict', {})\n                    )\n            if 'playlist_mincount' in test_case:\n                assertGreaterEqual(self, len(res_dict['entries']),\n                    test_case['playlist_mincount'], \n                    'Expected at least %d in playlist %s, but got only %d' %\n                    (test_case['playlist_mincount'], test_case['url'], len(\n                    res_dict['entries'])))\n            if 'playlist_count' in test_case:\n                self.assertEqual(len(res_dict['entries']), test_case[\n                    'playlist_count'], \n                    'Expected %d entries in playlist %s, but got %d.' % (\n                    test_case['playlist_count'], test_case['url'], len(\n                    res_dict['entries'])))\n            if 'playlist_duration_sum' in test_case:\n                got_duration = sum(e['duration'] for e in res_dict['entries'])\n                self.assertEqual(test_case['playlist_duration_sum'],\n                    got_duration)\n            if 'entries' not in res_dict:\n                res_dict['entries'] = [res_dict]\n            for tc_num, tc in enumerate(test_cases):\n                tc_res_dict = res_dict['entries'][tc_num]\n                expect_info_dict(self, tc_res_dict, tc.get('info_dict', {}))\n                if tc_res_dict.get('_type', 'video') != 'video':\n                    continue\n                tc_filename = get_tc_filename(tc)\n                if not test_case.get('params', {}).get('skip_download', False):\n                    self.assertTrue(os.path.exists(tc_filename), msg=\n                        'Missing file ' + tc_filename)\n                    self.assertTrue(tc_filename in finished_hook_called)\n                    expected_minsize = tc.get('file_minsize', 10000)\n                    if expected_minsize is not None:\n                        if params.get('test'):\n                            expected_minsize = max(expected_minsize, 10000)\n                        got_fsize = os.path.getsize(tc_filename)\n                        assertGreaterEqual(self, got_fsize,\n                            expected_minsize,\n                            f\"Expected {tc_filename} to be at least {format_bytes(expected_minsize)}, but it's only {format_bytes(got_fsize)} \"\n                            )\n                    if 'md5' in tc:\n                        md5_for_file = _file_md5(tc_filename)\n                        self.assertEqual(tc['md5'], md5_for_file)\n                info_json_fn = os.path.splitext(tc_filename)[0] + '.info.json'\n                self.assertTrue(os.path.exists(info_json_fn),\n                    f'Missing info file {info_json_fn}')\n                with open(info_json_fn, encoding='utf-8') as infof:\n                    info_dict = json.load(infof)\n                expect_info_dict(self, info_dict, tc.get('info_dict', {}))\n        finally:\n            try_rm_tcs_files()\n            if is_playlist and res_dict is not None and res_dict.get('entries'\n                ):\n                res_tcs = [{'info_dict': e} for e in res_dict['entries']]\n                try_rm_tcs_files(res_tcs)\n            ydl.close()\n    return test_template\n\ngenerator()\n", "code_start": "", "test_path": "../srcdata/Network/yt-dlp/test/test_download.py"}], "instruction": "Functionality: The expect_warnings function is designed to modify the warning reporting behavior of a given instance of a downloader (ydl). It wraps the original warning reporting function with a custom one that filters out warnings based on a list of regular expressions (warnings_re). Only warnings that do not match any of the provided regular expressions will be reported using the original warning function.\n\nInputs: \n- ydl: An instance of the downloader class, which has a method report_warning for reporting warnings.\n- warnings_re: A list of regular expressions (as strings). Each warning message will be checked against these regular expressions. If a warning message matches any of the regular expressions, it will not be reported.\n\nOutputs:\n- None. The function modifies the ydl instance in place by changing its report_warning method to the custom warning handler defined within expect_warnings.", "method_code_mask": "import errno\nimport hashlib\nimport json\nimport os.path\nimport re\nimport ssl\nimport sys\nimport types\nimport pytest\n\n\ndef expect_warnings(ydl, warnings_re): [MASK]\n"}
