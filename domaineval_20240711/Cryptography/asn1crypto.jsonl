{"method_name": "walk_ast", "full_method_name": "walk_ast", "method_path": "../srcdata/Cryptography/asn1crypto/tests/test_init.py", "method_code": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\ndef walk_ast(parent_node, modname, imports):\n    \"\"\"\n    Walks the AST for a module finding any imports and recording them\n    :param parent_node:\n        A node from the _ast module\n    :param modname:\n        A unicode string of the module we are walking the AST of\n    :param imports:\n        A set of unicode strings of the imports that have been found so far\n    \"\"\"\n    for node in ast.iter_child_nodes(parent_node):\n        if isinstance(node, _ast.Import):\n            if node.names[0].name.startswith(module.__name__):\n                add_mod(node.names[0].name, imports)\n        elif isinstance(node, _ast.ImportFrom):\n            if node.level > 0:\n                if modname == module.__name__:\n                    base_mod = module.__name__\n                else:\n                    base_mod = '.'.join(modname.split('.')[:-node.level])\n                if node.module:\n                    base_mod += '.' + node.module\n            else:\n                base_mod = node.module\n            if not base_mod.startswith(module.__name__):\n                continue\n            if node.level > 0 and not node.module:\n                for n in node.names:\n                    add_mod(base_mod + '.' + n.name, imports)\n            else:\n                add_mod(base_mod, imports)\n        elif isinstance(node, _ast.If):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info >= (3, 3) and isinstance(node, _ast.Try):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryFinally):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryExcept):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)", "test_code_list": [{"test_code": "import ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\n\nclass InitTests(unittest.TestCase):\n    def test_load_order(self):\n        deps = {}\n        mod_root = os.path.abspath(os.path.dirname(module.__file__))\n        files = []\n        for root, dnames, fnames in os.walk(mod_root):\n            for f in fnames:\n                if f.endswith('.py'):\n                    full_path = os.path.join(root, f)\n                    rel_path = full_path.replace(mod_root + os.sep, '')\n                    files.append((full_path, rel_path))\n        for full_path, rel_path in sorted(files):\n            with open(full_path, 'rb') as f:\n                full_code = f.read()\n                if sys.version_info >= (3,):\n                    full_code = full_code.decode('utf-8')\n            modname = rel_path.replace('.py', '').replace(os.sep, '.')\n            if modname == '__init__':\n                modname = module.__name__\n            else:\n                modname = '%s.%s' % (module.__name__, modname)\n            if sys.version_info < (3,\n                ) and sys.platform == 'win32' and b'\\r\\n' in full_code:\n                full_code = full_code.replace(b'\\r\\n', b'\\n')\n            imports = set([])\n            module_node = ast.parse(full_code, filename=full_path)\n            walk_ast(module_node, modname, imports)\n            deps[modname] = imports\n        load_order = module.load_order()\n        prev = set([])\n        for mod in load_order:\n            self.assertEqual(True, mod in deps)\n            self.assertEqual((mod, set([])), (mod, deps[mod] - prev))\n            prev.add(mod)\n    \nInitTests().test_load_order()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_init.py"}], "instruction": "Functionality: The walk_ast function is designed to traverse the Abstract Syntax Tree (AST) of a given Python module. It explores the AST nodes to identify any imports related to a specified module and records these imports. The function supports various types of import statements, including simple imports and imports from specific namespaces.\n\nInputs:\n1. parent_node: A node from the _ast module, representing the current node in the AST to be traversed.\n2. modname: A unicode string indicating the name of the module whose AST is being walked. This is necessary for resolving relative imports.\n3. imports: A set of unicode strings that keeps track of the imports that have been found during the traversal of the AST.\n\nOutputs:\nThe function modifies the 'imports' set in place. It does not return any value, but rather updates the 'imports' set with the names of the modules that were found to be imported within the given module.", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\n\n\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\n\n\ndef walk_ast(parent_node, modname, imports): [MASK]\n"}
{"method_name": "_int_to_bit_tuple", "full_method_name": "_int_to_bit_tuple", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/core.py", "method_code": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\ndef _int_to_bit_tuple(value, bits):\n    \"\"\"\n    Format value as a tuple of 1s and 0s.\n\n    :param value:\n        A non-negative integer to format\n\n    :param bits:\n        Number of bits in the output\n\n    :return:\n        A tuple of 1s and 0s with bits members.\n    \"\"\"\n    if not value and not bits:\n        return ()\n    result = tuple(map(int, format(value, '0{0}b'.format(bits))))\n    if len(result) != bits:\n        raise ValueError('Result too large: {0} > {1}'.format(len(result),\n            bits))\n    return result", "test_code_list": [{"test_code": "import pickle\nimport unittest\nimport os\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom asn1crypto import core\nfrom asn1crypto import util\n\nclass CoreTests(unittest.TestCase):\n    def test_int_to_bit_tuple(self):\n        self.assertEqual((), _int_to_bit_tuple(0, 0))\n        self.assertEqual((0,), _int_to_bit_tuple(0, 1))\n        self.assertEqual((1,), _int_to_bit_tuple(1, 1))\n        self.assertEqual((0, 0), _int_to_bit_tuple(0, 2))\n        self.assertEqual((0, 1), _int_to_bit_tuple(1, 2))\n        self.assertEqual((0, 0, 1), _int_to_bit_tuple(1, 3))\n        self.assertEqual((0, 1, 0), _int_to_bit_tuple(2, 3))\n        self.assertEqual((1, 0, 1), _int_to_bit_tuple(5, 3))\n        with self.assertRaises(ValueError):\n            _int_to_bit_tuple(9, 3)\n        with self.assertRaises(ValueError):\n            _int_to_bit_tuple(-9, 5)\n    \nCoreTests().test_int_to_bit_tuple()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_core.py"}, {"test_code": "import pickle\nimport unittest\nimport os\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom asn1crypto import core\nfrom asn1crypto import util\n\nclass CoreTests(unittest.TestCase):\n    def test_indefinite_length_bit_string(self):\n        data = b'#\\x80\\x03\\x02\\x00\\x01\\x03\\x02\\x02\\x04\\x00\\x00'\n        a = core.BitString.load(data)\n        self.assertEqual((0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1), a.native)\n        self.assertEqual((0, 0), a.unused_bits)\n        prim = core.BitString.load(b'\\x03\\x07\\x04\\n;_)\\x1c\\xd0')\n        self.assertEqual((0, 0, 0, 0), prim.unused_bits)\n        indef = core.BitString.load(\n            b'#\\x80\\x03\\x03\\x00\\n;\\x03\\x05\\x04_)\\x1c\\xd0\\x00\\x00')\n        self.assertEqual(prim.native, indef.native)\n        self.assertEqual(_int_to_bit_tuple(703132242381, 44), indef.native)\n        self.assertEqual((0, 0, 0, 0), indef.unused_bits)\n        unused = core.BitString.load(\n            b'#\\x80\\x03\\x03\\x00\\n;\\x03\\x05\\x04_)\\x1c\\xdd\\x00\\x00')\n        self.assertEqual(indef.native, unused.native)\n        self.assertEqual((1, 1, 0, 1), unused.unused_bits)\n        unused.set(indef.native)\n        self.assertEqual(indef.native, unused.native)\n        self.assertEqual((0, 0, 0, 0), unused.unused_bits)\n    \nCoreTests().test_indefinite_length_bit_string()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_core.py"}], "instruction": "Functionality: The function _int_to_bit_tuple is designed to convert a given non-negative integer into a tuple representation of its binary form, with a specified number of bits. It ensures the output tuple has exactly the number of bits requested, padding the binary representation with leading zeros if necessary.\n\nInputs: \n- value: A non-negative integer that you want to convert into binary format.\n- bits: An integer indicating the total number of bits you want in the output tuple.\n\nOutputs: \n- A tuple consisting of 1s and 0s representing the binary form of the input integer 'value', with the length of the tuple being equal to 'bits'. If the binary representation of 'value' has fewer bits than specified, the tuple will be padded with leading zeros. If 'value' requires more bits than specified, a ValueError will be raised.", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\n\n\ndef _int_to_bit_tuple(value, bits): [MASK]\n"}
{"method_name": "create_timezone", "full_method_name": "create_timezone", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/util.py", "method_code": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\ndef create_timezone(offset):\n    \"\"\"\n    Returns a new datetime.timezone object with the given offset.\n    Uses cached objects if possible.\n    :param offset:\n        A datetime.timedelta object; It needs to be in full minutes and between -23:59 and +23:59.\n    :return:\n        A datetime.timezone object\n    \"\"\"\n    try:\n        tz = _timezone_cache[offset]\n    except KeyError:\n        tz = _timezone_cache[offset] = timezone(offset)\n    return tz", "test_code_list": [{"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_properties(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        dt = util.extended_datetime(0, 11, 27, 5, 44, 31, 14889, zone)\n        self.assertEqual(dt.year, 0)\n        self.assertEqual(dt.month, 11)\n        self.assertEqual(dt.day, 27)\n        self.assertEqual(dt.hour, 5)\n        self.assertEqual(dt.minute, 44)\n        self.assertEqual(dt.second, 31)\n        self.assertEqual(dt.microsecond, 14889)\n        self.assertEqual(dt.tzinfo, zone)\n    \nUtilTests().test_extended_datetime_properties()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_replace(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 1, 1, 23, tzinfo=zone)\n        self.assertEqual(ext_dt.replace(year=2040, minute=59), datetime(2040, 1,\n            1, 23, 59, tzinfo=zone))\n        self.assertEqual(ext_dt.replace(minute=59), util.extended_datetime(0, 1,\n            1, 23, 59, tzinfo=zone))\n    \nUtilTests().test_extended_datetime_replace()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\nif sys.version_info < (3,):\n    py2 = True\n    byte_cls = str\n    num_cls = long\nelse:\n    py2 = False\n    byte_cls = bytes\n    num_cls = int\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_encodings(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 2, 29, 9, 17, 45, 14889, zone)\n        self.assertEqual(str(ext_dt), '0000-02-29 09:17:45.014889+12:45')\n        if py2:\n            self.assertEqual(unicode(ext_dt), '0000-02-29 09:17:45.014889+12:45')\n        ext_dt = util.extended_datetime(0, 2, 29, 9, 17, 45, 0, zone)\n        self.assertEqual(str(ext_dt), '0000-02-29 09:17:45+12:45')\n        if py2:\n            self.assertEqual(unicode(ext_dt), '0000-02-29 09:17:45+12:45')\nUtilTests().test_extended_datetime_encodings()", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_timestamp(self):\n        if sys.version_info >= (3, 3):\n            zone = create_timezone(timedelta(hours=12, minutes=45))\n            ext_dt = util.extended_datetime(0, 12, 31, 23, 0, 0, 14889, zone)\n            dt = datetime(1, 1, 1, 0, 0, 0, 14889, zone)\n            self.assertTrue(abs(dt.timestamp() - ext_dt.timestamp() - 3600.0) <\n                1e-07)\n    \nUtilTests().test_extended_datetime_timestamp()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\nutc = util.timezone.utc\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_compare(self):\n        self.assertTrue(util.extended_datetime(0, 1, 1) < datetime(1, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= datetime(1, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) != datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) >= datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) < util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= util.\n            extended_datetime(0, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) != util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) >= util.\n            extended_datetime(0, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) < util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 1) != util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) >= util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) < util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) <= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) != util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) == util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) >= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) > util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-8))) == datetime(1, 1, 1, 5, 4, 5,\n            6, utc))\n        self.assertTrue(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-8))) == datetime(1, 1, 1, 5, 7, 5,\n            6, create_timezone(timedelta(hours=0, minutes=3))))\n        self.assertFalse(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-7))) == datetime(1, 1, 1, 5, 4, 5,\n            6, utc))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 1, tzinfo=utc))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == '0000-01-01')\n        with self.assertRaises(TypeError):\n            util.extended_datetime(0, 1, 1) < '0000-01-02'\nUtilTests().test_extended_datetime_compare()", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_arithmetic(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 12, 31, 9, 17, 45, 14889, zone)\n        self.assertEqual(ext_dt + timedelta(hours=20), datetime(1, 1, 1, 5, 17,\n            45, 14889, zone))\n        self.assertEqual(ext_dt - timedelta(hours=20), util.extended_datetime(0,\n            12, 30, 13, 17, 45, 14889, zone))\n        self.assertEqual(ext_dt - ext_dt, timedelta(0))\n        zone2 = create_timezone(timedelta(hours=-8, minutes=-31))\n        ext_dt2 = util.extended_datetime(0, 11, 14, 13, 44, 20, 876543, zone2)\n        expected_diff = timedelta(days=47, hours=-4, minutes=-27, seconds=25,\n            microseconds=-861654)\n        expected_diff -= timedelta(hours=20, minutes=76)\n        self.assertEqual(ext_dt - ext_dt2, expected_diff)\n        dt = datetime(400, 12, 31, 9, 17, 45, 14889, zone)\n        self.assertEqual(dt - ext_dt, timedelta(days=util.extended_datetime.\n            DAYS_IN_400_YEARS))\n        self.assertEqual(ext_dt - dt, -timedelta(days=util.extended_datetime.\n            DAYS_IN_400_YEARS))\n        with self.assertRaises(TypeError):\n            ext_dt - 'test'\n    \nUtilTests().test_extended_datetime_arithmetic()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}], "instruction": "Functionality: The create_timezone function is designed to return a new datetime.timezone object with a given offset. It utilizes cached objects if available to optimize performance. The offset must be within the range of -23:59 to +23:59 and in full minutes.\n\nInputs:\n- offset: A datetime.timedelta object representing the desired timezone offset. This offset must be in full minutes and within the valid range of -23:59 to +23:59.\n\nOutputs:\n- A datetime.timezone object corresponding to the given offset. This object represents the timezone information with the specified offset from UTC.", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\n\n\ndef create_timezone(offset): [MASK]\n"}
