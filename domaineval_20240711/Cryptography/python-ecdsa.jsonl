{"method_name": "encode_bitstring", "full_method_name": "encode_bitstring", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\ndef encode_length(l):\n    assert l >= 0\n    if l < 128:\n        return int2byte(l)\n    s = ('%x' % l).encode()\n    if len(s) % 2:\n        s = b'0' + s\n    s = binascii.unhexlify(s)\n    llen = len(s)\n    return int2byte(128 | llen) + s\n_sentry = object()\ndef encode_bitstring(s, unused=_sentry):\n    \"\"\"\n    Encode a binary string as a BIT STRING using :term:`DER` encoding.\n    Note, because there is no native Python object that can encode an actual\n    bit string, this function only accepts byte strings as the `s` argument.\n    The byte string is the actual bit string that will be encoded, padded\n    on the right (least significant bits, looking from big endian perspective)\n    to the first full byte. If the bit string has a bit length that is multiple\n    of 8, then the padding should not be included. For correct DER encoding\n    the padding bits MUST be set to 0.\n    Number of bits of padding need to be provided as the `unused` parameter.\n    In case they are specified as None, it means the number of unused bits\n    is already encoded in the string as the first byte.\n    The deprecated call convention specifies just the `s` parameters and\n    encodes the number of unused bits as first parameter (same convention\n    as with None).\n    Empty string must be encoded with `unused` specified as 0.\n    Future version of python-ecdsa will make specifying the `unused` argument\n    mandatory.\n    :param s: bytes to encode\n    :type s: bytes like object\n    :param unused: number of bits at the end of `s` that are unused, must be\n        between 0 and 7 (inclusive)\n    :type unused: int or None\n    :raises ValueError: when `unused` is too large or too small\n    :return: `s` encoded using DER\n    :rtype: bytes\n    \"\"\"\n    encoded_unused = b''\n    len_extra = 0\n    if unused is _sentry:\n        warnings.warn(\n            'Legacy call convention used, unused= needs to be specified',\n            DeprecationWarning)\n    elif unused is not None:\n        if not 0 <= unused <= 7:\n            raise ValueError('unused must be integer between 0 and 7')\n        if unused:\n            if not s:\n                raise ValueError('unused is non-zero but s is empty')\n            last = str_idx_as_int(s, -1)\n            if last & 2 ** unused - 1:\n                raise ValueError('unused bits must be zeros in DER')\n        encoded_unused = int2byte(unused)\n        len_extra = 1\n    return b'\\x03' + encode_length(len(s) + len_extra) + encoded_unused + s", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_old_call_convention(self):\n        \"\"\"This is the old way to use the function.\"\"\"\n        warnings.simplefilter('always')\n        with pytest.warns(DeprecationWarning) as warns:\n            der = encode_bitstring(b'\\x00\\xff')\n        self.assertEqual(len(warns), 1)\n        self.assertIn('unused= needs to be specified', warns[0].message.args[0])\n        self.assertEqual(der, b'\\x03\\x02\\x00\\xff')\n    \nTestEncodeBitstring().test_old_call_convention()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_new_call_convention(self):\n        \"\"\"This is how it should be called now.\"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            der = encode_bitstring(b'\\xff', 0)\n        self.assertEqual(der, b'\\x03\\x02\\x00\\xff')\n    \nTestEncodeBitstring().test_new_call_convention()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_implicit_unused_bits(self):\n        \"\"\"\n            Writing bit string with already included the number of unused bits.\n            \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            der = encode_bitstring(b'\\x00\\xff', None)\n        self.assertEqual(der, b'\\x03\\x02\\x00\\xff')\n    \nTestEncodeBitstring().test_implicit_unused_bits()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_empty_string(self):\n        self.assertEqual(encode_bitstring(b'', 0), b'\\x03\\x01\\x00')\n    \nTestEncodeBitstring().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_invalid_unused_count(self):\n        with self.assertRaises(ValueError):\n            encode_bitstring(b'\\xff\\x00', 8)\n    \nTestEncodeBitstring().test_invalid_unused_count()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestEncodeBitstring(unittest.TestCase):\n    def test_invalid_unused_with_empty_string(self):\n        with self.assertRaises(ValueError):\n            encode_bitstring(b'', 1)\n    \nTestEncodeBitstring().test_invalid_unused_with_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The encode_bitstring function encodes a binary string as a BIT STRING using DER encoding. It accepts byte strings as input, where the byte string represents the bit string, padded on the right to the first full byte. If the bit string's length is a multiple of 8, the padding should not be included. For correct DER encoding, the padding bits MUST be set to 0. The number of bits of padding must be provided as the 'unused' parameter. If None, it means the number of unused bits is already encoded in the string as the first byte.\n\nInputs: \n- s: The byte string to encode. This should be a bytes-like object.\n- unused: The number of bits at the end of 's' that are unused. This should be an integer between 0 and 7 (inclusive) or None. If None, it is assumed the number of unused bits is encoded in the string.\n\nOutputs:\n- Returns a byte string representing the DER encoding of the input 's'. The output is of type 'bytes'.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\ndef encode_length(l):\n    assert l >= 0\n    if l < 128:\n        return int2byte(l)\n    s = ('%x' % l).encode()\n    if len(s) % 2:\n        s = b'0' + s\n    s = binascii.unhexlify(s)\n    llen = len(s)\n    return int2byte(128 | llen) + s\n\n\n_sentry = object()\n\n\ndef encode_bitstring(s, unused=_sentry): [MASK]\n"}
{"method_name": "sigdecode_strings", "full_method_name": "sigdecode_strings", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/util.py", "method_code": "from __future__ import division\nimport os\nimport math\nimport binascii\nimport sys\nfrom hashlib import sha256\nfrom six import PY2\nfrom six import int2byte\nfrom six import next\nclass MalformedSignature(Exception):\n    \"\"\"\n    Raised by decoding functions when the signature is malformed.\n\n    Malformed in this context means that the relevant strings or integers\n    do not match what a signature over provided curve would create. Either\n    because the byte strings have incorrect lengths or because the encoded\n    values are too large.\n    \"\"\"\n    pass\ndef sigdecode_strings(rs_strings, order):\n    \"\"\"\n    Decode the signature from two strings.\n    First string needs to be a big endian encoding of ``r``, second needs to\n    be a big endian encoding of the ``s`` parameter of an ECDSA signature.\n    It's expected that this function will be used as the ``sigdecode=``\n    parameter to the :func:`ecdsa.keys.VerifyingKey.verify` method.\n    :param list rs_strings: list of two bytes-like objects, each encoding one\n        parameter of signature\n    :param int order: order of the curve over which the signature was computed\n    :raises MalformedSignature: when the encoding of the signature is invalid\n    :return: tuple with decoded ``r`` and ``s`` values of signature\n    :rtype: tuple of ints\n    \"\"\"\n    if not len(rs_strings) == 2:\n        raise MalformedSignature(\n            'Invalid number of strings provided: {0}, expected 2'.format(\n            len(rs_strings)))\n    r_str, s_str = rs_strings\n    r_str = normalise_bytes(r_str)\n    s_str = normalise_bytes(s_str)\n    l = orderlen(order)\n    if not len(r_str) == l:\n        raise MalformedSignature(\n            \"Invalid length of first string ('r' parameter), expected {0} bytes long, provided string is {1} bytes long\"\n            .format(l, len(r_str)))\n    if not len(s_str) == l:\n        raise MalformedSignature(\n            \"Invalid length of second string ('s' parameter), expected {0} bytes long, provided string is {1} bytes long\"\n            .format(l, len(s_str)))\n    r = string_to_number_fixedlen(r_str, order)\n    s = string_to_number_fixedlen(s_str, order)\n    return r, s", "test_code_list": [{"test_code": "import unittest\nimport os\nimport shutil\nimport subprocess\nimport pytest\nimport sys\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport hashlib\nfrom functools import partial\nfrom six import binary_type\n\nclass ECDSA(unittest.TestCase):\n    def test_sig_decode_strings_with_invalid_count(self):\n        with self.assertRaises(MalformedSignature):\n            sigdecode_strings([b'one', b'two', b'three'], 255)\n    \nECDSA().test_sig_decode_strings_with_invalid_count()\n", "code_start": "from __future__ import with_statement\nfrom __future__ import division\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_pyecdsa.py"}], "instruction": "Functionality: This function decodes a signature from two strings representing the 'r' and 's' parameters of an ECDSA signature. It is designed to be used with the 'sigdecode=' parameter in the ecdsa.keys.VerifyingKey.verify method. The function ensures that the input strings are of the correct length and format, converting them from byte strings to integers, and returns a tuple of the decoded 'r' and 's' values.\n\nInputs:\n- rs_strings: A list containing two byte-like objects, where the first object is the big endian encoding of 'r' and the second object is the big endian encoding of 's'.\n- order: An integer representing the order of the curve over which the signature was computed.\n\nOutputs:\n- A tuple containing the decoded 'r' and 's' values as integers, if the input strings are valid.\n- Raises a MalformedSignature exception if the number of strings is not 2, the strings are not of the correct length, or the encoding of the signature is otherwise invalid.", "method_code_mask": "from __future__ import division\nimport os\nimport math\nimport binascii\nimport sys\nfrom hashlib import sha256\nfrom six import PY2\nfrom six import int2byte\nfrom six import next\n\n\nclass MalformedSignature(Exception):\n    \"\"\"\n    Raised by decoding functions when the signature is malformed.\n\n    Malformed in this context means that the relevant strings or integers\n    do not match what a signature over provided curve would create. Either\n    because the byte strings have incorrect lengths or because the encoded\n    values are too large.\n    \"\"\"\n    pass\n\n\ndef sigdecode_strings(rs_strings, order): [MASK]\n"}
{"method_name": "remove_integer", "full_method_name": "remove_integer", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\nclass UnexpectedDER(Exception):\n    pass\ndef remove_integer(string):\n    if not string:\n        raise UnexpectedDER('Empty string is an invalid encoding of an integer'\n            )\n    if string[:1] != b'\\x02':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'integer' (0x02), got 0x%02x\" % n)\n    length, llen = read_length(string[1:])\n    if length > len(string) - 1 - llen:\n        raise UnexpectedDER('Length longer than provided buffer')\n    if length == 0:\n        raise UnexpectedDER('0-byte long encoding of integer')\n    numberbytes = string[1 + llen:1 + llen + length]\n    rest = string[1 + llen + length:]\n    msb = str_idx_as_int(numberbytes, 0)\n    if not msb < 128:\n        raise UnexpectedDER('Negative integers are not supported')\n    if length > 1 and not msb:\n        smsb = str_idx_as_int(numberbytes, 1)\n        if smsb < 128:\n            raise UnexpectedDER(\n                'Invalid encoding of integer, unnecessary zero padding bytes')\n    return int(binascii.hexlify(numberbytes), 16), rest", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestRemoveInteger(unittest.TestCase):\n    def test_empty_string(self):\n        with self.assertRaises(UnexpectedDER):\n            remove_integer(b'')\n    \nTestRemoveInteger().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The remove_integer function is designed to parse and extract an integer value from a DER-encoded string. DER (Distinguished Encoding Rules) is a subset of ASN.1 (Abstract Syntax Notation One) that specifies the binary encoding of structured data types. This function specifically handles the 'integer' type (0x02) in DER encoding, reading and validating its length and byte content, then extracting the integer value along with any remaining string after the integer.\n\nInputs: \n   - string: A DER-encoded byte string from which an integer value is to be parsed. The string must contain a DER-encoded integer value at the beginning, followed by any possible remaining data.\n\nOutputs: \n   - (integer, remaining_string): A tuple where the first element is the integer value extracted from the DER-encoded byte string, and the second element is the remaining part of the string after the integer value. This allows for sequential parsing of multiple DER-encoded data types from a single string if necessary.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef remove_integer(string): [MASK]\n"}
{"method_name": "read_length", "full_method_name": "read_length", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestReadLength(unittest.TestCase):\n    def test_empty_string(self):\n        with self.assertRaises(UnexpectedDER):\n            read_length(b'')\n    \nTestReadLength().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The read_length function is designed to parse a DER (Distinguished Encoding Rules) encoded length from a byte string. It reads the length encoding and returns the length value and the number of bytes used to encode the length.\n\nInputs: \n- string: A byte string that encodes the length. The string is expected to start with the DER length encoding.\n\nOutputs: \n- A tuple (length, bytes_used) where 'length' is the integer value of the DER encoded length, and 'bytes_used' is the number of bytes from the input string that were used to encode the length.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string): [MASK]\n"}
{"method_name": "remove_sequence", "full_method_name": "remove_sequence", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\ndef remove_sequence(string):\n    if not string:\n        raise UnexpectedDER('Empty string does not encode a sequence')\n    if string[:1] != b'0':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'sequence' (0x30), got 0x%02x\" % n)\n    length, lengthlength = read_length(string[1:])\n    if length > len(string) - 1 - lengthlength:\n        raise UnexpectedDER('Length longer than the provided buffer')\n    endseq = 1 + lengthlength + length\n    return string[1 + lengthlength:endseq], string[endseq:]", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestRemoveSequence(unittest.TestCase):\n    def test_with_empty_string(self):\n        with self.assertRaises(UnexpectedDER) as e:\n            remove_sequence(b'')\n        self.assertIn('Empty string', str(e.exception))\n    \nTestRemoveSequence().test_with_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The function 'remove_sequence' is designed to process a DER (Distinguished Encoding Rules) encoded byte string. It extracts the sequence (a list of values) from the given string and separates the sequence from the rest of the string. The function verifies whether the string starts with the correct sequence identifier and reads the length of the sequence. It ensures the sequence encoding is minimal and does not exceed the buffer length.\n\nInputs: \n- string (bytes): A DER encoded byte string from which the sequence will be extracted.\n\nOutputs: \n- A tuple containing two elements:\n  1. The extracted sequence as a byte string.\n  2. The remaining part of the input string after the sequence, also as a byte string.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\ndef remove_sequence(string): [MASK]\n"}
{"method_name": "gcd", "full_method_name": "gcd", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]", "test_code_list": [{"test_code": "import operator\nfrom functools import reduce\nimport sys\nimport unittest\nimport pytest\nfrom gmpy2 import mpz\n\nclass TestNumbertheory(unittest.TestCase):\n    def test_gcd(self):\n        assert gcd(3 * 5 * 7, 3 * 5 * 11, 3 * 5 * 13) == 3 * 5\n        assert gcd([3 * 5 * 7, 3 * 5 * 11, 3 * 5 * 13]) == 3 * 5\n        assert gcd(3) == 3\n    \nTestNumbertheory().test_gcd()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_numbertheory.py"}], "instruction": "Functionality: The gcd function calculates the Greatest Common Divisor (GCD) of a set of integers. It is capable of handling multiple input arguments or a single iterable argument containing integers.\n\nInputs: The function accepts either multiple integer arguments separated by commas or a single iterable (like a list or tuple) of integers. At least two integers are required to compute the GCD.\n\nOutputs: The function returns a single integer representing the greatest common divisor of all provided integers. If the input is a single iterable, the GCD of all integers within that iterable will be returned. If less than two integers are provided, the function behavior is undefined.", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\n\n\ndef gcd(*a): [MASK]\n"}
{"method_name": "lcm", "full_method_name": "lcm", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]\ndef lcm2(a, b):\n    \"\"\"Least common multiple of two integers.\"\"\"\n    return a * b // gcd(a, b)\ndef lcm(*a):\n    \"\"\"Least common multiple.\n    Usage: lcm([ 3, 4, 5 ])\n    or:    lcm(3, 4, 5)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(lcm2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(lcm2, a[0])\n    return a[0]", "test_code_list": [{"test_code": "import operator\nfrom functools import reduce\nimport sys\nimport unittest\nimport pytest\nfrom gmpy2 import mpz\n\nclass TestNumbertheory(unittest.TestCase):\n    def test_lcm(self):\n        assert lcm(3, 5 * 3, 7 * 3) == 3 * 5 * 7\n        assert lcm([3, 5 * 3, 7 * 3]) == 3 * 5 * 7\n        assert lcm(3) == 3\n    \nTestNumbertheory().test_lcm()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_numbertheory.py"}], "instruction": "Functionality: The function lcm is designed to calculate the least common multiple (LCM) of a series of integer arguments. It utilizes the gcd function, which computes the greatest common divisor (GCD) of the numbers, to find the LCM based on the formula LCM(a, b) = (a * b) / GCD(a, b). The function supports both multiple arguments passed individually or as a list.\n\nInputs: The input to the lcm function can be in one of two forms:\n1. A series of integers passed as individual arguments.\n2. A single list or iterable containing the integers for which the LCM needs to be calculated.\n\nOutputs: The output of the lcm function is a single integer, which is the least common multiple of all the input numbers. If the input is a single number or an iterable containing a single number, the output will be that number itself.", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\n\n\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]\n\n\ndef lcm2(a, b):\n    \"\"\"Least common multiple of two integers.\"\"\"\n    return a * b // gcd(a, b)\n\n\ndef lcm(*a): [MASK]\n"}
{"method_name": "jacobi", "full_method_name": "jacobi", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ndef jacobi(a, n):\n    \"\"\"Jacobi symbol\"\"\"\n    if not n >= 3:\n        raise JacobiError('n must be larger than 2')\n    if not n % 2 == 1:\n        raise JacobiError('n must be odd')\n    a = a % n\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    a1, e = a, 0\n    while a1 % 2 == 0:\n        a1, e = a1 // 2, e + 1\n    if e % 2 == 0 or n % 8 == 1 or n % 8 == 7:\n        s = 1\n    else:\n        s = -1\n    if a1 == 1:\n        return s\n    if n % 4 == 3 and a1 % 4 == 3:\n        s = -s\n    return s * jacobi(n % a1, a1)", "test_code_list": [{"test_code": "import operator\nfrom functools import reduce\nimport sys\nimport unittest\nimport pytest\nfrom gmpy2 import mpz\n\nclass TestNumbertheory(unittest.TestCase):\n    def test_jacobi_with_zero(self):\n        assert jacobi(0, 3) == 0\n    \nTestNumbertheory().test_jacobi_with_zero()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_numbertheory.py"}, {"test_code": "import operator\nfrom functools import reduce\nimport sys\nimport unittest\nimport pytest\nfrom gmpy2 import mpz\n\nclass TestNumbertheory(unittest.TestCase):\n    def test_jacobi_with_one(self):\n        assert jacobi(1, 3) == 1\n    \nTestNumbertheory().test_jacobi_with_one()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_numbertheory.py"}], "instruction": "Functionality: The jacobi function calculates the Jacobi symbol (a/n), which is a generalization of the Legendre symbol in number theory. It is used to determine if a number 'a' is a quadratic residue modulo 'n'. The Jacobi symbol is calculated using a series of arithmetic operations and checks based on the prime factorization of 'n'.\n\nInputs: \n- a: An integer value representing the numerator of the Jacobi symbol.\n- n: An integer value representing the denominator of the Jacobi symbol. It must be greater than 2 and odd.\n\nOutputs:\n- Returns an integer value that is the result of the Jacobi symbol (a/n). This value can be -1, 0, or 1. A value of 1 indicates that 'a' might be a quadratic residue modulo 'n', -1 indicates that 'a' is not a quadratic residue modulo 'n', and 0 indicates that 'a' is divisible by 'n'.", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\n\n\ndef jacobi(a, n): [MASK]\n"}
{"method_name": "remove_object", "full_method_name": "remove_object", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\ndef remove_object(string):\n    if not string:\n        raise UnexpectedDER('Empty string does not encode an object identifier'\n            )\n    if string[:1] != b'\\x06':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'object' (0x06), got 0x%02x\" % n)\n    length, lengthlength = read_length(string[1:])\n    body = string[1 + lengthlength:1 + lengthlength + length]\n    rest = string[1 + lengthlength + length:]\n    if not body:\n        raise UnexpectedDER('Empty object identifier')\n    if len(body) != length:\n        raise UnexpectedDER(\n            'Length of object identifier longer than the provided buffer')\n    numbers = []\n    while body:\n        n, ll = read_number(body)\n        numbers.append(n)\n        body = body[ll:]\n    n0 = numbers.pop(0)\n    if n0 < 80:\n        first = n0 // 40\n    else:\n        first = 2\n    second = n0 - 40 * first\n    numbers.insert(0, first)\n    numbers.insert(1, second)\n    return tuple(numbers), rest", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestRemoveObject(unittest.TestCase):\n    def test_empty_string(self):\n        with self.assertRaises(UnexpectedDER):\n            remove_object(b'')\n    \nTestRemoveObject().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestRemoveObject(unittest.TestCase):\n    def test_missing_length(self):\n        with self.assertRaises(UnexpectedDER):\n            remove_object(b'\\x06')\n    \nTestRemoveObject().test_missing_length()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The function 'remove_object' is designed to parse a DER (Distinguished Encoding Rules) encoded object identifier from a given byte string. It extracts the object identifier and returns it as a tuple of numbers, along with the remaining part of the string after the object identifier.\n\nInputs: \n- string: A byte string that contains a DER encoded object identifier at the beginning. The object identifier is expected to be of type 'object' (0x06) and is followed by the length and the identifier itself.\n\nOutputs: \n- A tuple containing the numbers extracted from the DER encoded object identifier.\n- A byte string representing the remaining part of the input string after the object identifier has been parsed.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\ndef remove_object(string): [MASK]\n"}
{"method_name": "remove_bitstring", "full_method_name": "remove_bitstring", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\n_sentry = object()\ndef remove_bitstring(string, expect_unused=_sentry):\n    \"\"\"\n    Remove a BIT STRING object from `string` following :term:`DER`.\n    The `expect_unused` can be used to specify if the bit string should\n    have the amount of unused bits decoded or not. If it's an integer, any\n    read BIT STRING that has number of unused bits different from specified\n    value will cause UnexpectedDER exception to be raised (this is especially\n    useful when decoding BIT STRINGS that have DER encoded object in them;\n    DER encoding is byte oriented, so the unused bits will always equal 0).\n    If the `expect_unused` is specified as None, the first element returned\n    will be a tuple, with the first value being the extracted bit string\n    while the second value will be the decoded number of unused bits.\n    If the `expect_unused` is unspecified, the decoding of byte with\n    number of unused bits will not be attempted and the bit string will be\n    returned as-is, the callee will be required to decode it and verify its\n    correctness.\n    Future version of python will require the `expected_unused` parameter\n    to be specified.\n    :param string: string of bytes to extract the BIT STRING from\n    :type string: bytes like object\n    :param expect_unused: number of bits that should be unused in the BIT\n        STRING, or None, to return it to caller\n    :type expect_unused: int or None\n    :raises UnexpectedDER: when the encoding does not follow DER.\n    :return: a tuple with first element being the extracted bit string and\n        the second being the remaining bytes in the string (if any); if the\n        `expect_unused` is specified as None, the first element of the returned\n        tuple will be a tuple itself, with first element being the bit string\n        as bytes and the second element being the number of unused bits at the\n        end of the byte array as an integer\n    :rtype: tuple\n    \"\"\"\n    if not string:\n        raise UnexpectedDER('Empty string does not encode a bitstring')\n    if expect_unused is _sentry:\n        warnings.warn(\n            'Legacy call convention used, expect_unused= needs to be specified'\n            , DeprecationWarning)\n    num = str_idx_as_int(string, 0)\n    if string[:1] != b'\\x03':\n        raise UnexpectedDER('wanted bitstring (0x03), got 0x%02x' % num)\n    length, llen = read_length(string[1:])\n    if not length:\n        raise UnexpectedDER(\"Invalid length of bit string, can't be 0\")\n    body = string[1 + llen:1 + llen + length]\n    rest = string[1 + llen + length:]\n    if expect_unused is not _sentry:\n        unused = str_idx_as_int(body, 0)\n        if not 0 <= unused <= 7:\n            raise UnexpectedDER('Invalid encoding of unused bits')\n        if expect_unused is not None and expect_unused != unused:\n            raise UnexpectedDER('Unexpected number of unused bits')\n        body = body[1:]\n        if unused:\n            if not body:\n                raise UnexpectedDER('Invalid encoding of empty bit string')\n            last = str_idx_as_int(body, -1)\n            if last & 2 ** unused - 1:\n                raise UnexpectedDER('Non zero padding bits in bit string')\n        if expect_unused is None:\n            body = body, unused\n    return body, rest", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestRemoveBitstring(unittest.TestCase):\n    def test_empty_string(self):\n        with self.assertRaises(UnexpectedDER):\n            remove_bitstring(b'', None)\n    \nTestRemoveBitstring().test_empty_string()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The remove_bitstring function is designed to extract a BIT STRING object from a provided byte string, adhering to the DER (Distinguished Encoding Rules) encoding standard. This function is capable of validating the number of unused bits in the bit string if an expectation is specified.\n\nInputs: \n- string: A bytes-like object representing the encapsulated DER-encoded bit string from which the BIT STRING needs to be extracted.\n- expect_unused (optional): An integer specifying the number of bits that should be unused in the BIT STRING. If None, the function returns the number of unused bits along with the bit string. If unspecified, the bit string is returned as-is without decoding the unused bits.\n\nOutputs: \n- A tuple where the first element is the extracted bit string (and potentially a tuple containing the bit string and the number of unused bits if expect_unused is None), and the second element is the remaining bytes in the input string that were not part of the BIT STRING. The exact structure of the returned tuple depends on the value provided for the expect_unused parameter.", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\n_sentry = object()\n\n\ndef remove_bitstring(string, expect_unused=_sentry): [MASK]\n"}
{"method_name": "str_idx_as_int", "full_method_name": "str_idx_as_int", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/_compat.py", "method_code": "import sys\nimport re\nimport binascii\nfrom six import integer_types\nimport platform\ndef str_idx_as_int(string, index):\n    \"\"\"Take index'th byte from string, return as integer\"\"\"\n    val = string[index]\n    if isinstance(val, integer_types):\n        return val\n    return ord(val)", "test_code_list": [{"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestStrIdxAsInt(unittest.TestCase):\n    def test_str(self):\n        self.assertEqual(115, str_idx_as_int('str', 0))\n    \nTestStrIdxAsInt().test_str()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestStrIdxAsInt(unittest.TestCase):\n    def test_bytes(self):\n        self.assertEqual(115, str_idx_as_int(b'str', 0))\n    \nTestStrIdxAsInt().test_bytes()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}, {"test_code": "import warnings\nfrom binascii import hexlify\nimport unittest\nimport sys\nimport pytest\n\nclass TestStrIdxAsInt(unittest.TestCase):\n    def test_bytearray(self):\n        self.assertEqual(115, str_idx_as_int(bytearray(b'str'), 0))\n    \nTestStrIdxAsInt().test_bytearray()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/test_der.py"}], "instruction": "Functionality: The function str_idx_as_int is designed to extract the byte at a specified index from a given string and return its integer representation. This is particularly useful for dealing with byte strings where individual bytes need to be accessed and manipulated as integers.\n\nInputs: The function accepts two arguments:\n1. string: A string or byte string from which a byte will be extracted.\n2. index: An integer representing the position of the byte to be extracted from the string.\n\nOutputs: The function returns an integer. This integer is the numerical representation of the byte located at the specified index within the input string. If the byte at the given index is already an integer (in the context of the Python version being used), the function simply returns the value. Otherwise, it uses the ord() function to convert the character at the given index into its integer representation.", "method_code_mask": "import sys\nimport re\nimport binascii\nfrom six import integer_types\nimport platform\n\n\ndef str_idx_as_int(string, index): [MASK]\n"}
