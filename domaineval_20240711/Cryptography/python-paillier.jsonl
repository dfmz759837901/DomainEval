{"method_name": "powmod", "full_method_name": "powmod", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n_USE_MOD_FROM_GMP_SIZE = 1 << 8 * 2\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\ndef powmod(a, b, c):\n    \"\"\"\n    Uses GMP, if available, to do a^b mod c where a, b, c\n    are integers.\n    :return int: (a ** b) % c\n    \"\"\"\n    if a == 1:\n        return 1\n    if not HAVE_GMP or max(a, b, c) < _USE_MOD_FROM_GMP_SIZE:\n        return pow(a, b, c)\n    else:\n        return int(gmpy2.powmod(a, b, c))", "test_code_list": [{"test_code": "import unittest\nimport random\nimport math\nfrom math import gcd\n\nclass PaillierUtilTest(unittest.TestCase):\n    def testPowMod(self):\n        self.assertEqual(powmod(5, 3, 3), 2)\n        self.assertEqual(powmod(2, 10, 1000), 24)\n    \nPaillierUtilTest().testPowMod()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-paillier/phe/tests/util_test.py"}], "instruction": "Functionality: The powmod function computes the modular exponentiation of a base raised to a given exponent under a specified modulus. This operation is represented as (a^b) mod c, where 'a' is the base, 'b' is the exponent, and 'c' is the modulus. The function is designed to handle large numbers efficiently by using the GMP library when available, falling back to Python's built-in pow function for smaller numbers.\n\nInputs: \n- a (integer): The base of the modular exponentiation.\n- b (integer): The exponent to raise the base 'a' to.\n- c (integer): The modulus to perform the operation under.\n\nOutputs:\n- int: The result of (a^b) mod c. This is the modular exponentiation of 'a' raised to the power of 'b', modulo 'c'.", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n_USE_MOD_FROM_GMP_SIZE = 1 << 8 * 2\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\n\n\ndef powmod(a, b, c): [MASK]\n"}
{"method_name": "invert", "full_method_name": "invert", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\ndef invert(a, b):\n    \"\"\"\n    The multiplicitive inverse of a in the integers modulo b.\n    :return int: x, where a * x == 1 mod b\n    \"\"\"\n    if HAVE_GMP:\n        s = int(gmpy2.invert(a, b))\n        if s == 0:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s\n    else:\n        r, s, _ = extended_euclidean_algorithm(a, b)\n        if r != 1:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s % b", "test_code_list": [{"test_code": "import unittest\nimport random\nimport math\nfrom math import gcd\n\nclass PaillierUtilTest(unittest.TestCase):\n    def testInvert(self):\n        p = 101\n        for i in range(1, p):\n            iinv = invert(i, p)\n            self.assertEqual(iinv * i % p, 1)\n    \nPaillierUtilTest().testInvert()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-paillier/phe/tests/util_test.py"}, {"test_code": "import unittest\nimport random\nimport math\nfrom math import gcd\n\nclass PaillierUtilTest(unittest.TestCase):\n    def testInvertNonPrime(self):\n        a = 3\n        p = 4\n        self.assertEqual(a * invert(a, p) % p, 1)\n    \nPaillierUtilTest().testInvertNonPrime()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-paillier/phe/tests/util_test.py"}], "instruction": "Functionality: The invert function computes the multiplicative inverse of a given integer 'a' in the integers modulo 'b'. This means it finds an integer 'x' such that the product of 'a' and 'x' is congruent to 1 modulo 'b'. The function utilizes the extended Euclidean algorithm to find the inverse and checks for the condition where the gcd of 'a' and 'b' is not 1, which means the inverse does not exist.\n\nInputs: \n- a: An integer for which the multiplicative inverse is to be found.\n- b: The modulus, an integer defining the set of integers modulo 'b'.\n\nOutputs: \n- Returns an integer 'x', which is the multiplicative inverse of 'a' modulo 'b', such that a * x \u2261 1 (mod b).\n- If the inverse does not exist (i.e., 'a' and 'b' are not coprime), the function raises a ZeroDivisionError with the message 'invert() no inverse exists'.", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\n\n\ndef invert(a, b): [MASK]\n"}
{"method_name": "extended_euclidean_algorithm", "full_method_name": "extended_euclidean_algorithm", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ndef extended_euclidean_algorithm(a, b):\n    \"\"\"Extended Euclidean algorithm\n\n    Returns r, s, t such that r = s*a + t*b and r is gcd(a, b)\n\n    See <https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm>\n    \"\"\"\n    r0, r1 = a, b\n    s0, s1 = 1, 0\n    t0, t1 = 0, 1\n    while r1 != 0:\n        q = r0 // r1\n        r0, r1 = r1, r0 - q * r1\n        s0, s1 = s1, s0 - q * s1\n        t0, t1 = t1, t0 - q * t1\n    return r0, s0, t0", "test_code_list": [{"test_code": "import unittest\nimport random\nimport math\nfrom math import gcd\nclass PaillierUtilTest(unittest.TestCase):\n\n    def testPowMod(self):\n        self.assertEqual(util.powmod(5, 3, 3), 2)\n        self.assertEqual(util.powmod(2, 10, 1000), 24)\n\n    def testInvert(self):\n        p = 101\n        for i in range(1, p):\n            iinv = util.invert(i, p)\n            self.assertEqual(iinv * i % p, 1)\n\n    def testInvertNonPrime(self):\n        a = 3\n        p = 4\n        self.assertEqual(a * util.invert(a, p) % p, 1)\n\n    def testPrimeOverN(self):\n        self.assertIn(util.getprimeover(3), {5, 7, 11, 13})\n        for n in range(2, 50):\n            p = util.getprimeover(n)\n            self.assertGreaterEqual(p, 1 << n - 1)\n\n    def testIsqrt(self):\n        for _ in range(100):\n            n = random.randint(2, 10000000)\n            nsq = n * n\n            self.assertEqual(int(math.floor(math.sqrt(n))), util.isqrt(n))\n            self.assertEqual(util.isqrt(nsq), util.improved_i_sqrt(nsq))\n\nclass PaillierUtilFallbacksTest(PaillierUtilTest):\n    def testExtendedEuclieanAlgorithm(self):\n        self.assertEqual(extended_euclidean_algorithm(240, 46), (2, -9, 47))\n        for a, b in [(77, 99), (45, 127)]:\n            r, s, t = extended_euclidean_algorithm(a, b)\n            self.assertEqual(r, s * a + t * b)\n            self.assertEqual(r, gcd(a, b))\n    \nPaillierUtilFallbacksTest().testExtendedEuclieanAlgorithm()\n", "code_start": "", "test_path": "../srcdata/Cryptography/python-paillier/phe/tests/util_test.py"}], "instruction": "Functionality: The extended_euclidean_algorithm function implements the Extended Euclidean Algorithm. This algorithm is used to find the greatest common divisor (GCD) of two numbers, a and b, along with the coefficients s and t that satisfy the equation: r = s*a + t*b, where r is the GCD of a and b.\n\nInputs: \n- a: An integer, one of the numbers for which the GCD is to be found.\n- b: An integer, the other number for which the GCD is to be found.\n\nOutputs: \n- A tuple containing three values:\n  - r: The greatest common divisor of a and b.\n  - s: The coefficient for a in the equation r = s*a + t*b.\n  - t: The coefficient for b in the equation r = s*a + t*b.", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n\n\ndef extended_euclidean_algorithm(a, b): [MASK]\n"}
