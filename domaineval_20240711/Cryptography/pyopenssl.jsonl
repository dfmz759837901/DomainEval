{"method_name": "x509_name", "full_method_name": "x509_name", "method_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py", "method_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\ndef x509_name(**attrs):\n    \"\"\"\n    Return a new X509Name with the given attributes.\n    \"\"\"\n    name = X509().get_subject()\n    attrs = list(attrs.items())\n\n    def key(attr):\n        return attr[1]\n    attrs.sort(key=key)\n    for k, v in attrs:\n        setattr(name, k, v)\n    return name", "test_code_list": [{"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_type(self):\n        \"\"\"\n            The type of X509Name objects is `X509Name`.\n            \"\"\"\n        name = x509_name()\n        assert isinstance(name, X509Name)\n    \nTestX509Name().test_type()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_attributes(self):\n        \"\"\"\n            `X509Name` instances have attributes for each standard (?)\n            X509Name field.\n            \"\"\"\n        name = x509_name()\n        name.commonName = 'foo'\n        assert name.commonName == 'foo'\n        assert name.CN == 'foo'\n        name.CN = 'baz'\n        assert name.commonName == 'baz'\n        assert name.CN == 'baz'\n        name.commonName = 'bar'\n        assert name.commonName == 'bar'\n        assert name.CN == 'bar'\n        name.CN = 'quux'\n        assert name.commonName == 'quux'\n        assert name.CN == 'quux'\n        assert name.OU is None\n        with pytest.raises(AttributeError):\n            name.foobar\n    \nTestX509Name().test_attributes()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_copy(self):\n        \"\"\"\n            `X509Name` creates a new `X509Name` instance with all the same\n            attributes as an existing `X509Name` instance when called with one.\n            \"\"\"\n        name = x509_name(commonName='foo', emailAddress='bar@example.com')\n        copy = X509Name(name)\n        assert copy.commonName == 'foo'\n        assert copy.emailAddress == 'bar@example.com'\n        copy.commonName = 'baz'\n        assert name.commonName == 'foo'\n        name.emailAddress = 'quux@example.com'\n        assert copy.emailAddress == 'bar@example.com'\n    \nTestX509Name().test_copy()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_repr(self):\n        \"\"\"\n            `repr` passed an `X509Name` instance should return a string containing\n            a description of the type and the NIDs which have been set on it.\n            \"\"\"\n        name = x509_name(commonName='foo', emailAddress='bar')\n        assert repr(name) == \"<X509Name object '/emailAddress=bar/CN=foo'>\"\n    \nTestX509Name().test_repr()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_comparison(self):\n        \"\"\"\n            `X509Name` instances should compare based on their NIDs.\n            \"\"\"\n    \n        def _equality(a, b, assert_true, assert_false):\n            assert_true(a == b)\n            assert_false(a != b)\n            assert_true(b == a)\n            assert_false(b != a)\n    \n        def assert_true(x):\n            assert x\n    \n        def assert_false(x):\n            assert not x\n    \n        def assert_equal(a, b):\n            _equality(a, b, assert_true, assert_false)\n        name = x509_name()\n        assert_equal(name, name)\n        assert_equal(x509_name(), x509_name())\n        assert_equal(x509_name(commonName='foo'), x509_name(commonName='foo'))\n        assert_equal(x509_name(commonName='foo'), x509_name(CN='foo'))\n        assert_equal(x509_name(CN='foo', organizationalUnitName='bar'),\n            x509_name(commonName='foo', OU='bar'))\n    \n        def assert_not_equal(a, b):\n            _equality(a, b, assert_false, assert_true)\n        assert_not_equal(x509_name(CN='foo'), x509_name(CN='bar'))\n        assert_not_equal(x509_name(CN='foo'), x509_name(OU='foo'))\n        assert_not_equal(x509_name(), object())\n    \n        def _inequality(a, b, assert_true, assert_false):\n            assert_true(a < b)\n            assert_true(a <= b)\n            assert_true(b > a)\n            assert_true(b >= a)\n            assert_false(a > b)\n            assert_false(a >= b)\n            assert_false(b < a)\n            assert_false(b <= a)\n    \n        def assert_less_than(a, b):\n            _inequality(a, b, assert_true, assert_false)\n        assert_less_than(x509_name(CN='abc'), x509_name(CN='def'))\n    \n        def assert_greater_than(a, b):\n            _inequality(a, b, assert_false, assert_true)\n        assert_greater_than(x509_name(CN='def'), x509_name(CN='abc'))\n    \n        def assert_raises(a, b):\n            with pytest.raises(TypeError):\n                a < b\n            with pytest.raises(TypeError):\n                a <= b\n            with pytest.raises(TypeError):\n                a > b\n            with pytest.raises(TypeError):\n                a >= b\n        assert_raises(x509_name(), object())\n    \nTestX509Name().test_comparison()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_hash(self):\n        \"\"\"\n            `X509Name.hash` returns an integer hash based on the value of the name.\n            \"\"\"\n        a = x509_name(CN='foo')\n        b = x509_name(CN='foo')\n        assert a.hash() == b.hash()\n        a.CN = 'bar'\n        assert a.hash() != b.hash()\n    \nTestX509Name().test_hash()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_der(self):\n        \"\"\"\n            `X509Name.der` returns the DER encoded form of the name.\n            \"\"\"\n        a = x509_name(CN='foo', C='US')\n        assert a.der(\n            ) == b'0\\x1b1\\x0b0\\t\\x06\\x03U\\x04\\x06\\x13\\x02US1\\x0c0\\n\\x06\\x03U\\x04\\x03\\x0c\\x03foo'\n    \nTestX509Name().test_der()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}, {"test_code": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\nclass TestX509Name():\n    def test_get_components(self):\n        \"\"\"\n            `X509Name.get_components` returns a `list` of two-tuples of `str`\n            giving the NIDs and associated values which make up the name.\n            \"\"\"\n        a = x509_name()\n        assert a.get_components() == []\n        a.CN = 'foo'\n        assert a.get_components() == [(b'CN', b'foo')]\n        a.organizationalUnitName = 'bar'\n        assert a.get_components() == [(b'CN', b'foo'), (b'OU', b'bar')]\n    \nTestX509Name().test_get_components()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_crypto.py"}], "instruction": "Functionality: The function x509_name creates a new X509Name object, which is used to represent the subject or issuer of an X.509 certificate. This function allows for the setting of various attributes that are commonly found in X509 certificates, such as Common Name (CN), Organization (O), Organizational Unit (OU), Locality (L), State or Province (ST), Country (C), and others, which are important for identifying entities within a Public Key Infrastructure (PKI).\n\nInputs: \n    - **attrs**: This parameter is a dictionary where the keys are strings representing the attribute names (e.g., 'C', 'ST', 'L', 'O', 'OU', 'CN'), and the values are strings representing the attribute values. The attributes are sorted by their values before being set on the X509Name object.\n\nOutputs:\n    - Returns a new X509Name object with the specified attributes set. This object can then be used to create X.509 certificates.\n\nNote: The function does not perform any validation of the input attributes, so invalid attribute names or values may result in unexpected behavior or errors.", "method_code_mask": "import base64\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom subprocess import PIPE\nfrom subprocess import Popen\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import ed448\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_ASN1\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import FILETYPE_TEXT\nfrom OpenSSL.crypto import TYPE_DSA\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import Error\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Name\nfrom OpenSSL.crypto import X509Req\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import X509StoreContext\nfrom OpenSSL.crypto import X509StoreContextError\nfrom OpenSSL.crypto import X509StoreFlags\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_certificate_request\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import dump_publickey\nfrom OpenSSL.crypto import get_elliptic_curve\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_certificate_request\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import load_publickey\nfrom OpenSSL.crypto import sign\nfrom OpenSSL.crypto import verify\nfrom OpenSSL.crypto import CRL\nfrom OpenSSL.crypto import Revoked\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.crypto import dump_crl\nfrom OpenSSL.crypto import load_crl\nfrom cryptography.x509.extensions import CRLReason\nfrom cryptography.x509.extensions import ReasonFlags\n\n\ndef x509_name(**attrs): [MASK]\n"}
{"method_name": "socket_any_family", "full_method_name": "socket_any_family", "method_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py", "method_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef socket_any_family():\n    try:\n        return socket(AF_INET)\n    except OSError as e:\n        if e.errno == EAFNOSUPPORT:\n            return socket(AF_INET6)\n        raise", "test_code_list": [{"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef loopback_address(socket):\n    if socket.family == AF_INET:\n        return '127.0.0.1'\n    else:\n        assert socket.family == AF_INET6\n        return '::1'\ndef socket_pair():\n    \"\"\"\n    Establish and return a pair of network sockets connected to each other.\n    \"\"\"\n    port = socket_any_family()\n    port.bind(('', 0))\n    port.listen(1)\n    client = socket(port.family)\n    client.setblocking(False)\n    client.connect_ex((loopback_address(port), port.getsockname()[1]))\n    client.setblocking(True)\n    server = port.accept()[0]\n    port.close()\n    server.send(b'x')\n    assert client.recv(1024) == b'x'\n    client.send(b'y')\n    assert server.recv(1024) == b'y'\n    server.setblocking(False)\n    client.setblocking(False)\n    return server, client\nsocket_pair()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef loopback_address(socket):\n    if socket.family == AF_INET:\n        return '127.0.0.1'\n    else:\n        assert socket.family == AF_INET6\n        return '::1'\nclass TestConnection():\n    def test_connect_refused(self):\n        \"\"\"\n            `Connection.connect` raises `socket.error` if the underlying socket\n            connect method raises it.\n            \"\"\"\n        client = socket_any_family()\n        context = Context(SSLv23_METHOD)\n        clientSSL = Connection(context, client)\n        try:\n            clientSSL.connect((loopback_address(client), 1))\n        except OSError as e:\n            exc = e\n        assert exc.args[0] == ECONNREFUSED\nTestConnection().test_connect_refused()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\nclass TestConnection():\n    def test_connect_ex(self):\n        \"\"\"\n            If there is a connection error, `Connection.connect_ex` returns the\n            errno instead of raising an exception.\n            \"\"\"\n        port = socket_any_family()\n        port.bind(('', 0))\n        port.listen(3)\n        clientSSL = Connection(Context(SSLv23_METHOD), socket(port.family))\n        clientSSL.setblocking(False)\n        result = clientSSL.connect_ex(port.getsockname())\n        expected = EINPROGRESS, EWOULDBLOCK\n        assert result in expected\n    \nTestConnection().test_connect_ex()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\nclass TestConnection():\n    def test_set_shutdown(self):\n        \"\"\"\n            `Connection.set_shutdown` sets the state of the SSL connection\n            shutdown process.\n            \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), socket_any_family())\n        connection.set_shutdown(RECEIVED_SHUTDOWN)\n        assert connection.get_shutdown() == RECEIVED_SHUTDOWN\n    \nTestConnection().test_set_shutdown()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}], "instruction": "Functionality: The function socket_any_family aims to create a socket that can be used for network communication. It attempts to initialize a socket using the AF_INET address family, which is typically used for IPv4 addresses. If the creation of an AF_INET socket fails due to the system not supporting this address family (indicated by the error code EAFNOSUPPORT), the function will then attempt to create a socket using the AF_INET6 address family, which is suitable for IPv6 addresses. If neither address family is supported by the system, the function will propagate the exception.\n\nInputs: The function does not take any input arguments. It is designed to autonomously determine the best family for the socket based on system support.\n\nOutputs: The function returns a socket object that can be used for network communication. The specific address family (AF_INET or AF_INET6) of the returned socket will depend on the system's capabilities. If the system does not support either address family, the function will raise an OSError with an appropriate error message.", "method_code_mask": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\n\ndef socket_any_family(): [MASK]\n"}
{"method_name": "interact_in_memory", "full_method_name": "interact_in_memory", "method_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py", "method_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef interact_in_memory(client_conn, server_conn):\n    \"\"\"\n    Try to read application bytes from each of the two `Connection` objects.\n    Copy bytes back and forth between their send/receive buffers for as long\n    as there is anything to copy.  When there is nothing more to copy,\n    return `None`.  If one of them actually manages to deliver some application\n    bytes, return a two-tuple of the connection from which the bytes were read\n    and the bytes themselves.\n    \"\"\"\n    wrote = True\n    while wrote:\n        wrote = False\n        for read, write in [(client_conn, server_conn), (server_conn,\n            client_conn)]:\n            try:\n                data = read.recv(2 ** 16)\n            except WantReadError:\n                pass\n            else:\n                return read, data\n            while True:\n                try:\n                    dirty = read.bio_read(4096)\n                except WantReadError:\n                    break\n                else:\n                    wrote = True\n                    write.bio_write(dirty)", "test_code_list": [{"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef verify_cb(conn, cert, errnum, depth, ok):\n    return ok\ndef _create_certificate_chain():\n    \"\"\"\n    Construct and return a chain of certificates.\n        1. A new self-signed certificate authority certificate (cacert)\n        2. A new intermediate certificate signed by cacert (icert)\n        3. A new server certificate signed by icert (scert)\n    \"\"\"\n    caext = X509Extension(b'basicConstraints', False, b'CA:true')\n    not_after_date = datetime.date.today() + datetime.timedelta(days=365)\n    not_after = not_after_date.strftime('%Y%m%d%H%M%SZ').encode('ascii')\n    cakey = PKey()\n    cakey.generate_key(TYPE_RSA, 2048)\n    cacert = X509()\n    cacert.set_version(2)\n    cacert.get_subject().commonName = 'Authority Certificate'\n    cacert.set_issuer(cacert.get_subject())\n    cacert.set_pubkey(cakey)\n    cacert.set_notBefore(b'20000101000000Z')\n    cacert.set_notAfter(not_after)\n    cacert.add_extensions([caext])\n    cacert.set_serial_number(0)\n    cacert.sign(cakey, 'sha256')\n    ikey = PKey()\n    ikey.generate_key(TYPE_RSA, 2048)\n    icert = X509()\n    icert.set_version(2)\n    icert.get_subject().commonName = 'Intermediate Certificate'\n    icert.set_issuer(cacert.get_subject())\n    icert.set_pubkey(ikey)\n    icert.set_notBefore(b'20000101000000Z')\n    icert.set_notAfter(not_after)\n    icert.add_extensions([caext])\n    icert.set_serial_number(0)\n    icert.sign(cakey, 'sha256')\n    skey = PKey()\n    skey.generate_key(TYPE_RSA, 2048)\n    scert = X509()\n    scert.set_version(2)\n    scert.get_subject().commonName = 'Server Certificate'\n    scert.set_issuer(icert.get_subject())\n    scert.set_pubkey(skey)\n    scert.set_notBefore(b'20000101000000Z')\n    scert.set_notAfter(not_after)\n    scert.add_extensions([X509Extension(b'basicConstraints', True,\n        b'CA:false')])\n    scert.set_serial_number(0)\n    scert.sign(ikey, 'sha256')\n    return [(cakey, cacert), (ikey, icert), (skey, scert)]\nclass TestConnection():\n    def test_get_peer_cert_chain(self):\n        \"\"\"\n            `Connection.get_peer_cert_chain` returns a list of certificates\n            which the connected server returned for the certification verification.\n            \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(VERIFY_NONE, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        chain = client.get_peer_cert_chain()\n        assert len(chain) == 3\n        assert 'Server Certificate' == chain[0].get_subject().CN\n        assert 'Intermediate Certificate' == chain[1].get_subject().CN\n        assert 'Authority Certificate' == chain[2].get_subject().CN\nTestConnection().test_get_peer_cert_chain()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef verify_cb(conn, cert, errnum, depth, ok):\n    return ok\ndef _create_certificate_chain():\n    \"\"\"\n    Construct and return a chain of certificates.\n        1. A new self-signed certificate authority certificate (cacert)\n        2. A new intermediate certificate signed by cacert (icert)\n        3. A new server certificate signed by icert (scert)\n    \"\"\"\n    caext = X509Extension(b'basicConstraints', False, b'CA:true')\n    not_after_date = datetime.date.today() + datetime.timedelta(days=365)\n    not_after = not_after_date.strftime('%Y%m%d%H%M%SZ').encode('ascii')\n    cakey = PKey()\n    cakey.generate_key(TYPE_RSA, 2048)\n    cacert = X509()\n    cacert.set_version(2)\n    cacert.get_subject().commonName = 'Authority Certificate'\n    cacert.set_issuer(cacert.get_subject())\n    cacert.set_pubkey(cakey)\n    cacert.set_notBefore(b'20000101000000Z')\n    cacert.set_notAfter(not_after)\n    cacert.add_extensions([caext])\n    cacert.set_serial_number(0)\n    cacert.sign(cakey, 'sha256')\n    ikey = PKey()\n    ikey.generate_key(TYPE_RSA, 2048)\n    icert = X509()\n    icert.set_version(2)\n    icert.get_subject().commonName = 'Intermediate Certificate'\n    icert.set_issuer(cacert.get_subject())\n    icert.set_pubkey(ikey)\n    icert.set_notBefore(b'20000101000000Z')\n    icert.set_notAfter(not_after)\n    icert.add_extensions([caext])\n    icert.set_serial_number(0)\n    icert.sign(cakey, 'sha256')\n    skey = PKey()\n    skey.generate_key(TYPE_RSA, 2048)\n    scert = X509()\n    scert.set_version(2)\n    scert.get_subject().commonName = 'Server Certificate'\n    scert.set_issuer(icert.get_subject())\n    scert.set_pubkey(skey)\n    scert.set_notBefore(b'20000101000000Z')\n    scert.set_notAfter(not_after)\n    scert.add_extensions([X509Extension(b'basicConstraints', True,\n        b'CA:false')])\n    scert.set_serial_number(0)\n    scert.sign(ikey, 'sha256')\n    return [(cakey, cacert), (ikey, icert), (skey, scert)]\nclass TestConnection():\n    def test_get_verified_chain(self):\n        \"\"\"\n            `Connection.get_verified_chain` returns a list of certificates\n            which the connected server returned for the certification verification.\n            \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.get_cert_store().add_cert(cacert)\n        clientContext.set_verify(VERIFY_PEER, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        chain = client.get_verified_chain()\n        assert len(chain) == 3\n        assert 'Server Certificate' == chain[0].get_subject().CN\n        assert 'Intermediate Certificate' == chain[1].get_subject().CN\n        assert 'Authority Certificate' == chain[2].get_subject().CN\nTestConnection().test_get_verified_chain()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}], "instruction": "Functionality: The interact_in_memory function is designed to facilitate communication between two OpenSSL SSL/TLS Connection objects, client_conn and server_conn, by copying data back and forth between their send and receive buffers. It reads application bytes from each connection, copies the data between them, and continues the process until there is nothing more to copy. If one of the connections manages to deliver application bytes, the function returns a tuple containing the connection from which the bytes were read and the bytes themselves. If no bytes are delivered after all possible copying is done, the function returns None.\n\nInputs: \n- client_conn: An instance of the OpenSSL SSL/TLS Connection object representing the client side of the connection.\n- server_conn: An instance of the OpenSSL SSL/TLS Connection object representing the server side of the connection.\n\nOutputs: \n- None: If no application bytes are delivered after all possible data has been copied between the connections.\n- Tuple: A two-element tuple containing the connection from which the bytes were read and the bytes themselves, if an application delivers bytes.", "method_code_mask": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\n\ndef interact_in_memory(client_conn, server_conn): [MASK]\n"}
{"method_name": "_create_certificate_chain", "full_method_name": "_create_certificate_chain", "method_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py", "method_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef _create_certificate_chain():\n    \"\"\"\n    Construct and return a chain of certificates.\n\n        1. A new self-signed certificate authority certificate (cacert)\n        2. A new intermediate certificate signed by cacert (icert)\n        3. A new server certificate signed by icert (scert)\n    \"\"\"\n    caext = X509Extension(b'basicConstraints', False, b'CA:true')\n    not_after_date = datetime.date.today() + datetime.timedelta(days=365)\n    not_after = not_after_date.strftime('%Y%m%d%H%M%SZ').encode('ascii')\n    cakey = PKey()\n    cakey.generate_key(TYPE_RSA, 2048)\n    cacert = X509()\n    cacert.set_version(2)\n    cacert.get_subject().commonName = 'Authority Certificate'\n    cacert.set_issuer(cacert.get_subject())\n    cacert.set_pubkey(cakey)\n    cacert.set_notBefore(b'20000101000000Z')\n    cacert.set_notAfter(not_after)\n    cacert.add_extensions([caext])\n    cacert.set_serial_number(0)\n    cacert.sign(cakey, 'sha256')\n    ikey = PKey()\n    ikey.generate_key(TYPE_RSA, 2048)\n    icert = X509()\n    icert.set_version(2)\n    icert.get_subject().commonName = 'Intermediate Certificate'\n    icert.set_issuer(cacert.get_subject())\n    icert.set_pubkey(ikey)\n    icert.set_notBefore(b'20000101000000Z')\n    icert.set_notAfter(not_after)\n    icert.add_extensions([caext])\n    icert.set_serial_number(0)\n    icert.sign(cakey, 'sha256')\n    skey = PKey()\n    skey.generate_key(TYPE_RSA, 2048)\n    scert = X509()\n    scert.set_version(2)\n    scert.get_subject().commonName = 'Server Certificate'\n    scert.set_issuer(icert.get_subject())\n    scert.set_pubkey(skey)\n    scert.set_notBefore(b'20000101000000Z')\n    scert.set_notAfter(not_after)\n    scert.add_extensions([X509Extension(b'basicConstraints', True,\n        b'CA:false')])\n    scert.set_serial_number(0)\n    scert.sign(ikey, 'sha256')\n    return [(cakey, cacert), (ikey, icert), (skey, scert)]", "test_code_list": [{"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\nclass TestConnection():\n    def test_get_certificate(self):\n        \"\"\"\n            `Connection.get_certificate` returns the local certificate.\n            \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n        context = Context(SSLv23_METHOD)\n        context.use_certificate(scert)\n        client = Connection(context, None)\n        cert = client.get_certificate()\n        assert cert is not None\n        assert 'Server Certificate' == cert.get_subject().CN\n    \nTestConnection().test_get_certificate()\n", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef interact_in_memory(client_conn, server_conn):\n    \"\"\"\n    Try to read application bytes from each of the two `Connection` objects.\n    Copy bytes back and forth between their send/receive buffers for as long\n    as there is anything to copy.  When there is nothing more to copy,\n    return `None`.  If one of them actually manages to deliver some application\n    bytes, return a two-tuple of the connection from which the bytes were read\n    and the bytes themselves.\n    \"\"\"\n    wrote = True\n    while wrote:\n        wrote = False\n        for read, write in [(client_conn, server_conn), (server_conn,\n            client_conn)]:\n            try:\n                data = read.recv(2 ** 16)\n            except WantReadError:\n                pass\n            else:\n                return read, data\n            while True:\n                try:\n                    dirty = read.bio_read(4096)\n                except WantReadError:\n                    break\n                else:\n                    wrote = True\n                    write.bio_write(dirty)\ndef verify_cb(conn, cert, errnum, depth, ok):\n    return ok\nclass TestConnection():\n    def test_get_peer_cert_chain(self):\n        \"\"\"\n            `Connection.get_peer_cert_chain` returns a list of certificates\n            which the connected server returned for the certification verification.\n            \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(VERIFY_NONE, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        chain = client.get_peer_cert_chain()\n        assert len(chain) == 3\n        assert 'Server Certificate' == chain[0].get_subject().CN\n        assert 'Intermediate Certificate' == chain[1].get_subject().CN\n        assert 'Authority Certificate' == chain[2].get_subject().CN\nTestConnection().test_get_peer_cert_chain()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}, {"test_code": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\ndef interact_in_memory(client_conn, server_conn):\n    \"\"\"\n    Try to read application bytes from each of the two `Connection` objects.\n    Copy bytes back and forth between their send/receive buffers for as long\n    as there is anything to copy.  When there is nothing more to copy,\n    return `None`.  If one of them actually manages to deliver some application\n    bytes, return a two-tuple of the connection from which the bytes were read\n    and the bytes themselves.\n    \"\"\"\n    wrote = True\n    while wrote:\n        wrote = False\n        for read, write in [(client_conn, server_conn), (server_conn,\n            client_conn)]:\n            try:\n                data = read.recv(2 ** 16)\n            except WantReadError:\n                pass\n            else:\n                return read, data\n            while True:\n                try:\n                    dirty = read.bio_read(4096)\n                except WantReadError:\n                    break\n                else:\n                    wrote = True\n                    write.bio_write(dirty)\ndef verify_cb(conn, cert, errnum, depth, ok):\n    return ok\nclass TestConnection():\n    def test_get_verified_chain(self):\n        \"\"\"\n            `Connection.get_verified_chain` returns a list of certificates\n            which the connected server returned for the certification verification.\n            \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.get_cert_store().add_cert(cacert)\n        clientContext.set_verify(VERIFY_PEER, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        chain = client.get_verified_chain()\n        assert len(chain) == 3\n        assert 'Server Certificate' == chain[0].get_subject().CN\n        assert 'Intermediate Certificate' == chain[1].get_subject().CN\n        assert 'Authority Certificate' == chain[2].get_subject().CN\nTestConnection().test_get_verified_chain()", "code_start": "", "test_path": "../srcdata/Cryptography/pyopenssl/tests/test_ssl.py"}], "instruction": "Functionality: The function _create_certificate_chain is designed to construct and return a chain of digital certificates used for SSL/TLS security. This chain consists of three main components:\n1. A self-signed certificate authority certificate (cacert).\n2. An intermediate certificate signed by cacert (icert).\n3. A server certificate signed by icert (scert).\nThe function generates these certificates using OpenSSL's X509 and PKey classes, sets their subjects, issuers, public keys, validity dates, and signs them with SHA256.\n\nInputs: The function does not take any input arguments. It generates all required data internally.\n\nOutputs: The function returns a tuple of tuples, each containing a private key and its corresponding certificate. The structure of the output is [(cakey, cacert), (ikey, icert), (skey, scert)], where:\n- cakey and cacert represent the private key and certificate of the certificate authority.\n- ikey and icert represent the private key and certificate of the intermediate certificate.\n- skey and scert represent the private key and certificate of the server certificate.", "method_code_mask": "import datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import EAFNOSUPPORT\nfrom errno import ECONNREFUSED\nfrom errno import EINPROGRESS\nfrom errno import EPIPE\nfrom errno import ESHUTDOWN\nfrom errno import EWOULDBLOCK\nfrom gc import collect\nfrom gc import get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import MSG_PEEK\nfrom socket import SHUT_RDWR\nfrom socket import gaierror\nfrom socket import socket\nfrom sys import getfilesystemencoding\nfrom sys import platform\nfrom typing import Union\nfrom weakref import ref\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import FILETYPE_PEM\nfrom OpenSSL.crypto import TYPE_RSA\nfrom OpenSSL.crypto import X509\nfrom OpenSSL.crypto import PKey\nfrom OpenSSL.crypto import X509Store\nfrom OpenSSL.crypto import dump_certificate\nfrom OpenSSL.crypto import dump_privatekey\nfrom OpenSSL.crypto import get_elliptic_curves\nfrom OpenSSL.crypto import load_certificate\nfrom OpenSSL.crypto import load_privatekey\nfrom OpenSSL.crypto import X509Extension\nfrom OpenSSL.SSL import DTLS_METHOD\nfrom OpenSSL.SSL import MODE_RELEASE_BUFFERS\nfrom OpenSSL.SSL import NO_OVERLAPPING_PROTOCOLS\nfrom OpenSSL.SSL import OP_COOKIE_EXCHANGE\nfrom OpenSSL.SSL import OP_NO_COMPRESSION\nfrom OpenSSL.SSL import OP_NO_QUERY_MTU\nfrom OpenSSL.SSL import OP_NO_TICKET\nfrom OpenSSL.SSL import OP_SINGLE_DH_USE\nfrom OpenSSL.SSL import OPENSSL_VERSION_NUMBER\nfrom OpenSSL.SSL import RECEIVED_SHUTDOWN\nfrom OpenSSL.SSL import SENT_SHUTDOWN\nfrom OpenSSL.SSL import SESS_CACHE_BOTH\nfrom OpenSSL.SSL import SESS_CACHE_CLIENT\nfrom OpenSSL.SSL import SESS_CACHE_NO_AUTO_CLEAR\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_LOOKUP\nfrom OpenSSL.SSL import SESS_CACHE_NO_INTERNAL_STORE\nfrom OpenSSL.SSL import SESS_CACHE_OFF\nfrom OpenSSL.SSL import SESS_CACHE_SERVER\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_EXIT\nfrom OpenSSL.SSL import SSL_CB_ACCEPT_LOOP\nfrom OpenSSL.SSL import SSL_CB_ALERT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_EXIT\nfrom OpenSSL.SSL import SSL_CB_CONNECT_LOOP\nfrom OpenSSL.SSL import SSL_CB_EXIT\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE\nfrom OpenSSL.SSL import SSL_CB_HANDSHAKE_START\nfrom OpenSSL.SSL import SSL_CB_LOOP\nfrom OpenSSL.SSL import SSL_CB_READ\nfrom OpenSSL.SSL import SSL_CB_READ_ALERT\nfrom OpenSSL.SSL import SSL_CB_WRITE\nfrom OpenSSL.SSL import SSL_CB_WRITE_ALERT\nfrom OpenSSL.SSL import SSL_ST_ACCEPT\nfrom OpenSSL.SSL import SSL_ST_CONNECT\nfrom OpenSSL.SSL import SSL_ST_MASK\nfrom OpenSSL.SSL import SSLEAY_BUILT_ON\nfrom OpenSSL.SSL import SSLEAY_CFLAGS\nfrom OpenSSL.SSL import SSLEAY_DIR\nfrom OpenSSL.SSL import SSLEAY_PLATFORM\nfrom OpenSSL.SSL import SSLEAY_VERSION\nfrom OpenSSL.SSL import TLS1_1_VERSION\nfrom OpenSSL.SSL import TLS1_2_VERSION\nfrom OpenSSL.SSL import TLS1_3_VERSION\nfrom OpenSSL.SSL import TLS_METHOD\nfrom OpenSSL.SSL import VERIFY_CLIENT_ONCE\nfrom OpenSSL.SSL import VERIFY_FAIL_IF_NO_PEER_CERT\nfrom OpenSSL.SSL import VERIFY_NONE\nfrom OpenSSL.SSL import VERIFY_PEER\nfrom OpenSSL.SSL import Connection\nfrom OpenSSL.SSL import Context\nfrom OpenSSL.SSL import Error\nfrom OpenSSL.SSL import OP_NO_SSLv2\nfrom OpenSSL.SSL import OP_NO_SSLv3\nfrom OpenSSL.SSL import Session\nfrom OpenSSL.SSL import SSLeay_version\nfrom OpenSSL.SSL import SSLv23_METHOD\nfrom OpenSSL.SSL import SysCallError\nfrom OpenSSL.SSL import TLSv1_1_METHOD\nfrom OpenSSL.SSL import TLSv1_2_METHOD\nfrom OpenSSL.SSL import TLSv1_METHOD\nfrom OpenSSL.SSL import WantReadError\nfrom OpenSSL.SSL import WantWriteError\nfrom OpenSSL.SSL import ZeroReturnError\nfrom OpenSSL.SSL import _make_requires\nfrom OpenSSL.SSL import OP_NO_TLSv1_3\n\n\ndef _create_certificate_chain(): [MASK]\n"}
