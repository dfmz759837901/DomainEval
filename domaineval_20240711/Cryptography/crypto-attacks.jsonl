{"method_name": "attack", "full_method_name": "attack", "method_path": "../srcdata/Cryptography/crypto-attacks/attacks/rsa/known_d.py", "method_code": "from math import gcd\nfrom random import randrange\ndef attack(N, e, d):\n    \"\"\"\n    Recovers the prime factors from a modulus if the public exponent and private exponent are known.\n    :param N: the modulus\n    :param e: the public exponent\n    :param d: the private exponent\n    :return: a tuple containing the prime factors\n    \"\"\"\n    k = e * d - 1\n    t = 0\n    while k % 2 ** t == 0:\n        t += 1\n    while True:\n        g = randrange(1, N)\n        for s in range(1, t + 1):\n            x = pow(g, k // 2 ** s, N)\n            p = gcd(x - 1, N)\n            if 1 < p < N and N % p == 0:\n                return p, N // p", "test_code_list": [{"test_code": "import os\nimport sys\nfrom hashlib import sha256\nfrom math import lcm\nfrom random import getrandbits\nfrom random import randrange\nfrom unittest import TestCase\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom Crypto.PublicKey import RSA\n\nclass TestRSA(TestCase):\n    def test_known_d(self):\n        p = (\n            10999882285407021659159843781080979389814097626452668846482424135627220062700466847567575264657287989126943263999867722090759547565297969535143544253926071\n            )\n        q = (\n            12894820825544912052042889653649757120734073367261758361676140208842841153775542379620171049124260330205408767340830801133280422958906941622318918402459837\n            )\n        N = p * q\n        phi = (p - 1) * (q - 1)\n        e = 65537\n        d = pow(e, -1, phi)\n        p_, q_ = attack(N, e, d)\n        self.assertIsInstance(p_, int)\n        self.assertIsInstance(q_, int)\n        self.assertEqual(N, p_ * q_)\n    \nTestRSA().test_known_d()\n", "code_start": "", "test_path": "../srcdata/Cryptography/crypto-attacks/test/test_rsa.py"}], "instruction": "Functionality: The function 'attack' aims to recover the prime factors from a given modulus if both the public exponent and the private exponent are known. This function leverages the relationship between the public and private exponents to find the prime factors that were used to generate the modulus.\n\nInputs:\n- N: The modulus, which is a positive integer resulting from the multiplication of two large prime numbers.\n- e: The public exponent, which is a positive integer and part of the public key used in RSA encryption.\n- d: The private exponent, which is a positive integer and part of the private key used in RSA encryption.\n\nOutputs:\n- A tuple containing two prime factors of the modulus N. These factors are returned as the result of the function. The function will continue to run until it finds a pair of factors that satisfy the condition of being proper divisors of N.", "method_code_mask": "from math import gcd\nfrom random import randrange\n\n\ndef attack(N, e, d): [MASK]\n"}
{"method_name": "factorize", "full_method_name": "factorize", "method_path": "../srcdata/Cryptography/crypto-attacks/attacks/factorization/twin_primes.py", "method_code": "from math import isqrt\ndef factorize(N):\n    \"\"\"\n    Recovers the prime factors from a modulus if the factors are twin primes.\n    :param N: the modulus\n    :return: a tuple containing the prime factors, or None if there is no factorization\n    \"\"\"\n    p = isqrt(N + 1) - 1\n    q = isqrt(N + 1) + 1\n    return p, q if p * q == N else None", "test_code_list": [{"test_code": "import os\nimport sys\nfrom unittest import TestCase\n\nclass TestFactorization(TestCase):\n    def test_twin_primes(self):\n        p = (\n            4045364040964617981493056570547683620499113851384489798802437290109120991898115799819774088264427282611552038114397865000343325953101387058967136608664301\n            )\n        q = (\n            4045364040964617981493056570547683620499113851384489798802437290109120991898115799819774088264427282611552038114397865000343325953101387058967136608664303\n            )\n        N = p * q\n        p_, q_ = factorize(N)\n        self.assertIsInstance(p_, int)\n        self.assertIsInstance(q_, int)\n        self.assertEqual(N, p_ * q_)\n    \nTestFactorization().test_twin_primes()\n", "code_start": "", "test_path": "../srcdata/Cryptography/crypto-attacks/test/test_factorization.py"}], "instruction": "Functionality: The function factorize is designed to recover the prime factors of a given modulus N, specifically when these factors are twin primes. Twin primes are pairs of primes that have a difference of two, e.g., (3, 5), (5, 7), (11, 13), etc. This function employs a method to find such factors by calculating square roots and adjusting them to find potential factors.\n\nInputs: \n- N: an integer representing the modulus. The value of N is the product of the two prime factors that the function attempts to find. It is assumed that N is the result of multiplying two prime numbers that are twin primes.\n\nOutputs:\n- A tuple containing the prime factors if they exist and meet the twin prime condition. The tuple will contain two integers, p and q, where p * q = N.\n- None: If the function is unable to find factors that satisfy the conditions (i.e., N is not the product of twin primes), it will return None to indicate that no factorization was found under these conditions.", "method_code_mask": "from math import isqrt\n\n\ndef factorize(N): [MASK]\n"}
{"method_name": "attack", "full_method_name": "attack", "method_path": "../srcdata/Cryptography/crypto-attacks/attacks/elgamal_encryption/nonce_reuse.py", "method_code": "\ndef attack(p, m, c1, c2, c1_, c2_):\n    \"\"\"\n    Recovers a secret plaintext encrypted using the same nonce as a previous, known plaintext.\n    :param p: the prime used in the ElGamal scheme\n    :param m: the known plaintext\n    :param c1: the ciphertext of the known plaintext\n    :param c2: the ciphertext of the known plaintext\n    :param c1_: the ciphertext of the secret plaintext\n    :param c2_: the ciphertext of the secret plaintext\n    :return: the secret plaintext\n    \"\"\"\n    s = c2 * pow(m, -1, p) % p\n    m_ = c2_ * pow(s, -1, p) % p\n    return int(m_)", "test_code_list": [{"test_code": "import os\nimport sys\nfrom random import randrange\nfrom unittest import TestCase\n\nclass TestElgamalEncryption(TestCase):\n    def test_nonce_reuse(self):\n        p = 16902648776703029279\n        g = 3\n        for _ in range(100):\n            x = randrange(1, p)\n            h = pow(g, x, p)\n            y = randrange(1, p)\n            s = pow(h, y, p)\n            m = randrange(1, p)\n            c1 = pow(g, y, p)\n            c2 = m * s % p\n            m_ = randrange(1, p)\n            c1_ = pow(g, y, p)\n            c2_ = m_ * s % p\n            m__ = attack(p, m, c1, c2, c1_, c2_)\n            self.assertIsInstance(m__, int)\n            self.assertEqual(m_, m__)\n    \nTestElgamalEncryption().test_nonce_reuse()\n", "code_start": "", "test_path": "../srcdata/Cryptography/crypto-attacks/test/test_elgamal_encryption.py"}], "instruction": "Functionality: This function is designed to recover a secret plaintext that has been encrypted using the ElGamal scheme with the same nonce as a previous, known plaintext. The function calculates the secret plaintext by exploiting the properties of the ElGamal encryption scheme when the same nonce is reused.\n\nInputs:\n- p: A prime number utilized in the ElGamal encryption scheme. This is the modular base for all calculations.\n- m: The known plaintext that was encrypted using the same nonce as the secret plaintext.\n- c1, c2: The components of the ciphertext resulting from the encryption of the known plaintext using the ElGamal scheme. Note: In ElGamal, a ciphertext is a pair (c1, c2).\n- c1_, c2_: The components of the ciphertext resulting from the encryption of the secret plaintext using the ElGamal scheme with the same nonce as that used for the known plaintext.\n\nOutputs:\n- The function returns the secret plaintext as an integer. This is the decrypted message that was originally encrypted along with the known plaintext using the same nonce in the ElGamal scheme.", "method_code_mask": "def attack(p, m, c1, c2, c1_, c2_): [MASK]\n"}
