{"method_name": "get_code_snippet", "full_method_name": "get_code_snippet", "method_path": "../srcdata/Cryptography/detect-secrets/detect_secrets/util/code_snippet.py", "method_code": "from typing import Generator\nfrom typing import List\nclass CodeSnippet:\n\n    def __init__(self, snippet: List[str], start_line: int, target_index: int\n        ) ->None:\n        \"\"\"\n        :param snippet: lines of code extracted from file\n        :param start_line: first line number in segment\n        :param target_index: index in snippet of target line\n        \"\"\"\n        self.lines = snippet\n        self.start_line = start_line\n        self.target_index = target_index\n\n    @property\n    def target_line(self) ->str:\n        return self.lines[self.target_index]\n\n    @target_line.setter\n    def target_line(self, value: str) ->None:\n        self.lines[self.target_index] = value\n\n    @property\n    def previous_line(self) ->str:\n        if self.target_index == 0 or len(self.lines) < self.target_index:\n            return ''\n        return self.lines[self.target_index - 1]\n\n    def add_line_numbers(self) ->'CodeSnippet':\n        for index, line in enumerate(self.lines):\n            self.lines[index] = u'{}:{}'.format(self.get_line_number(self.\n                start_line + index + 1), line)\n        return self\n\n    def highlight_line(self, payload: str) ->'CodeSnippet':\n        \"\"\"\n        :param payload: string to highlight, on chosen line\n        \"\"\"\n        try:\n            index_of_payload = self.target_line.lower().index(payload.lower())\n            end_of_payload = index_of_payload + len(payload)\n            self.target_line = u'{}{}{}'.format(self.target_line[:\n                index_of_payload], self.apply_highlight(self.target_line[\n                index_of_payload:end_of_payload]), self.target_line[\n                end_of_payload:])\n            return self\n        except ValueError:\n            raise SecretNotFoundOnSpecifiedLineError(self.target_index)\n\n    def get_line_number(self, line_number: int) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(str(line_number), AnsiColor.LIGHT_GREEN)\n\n    def apply_highlight(self, payload: str) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(payload, AnsiColor.RED_BACKGROUND)\n\n    def __str__(self) ->str:\n        return '\\n'.join(self.lines)\n\n    def __iter__(self) ->Generator[str, None, None]:\n        yield from self.lines\ndef get_code_snippet(lines: List[str], line_number: int, lines_of_context:\n    int=5) ->'CodeSnippet':\n    \"\"\"\n    :param lines: an iterator of lines in the file\n    :param line_number: line which you want to focus on\n    :param lines_of_context: how many lines to display around the line you want\n        to focus on.\n    \"\"\"\n    target_line_index = line_number - 1\n    end_line_index = target_line_index + lines_of_context + 1\n    if target_line_index <= lines_of_context:\n        start_line_index = 0\n    else:\n        start_line_index = target_line_index - lines_of_context\n        target_line_index = lines_of_context\n    return CodeSnippet(snippet=lines[start_line_index:end_line_index],\n        start_line=start_line_index, target_index=target_line_index)", "test_code_list": [{"test_code": "import pytest\ndef test_target_line():\n    assert get_code_snippet(list('abcde'), 3, lines_of_context=2\n        ).target_line == 'c'\n\ntest_target_line()\n", "code_start": "", "test_path": "../srcdata/Cryptography/detect-secrets/tests/util/code_snippet_test.py"}, {"test_code": "import pytest\ndef test_previous_line():\n    assert get_code_snippet(list('abcde'), 3, lines_of_context=2\n        ).previous_line == 'b'\n\ntest_previous_line()\n", "code_start": "", "test_path": "../srcdata/Cryptography/detect-secrets/tests/util/code_snippet_test.py"}], "instruction": "Functionality: The get_code_snippet function is designed to extract a snippet of code from a list of lines, focusing on a specific line number, and including a certain number of lines of context around it. It creates and returns a CodeSnippet object, which encapsulates the extracted code snippet, the start line number of the snippet, and the index of the target line within the snippet.\n\nInputs: \n- lines: A List[str] representing the lines of a file from which the code snippet is extracted.\n- line_number: An int representing the line number in the file that the snippet should focus on.\n- lines_of_context: An optional int parameter (default is 5) that indicates how many lines of context (before and after) should be included in the snippet around the target line.\n\nOutputs:\n- A CodeSnippet object that contains the extracted code snippet, with the start line number and the index of the target line within the snippet. The CodeSnippet object has properties and methods to access and manipulate the target line, add line numbers, highlight a line, and retrieve the snippet as a string or an iterable of lines.", "method_code_mask": "from typing import Generator\nfrom typing import List\n\n\nclass CodeSnippet:\n\n    def __init__(self, snippet: List[str], start_line: int, target_index: int\n        ) ->None:\n        \"\"\"\n        :param snippet: lines of code extracted from file\n        :param start_line: first line number in segment\n        :param target_index: index in snippet of target line\n        \"\"\"\n        self.lines = snippet\n        self.start_line = start_line\n        self.target_index = target_index\n\n    @property\n    def target_line(self) ->str:\n        return self.lines[self.target_index]\n\n    @target_line.setter\n    def target_line(self, value: str) ->None:\n        self.lines[self.target_index] = value\n\n    @property\n    def previous_line(self) ->str:\n        if self.target_index == 0 or len(self.lines) < self.target_index:\n            return ''\n        return self.lines[self.target_index - 1]\n\n    def add_line_numbers(self) ->'CodeSnippet':\n        for index, line in enumerate(self.lines):\n            self.lines[index] = u'{}:{}'.format(self.get_line_number(self.\n                start_line + index + 1), line)\n        return self\n\n    def highlight_line(self, payload: str) ->'CodeSnippet':\n        \"\"\"\n        :param payload: string to highlight, on chosen line\n        \"\"\"\n        try:\n            index_of_payload = self.target_line.lower().index(payload.lower())\n            end_of_payload = index_of_payload + len(payload)\n            self.target_line = u'{}{}{}'.format(self.target_line[:\n                index_of_payload], self.apply_highlight(self.target_line[\n                index_of_payload:end_of_payload]), self.target_line[\n                end_of_payload:])\n            return self\n        except ValueError:\n            raise SecretNotFoundOnSpecifiedLineError(self.target_index)\n\n    def get_line_number(self, line_number: int) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(str(line_number), AnsiColor.LIGHT_GREEN)\n\n    def apply_highlight(self, payload: str) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(payload, AnsiColor.RED_BACKGROUND)\n\n    def __str__(self) ->str:\n        return '\\n'.join(self.lines)\n\n    def __iter__(self) ->Generator[str, None, None]:\n        yield from self.lines\n\n\ndef get_code_snippet(lines: List[str], line_number: int, lines_of_context:\n    int=5) ->'CodeSnippet': [MASK]\n"}
{"method_name": "is_sequential_string", "full_method_name": "is_sequential_string", "method_path": "../srcdata/Cryptography/detect-secrets/detect_secrets/filters/heuristic.py", "method_code": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\ndef is_sequential_string(secret: str) ->bool:\n    sequences = (string.ascii_uppercase + string.ascii_uppercase + string.\n        digits + '+/', string.digits + string.ascii_uppercase + string.\n        ascii_uppercase + '+/', (string.digits + string.ascii_uppercase) * \n        2, string.digits * 2, string.hexdigits.upper() + string.hexdigits.\n        upper(), string.ascii_uppercase + '=/')\n    uppercase = secret.upper()\n    for sequential_string in sequences:\n        if uppercase in sequential_string:\n            return True\n    return False", "test_code_list": [{"test_code": "import os\nimport pytest\n\nclass TestIsSequentialString():\n    @staticmethod\n    def test_failure():\n        assert not is_sequential_string('BEEF1234')\n    \nTestIsSequentialString().test_failure()\n", "code_start": "", "test_path": "../srcdata/Cryptography/detect-secrets/tests/filters/heuristic_filter_test.py"}], "instruction": "Functionality: The function is_sequential_string aims to determine if a given string is a sequential string. A string is considered sequential if it is a substring of a predefined sequence of characters. These sequences include the alphabet (both uppercase twice and mixed with digits), digits (repeated twice), hexadecimal digits (uppercase repeated), and a specific combination of uppercase letters and a special character.\n\nInputs: The function takes a single argument:\n- secret: A string that needs to be evaluated to determine if it is sequential.\n\nOutputs: The function returns a boolean value:\n- True: If the input string is found as a substring in any of the predefined sequences.\n- False: If the input string is not found as a substring in any of the predefined sequences.", "method_code_mask": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\n\n\ndef is_sequential_string(secret: str) ->bool: [MASK]\n"}
