{"method_name": "set_loggers", "full_method_name": "set_loggers", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/loggers/set_log_levels.py", "method_code": "import logging\ndef set_loggers(verbosity: int=0, api_verbosity: str='info') ->None:\n    \"\"\"\n    Set the logging level for third party libraries\n    :param verbosity: Verbosity level. amount of `-v` passed to the command line\n    :return: None\n    \"\"\"\n    for logger_name in ('requests', 'urllib3', 'httpcore'):\n        logging.getLogger(logger_name).setLevel(logging.INFO if verbosity <=\n            1 else logging.DEBUG)\n    logging.getLogger('ccxt.base.exchange').setLevel(logging.INFO if \n        verbosity <= 2 else logging.DEBUG)\n    logging.getLogger('telegram').setLevel(logging.INFO)\n    logging.getLogger('httpx').setLevel(logging.WARNING)\n    logging.getLogger('werkzeug').setLevel(logging.ERROR if api_verbosity ==\n        'error' else logging.INFO)", "test_code_list": [{"test_code": "import logging\nimport sys\nimport pytest\ndef test_set_loggers() ->None:\n    logging.getLogger('requests').setLevel(logging.DEBUG)\n    logging.getLogger('urllib3').setLevel(logging.DEBUG)\n    logging.getLogger('ccxt.base.exchange').setLevel(logging.DEBUG)\n    logging.getLogger('telegram').setLevel(logging.DEBUG)\n    previous_value1 = logging.getLogger('requests').level\n    previous_value2 = logging.getLogger('ccxt.base.exchange').level\n    previous_value3 = logging.getLogger('telegram').level\n    set_loggers()\n    value1 = logging.getLogger('requests').level\n    assert previous_value1 is not value1\n    assert value1 is logging.INFO\n    value2 = logging.getLogger('ccxt.base.exchange').level\n    assert previous_value2 is not value2\n    assert value2 is logging.INFO\n    value3 = logging.getLogger('telegram').level\n    assert previous_value3 is not value3\n    assert value3 is logging.INFO\n    set_loggers(verbosity=2)\n    assert logging.getLogger('requests').level is logging.DEBUG\n    assert logging.getLogger('ccxt.base.exchange').level is logging.INFO\n    assert logging.getLogger('telegram').level is logging.INFO\n    assert logging.getLogger('werkzeug').level is logging.INFO\n    set_loggers(verbosity=3, api_verbosity='error')\n    assert logging.getLogger('requests').level is logging.DEBUG\n    assert logging.getLogger('ccxt.base.exchange').level is logging.DEBUG\n    assert logging.getLogger('telegram').level is logging.INFO\n    assert logging.getLogger('werkzeug').level is logging.ERROR\n\ntest_set_loggers()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_log_setup.py"}], "instruction": "set_loggers(verbosity=2, api_verbosity='debug')", "method_code_mask": "import logging\n\n\ndef set_loggers(verbosity: int=0, api_verbosity: str='info') ->None: [MASK]\n"}
{"method_name": "check_int_positive", "full_method_name": "check_int_positive", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/cli_options.py", "method_code": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\ndef check_int_positive(value: str) ->int:\n    try:\n        uint = int(value)\n        if uint <= 0:\n            raise ValueError\n    except ValueError:\n        raise ArgumentTypeError(\n            f'{value} is invalid for this parameter, should be a positive integer value'\n            )\n    return uint", "test_code_list": [{"test_code": "import argparse\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_check_int_positive() ->None:\n    assert check_int_positive('3') == 3\n    assert check_int_positive('1') == 1\n    assert check_int_positive('100') == 100\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('-2')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('0')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive(0)\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('3.5')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('DeadBeef')\n\ntest_check_int_positive()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_arguments.py"}], "instruction": "Functionality: The check_int_positive function is designed to validate whether a given string can be converted into a positive integer. It will raise an error if the string either cannot be converted into an integer or represents a non-positive integer value (zero or negative).\n\nInputs: A string value that the function will attempt to convert into an integer.\n\nOutputs: If the given string is a valid representation of a positive integer, the function will return the integer value. If the string is not a valid representation of a positive integer, the function will raise an ArgumentTypeError with a message indicating that the value is invalid for this parameter, and it should be a positive integer value.", "method_code_mask": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\n\n\ndef check_int_positive(value: str) ->int: [MASK]\n"}
{"method_name": "check_int_nonzero", "full_method_name": "check_int_nonzero", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/cli_options.py", "method_code": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\ndef check_int_nonzero(value: str) ->int:\n    try:\n        uint = int(value)\n        if uint == 0:\n            raise ValueError\n    except ValueError:\n        raise ArgumentTypeError(\n            f'{value} is invalid for this parameter, should be a non-zero integer value'\n            )\n    return uint", "test_code_list": [{"test_code": "import argparse\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_check_int_nonzero() ->None:\n    assert check_int_nonzero('3') == 3\n    assert check_int_nonzero('1') == 1\n    assert check_int_nonzero('100') == 100\n    assert check_int_nonzero('-2') == -2\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('0')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero(0)\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('3.5')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('DeadBeef')\n\ntest_check_int_nonzero()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_arguments.py"}], "instruction": "Functionality: The check_int_nonzero function is designed to verify if a given string value can be converted to a non-zero integer. It will convert the string to an integer and then check if the integer is not equal to zero. If the conversion is successful and the integer is non-zero, it returns the integer. If the string cannot be converted to an integer or if the integer is zero, it raises an ArgumentTypeError with a specific error message.\n\nInputs: \n- value: A string value that needs to be checked. This string is expected to potentially represent an integer.\n\nOutputs:\n- If the string can be converted to a non-zero integer, the function returns the integer value.\n- If the string cannot be converted to an integer or if the integer is zero, the function raises an ArgumentTypeError with a message stating \"{value} is invalid for this parameter, should be a non-zero integer value\".", "method_code_mask": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\n\n\ndef check_int_nonzero(value: str) ->int: [MASK]\n"}
{"method_name": "safe_value_fallback", "full_method_name": "safe_value_fallback", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/misc.py", "method_code": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndef safe_value_fallback(obj: dict, key1: str, key2: Optional[str]=None,\n    default_value=None):\n    \"\"\"\n    Search a value in obj, return this if it's not None.\n    Then search key2 in obj - return that if it's not none - then use default_value.\n    Else falls back to None.\n    \"\"\"\n    if key1 in obj and obj[key1] is not None:\n        return obj[key1]\n    elif key2 and key2 in obj and obj[key2] is not None:\n        return obj[key2]\n    return default_value", "test_code_list": [{"test_code": "from copy import deepcopy\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pandas as pd\nimport pytest\nfrom pandas.testing import assert_frame_equal\ndef test_safe_value_fallback():\n    dict1 = {'keya': None, 'keyb': 2, 'keyc': 5, 'keyd': None}\n    assert safe_value_fallback(dict1, 'keya', 'keyb') == 2\n    assert safe_value_fallback(dict1, 'keyb', 'keya') == 2\n    assert safe_value_fallback(dict1, 'keyb', 'keyc') == 2\n    assert safe_value_fallback(dict1, 'keya', 'keyc') == 5\n    assert safe_value_fallback(dict1, 'keyc', 'keyb') == 5\n    assert safe_value_fallback(dict1, 'keya', 'keyd') is None\n    assert safe_value_fallback(dict1, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback(dict1, 'keyNo', 'keyNo', 55) == 55\n    assert safe_value_fallback(dict1, 'keyNo', default_value=55) == 55\n    assert safe_value_fallback(dict1, 'keyNo', None, default_value=55) == 55\n\ntest_safe_value_fallback()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_misc.py"}], "instruction": "Functionality: The function 'safe_value_fallback' is designed to safely retrieve values from a dictionary object. It first checks if the primary key (key1) is present in the dictionary and if the corresponding value is not None. If these conditions are met, the value associated with key1 is returned. If not, the function then looks for a secondary key (key2) in the dictionary. If key2 is present and the value is not None, this value is returned. If neither key1 nor key2 meets the conditions, or if key2 is not provided, the function returns a default_value. If the default_value is also None, the function ultimately returns None.\n\nInputs: \n- obj: A dictionary object from which to retrieve values.\n- key1: A string representing the primary key to search for in the dictionary.\n- key2: An optional string representing the secondary key to search for in the dictionary if the primary key does not yield a non-None value. Default is None.\n- default_value: A value to return if both keys do not yield non-None values. Default is None.\n\nOutputs:\n- The function returns the value associated with key1 if it is present and not None, the value associated with key2 if it is present and not None, or the default_value if both keys do not yield non-None values. If default_value is None and neither key yields a non-None value, the function returns None.", "method_code_mask": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\n\n\ndef safe_value_fallback(obj: dict, key1: str, key2: Optional[str]=None,\n    default_value=None): [MASK]\n"}
{"method_name": "safe_value_fallback2", "full_method_name": "safe_value_fallback2", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/misc.py", "method_code": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndictMap = Union[Dict[str, Any], Mapping[str, Any]]\ndef safe_value_fallback2(dict1: dictMap, dict2: dictMap, key1: str, key2:\n    str, default_value=None):\n    \"\"\"\n    Search a value in dict1, return this if it's not None.\n    Fall back to dict2 - return key2 from dict2 if it's not None.\n    Else falls back to None.\n    \"\"\"\n    if key1 in dict1 and dict1[key1] is not None:\n        return dict1[key1]\n    elif key2 in dict2 and dict2[key2] is not None:\n        return dict2[key2]\n    return default_value", "test_code_list": [{"test_code": "from copy import deepcopy\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pandas as pd\nimport pytest\nfrom pandas.testing import assert_frame_equal\ndef test_safe_value_fallback2():\n    dict1 = {'keya': None, 'keyb': 2, 'keyc': 5, 'keyd': None}\n    dict2 = {'keya': 20, 'keyb': None, 'keyc': 6, 'keyd': None}\n    assert safe_value_fallback2(dict1, dict2, 'keya', 'keya') == 20\n    assert safe_value_fallback2(dict2, dict1, 'keya', 'keya') == 20\n    assert safe_value_fallback2(dict1, dict2, 'keyb', 'keyb') == 2\n    assert safe_value_fallback2(dict2, dict1, 'keyb', 'keyb') == 2\n    assert safe_value_fallback2(dict1, dict2, 'keyc', 'keyc') == 5\n    assert safe_value_fallback2(dict2, dict1, 'keyc', 'keyc') == 6\n    assert safe_value_fallback2(dict1, dict2, 'keyd', 'keyd') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyd', 'keyd') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyd', 'keyd', 1234) == 1234\n    assert safe_value_fallback2(dict1, dict2, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyNo', 'keyNo', 1234) == 1234\n\ntest_safe_value_fallback2()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_misc.py"}], "instruction": "Functionality: The function 'safe_value_fallback2' is designed to safely retrieve a value from two dictionaries. It first attempts to find and return the value associated with 'key1' in 'dict1'. If 'key1' is not present in 'dict1' or its value is None, the function then attempts to find and return the value associated with 'key2' in 'dict2'. If 'key2' is not present in 'dict2' or its value is also None, the function will return 'default_value', which is None by default if not provided.\n\nInputs: \n1. dict1: A dictionary where the keys are strings and the values are of any type.\n2. dict2: A dictionary where the keys are strings and the values are of any type.\n3. key1: A string representing the key to look up in the first dictionary, 'dict1'.\n4. key2: A string representing the key to look up in the second dictionary, 'dict2'.\n5. default_value (optional): A value to return if neither 'key1' in 'dict1' nor 'key2' in 'dict2' has a non-None value. This parameter is optional and will default to None if not provided.\n\nOutputs:\n1. The value associated with 'key1' in 'dict1' if it exists and is not None.\n2. The value associated with 'key2' in 'dict2' if 'key1' does not exist in 'dict1' or its value is None, and if 'key2' exists in 'dict2' and is not None.\n3. 'default_value' if the conditions described above are not met.", "method_code_mask": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndictMap = Union[Dict[str, Any], Mapping[str, Any]]\n\n\ndef safe_value_fallback2(dict1: dictMap, dict2: dictMap, key1: str, key2:\n    str, default_value=None): [MASK]\n"}
{"method_name": "round_value", "full_method_name": "round_value", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/formatters.py", "method_code": "def strip_trailing_zeros(value: str) ->str:\n    \"\"\"\n    Strip trailing zeros from a string\n    :param value: Value to be stripped\n    :return: Stripped value\n    \"\"\"\n    return value.rstrip('0').rstrip('.')\ndef round_value(value: float, decimals: int, keep_trailing_zeros=False) ->str:\n    \"\"\"\n    Round value to given decimals\n    :param value: Value to be rounded\n    :param decimals: Number of decimals to round to\n    :param keep_trailing_zeros: Keep trailing zeros \"222.200\" vs. \"222.2\"\n    :return: Rounded value as string\n    \"\"\"\n    val = f'{value:.{decimals}f}'\n    if not keep_trailing_zeros:\n        val = strip_trailing_zeros(val)\n    return val", "test_code_list": [{"test_code": "def test_round_value():\n    assert round_value(222.222222, 3) == '222.222'\n    assert round_value(222.2, 3) == '222.2'\n    assert round_value(222.0, 3) == '222'\n    assert round_value(222.12745, 3) == '222.127'\n    assert round_value(0.1274512123, 8) == '0.12745121'\n    assert round_value(0.1274512123, 5) == '0.12745'\n    assert round_value(222.2, 3, True) == '222.200'\n    assert round_value(222.2, 0, True) == '222'\n\ntest_round_value()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_formatters.py"}], "instruction": "Functionality: The round_value function rounds a given floating-point number to a specified number of decimal places and returns the result as a string. It also has an optional parameter to control whether trailing zeros should be kept in the output.\n\nInputs: \n- value: A floating-point number to be rounded.\n- decimals: An integer specifying the number of decimal places to round the number to.\n- keep_trailing_zeros: A boolean value indicating whether trailing zeros should be kept in the output string. The default value is False.\n\nOutputs: \n- A string representing the rounded number. If keep_trailing_zeros is True, the string will preserve trailing zeros; otherwise, trailing zeros will be removed.", "method_code_mask": "def strip_trailing_zeros(value: str) ->str:\n    \"\"\"\n    Strip trailing zeros from a string\n    :param value: Value to be stripped\n    :return: Stripped value\n    \"\"\"\n    return value.rstrip('0').rstrip('.')\n\n\ndef round_value(value: float, decimals: int, keep_trailing_zeros=False\n    ) ->str: [MASK]\n"}
{"method_name": "dt_ts_def", "full_method_name": "dt_ts_def", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "method_code": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_ts_def(dt: Optional[datetime], default: int=0) ->int:\n    \"\"\"\n    Return dt in ms as a timestamp in UTC.\n    If dt is None, return the given default.\n    \"\"\"\n    if dt:\n        return int(dt.timestamp() * 1000)\n    return default", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_ts_def():\n    assert dt_ts_def(None) == 0\n    assert dt_ts_def(None, 123) == 123\n    assert dt_ts_def(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n    assert dt_ts_def(datetime(2023, 5, 5, tzinfo=timezone.utc), 123\n        ) == 1683244800000\n\ntest_dt_ts_def()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "instruction": "Functionality: Convert a given datetime object to a timestamp in milliseconds, adjusted to UTC. If the input datetime object is None, return a default value provided as an argument.\n\nInputs: \n- dt: An optional datetime object (could be None). This represents the date and time to be converted to a timestamp.\n- default: An integer (default value is 0). This is the value to be returned if the dt argument is None.\n\nOutputs:\n- An integer representing the timestamp in milliseconds if the dt argument is not None. If dt is None, the function returns the default value.", "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_ts_def(dt: Optional[datetime], default: int=0) ->int: [MASK]\n"}
{"method_name": "dt_ts_none", "full_method_name": "dt_ts_none", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "method_code": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_ts_none(dt: Optional[datetime]) ->Optional[int]:\n    \"\"\"\n    Return dt in ms as a timestamp in UTC.\n    If dt is None, return the given default.\n    \"\"\"\n    if dt:\n        return int(dt.timestamp() * 1000)\n    return None", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_ts_none():\n    assert dt_ts_none(None) is None\n    assert dt_ts_none(None) is None\n    assert dt_ts_none(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n    assert dt_ts_none(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n\ntest_dt_ts_none()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "instruction": "Functionality: The function dt_ts_none is designed to convert a given datetime object into a timestamp measured in milliseconds, specifically adjusted to UTC. If the input datetime object is None, the function should return None as well.\n\nInputs: \n- dt: An optional datetime object. It can be a datetime instance or None. The datetime instance should represent a point in time.\n\nOutputs: \n- An optional integer representing the timestamp in milliseconds if the input datetime object is not None. If the input is None, the function should return None.", "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_ts_none(dt: Optional[datetime]) ->Optional[int]: [MASK]\n"}
{"method_name": "dt_utc", "full_method_name": "dt_utc", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "method_code": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_utc(year: int, month: int, day: int, hour: int=0, minute: int=0,\n    second: int=0, microsecond: int=0) ->datetime:\n    \"\"\"Return a datetime in UTC.\"\"\"\n    return datetime(year, month, day, hour, minute, second, microsecond,\n        tzinfo=timezone.utc)", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_utc():\n    assert dt_utc(2023, 5, 5) == datetime(2023, 5, 5, tzinfo=timezone.utc)\n    assert dt_utc(2023, 5, 5, 0, 0, 0, 555500) == datetime(2023, 5, 5, 0, 0,\n        0, 555500, tzinfo=timezone.utc)\n\ntest_dt_utc()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "instruction": "Functionality: The function dt_utc is designed to generate a datetime object representing a specific date and time in the UTC time zone. The function allows for the specification of the year, month, and day as mandatory fields, while the hour, minute, second, and microsecond are optional, defaulting to 0 if not provided.\n\nInputs: \n- year: An integer representing the year.\n- month: An integer representing the month.\n- day: An integer representing the day.\n- hour: An optional integer representing the hour. Defaults to 0 if not provided.\n- minute: An optional integer representing the minute. Defaults to 0 if not provided.\n- second: An optional integer representing the second. Defaults to 0 if not provided.\n- microsecond: An optional integer representing the microsecond. Defaults to 0 if not provided.\n\nOutputs:\n- A datetime object with the provided date and time information, set in the UTC time zone.", "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_utc(year: int, month: int, day: int, hour: int=0, minute: int=0,\n    second: int=0, microsecond: int=0) ->datetime: [MASK]\n"}
{"method_name": "shorten_date", "full_method_name": "shorten_date", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "method_code": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef shorten_date(_date: str) ->str:\n    \"\"\"\n    Trim the date so it fits on small screens\n    \"\"\"\n    new_date = re.sub('seconds?', 'sec', _date)\n    new_date = re.sub('minutes?', 'min', new_date)\n    new_date = re.sub('hours?', 'h', new_date)\n    new_date = re.sub('days?', 'd', new_date)\n    new_date = re.sub('^an?', '1', new_date)\n    return new_date", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_shorten_date() ->None:\n    str_data = '1 day, 2 hours, 3 minutes, 4 seconds ago'\n    str_shorten_data = '1 d, 2 h, 3 min, 4 sec ago'\n    assert shorten_date(str_data) == str_shorten_data\n\ntest_shorten_date()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "instruction": "Functionality: The function \"shorten_date\" is designed to reduce the length of date strings to make them more suitable for display on small screens. The function does this by replacing certain words with shorter alternatives and standardizing '1' as the representation for 'a' or 'an'.\n\nInputs: The function takes one input:\n- _date (str): A string representing a date or time ago which can include words like seconds, minutes, hours, and days.\n\nOutputs: The function returns one output:\n- str: A shortened string of the input date, where 'seconds' are replaced with 'sec', 'minutes' with 'min', 'hours' with 'h', 'days' with 'd', and 'a' or 'an' at the beginning of the string is replaced with '1'.", "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef shorten_date(_date: str) ->str: [MASK]\n"}
{"method_name": "validate_is_float", "full_method_name": "validate_is_float", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/build_config_commands.py", "method_code": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\ndef validate_is_float(val):\n    try:\n        _ = float(val)\n        return True\n    except Exception:\n        return False", "test_code_list": [{"test_code": "from pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_validate_is_float():\n    assert validate_is_float('2.0')\n    assert validate_is_float('2.1')\n    assert validate_is_float('0.1')\n    assert validate_is_float('-0.5')\n    assert not validate_is_float('-0.5e')\n\ntest_validate_is_float()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/commands/test_build_config.py"}], "instruction": "Functionality: The validate_is_float function aims to determine whether a given input can be converted to a float. This is achieved by attempting to cast the input value to a float. If the conversion is successful, the function returns True, indicating that the input is indeed a float or can be cast as one. Conversely, if the conversion fails (throws an exception), the function returns False, indicating that the input is not a valid float.\n\nInputs: The function takes a single argument 'val', which is the value to be checked. The 'val' can be of any data type (e.g., string, integer, float, list, dictionary).\n\nOutputs: The function returns a boolean value. True is returned if 'val' can be cast to a float, and False is returned otherwise.", "method_code_mask": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\n\n\ndef validate_is_float(val): [MASK]\n"}
{"method_name": "validate_is_int", "full_method_name": "validate_is_int", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/build_config_commands.py", "method_code": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\ndef validate_is_int(val):\n    try:\n        _ = int(val)\n        return True\n    except Exception:\n        return False", "test_code_list": [{"test_code": "from pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_validate_is_int():\n    assert validate_is_int('2')\n    assert validate_is_int('6')\n    assert validate_is_int('-1')\n    assert validate_is_int('500')\n    assert not validate_is_int('2.0')\n    assert not validate_is_int('2.1')\n    assert not validate_is_int('-2.1')\n    assert not validate_is_int('-ee')\n\ntest_validate_is_int()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/commands/test_build_config.py"}], "instruction": "Functionality: The function 'validate_is_int' is designed to check whether a given value can be converted to an integer without losing any information. If the value can be safely converted to an integer, the function returns True. Otherwise, it returns False.\n\nInputs: \n- val: Any data type (number, string, list, dictionary, etc.) that the function will check to see if it can be converted to an integer.\n\nOutputs:\n- True (boolean): If the input value can be converted to an integer.\n- False (boolean): If the input value cannot be converted to an integer without losing information.", "method_code_mask": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\n\n\ndef validate_is_int(val): [MASK]\n"}
{"method_name": "stoploss_from_absolute", "full_method_name": "stoploss_from_absolute", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/strategy/strategy_helper.py", "method_code": "from typing import Optional\nimport pandas as pd\ndef stoploss_from_absolute(stop_rate: float, current_rate: float, is_short:\n    bool=False, leverage: float=1.0) ->float:\n    \"\"\"\n    Given current price and desired stop price, return a stop loss value that is relative to current\n    price.\n\n    The requested stop can be positive for a stop above the open price, or negative for\n    a stop below the open price. The return value is always >= 0.\n\n    Returns 0 if the resulting stop price would be above the current price.\n\n    :param stop_rate: Stop loss price.\n    :param current_rate: Current asset price.\n    :param is_short: When true, perform the calculation for short instead of long\n    :param leverage: Leverage to use for the calculation\n    :return: Positive stop loss value relative to current price\n    \"\"\"\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\ndef test_stoploss_from_absolute():\n    assert pytest.approx(stoploss_from_absolute(90, 100)) == 1 - 90 / 100\n    assert pytest.approx(stoploss_from_absolute(90, 100)) == 0.1\n    assert pytest.approx(stoploss_from_absolute(95, 100)) == 0.05\n    assert pytest.approx(stoploss_from_absolute(100, 100)) == 0\n    assert pytest.approx(stoploss_from_absolute(110, 100)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 0)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100, False, leverage=5)\n        ) == 5\n    assert pytest.approx(stoploss_from_absolute(90, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(110, 100, True)) == -(1 - \n        110 / 100)\n    assert pytest.approx(stoploss_from_absolute(110, 100, True)) == 0.1\n    assert pytest.approx(stoploss_from_absolute(105, 100, True)) == 0.05\n    assert pytest.approx(stoploss_from_absolute(105, 100, True, 5)) == 0.05 * 5\n    assert pytest.approx(stoploss_from_absolute(100, 0, True)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 1, is_short=True)) == 1\n    assert pytest.approx(stoploss_from_absolute(100, 1, is_short=True,\n        leverage=5)) == 5\n\ntest_stoploss_from_absolute()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/strategy/test_strategy_helpers.py"}], "instruction": "Functionality: The function 'stoploss_from_absolute' computes a relative stop loss value from an absolute stop loss price. It takes into account the current asset price, whether the position is short or long, and the leverage being used.\n\nInputs: \n- stop_rate: The absolute stop loss price.\n- current_rate: The current price of the asset.\n- is_short: A boolean flag indicating whether the position is a short position (True) or a long position (False).\n- leverage: The leverage factor to be applied in the calculation.\n\nOutputs:\n- A float value representing the positive stop loss relative to the current price. The function returns 0 if the calculated stop loss would result in a price above the current price. The returned value is always in the range [0, 1] after applying the leverage.", "method_code_mask": "from typing import Optional\nimport pandas as pd\n\n\ndef stoploss_from_absolute(stop_rate: float, current_rate: float, is_short:\n    bool=False, leverage: float=1.0) ->float: [MASK]\n"}
{"method_name": "get_last_sequence_ids", "full_method_name": "get_last_sequence_ids", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/persistence/migrations.py", "method_code": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\ndef get_last_sequence_ids(engine, trade_back_name: str, order_back_name: str):\n    order_id: Optional[int] = None\n    trade_id: Optional[int] = None\n    if engine.name == 'postgresql':\n        with engine.begin() as connection:\n            trade_id = connection.execute(text(\n                \"select nextval('trades_id_seq')\")).fetchone()[0]\n            order_id = connection.execute(text(\n                \"select nextval('orders_id_seq')\")).fetchone()[0]\n        with engine.begin() as connection:\n            connection.execute(text(\n                f'ALTER SEQUENCE orders_id_seq rename to {order_back_name}_id_seq_bak'\n                ))\n            connection.execute(text(\n                f'ALTER SEQUENCE trades_id_seq rename to {trade_back_name}_id_seq_bak'\n                ))\n    return order_id, trade_id", "test_code_list": [{"test_code": "import logging\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy.schema import CreateTable\ndef test_migrate_get_last_sequence_ids():\n    engine = MagicMock()\n    engine.begin = MagicMock()\n    engine.name = 'postgresql'\n    get_last_sequence_ids(engine, 'trades_bak', 'orders_bak')\n    assert engine.begin.call_count == 2\n    engine.reset_mock()\n    engine.begin.reset_mock()\n    engine.name = 'somethingelse'\n    get_last_sequence_ids(engine, 'trades_bak', 'orders_bak')\n    assert engine.begin.call_count == 0\n\ntest_migrate_get_last_sequence_ids()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/persistence/test_migrations.py"}], "instruction": "Functionality: The function 'get_last_sequence_ids' is designed to retrieve the next values from the 'orders_id_seq' and 'trades_id_seq' sequences in a PostgreSQL database, which are typically used to generate unique IDs for new records in the 'orders' and 'trades' tables, respectively. After fetching these values, the function renames the sequences to include a backup name provided by the user. This functionality can be particularly useful when there is a need to perform operations that require knowing the next sequence value before it is actually used in the database, such as preparing to insert new records with custom initial IDs.\n\nInputs: \n1. engine: An SQLAlchemy engine object that represents the connection to the PostgreSQL database.\n2. trade_back_name: A string representing the backup name to be appended when renaming the 'trades_id_seq' sequence.\n3. order_back_name: A string representing the backup name to be appended when renaming the 'orders_id_seq' sequence.\n\nOutputs:\n1. order_id: An integer representing the next available ID from the 'orders_id_seq' sequence. It may be None if the database engine is not PostgreSQL or if there is an error.\n2. trade_id: An integer representing the next available ID from the 'trades_id_seq' sequence. It may be None if the database engine is not PostgreSQL or if there is an error.", "method_code_mask": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\n\n\ndef get_last_sequence_ids(engine, trade_back_name: str, order_back_name: str\n    ): [MASK]\n"}
{"method_name": "set_sequence_ids", "full_method_name": "set_sequence_ids", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/persistence/migrations.py", "method_code": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\ndef set_sequence_ids(engine, order_id, trade_id, pairlock_id=None):\n    if engine.name == 'postgresql':\n        with engine.begin() as connection:\n            if order_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE orders_id_seq RESTART WITH {order_id}'))\n            if trade_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE trades_id_seq RESTART WITH {trade_id}'))\n            if pairlock_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE pairlocks_id_seq RESTART WITH {pairlock_id}'\n                    ))", "test_code_list": [{"test_code": "import logging\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy.schema import CreateTable\ndef test_migrate_set_sequence_ids():\n    engine = MagicMock()\n    engine.begin = MagicMock()\n    engine.name = 'postgresql'\n    set_sequence_ids(engine, 22, 55, 5)\n    assert engine.begin.call_count == 1\n    engine.reset_mock()\n    engine.begin.reset_mock()\n    engine.name = 'somethingelse'\n    set_sequence_ids(engine, 22, 55, 6)\n    assert engine.begin.call_count == 0\n\ntest_migrate_set_sequence_ids()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/persistence/test_migrations.py"}], "instruction": "Functionality: The function 'set_sequence_ids' is designed to alter the starting value of specific sequence IDs in a PostgreSQL database. This ensures that the next value generated by these sequences will start from the specified ID, useful for resetting or customizing the auto-increment values for tables such as orders, trades, and pairlocks.\n\nInputs: \n1. engine: A SQLAlchemy engine object. This engine is used to connect to the database and execute SQL commands.\n2. order_id: An integer value representing the new starting ID for the 'orders' table sequence.\n3. trade_id: An integer value representing the new starting ID for the 'trades' table sequence.\n4. pairlock_id: An optional integer value representing the new starting ID for the 'pairlocks' table sequence. It is optional and can be None.\n\nOutputs: \nThe function does not return any value. Its effect is observed in the database where the sequence IDs are altered according to the input parameters. If the function executes successfully, the sequence 'orders_id_seq' will restart with 'order_id', 'trades_id_seq' with 'trade_id', and 'pairlocks_id_seq' with 'pairlock_id' if provided.", "method_code_mask": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\n\n\ndef set_sequence_ids(engine, order_id, trade_id, pairlock_id=None): [MASK]\n"}
{"method_name": "hyperopt_serializer", "full_method_name": "hyperopt_serializer", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/optimize/hyperopt_tools.py", "method_code": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport numpy as np\nfrom pandas import isna\nfrom pandas import json_normalize\ndef hyperopt_serializer(x):\n    if isinstance(x, np.integer):\n        return int(x)\n    if isinstance(x, np.bool_):\n        return bool(x)\n    return str(x)", "test_code_list": [{"test_code": "import logging\nimport re\nfrom pathlib import Path\nfrom typing import Dict\nfrom typing import List\nimport numpy as np\nimport pytest\ndef test_hyperopt_serializer():\n    assert isinstance(hyperopt_serializer(np.int_(5)), int)\n    assert isinstance(hyperopt_serializer(np.bool_(True)), bool)\n    assert isinstance(hyperopt_serializer(np.bool_(False)), bool)\n\ntest_hyperopt_serializer()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/optimize/test_hyperopt_tools.py"}], "instruction": "Functionality: This function, hyperopt_serializer, is intended to convert various data types into simpler, serializable types. Specifically, it handles numpy integer types by converting them to Python's built-in int type, numpy boolean types are converted to Python's built-in bool type, and all other data types are converted to strings. This is particularly useful when preparing data for serialization, such as when you need to convert complex data structures into JSON format.\n\nInputs: \n- x: This is a single data point of any type. It could be an integer, boolean, or any other type. This input is what the function will attempt to serialize into a simpler data type.\n\nOutputs:\n- The function returns a data point that has been converted to either an int, bool, or str type. This will depend on the original type of the input 'x'. Integers and booleans from numpy are converted to their Python equivalents, while all other types are converted to strings.", "method_code_mask": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport numpy as np\nfrom pandas import isna\nfrom pandas import json_normalize\n\n\ndef hyperopt_serializer(x): [MASK]\n"}
{"method_name": "generate_pair_metrics", "full_method_name": "generate_pair_metrics", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/optimize/optimize_reports/optimize_reports.py", "method_code": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Literal\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import concat\nfrom pandas import to_datetime\ndef _generate_result_line(result: DataFrame, starting_balance: int,\n    first_column: Union[str, List[str]]) ->Dict:\n    \"\"\"\n    Generate one result dict, with \"first_column\" as key.\n    \"\"\"\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': \n        result['profit_ratio'].mean() if len(result) > 0 else 0.0,\n        'profit_mean_pct': round(result['profit_ratio'].mean() * 100.0, 2) if\n        len(result) > 0 else 0.0, 'profit_sum': profit_sum,\n        'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs':\n        result['profit_abs'].sum(), 'profit_total': profit_total,\n        'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg':\n        str(timedelta(minutes=round(result['trade_duration'].mean()))) if \n        not result.empty else '0:00', 'wins': len(result[result[\n        'profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]\n        ), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(\n        result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0\n        }\ndef generate_pair_metrics(pairlist: List[str], stake_currency: str,\n    starting_balance: int, results: DataFrame, skip_nan: bool=False) ->List[\n    Dict]:\n    \"\"\"\n    Generates and returns a list  for the given backtest data and the results dataframe\n    :param pairlist: Pairlist used\n    :param stake_currency: stake-currency - used to correctly name headers\n    :param starting_balance: Starting balance\n    :param results: Dataframe containing the backtest results\n    :param skip_nan: Print \"left open\" open trades\n    :return: List of Dicts containing the metrics per pair\n    \"\"\"\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance,\n            pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'],\n        reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance,\n        'TOTAL'))\n    return tabular_data", "test_code_list": [{"test_code": "import re\nfrom datetime import timedelta\nfrom pathlib import Path\nfrom shutil import copyfile\nimport joblib\nimport pandas as pd\nimport pytest\ndef test_generate_pair_metrics():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio':\n        [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30],\n        'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC',\n        starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[\n        -1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1\n        ]['profit_sum'] * 100\n\ntest_generate_pair_metrics()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/optimize/test_optimize_reports.py"}], "instruction": "Functionality: The function 'generate_pair_metrics' processes a DataFrame containing backtest results for multiple trading pairs and generates performance metrics for each pair.\nInputs: \n    - pairlist: List of strings representing the trading pairs.\n    - stake_currency: A string representing the stake currency used in the backtest.\n    - starting_balance: An integer representing the starting balance for the backtest.\n    - results: A DataFrame containing the backtest results, with columns including 'pair', 'profit_ratio', 'profit_abs', and 'trade_duration'.\n    - skip_nan: A boolean indicating whether to skip pairs with all NaN values in 'profit_abs' column.\nOutputs:\n    - A list of dictionaries, each containing metrics for a single pair or the total across all pairs. The metrics include the number of trades, mean profit ratio, total profit ratio, total profit in absolute terms, average trade duration, number of wins, draws, and losses, and the winrate. The 'TOTAL' entry aggregates the metrics across all pairs.", "method_code_mask": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Literal\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import concat\nfrom pandas import to_datetime\n\n\ndef _generate_result_line(result: DataFrame, starting_balance: int,\n    first_column: Union[str, List[str]]) ->Dict:\n    \"\"\"\n    Generate one result dict, with \"first_column\" as key.\n    \"\"\"\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': \n        result['profit_ratio'].mean() if len(result) > 0 else 0.0,\n        'profit_mean_pct': round(result['profit_ratio'].mean() * 100.0, 2) if\n        len(result) > 0 else 0.0, 'profit_sum': profit_sum,\n        'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs':\n        result['profit_abs'].sum(), 'profit_total': profit_total,\n        'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg':\n        str(timedelta(minutes=round(result['trade_duration'].mean()))) if \n        not result.empty else '0:00', 'wins': len(result[result[\n        'profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]\n        ), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(\n        result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0\n        }\n\n\ndef generate_pair_metrics(pairlist: List[str], stake_currency: str,\n    starting_balance: int, results: DataFrame, skip_nan: bool=False) ->List[\n    Dict]: [MASK]\n"}
