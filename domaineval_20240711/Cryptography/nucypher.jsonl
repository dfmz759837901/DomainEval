{"method_name": "_resolve_ipv4", "full_method_name": "_resolve_ipv4", "method_path": "../srcdata/Cryptography/nucypher/nucypher/utilities/networking.py", "method_code": "import random\nfrom http import HTTPStatus\nfrom ipaddress import AddressValueError\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom typing import Optional\nfrom typing import Union\nimport requests\nfrom flask import Request\nfrom requests.exceptions import HTTPError\nfrom requests.exceptions import RequestException\ndef _resolve_ipv4(ip: str) ->Optional[IPv4Address]:\n    \"\"\"\n    Resolve an IPv6 address to IPv4 if required and possible.\n    Returns None if there is no valid IPv4 address available.\n    \"\"\"\n    try:\n        ip = ip_address(ip.strip())\n    except (AddressValueError, ValueError):\n        raise AddressValueError(\n            f\"'{ip}' does not appear to be an IPv4 or IPv6 address\")\n    if isinstance(ip, IPv6Address):\n        return ip.ipv4_mapped\n    elif isinstance(ip, IPv4Address):\n        return ip", "test_code_list": [{"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_valid_ipv4():\n    assert _resolve_ipv4('8.8.8.8') == IPv4Address('8.8.8.8')\n\ntest_resolve_ipv4_with_valid_ipv4()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}, {"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_valid_mapped_ipv6():\n    assert _resolve_ipv4('::ffff:8.8.8.8') == IPv4Address('8.8.8.8')\n\ntest_resolve_ipv4_with_valid_mapped_ipv6()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}, {"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_non_mapped_ipv6():\n    assert _resolve_ipv4('2001:0db8::') is None\n\ntest_resolve_ipv4_with_non_mapped_ipv6()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}], "instruction": "Functionality: The function _resolve_ipv4 is designed to take a string representing an IP address and determine if it is an IPv4 or IPv6 address. If the input is an IPv6 address, the function attempts to resolve it to an IPv4 address if possible. If the input is already an IPv4 address, it is returned as is. The function returns None if the input does not represent a valid IPv4 address or if there is no valid IPv4 mapping for an IPv6 address.\n\nInputs: \n- ip: A string representing an IP address (either IPv4 or IPv6).\n\nOutputs: \n- Optional[IPv4Address]: If the input is a valid IPv4 address or if an IPv6 address can be resolved to a valid IPv4 address, the function returns that IPv4 address. If the input cannot be resolved to a valid IPv4 address, the function returns None.", "method_code_mask": "import random\nfrom http import HTTPStatus\nfrom ipaddress import AddressValueError\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom typing import Optional\nfrom typing import Union\nimport requests\nfrom flask import Request\nfrom requests.exceptions import HTTPError\nfrom requests.exceptions import RequestException\n\n\ndef _resolve_ipv4(ip: str) ->Optional[IPv4Address]: [MASK]\n"}
{"method_name": "secure_random", "full_method_name": "secure_random", "method_path": "../srcdata/Cryptography/nucypher/nucypher/crypto/utils.py", "method_code": "from secrets import SystemRandom\nfrom typing import Union\nSYSTEM_RAND = SystemRandom()\ndef secure_random(num_bytes: int) ->bytes:\n    \"\"\"\n    Returns an amount `num_bytes` of data from the OS's random device.\n    If a randomness source isn't found, returns a `NotImplementedError`.\n    In this case, a secure random source most likely doesn't exist and\n    randomness will have to found elsewhere.\n    :param num_bytes: Number of bytes to return.\n    :return: bytes\n    \"\"\"\n    return SYSTEM_RAND.getrandbits(num_bytes * 8).to_bytes(num_bytes,\n        byteorder='big')", "test_code_list": [{"test_code": "import unittest\n\nclass TestCrypto(unittest.TestCase):\n    def test_secure_random(self):\n        rand1 = secure_random(10)\n        rand2 = secure_random(10)\n        self.assertNotEqual(rand1, rand2)\n        self.assertEqual(bytes, type(rand1))\n        self.assertEqual(bytes, type(rand2))\n        self.assertEqual(10, len(rand1))\n        self.assertEqual(10, len(rand2))\n    \nTestCrypto().test_secure_random()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/crypto/test_keccak_sanity.py"}], "instruction": "Functionality: The secure_random function generates a specified number of bytes of secure random data using the operating system's random device. If a secure random source is not available, it raises a NotImplementedError, indicating that a secure random source likely does not exist and randomness must be obtained from an alternative source.\n\nInputs: \n- num_bytes (int): The number of bytes of random data to be generated.\n\nOutputs: \n- bytes: A byte string of length num_bytes containing secure random data. If a secure random source is not available, the function does not return a value but raises a NotImplementedError.", "method_code_mask": "from secrets import SystemRandom\nfrom typing import Union\nSYSTEM_RAND = SystemRandom()\n\n\ndef secure_random(num_bytes: int) ->bytes: [MASK]\n"}
{"method_name": "is_context_variable", "full_method_name": "is_context_variable", "method_path": "../srcdata/Cryptography/nucypher/nucypher/policy/conditions/context.py", "method_code": "import re\nfrom typing import Any\nfrom typing import List\nfrom typing import Union\nCONTEXT_REGEX = re.compile(':[a-zA-Z_][a-zA-Z0-9_]*')\nCONTEXT_PREFIX = ':'\ndef is_context_variable(variable) ->bool:\n    if isinstance(variable, str) and variable.startswith(CONTEXT_PREFIX):\n        if CONTEXT_REGEX.fullmatch(variable):\n            return True\n        else:\n            raise ValueError(\n                f\"Context variable name '{variable}' is not valid.\")\n    return False", "test_code_list": [{"test_code": "import itertools\nimport re\nimport pytest\nINVALID_CONTEXT_PARAM_NAMES = [':', ':)', ':!', ':3', ':super\u00f1o\u00f1o',\n    ':::::this//is       \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c ', \"\"\":123 \"$%'+-?\n  jarl!! cobarde!!\"\"\"]\nDEFINITELY_NOT_CONTEXT_PARAM_NAMES = ['1234', 'foo', '', 123]\nVALID_CONTEXT_PARAM_NAMES = [':foo', ':_bar', ':bar_', ':_bar_', ':VAR',\n    ':a1234', ':snake_case', ':camelCase', ':_']\ndef test_is_context_variable():\n    for variable in VALID_CONTEXT_PARAM_NAMES:\n        assert is_context_variable(variable)\n    for variable in DEFINITELY_NOT_CONTEXT_PARAM_NAMES:\n        assert not is_context_variable(variable)\n    for variable in INVALID_CONTEXT_PARAM_NAMES:\n        expected_message = re.escape(\n            f\"Context variable name '{variable}' is not valid.\")\n        with pytest.raises(ValueError, match=expected_message):\n            _ = is_context_variable(variable)\ntest_is_context_variable()", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/conditions/test_context.py"}], "instruction": "Functionality: This function checks whether a given variable is a valid context variable. A context variable is defined as a string that begins with a colon (:) followed by a valid Python variable name. The valid variable name starts with a letter or an underscore (_) and is followed by any number of letters, numbers, or underscores.\n\nInputs: \n- variable: Any type of variable to be checked.\n\nOutputs: \n- True if the variable is a valid context variable.\n- False if the variable is not a context variable.\n- Raises ValueError if the variable is a string that starts with a colon but does not match the regex for a valid context variable name.", "method_code_mask": "import re\nfrom typing import Any\nfrom typing import List\nfrom typing import Union\nCONTEXT_REGEX = re.compile(':[a-zA-Z_][a-zA-Z0-9_]*')\nCONTEXT_PREFIX = ':'\n\n\ndef is_context_variable(variable) ->bool: [MASK]\n"}
