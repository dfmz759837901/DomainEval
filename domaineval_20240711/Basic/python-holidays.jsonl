{"method_name": "CountryHoliday", "full_method_name": "CountryHoliday", "method_path": "../srcdata/Basic/python-holidays/holidays/utils.py", "method_code": "import warnings\nfrom functools import lru_cache\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nfrom holidays.holiday_base import HolidayBase\nfrom holidays.registry import EntityLoader\nimport holidays\ndef CountryHoliday(country: str, subdiv: Optional[str]=None, years:\n    Optional[Union[int, Iterable[int]]]=None, expand: bool=True, observed:\n    bool=True, prov: Optional[str]=None, state: Optional[str]=None\n    ) ->HolidayBase:\n    \"\"\"\n    Deprecated name for :py:func:`country_holidays`.\n\n    :meta private:\n    \"\"\"\n    warnings.warn('CountryHoliday is deprecated, use country_holidays instead.'\n        , DeprecationWarning)\n    return country_holidays(country, subdiv, years, expand, observed, prov,\n        state)", "test_code_list": [{"test_code": "import unittest\nimport warnings\nfrom datetime import date\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nimport holidays\nfrom holidays.utils import CountryHoliday\nfrom holidays.utils import country_holidays\nfrom holidays.utils import financial_holidays\nfrom holidays.utils import list_localized_countries\nfrom holidays.utils import list_localized_financial\nfrom holidays.utils import list_supported_countries\nfrom holidays.utils import list_supported_financial\n\nclass TestCountryHolidays(unittest.TestCase):\n    def test_country_holiday_class_deprecation(self):\n        with warnings.catch_warnings(record=True) as ctx:\n            warnings.simplefilter('always')\n            CountryHoliday('IT')\n            warning = ctx[0]\n            self.assertTrue(issubclass(warning.category, DeprecationWarning))\n            self.assertIn('CountryHoliday is deprecated', str(warning.message))\n    \nTestCountryHolidays().test_country_holiday_class_deprecation()\n", "code_start": "", "test_path": "../srcdata/Basic/python-holidays/tests/test_utils.py"}], "instruction": "Functionality: The CountryHoliday function returns a list of holidays for a given country, with the option to specify subdivisions, years, and whether to include observed dates. The function is a wrapper for the 'country_holidays' function from the holidays library and is designed to deprecate its usage, instead recommending 'country_holidays' for future calls.\n\nInputs:\n- country: A string representing the country for which to retrieve holiday dates.\n- subdiv: An optional string representing the subdivision (e.g., state or province) within the country.\n- years: An optional input that can be either a single integer or an iterable of integers, specifying the years for which to return holiday dates.\n- expand: A boolean value indicating whether to expand the years if it's not a list.\n- observed: A boolean value indicating whether to return observed holiday dates if the actual date falls on a weekend.\n- prov: An optional string representing the province, if different from the subdiv.\n- state: An optional string representing the state, if different from the subdiv.\n\nOutputs:\n- The function returns an instance of HolidayBase, a class from the holidays library that contains the holiday dates for the specified parameters. The returned object can be used to retrieve holiday dates for the given country and years.", "method_code_mask": "import warnings\nfrom functools import lru_cache\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nfrom holidays.holiday_base import HolidayBase\nfrom holidays.registry import EntityLoader\nimport holidays\n\n\ndef CountryHoliday(country: str, subdiv: Optional[str]=None, years:\n    Optional[Union[int, Iterable[int]]]=None, expand: bool=True, observed:\n    bool=True, prov: Optional[str]=None, state: Optional[str]=None\n    ) ->HolidayBase: [MASK]\n"}
{"method_name": "financial_holidays", "full_method_name": "financial_holidays", "method_path": "../srcdata/Basic/python-holidays/holidays/utils.py", "method_code": "import warnings\nfrom functools import lru_cache\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nfrom holidays.holiday_base import HolidayBase\nfrom holidays.registry import EntityLoader\nimport holidays\ndef financial_holidays(market: str, subdiv: Optional[str]=None, years:\n    Optional[Union[int, Iterable[int]]]=None, expand: bool=True, observed:\n    bool=True, language: Optional[str]=None) ->HolidayBase:\n    \"\"\"\n    Returns a new dictionary-like :py:class:`HolidayBase` object for the public\n    holidays of the financial market matching **market** and other keyword\n    arguments.\n\n    :param market:\n        An ISO 3166-1 Alpha-2 market code.\n\n    :param subdiv:\n        Currently not implemented for markets (see documentation).\n\n    :param years:\n        The year(s) to pre-calculate public holidays for at instantiation.\n\n    :param expand:\n        Whether the entire year is calculated when one date from that year\n        is requested.\n\n    :param observed:\n        Whether to include the dates of when public holiday are observed\n        (e.g. a holiday falling on a Sunday being observed the following\n        Monday). False may not work for all countries.\n\n    :param language:\n        The language which the returned holiday names will be translated\n        into. It must be an ISO 639-1 (2-letter) language code. If the\n        language translation is not supported the original holiday names\n        will be used.\n\n    :return:\n        A :py:class:`HolidayBase` object matching the **market**.\n\n    Example usage:\n\n    >>> from holidays import financial_holidays\n    >>> nyse_holidays = financial_holidays('NYSE')\n\n    See :py:func:`country_holidays` documentation for further details and\n    examples.\n    \"\"\"\n    import holidays\n    try:\n        return getattr(holidays, market)(years=years, subdiv=subdiv, expand\n            =expand, observed=observed, language=language)\n    except AttributeError:\n        raise NotImplementedError(f'Financial market {market} not available')", "test_code_list": [{"test_code": "import unittest\nimport warnings\nfrom datetime import date\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nimport holidays\nfrom holidays.utils import CountryHoliday\nfrom holidays.utils import country_holidays\nfrom holidays.utils import financial_holidays\nfrom holidays.utils import list_localized_countries\nfrom holidays.utils import list_localized_financial\nfrom holidays.utils import list_supported_countries\nfrom holidays.utils import list_supported_financial\n\nclass TestFinancialHolidays(unittest.TestCase):\n    def test_market_single_year(self):\n        h = financial_holidays('NYSE', years=2021)\n        self.assertEqual(h.years, {2021})\n    \nTestFinancialHolidays().test_market_single_year()\n", "code_start": "", "test_path": "../srcdata/Basic/python-holidays/tests/test_utils.py"}, {"test_code": "import unittest\nimport warnings\nfrom datetime import date\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nimport holidays\nfrom holidays.utils import CountryHoliday\nfrom holidays.utils import country_holidays\nfrom holidays.utils import financial_holidays\nfrom holidays.utils import list_localized_countries\nfrom holidays.utils import list_localized_financial\nfrom holidays.utils import list_supported_countries\nfrom holidays.utils import list_supported_financial\n\nclass TestFinancialHolidays(unittest.TestCase):\n    def test_market_years(self):\n        h = financial_holidays('NYSE', years=(2015, 2016))\n        self.assertEqual(h.years, {2015, 2016})\n    \nTestFinancialHolidays().test_market_years()\n", "code_start": "", "test_path": "../srcdata/Basic/python-holidays/tests/test_utils.py"}, {"test_code": "import unittest\nimport warnings\nfrom datetime import date\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nimport holidays\nfrom holidays.utils import CountryHoliday\nfrom holidays.utils import country_holidays\nfrom holidays.utils import financial_holidays\nfrom holidays.utils import list_localized_countries\nfrom holidays.utils import list_localized_financial\nfrom holidays.utils import list_supported_countries\nfrom holidays.utils import list_supported_financial\n\nclass TestFinancialHolidays(unittest.TestCase):\n    def test_exceptions(self):\n        self.assertRaises(NotImplementedError, lambda : financial_holidays('XXXX'))\n        self.assertRaises(NotImplementedError, lambda : financial_holidays(\n            'NYSE', subdiv='XXXX'))\n    \nTestFinancialHolidays().test_exceptions()\n", "code_start": "", "test_path": "../srcdata/Basic/python-holidays/tests/test_utils.py"}], "instruction": "Functionality: The financial_holidays function returns a dictionary-like HolidayBase object containing the public holidays for a specified financial market. The object is populated with holidays for the specified year(s) and can include observed dates if requested.\n\nInputs:\n- market: An ISO 3166-1 Alpha-2 market code (str) indicating the financial market for which holidays are to be retrieved.\n- subdiv: An optional subdivision within the market (str) - currently not implemented for markets.\n- years: An optional single year or iterable of years (int or Iterable[int]) for which holidays are to be pre-calculated.\n- expand: A boolean (bool) indicating whether the entire year's holidays should be calculated when a date from that year is requested.\n- observed: A boolean (bool) specifying if observed dates should be included (e.g., when a holiday falls on a weekend).\n- language: An optional ISO 639-1 (2-letter) language code (str) for holiday name translations.\n\nOutputs:\n- A HolidayBase object representing the public holidays of the specified financial market, populated with holidays from the provided years and respecting the expand and observed parameters.", "method_code_mask": "import warnings\nfrom functools import lru_cache\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nfrom holidays.holiday_base import HolidayBase\nfrom holidays.registry import EntityLoader\nimport holidays\n\n\ndef financial_holidays(market: str, subdiv: Optional[str]=None, years:\n    Optional[Union[int, Iterable[int]]]=None, expand: bool=True, observed:\n    bool=True, language: Optional[str]=None) ->HolidayBase: [MASK]\n"}
{"method_name": "_get_nth_weekday_of_month", "full_method_name": "_get_nth_weekday_of_month", "method_path": "../srcdata/Basic/python-holidays/holidays/calendars/gregorian.py", "method_code": "from datetime import date\ndef _timedelta(dt: date, days: int=0) ->date:\n    \"\"\"\n    Return date that is `days` days after (days > 0) or before (days < 0) specified date.\n    \"\"\"\n    return date.fromordinal(dt.toordinal() + days)\ndef _get_nth_weekday_from(n: int, weekday: int, from_dt: date) ->date:\n    \"\"\"\n    Return date of a n-th weekday before a specific date\n    if n is negative.\n    Return date of n-th weekday after (including) a specific date\n    if n is positive.\n    Examples: 1st Monday, 2nd Saturday, etc).\n    \"\"\"\n    return _timedelta(from_dt, (n - 1) * 7 + (weekday - from_dt.weekday()) %\n        7 if n > 0 else (n + 1) * 7 - (from_dt.weekday() - weekday) % 7)\ndef _get_nth_weekday_of_month(n: int, weekday: int, month: int, year: int\n    ) ->date:\n    \"\"\"\n    Return date of n-th weekday of month for a specific year\n    (e.g. 1st Monday of Apr, 2nd Friday of June, etc).\n    If n is negative the countdown starts at the end of month\n    (i.e. -1 is last).\n    \"\"\"\n    requested_year_month = year, month\n    if n < 0:\n        month += 1\n        if month > 12:\n            month = 1\n            year += 1\n        start_date = _timedelta(date(year, month, 1), -1)\n    else:\n        start_date = date(year, month, 1)\n    dt = _get_nth_weekday_from(n, weekday, start_date)\n    dt_year_month = dt.year, dt.month\n    if dt_year_month != requested_year_month:\n        raise ValueError(f'{dt_year_month} returned for {requested_year_month}'\n            )\n    return dt", "test_code_list": [{"test_code": "from datetime import date\nfrom unittest import TestCase\nfrom holidays.calendars.gregorian import TUE\nfrom holidays.calendars.gregorian import SAT\n\nclass TestGregorianCalendar(TestCase):\n    def test_get_nth_weekday_of_month(self):\n        year = 2023\n        for month, day in enumerate((3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5), 1):\n            first_tuesday = _get_nth_weekday_of_month(1, TUE, month, year)\n            self.assertEqual(first_tuesday.day, day)\n        for month, day in enumerate((28, 25, 25, 29, 27, 24, 29, 26, 30, 28, 25,\n            30), 1):\n            last_friday = _get_nth_weekday_of_month(-1, SAT, month, year)\n            self.assertEqual(last_friday.day, day)\n    \nTestGregorianCalendar().test_get_nth_weekday_of_month()\n", "code_start": "", "test_path": "../srcdata/Basic/python-holidays/tests/calendars/test_gregorian.py"}], "instruction": "Functionality: The function _get_nth_weekday_of_month calculates and returns the date of the n-th specified weekday in a given month of a specific year. If n is negative, the function counts from the end of the month, for example, -1 is the last weekday of the specified type in the month.\n\nInputs:\nn: An integer representing the nth weekday to find. If n is positive, the function looks forward from the start of the month. If n is negative, the function looks backward from the end of the month.\nweekday: An integer representing the weekday to find. Monday is 0, Tuesday is 1, ..., Sunday is 6.\nmonth: An integer representing the month of the year in question (1 for January, 2 for February, etc.).\nyear: An integer representing the specific year.\n\nOutputs:\nA datetime.date object representing the date of the n-th weekday in the specified month of the given year.", "method_code_mask": "from datetime import date\n\n\ndef _timedelta(dt: date, days: int=0) ->date:\n    \"\"\"\n    Return date that is `days` days after (days > 0) or before (days < 0) specified date.\n    \"\"\"\n    return date.fromordinal(dt.toordinal() + days)\n\n\ndef _get_nth_weekday_from(n: int, weekday: int, from_dt: date) ->date:\n    \"\"\"\n    Return date of a n-th weekday before a specific date\n    if n is negative.\n    Return date of n-th weekday after (including) a specific date\n    if n is positive.\n    Examples: 1st Monday, 2nd Saturday, etc).\n    \"\"\"\n    return _timedelta(from_dt, (n - 1) * 7 + (weekday - from_dt.weekday()) %\n        7 if n > 0 else (n + 1) * 7 - (from_dt.weekday() - weekday) % 7)\n\n\ndef _get_nth_weekday_of_month(n: int, weekday: int, month: int, year: int\n    ) ->date: [MASK]\n"}
