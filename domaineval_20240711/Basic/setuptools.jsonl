{"method_name": "makeSetup", "full_method_name": "makeSetup", "method_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py", "method_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\ndef makeSetup(**args):\n    \"\"\"Return distribution from 'setup(**args)', without executing commands\"\"\"\n    distutils.core._setup_stop_after = 'commandline'\n    args.setdefault('script_args', ['install'])\n    try:\n        return setuptools.setup(**args)\n    finally:\n        distutils.core._setup_stop_after = None", "test_code_list": [{"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testTestIsCommand(self):\n\t    test_cmd = makeSetup().get_command_obj('test')\n\t    assert isinstance(test_cmd, distutils.cmd.Command)\n\t\nTestCommandTests().testTestIsCommand()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testLongOptSuiteWNoDefault(self):\n\t    ts1 = makeSetup(script_args=['test', '--test-suite=foo.tests.suite'])\n\t    ts1 = ts1.get_command_obj('test')\n\t    ts1.ensure_finalized()\n\t    assert ts1.test_suite == 'foo.tests.suite'\n\t\nTestCommandTests().testLongOptSuiteWNoDefault()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testDefaultSuite(self):\n\t    ts2 = makeSetup(test_suite='bar.tests.suite').get_command_obj('test')\n\t    ts2.ensure_finalized()\n\t    assert ts2.test_suite == 'bar.tests.suite'\n\t\nTestCommandTests().testDefaultSuite()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testDefaultWModuleOnCmdLine(self):\n\t    ts3 = makeSetup(test_suite='bar.tests', script_args=['test', '-m',\n\t        'foo.tests']).get_command_obj('test')\n\t    ts3.ensure_finalized()\n\t    assert ts3.test_module == 'foo.tests'\n\t    assert ts3.test_suite == 'foo.tests.test_suite'\n\t\nTestCommandTests().testDefaultWModuleOnCmdLine()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testNoSuite(self):\n\t    ts5 = makeSetup().get_command_obj('test')\n\t    ts5.ensure_finalized()\n\t    assert ts5.test_suite is None\n\t\nTestCommandTests().testNoSuite()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}], "instruction": "Functionality: The makeSetup function is designed to create a distribution object from the 'setup' function in distutils, without executing any build or installation commands. This is useful for testing setup scripts and extensions in a controlled environment. The function temporarily modifies the '_setup_stop_after' attribute of the 'distutils.core' module to 'commandline', allowing the setup process to halt before any commands are executed. It then calls 'setuptools.setup' with the provided arguments, and finally resets the '_setup_stop_after' attribute to None.\n\nInputs: The function accepts arguments in the form of keyword arguments (**args). These arguments are typically used in a setup script, and can include details such as the name of the package, its version, a list of scripts, packages, and extensions, as well as other metadata that would be passed to the 'setuptools.setup' function.\n\nOutputs: The function returns the distribution object created by 'setuptools.setup'. This distribution object contains all the metadata and configurations that were passed to the 'setup' function, but does not trigger any build or installation processes. This makes it a safe and effective way to test setup configurations without affecting the system or environment it is run in.", "method_code_mask": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\n\ndef makeSetup(**args): [MASK]\n"}
{"method_name": "get_abi3_suffix", "full_method_name": "get_abi3_suffix", "method_path": "../srcdata/Basic/setuptools/setuptools/command/build_ext.py", "method_code": "from __future__ import annotations\nimport os\nimport sys\nimport itertools\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom typing import Iterator\nfrom pathlib import Path\nfrom distutils.command.build_ext import build_ext as _du_build_ext\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom distutils.sysconfig import get_config_var\nfrom distutils import log\nfrom setuptools.errors import BaseError\nfrom setuptools.extension import Extension\nfrom setuptools.extension import Library\nfrom distutils.sysconfig import _config_vars as _CONFIG_VARS\nfrom distutils.util import byte_compile\ndef get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix in EXTENSION_SUFFIXES:\n        if '.abi3' in suffix:\n            return suffix\n        elif suffix == '.pyd':\n            return suffix\n    return None", "test_code_list": [{"test_code": "import os\nimport sys\nimport distutils.command.build_ext as orig\nfrom distutils.sysconfig import get_config_var\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.build_ext import get_abi3_suffix\nfrom setuptools.dist import Distribution\nfrom setuptools.extension import Extension\nfrom setuptools.errors import CompileError\nimport pytest\n\nclass TestBuildExt():\n\tdef test_abi3_filename(self):\n\t    \"\"\"\n\t        Filename needs to be loadable by several versions\n\t        of Python 3 if 'is_abi3' is truthy on Extension()\n\t        \"\"\"\n\t    print(get_abi3_suffix())\n\t    extension = Extension('spam.eggs', ['eggs.c'], py_limited_api=True)\n\t    dist = Distribution(dict(ext_modules=[extension]))\n\t    cmd = build_ext(dist)\n\t    cmd.finalize_options()\n\t    assert 'spam.eggs' in cmd.ext_map\n\t    res = cmd.get_ext_filename('spam.eggs')\n\t    if not get_abi3_suffix():\n\t        assert res.endswith(get_config_var('EXT_SUFFIX'))\n\t    elif sys.platform == 'win32':\n\t        assert res.endswith('eggs.pyd')\n\t    else:\n\t        assert 'abi3' in res\n\t\nTestBuildExt().test_abi3_filename()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_build_ext.py"}], "instruction": "Functionality: The get_abi3_suffix function is designed to determine and return the file extension that is used for a Python Extension module which is compliant with the abi3 (Application Binary Interface version 3) standard. This is crucial for ensuring compatibility across different Python installations.\n\nInputs: This function does not take any input arguments. It relies on predefined constants and variables within the Python environment, such as EXTENSION_SUFFIXES, to determine the correct extension.\n\nOutputs: The function returns a string representing the file extension for an abi3-compliant Extension module. If a suffix containing '.abi3' is found, it is returned. If not, and if the environment is on Windows, '.pyd' is returned. If no suitable suffix is found, the function returns None.", "method_code_mask": "from __future__ import annotations\nimport os\nimport sys\nimport itertools\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom typing import Iterator\nfrom pathlib import Path\nfrom distutils.command.build_ext import build_ext as _du_build_ext\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom distutils.sysconfig import get_config_var\nfrom distutils import log\nfrom setuptools.errors import BaseError\nfrom setuptools.extension import Extension\nfrom setuptools.extension import Library\nfrom distutils.sysconfig import _config_vars as _CONFIG_VARS\nfrom distutils.util import byte_compile\n\n\ndef get_abi3_suffix(): [MASK]\n"}
{"method_name": "from_param", "full_method_name": "CommandSpec.from_param", "method_path": "../srcdata/Basic/setuptools/setuptools/command/easy_install.py", "method_code": "from __future__ import annotations\nfrom glob import glob\nfrom distutils.util import get_platform\nfrom distutils.util import convert_path\nfrom distutils.util import subst_vars\nfrom distutils.errors import DistutilsArgError\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsError\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils import log\nfrom distutils import dir_util\nfrom distutils.command.build_scripts import first_line_re\nfrom distutils.command import install\nimport sys\nimport os\nimport zipimport\nimport shutil\nimport tempfile\nimport zipfile\nimport re\nimport stat\nimport random\nimport textwrap\nimport warnings\nimport site\nimport struct\nimport contextlib\nimport subprocess\nimport shlex\nimport io\nimport configparser\nimport sysconfig\nfrom sysconfig import get_path\nfrom setuptools import Command\nfrom setuptools.sandbox import run_setup\nfrom setuptools.command import setopt\nfrom setuptools.archive_util import unpack_archive\nfrom setuptools.package_index import PackageIndex\nfrom setuptools.package_index import parse_requirement_arg\nfrom setuptools.package_index import URL_SCHEME\nfrom setuptools.command import bdist_egg\nfrom setuptools.command import egg_info\nfrom setuptools.warnings import SetuptoolsDeprecationWarning\nfrom setuptools.warnings import SetuptoolsWarning\nfrom setuptools.wheel import Wheel\nfrom pkg_resources import normalize_path\nfrom pkg_resources import resource_string\nfrom pkg_resources import get_distribution\nfrom pkg_resources import find_distributions\nfrom pkg_resources import Environment\nfrom pkg_resources import Requirement\nfrom pkg_resources import Distribution\nfrom pkg_resources import PathMetadata\nfrom pkg_resources import EggMetadata\nfrom pkg_resources import WorkingSet\nfrom pkg_resources import DistributionNotFound\nfrom pkg_resources import VersionConflict\nfrom pkg_resources import DEVELOP_DIST\nimport pkg_resources\nfrom distutils import file_util\nfrom distutils.spawn import spawn\nfrom distutils.util import byte_compile\nfrom os import chmod as _chmod\nclass CommandSpec(list):\n    \"\"\"\n    A command spec for a #! header, specified as a list of arguments akin to\n    those passed to Popen.\n    \"\"\"\n    options: list[str] = []\n    split_args: dict[str, bool] = dict()\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Choose the best CommandSpec class based on environmental conditions.\n        \"\"\"\n        return cls\n\n    @classmethod\n    def _sys_executable(cls):\n        _default = os.path.normpath(sys.executable)\n        return os.environ.get('__PYVENV_LAUNCHER__', _default)\n\n    @classmethod\n    def from_param(cls, param):\n        \"\"\"\n        Construct a CommandSpec from a parameter to build_scripts, which may\n        be None.\n        \"\"\"\n        if isinstance(param, cls):\n            return param\n        if isinstance(param, list):\n            return cls(param)\n        if param is None:\n            return cls.from_environment()\n        return cls.from_string(param)\n\n    @classmethod\n    def from_environment(cls):\n        return cls([cls._sys_executable()])\n\n    @classmethod\n    def from_string(cls, string):\n        \"\"\"\n        Construct a command spec from a simple string representing a command\n        line parseable by shlex.split.\n        \"\"\"\n        items = shlex.split(string, **cls.split_args)\n        return cls(items)\n\n    def install_options(self, script_text):\n        self.options = shlex.split(self._extract_options(script_text))\n        cmdline = subprocess.list2cmdline(self)\n        if not isascii(cmdline):\n            self.options[:0] = ['-x']\n\n    @staticmethod\n    def _extract_options(orig_script):\n        \"\"\"\n        Extract any options from the first line of the script.\n        \"\"\"\n        first = (orig_script + '\\n').splitlines()[0]\n        match = _first_line_re().match(first)\n        options = match.group(1) or '' if match else ''\n        return options.strip()\n\n    def as_header(self):\n        return self._render(self + list(self.options))\n\n    @staticmethod\n    def _strip_quotes(item):\n        _QUOTES = '\"\\''\n        for q in _QUOTES:\n            if item.startswith(q) and item.endswith(q):\n                return item[1:-1]\n        return item\n\n    @staticmethod\n    def _render(items):\n        cmdline = subprocess.list2cmdline(CommandSpec._strip_quotes(item.\n            strip()) for item in items)\n        return '#!' + cmdline + '\\n'", "test_code_list": [{"test_code": "import sys\nimport os\nimport tempfile\nimport site\nimport contextlib\nimport tarfile\nimport logging\nimport itertools\nimport distutils.errors\nimport io\nfrom typing import NamedTuple\nimport zipfile\nimport time\nimport re\nimport subprocess\nimport pathlib\nimport warnings\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nfrom setuptools import sandbox\nfrom setuptools.sandbox import run_setup\nimport setuptools.command.easy_install as ei\nfrom setuptools.command.easy_install import PthDistributions\nfrom setuptools.dist import Distribution\nfrom pkg_resources import normalize_path\nfrom pkg_resources import working_set\nfrom pkg_resources import Distribution as PRDistribution\nimport pkg_resources\n\nclass TestCommandSpec():\n\tdef test_from_simple_string_uses_shlex(self):\n\t    \"\"\"\n\t        In order to support `executable = /usr/bin/env my-python`, make sure\n\t        from_param invokes shlex on that input.\n\t        \"\"\"\n\t    cmd = CommandSpec.from_param('/usr/bin/env my-python')\n\t    assert len(cmd) == 2\n\t    assert '\"' not in cmd.as_header()\n\t\nTestCommandSpec().test_from_simple_string_uses_shlex()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_easy_install.py"}], "instruction": "Functionality: The CommandSpec class is a utility for managing command specifications in a way that is suitable for use in #! headers of scripts. It offers methods to construct a command specification from various inputs, including direct parameterization, environment settings, and strings. The from_param function is a specific method within the CommandSpec class, aimed at generating a command specification from a build_scripts parameter.\n\nInputs: \n1. param: This parameter can take one of several forms:\n   a. None: This signifies that the command should be derived from the system's environment.\n   b. CommandSpec: If the parameter is already an instance of CommandSpec, it is directly returned.\n   c. List: A list of arguments similar to those passed to Popen.\n   d. String: A command line string that can be split using shlex.split and converted into a CommandSpec.\n\nOutputs:\n1. CommandSpec: Returns a new instance of CommandSpec populated based on the input parameter. If the input is None, the command is derived from the system environment. If the input is a list, it directly creates a CommandSpec from that list. If the input is a string, it parses the string and creates a CommandSpec from the parsed arguments.", "method_code_mask": "from __future__ import annotations\nfrom glob import glob\nfrom distutils.util import get_platform\nfrom distutils.util import convert_path\nfrom distutils.util import subst_vars\nfrom distutils.errors import DistutilsArgError\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsError\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils import log\nfrom distutils import dir_util\nfrom distutils.command.build_scripts import first_line_re\nfrom distutils.command import install\nimport sys\nimport os\nimport zipimport\nimport shutil\nimport tempfile\nimport zipfile\nimport re\nimport stat\nimport random\nimport textwrap\nimport warnings\nimport site\nimport struct\nimport contextlib\nimport subprocess\nimport shlex\nimport io\nimport configparser\nimport sysconfig\nfrom sysconfig import get_path\nfrom setuptools import Command\nfrom setuptools.sandbox import run_setup\nfrom setuptools.command import setopt\nfrom setuptools.archive_util import unpack_archive\nfrom setuptools.package_index import PackageIndex\nfrom setuptools.package_index import parse_requirement_arg\nfrom setuptools.package_index import URL_SCHEME\nfrom setuptools.command import bdist_egg\nfrom setuptools.command import egg_info\nfrom setuptools.warnings import SetuptoolsDeprecationWarning\nfrom setuptools.warnings import SetuptoolsWarning\nfrom setuptools.wheel import Wheel\nfrom pkg_resources import normalize_path\nfrom pkg_resources import resource_string\nfrom pkg_resources import get_distribution\nfrom pkg_resources import find_distributions\nfrom pkg_resources import Environment\nfrom pkg_resources import Requirement\nfrom pkg_resources import Distribution\nfrom pkg_resources import PathMetadata\nfrom pkg_resources import EggMetadata\nfrom pkg_resources import WorkingSet\nfrom pkg_resources import DistributionNotFound\nfrom pkg_resources import VersionConflict\nfrom pkg_resources import DEVELOP_DIST\nimport pkg_resources\nfrom distutils import file_util\nfrom distutils.spawn import spawn\nfrom distutils.util import byte_compile\nfrom os import chmod as _chmod\n\n\nclass CommandSpec(list):\n    \"\"\"\n    A command spec for a #! header, specified as a list of arguments akin to\n    those passed to Popen.\n    \"\"\"\n    options: list[str] = []\n    split_args: dict[str, bool] = dict()\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Choose the best CommandSpec class based on environmental conditions.\n        \"\"\"\n        return cls\n\n    @classmethod\n    def _sys_executable(cls):\n        _default = os.path.normpath(sys.executable)\n        return os.environ.get('__PYVENV_LAUNCHER__', _default)\n\n    @classmethod\n    def from_param(cls, param): [MASK]\n\n    @classmethod\n    def from_environment(cls):\n        return cls([cls._sys_executable()])\n\n    @classmethod\n    def from_string(cls, string):\n        \"\"\"\n        Construct a command spec from a simple string representing a command\n        line parseable by shlex.split.\n        \"\"\"\n        items = shlex.split(string, **cls.split_args)\n        return cls(items)\n\n    def install_options(self, script_text):\n        self.options = shlex.split(self._extract_options(script_text))\n        cmdline = subprocess.list2cmdline(self)\n        if not isascii(cmdline):\n            self.options[:0] = ['-x']\n\n    @staticmethod\n    def _extract_options(orig_script):\n        \"\"\"\n        Extract any options from the first line of the script.\n        \"\"\"\n        first = (orig_script + '\\n').splitlines()[0]\n        match = _first_line_re().match(first)\n        options = match.group(1) or '' if match else ''\n        return options.strip()\n\n    def as_header(self):\n        return self._render(self + list(self.options))\n\n    @staticmethod\n    def _strip_quotes(item):\n        _QUOTES = '\"\\''\n        for q in _QUOTES:\n            if item.startswith(q) and item.endswith(q):\n                return item[1:-1]\n        return item\n\n    @staticmethod\n    def _render(items):\n        cmdline = subprocess.list2cmdline(CommandSpec._strip_quotes(item.\n            strip()) for item in items)\n        return '#!' + cmdline + '\\n'\n"}
