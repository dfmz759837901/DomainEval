{"method_name": "encode_cf_datetime", "full_method_name": "encode_cf_datetime", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef encode_cf_datetime(dates: T_DuckArray, units: (str | None)=None,\n    calendar: (str | None)=None, dtype: (np.dtype | None)=None) ->tuple[\n    T_DuckArray, str, str]:\n    \"\"\"Given an array of datetime objects, returns the tuple `(num, units,\n    calendar)` suitable for a CF compliant time variable.\n\n    Unlike `date2num`, this function can handle datetime64 arrays.\n\n    See Also\n    --------\n    cftime.date2num\n    \"\"\"\n    dates = asarray(dates)\n    if is_chunked_array(dates):\n        return _lazily_encode_cf_datetime(dates, units, calendar, dtype)\n    else:\n        return _eagerly_encode_cf_datetime(dates, units, calendar, dtype)", "test_code_list": [{"test_code": "import warnings\nfrom datetime import timedelta\nfrom itertools import product\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import conventions\nfrom xarray import date_range\nfrom xarray import decode_cf\nfrom xarray.coding.times import _STANDARD_CALENDARS as _STANDARD_CALENDARS_UNSORTED\nfrom xarray.coding.times import CFDatetimeCoder\nfrom xarray.coding.times import _encode_datetime_with_cftime\nfrom xarray.coding.times import _netcdf_to_numpy_timeunit\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import cftime_to_nptime\nfrom xarray.coding.times import decode_cf_datetime\nfrom xarray.coding.times import decode_cf_timedelta\nfrom xarray.coding.times import encode_cf_datetime\nfrom xarray.coding.times import encode_cf_timedelta\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.coding.times import infer_datetime_units\nfrom xarray.coding.times import infer_timedelta_units\nfrom xarray.coding.times import to_timedelta_unboxed\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import _update_bounds_attributes\nfrom xarray.conventions import cf_encoder\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import FirstElementAccessibleArray\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_duckarray_allclose\nfrom xarray.tests import assert_duckarray_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom datetime import datetime\nfrom xarray.core.common import _contains_cftime_datetimes\nimport dask.array\ndef test_encode_cf_datetime_pandas_min() ->None:\n    dates = pd.date_range('2000', periods=3)\n    num, units, calendar = encode_cf_datetime(dates)\n    expected_num = np.array([0.0, 1.0, 2.0])\n    expected_units = 'days since 2000-01-01 00:00:00'\n    expected_calendar = 'proleptic_gregorian'\n    np.testing.assert_array_equal(num, expected_num)\n    assert units == expected_units\n    assert calendar == expected_calendar\n\ntest_encode_cf_datetime_pandas_min()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_times.py"}], "instruction": "Functionality: The encode_cf_datetime function is designed to convert an array of datetime objects into a tuple that is compliant with the CF (Climate and Forecast) metadata conventions. This tuple contains a numerical representation of the dates, the units used for this numerical representation, and the calendar system used. This function is capable of handling both Python datetime objects and numpy.datetime64 arrays, making it versatile for data encoding needs in climate and weather data analysis.\n\nInputs: \n- dates: A T_DuckArray object containing datetime objects. This can be a list, numpy array, or any array-like object that contains datetime information.\n- units: An optional string parameter specifying the units in which the date is represented. If not provided, the function will determine an appropriate unit based on the datetime resolution.\n- calendar: An optional string parameter specifying the calendar system used for the datetime objects. If not provided, the function will default to the proleptic Gregorian calendar.\n- dtype: An optional numpy.dtype object specifying the data type for the output numerical array. If not provided, the function will determine an appropriate data type based on the datetime resolution.\n\nOutputs: \n- A tuple containing:\n    1. num: A T_DuckArray object representing the numerical values of the input dates in the specified units.\n    2. units: A string representing the units in which the dates are encoded (e.g., 'days since 1970-01-01').\n    3. calendar: A string representing the calendar system used for the encoding (e.g., 'gregorian').", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef encode_cf_datetime(dates: T_DuckArray, units: (str | None)=None,\n    calendar: (str | None)=None, dtype: (np.dtype | None)=None) ->tuple[\n    T_DuckArray, str, str]: [MASK]\n"}
{"method_name": "decode_cf_datetime", "full_method_name": "decode_cf_datetime", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef decode_cf_datetime(num_dates, units: str, calendar: (str | None)=None,\n    use_cftime: (bool | None)=None) ->np.ndarray:\n    \"\"\"Given an array of numeric dates in netCDF format, convert it into a\n    numpy array of date time objects.\n\n    For standard (Gregorian) calendars, this function uses vectorized\n    operations, which makes it much faster than cftime.num2date. In such a\n    case, the returned array will be of type np.datetime64.\n\n    Note that time unit in `units` must not be smaller than microseconds and\n    not larger than days.\n\n    See Also\n    --------\n    cftime.num2date\n    \"\"\"\n    num_dates = np.asarray(num_dates)\n    flat_num_dates = ravel(num_dates)\n    if calendar is None:\n        calendar = 'standard'\n    if use_cftime is None:\n        try:\n            dates = _decode_datetime_with_pandas(flat_num_dates, units,\n                calendar)\n        except (KeyError, OutOfBoundsDatetime, OutOfBoundsTimedelta,\n            OverflowError):\n            dates = _decode_datetime_with_cftime(flat_num_dates.astype(\n                float), units, calendar)\n            if dates[np.nanargmin(num_dates)].year < 1678 or dates[np.\n                nanargmax(num_dates)].year >= 2262:\n                if _is_standard_calendar(calendar):\n                    warnings.warn(\n                        'Unable to decode time axis into full numpy.datetime64 objects, continuing using cftime.datetime objects instead, reason: dates out of range'\n                        , SerializationWarning, stacklevel=3)\n            elif _is_standard_calendar(calendar):\n                dates = cftime_to_nptime(dates)\n    elif use_cftime:\n        dates = _decode_datetime_with_cftime(flat_num_dates, units, calendar)\n    else:\n        dates = _decode_datetime_with_pandas(flat_num_dates, units, calendar)\n    return reshape(dates, num_dates.shape)", "test_code_list": [{"test_code": "import warnings\nfrom datetime import timedelta\nfrom itertools import product\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import conventions\nfrom xarray import date_range\nfrom xarray import decode_cf\nfrom xarray.coding.times import _STANDARD_CALENDARS as _STANDARD_CALENDARS_UNSORTED\nfrom xarray.coding.times import CFDatetimeCoder\nfrom xarray.coding.times import _encode_datetime_with_cftime\nfrom xarray.coding.times import _netcdf_to_numpy_timeunit\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import cftime_to_nptime\nfrom xarray.coding.times import decode_cf_datetime\nfrom xarray.coding.times import decode_cf_timedelta\nfrom xarray.coding.times import encode_cf_datetime\nfrom xarray.coding.times import encode_cf_timedelta\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.coding.times import infer_datetime_units\nfrom xarray.coding.times import infer_timedelta_units\nfrom xarray.coding.times import to_timedelta_unboxed\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import _update_bounds_attributes\nfrom xarray.conventions import cf_encoder\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import FirstElementAccessibleArray\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_duckarray_allclose\nfrom xarray.tests import assert_duckarray_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom datetime import datetime\nfrom xarray.core.common import _contains_cftime_datetimes\nimport dask.array\ndef test_decode_cf_datetime_non_standard_units() ->None:\n    expected = pd.date_range(periods=100, start='1970-01-01', freq='h')\n    units = 'hours since 1-1-1970'\n    actual = decode_cf_datetime(np.arange(100), units)\n    assert_array_equal(actual, expected)\n\ntest_decode_cf_datetime_non_standard_units()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_times.py"}, {"test_code": "import warnings\nfrom datetime import timedelta\nfrom itertools import product\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import conventions\nfrom xarray import date_range\nfrom xarray import decode_cf\nfrom xarray.coding.times import _STANDARD_CALENDARS as _STANDARD_CALENDARS_UNSORTED\nfrom xarray.coding.times import CFDatetimeCoder\nfrom xarray.coding.times import _encode_datetime_with_cftime\nfrom xarray.coding.times import _netcdf_to_numpy_timeunit\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import cftime_to_nptime\nfrom xarray.coding.times import decode_cf_datetime\nfrom xarray.coding.times import decode_cf_timedelta\nfrom xarray.coding.times import encode_cf_datetime\nfrom xarray.coding.times import encode_cf_timedelta\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.coding.times import infer_datetime_units\nfrom xarray.coding.times import infer_timedelta_units\nfrom xarray.coding.times import to_timedelta_unboxed\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import _update_bounds_attributes\nfrom xarray.conventions import cf_encoder\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import FirstElementAccessibleArray\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_duckarray_allclose\nfrom xarray.tests import assert_duckarray_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom datetime import datetime\nfrom xarray.core.common import _contains_cftime_datetimes\nimport dask.array\ndef test_decode_float_datetime():\n    num_dates = np.array([1867128, 1867134, 1867140], dtype='float32')\n    units = 'hours since 1800-01-01'\n    calendar = 'standard'\n    expected = np.array(['2013-01-01T00:00:00', '2013-01-01T06:00:00',\n        '2013-01-01T12:00:00'], dtype='datetime64[ns]')\n    actual = decode_cf_datetime(num_dates, units=units, calendar=calendar,\n        use_cftime=False)\n    np.testing.assert_equal(actual, expected)\n\ntest_decode_float_datetime()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_times.py"}], "instruction": "Functionality: The decode_cf_datetime function is designed to convert an array of numeric dates, formatted in the netCDF standard, into a numpy array of datetime objects. This function is optimized for speed, especially when dealing with standard (Gregorian) calendars, where it utilizes vectorized operations to outperform slower alternatives like cftime.num2date. The output array's type will be np.datetime64 for standard calendars. The function handles unit conversions and can gracefully fall back to using cftime.datetime objects when dates are out of range for np.datetime64.\n\nInputs: \n- num_dates: An array-like object containing numeric representations of dates. This input is converted to a numpy array internally.\n- units: A string specifying the unit of time and the reference date for the numeric dates. For example, 'days since 2000-01-01'.\n- calendar: A string or None specifying the calendar system used by the numeric dates. If not provided, the standard (Gregorian) calendar is assumed.\n- use_cftime: A boolean or None option to force or avoid the use of cftime for decoding. If None (default), the function will automatically choose the most efficient method.\n\nOutputs:\n- A numpy array of datetime objects corresponding to the input numeric dates. The type of the datetime objects will be np.datetime64 if possible, or cftime.datetime if the dates are out of np.datetime64's range or when use_cftime is True.", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef decode_cf_datetime(num_dates, units: str, calendar: (str | None)=None,\n    use_cftime: (bool | None)=None) ->np.ndarray: [MASK]\n"}
{"method_name": "decode_cf_timedelta", "full_method_name": "decode_cf_timedelta", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef decode_cf_timedelta(num_timedeltas, units: str) ->np.ndarray:\n    \"\"\"Given an array of numeric timedeltas in netCDF format, convert it into a\n    numpy timedelta64[ns] array.\n    \"\"\"\n    num_timedeltas = np.asarray(num_timedeltas)\n    units = _netcdf_to_numpy_timeunit(units)\n    result = to_timedelta_unboxed(ravel(num_timedeltas), unit=units)\n    return reshape(result, num_timedeltas.shape)", "test_code_list": [{"test_code": "import warnings\nfrom datetime import timedelta\nfrom itertools import product\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import conventions\nfrom xarray import date_range\nfrom xarray import decode_cf\nfrom xarray.coding.times import _STANDARD_CALENDARS as _STANDARD_CALENDARS_UNSORTED\nfrom xarray.coding.times import CFDatetimeCoder\nfrom xarray.coding.times import _encode_datetime_with_cftime\nfrom xarray.coding.times import _netcdf_to_numpy_timeunit\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import cftime_to_nptime\nfrom xarray.coding.times import decode_cf_datetime\nfrom xarray.coding.times import decode_cf_timedelta\nfrom xarray.coding.times import encode_cf_datetime\nfrom xarray.coding.times import encode_cf_timedelta\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.coding.times import infer_datetime_units\nfrom xarray.coding.times import infer_timedelta_units\nfrom xarray.coding.times import to_timedelta_unboxed\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import _update_bounds_attributes\nfrom xarray.conventions import cf_encoder\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import FirstElementAccessibleArray\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_duckarray_allclose\nfrom xarray.tests import assert_duckarray_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom datetime import datetime\nfrom xarray.core.common import _contains_cftime_datetimes\nimport dask.array\ndef test_cf_timedelta_2d() ->None:\n    units = 'days'\n    numbers = np.atleast_2d([1, 2, 3])\n    timedeltas = np.atleast_2d(to_timedelta_unboxed(['1D', '2D', '3D']))\n    expected = timedeltas\n    actual = decode_cf_timedelta(numbers, units)\n    assert_array_equal(expected, actual)\n    assert expected.dtype == actual.dtype\n\ntest_cf_timedelta_2d()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_times.py"}], "instruction": "Functionality: The decode_cf_timedelta function is designed to transform an array of numeric timedeltas, provided in netCDF format, into a numpy timedelta64[ns] array, suitable for high-precision temporal calculations and analysis.\nInputs: \n    - num_timedeltas: A numpy array containing numeric representations of timedeltas in the netCDF format.\n    - units: A string specifying the units of the timedeltas in the num_timedeltas array. This must be in a format that can be understood by the function to convert it to nanoseconds (ns), which is the unit used by numpy's timedelta64[ns].\nOutputs: \n    - A numpy array of timedelta64[ns] objects, representing the timedeltas from the input array, reshaped to match the original shape of the num_timedeltas array. This output array is ready for use in further temporal computations and analyses.", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef decode_cf_timedelta(num_timedeltas, units: str) ->np.ndarray: [MASK]\n"}
{"method_name": "_update_bounds_attributes", "full_method_name": "_update_bounds_attributes", "method_path": "../srcdata/Basic/xarray/xarray/conventions.py", "method_code": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\ndef _update_bounds_attributes(variables: T_Variables) ->None:\n    \"\"\"Adds time attributes to time bounds variables.\n\n    Variables handling time bounds (\"Cell boundaries\" in the CF\n    conventions) do not necessarily carry the necessary attributes to be\n    decoded. This copies the attributes from the time variable to the\n    associated boundaries.\n\n    See Also:\n\n    http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/\n         cf-conventions.html#cell-boundaries\n\n    https://github.com/pydata/xarray/issues/2565\n    \"\"\"\n    for v in variables.values():\n        attrs = v.attrs\n        units = attrs.get('units')\n        has_date_units = isinstance(units, str) and 'since' in units\n        if has_date_units and 'bounds' in attrs:\n            if attrs['bounds'] in variables:\n                bounds_attrs = variables[attrs['bounds']].attrs\n                bounds_attrs.setdefault('units', attrs['units'])\n                if 'calendar' in attrs:\n                    bounds_attrs.setdefault('calendar', attrs['calendar'])", "test_code_list": [{"test_code": "import warnings\nfrom datetime import timedelta\nfrom itertools import product\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import conventions\nfrom xarray import date_range\nfrom xarray import decode_cf\nfrom xarray.coding.times import _STANDARD_CALENDARS as _STANDARD_CALENDARS_UNSORTED\nfrom xarray.coding.times import CFDatetimeCoder\nfrom xarray.coding.times import _encode_datetime_with_cftime\nfrom xarray.coding.times import _netcdf_to_numpy_timeunit\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import cftime_to_nptime\nfrom xarray.coding.times import decode_cf_datetime\nfrom xarray.coding.times import decode_cf_timedelta\nfrom xarray.coding.times import encode_cf_datetime\nfrom xarray.coding.times import encode_cf_timedelta\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.coding.times import infer_datetime_units\nfrom xarray.coding.times import infer_timedelta_units\nfrom xarray.coding.times import to_timedelta_unboxed\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import _update_bounds_attributes\nfrom xarray.conventions import cf_encoder\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import FirstElementAccessibleArray\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_duckarray_allclose\nfrom xarray.tests import assert_duckarray_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom datetime import datetime\nfrom xarray.core.common import _contains_cftime_datetimes\nimport dask.array\ndef test_decode_cf_time_bounds() ->None:\n    da = DataArray(np.arange(6, dtype='int64').reshape((3, 2)), coords={\n        'time': [1, 2, 3]}, dims=('time', 'nbnd'), name='time_bnds')\n    attrs = {'units': 'days since 2001-01', 'calendar': 'standard',\n        'bounds': 'time_bnds'}\n    ds = da.to_dataset()\n    ds['time'].attrs.update(attrs)\n    _update_bounds_attributes(ds.variables)\n    assert ds.variables['time_bnds'].attrs == {'units':\n        'days since 2001-01', 'calendar': 'standard'}\n    dsc = decode_cf(ds)\n    assert dsc.time_bnds.dtype == np.dtype('M8[ns]')\n    dsc = decode_cf(ds, decode_times=False)\n    assert dsc.time_bnds.dtype == np.dtype('int64')\n    ds = da.to_dataset()\n    ds['time'].attrs.update(attrs)\n    bnd_attr = {'units': 'hours since 2001-01', 'calendar': 'noleap'}\n    ds['time_bnds'].attrs.update(bnd_attr)\n    _update_bounds_attributes(ds.variables)\n    assert ds.variables['time_bnds'].attrs == bnd_attr\n    ds = da.to_dataset()\n    ds['time'].attrs.update(attrs)\n    ds['time'].attrs['bounds'] = 'fake_var'\n    _update_bounds_attributes(ds.variables)\n\ntest_decode_cf_time_bounds()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_times.py"}], "instruction": "Functionality: The _update_bounds_attributes function is designed to enrich time bounds variables with necessary time attributes that they might be missing. This is crucial for decoding time bounds data, which is often associated with \"Cell boundaries\" according to the CF conventions. The function iterates through a given dictionary of variables, identifies those that represent time bounds, and copies the required attributes from the associated time variable to the bounds variable.\n\nInputs: \n    variables: A dictionary (T_Variables) containing Variable objects. Each Variable object represents a variable in a dataset, and it includes attributes that define its properties. This dictionary is the primary input, and the function checks each Variable object to determine if it is a time bounds variable that needs attribute updates.\n\nOutputs:\n    None: The function modifies the input dictionary in place by updating the attributes of the time bounds variables. It does not return any value but ensures that the time bounds variables now carry the necessary attributes ('units' and 'calendar') for proper decoding.\n\nNote: The function assumes that the 'units' property of a time variable contains the string 'since' to identify a time bound variable. If a time bound variable is found, and if the 'bounds' attribute points to a valid variable in the input dictionary, the function will update the 'units' attribute of the bounds variable. If the original time variable has a 'calendar' attribute, this will also be copied to the bounds variable.", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\n\n\ndef _update_bounds_attributes(variables: T_Variables) ->None: [MASK]\n"}
{"method_name": "decode_cf_variable", "full_method_name": "decode_cf_variable", "method_path": "../srcdata/Basic/xarray/xarray/conventions.py", "method_code": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\ndef decode_cf_variable(name: Hashable, var: Variable, concat_characters:\n    bool=True, mask_and_scale: bool=True, decode_times: bool=True,\n    decode_endianness: bool=True, stack_char_dim: bool=True, use_cftime: (\n    bool | None)=None, decode_timedelta: (bool | None)=None) ->Variable:\n    \"\"\"\n    Decodes a variable which may hold CF encoded information.\n\n    This includes variables that have been masked and scaled, which\n    hold CF style time variables (this is almost always the case if\n    the dataset has been serialized) and which have strings encoded\n    as character arrays.\n\n    Parameters\n    ----------\n    name : str\n        Name of the variable. Used for better error messages.\n    var : Variable\n        A variable holding potentially CF encoded information.\n    concat_characters : bool\n        Should character arrays be concatenated to strings, for\n        example: [\"h\", \"e\", \"l\", \"l\", \"o\"] -> \"hello\"\n    mask_and_scale : bool\n        Lazily scale (using scale_factor and add_offset) and mask\n        (using _FillValue). If the _Unsigned attribute is present\n        treat integer arrays as unsigned.\n    decode_times : bool\n        Decode cf times (\"hours since 2000-01-01\") to np.datetime64.\n    decode_endianness : bool\n        Decode arrays from non-native to native endianness.\n    stack_char_dim : bool\n        Whether to stack characters into bytes along the last dimension of this\n        array. Passed as an argument because we need to look at the full\n        dataset to figure out if this is appropriate.\n    use_cftime : bool, optional\n        Only relevant if encoded dates come from a standard calendar\n        (e.g. \"gregorian\", \"proleptic_gregorian\", \"standard\", or not\n        specified).  If None (default), attempt to decode times to\n        ``np.datetime64[ns]`` objects; if this is not possible, decode times to\n        ``cftime.datetime`` objects. If True, always decode times to\n        ``cftime.datetime`` objects, regardless of whether or not they can be\n        represented using ``np.datetime64[ns]`` objects.  If False, always\n        decode times to ``np.datetime64[ns]`` objects; if this is not possible\n        raise an error.\n\n    Returns\n    -------\n    out : Variable\n        A variable holding the decoded equivalent of var.\n    \"\"\"\n    if _contains_datetime_like_objects(var):\n        return var\n    original_dtype = var.dtype\n    if decode_timedelta is None:\n        decode_timedelta = decode_times\n    if concat_characters:\n        if stack_char_dim:\n            var = strings.CharacterArrayCoder().decode(var, name=name)\n        var = strings.EncodedStringCoder().decode(var)\n    if original_dtype == object:\n        var = variables.ObjectVLenStringCoder().decode(var)\n        original_dtype = var.dtype\n    if mask_and_scale:\n        for coder in [variables.UnsignedIntegerCoder(), variables.\n            CFMaskCoder(), variables.CFScaleOffsetCoder()]:\n            var = coder.decode(var, name=name)\n    if decode_timedelta:\n        var = times.CFTimedeltaCoder().decode(var, name=name)\n    if decode_times:\n        var = times.CFDatetimeCoder(use_cftime=use_cftime).decode(var, name\n            =name)\n    if decode_endianness and not var.dtype.isnative:\n        var = variables.EndianCoder().decode(var)\n        original_dtype = var.dtype\n    var = variables.BooleanCoder().decode(var)\n    dimensions, data, attributes, encoding = variables.unpack_for_decoding(var)\n    encoding.setdefault('dtype', original_dtype)\n    if not is_duck_dask_array(data):\n        data = indexing.LazilyIndexedArray(data)\n    return Variable(dimensions, data, attributes, encoding=encoding,\n        fastpath=True)", "test_code_list": [{"test_code": "import contextlib\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import Dataset\nfrom xarray import SerializationWarning\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray import open_dataset\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.memory import InMemoryDataStore\nfrom xarray.conventions import decode_cf\nfrom xarray.testing import assert_identical\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests.test_backends import CFEncodedBase\nfrom datetime import datetime\nimport dask.array as da\ndef test_decode_cf_variable_timedelta64():\n    variable = Variable(['time'], pd.timedelta_range('1D', periods=2))\n    decoded = decode_cf_variable('time', variable)\n    assert decoded.encoding == {}\n    assert_identical(decoded, variable)\n\ntest_decode_cf_variable_timedelta64()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_conventions.py"}, {"test_code": "import contextlib\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import Dataset\nfrom xarray import SerializationWarning\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray import open_dataset\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.memory import InMemoryDataStore\nfrom xarray.conventions import decode_cf\nfrom xarray.testing import assert_identical\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests.test_backends import CFEncodedBase\nfrom datetime import datetime\nimport dask.array as da\ndef test_decode_cf_variable_datetime64():\n    variable = Variable(['time'], pd.date_range('2000', periods=2))\n    decoded = decode_cf_variable('time', variable)\n    assert decoded.encoding == {}\n    assert_identical(decoded, variable)\n\ntest_decode_cf_variable_datetime64()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_conventions.py"}], "instruction": "Functionality: The decode_cf_variable function decodes a variable which may hold CF (Climate and Forecast) encoded information. It handles variables masked and scaled, CF style time variables, and strings encoded as character arrays.\n\nInputs:\n- name (Hashable): Name of the variable, used for better error messages.\n- var (Variable): A variable holding potentially CF encoded information.\n- concat_characters (bool): Should character arrays be concatenated to strings?\n- mask_and_scale (bool): Should scaling and masking be applied using scale_factor, add_offset, and _FillValue?\n- decode_times (bool): Should CF times be decoded to np.datetime64?\n- decode_endianness (bool): Should arrays be decoded from non-native to native endianness?\n- stack_char_dim (bool): Should characters be stacked into bytes along the last dimension of the array?\n- use_cftime (bool | None): Determines the decoding method for standard calendar encoded dates.\n- decode_timedelta (bool | None): Determines if CF time deltas should be decoded.\n\nOutputs:\n- Variable: A variable holding the decoded equivalent of the input variable.", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\n\n\ndef decode_cf_variable(name: Hashable, var: Variable, concat_characters:\n    bool=True, mask_and_scale: bool=True, decode_times: bool=True,\n    decode_endianness: bool=True, stack_char_dim: bool=True, use_cftime: (\n    bool | None)=None, decode_timedelta: (bool | None)=None) ->Variable: [MASK]\n"}
{"method_name": "format_dims", "full_method_name": "format_dims", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting_html.py", "method_code": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\ndef format_dims(dim_sizes, dims_with_index) ->str:\n    if not dim_sizes:\n        return ''\n    dim_css_map = {dim: (\" class='xr-has-index'\" if dim in dims_with_index else\n        '') for dim in dim_sizes}\n    dims_li = ''.join(\n        f'<li><span{dim_css_map[dim]}>{escape(str(dim))}</span>: {size}</li>'\n         for dim, size in dim_sizes.items())\n    return f\"<ul class='xr-dim-list'>{dims_li}</ul>\"", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting_html as fh\nfrom xarray.core.coordinates import Coordinates\nfrom random import randint\ndef test_format_dims_no_dims() ->None:\n    dims: dict = {}\n    dims_with_index: list = []\n    formatted = format_dims(dims, dims_with_index)\n    assert formatted == ''\n\ntest_format_dims_no_dims()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting_html.py"}, {"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting_html as fh\nfrom xarray.core.coordinates import Coordinates\nfrom random import randint\ndef test_format_dims_unsafe_dim_name() ->None:\n    dims = {'<x>': 3, 'y': 2}\n    dims_with_index: list = []\n    formatted = format_dims(dims, dims_with_index)\n    assert '&lt;x&gt;' in formatted\n\ntest_format_dims_unsafe_dim_name()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting_html.py"}, {"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting_html as fh\nfrom xarray.core.coordinates import Coordinates\nfrom random import randint\ndef test_format_dims_non_index() ->None:\n    dims, dims_with_index = {'x': 3, 'y': 2}, ['time']\n    formatted = format_dims(dims, dims_with_index)\n    assert \"class='xr-has-index'\" not in formatted\n\ntest_format_dims_non_index()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting_html.py"}, {"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting_html as fh\nfrom xarray.core.coordinates import Coordinates\nfrom random import randint\ndef test_format_dims_index() ->None:\n    dims, dims_with_index = {'x': 3, 'y': 2}, ['x']\n    formatted = format_dims(dims, dims_with_index)\n    assert \"class='xr-has-index'\" in formatted\n\ntest_format_dims_index()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting_html.py"}], "instruction": "Functionality: The function 'format_dims' is designed to generate a formatted string representation of dimensions and their respective sizes, with an option to highlight dimensions that have associated index information. The output is an HTML-formatted string that visually distinguishes dimensions with index information, enhancing the readability of dimension details.\n\nInputs: \n- dim_sizes (Mapping): A mapping where keys are dimension names (str) and values are the sizes of those dimensions (int).\n- dims_with_index (Iterable): An iterable containing the names of dimensions that have associated index information.\n\nOutputs: \n- str: A string formatted in HTML that represents the dimensions and their sizes. Dimensions included in 'dims_with_index' are visually highlighted in the output string.", "method_code_mask": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\n\n\ndef format_dims(dim_sizes, dims_with_index) ->str: [MASK]\n"}
{"method_name": "summarize_attrs", "full_method_name": "summarize_attrs", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting_html.py", "method_code": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\ndef summarize_attrs(attrs) ->str:\n    attrs_dl = ''.join(\n        f'<dt><span>{escape(str(k))} :</span></dt><dd>{escape(str(v))}</dd>'\n         for k, v in attrs.items())\n    return f\"<dl class='xr-attrs'>{attrs_dl}</dl>\"", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting_html as fh\nfrom xarray.core.coordinates import Coordinates\nfrom random import randint\ndef test_summarize_attrs_with_unsafe_attr_name_and_value() ->None:\n    attrs = {'<x>': 3, 'y': '<pd.DataFrame>'}\n    formatted = summarize_attrs(attrs)\n    assert '<dt><span>&lt;x&gt; :</span></dt>' in formatted\n    assert '<dt><span>y :</span></dt>' in formatted\n    assert '<dd>3</dd>' in formatted\n    assert '<dd>&lt;pd.DataFrame&gt;</dd>' in formatted\n\ntest_summarize_attrs_with_unsafe_attr_name_and_value()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting_html.py"}], "instruction": "Functionality: The summarize_attrs function is designed to generate an HTML representation of attributes in a dictionary format. This function takes a dictionary of attributes as input and formats it into a HTML definition list (dl) where each key-value pair is represented as a term (dt) and a description (dd), respectively. This HTML string can be useful for displaying attributes in a structured way on web pages.\nInputs: \nattrs (dict): A dictionary containing attribute names as keys and their corresponding values. The keys and values can be of any data type that can be converted to a string representation.\nOutputs: \nstr: A string containing the HTML representation of the input attributes. The output string is an HTML definition list with a class attribute 'xr-attrs', where each attribute key-value pair is formatted as a term (dt) and a description (dd).", "method_code_mask": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\n\n\ndef summarize_attrs(attrs) ->str: [MASK]\n"}
{"method_name": "maybe_coerce_to_str", "full_method_name": "maybe_coerce_to_str", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef maybe_coerce_to_str(index, original_coords):\n    \"\"\"maybe coerce a pandas Index back to a nunpy array of type str\n\n    pd.Index uses object-dtype to store str - try to avoid this for coords\n    \"\"\"\n    from xarray.core import dtypes\n    try:\n        result_type = dtypes.result_type(*original_coords)\n    except TypeError:\n        pass\n    else:\n        if result_type.kind in 'SU':\n            index = np.asarray(index, dtype=result_type.type)\n    return index", "test_code_list": [{"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\ndef test_maybe_coerce_to_str_minimal_str_dtype():\n    a = np.array(['a', 'a_long_string'])\n    index = pd.Index(['a'])\n    actual = maybe_coerce_to_str(index, [a])\n    expected = np.array('a')\n    assert_array_equal(expected, actual)\n    assert expected.dtype == actual.dtype\n\ntest_maybe_coerce_to_str_minimal_str_dtype()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}], "instruction": "Functionality: The maybe_coerce_to_str function aims to potentially convert a pandas Index back to a numpy array of type str, avoiding the use of object-dtype for storing strings in coordinates, which is the default behavior of pd.Index.\n\nInputs: \n- index: A pandas Index that might need to be coerced back to a numpy array of type str.\n- original_coords: A collection of original coordinates used to determine the type of the output array. This collection is used to infer the appropriate string type for the coerced array.\n\nOutputs:\n- index: The coerced numpy array of type str, if the original_coords suggest that the output should be of string type. If the original_coords do not imply a string type, the input index is returned unchanged.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef maybe_coerce_to_str(index, original_coords): [MASK]\n"}
{"method_name": "equivalent", "full_method_name": "equivalent", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef equivalent(first: T, second: T) ->bool:\n    \"\"\"Compare two objects for equivalence (identity or equality), using\n    array_equiv if either object is an ndarray. If both objects are lists,\n    equivalent is sequentially called on all the elements.\n    \"\"\"\n    from xarray.core import duck_array_ops\n    if first is second:\n        return True\n    if isinstance(first, np.ndarray) or isinstance(second, np.ndarray):\n        return duck_array_ops.array_equiv(first, second)\n    if isinstance(first, list) or isinstance(second, list):\n        return list_equiv(first, second)\n    return first == second or pd.isnull(first) and pd.isnull(second)", "test_code_list": [{"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass TestDictionaries():\n\tdef test_equivalent(self):\n\t    assert equivalent(0, 0)\n\t    assert equivalent(np.nan, np.nan)\n\t    assert equivalent(0, np.array(0.0))\n\t    assert equivalent([0], np.array([0]))\n\t    assert equivalent(np.array([0]), [0])\n\t    assert equivalent(np.arange(3), 1.0 * np.arange(3))\n\t    assert not equivalent(0, np.zeros(3))\n\t\nTestDictionaries().test_equivalent()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}], "instruction": "Functionality: The function equivalent checks if two objects, first and second, are equivalent. Equivalence means identity (they are the same object), equality, or array equivalence if either object is a numpy ndarray. For lists, it checks equivalence of all elements sequentially.\n\nInputs:\n    first: T - The first object to compare. T can be any type.\n    second: T - The second object to compare. T can be any type.\n\nOutputs:\n    bool - Returns True if the objects are equivalent (identity, equality, or array equivalence for ndarrays), and False otherwise.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef equivalent(first: T, second: T) ->bool: [MASK]\n"}
{"method_name": "is_uniform_spaced", "full_method_name": "is_uniform_spaced", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef is_uniform_spaced(arr, **kwargs) ->bool:\n    \"\"\"Return True if values of an array are uniformly spaced and sorted.\n\n    >>> is_uniform_spaced(range(5))\n    True\n    >>> is_uniform_spaced([-4, 0, 100])\n    False\n\n    kwargs are additional arguments to ``np.isclose``\n    \"\"\"\n    arr = np.array(arr, dtype=float)\n    diffs = np.diff(arr)\n    return bool(np.isclose(diffs.min(), diffs.max(), **kwargs))", "test_code_list": [{"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_sorted_uniform(self):\n\t    assert is_uniform_spaced(np.arange(5))\n\t\nTest_is_uniform_and_sorted().test_sorted_uniform()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}, {"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_sorted_not_uniform(self):\n\t    assert not is_uniform_spaced([-2, 1, 89])\n\t\nTest_is_uniform_and_sorted().test_sorted_not_uniform()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}, {"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_not_sorted_uniform(self):\n\t    assert not is_uniform_spaced([1, -1, 3])\n\t\nTest_is_uniform_and_sorted().test_not_sorted_uniform()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}, {"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_not_sorted_not_uniform(self):\n\t    assert not is_uniform_spaced([4, 1, 89])\n\t\nTest_is_uniform_and_sorted().test_not_sorted_not_uniform()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}, {"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_two_numbers(self):\n\t    assert is_uniform_spaced([0, 1.7])\n\t\nTest_is_uniform_and_sorted().test_two_numbers()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}, {"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_is_uniform_and_sorted():\n\tdef test_relative_tolerance(self):\n\t    assert is_uniform_spaced([0, 0.97, 2], rtol=0.1)\n\t\nTest_is_uniform_and_sorted().test_relative_tolerance()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}], "instruction": "Functionality: The function 'is_uniform_spaced' checks if the elements of a given array are uniformly spaced and sorted. It returns True if all differences between consecutive elements are equal, indicating uniform spacing, and the elements are in sorted order. If the elements are not uniformly spaced or not sorted, it returns False. The function allows additional keyword arguments to be passed to the 'np.isclose' function, which can be used to customize the comparison tolerance.\n\nInputs: \n- arr: An array-like object. It can be a Python list, a NumPy array, or any object that can be converted to a NumPy array of type float. This array is checked for uniform spacing and sorting.\n- **kwargs: Additional keyword arguments that are passed to the 'np.isclose' function. These arguments are optional and can be used to adjust the tolerance for the comparison of the differences between array elements.\n\nOutputs:\n- A boolean value indicating whether the elements of the input array are uniformly spaced and sorted. True is returned if the elements are uniformly spaced and sorted; False is returned otherwise.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef is_uniform_spaced(arr, **kwargs) ->bool: [MASK]\n"}
{"method_name": "hashable", "full_method_name": "hashable", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef hashable(v: Any) ->TypeGuard[Hashable]:\n    \"\"\"Determine whether `v` can be hashed.\"\"\"\n    try:\n        hash(v)\n    except TypeError:\n        return False\n    return True", "test_code_list": [{"test_code": "from collections.abc import Hashable\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import infix_dims\nfrom xarray.core.utils import iterate_nested\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_dask\nimport dask.array as da\n\nclass Test_hashable():\n\tdef test_hashable(self):\n\t    for v in [False, 1, (2,), (3, 4), 'four']:\n\t        assert hashable(v)\n\t    for v in [[5, 6], ['seven', '8'], {(9): 'ten'}]:\n\t        assert not hashable(v)\n\t\nTest_hashable().test_hashable()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_utils.py"}], "instruction": "Functionality: Determine whether the provided input can be hashed.\nInputs: v (Any): The input value to be checked for hashability. This can be any data type.\nOutputs: TypeGuard[Hashable]: A boolean value indicating whether the input is hashable. True if the input can be hashed, False otherwise.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef hashable(v: Any) ->TypeGuard[Hashable]: [MASK]\n"}
{"method_name": "list_engines", "full_method_name": "list_engines", "method_path": "../srcdata/Basic/xarray/xarray/backends/plugins.py", "method_code": "from __future__ import annotations\nimport functools\nimport inspect\nimport itertools\nimport sys\nimport warnings\nfrom importlib.metadata import entry_points\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.core.utils import module_available\nimport os\nfrom importlib.metadata import EntryPoint\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\n@functools.lru_cache(maxsize=1)\ndef list_engines() ->dict[str, BackendEntrypoint]:\n    \"\"\"\n    Return a dictionary of available engines and their BackendEntrypoint objects.\n\n    Returns\n    -------\n    dictionary\n\n    Notes\n    -----\n    This function lives in the backends namespace (``engs=xr.backends.list_engines()``).\n    If available, more information is available about each backend via ``engs[\"eng_name\"]``.\n\n    # New selection mechanism introduced with Python 3.10. See GH6514.\n    \"\"\"\n    if sys.version_info >= (3, 10):\n        entrypoints = entry_points(group='xarray.backends')\n    else:\n        entrypoints = entry_points().get('xarray.backends', [])\n    return build_engines(entrypoints)", "test_code_list": [{"test_code": "import sys\nfrom importlib.metadata import EntryPoint\nfrom unittest import mock\nimport pytest\nfrom xarray.backends import common\nfrom xarray.backends import plugins\nfrom xarray.tests import has_h5netcdf\nfrom xarray.tests import has_netCDF4\nfrom xarray.tests import has_pydap\nfrom xarray.tests import has_scipy\nfrom xarray.tests import has_zarr\nimport xarray\nfrom xarray.backends import list_engines\nfrom xarray.backends import refresh_engines\ndef test_lazy_import() ->None:\n    \"\"\"Test that some modules are imported in a lazy manner.\n\n    When importing xarray these should not be imported as well.\n    Only when running code for the first time that requires them.\n    \"\"\"\n    deny_list = ['cubed', 'cupy', 'dask.array', 'dask.distributed', 'flox',\n        'h5netcdf', 'matplotlib', 'nc_time_axis', 'netCDF4', 'numbagg',\n        'pint', 'pydap', 'scipy', 'sparse', 'zarr']\n    modules_backup = {}\n    for pkg in list(sys.modules.keys()):\n        for mod in (deny_list + ['xarray']):\n            if pkg.startswith(mod):\n                modules_backup[pkg] = sys.modules[pkg]\n                del sys.modules[pkg]\n                break\n    try:\n        import xarray\n        from xarray.backends import list_engines\n        list_engines()\n        is_imported = set()\n        for pkg in sys.modules:\n            for mod in deny_list:\n                if pkg.startswith(mod):\n                    is_imported.add(mod)\n                    break\n        assert len(is_imported\n            ) == 0, f'{is_imported} have been imported but should be lazy'\n    finally:\n        sys.modules.update(modules_backup)\n\ntest_lazy_import()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plugins.py"}, {"test_code": "import sys\nfrom importlib.metadata import EntryPoint\nfrom unittest import mock\nimport pytest\nfrom xarray.backends import common\nfrom xarray.backends import plugins\nfrom xarray.tests import has_h5netcdf\nfrom xarray.tests import has_netCDF4\nfrom xarray.tests import has_pydap\nfrom xarray.tests import has_scipy\nfrom xarray.tests import has_zarr\nimport xarray\nfrom xarray.backends import list_engines\nfrom xarray.backends import refresh_engines\ndef test_list_engines() ->None:\n    from xarray.backends import list_engines\n    engines = list_engines()\n    assert list_engines.cache_info().currsize == 1\n    assert ('scipy' in engines) == has_scipy\n    assert ('h5netcdf' in engines) == has_h5netcdf\n    assert ('netcdf4' in engines) == has_netCDF4\n    assert ('pydap' in engines) == has_pydap\n    assert ('zarr' in engines) == has_zarr\n    assert 'store' in engines\n\ntest_list_engines()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plugins.py"}, {"test_code": "import sys\nfrom importlib.metadata import EntryPoint\nfrom unittest import mock\nimport pytest\nfrom xarray.backends import common\nfrom xarray.backends import plugins\nfrom xarray.tests import has_h5netcdf\nfrom xarray.tests import has_netCDF4\nfrom xarray.tests import has_pydap\nfrom xarray.tests import has_scipy\nfrom xarray.tests import has_zarr\nimport xarray\nfrom xarray.backends import list_engines\nfrom xarray.backends import refresh_engines\ndef test_list_engines() ->None:\n    from xarray.backends import list_engines\n    engines = list_engines()\n    assert list_engines.cache_info().currsize == 1\n    assert ('scipy' in engines) == has_scipy\n    assert ('h5netcdf' in engines) == has_h5netcdf\n    assert ('netcdf4' in engines) == has_netCDF4\n    assert ('pydap' in engines) == has_pydap\n    assert ('zarr' in engines) == has_zarr\n    assert 'store' in engines\n\ntest_list_engines()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plugins.py"}], "instruction": "Functionality: The function 'list_engines' is designed to return a dictionary containing information about available engines and their corresponding BackendEntrypoint objects. It leverages the 'entry_points' function from 'importlib.metadata' to fetch backend entry points, which are then used to build and return the engines dictionary.\n\nInputs: There are no input arguments for this function. It uses the system's environment and available modules to determine the engines and their information.\n\nOutputs: The function returns a dictionary where the keys are the names of the available engines, and the values are BackendEntrypoint objects. Each BackendEntrypoint object contains information about a specific engine that can be used for data handling and manipulation.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport inspect\nimport itertools\nimport sys\nimport warnings\nfrom importlib.metadata import entry_points\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.core.utils import module_available\nimport os\nfrom importlib.metadata import EntryPoint\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\n\n\n@functools.lru_cache(maxsize=1)\ndef list_engines() ->dict[str, BackendEntrypoint]: [MASK]\n"}
{"method_name": "check_vlen_dtype", "full_method_name": "check_vlen_dtype", "method_path": "../srcdata/Basic/xarray/xarray/coding/strings.py", "method_code": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\ndef check_vlen_dtype(dtype):\n    if dtype.kind != 'O' or dtype.metadata is None:\n        return None\n    else:\n        return dtype.metadata.get('element_type', dtype.metadata.get('vlen'))", "test_code_list": [{"test_code": "from contextlib import suppress\nimport numpy as np\nimport pytest\nfrom xarray import Variable\nfrom xarray.coding import strings\nfrom xarray.core import indexing\nfrom xarray.tests import IndexerMaker\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_dask\nimport dask.array as da\ndef test_vlen_dtype() ->None:\n    dtype = strings.create_vlen_dtype(str)\n    assert dtype.metadata['element_type'] == str\n    assert strings.is_unicode_dtype(dtype)\n    assert not strings.is_bytes_dtype(dtype)\n    assert check_vlen_dtype(dtype) is str\n    dtype = strings.create_vlen_dtype(bytes)\n    assert dtype.metadata['element_type'] == bytes\n    assert not strings.is_unicode_dtype(dtype)\n    assert strings.is_bytes_dtype(dtype)\n    assert check_vlen_dtype(dtype) is bytes\n    dtype = np.dtype('O', metadata={'vlen': str})\n    assert check_vlen_dtype(dtype) is str\n    assert check_vlen_dtype(np.dtype(object)) is None\n\ntest_vlen_dtype()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_strings.py"}, {"test_code": "import contextlib\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import Dataset\nfrom xarray import SerializationWarning\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray import open_dataset\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.memory import InMemoryDataStore\nfrom xarray.conventions import decode_cf\nfrom xarray.testing import assert_identical\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests.test_backends import CFEncodedBase\nfrom datetime import datetime\nimport dask.array as da\ndef test_encode_cf_variable_with_vlen_dtype() ->None:\n    v = Variable(['x'], np.array(['a', 'b'], dtype=coding.strings.\n        create_vlen_dtype(str)))\n    encoded_v = conventions.encode_cf_variable(v)\n    assert encoded_v.data.dtype.kind == 'O'\n    assert check_vlen_dtype(encoded_v.data.dtype) == str\n    v = Variable(['x'], np.array([], dtype=coding.strings.create_vlen_dtype\n        (str)))\n    encoded_v = conventions.encode_cf_variable(v)\n    assert encoded_v.data.dtype.kind == 'O'\n    assert check_vlen_dtype(encoded_v.data.dtype) == str\n\ntest_encode_cf_variable_with_vlen_dtype()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_conventions.py"}], "instruction": "Functionality: The check_vlen_dtype function is designed to inspect a given data type (dtype) and determine if it is a variable-length (vlen) data type. It checks if the dtype is of object kind and if it carries metadata that defines its element type, typically used in contexts where the length of arrays can vary.\n\nInputs: \n- dtype: A numpy data type (np.dtype) that needs to be checked.\n\nOutputs: \n- If the input dtype is not of object kind ('O') or does not carry any metadata, the function returns None.\n- If the input dtype is of object kind and carries metadata, the function returns the 'element_type' or 'vlen' metadata, which specifies the type of the elements in the vlen array.", "method_code_mask": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\n\n\ndef check_vlen_dtype(dtype): [MASK]\n"}
{"method_name": "create_vlen_dtype", "full_method_name": "create_vlen_dtype", "method_path": "../srcdata/Basic/xarray/xarray/coding/strings.py", "method_code": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\ndef create_vlen_dtype(element_type):\n    if element_type not in (str, bytes):\n        raise TypeError(f'unsupported type for vlen_dtype: {element_type!r}')\n    return np.dtype('O', metadata={'element_type': element_type})", "test_code_list": [{"test_code": "from contextlib import suppress\nimport numpy as np\nimport pytest\nfrom xarray import Variable\nfrom xarray.coding import strings\nfrom xarray.core import indexing\nfrom xarray.tests import IndexerMaker\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_dask\nimport dask.array as da\ndef test_vlen_dtype() ->None:\n    dtype = create_vlen_dtype(str)\n    assert dtype.metadata['element_type'] == str\n    assert strings.is_unicode_dtype(dtype)\n    assert not strings.is_bytes_dtype(dtype)\n    assert strings.check_vlen_dtype(dtype) is str\n    dtype = create_vlen_dtype(bytes)\n    assert dtype.metadata['element_type'] == bytes\n    assert not strings.is_unicode_dtype(dtype)\n    assert strings.is_bytes_dtype(dtype)\n    assert strings.check_vlen_dtype(dtype) is bytes\n    dtype = np.dtype('O', metadata={'vlen': str})\n    assert strings.check_vlen_dtype(dtype) is str\n    assert strings.check_vlen_dtype(np.dtype(object)) is None\n\ntest_vlen_dtype()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_strings.py"}, {"test_code": "from contextlib import suppress\nimport numpy as np\nimport pytest\nfrom xarray import Variable\nfrom xarray.coding import strings\nfrom xarray.core import indexing\nfrom xarray.tests import IndexerMaker\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_dask\nimport dask.array as da\ndef test_EncodedStringCoder_encode() ->None:\n    dtype = create_vlen_dtype(str)\n    raw_data = np.array(['abc', '\u00df\u2202\u00b5\u2206'], dtype=dtype)\n    expected_data = np.array([r.encode('utf-8') for r in raw_data], dtype=\n        object)\n    coder = strings.EncodedStringCoder(allows_unicode=True)\n    raw = Variable(('x',), raw_data, encoding={'dtype': 'S1'})\n    actual = coder.encode(raw)\n    expected = Variable(('x',), expected_data, attrs={'_Encoding': 'utf-8'})\n    assert_identical(actual, expected)\n    raw = Variable(('x',), raw_data)\n    assert_identical(coder.encode(raw), raw)\n    coder = strings.EncodedStringCoder(allows_unicode=False)\n    assert_identical(coder.encode(raw), expected)\n\ntest_EncodedStringCoder_encode()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_coding_strings.py"}, {"test_code": "import contextlib\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import Dataset\nfrom xarray import SerializationWarning\nfrom xarray import Variable\nfrom xarray import cftime_range\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray import open_dataset\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.memory import InMemoryDataStore\nfrom xarray.conventions import decode_cf\nfrom xarray.testing import assert_identical\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests.test_backends import CFEncodedBase\nfrom datetime import datetime\nimport dask.array as da\ndef test_encode_cf_variable_with_vlen_dtype() ->None:\n    v = Variable(['x'], np.array(['a', 'b'], dtype=coding.strings.\n        create_vlen_dtype(str)))\n    encoded_v = conventions.encode_cf_variable(v)\n    assert encoded_v.data.dtype.kind == 'O'\n    assert coding.strings.check_vlen_dtype(encoded_v.data.dtype) == str\n    v = Variable(['x'], np.array([], dtype=create_vlen_dtype\n        (str)))\n    encoded_v = conventions.encode_cf_variable(v)\n    assert encoded_v.data.dtype.kind == 'O'\n    assert coding.strings.check_vlen_dtype(encoded_v.data.dtype) == str\n\ntest_encode_cf_variable_with_vlen_dtype()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_conventions.py"}], "instruction": "Functionality: The create_vlen_dtype function is designed to generate a variable-length (vlen) data type for use in numpy arrays, suitable for storing an array of strings or bytes of varying lengths. This function ensures that the data type metadata includes information about the type of elements it can hold, which is either strings or bytes.\n\nInputs: \n- element_type: A Python type (either str or bytes) indicating the type of elements this vlen data type will hold. This argument is mandatory.\n\nOutputs:\n- A numpy data type (dtype) object with metadata specifying the element_type. This dtype can be used to create numpy arrays capable of storing variable-length elements of the specified type.", "method_code_mask": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\n\n\ndef create_vlen_dtype(element_type): [MASK]\n"}
{"method_name": "_asarray_tuplesafe", "full_method_name": "_asarray_tuplesafe", "method_path": "../srcdata/Basic/xarray/xarray/core/indexes.py", "method_code": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\ndef _asarray_tuplesafe(values):\n    \"\"\"\n    Convert values into a numpy array of at most 1-dimension, while preserving\n    tuples.\n\n    Adapted from pandas.core.common._asarray_tuplesafe\n    \"\"\"\n    if isinstance(values, tuple):\n        result = utils.to_0d_object_array(values)\n    else:\n        result = np.asarray(values)\n        if result.ndim == 2:\n            result = np.empty(len(values), dtype=object)\n            result[:] = values\n    return result", "test_code_list": [{"test_code": "import copy\nfrom datetime import datetime\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.indexes import Hashable\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import Indexes\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.indexes import _asarray_tuplesafe\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_cftime\nfrom xarray.tests.test_coding_times import _all_cftime_date_types\ndef test_asarray_tuplesafe() ->None:\n    res = _asarray_tuplesafe(('a', 1))\n    assert isinstance(res, np.ndarray)\n    assert res.ndim == 0\n    assert res.item() == ('a', 1)\n    res = _asarray_tuplesafe([(0,), (1,)])\n    assert res.shape == (2,)\n    assert res[0] == (0,)\n    assert res[1] == (1,)\n\ntest_asarray_tuplesafe()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_indexes.py"}], "instruction": "Functionality: The _asarray_tuplesafe function is designed to convert input values into a numpy array of at most 1 dimension, with special handling for tuples. It ensures that tuples are preserved as individual elements in the resulting array, rather than being flattened. This function is particularly useful when working with data that may include tuples as elements, which should remain intact within the array structure.\n\nInputs: The function takes a single argument, 'values', which can be any object but is typically a list, array, or tuple that you want to convert to a numpy array while preserving the tuple structure.\n\nOutputs: The function returns a numpy array. If the input is a tuple, it returns a 0-dimensional object array preserving the tuple. If the input results in a 2-dimensional array, it will be converted to a 1-dimensional object array with the original elements as its contents, ensuring a maximum of 1 dimension in the output.", "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\n\n\ndef _asarray_tuplesafe(values): [MASK]\n"}
{"method_name": "safe_cast_to_index", "full_method_name": "safe_cast_to_index", "method_path": "../srcdata/Basic/xarray/xarray/core/indexes.py", "method_code": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\ndef safe_cast_to_index(array: Any) ->pd.Index:\n    \"\"\"Given an array, safely cast it to a pandas.Index.\n\n    If it is already a pandas.Index, return it unchanged.\n\n    Unlike pandas.Index, if the array has dtype=object or dtype=timedelta64,\n    this function will not attempt to do automatic type conversion but will\n    always return an index with dtype=object.\n    \"\"\"\n    from xarray.core.dataarray import DataArray\n    from xarray.core.variable import Variable\n    if isinstance(array, pd.Index):\n        index = array\n    elif isinstance(array, (DataArray, Variable)):\n        index = array._to_index()\n    elif isinstance(array, Index):\n        index = array.to_pandas_index()\n    elif isinstance(array, PandasIndexingAdapter):\n        index = array.array\n    else:\n        kwargs: dict[str, Any] = {}\n        if hasattr(array, 'dtype'):\n            if array.dtype.kind == 'O':\n                kwargs['dtype'] = 'object'\n            elif array.dtype == 'float16':\n                emit_user_level_warning(\n                    '`pandas.Index` does not support the `float16` dtype. Casting to `float64` for you, but in the future please manually cast to either `float32` and `float64`.'\n                    , category=DeprecationWarning)\n                kwargs['dtype'] = 'float64'\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)", "test_code_list": [{"test_code": "import copy\nfrom datetime import datetime\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.indexes import Hashable\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import Indexes\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.indexes import _asarray_tuplesafe\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_cftime\nfrom xarray.tests.test_coding_times import _all_cftime_date_types\ndef test_safe_cast_to_index():\n    dates = pd.date_range('2000-01-01', periods=10)\n    x = np.arange(5)\n    td = x * np.timedelta64(1, 'D')\n    for expected, array in [(dates, dates.values), (pd.Index(x, dtype=\n        object), x.astype(object)), (pd.Index(td), td), (pd.Index(td, dtype\n        =object), td.astype(object))]:\n        actual = safe_cast_to_index(array)\n        assert_array_equal(expected, actual)\n        assert expected.dtype == actual.dtype\n\ntest_safe_cast_to_index()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_indexes.py"}, {"test_code": "import copy\nfrom datetime import datetime\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.indexes import Hashable\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import Indexes\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.indexes import _asarray_tuplesafe\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import requires_cftime\nfrom xarray.tests.test_coding_times import _all_cftime_date_types\n@requires_cftime\ndef test_safe_cast_to_index_datetime_datetime():\n    dates = [datetime(1, 1, day) for day in range(1, 20)]\n    expected = pd.Index(dates)\n    actual = safe_cast_to_index(np.array(dates))\n    assert_array_equal(expected, actual)\n    assert isinstance(actual, pd.Index)\n\ntest_safe_cast_to_index_datetime_datetime()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_indexes.py"}], "instruction": "Functionality: The safe_cast_to_index function is designed to safely convert a given array to a pandas.Index object. It ensures that if the input is already a pandas.Index, it is returned unchanged. For inputs with dtype=object or dtype=timedelta64, the function prevents automatic type conversion and maintains the dtype=object. This is a crucial function for data handling in scenarios where data types need to be preserved or specifically managed.\n\nInputs: \n- array: Any\n  The input can be of any type that can be converted or cast to a pandas.Index. This includes pandas Index objects, DataArray, Variable, Index, PandasIndexingAdapter, or any other object that can be represented as a NumPy array.\n\nOutputs: \n- pd.Index\n  The function returns a pandas.Index object. If the input is already a pandas.Index, it is returned directly. Otherwise, the input is converted to a pandas.Index, taking into account the type preservation for dtype=object or dtype=timedelta64 arrays.", "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\n\n\ndef safe_cast_to_index(array: Any) ->pd.Index: [MASK]\n"}
{"method_name": "date_range_like", "full_method_name": "date_range_like", "method_path": "../srcdata/Basic/xarray/xarray/coding/cftime_offsets.py", "method_code": "from __future__ import annotations\nimport re\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.cftimeindex import _parse_iso8601_with_reso\nfrom xarray.coding.times import _is_standard_calendar\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import convert_time_or_go_back\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.pdcompat import NoDefault\nfrom xarray.core.pdcompat import count_not_none\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pdcompat import no_default\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.types import InclusiveOptions\nfrom xarray.core.types import Self\nfrom xarray.core.types import SideOptions\nfrom xarray.coding.frequencies import infer_freq\nfrom xarray.core.dataarray import DataArray\ndef date_range_like(source, calendar, use_cftime=None):\n    \"\"\"Generate a datetime array with the same frequency, start and end as\n    another one, but in a different calendar.\n\n    Parameters\n    ----------\n    source : DataArray, CFTimeIndex, or pd.DatetimeIndex\n        1D datetime array\n    calendar : str\n        New calendar name.\n    use_cftime : bool, optional\n        If True, the output uses :py:class:`cftime.datetime` objects.\n        If None (default), :py:class:`numpy.datetime64` values are used if possible.\n        If False, :py:class:`numpy.datetime64` values are used or an error is raised.\n\n    Returns\n    -------\n    DataArray\n        1D datetime coordinate with the same start, end and frequency as the\n        source, but in the new calendar. The start date is assumed to exist in\n        the target calendar. If the end date doesn't exist, the code tries 1\n        and 2 calendar days before. There is a special case when the source time\n        series is daily or coarser and the end of the input range is on the\n        last day of the month. Then the output range will also end on the last\n        day of the month in the new calendar.\n    \"\"\"\n    from xarray.coding.frequencies import infer_freq\n    from xarray.core.dataarray import DataArray\n    if not isinstance(source, (pd.DatetimeIndex, CFTimeIndex)) and (\n        isinstance(source, DataArray) and source.ndim != 1 or not\n        _contains_datetime_like_objects(source.variable)):\n        raise ValueError(\n            \"'source' must be a 1D array of datetime objects for inferring its range.\"\n            )\n    freq = infer_freq(source)\n    if freq is None:\n        raise ValueError(\n            '`date_range_like` was unable to generate a range as the source frequency was not inferable.'\n            )\n    freq = _legacy_to_new_freq(freq)\n    use_cftime = _should_cftime_be_used(source, calendar, use_cftime)\n    source_start = source.values.min()\n    source_end = source.values.max()\n    freq_as_offset = to_offset(freq)\n    if freq_as_offset.n < 0:\n        source_start, source_end = source_end, source_start\n    if is_np_datetime_like(source.dtype):\n        source_calendar = 'standard'\n        source_start = nanosecond_precision_timestamp(source_start)\n        source_end = nanosecond_precision_timestamp(source_end)\n    elif isinstance(source, CFTimeIndex):\n        source_calendar = source.calendar\n    else:\n        source_calendar = source.dt.calendar\n    if calendar == source_calendar and is_np_datetime_like(source.dtype\n        ) ^ use_cftime:\n        return source\n    date_type = get_date_type(calendar, use_cftime)\n    start = convert_time_or_go_back(source_start, date_type)\n    end = convert_time_or_go_back(source_end, date_type)\n    if source_end.day == source_end.daysinmonth and isinstance(freq_as_offset,\n        (YearEnd, QuarterEnd, MonthEnd, Day)):\n        end = end.replace(day=end.daysinmonth)\n    return date_range(start=start.isoformat(), end=end.isoformat(), freq=\n        freq, calendar=calendar)", "test_code_list": [{"test_code": "from itertools import product\nfrom typing import Callable\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import CFTimeIndex\nfrom xarray.coding.cftime_offsets import _MONTH_ABBREVIATIONS\nfrom xarray.coding.cftime_offsets import BaseCFTimeOffset\nfrom xarray.coding.cftime_offsets import Day\nfrom xarray.coding.cftime_offsets import Hour\nfrom xarray.coding.cftime_offsets import Microsecond\nfrom xarray.coding.cftime_offsets import Millisecond\nfrom xarray.coding.cftime_offsets import Minute\nfrom xarray.coding.cftime_offsets import MonthBegin\nfrom xarray.coding.cftime_offsets import MonthEnd\nfrom xarray.coding.cftime_offsets import QuarterBegin\nfrom xarray.coding.cftime_offsets import QuarterEnd\nfrom xarray.coding.cftime_offsets import Second\nfrom xarray.coding.cftime_offsets import Tick\nfrom xarray.coding.cftime_offsets import YearBegin\nfrom xarray.coding.cftime_offsets import YearEnd\nfrom xarray.coding.cftime_offsets import _days_in_month\nfrom xarray.coding.cftime_offsets import cftime_range\nfrom xarray.coding.cftime_offsets import date_range\nfrom xarray.coding.cftime_offsets import date_range_like\nfrom xarray.coding.cftime_offsets import get_date_type\nfrom xarray.coding.cftime_offsets import to_cftime_datetime\nfrom xarray.coding.cftime_offsets import to_offset\nfrom xarray.coding.frequencies import infer_freq\nfrom xarray.core.dataarray import DataArray\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_cftime\nfrom xarray.tests import requires_cftime\ndef test_date_range_like_same_calendar():\n    src = date_range('2000-01-01', periods=12, freq='6h', use_cftime=False)\n    out = date_range_like(src, 'standard', use_cftime=False)\n    assert src is out\n\ntest_date_range_like_same_calendar()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_cftime_offsets.py"}], "instruction": "Functionality: The date_range_like function generates a datetime array with the same frequency, start, and end dates as another datetime array, but in a different calendar. It is particularly useful for time series data transformation between different calendar systems, such as from the standard Gregorian calendar to a non-standard calendar supported by cftime.\n\nInputs:\n- source: A DataArray, CFTimeIndex, or pd.DatetimeIndex object representing a 1D datetime array. This array serves as the template for the frequency, start, and end dates.\n- calendar: A string representing the name of the new calendar to which the datetime array should be converted.\n- use_cftime (optional): A boolean flag to specify whether the output should use cftime.datetime objects (True), numpy.datetime64 values if possible (None), or force the use of numpy.datetime64 objects (False).\n\nOutputs:\n- A DataArray object representing a 1D datetime coordinate. This coordinate will have the same start, end, and frequency as the source, but it will be based on the new calendar specified by the 'calendar' parameter. The function assumes the start date exists in the target calendar. If the end date does not exist in the new calendar, it tries 1 and 2 calendar days before the end date. If the source time series is daily or coarser and ends on the last day of the month, the output range will also end on the last day of the month in the new calendar.", "method_code_mask": "from __future__ import annotations\nimport re\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.cftimeindex import _parse_iso8601_with_reso\nfrom xarray.coding.times import _is_standard_calendar\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import convert_time_or_go_back\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.pdcompat import NoDefault\nfrom xarray.core.pdcompat import count_not_none\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pdcompat import no_default\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.types import InclusiveOptions\nfrom xarray.core.types import Self\nfrom xarray.core.types import SideOptions\nfrom xarray.coding.frequencies import infer_freq\nfrom xarray.core.dataarray import DataArray\n\n\ndef date_range_like(source, calendar, use_cftime=None): [MASK]\n"}
{"method_name": "where", "full_method_name": "where", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef where(condition, x, y):\n    \"\"\"Three argument where() with better dtype promotion rules.\"\"\"\n    xp = get_array_namespace(condition)\n    return xp.where(condition, *as_shared_dtype([x, y], xp=xp))", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestOps():\n\tdef test_where_type_promotion(self):\n\t    result = where(np.array([True, False]), np.array([1, 2]), np.array(['a',\n\t        'b']))\n\t    assert_array_equal(result, np.array([1, 'b'], dtype=object))\n\t    result = where([True, False], np.array([1, 2], np.float32), np.nan)\n\t    assert result.dtype == np.float32\n\t    assert_array_equal(result, np.array([1, np.nan], dtype=np.float32))\n\t\nTestOps().test_where_type_promotion()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The where function is designed to return elements chosen from x or y depending on a condition. It works as a three-argument version of the numpy where function, with enhanced data type promotion rules. This function is particularly useful in scenarios where elements from two different arrays need to be selected based on a condition array.\n\nInputs:\n- condition: A NumPy array or a similar duck-array that serves as the condition. This array must be broadcastable to the shapes of x and y.\n- x: A NumPy array or similar duck-array from which elements are chosen when the 'condition' is True.\n- y: A NumPy array or similar duck-array from which elements are chosen when the 'condition' is False.\n\nOutputs:\n- A NumPy array with elements from x where 'condition' is True, and elements from y where 'condition' is False. The returned array will have the same shape as the broadcasted shapes of x and y. Data type promotion rules are applied to ensure compatibility between x and y, leading to a well-defined output data type.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef where(condition, x, y): [MASK]\n"}
{"method_name": "_is_contiguous", "full_method_name": "_is_contiguous", "method_path": "../srcdata/Basic/xarray/xarray/core/nputils.py", "method_code": "from __future__ import annotations\nimport warnings\nfrom typing import Callable\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy import RankWarning\nfrom xarray.core.options import OPTIONS\nimport bottleneck as bn\ndef _is_contiguous(positions):\n    \"\"\"Given a non-empty list, does it consist of contiguous integers?\"\"\"\n    previous = positions[0]\n    for current in positions[1:]:\n        if current != previous + 1:\n            return False\n        previous = current\n    return True", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom xarray.core.nputils import NumpyVIndexAdapter\nfrom xarray.core.nputils import _is_contiguous\ndef test_is_contiguous() ->None:\n    assert _is_contiguous([1])\n    assert _is_contiguous([1, 2, 3])\n    assert not _is_contiguous([1, 3])\n\ntest_is_contiguous()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_nputils.py"}], "instruction": "Functionality: The function _is_contiguous checks whether a given list of integers consists of contiguous integers, meaning that there are no gaps between the integers in the sequence. It returns True if the list is contiguous, and False otherwise.\n\nInputs:\n- positions: a non-empty list of integers. The list will not contain duplicate integers and will have at least one element.\n\nOutputs:\n- A boolean value indicating whether the input list consists of contiguous integers. True if the list is contiguous, and False if there is a gap between any two consecutive integers.", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom typing import Callable\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy import RankWarning\nfrom xarray.core.options import OPTIONS\nimport bottleneck as bn\n\n\ndef _is_contiguous(positions): [MASK]\n"}
{"method_name": "encode_zarr_attr_value", "full_method_name": "encode_zarr_attr_value", "method_path": "../srcdata/Basic/xarray/xarray/backends/zarr.py", "method_code": "from __future__ import annotations\nimport json\nimport os\nimport warnings\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import AbstractWritableDataStore\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import _encode_variable_name\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import HiddenKeyDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\ndef encode_zarr_attr_value(value):\n    \"\"\"\n    Encode a attribute value as something that can be serialized as json\n\n    Many xarray datasets / variables have numpy arrays and values. This\n    function handles encoding / decoding of such items.\n\n    ndarray -> list\n    scalar array -> scalar\n    other -> other (no change)\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        encoded = value.tolist()\n    elif isinstance(value, np.generic):\n        encoded = value.item()\n    else:\n        encoded = value\n    return encoded", "test_code_list": [{"test_code": "import contextlib\nimport gzip\nimport itertools\nimport math\nimport os.path\nimport pickle\nimport platform\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport uuid\nimport warnings\nfrom collections.abc import Generator\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom contextlib import ExitStack\nfrom io import BytesIO\nfrom os import listdir\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Final\nfrom typing import Literal\nfrom typing import cast\nfrom unittest.mock import patch\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom packaging.version import Version\nfrom pandas.errors import OutOfBoundsDatetime\nimport xarray as xr\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import backends\nfrom xarray import load_dataarray\nfrom xarray import load_dataset\nfrom xarray import open_dataarray\nfrom xarray import open_dataset\nfrom xarray import open_mfdataset\nfrom xarray import save_mfdataset\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.h5netcdf_ import H5netcdfBackendEntrypoint\nfrom xarray.backends.netcdf3 import _nc3_dtype_coercions\nfrom xarray.backends.netCDF4_ import NetCDF4BackendEntrypoint\nfrom xarray.backends.netCDF4_ import _extract_nc4_variable_encoding\nfrom xarray.backends.pydap_ import PydapDataStore\nfrom xarray.backends.scipy_ import ScipyBackendEntrypoint\nfrom xarray.coding.cftime_offsets import cftime_range\nfrom xarray.coding.strings import check_vlen_dtype\nfrom xarray.coding.strings import create_vlen_dtype\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import encode_dataset_coordinates\nfrom xarray.core import indexing\nfrom xarray.core.options import set_options\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_netCDF4\nfrom xarray.tests import has_scipy\nfrom xarray.tests import mock\nfrom xarray.tests import network\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_fsspec\nfrom xarray.tests import requires_h5netcdf\nfrom xarray.tests import requires_iris\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests import requires_pydap\nfrom xarray.tests import requires_scipy\nfrom xarray.tests import requires_scipy_or_netCDF4\nfrom xarray.tests import requires_zarr\nfrom xarray.tests.test_coding_times import _ALL_CALENDARS\nfrom xarray.tests.test_coding_times import _NON_STANDARD_CALENDARS\nfrom xarray.tests.test_coding_times import _STANDARD_CALENDARS\nfrom xarray.tests.test_dataset import create_append_string_length_mismatch_test_data\nfrom xarray.tests.test_dataset import create_append_test_data\nfrom xarray.tests.test_dataset import create_test_data\nimport dask\nimport dask.array as da\nfrom xarray.tests.test_coding_times import _all_cftime_date_types\nfrom dask.delayed import Delayed\nfrom unittest.mock import MagicMock\nimport fsspec\nfrom xarray.backends.zarr import ZarrStore\n@requires_zarr\ndef test_encode_zarr_attr_value() ->None:\n    arr = np.array([1, 2, 3])\n    expected1 = [1, 2, 3]\n    actual1 = encode_zarr_attr_value(arr)\n    assert isinstance(actual1, list)\n    assert actual1 == expected1\n    sarr = np.array(1)[()]\n    expected2 = 1\n    actual2 = encode_zarr_attr_value(sarr)\n    assert isinstance(actual2, int)\n    assert actual2 == expected2\n    expected3 = 'foo'\n    actual3 = encode_zarr_attr_value(expected3)\n    assert isinstance(actual3, str)\n    assert actual3 == expected3\n\ntest_encode_zarr_attr_value()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_backends.py"}], "instruction": "Functionality: The encode_zarr_attr_value function converts attribute values into a format that can be serialized as JSON. This is particularly useful for handling numpy arrays and scalar arrays within xarray datasets or variables, ensuring they are compatible with JSON serialization formats. Non-array and non-scalar array values are returned without change.\n\nInputs: \n- value: Any value that needs to be serialized, such as numpy arrays, scalar arrays, or other data types.\n\nOutputs:\n- encoded: The serialized representation of the input value. If the input is a numpy array, it is converted to a list. If the input is a numpy scalar array, it is converted to a scalar value. Other input types are returned unchanged.", "method_code_mask": "from __future__ import annotations\nimport json\nimport os\nimport warnings\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import AbstractWritableDataStore\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import _encode_variable_name\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import HiddenKeyDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\n\n\ndef encode_zarr_attr_value(value): [MASK]\n"}
{"method_name": "_extract_nc4_variable_encoding", "full_method_name": "_extract_nc4_variable_encoding", "method_path": "../srcdata/Basic/xarray/xarray/backends/netCDF4_.py", "method_code": "from __future__ import annotations\nimport functools\nimport operator\nimport os\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom xarray import coding\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.common import find_root_and_group\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.file_manager import CachingFileManager\nfrom xarray.backends.file_manager import DummyFileManager\nfrom xarray.backends.locks import HDF5_LOCK\nfrom xarray.backends.locks import NETCDFC_LOCK\nfrom xarray.backends.locks import combine_locks\nfrom xarray.backends.locks import ensure_lock\nfrom xarray.backends.locks import get_write_lock\nfrom xarray.backends.netcdf3 import encode_nc3_attr_value\nfrom xarray.backends.netcdf3 import encode_nc3_variable\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.utils import is_remote_uri\nfrom xarray.core.utils import try_read_magic_number_from_path\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\ndef _extract_nc4_variable_encoding(variable: Variable, raise_on_invalid=\n    False, lsd_okay=True, h5py_okay=False, backend='netCDF4',\n    unlimited_dims=None) ->dict[str, Any]:\n    if unlimited_dims is None:\n        unlimited_dims = ()\n    encoding = variable.encoding.copy()\n    safe_to_drop = {'source', 'original_shape'}\n    valid_encodings = {'zlib', 'complevel', 'fletcher32', 'contiguous',\n        'chunksizes', 'shuffle', '_FillValue', 'dtype', 'compression',\n        'significant_digits', 'quantize_mode', 'blosc_shuffle',\n        'szip_coding', 'szip_pixels_per_block', 'endian'}\n    if lsd_okay:\n        valid_encodings.add('least_significant_digit')\n    if h5py_okay:\n        valid_encodings.add('compression_opts')\n    if not raise_on_invalid and encoding.get('chunksizes') is not None:\n        chunksizes = encoding['chunksizes']\n        chunks_too_big = any(c > d and dim not in unlimited_dims for c, d,\n            dim in zip(chunksizes, variable.shape, variable.dims))\n        has_original_shape = 'original_shape' in encoding\n        changed_shape = has_original_shape and encoding.get('original_shape'\n            ) != variable.shape\n        if chunks_too_big or changed_shape:\n            del encoding['chunksizes']\n    var_has_unlim_dim = any(dim in unlimited_dims for dim in variable.dims)\n    if (not raise_on_invalid and var_has_unlim_dim and 'contiguous' in\n        encoding.keys()):\n        del encoding['contiguous']\n    for k in safe_to_drop:\n        if k in encoding:\n            del encoding[k]\n    if raise_on_invalid:\n        invalid = [k for k in encoding if k not in valid_encodings]\n        if invalid:\n            raise ValueError(\n                f'unexpected encoding parameters for {backend!r} backend: {invalid!r}. Valid encodings are: {valid_encodings!r}'\n                )\n    else:\n        for k in list(encoding):\n            if k not in valid_encodings:\n                del encoding[k]\n    return encoding", "test_code_list": [{"test_code": "import contextlib\nimport gzip\nimport itertools\nimport math\nimport os.path\nimport pickle\nimport platform\nimport re\nimport shutil\nimport sys\nimport tempfile\nimport uuid\nimport warnings\nfrom collections.abc import Generator\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom contextlib import ExitStack\nfrom io import BytesIO\nfrom os import listdir\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Final\nfrom typing import Literal\nfrom typing import cast\nfrom unittest.mock import patch\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom packaging.version import Version\nfrom pandas.errors import OutOfBoundsDatetime\nimport xarray as xr\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import backends\nfrom xarray import load_dataarray\nfrom xarray import load_dataset\nfrom xarray import open_dataarray\nfrom xarray import open_dataset\nfrom xarray import open_mfdataset\nfrom xarray import save_mfdataset\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.h5netcdf_ import H5netcdfBackendEntrypoint\nfrom xarray.backends.netcdf3 import _nc3_dtype_coercions\nfrom xarray.backends.netCDF4_ import NetCDF4BackendEntrypoint\nfrom xarray.backends.netCDF4_ import _extract_nc4_variable_encoding\nfrom xarray.backends.pydap_ import PydapDataStore\nfrom xarray.backends.scipy_ import ScipyBackendEntrypoint\nfrom xarray.coding.cftime_offsets import cftime_range\nfrom xarray.coding.strings import check_vlen_dtype\nfrom xarray.coding.strings import create_vlen_dtype\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.conventions import encode_dataset_coordinates\nfrom xarray.core import indexing\nfrom xarray.core.options import set_options\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_netCDF4\nfrom xarray.tests import has_scipy\nfrom xarray.tests import mock\nfrom xarray.tests import network\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_fsspec\nfrom xarray.tests import requires_h5netcdf\nfrom xarray.tests import requires_iris\nfrom xarray.tests import requires_netCDF4\nfrom xarray.tests import requires_pydap\nfrom xarray.tests import requires_scipy\nfrom xarray.tests import requires_scipy_or_netCDF4\nfrom xarray.tests import requires_zarr\nfrom xarray.tests.test_coding_times import _ALL_CALENDARS\nfrom xarray.tests.test_coding_times import _NON_STANDARD_CALENDARS\nfrom xarray.tests.test_coding_times import _STANDARD_CALENDARS\nfrom xarray.tests.test_dataset import create_append_string_length_mismatch_test_data\nfrom xarray.tests.test_dataset import create_append_test_data\nfrom xarray.tests.test_dataset import create_test_data\nimport dask\nimport dask.array as da\nfrom xarray.tests.test_coding_times import _all_cftime_date_types\nfrom dask.delayed import Delayed\nfrom unittest.mock import MagicMock\nimport fsspec\nfrom xarray.backends.zarr import ZarrStore\n\nclass TestEncodingInvalid():\n\tdef test_extract_nc4_variable_encoding(self) ->None:\n\t    var = xr.Variable(('x',), [1, 2, 3], {}, {'foo': 'bar'})\n\t    with pytest.raises(ValueError, match='unexpected encoding'):\n\t        _extract_nc4_variable_encoding(var, raise_on_invalid=True)\n\t    var = xr.Variable(('x',), [1, 2, 3], {}, {'chunking': (2, 1)})\n\t    encoding = _extract_nc4_variable_encoding(var)\n\t    assert {} == encoding\n\t    var = xr.Variable(('x',), [1, 2, 3], {}, {'shuffle': True})\n\t    encoding = _extract_nc4_variable_encoding(var, raise_on_invalid=True)\n\t    assert {'shuffle': True} == encoding\n\t    var = xr.Variable(('x',), [1, 2, 3], {}, {'contiguous': True})\n\t    encoding = _extract_nc4_variable_encoding(var, unlimited_dims=('x',))\n\t    assert {} == encoding\n\t\nTestEncodingInvalid().test_extract_nc4_variable_encoding()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_backends.py"}], "instruction": "Functionality: Extracts and validates variable encoding for netCDF4 files, ensuring compatibility with the netCDF4 backend. This function prepares the variable encoding by removing unsupported or invalid encoding parameters based on the specified conditions and backend.\n\nInputs: \n- variable: Variable\n    An xarray Variable instance for which the encoding is to be extracted.\n- raise_on_invalid: bool (default=False)\n    If True, raises a ValueError if the encoding contains invalid parameters for the specified backend.\n- lsd_okay: bool (default=True)\n    If True, allows the 'least_significant_digit' encoding parameter.\n- h5py_okay: bool (default=False)\n    If True, allows the 'compression_opts' encoding parameter.\n- backend: str (default='netCDF4')\n    The name of the backend to encode for ('netCDF4' by default).\n- unlimited_dims: Iterable (default=None)\n    An iterable of dimension names that can be unlimited. If None, no dimensions are considered unlimited.\n\nOutputs: \n- dict[str, Any]\n    A dictionary containing the filtered and valid encoding parameters for the provided Variable, suitable for the specified backend.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport operator\nimport os\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom xarray import coding\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.common import find_root_and_group\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.file_manager import CachingFileManager\nfrom xarray.backends.file_manager import DummyFileManager\nfrom xarray.backends.locks import HDF5_LOCK\nfrom xarray.backends.locks import NETCDFC_LOCK\nfrom xarray.backends.locks import combine_locks\nfrom xarray.backends.locks import ensure_lock\nfrom xarray.backends.locks import get_write_lock\nfrom xarray.backends.netcdf3 import encode_nc3_attr_value\nfrom xarray.backends.netcdf3 import encode_nc3_variable\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.utils import is_remote_uri\nfrom xarray.core.utils import try_read_magic_number_from_path\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\n\n\ndef _extract_nc4_variable_encoding(variable: Variable, raise_on_invalid=\n    False, lsd_okay=True, h5py_okay=False, backend='netCDF4',\n    unlimited_dims=None) ->dict[str, Any]: [MASK]\n"}
{"method_name": "get_example_data", "full_method_name": "get_example_data", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_interp.py", "method_code": "from __future__ import annotations\nfrom itertools import combinations\nfrom itertools import permutations\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import _parse_array_of_cftime_strings\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_scipy\nfrom xarray.tests.test_dataset import create_test_data\nimport scipy\ndef get_example_data(case: int) ->xr.DataArray:\n    if case == 0:\n        x = np.linspace(0, 1, 100)\n        y = np.linspace(0, 0.1, 30)\n        return xr.DataArray(np.sin(x[:, np.newaxis]) * np.cos(y), dims=['x',\n            'y'], coords={'x': x, 'y': y, 'x2': ('x', x ** 2)})\n    elif case == 1:\n        return get_example_data(0).chunk({'y': 3})\n    elif case == 2:\n        return get_example_data(0).chunk({'x': 25, 'y': 3})\n    elif case == 3:\n        x = np.linspace(0, 1, 100)\n        y = np.linspace(0, 0.1, 30)\n        z = np.linspace(0.1, 0.2, 10)\n        return xr.DataArray(np.sin(x[:, np.newaxis, np.newaxis]) * np.cos(y\n            [:, np.newaxis]) * z, dims=['x', 'y', 'z'], coords={'x': x, 'y':\n            y, 'x2': ('x', x ** 2), 'z': z})\n    elif case == 4:\n        return get_example_data(3).chunk({'z': 5})\n    else:\n        raise ValueError('case must be 1-4')", "test_code_list": [{"test_code": "from itertools import combinations\nfrom itertools import permutations\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import _parse_array_of_cftime_strings\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_scipy\nfrom xarray.tests.test_dataset import create_test_data\nimport scipy\ndef test_keywargs():\n    if not has_scipy:\n        pytest.skip('scipy is not installed.')\n    da = get_example_data(0)\n    assert_equal(da.interp(x=[0.5, 0.8]), da.interp({'x': [0.5, 0.8]}))\n\ntest_keywargs()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_interp.py"}], "instruction": "Functionality: Generate example DataArrays for testing and demonstration purposes.\nInputs: \n    - case: An integer (1-4) that specifies which type of example DataArray to generate. Each case number corresponds to a different data structure or chunking strategy.\n\nOutputs:\n    - DataArray: An xarray DataArray object that is generated based on the specified 'case'. The DataArray will have different shapes, dimensions, and chunking depending on the value of 'case':\n        - case == 0: A 2D DataArray with dimensions 'x' and 'y', representing a sine and cosine function of 'x' and 'y'.\n        - case == 1: The same as case 0, but with chunking applied along the 'y' dimension.\n        - case == 2: The same as case 0, but with chunking applied along both 'x' and 'y' dimensions.\n        - case == 3: A 3D DataArray with dimensions 'x', 'y', and 'z', representing a sine and cosine function of 'x' and 'y', and a multiplication with 'z'.\n        - case == 4: The same as case 3, but with chunking applied along the 'z' dimension.\n        For any other value of 'case', the function raises a ValueError.", "method_code_mask": "from __future__ import annotations\nfrom itertools import combinations\nfrom itertools import permutations\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import _parse_array_of_cftime_strings\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_scipy\nfrom xarray.tests.test_dataset import create_test_data\nimport scipy\n\n\ndef get_example_data(case: int) ->xr.DataArray: [MASK]\n"}
{"method_name": "group_indexers_by_index", "full_method_name": "group_indexers_by_index", "method_path": "../srcdata/Basic/xarray/xarray/core/indexing.py", "method_code": "from __future__ import annotations\nimport enum\nimport functools\nimport operator\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom datetime import timedelta\nfrom html import escape\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import duck_array_ops\nfrom xarray.core.nputils import NumpyVIndexAdapter\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import NDArrayMixin\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import to_0d_array\nfrom numpy.typing import DTypeLike\nfrom xarray.core.indexes import Index\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.formatting import short_array_repr\ndef group_indexers_by_index(obj: T_Xarray, indexers: Mapping[Any, Any],\n    options: Mapping[str, Any]) ->list[tuple[Index, dict[Any, Any]]]:\n    \"\"\"Returns a list of unique indexes and their corresponding indexers.\"\"\"\n    unique_indexes = {}\n    grouped_indexers: Mapping[int | None, dict] = defaultdict(dict)\n    for key, label in indexers.items():\n        index: Index = obj.xindexes.get(key, None)\n        if index is not None:\n            index_id = id(index)\n            unique_indexes[index_id] = index\n            grouped_indexers[index_id][key] = label\n        elif key in obj.coords:\n            raise KeyError(f'no index found for coordinate {key!r}')\n        elif key not in obj.dims:\n            raise KeyError(\n                f'{key!r} is not a valid dimension or coordinate for {obj.__class__.__name__} with dimensions {obj.dims!r}'\n                )\n        elif len(options):\n            raise ValueError(\n                f'cannot supply selection options {options!r} for dimension {key!r}that has no associated coordinate or index'\n                )\n        else:\n            unique_indexes[None] = None\n            grouped_indexers[None][key] = label\n    return [(unique_indexes[k], grouped_indexers[k]) for k in unique_indexes]", "test_code_list": [{"test_code": "import itertools\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray.core import indexing\nfrom xarray.core import nputils\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.types import T_Xarray\nfrom xarray.tests import IndexerMaker\nfrom xarray.tests import ReturnItem\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_dask\nimport dask.array\nimport dask.array as da\n\nclass TestIndexers():\n\tdef test_group_indexers_by_index(self) ->None:\n\t    mindex = pd.MultiIndex.from_product([['a', 'b'], [1, 2]], names=('one',\n\t        'two'))\n\t    data = DataArray(np.zeros((4, 2, 2)), coords={'x': mindex, 'y': [1, 2]},\n\t        dims=('x', 'y', 'z'))\n\t    data.coords['y2'] = 'y', [2.0, 3.0]\n\t    grouped_indexers = group_indexers_by_index(data, {'z': 0,\n\t        'one': 'a', 'two': 1, 'y': 0}, {})\n\t    for idx, indexers in grouped_indexers:\n\t        if idx is None:\n\t            assert indexers == {'z': 0}\n\t        elif idx.equals(data.xindexes['x']):\n\t            assert indexers == {'one': 'a', 'two': 1}\n\t        elif idx.equals(data.xindexes['y']):\n\t            assert indexers == {'y': 0}\n\t    assert len(grouped_indexers) == 3\n\t    with pytest.raises(KeyError, match=\"no index found for coordinate 'y2'\"):\n\t        group_indexers_by_index(data, {'y2': 2.0}, {})\n\t    with pytest.raises(KeyError, match=\n\t        \"'w' is not a valid dimension or coordinate\"):\n\t        group_indexers_by_index(data, {'w': 'a'}, {})\n\t    with pytest.raises(ValueError, match='cannot supply.*'):\n\t        group_indexers_by_index(data, {'z': 1}, {'method': 'nearest'})\n\t\nTestIndexers().test_group_indexers_by_index()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_indexing.py"}], "instruction": "Functionality: The function group_indexers_by_index is designed to process a given xarray object and a mapping of indexers, returning a list of unique indexes and their corresponding indexers. This function is particularly useful for organizing and optimizing operations on multi-dimensional arrays with complex indexing schemes.\n\nInputs: \n- obj: T_Xarray\n    An xarray object that can be either a Dataset or a DataArray.\n- indexers: Mapping[Any, Any]\n    A mapping of keys to labels, where each key is a dimension or coordinate in the xarray object, and each label is the indexer value for that key.\n- options: Mapping[str, Any]\n    Additional options that can be provided to customize the behavior of indexer selection.\n\nOutputs:\n- List[tuple[Index, dict[Any, Any]]]\n    A list of tuples, where each tuple contains a unique Index object and a dictionary mapping keys to labels associated with that index. If a dimension or coordinate does not have an associated index, the index will be None.", "method_code_mask": "from __future__ import annotations\nimport enum\nimport functools\nimport operator\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom datetime import timedelta\nfrom html import escape\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import duck_array_ops\nfrom xarray.core.nputils import NumpyVIndexAdapter\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import NDArrayMixin\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import to_0d_array\nfrom numpy.typing import DTypeLike\nfrom xarray.core.indexes import Index\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.formatting import short_array_repr\n\n\ndef group_indexers_by_index(obj: T_Xarray, indexers: Mapping[Any, Any],\n    options: Mapping[str, Any]) ->list[tuple[Index, dict[Any, Any]]]: [MASK]\n"}
{"method_name": "result_name", "full_method_name": "result_name", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef result_name(objects: Iterable[Any]) ->Any:\n    names = {getattr(obj, 'name', _DEFAULT_NAME) for obj in objects}\n    names.discard(_DEFAULT_NAME)\n    if len(names) == 1:\n        name, = names\n    else:\n        name = None\n    return name", "test_code_list": [{"test_code": "import functools\nimport operator\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport xarray as xr\nfrom xarray.core.alignment import broadcast\nfrom xarray.core.computation import _UFuncSignature\nfrom xarray.core.computation import apply_ufunc\nfrom xarray.core.computation import broadcast_compat_data\nfrom xarray.core.computation import collect_dict_values\nfrom xarray.core.computation import join_dict_keys\nfrom xarray.core.computation import ordered_set_intersection\nfrom xarray.core.computation import ordered_set_union\nfrom xarray.core.computation import result_name\nfrom xarray.core.computation import unified_dim_sizes\nfrom xarray.tests import has_dask\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.testing import assert_identical as assert_identical_\nimport dask.array as da\nfrom dask import is_dask_collection\ndef test_result_name() ->None:\n\n\n    class Named:\n\n        def __init__(self, name=None):\n            self.name = name\n    assert result_name([1, 2]) is None\n    assert result_name([Named()]) is None\n    assert result_name([Named('foo'), 2]) == 'foo'\n    assert result_name([Named('foo'), Named('bar')]) is None\n    assert result_name([Named('foo'), Named()]) is None\n\ntest_result_name()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_computation.py"}], "instruction": "Functionality: The result_name function is designed to extract and determine the unique name from a collection of objects, primarily targeting DataArray or similar objects that have a 'name' attribute. It retrieves the 'name' attribute from each object within the given iterable, filters out any default names, and returns the single unique name if there's only one. If multiple unique names are present or no names can be determined, the function returns None.\n\nInputs: \n- objects: An iterable collection of objects. Each object is expected to potentially have a 'name' attribute that can be retrieved using getattr(obj, 'name', _DEFAULT_NAME). The objects could be DataArray instances or any other objects that conform to this attribute pattern.\n\nOutputs: \n- The function returns a single name (of type Any) if all objects within the iterable have the same non-default name. If the names are not consistent or if the iterable contains objects without a unique name, the function returns None.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef result_name(objects: Iterable[Any]) ->Any: [MASK]\n"}
{"method_name": "ordered_set_intersection", "full_method_name": "ordered_set_intersection", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef ordered_set_intersection(all_keys: list[Iterable]) ->Iterable:\n    intersection = set(all_keys[0])\n    for keys in all_keys[1:]:\n        intersection.intersection_update(keys)\n    return [key for key in all_keys[0] if key in intersection]", "test_code_list": [{"test_code": "import functools\nimport operator\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport xarray as xr\nfrom xarray.core.alignment import broadcast\nfrom xarray.core.computation import _UFuncSignature\nfrom xarray.core.computation import apply_ufunc\nfrom xarray.core.computation import broadcast_compat_data\nfrom xarray.core.computation import collect_dict_values\nfrom xarray.core.computation import join_dict_keys\nfrom xarray.core.computation import ordered_set_intersection\nfrom xarray.core.computation import ordered_set_union\nfrom xarray.core.computation import result_name\nfrom xarray.core.computation import unified_dim_sizes\nfrom xarray.tests import has_dask\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.testing import assert_identical as assert_identical_\nimport dask.array as da\nfrom dask import is_dask_collection\ndef test_ordered_set_intersection() ->None:\n    assert list(ordered_set_intersection([[1, 2]])) == [1, 2]\n    assert list(ordered_set_intersection([[1, 2], [2, 1]])) == [1, 2]\n    assert list(ordered_set_intersection([[1, 2], [1, 3]])) == [1]\n    assert list(ordered_set_intersection([[1, 2], [2]])) == [2]\n\ntest_ordered_set_intersection()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_computation.py"}], "instruction": "Functionality: The ordered_set_intersection function is designed to find the intersection of multiple iterables (like lists, tuples, etc.) while preserving the order of elements as they appeared in the first iterable. This function first converts the first iterable into a set to find the intersection. Then, it iteratively updates this set with the intersection of subsequent iterables. Finally, it constructs a list containing only the elements found in the intersection, maintaining their original order from the first iterable.\n\nInputs: The function takes a single argument:\n- all_keys: a list of iterables (e.g., lists, tuples, sets). Each iterable is expected to contain hashable elements.\n\nOutputs: The function returns a single output:\n- An iterable (list) containing the elements that are common to all provided iterables, in the order they appeared in the first iterable.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef ordered_set_intersection(all_keys: list[Iterable]) ->Iterable: [MASK]\n"}
{"method_name": "join_dict_keys", "full_method_name": "join_dict_keys", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef join_dict_keys(objects: Iterable[Mapping | Any], how: str='inner'\n    ) ->Iterable:\n    joiner = _JOINERS[how]\n    all_keys = [obj.keys() for obj in objects if hasattr(obj, 'keys')]\n    return joiner(all_keys)", "test_code_list": [{"test_code": "import functools\nimport operator\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport xarray as xr\nfrom xarray.core.alignment import broadcast\nfrom xarray.core.computation import _UFuncSignature\nfrom xarray.core.computation import apply_ufunc\nfrom xarray.core.computation import broadcast_compat_data\nfrom xarray.core.computation import collect_dict_values\nfrom xarray.core.computation import join_dict_keys\nfrom xarray.core.computation import ordered_set_intersection\nfrom xarray.core.computation import ordered_set_union\nfrom xarray.core.computation import result_name\nfrom xarray.core.computation import unified_dim_sizes\nfrom xarray.tests import has_dask\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.testing import assert_identical as assert_identical_\nimport dask.array as da\nfrom dask import is_dask_collection\ndef test_join_dict_keys() ->None:\n    dicts = [dict.fromkeys(keys) for keys in [['x', 'y'], ['y', 'z']]]\n    assert list(join_dict_keys(dicts, 'left')) == ['x', 'y']\n    assert list(join_dict_keys(dicts, 'right')) == ['y', 'z']\n    assert list(join_dict_keys(dicts, 'inner')) == ['y']\n    assert list(join_dict_keys(dicts, 'outer')) == ['x', 'y', 'z']\n    with pytest.raises(ValueError):\n        join_dict_keys(dicts, 'exact')\n    with pytest.raises(KeyError):\n        join_dict_keys(dicts, 'foobar')\n\ntest_join_dict_keys()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_computation.py"}], "instruction": "Functionality: \nThe function 'join_dict_keys' is designed to join the keys from multiple dictionary-like objects based on a specified method. It takes a collection of dictionary-like objects and a method for joining. The method can be 'inner', 'outer', 'left', or 'right', determining how keys from different dictionaries are combined. \n\nInputs: \n1. objects: An iterable collection of mapping objects or any objects that have a 'keys' method. This can be a list, tuple, or any other iterable that contains dictionary-like objects.\n2. how: A string indicating the method for joining keys. It can be one of the following:\n   - 'inner': Retains only keys that are common across all dictionaries.\n   - 'outer': Includes all unique keys from all dictionaries.\n   - 'left': Retains keys from the first dictionary in the iterable.\n   - 'right': Retains keys from the last dictionary in the iterable. \n   The default method is 'inner'.\n\nOutputs:\nThe function returns an iterable of keys that have been joined according to the specified method. The keys returned are those that satisfy the join criteria defined by the 'how' parameter.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef join_dict_keys(objects: Iterable[Mapping | Any], how: str='inner'\n    ) ->Iterable: [MASK]\n"}
{"method_name": "collect_dict_values", "full_method_name": "collect_dict_values", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef collect_dict_values(objects: Iterable[Mapping | Any], keys: Iterable,\n    fill_value: object=None) ->list[list]:\n    return [[(obj.get(key, fill_value) if is_dict_like(obj) else obj) for\n        obj in objects] for key in keys]", "test_code_list": [{"test_code": "import functools\nimport operator\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport xarray as xr\nfrom xarray.core.alignment import broadcast\nfrom xarray.core.computation import _UFuncSignature\nfrom xarray.core.computation import apply_ufunc\nfrom xarray.core.computation import broadcast_compat_data\nfrom xarray.core.computation import collect_dict_values\nfrom xarray.core.computation import join_dict_keys\nfrom xarray.core.computation import ordered_set_intersection\nfrom xarray.core.computation import ordered_set_union\nfrom xarray.core.computation import result_name\nfrom xarray.core.computation import unified_dim_sizes\nfrom xarray.tests import has_dask\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.testing import assert_identical as assert_identical_\nimport dask.array as da\nfrom dask import is_dask_collection\ndef test_collect_dict_values() ->None:\n    dicts = [{'x': 1, 'y': 2, 'z': 3}, {'z': 4}, 5]\n    expected = [[1, 0, 5], [2, 0, 5], [3, 4, 5]]\n    collected = collect_dict_values(dicts, ['x', 'y', 'z'], fill_value=0)\n    assert collected == expected\n\ntest_collect_dict_values()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_computation.py"}], "instruction": "Functionality: Implement a function named collect_dict_values that takes a collection of mappings or other objects and a collection of keys, then returns a list of lists, where each inner list contains the value for a corresponding key from each object in the collection. If an object is not a mapping, the function treats it as if it had a value of fill_value for every key. If a key is not found in a mapping, the function uses fill_value as the value for that key in the output.\n\nInputs: \n- objects: An Iterable collection containing Mappings or other objects. Mappings can be dictionaries or any other object that supports the get method for retrieving values by key.\n- keys: An Iterable containing the keys for which values are to be collected from the objects.\n- fill_value: An object (default is None) that is used as the value for keys not found in mappings or for objects that are not mappings.\n\nOutputs: \n- A list of lists, where each inner list contains M elements, corresponding to the values of a given key from each of the M objects in the input collection. Each inner list contains the value for a corresponding key from each object, or the fill_value if the key is not found in a mapping or the object is not a mapping.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef collect_dict_values(objects: Iterable[Mapping | Any], keys: Iterable,\n    fill_value: object=None) ->list[list]: [MASK]\n"}
{"method_name": "unified_dim_sizes", "full_method_name": "unified_dim_sizes", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef unified_dim_sizes(variables: Iterable[Variable], exclude_dims: Set=\n    frozenset()) ->dict[Hashable, int]:\n    dim_sizes: dict[Hashable, int] = {}\n    for var in variables:\n        if len(set(var.dims)) < len(var.dims):\n            raise ValueError(\n                f'broadcasting cannot handle duplicate dimensions on a variable: {list(var.dims)}'\n                )\n        for dim, size in zip(var.dims, var.shape):\n            if dim not in exclude_dims:\n                if dim not in dim_sizes:\n                    dim_sizes[dim] = size\n                elif dim_sizes[dim] != size:\n                    raise ValueError(\n                        f'operands cannot be broadcast together with mismatched lengths for dimension {dim}: {dim_sizes[dim]} vs {size}'\n                        )\n    return dim_sizes", "test_code_list": [{"test_code": "import functools\nimport operator\nimport pickle\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport xarray as xr\nfrom xarray.core.alignment import broadcast\nfrom xarray.core.computation import _UFuncSignature\nfrom xarray.core.computation import apply_ufunc\nfrom xarray.core.computation import broadcast_compat_data\nfrom xarray.core.computation import collect_dict_values\nfrom xarray.core.computation import join_dict_keys\nfrom xarray.core.computation import ordered_set_intersection\nfrom xarray.core.computation import ordered_set_union\nfrom xarray.core.computation import result_name\nfrom xarray.core.computation import unified_dim_sizes\nfrom xarray.tests import has_dask\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.testing import assert_identical as assert_identical_\nimport dask.array as da\nfrom dask import is_dask_collection\ndef test_unified_dim_sizes() ->None:\n    assert unified_dim_sizes([xr.Variable((), 0)]) == {}\n    assert unified_dim_sizes([xr.Variable('x', [1]), xr.Variable('x', [1])]\n        ) == {'x': 1}\n    assert unified_dim_sizes([xr.Variable('x', [1]), xr.Variable('y', [1, 2])]\n        ) == {'x': 1, 'y': 2}\n    assert unified_dim_sizes([xr.Variable(('x', 'z'), [[1]]), xr.Variable((\n        'y', 'z'), [[1, 2], [3, 4]])], exclude_dims={'z'}) == {'x': 1, 'y': 2}\n    with pytest.raises(ValueError):\n        unified_dim_sizes([xr.Variable(('x', 'x'), [[1]])])\n    with pytest.raises(ValueError):\n        unified_dim_sizes([xr.Variable('x', [1]), xr.Variable('x', [1, 2])])\n\ntest_unified_dim_sizes()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_computation.py"}], "instruction": "Functionality: The unified_dim_sizes function is designed to determine the unified sizes of dimensions across a collection of Variables. It ensures that all dimensions are unique within each Variable and that dimensions with the same name have consistent sizes across all Variables. If these conditions are not met, the function raises a ValueError. The function also allows specifying dimensions to exclude from the size unification process.\n\nInputs: \n- variables: An Iterable of Variable objects. Each Variable represents a multidimensional array with associated dimension names and sizes.\n- exclude_dims: A Set of Hashable objects (default is an empty frozenset). This set specifies the dimensions to be excluded from the unification process.\n\nOutputs: \n- A dictionary where keys are Hashable dimension names and values are integers representing the size of each dimension. This dictionary represents the unified dimension sizes across the input Variables, excluding any dimensions specified in exclude_dims.", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef unified_dim_sizes(variables: Iterable[Variable], exclude_dims: Set=\n    frozenset()) ->dict[Hashable, int]: [MASK]\n"}
{"method_name": "broadcast_dimension_size", "full_method_name": "broadcast_dimension_size", "method_path": "../srcdata/Basic/xarray/xarray/core/merge.py", "method_code": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Union\nimport pandas as pd\nfrom xarray.core import dtypes\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.duck_array_ops import lazy_array_equiv\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.indexes import indexes_equal\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import compat_dict_union\nfrom xarray.core.utils import dict_equiv\nfrom xarray.core.utils import equivalent\nfrom xarray.core.variable import Variable\nfrom xarray.core.variable import as_variable\nfrom xarray.core.variable import calculate_dimensions\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import CompatOptions\nfrom xarray.core.types import JoinOptions\ndef broadcast_dimension_size(variables: list[Variable]) ->dict[Hashable, int]:\n    \"\"\"Extract dimension sizes from a dictionary of variables.\n\n    Raises ValueError if any dimensions have different sizes.\n    \"\"\"\n    dims: dict[Hashable, int] = {}\n    for var in variables:\n        for dim, size in zip(var.dims, var.shape):\n            if dim in dims and size != dims[dim]:\n                raise ValueError(f'index {dim!r} not aligned')\n            dims[dim] = size\n    return dims", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport xarray as xr\nfrom xarray.core import dtypes\nfrom xarray.core import merge\nfrom xarray.core.merge import MergeError\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests.test_dataset import create_test_data\n\nclass TestMergeInternals():\n\tdef test_broadcast_dimension_size(self):\n\t    actual = broadcast_dimension_size([xr.Variable('x', [1]), xr.\n\t        Variable('y', [2, 1])])\n\t    assert actual == {'x': 1, 'y': 2}\n\t    actual = broadcast_dimension_size([xr.Variable(('x', 'y'), [[1, 2\n\t        ]]), xr.Variable('y', [2, 1])])\n\t    assert actual == {'x': 1, 'y': 2}\n\t    with pytest.raises(ValueError):\n\t        broadcast_dimension_size([xr.Variable(('x', 'y'), [[1, 2]]),\n\t            xr.Variable('y', [2])])\n\t\nTestMergeInternals().test_broadcast_dimension_size()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_merge.py"}], "instruction": "Functionality: The broadcast_dimension_size function is designed to extract dimension sizes from a list of Variable objects. It iterates through each variable in the list, extracts the dimensions and their sizes, and ensures that all dimensions with the same name have identical sizes across all variables. If it finds any dimension with inconsistent sizes, it raises a ValueError.\n\nInputs: \n- variables: a list of Variable objects. Each Variable object represents an array with associated metadata, such as dimensions and coordinates.\n\nOutputs:\n- A dictionary mapping each unique dimension name (a hashable type) to its size (an integer). This dictionary indicates the size of each dimension across all the variables in the input list, under the condition that all dimensions of the same name have the same size. If any dimension does not meet this condition, the function will raise a ValueError.\n\nNote: The function does not return anything if it encounters dimensions with inconsistent sizes; instead, it raises an exception to indicate the failure.", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Union\nimport pandas as pd\nfrom xarray.core import dtypes\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.duck_array_ops import lazy_array_equiv\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.indexes import indexes_equal\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import compat_dict_union\nfrom xarray.core.utils import dict_equiv\nfrom xarray.core.utils import equivalent\nfrom xarray.core.variable import Variable\nfrom xarray.core.variable import as_variable\nfrom xarray.core.variable import calculate_dimensions\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import CompatOptions\nfrom xarray.core.types import JoinOptions\n\n\ndef broadcast_dimension_size(variables: list[Variable]) ->dict[Hashable, int\n    ]: [MASK]\n"}
{"method_name": "figure_context", "full_method_name": "figure_context", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@contextlib.contextmanager\ndef figure_context(*args, **kwargs):\n    \"\"\"context manager which autocloses a figure (even if the test failed)\"\"\"\n    try:\n        yield None\n    finally:\n        plt.close('all')", "test_code_list": [{"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\ndef test_get_axis_current() ->None:\n    with figure_context():\n        _, ax = plt.subplots()\n        out_ax = get_axis()\n        assert ax is out_ax\n\ntest_get_axis_current()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\ndef test_maybe_gca() ->None:\n    with figure_context():\n        ax = _maybe_gca(aspect=1)\n        assert isinstance(ax, mpl.axes.Axes)\n        assert ax.get_aspect() == 1\n    with figure_context():\n        plt.figure()\n        ax = _maybe_gca(aspect=1)\n        assert isinstance(ax, mpl.axes.Axes)\n        assert ax.get_aspect() == 1\n    with figure_context():\n        existing_axes = plt.axes()\n        ax = _maybe_gca(aspect=1)\n        assert existing_axes == ax\n        assert ax.get_aspect() == 'auto'\n\ntest_maybe_gca()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\ndef test_plot1d_default_rcparams() ->None:\n    import matplotlib as mpl\n    ds = xr.tutorial.scatter_example_dataset(seed=42)\n    with figure_context():\n        fig, ax = plt.subplots(1, 1)\n        ds.plot.scatter(x='A', y='B', marker='o', ax=ax)\n        actual: np.ndarray = mpl.colors.to_rgba_array('w')\n        expected: np.ndarray = ax.collections[0].get_edgecolor()\n        np.testing.assert_allclose(actual, expected)\n        fg = ds.plot.scatter(x='A', y='B', col='x', marker='o')\n        ax = fg.axs.ravel()[0]\n        actual = mpl.colors.to_rgba_array('w')\n        expected = ax.collections[0].get_edgecolor()\n        np.testing.assert_allclose(actual, expected)\n        with assert_no_warnings():\n            fig, ax = plt.subplots(1, 1)\n            ds.plot.scatter(x='A', y='B', ax=ax, marker='x')\n        fig, ax = plt.subplots(1, 1)\n        ds.plot.scatter(x='A', y='B', marker='o', ax=ax, edgecolor='k')\n        actual = mpl.colors.to_rgba_array('k')\n        expected = ax.collections[0].get_edgecolor()\n        np.testing.assert_allclose(actual, expected)\n\ntest_plot1d_default_rcparams()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\tdef test_2d_coords_line_plot(self) ->None:\n\t    lon, lat = np.meshgrid(np.linspace(-20, 20, 5), np.linspace(0, 30, 4))\n\t    lon += lat / 10\n\t    lat += lon / 10\n\t    da = xr.DataArray(np.arange(20).reshape(4, 5), dims=['y', 'x'], coords=\n\t        {'lat': (('y', 'x'), lat), 'lon': (('y', 'x'), lon)})\n\t    with figure_context():\n\t        hdl = da.plot.line(x='lon', hue='x')\n\t        assert len(hdl) == 5\n\t    with figure_context():\n\t        hdl = da.plot.line(x='lon', hue='y')\n\t        assert len(hdl) == 4\n\t    with pytest.raises(ValueError, match=\n\t        'For 2D inputs, hue must be a dimension'):\n\t        da.plot.line(x='lon', hue='lat')\n\t\nTestPlot().test_2d_coords_line_plot()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}], "instruction": "Functionality: This function, named figure_context, is a context manager designed to manage the lifecycle of figures in a testing environment, especially useful for scenarios involving matplotlib plots. It ensures that figures are properly closed after tests, preventing memory leaks and graphical artifacts, even in cases where tests might fail. This is crucial for maintaining clean and reliable test suites, especially when dealing with dynamic, graphical outputs.\n\nInputs: figure_context does not require any direct input arguments when it is called. However, it can be used within a with statement where any arguments passed to the plotting functions inside the block will be handled by those functions specifically. The figure_context manager itself does not process or require any explicit inputs.\n\nOutputs: figure_context itself does not return any output values. Its primary purpose is to manage the state of matplotlib figures, ensuring they are closed appropriately at the end of a test or code block. This functionality indirectly ensures that the testing environment is left in a clean state, free from open figures that could otherwise impact subsequent tests or the overall stability of the testing process.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n\n\n@contextlib.contextmanager\ndef figure_context(*args, **kwargs): [MASK]\n"}
{"method_name": "scatter_example_dataset", "full_method_name": "scatter_example_dataset", "method_path": "../srcdata/Basic/xarray/xarray/tutorial.py", "method_code": "from __future__ import annotations\nimport os\nimport pathlib\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom xarray.backends.api import open_dataset as _open_dataset\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nimport pooch\nimport scipy\ndef scatter_example_dataset(*, seed: (None | int)=None) ->Dataset:\n    \"\"\"\n    Create an example dataset.\n\n    Parameters\n    ----------\n    seed : int, optional\n        Seed for the random number generation.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    A = DataArray(np.zeros([3, 11, 4, 4]), dims=['x', 'y', 'z', 'w'],\n        coords={'x': np.arange(3), 'y': np.linspace(0, 1, 11), 'z': np.\n        arange(4), 'w': 0.1 * rng.standard_normal(4)})\n    B = 0.1 * A.x ** 2 + A.y ** 2.5 + 0.1 * A.z * A.w\n    A = -0.1 * A.x + A.y / (5 + A.z) + A.w\n    ds = Dataset({'A': A, 'B': B})\n    ds['w'] = ['one', 'two', 'three', 'five']\n    ds.x.attrs['units'] = 'xunits'\n    ds.y.attrs['units'] = 'yunits'\n    ds.z.attrs['units'] = 'zunits'\n    ds.w.attrs['units'] = 'wunits'\n    ds.A.attrs['units'] = 'Aunits'\n    ds.B.attrs['units'] = 'Bunits'\n    return ds", "test_code_list": [{"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\ndef test_assert_valid_xy() ->None:\n    ds = scatter_example_dataset()\n    darray = ds.A\n    _assert_valid_xy(darray=darray, xy='x', name='x')\n    _assert_valid_xy(darray=darray, xy=None, name='x')\n    with pytest.raises(ValueError, match='x must be one of'):\n        _assert_valid_xy(darray=darray, xy='error_now', name='x')\n\ntest_assert_valid_xy()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}], "instruction": "Functionality: Create an example dataset with synthetic data and attributes for testing or demonstration.\n\nInputs:\n    seed : int, optional\n        Seed for the random number generation. If not provided, the random number generator will use the current system time. This parameter allows for reproducibility of the dataset.\n\nOutputs:\n    Dataset\n        A xarray Dataset with the following variables and attributes:\n        - 'A': A DataArray with dimensions 'x', 'y', 'z', and 'w'. The values are generated based on a formula involving these dimensions.\n        - 'B': A DataArray with the same dimensions as 'A'. The values are generated using a different formula involving these dimensions.\n        - 'w': A coordinate array with labels ['one', 'two', 'three', 'five'].\n        Each variable and coordinate in the dataset also has the following attributes:\n        - 'x': units 'xunits'\n        - 'y': units 'yunits'\n        - 'z': units 'zunits'\n        - 'w': units 'wunits'\n        - 'A': units 'Aunits'\n        - 'B': units 'Bunits'", "method_code_mask": "from __future__ import annotations\nimport os\nimport pathlib\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom xarray.backends.api import open_dataset as _open_dataset\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nimport pooch\nimport scipy\n\n\ndef scatter_example_dataset(*, seed: (None | int)=None) ->Dataset: [MASK]\n"}
{"method_name": "easy_array", "full_method_name": "easy_array", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\ndef easy_array(shape: tuple[int, ...], start: float=0, stop: float=1\n    ) ->np.ndarray:\n    \"\"\"\n    Make an array with desired shape using np.linspace\n\n    shape is a tuple like (2, 3)\n    \"\"\"\n    a = np.linspace(start, stop, num=math.prod(shape))\n    return a.reshape(shape)", "test_code_list": [{"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\tdef test2d_1d_2d_coordinates_pcolormesh(self) ->None:\n\t    sz = 10\n\t    y2d, x2d = np.meshgrid(np.arange(sz), np.arange(sz))\n\t    a = DataArray(easy_array((sz, sz)), dims=['x', 'y'], coords={'x2d': ([\n\t        'x', 'y'], x2d), 'y2d': (['x', 'y'], y2d)})\n\t    for x, y in [('x', 'y'), ('y', 'x'), ('x2d', 'y'), ('y', 'x2d'), ('x',\n\t        'y2d'), ('y2d', 'x'), ('x2d', 'y2d'), ('y2d', 'x2d')]:\n\t        p = a.plot.pcolormesh(x=x, y=y)\n\t        v = p.get_paths()[0].vertices\n\t        assert isinstance(v, np.ndarray)\n\t        _, unique_counts = np.unique(v[:-1], axis=0, return_counts=True)\n\t        assert np.all(unique_counts == 1)\n\t\nTestPlot().test2d_1d_2d_coordinates_pcolormesh()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\tdef test_contourf_cmap_set(self) ->None:\n\t    a = DataArray(easy_array((4, 4)), dims=['z', 'time'])\n\t    cmap_expected = mpl.colormaps['viridis']\n\t    pl = a.plot.contourf(cmap=copy(cmap_expected), vmin=0.1, vmax=0.9)\n\t    cmap = pl.cmap\n\t    assert cmap is not None\n\t    assert_array_equal(cmap(np.ma.masked_invalid([np.nan]))[0],\n\t        cmap_expected(np.ma.masked_invalid([np.nan]))[0])\n\t    assert cmap(-np.inf) == cmap_expected(-np.inf)\n\t    assert cmap(np.inf) == cmap_expected(np.inf)\n\t\nTestPlot().test_contourf_cmap_set()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\tdef test_contourf_cmap_set_with_bad_under_over(self) ->None:\n\t    a = DataArray(easy_array((4, 4)), dims=['z', 'time'])\n\t    cmap_expected = copy(mpl.colormaps['viridis'])\n\t    cmap_expected.set_bad('w')\n\t    assert np.all(cmap_expected(np.ma.masked_invalid([np.nan]))[0] != mpl.\n\t        colormaps['viridis'](np.ma.masked_invalid([np.nan]))[0])\n\t    cmap_expected.set_under('r')\n\t    assert cmap_expected(-np.inf) != mpl.colormaps['viridis'](-np.inf)\n\t    cmap_expected.set_over('g')\n\t    assert cmap_expected(np.inf) != mpl.colormaps['viridis'](-np.inf)\n\t    pl = a.plot.contourf(cmap=copy(cmap_expected))\n\t    cmap = pl.cmap\n\t    assert cmap is not None\n\t    assert_array_equal(cmap(np.ma.masked_invalid([np.nan]))[0],\n\t        cmap_expected(np.ma.masked_invalid([np.nan]))[0])\n\t    assert cmap(-np.inf) == cmap_expected(-np.inf)\n\t    assert cmap(np.inf) == cmap_expected(np.inf)\n\t\nTestPlot().test_contourf_cmap_set_with_bad_under_over()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\tdef test_datetime_dimension(self) ->None:\n\t    nrow = 3\n\t    ncol = 4\n\t    time = pd.date_range('2000-01-01', periods=nrow)\n\t    a = DataArray(easy_array((nrow, ncol)), coords=[('time', time), ('y',\n\t        range(ncol))])\n\t    a.plot()\n\t    ax = plt.gca()\n\t    assert ax.has_data()\n\t\nTestPlot().test_datetime_dimension()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\t@pytest.mark.slow\n\t@pytest.mark.filterwarnings('ignore:tight_layout cannot')\n\tdef test_convenient_facetgrid(self) ->None:\n\t    a = easy_array((10, 15, 4))\n\t    d = DataArray(a, dims=['y', 'x', 'z'])\n\t    d.coords['z'] = list('abcd')\n\t    g = d.plot(x='x', y='y', col='z', col_wrap=2, cmap='cool')\n\t    assert_array_equal(g.axs.shape, [2, 2])\n\t    for ax in g.axs.flat:\n\t        assert ax.has_data()\n\t    with pytest.raises(ValueError, match='[Ff]acet'):\n\t        d.plot(x='x', y='y', col='z', ax=plt.gca())\n\t    with pytest.raises(ValueError, match='[Ff]acet'):\n\t        d[0].plot(x='x', y='y', col='z', ax=plt.gca())\n\t\nTestPlot().test_convenient_facetgrid()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\t@pytest.mark.slow\n\tdef test_subplot_kws(self) ->None:\n\t    a = easy_array((10, 15, 4))\n\t    d = DataArray(a, dims=['y', 'x', 'z'])\n\t    d.coords['z'] = list('abcd')\n\t    g = d.plot(x='x', y='y', col='z', col_wrap=2, cmap='cool', subplot_kws=\n\t        dict(facecolor='r'))\n\t    for ax in g.axs.flat:\n\t        assert ax.get_facecolor()[0:3] == mpl.colors.to_rgb('r')\n\t\nTestPlot().test_subplot_kws()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}, {"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@requires_matplotlib\nclass PlotTestCase:\n\n    @pytest.fixture(autouse=True)\n    def setup(self) ->Generator:\n        yield\n        plt.close('all')\n\n    def pass_in_axis(self, plotmethod, subplot_kw=None) ->None:\n        fig, axs = plt.subplots(ncols=2, subplot_kw=subplot_kw, squeeze=False)\n        ax = axs[0, 0]\n        plotmethod(ax=ax)\n        assert ax.has_data()\n\n    @pytest.mark.slow\n    def imshow_called(self, plotmethod) ->bool:\n        plotmethod()\n        images = plt.gca().findobj(mpl.image.AxesImage)\n        return len(images) > 0\n\n    def contourf_called(self, plotmethod) ->bool:\n        plotmethod()\n\n        def matchfunc(x) ->bool:\n            return isinstance(x, (mpl.collections.PathCollection, mpl.\n                contour.QuadContourSet))\n        paths = plt.gca().findobj(matchfunc)\n        return len(paths) > 0\n\nclass TestPlot(PlotTestCase):\n\t@pytest.mark.slow\n\t@pytest.mark.filterwarnings('ignore:tight_layout cannot')\n\tdef test_convenient_facetgrid_4d(self) ->None:\n\t    a = easy_array((10, 15, 2, 3))\n\t    d = DataArray(a, dims=['y', 'x', 'columns', 'rows'])\n\t    g = d.plot(x='x', y='y', col='columns', row='rows')\n\t    assert_array_equal(g.axs.shape, [3, 2])\n\t    for ax in g.axs.flat:\n\t        assert ax.has_data()\n\t    with pytest.raises(ValueError, match='[Ff]acet'):\n\t        d.plot(x='x', y='y', col='columns', ax=plt.gca())\n\t\nTestPlot().test_convenient_facetgrid_4d()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}], "instruction": "Functionality: The easy_array function creates an array with a specified shape using values evenly spaced between a start and stop value.\n\nInputs: \n- shape: A tuple of integers representing the desired shape of the output array. For example, (2, 3) for a 2x3 array.\n- start: A float representing the starting value of the array. Default is 0.\n- stop: A float representing the ending value of the array. Default is 1.\n\nOutputs: \n- An ndarray of the specified shape with values evenly spaced between start and stop, inclusive.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n\n\ndef easy_array(shape: tuple[int, ...], start: float=0, stop: float=1\n    ) ->np.ndarray: [MASK]\n"}
{"method_name": "_color_palette", "full_method_name": "_color_palette", "method_path": "../srcdata/Basic/xarray/xarray/plot/utils.py", "method_code": "from __future__ import annotations\nimport itertools\nimport textwrap\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom datetime import date\nfrom datetime import datetime\nfrom inspect import getfullargspec\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import module_available\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import FuncFormatter\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import AspectOptions\nfrom xarray.core.types import ScaleOptions\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\nfrom seaborn import color_palette\nimport matplotlib.dates as mdates\ndef _color_palette(cmap, n_colors):\n    import matplotlib.pyplot as plt\n    from matplotlib.colors import ListedColormap\n    colors_i = np.linspace(0, 1.0, n_colors)\n    if isinstance(cmap, (list, tuple)):\n        cmap = ListedColormap(cmap, N=n_colors)\n        pal = cmap(colors_i)\n    elif isinstance(cmap, str):\n        try:\n            cmap = plt.get_cmap(cmap)\n            pal = cmap(colors_i)\n        except ValueError:\n            try:\n                from seaborn import color_palette\n                pal = color_palette(cmap, n_colors=n_colors)\n            except (ValueError, ImportError):\n                cmap = ListedColormap([cmap], N=n_colors)\n                pal = cmap(colors_i)\n    else:\n        pal = cmap(colors_i)\n    return pal", "test_code_list": [{"test_code": "import contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n\nclass TestDiscreteColorMap():\n\t@pytest.mark.slow\n\tdef test_recover_from_seaborn_jet_exception(self) ->None:\n\t    pal = _color_palette('jet', 4)\n\t    assert type(pal) == np.ndarray\n\t    assert len(pal) == 4\n\t\nTestDiscreteColorMap().test_recover_from_seaborn_jet_exception()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py"}], "instruction": "Functionality: The _color_palette function is designed to generate a palette of colors based on a given color map (cmap) and the number of colors (n_colors) desired. It supports various types of inputs for cmap, including lists, tuples, strings, and more, and ensures that the output is a sequence of colors that can be used for various visualization purposes.\n\nInputs:\n- cmap: This parameter can be of several types: a list or tuple of colors, a string representing a Matplotlib or Seaborn color map name, or any other object that can be interpreted as a color map by Matplotlib.\n- n_colors: An integer specifying the number of colors to generate in the palette.\n\nOutputs:\n- pal: A numpy array of shape (n_colors, 4) representing the color palette. Each row in the array corresponds to one color in the palette, and the four columns represent the red, green, blue, and alpha (transparency) values of each color, respectively.", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport textwrap\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom datetime import date\nfrom datetime import datetime\nfrom inspect import getfullargspec\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import module_available\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import FuncFormatter\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import AspectOptions\nfrom xarray.core.types import ScaleOptions\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\nfrom seaborn import color_palette\nimport matplotlib.dates as mdates\n\n\ndef _color_palette(cmap, n_colors): [MASK]\n"}
{"method_name": "da", "full_method_name": "da.interpolate_na", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py", "method_code": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@pytest.fixture\ndef da():\n    return xr.DataArray([0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7],\n        dims='time')", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_scipy\ndef test_interpolate_kwargs():\n    da = xr.DataArray(np.array([4, 5, np.nan], dtype=np.float64), dims='x')\n    expected = xr.DataArray(np.array([4, 5, 6], dtype=np.float64), dims='x')\n    actual = da.interpolate_na(dim='x', fill_value='extrapolate')\n    assert_equal(actual, expected)\n    expected = xr.DataArray(np.array([4, 5, -999], dtype=np.float64), dims='x')\n    actual = da.interpolate_na(dim='x', fill_value=-999)\n    assert_equal(actual, expected)\n\ntest_interpolate_kwargs()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_bottleneck\ndef test_interpolate_limits():\n    da = xr.DataArray(np.array([1, 2, np.nan, np.nan, np.nan, 6], dtype=np.\n        float64), dims='x')\n    actual = da.interpolate_na(dim='x', limit=None)\n    assert actual.isnull().sum() == 0\n    actual = da.interpolate_na(dim='x', limit=2)\n    expected = xr.DataArray(np.array([1, 2, 3, 4, np.nan, 6], dtype=np.\n        float64), dims='x')\n    assert_equal(actual, expected)\n\ntest_interpolate_limits()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_scipy\ndef test_interpolate_methods():\n    for method in ['linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic'\n        ]:\n        kwargs = {}\n        da = xr.DataArray(np.array([0, 1, 2, np.nan, np.nan, np.nan, 6, 7, \n            8], dtype=np.float64), dims='x')\n        actual = da.interpolate_na('x', method=method, **kwargs)\n        assert actual.isnull().sum() == 0\n        actual = da.interpolate_na('x', method=method, limit=2, **kwargs)\n        assert actual.isnull().sum() == 1\n\ntest_interpolate_methods()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\ndef test_interpolate_use_coordinate():\n    xc = xr.Variable('x', [100, 200, 300, 400, 500, 600])\n    da = xr.DataArray(np.array([1, 2, np.nan, np.nan, np.nan, 6], dtype=np.\n        float64), dims='x', coords={'xc': xc})\n    actual = da.interpolate_na(dim='x', use_coordinate=False)\n    expected = da.interpolate_na(dim='x')\n    assert_equal(actual, expected)\n    actual = da.interpolate_na(dim='x', use_coordinate='xc')\n    expected = da.interpolate_na(dim='x')\n    assert_equal(actual, expected)\n    actual = da.interpolate_na(dim='x', use_coordinate='x')\n    expected = da.interpolate_na(dim='x')\n    assert_equal(actual, expected)\n\ntest_interpolate_use_coordinate()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_bottleneck\ndef test_ffill_limit():\n    da = xr.DataArray([0, np.nan, np.nan, np.nan, np.nan, 3, 4, 5, np.nan, \n        6, 7], dims='time')\n    result = da.ffill('time')\n    expected = xr.DataArray([0, 0, 0, 0, 0, 3, 4, 5, 5, 6, 7], dims='time')\n    assert_array_equal(result, expected)\n    result = da.ffill('time', limit=1)\n    expected = xr.DataArray([0, 0, np.nan, np.nan, np.nan, 3, 4, 5, 5, 6, 7\n        ], dims='time')\n    assert_array_equal(result, expected)\n\ntest_ffill_limit()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}], "instruction": "Functionality: The da.interpolate_na function is designed to interpolate missing values (NaNs) in a DataArray. It can use various interpolation methods and handle multi-dimensional arrays. The function supports linear, cubic, and nearest neighbor interpolation methods and can also limit the number of consecutive NaNs to interpolate.\n\nInputs: \n- da: An xarray DataArray object with missing values that need to be interpolated. For example, da could be a DataArray with dimensions such as 'time' and missing values represented by NaNs.\n- dim: The dimension along which to interpolate. This is an optional argument.\n- method: The interpolation method to use, which can be 'linear', 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 'previous', or 'next'. This is an optional argument.\n- limit: The maximum number of consecutive NaNs to fill. This is an optional argument.\n- use_coordinate: Whether to use the values of the specified dimension as the x values in the interpolation. This is an optional argument.\n- kwargs: Additional keyword arguments to be passed to the interpolation method.\n\nOutputs: \n- interpolated_da: The function returns an xarray DataArray with the missing values interpolated according to the specified method and parameters. The dimensions and attributes of the output DataArray match those of the input DataArray, except for the values where NaNs were present.", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n\n\n@pytest.fixture\ndef da(): [MASK]\n"}
{"method_name": "make_interpolate_example_data", "full_method_name": "make_interpolate_example_data", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py", "method_code": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\ndef make_interpolate_example_data(shape, frac_nan, seed=12345, non_uniform=\n    False):\n    rs = np.random.RandomState(seed)\n    vals = rs.normal(size=shape)\n    if frac_nan == 1:\n        vals[:] = np.nan\n    elif frac_nan == 0:\n        pass\n    else:\n        n_missing = int(vals.size * frac_nan)\n        ys = np.arange(shape[0])\n        xs = np.arange(shape[1])\n        if n_missing:\n            np.random.shuffle(ys)\n            ys = ys[:n_missing]\n            np.random.shuffle(xs)\n            xs = xs[:n_missing]\n            vals[ys, xs] = np.nan\n    if non_uniform:\n        deltas = pd.to_timedelta(rs.normal(size=shape[0], scale=10), unit='D')\n        coords = {'time': (pd.Timestamp('2000-01-01') + deltas).sort_values()}\n    else:\n        coords = {'time': pd.date_range('2000-01-01', freq='D', periods=\n            shape[0])}\n    da = xr.DataArray(vals, dims=('time', 'x'), coords=coords)\n    df = da.to_pandas()\n    return da, df", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_scipy\ndef test_interpolate_pd_compat_non_uniform_index():\n    shapes = [(8, 8), (1, 20), (20, 1), (100, 100)]\n    frac_nans = [0, 0.5, 1]\n    methods = ['time', 'index', 'values']\n    for shape, frac_nan, method in itertools.product(shapes, frac_nans, methods\n        ):\n        da, df = make_interpolate_example_data(shape, frac_nan, non_uniform\n            =True)\n        for dim in ['time', 'x']:\n            if method == 'time' and dim != 'time':\n                continue\n            actual = da.interpolate_na(method='linear', dim=dim,\n                use_coordinate=True, fill_value=np.nan)\n            expected = df.interpolate(method=method, axis=da.get_axis_num(dim))\n            expected_values = expected.values.copy()\n            expected_values[pd.isnull(actual.values)] = np.nan\n            np.testing.assert_allclose(actual.values, expected_values)\n\ntest_interpolate_pd_compat_non_uniform_index()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@requires_scipy\ndef test_interpolate_pd_compat_polynomial():\n    shapes = [(8, 8), (1, 20), (20, 1), (100, 100)]\n    frac_nans = [0, 0.5, 1]\n    orders = [1, 2, 3]\n    for shape, frac_nan, order in itertools.product(shapes, frac_nans, orders):\n        da, df = make_interpolate_example_data(shape, frac_nan)\n        for dim in ['time', 'x']:\n            actual = da.interpolate_na(method='polynomial', order=order,\n                dim=dim, use_coordinate=False)\n            expected = df.interpolate(method='polynomial', order=order,\n                axis=da.get_axis_num(dim))\n            np.testing.assert_allclose(actual.values, expected.values)\n\ntest_interpolate_pd_compat_polynomial()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py"}], "instruction": "Functionality: The make_interpolate_example_data function generates data for testing interpolation algorithms. It creates a 2D array with a specified fraction of missing values and optionally non-uniformly spaced time coordinates. The function is useful for testing how interpolation methods handle missing data and irregular sampling.\n\nInputs:\n- shape: A tuple specifying the dimensions of the array to create. The first element is the number of time points, and the second is the number of other dimensions (e.g., spatial points).\n- frac_nan: A float between 0 and 1 indicating the fraction of data points to be set to NaN.\n- seed: An integer (default 12345) for initializing the random number generator to ensure reproducibility.\n- non_uniform: A boolean (default False) indicating whether to generate non-uniformly spaced time coordinates.\n\nOutputs:\n- da: An xarray DataArray containing the generated data with potential missing values and the specified dimensions.\n- df: A pandas DataFrame containing the same generated data as in da, for comparison and further analysis.", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n\n\ndef make_interpolate_example_data(shape, frac_nan, seed=12345, non_uniform=\n    False): [MASK]\n"}
{"method_name": "py_timedelta_to_float", "full_method_name": "py_timedelta_to_float", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef py_timedelta_to_float(array, datetime_unit):\n    \"\"\"Convert a timedelta object to a float, possibly at a loss of resolution.\"\"\"\n    array = asarray(array)\n    if is_duck_dask_array(array):\n        array = array.map_blocks(_timedelta_to_seconds, meta=np.array([],\n            dtype=np.float64))\n    else:\n        array = _timedelta_to_seconds(array)\n    conversion_factor = np.timedelta64(1, 'us') / np.timedelta64(1,\n        datetime_unit)\n    return conversion_factor * array", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\ndef test_py_timedelta_to_float():\n    assert py_timedelta_to_float(dt.timedelta(days=1), 'ns'\n        ) == 86400 * 1000000000.0\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 'ps'\n        ) == 86400 * 1e+18\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 'ns'\n        ) == 86400 * 1000000000000000.0\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 'us'\n        ) == 86400 * 1000000000000.0\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 'ms'\n        ) == 86400 * 1000000000.0\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 's'\n        ) == 86400 * 1000000.0\n    assert py_timedelta_to_float(dt.timedelta(days=1000000.0), 'D'\n        ) == 1000000.0\n\ntest_py_timedelta_to_float()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The function py_timedelta_to_float is designed to convert a timedelta object, which is an instance representing a duration, into a float value. This conversion is performed with respect to a specified datetime unit, potentially leading to a loss of resolution. The function supports both NumPy-like arrays and Dask arrays, applying the conversion accordingly.\n\nInputs: \n1. array: A timedelta object or an array-like object (either a NumPy array or a Dask array) containing timedelta objects.\n2. datetime_unit: A string indicating the unit of time for the conversion. This can be any of the following: 'Y', 'M', 'D', 'h', 'm', 's', 'ms', 'us', 'ns', 'ps', 'fs', 'as'.\n\nOutputs:\n1. float_array: A float value or an array of float values, depending on the input. The output will represent the duration in the specified datetime_unit. The resolution of the output may be lower than that of the input timedelta object due to the conversion process.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef py_timedelta_to_float(array, datetime_unit): [MASK]\n"}
{"method_name": "push", "full_method_name": "push", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef push(array, n, axis):\n    if not OPTIONS['use_bottleneck'] and not OPTIONS['use_numbagg']:\n        raise RuntimeError(\n            'ffill & bfill requires bottleneck or numbagg to be enabled. Call `xr.set_options(use_bottleneck=True)` or `xr.set_options(use_numbagg=True)` to enable one.'\n            )\n    if is_duck_dask_array(array):\n        return dask_array_ops.push(array, n, axis)\n    else:\n        return _push(array, n, axis)", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n@requires_dask\n@requires_bottleneck\ndef test_push_dask():\n    import bottleneck\n    import dask.array\n    array = np.array([np.nan, 1, 2, 3, np.nan, np.nan, np.nan, np.nan, 4, 5,\n        np.nan, 6])\n    for n in [None, 1, 2, 3, 4, 5, 11]:\n        expected = bottleneck.push(array, axis=0, n=n)\n        for c in range(1, 11):\n            with raise_if_dask_computes():\n                actual = push(dask.array.from_array(array, chunks=c), axis=\n                    0, n=n)\n            np.testing.assert_equal(actual, expected)\n        with raise_if_dask_computes():\n            actual = push(dask.array.from_array(array, chunks=(1, 2, 3, 2, \n                2, 1, 1)), axis=0, n=n)\n        np.testing.assert_equal(actual, expected)\n\ntest_push_dask()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The push function is designed to shift the elements of an array along a specified axis by a given number of positions. This operation is commonly referred to as \"rolling\" or \"sliding\" the elements of the array. The function supports both forward and backward shifts, depending on the direction and value of the shift parameter. It is particularly useful for data preprocessing, time series analysis, and other computational tasks where element rearrangement in an array or dataset is required.\n\nInputs:\n1. array: A numpy array or a duck array. This is the underlying data structure on which the push function operates. It can be of any shape and dimension, and should contain numerical data.\n2. n: An integer representing the number of positions to shift the elements of the array. The sign of this number determines the direction of the shift. A positive value shifts the elements forward while a negative value shifts them backward.\n3. axis: An integer that specifies the axis along which the elements are shifted. The axis should be within the range of the array's dimensions.\n\nOutputs:\n1. shifted_array: The output is a numpy array or a duck array, depending on the input type, with elements shifted by the specified number of positions along the designated axis. The shape and dimension of the output array remain the same as the input array, with the only difference being the rearrangement of its elements.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef push(array, n, axis): [MASK]\n"}
{"method_name": "concatenate", "full_method_name": "concatenate", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef concatenate(arrays, axis=0):\n    \"\"\"concatenate() with better dtype promotion rules.\"\"\"\n    if hasattr(arrays[0], '__array_namespace__') and not isinstance(arrays[\n        0], np.ndarray):\n        xp = get_array_namespace(arrays[0])\n        return xp.concat(as_shared_dtype(arrays, xp=xp), axis=axis)\n    return _concatenate(as_shared_dtype(arrays), axis=axis)", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestOps():\n\tdef test_concatenate_type_promotion(self):\n\t    result = concatenate([np.array([1]), np.array(['b'])])\n\t    assert_array_equal(result, np.array([1, 'b'], dtype=object))\n\t\nTestOps().test_concatenate_type_promotion()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The function 'concatenate' is designed to join a sequence of arrays along a new specified axis. It implements a version of numpy's concatenate function but with improved data type promotion rules, making it more versatile for handling arrays with different data types.\nInputs: \n- arrays: This is a sequence of array-like objects (numpy arrays, lists, etc.). All input arrays must have the same shape, except in the dimension corresponding to 'axis'.\n- axis: An integer, optional. This parameter specifies the axis along which the arrays will be joined. Default is 0 (along the first dimension).\nOutputs: \n- The function returns a single array that is the result of joining the input arrays along the specified 'axis'. The data type of the output array is determined by type promotion rules that aim to find the smallest data type into which all input arrays can be cast.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef concatenate(arrays, axis=0): [MASK]\n"}
{"method_name": "stack", "full_method_name": "stack", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef stack(arrays, axis=0):\n    \"\"\"stack() with better dtype promotion rules.\"\"\"\n    xp = get_array_namespace(arrays[0])\n    return xp.stack(as_shared_dtype(arrays, xp=xp), axis=axis)", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestOps():\n\tdef test_stack_type_promotion(self):\n\t    result = stack([1, 'b'])\n\t    assert_array_equal(result, np.array([1, 'b'], dtype=object))\n\t\nTestOps().test_stack_type_promotion()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The function 'stack' is designed to join a sequence of arrays along a new axis. The new axis is specified by the 'axis' argument. The arrays must have the same shape.\n\nInputs: \n1. arrays: This is a sequence of array-like objects. All input arrays must have the same shape.\n2. axis: An integer value that indicates the axis along which the arrays will be stacked. The default value is 0.\n\nOutputs: \n1. A single array with the input arrays stacked along the specified axis. The output array will have a new dimension inserted at the specified axis position.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef stack(arrays, axis=0): [MASK]\n"}
{"method_name": "mean", "full_method_name": "mean", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef mean(array, axis=None, skipna=None, **kwargs):\n    \"\"\"inhouse mean that can handle np.datetime64 or cftime.datetime\n    dtypes\"\"\"\n    from xarray.core.common import _contains_cftime_datetimes\n    array = asarray(array)\n    if dtypes.is_datetime_like(array.dtype):\n        offset = _datetime_nanmin(array)\n        dtype = 'timedelta64[ns]'\n        return _mean(datetime_to_numeric(array, offset), axis=axis, skipna=\n            skipna, **kwargs).astype(dtype) + offset\n    elif _contains_cftime_datetimes(array):\n        offset = min(array)\n        timedeltas = datetime_to_numeric(array, offset, datetime_unit='us')\n        mean_timedeltas = _mean(timedeltas, axis=axis, skipna=skipna, **kwargs)\n        return _to_pytimedelta(mean_timedeltas, unit='us') + offset\n    else:\n        return _mean(array, axis=axis, skipna=skipna, **kwargs)", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestOps():\n\t@pytest.mark.filterwarnings('error')\n\tdef test_all_nan_arrays(self):\n\t    assert np.isnan(mean([np.nan, np.nan]))\n\t\nTestOps().test_all_nan_arrays()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The mean function calculates the average of the elements of an input array along a specified axis, handling special cases for datetime and cftime datatypes.\n\nInputs:\n1. array: A numpy array or a similar array-like object for which the mean is to be calculated. The array can contain numerical, datetime, or cftime datetime values.\n2. axis: Optional. An integer or a tuple of integers specifying the axis or axes along which the means are computed. The default, None, will compute the mean of the flattened array.\n3. skipna: Optional. A boolean value indicating whether to skip missing values (NaNs) when computing the mean. If None (default), the function will use the global option.\n\nOutputs:\n1. mean: The mean of the input array along the specified axis. The output will be a numpy array or a scalar value depending on the input array and the specified axis. For datetime arrays, the mean will also be a datetime object or a datetime array.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef mean(array, axis=None, skipna=None, **kwargs): [MASK]\n"}
{"method_name": "array_notnull_equiv", "full_method_name": "array_notnull_equiv", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef array_notnull_equiv(arr1, arr2):\n    \"\"\"Like np.array_equal, but also allows values to be NaN in either or both\n    arrays\n    \"\"\"\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    lazy_equiv = lazy_array_equiv(arr1, arr2)\n    if lazy_equiv is None:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', \"In the future, 'NAT == x'\")\n            flag_array = (arr1 == arr2) | isnull(arr1) | isnull(arr2)\n            return bool(flag_array.all())\n    else:\n        return lazy_equiv", "test_code_list": [{"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestArrayNotNullEquiv():\n\tdef test_some_not_equal(self):\n\t    a = np.array([1, 2, 4])\n\t    b = np.array([1, np.nan, 3])\n\t    assert not array_notnull_equiv(a, b)\n\t\nTestArrayNotNullEquiv().test_some_not_equal()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}, {"test_code": "import datetime as dt\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom numpy import array\nfrom numpy import nan\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import cftime_range\nfrom xarray import concat\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.duck_array_ops import array_notnull_equiv\nfrom xarray.core.duck_array_ops import concatenate\nfrom xarray.core.duck_array_ops import count\nfrom xarray.core.duck_array_ops import first\nfrom xarray.core.duck_array_ops import gradient\nfrom xarray.core.duck_array_ops import last\nfrom xarray.core.duck_array_ops import least_squares\nfrom xarray.core.duck_array_ops import mean\nfrom xarray.core.duck_array_ops import np_timedelta64_to_float\nfrom xarray.core.duck_array_ops import pd_timedelta_to_float\nfrom xarray.core.duck_array_ops import push\nfrom xarray.core.duck_array_ops import py_timedelta_to_float\nfrom xarray.core.duck_array_ops import stack\nfrom xarray.core.duck_array_ops import timedelta_to_numeric\nfrom xarray.core.duck_array_ops import where\nfrom xarray.testing import assert_allclose\nfrom xarray.testing import assert_equal\nfrom xarray.testing import assert_identical\nfrom xarray.tests import arm_xfail\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nimport pyarrow as pa\nimport dask.array\nimport dask.array as da\nimport bottleneck\n\nclass TestArrayNotNullEquiv():\n\tdef test_wrong_shape(self):\n\t    a = np.array([[1, np.nan, np.nan, 4]])\n\t    b = np.array([[1, 2], [np.nan, 4]])\n\t    assert not array_notnull_equiv(a, b)\n\t\nTestArrayNotNullEquiv().test_wrong_shape()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_duck_array_ops.py"}], "instruction": "Functionality: The function array_notnull_equiv is designed to compare two arrays (arr1 and arr2) for equivalence, considering NaN values. It returns True if the arrays are equal or if the positions where NaN values are present in either or both arrays match, and False otherwise. The comparison is similar to np.array_equal but is more lenient with NaN values.\n\nInputs: \n1. arr1: A numpy array or array-like object. This is the first array to be compared.\n2. arr2: A numpy array or array-like object. This is the second array to be compared.\n\nOutputs: \n1. A boolean value indicating whether the arrays are equivalent considering NaN values. True if the arrays are equal or if NaN positions match, and False otherwise.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef array_notnull_equiv(arr1, arr2): [MASK]\n"}
{"method_name": "_consolidate_slices", "full_method_name": "_consolidate_slices", "method_path": "../srcdata/Basic/xarray/xarray/core/groupby.py", "method_code": "from __future__ import annotations\nimport copy\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import nputils\nfrom xarray.core import ops\nfrom xarray.core._aggregations import DataArrayGroupByAggregations\nfrom xarray.core._aggregations import DatasetGroupByAggregations\nfrom xarray.core.alignment import align\nfrom xarray.core.arithmetic import DataArrayGroupbyArithmetic\nfrom xarray.core.arithmetic import DatasetGroupbyArithmetic\nfrom xarray.core.common import ImplementsArrayReduce\nfrom xarray.core.common import ImplementsDatasetReduce\nfrom xarray.core.concat import concat\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import QuantileMethods\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.types import T_DataWithCoords\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import hashable\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import maybe_wrap_array\nfrom xarray.core.utils import module_available\nfrom xarray.core.utils import peek_at\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.util.deprecation_helpers import _deprecate_positional_args\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.utils import Frozen\ndef _consolidate_slices(slices: list[slice]) ->list[slice]:\n    \"\"\"Consolidate adjacent slices in a list of slices.\"\"\"\n    result: list[slice] = []\n    last_slice = slice(None)\n    for slice_ in slices:\n        if not isinstance(slice_, slice):\n            raise ValueError(f'list element is not a slice: {slice_!r}')\n        if result and last_slice.stop == slice_.start and _is_one_or_none(\n            last_slice.step) and _is_one_or_none(slice_.step):\n            last_slice = slice(last_slice.start, slice_.stop, slice_.step)\n            result[-1] = last_slice\n        else:\n            result.append(slice_)\n            last_slice = slice_\n    return result", "test_code_list": [{"test_code": "import operator\nimport warnings\nfrom unittest import mock\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom packaging.version import Version\nimport xarray as xr\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray import Variable\nfrom xarray.core.groupby import _consolidate_slices\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import InaccessibleArray\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import create_test_data\nfrom xarray.tests import has_cftime\nfrom xarray.tests import has_flox\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_flox\nfrom xarray.tests import requires_scipy\nfrom scipy.interpolate import interp1d\ndef test_consolidate_slices() ->None:\n    assert _consolidate_slices([slice(3), slice(3, 5)]) == [slice(5)]\n    assert _consolidate_slices([slice(2, 3), slice(3, 6)]) == [slice(2, 6)]\n    assert _consolidate_slices([slice(2, 3, 1), slice(3, 6, 1)]) == [slice(\n        2, 6, 1)]\n    slices = [slice(2, 3), slice(5, 6)]\n    assert _consolidate_slices(slices) == slices\n    with pytest.raises(ValueError):\n        _consolidate_slices([slice(3), 4])\n\ntest_consolidate_slices()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_groupby.py"}], "instruction": "Functionality: The _consolidate_slices function is designed to process a list of slices, consolidating adjacent slices into a single slice when possible. This is particularly useful for optimizing operations that deal with slice indexing, such as those found in array manipulations or data slicing in pandas DataFrames or xarray objects.\n\nInputs: \n- slices: A list of slice objects. Each slice object represents a segment with start, stop, and step attributes that define the range of the segment. The list can contain multiple slices that may or may not be adjacent to each other.\n\nOutputs: \n- A list of slice objects. The function returns a new list where adjacent slices from the input list are merged into a single slice if they are consecutive and have compatible step values (either both None or both 1). This consolidation ensures that the output list contains the minimum number of slices necessary to represent the same range as the original list of slices. In case of any non-slice input, the function raises a ValueError.", "method_code_mask": "from __future__ import annotations\nimport copy\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import nputils\nfrom xarray.core import ops\nfrom xarray.core._aggregations import DataArrayGroupByAggregations\nfrom xarray.core._aggregations import DatasetGroupByAggregations\nfrom xarray.core.alignment import align\nfrom xarray.core.arithmetic import DataArrayGroupbyArithmetic\nfrom xarray.core.arithmetic import DatasetGroupbyArithmetic\nfrom xarray.core.common import ImplementsArrayReduce\nfrom xarray.core.common import ImplementsDatasetReduce\nfrom xarray.core.concat import concat\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import QuantileMethods\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.types import T_DataWithCoords\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import hashable\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import maybe_wrap_array\nfrom xarray.core.utils import module_available\nfrom xarray.core.utils import peek_at\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.util.deprecation_helpers import _deprecate_positional_args\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.utils import Frozen\n\n\ndef _consolidate_slices(slices: list[slice]) ->list[slice]: [MASK]\n"}
{"method_name": "inline_variable_array_repr", "full_method_name": "inline_variable_array_repr", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef inline_variable_array_repr(var, max_width):\n    \"\"\"Build a one-line summary of a variable's data.\"\"\"\n    if hasattr(var._data, '_repr_inline_'):\n        return var._data._repr_inline_(max_width)\n    if var._in_memory:\n        return format_array_flat(var, max_width)\n    dask_array_type = array_type('dask')\n    if isinstance(var._data, dask_array_type):\n        return inline_dask_repr(var.data)\n    sparse_array_type = array_type('sparse')\n    if isinstance(var._data, sparse_array_type):\n        return inline_sparse_repr(var.data)\n    if hasattr(var._data, '__array_function__'):\n        return maybe_truncate(repr(var._data).replace('\\n', ' '), max_width)\n    return '...'", "test_code_list": [{"test_code": "import sys\nfrom textwrap import dedent\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting\nfrom xarray.core.indexes import Index\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom datetime import datetime\nimport dask.array as da\nfrom xarray.core.indexing import LazilyIndexedArray\ndef test_inline_variable_array_repr_custom_repr() ->None:\n\n\n    class CustomArray:\n\n        def __init__(self, value, attr):\n            self.value = value\n            self.attr = attr\n\n        def _repr_inline_(self, width):\n            formatted = f'({self.attr}) {self.value}'\n            if len(formatted) > width:\n                formatted = f'({self.attr}) ...'\n            return formatted\n\n        def __array_namespace__(self, *args, **kwargs):\n            return NotImplemented\n\n        @property\n        def shape(self) ->tuple[int, ...]:\n            return self.value.shape\n\n        @property\n        def dtype(self):\n            return self.value.dtype\n\n        @property\n        def ndim(self):\n            return self.value.ndim\n    value = CustomArray(np.array([20, 40]), 'm')\n    variable = xr.Variable('x', value)\n    max_width = 10\n    actual = inline_variable_array_repr(variable, max_width=10)\n    assert actual == value._repr_inline_(max_width)\n\ntest_inline_variable_array_repr_custom_repr()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting.py"}], "instruction": "Functionality: \nThe inline_variable_array_repr function is designed to build a one-line summary representation of a Variable's data. This function aims to provide a concise visual summary of the data contained within a Variable instance, especially useful for debugging and logging purposes. It supports various types of data representations, including in-memory arrays, Dask arrays, and sparse arrays, among others.\n\nInputs:\n1. var (Variable): A Variable instance whose data needs to be summarized. The Variable is expected to be a part of the xarray library and can contain different types of data arrays.\n2. max_width (int): An integer specifying the maximum width (in characters) for the returned string. This parameter helps in controlling the verbosity of the output and ensures that the summary does not exceed a certain length, making it suitable for display in limited spaces.\n\nOutputs:\nA string that is a one-line summary representation of the Variable's data. The string is truncated or formatted to fit within the specified max_width, providing a brief overview of the Variable's contents. The output string may vary based on the type of data contained in the Variable (e.g., in-memory array, Dask array, sparse array), and it will be designed to be as informative as possible given the constraints.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef inline_variable_array_repr(var, max_width): [MASK]\n"}
{"method_name": "set_numpy_options", "full_method_name": "set_numpy_options", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n@contextlib.contextmanager\ndef set_numpy_options(*args, **kwargs):\n    original = np.get_printoptions()\n    np.set_printoptions(*args, **kwargs)\n    try:\n        yield\n    finally:\n        np.set_printoptions(**original)", "test_code_list": [{"test_code": "import sys\nfrom textwrap import dedent\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting\nfrom xarray.core.indexes import Index\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom datetime import datetime\nimport dask.array as da\nfrom xarray.core.indexing import LazilyIndexedArray\ndef test_set_numpy_options() ->None:\n    original_options = np.get_printoptions()\n    with set_numpy_options(threshold=10):\n        assert len(repr(np.arange(500))) < 200\n    assert np.get_printoptions() == original_options\n\ntest_set_numpy_options()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting.py"}], "instruction": "Functionality: The set_numpy_options function is a context manager that temporarily changes the print options of NumPy for the duration of the enclosed code block. It allows the user to modify how NumPy arrays are printed, which can be useful for debugging or for generating more readable output under certain conditions. The function restores the original print options after the block is executed, ensuring that the changes do not affect the rest of the program.\n\nInputs: \n- *args: Positional arguments to be passed to np.set_printoptions(). These arguments can include values like precision, threshold, edgeitems, linewidth, etc., that control the print format of NumPy arrays.\n- **kwargs: Keyword arguments to be passed to np.set_printoptions(). These arguments serve the same purpose as the positional arguments but can be named for clarity and ease of use.\n\nOutputs:\n- None: The function itself does not return any output. However, it modifies the behavior of NumPy's print function within the scope of the enclosed block.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\n@contextlib.contextmanager\ndef set_numpy_options(*args, **kwargs): [MASK]\n"}
{"method_name": "first_n_items", "full_method_name": "first_n_items", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef first_n_items(array, n_desired):\n    \"\"\"Returns the first n_desired items of an array\"\"\"\n    from xarray.core.variable import Variable\n    if n_desired < 1:\n        raise ValueError('must request at least one item')\n    if array.size == 0:\n        return []\n    if n_desired < array.size:\n        indexer = _get_indexer_at_least_n_items(array.shape, n_desired,\n            from_end=False)\n        array = array[indexer]\n    if isinstance(array, Variable):\n        array = array._data\n    return np.ravel(to_duck_array(array))[:n_desired]", "test_code_list": [{"test_code": "import sys\nfrom textwrap import dedent\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting\nfrom xarray.core.indexes import Index\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom datetime import datetime\nimport dask.array as da\nfrom xarray.core.indexing import LazilyIndexedArray\n\nclass TestFormatting():\n\tdef test_last_n_items(self) ->None:\n\t    array = np.arange(100).reshape(10, 5, 2)\n\t    for n in [3, 10, 13, 100, 200]:\n\t        actual = formatting.last_n_items(array, n)\n\t        expected = array.flat[-n:]\n\t        assert (expected == actual).all()\n\t    with pytest.raises(ValueError, match='at least one item'):\n\t        first_n_items(array, 0)\n\t\nTestFormatting().test_last_n_items()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting.py"}], "instruction": "Functionality: The first_n_items function is designed to return the first n_desired items of a given array. It is capable of handling various types of arrays, including those from the xarray library. The function ensures that the output contains exactly n_desired items, truncating or expanding the array as necessary.\n\nInputs: \n- array: An array-like data structure from which items are to be retrieved. This can be a one-dimensional or multi-dimensional array, and it can be of any type that is compatible with the xarray library.\n- n_desired: An integer that represents the number of items to be returned from the array. This argument must be at least 1; otherwise, a ValueError will be raised.\n\nOutputs: \n- A list containing the first n_desired items of the input array. If the input array has fewer than n_desired items, the output list will contain all available items. If the input array is empty, an empty list is returned.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef first_n_items(array, n_desired): [MASK]\n"}
{"method_name": "maybe_truncate", "full_method_name": "maybe_truncate", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef maybe_truncate(obj, maxlen=500):\n    s = str(obj)\n    if len(s) > maxlen:\n        s = s[:maxlen - 3] + '...'\n    return s", "test_code_list": [{"test_code": "import sys\nfrom textwrap import dedent\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting\nfrom xarray.core.indexes import Index\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom datetime import datetime\nimport dask.array as da\nfrom xarray.core.indexing import LazilyIndexedArray\n\nclass TestFormatting():\n\tdef test_maybe_truncate(self) ->None:\n\t    assert maybe_truncate('\u00df', 10) == '\u00df'\n\t\nTestFormatting().test_maybe_truncate()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting.py"}], "instruction": "Functionality: The maybe_truncate function is designed to truncate the string representation of an input object if its length exceeds a specified maximum length. This function is useful for providing a shortened, readable representation of potentially large data structures.\n\nInputs: \n1. obj: Any Python object (e.g., string, list, dictionary, etc.). The function will convert this object into a string using the str() function before applying any truncation.\n2. maxlen (optional): An integer specifying the maximum allowed length of the string representation. If the length of the string representation exceeds this value, truncation will occur. The default value is 500.\n\nOutputs: \n1. A string representation of the input object. If the length of this string exceeds maxlen, the function returns a truncated version of the string, ending with '...'. Otherwise, it returns the complete string representation without any changes.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef maybe_truncate(obj, maxlen=500): [MASK]\n"}
{"method_name": "format_timestamp", "full_method_name": "format_timestamp", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef format_timestamp(t):\n    \"\"\"Cast given object to a Timestamp and return a nicely formatted string\"\"\"\n    try:\n        timestamp = pd.Timestamp(t)\n        datetime_str = timestamp.isoformat(sep=' ')\n    except OutOfBoundsDatetime:\n        datetime_str = str(t)\n    try:\n        date_str, time_str = datetime_str.split()\n    except ValueError:\n        return datetime_str\n    else:\n        if time_str == '00:00:00':\n            return date_str\n        else:\n            return f'{date_str}T{time_str}'", "test_code_list": [{"test_code": "import sys\nfrom textwrap import dedent\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core import formatting\nfrom xarray.core.indexes import Index\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_netCDF4\nfrom datetime import datetime\nimport dask.array as da\nfrom xarray.core.indexing import LazilyIndexedArray\n\nclass TestFormatting():\n\tdef test_format_timestamp_out_of_bounds(self) ->None:\n\t    from datetime import datetime\n\t    date = datetime(1300, 12, 1)\n\t    expected = '1300-12-01'\n\t    result = format_timestamp(date)\n\t    assert result == expected\n\t    date = datetime(2300, 12, 1)\n\t    expected = '2300-12-01'\n\t    result = format_timestamp(date)\n\t    assert result == expected\n\t\nTestFormatting().test_format_timestamp_out_of_bounds()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/xarray/xarray/tests/test_formatting.py"}], "instruction": "Functionality: The format_timestamp function is designed to take an input object, attempt to cast it to a Pandas Timestamp, and then return a string representation of the timestamp in a human-readable format. If the object cannot be cast to a Timestamp due to being out of bounds, it will return the string representation of the original object. The function simplifies the timestamp by removing the 'T' separator if the time is exactly midnight, otherwise, it formats the timestamp with a 'T' separator between the date and time.\n\nInputs: \n- t: The input object to be formatted. This can be any object that can potentially be cast to a Pandas Timestamp, including but not limited to datetime objects, timestamps, or strings that can be interpreted as dates or times.\n\nOutputs:\n- datetime_str: A string representation of the timestamp. If the time is exactly midnight, the time part is omitted, and only the date is returned. Otherwise, the date and time are returned in ISO format with a 'T' separator, for example, '2023-09-15T12:34:56'.", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef format_timestamp(t): [MASK]\n"}
