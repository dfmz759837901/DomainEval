{"method_name": "is_timestamp", "full_method_name": "is_timestamp", "method_path": "../srcdata/Basic/arrow/arrow/util.py", "method_code": "import datetime\nfrom typing import Any\nfrom typing import Optional\nfrom typing import cast\nfrom dateutil.rrule import WEEKLY\nfrom dateutil.rrule import rrule\nfrom arrow.constants import MAX_ORDINAL\nfrom arrow.constants import MAX_TIMESTAMP\nfrom arrow.constants import MAX_TIMESTAMP_MS\nfrom arrow.constants import MAX_TIMESTAMP_US\nfrom arrow.constants import MIN_ORDINAL\ndef is_timestamp(value: Any) ->bool:\n    \"\"\"Check if value is a valid timestamp.\"\"\"\n    if isinstance(value, bool):\n        return False\n    if not isinstance(value, (int, float, str)):\n        return False\n    try:\n        float(value)\n        return True\n    except ValueError:\n        return False", "test_code_list": [{"test_code": "import time\nfrom datetime import datetime\nimport pytest\nfrom arrow import util\n\nclass TestUtil():\n    def test_is_timestamp(self):\n        timestamp_float = time.time()\n        timestamp_int = int(timestamp_float)\n        assert is_timestamp(timestamp_int)\n        assert is_timestamp(timestamp_float)\n        assert is_timestamp(str(timestamp_int))\n        assert is_timestamp(str(timestamp_float))\n        assert not is_timestamp(True)\n        assert not is_timestamp(False)\n    \n    \n        class InvalidTimestamp:\n            pass\n        assert not is_timestamp(InvalidTimestamp())\n        full_datetime = '2019-06-23T13:12:42'\n        assert not is_timestamp(full_datetime)\n    \nTestUtil().test_is_timestamp()\n", "code_start": "", "test_path": "../srcdata/Basic/arrow/tests/test_util.py"}], "instruction": "Functionality: The function 'is_timestamp' is designed to determine whether a given value is a valid timestamp. It checks if the input value can be interpreted as a timestamp, which is essentially a number representing the time since the Unix epoch (midnight, January 1, 1970, UTC). The function should handle various types of inputs and return a boolean result based on whether the input can be considered a valid timestamp format.\n\nInputs: The function takes a single input argument 'value', which can be of any data type (int, float, str, etc.).\n\nOutputs: The function outputs a boolean value. If 'value' is a valid timestamp, the function returns True; otherwise, it returns False. The function will return False for non-numeric types, boolean values, and numeric values that cannot be converted to a float. Note that the function does not validate the timestamp's value itself (e.g., whether it represents a future date or a past date); it only checks if the input can be interpreted as a timestamp.", "method_code_mask": "import datetime\nfrom typing import Any\nfrom typing import Optional\nfrom typing import cast\nfrom dateutil.rrule import WEEKLY\nfrom dateutil.rrule import rrule\nfrom arrow.constants import MAX_ORDINAL\nfrom arrow.constants import MAX_TIMESTAMP\nfrom arrow.constants import MAX_TIMESTAMP_MS\nfrom arrow.constants import MAX_TIMESTAMP_US\nfrom arrow.constants import MIN_ORDINAL\n\n\ndef is_timestamp(value: Any) ->bool: [MASK]\n"}
{"method_name": "normalize_timestamp", "full_method_name": "normalize_timestamp", "method_path": "../srcdata/Basic/arrow/arrow/util.py", "method_code": "import datetime\nfrom typing import Any\nfrom typing import Optional\nfrom typing import cast\nfrom dateutil.rrule import WEEKLY\nfrom dateutil.rrule import rrule\nfrom arrow.constants import MAX_ORDINAL\nfrom arrow.constants import MAX_TIMESTAMP\nfrom arrow.constants import MAX_TIMESTAMP_MS\nfrom arrow.constants import MAX_TIMESTAMP_US\nfrom arrow.constants import MIN_ORDINAL\ndef normalize_timestamp(timestamp: float) ->float:\n    \"\"\"Normalize millisecond and microsecond timestamps into normal timestamps.\"\"\"\n    if timestamp > MAX_TIMESTAMP:\n        if timestamp < MAX_TIMESTAMP_MS:\n            timestamp /= 1000\n        elif timestamp < MAX_TIMESTAMP_US:\n            timestamp /= 1000000\n        else:\n            raise ValueError(\n                f'The specified timestamp {timestamp!r} is too large.')\n    return timestamp", "test_code_list": [{"test_code": "import time\nfrom datetime import datetime\nimport pytest\nfrom arrow import util\n\nclass TestUtil():\n    def test_normalize_timestamp(self):\n        timestamp = 1591161115.194556\n        millisecond_timestamp = 1591161115194\n        microsecond_timestamp = 1591161115194556\n        assert normalize_timestamp(timestamp) == timestamp\n        assert normalize_timestamp(millisecond_timestamp) == 1591161115.194\n        assert normalize_timestamp(microsecond_timestamp) == 1591161115.194556\n        with pytest.raises(ValueError):\n            normalize_timestamp(3e+17)\n    \nTestUtil().test_normalize_timestamp()\n", "code_start": "", "test_path": "../srcdata/Basic/arrow/tests/test_util.py"}], "instruction": "Functionality: The normalize_timestamp function is designed to take a timestamp that may be in milliseconds or microseconds and normalize it to a standard timestamp format, which is in seconds. This is particularly useful when dealing with timestamps that could be in different units, ensuring that they are all converted to the same unit for consistency and easier processing.\n\nInputs: \n- timestamp: A float representing the timestamp to be normalized. This timestamp could be in seconds, milliseconds, or microseconds.\n\nOutputs: \n- Returns a float representing the normalized timestamp, which will always be in seconds. If the input timestamp exceeds the maximum value for a standard timestamp (in seconds), the function will raise a ValueError, indicating that the timestamp is too large to be normalized.", "method_code_mask": "import datetime\nfrom typing import Any\nfrom typing import Optional\nfrom typing import cast\nfrom dateutil.rrule import WEEKLY\nfrom dateutil.rrule import rrule\nfrom arrow.constants import MAX_ORDINAL\nfrom arrow.constants import MAX_TIMESTAMP\nfrom arrow.constants import MAX_TIMESTAMP_MS\nfrom arrow.constants import MAX_TIMESTAMP_US\nfrom arrow.constants import MIN_ORDINAL\n\n\ndef normalize_timestamp(timestamp: float) ->float: [MASK]\n"}
