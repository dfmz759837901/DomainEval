{"method_name": "repair_item", "full_method_name": "repair_item", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/repair.py", "method_code": "from __future__ import annotations\nimport logging\nfrom os.path import basename\nimport aiostream\ndef repair_item(href, item, seen_uids, repair_unsafe_uid):\n    if item.parsed is None:\n        raise IrreparableItem\n    new_item = item\n    if not item.uid:\n        logger.warning('No UID, assigning random UID.')\n        new_item = item.with_uid(generate_href())\n    elif item.uid in seen_uids:\n        logger.warning('Duplicate UID, assigning random UID.')\n        new_item = item.with_uid(generate_href())\n    elif not href_safe(item.uid) or not href_safe(basename(href)):\n        if not repair_unsafe_uid:\n            logger.warning(\n                'UID may cause problems, add --repair-unsafe-uid to repair.')\n        else:\n            logger.warning('UID or href is unsafe, assigning random UID.')\n            new_item = item.with_uid(generate_href())\n    if not new_item.uid:\n        raise IrreparableItem\n    return new_item", "test_code_list": [{"test_code": "import aiostream\nimport pytest\nfrom vdirsyncer.repair import IrreparableItem\nfrom vdirsyncer.repair import repair_item\nfrom vdirsyncer.repair import repair_storage\nfrom vdirsyncer.storage.memory import MemoryStorage\nfrom vdirsyncer.utils import href_safe\nfrom vdirsyncer.vobject import Item\ndef test_repair_do_nothing():\n    item = Item('BEGIN:VCARD\\nUID:justfine\\nEND:VCARD')\n    assert repair_item('fine', item, set(), True) is item\n    assert repair_item('@@@@/fine', item, set(), True) is item\n\ntest_repair_do_nothing()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/test_repair.py"}], "instruction": "Functionality: The repair_item function is designed to process and repair potentially problematic items from a list. It checks if the item has a parsed attribute, ensures that the item has a unique identifier (UID), and verifies that the UID and the base name of the href are safe. If any of these conditions are not met, the function generates a new random UID for the item.\n\nInputs: \n- href (str): A string representing the href associated with the item.\n- item (object): An object that represents an item to be processed. It should have attributes parsed, uid, and a method with_uid to generate an item with a new UID.\n- seen_uids (set): A set containing all UIDs that have already been seen in the list. This is used to check for duplicate UIDs.\n- repair_unsafe_uid (bool): A boolean flag that determines whether the function should repair items with unsafe UIDs. If True, it will generate a new UID; if False, it will log a warning and not modify the item.\n\nOutputs:\n- Returns a new_item (object) with the corrected UID if the item was successfully repaired.\n- Raises an IrreparableItem exception if the item cannot be assigned a UID or if it fails to meet the required conditions after attempts to repair it.", "method_code_mask": "from __future__ import annotations\nimport logging\nfrom os.path import basename\nimport aiostream\n\n\ndef repair_item(href, item, seen_uids, repair_unsafe_uid): [MASK]\n"}
{"method_name": "expand_fetch_params", "full_method_name": "expand_fetch_params", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/cli/fetchparams.py", "method_code": "from __future__ import annotations\nimport logging\nimport click\nimport subprocess\ndef expand_fetch_params(config):\n    config = dict(config)\n    for key in list(config):\n        if not key.endswith(SUFFIX):\n            continue\n        newkey = key[:-len(SUFFIX)]\n        if newkey in config:\n            raise ValueError(f\"Can't set {key} and {newkey}.\")\n        config[newkey] = _fetch_value(config[key], key)\n        del config[key]\n    return config", "test_code_list": [{"test_code": "from contextlib import contextmanager\nfrom unittest.mock import patch\nimport pytest\nfrom vdirsyncer import exceptions\nfrom vdirsyncer.cli.fetchparams import STRATEGIES\nfrom vdirsyncer.cli.fetchparams import expand_fetch_params\ndef test_key_conflict():\n    with pytest.raises(ValueError) as excinfo:\n        expand_fetch_params({'foo': 'bar', 'foo.fetch': ['mystrategy', 'baz']})\n    assert \"Can't set foo.fetch and foo.\" in str(excinfo.value)\n\ntest_key_conflict()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/cli/test_fetchparams.py"}, {"test_code": "from contextlib import contextmanager\nfrom unittest.mock import patch\nimport pytest\nfrom vdirsyncer import exceptions\nfrom vdirsyncer.cli.fetchparams import STRATEGIES\nfrom vdirsyncer.cli.fetchparams import expand_fetch_params\ndef test_unknown_strategy():\n    with pytest.raises(exceptions.UserError) as excinfo:\n        expand_fetch_params({'foo.fetch': ['unreal', 'asdf']})\n    assert 'Unknown strategy' in str(excinfo.value)\n\ntest_unknown_strategy()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/cli/test_fetchparams.py"}], "instruction": "Functionality: The function 'expand_fetch_params' takes a dictionary as an input, which represents a configuration. It processes the dictionary by expanding any key that ends with a specific suffix (denoted as 'SUFFIX' in the code, but its actual value is not provided). The function checks for keys that end with this suffix, removes the suffix from the key, fetches the value associated with the original key, and then replaces the original key with the new key (without the suffix) in the dictionary. The fetched value, obtained by a private function '_fetch_value', is then assigned to the new key. If a key without the suffix already exists in the dictionary, the function raises a ValueError to prevent overwriting or conflicting configurations.\n\nInputs: \n- config: A dictionary representing the configuration. The dictionary keys should be strings, and the values can be of any type that is compatible with the '_fetch_value' function.\n\nOutputs: \n- Returns a modified dictionary where keys that ended with the 'SUFFIX' have been expanded and renamed, and their values have been fetched and replaced accordingly. If any error occurs, such as a conflict with an existing key without the suffix, the function will raise a ValueError.", "method_code_mask": "from __future__ import annotations\nimport logging\nimport click\nimport subprocess\n\n\ndef expand_fetch_params(config): [MASK]\n"}
{"method_name": "parse", "full_method_name": "_Component.parse", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/vobject.py", "method_code": "from __future__ import annotations\nimport hashlib\nfrom itertools import chain\nfrom itertools import tee\nclass _Component:\n    \"\"\"\n    Raw outline of the components.\n\n    Vdirsyncer's operations on iCalendar and VCard objects are limited to\n    retrieving the UID and splitting larger files into items. Consequently this\n    parser is very lazy, with the downside that manipulation of item properties\n    are extremely costly.\n\n    Other features:\n\n    - Preserve the original property order and wrapping.\n    - Don't choke on irrelevant details like invalid datetime formats.\n\n    Original version from https://github.com/collective/icalendar/, but apart\n    from the similar API, very few parts have been reused.\n    \"\"\"\n\n    def __init__(self, name, lines, subcomponents):\n        \"\"\"\n        :param name: The component name.\n        :param lines: The component's own properties, as list of lines\n            (strings).\n        :param subcomponents: List of components.\n        \"\"\"\n        self.name = name\n        self.props = lines\n        self.subcomponents = subcomponents\n\n    @classmethod\n    def parse(cls, lines, multiple=False):\n        if isinstance(lines, bytes):\n            lines = lines.decode('utf-8')\n        if isinstance(lines, str):\n            lines = lines.splitlines()\n        stack = []\n        rv = []\n        try:\n            for _i, line in enumerate(lines):\n                if line.startswith('BEGIN:'):\n                    c_name = line[len('BEGIN:'):].strip().upper()\n                    stack.append(cls(c_name, [], []))\n                elif line.startswith('END:'):\n                    component = stack.pop()\n                    c_name = line[len('END:'):].strip().upper()\n                    if c_name != component.name:\n                        raise ValueError(\n                            f'Got END:{c_name}, expected END:{component.name}'\n                             + f' at line {_i + 1}')\n                    if stack:\n                        stack[-1].subcomponents.append(component)\n                    else:\n                        rv.append(component)\n                elif line.strip():\n                    stack[-1].props.append(line)\n        except IndexError:\n            raise ValueError(f'Parsing error at line {_i + 1}')\n        if len(stack) > 0:\n            raise ValueError(\n                f\"Missing END for component(s): {', '.join(c.name for c in stack)}\"\n                )\n        if multiple:\n            return rv\n        elif len(rv) != 1:\n            raise ValueError(f'Found {len(rv)} components, expected one.')\n        else:\n            return rv[0]\n\n    def dump_lines(self):\n        yield f'BEGIN:{self.name}'\n        yield from self.props\n        for c in self.subcomponents:\n            yield from c.dump_lines()\n        yield f'END:{self.name}'\n\n    def __delitem__(self, key):\n        prefix = f'{key}:', f'{key};'\n        new_lines = []\n        lineiter = iter(self.props)\n        while True:\n            for line in lineiter:\n                if line.startswith(prefix):\n                    break\n                else:\n                    new_lines.append(line)\n            else:\n                break\n            for line in lineiter:\n                if not line.startswith((' ', '\\t')):\n                    new_lines.append(line)\n                    break\n        self.props = new_lines\n\n    def __setitem__(self, key, val):\n        assert isinstance(val, str)\n        assert '\\n' not in val\n        del self[key]\n        line = f'{key}:{val}'\n        self.props.append(line)\n\n    def __contains__(self, obj):\n        if isinstance(obj, type(self)):\n            return obj not in self.subcomponents and not any(obj in x for x in\n                self.subcomponents)\n        elif isinstance(obj, str):\n            return self.get(obj, None) is not None\n        else:\n            raise ValueError(obj)\n\n    def __getitem__(self, key):\n        prefix_without_params = f'{key}:'\n        prefix_with_params = f'{key};'\n        iterlines = iter(self.props)\n        for line in iterlines:\n            if line.startswith(prefix_without_params):\n                rv = line[len(prefix_without_params):]\n                break\n            elif line.startswith(prefix_with_params):\n                rv = line[len(prefix_with_params):].split(':', 1)[-1]\n                break\n        else:\n            raise KeyError\n        for line in iterlines:\n            if line.startswith((' ', '\\t')):\n                rv += line[1:]\n            else:\n                break\n        return rv\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __eq__(self, other):\n        return (isinstance(other, type(self)) and self.name == other.name and\n            self.props == other.props and self.subcomponents == other.\n            subcomponents)", "test_code_list": [{"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_broken_item():\n    with pytest.raises(ValueError) as excinfo:\n        _Component.parse('END:FOO')\n    assert 'Parsing error at line 1' in str(excinfo.value)\n    item = vobject.Item('END:FOO')\n    assert item.parsed is None\n\ntest_broken_item()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}, {"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_mismatched_end():\n    with pytest.raises(ValueError) as excinfo:\n        _Component.parse(['BEGIN:FOO', 'END:BAR'])\n    assert 'Got END:BAR, expected END:FOO at line 2' in str(excinfo.value)\n\ntest_mismatched_end()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}, {"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_missing_end():\n    with pytest.raises(ValueError) as excinfo:\n        _Component.parse(['BEGIN:FOO', 'BEGIN:BAR', 'END:BAR'])\n    assert 'Missing END for component(s): FOO' in str(excinfo.value)\n\ntest_missing_end()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}, {"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_multiple_items():\n    with pytest.raises(ValueError) as excinfo:\n        _Component.parse(['BEGIN:FOO', 'END:FOO', 'BEGIN:FOO',\n            'END:FOO'])\n    assert 'Found 2 components, expected one' in str(excinfo.value)\n    c1, c2 = _Component.parse(['BEGIN:FOO', 'END:FOO', 'BEGIN:FOO',\n        'END:FOO'], multiple=True)\n    assert c1.name == c2.name == 'FOO'\n\ntest_multiple_items()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}, {"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_input_types():\n    lines = ['BEGIN:FOO', 'FOO:BAR', 'END:FOO']\n    for x in (lines, '\\r\\n'.join(lines), '\\r\\n'.join(lines).encode('ascii')):\n        c = _Component.parse(x)\n        assert c.name == 'FOO'\n        assert c.props == ['FOO:BAR']\n        assert not c.subcomponents\n\ntest_input_types()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}, {"test_code": "from textwrap import dedent\nimport pytest\nimport vdirsyncer.vobject as vobject\ndef test_component_contains():\n    item = _Component.parse(['BEGIN:FOO', 'FOO:YES', 'END:FOO'])\n    assert 'FOO' in item\n    assert 'BAZ' not in item\n    with pytest.raises(ValueError):\n        42 in item\n\ntest_component_contains()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/unit/utils/test_vobject.py"}], "instruction": "Functionality: Parses a string or bytes object that represents one or more iCalendar or VCard components into a structured component object.\n\nInputs: \n- lines: A string, list of strings, or bytes object. If it's a bytes object, it will be decoded to utf-8. If it's a string, it will be split into lines. If it's a list, it should already be a list of strings.\n- multiple: A boolean value. If set to True, the function will return all components found. If set to False, it will raise an exception if more than one component is found, and it will return only the first component.\n\nOutputs:\n- If multiple is True, returns a list of Component objects.\n- If multiple is False, returns a single Component object or raises a ValueError if more than one component is detected in the input.", "method_code_mask": "from __future__ import annotations\nimport hashlib\nfrom itertools import chain\nfrom itertools import tee\n\n\nclass _Component:\n    \"\"\"\n    Raw outline of the components.\n\n    Vdirsyncer's operations on iCalendar and VCard objects are limited to\n    retrieving the UID and splitting larger files into items. Consequently this\n    parser is very lazy, with the downside that manipulation of item properties\n    are extremely costly.\n\n    Other features:\n\n    - Preserve the original property order and wrapping.\n    - Don't choke on irrelevant details like invalid datetime formats.\n\n    Original version from https://github.com/collective/icalendar/, but apart\n    from the similar API, very few parts have been reused.\n    \"\"\"\n\n    def __init__(self, name, lines, subcomponents):\n        \"\"\"\n        :param name: The component name.\n        :param lines: The component's own properties, as list of lines\n            (strings).\n        :param subcomponents: List of components.\n        \"\"\"\n        self.name = name\n        self.props = lines\n        self.subcomponents = subcomponents\n\n    @classmethod\n    def parse(cls, lines, multiple=False): [MASK]\n\n    def dump_lines(self):\n        yield f'BEGIN:{self.name}'\n        yield from self.props\n        for c in self.subcomponents:\n            yield from c.dump_lines()\n        yield f'END:{self.name}'\n\n    def __delitem__(self, key):\n        prefix = f'{key}:', f'{key};'\n        new_lines = []\n        lineiter = iter(self.props)\n        while True:\n            for line in lineiter:\n                if line.startswith(prefix):\n                    break\n                else:\n                    new_lines.append(line)\n            else:\n                break\n            for line in lineiter:\n                if not line.startswith((' ', '\\t')):\n                    new_lines.append(line)\n                    break\n        self.props = new_lines\n\n    def __setitem__(self, key, val):\n        assert isinstance(val, str)\n        assert '\\n' not in val\n        del self[key]\n        line = f'{key}:{val}'\n        self.props.append(line)\n\n    def __contains__(self, obj):\n        if isinstance(obj, type(self)):\n            return obj not in self.subcomponents and not any(obj in x for x in\n                self.subcomponents)\n        elif isinstance(obj, str):\n            return self.get(obj, None) is not None\n        else:\n            raise ValueError(obj)\n\n    def __getitem__(self, key):\n        prefix_without_params = f'{key}:'\n        prefix_with_params = f'{key};'\n        iterlines = iter(self.props)\n        for line in iterlines:\n            if line.startswith(prefix_without_params):\n                rv = line[len(prefix_without_params):]\n                break\n            elif line.startswith(prefix_with_params):\n                rv = line[len(prefix_with_params):].split(':', 1)[-1]\n                break\n        else:\n            raise KeyError\n        for line in iterlines:\n            if line.startswith((' ', '\\t')):\n                rv += line[1:]\n            else:\n                break\n        return rv\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __eq__(self, other):\n        return (isinstance(other, type(self)) and self.name == other.name and\n            self.props == other.props and self.subcomponents == other.\n            subcomponents)\n"}
{"method_name": "_parse_xml", "full_method_name": "_parse_xml", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/storage/dav.py", "method_code": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\ndef _parse_xml(content):\n    try:\n        return etree.XML(_clean_body(content))\n    except etree.ParseError as e:\n        raise InvalidXMLResponse(\n            f\"\"\"Invalid XML encountered: {e}\nDouble-check the URLs in your config.\"\"\"\n            )", "test_code_list": [{"test_code": "import pytest\nfrom vdirsyncer.storage.dav import _BAD_XML_CHARS\nfrom vdirsyncer.storage.dav import _merge_xml\nfrom vdirsyncer.storage.dav import _normalize_href\nfrom vdirsyncer.storage.dav import _parse_xml\ndef test_xml_utilities():\n    x = _parse_xml(\n        b'<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n        <multistatus xmlns=\"DAV:\">\\n            <response>\\n                <propstat>\\n                    <status>HTTP/1.1 404 Not Found</status>\\n                    <prop>\\n                        <getcontenttype/>\\n                    </prop>\\n                </propstat>\\n                <propstat>\\n                    <prop>\\n                        <resourcetype>\\n                            <collection/>\\n                        </resourcetype>\\n                    </prop>\\n                </propstat>\\n            </response>\\n        </multistatus>\\n    '\n        )\n    response = x.find('{DAV:}response')\n    props = _merge_xml(response.findall('{DAV:}propstat/{DAV:}prop'))\n    assert props.find('{DAV:}resourcetype/{DAV:}collection') is not None\n    assert props.find('{DAV:}getcontenttype') is not None\n\ntest_xml_utilities()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/storage/dav/test_main.py"}], "instruction": "Functionality: The function _parse_xml is responsible for parsing XML content into an ElementTree object. It takes a string content as input, which is expected to be in XML format. The function first cleans the body of the content (this cleaning process is handled by another function, _clean_body, not shown here). After cleaning, it attempts to parse the content using the xml.etree.ElementTree module's XML function. If the parsing is successful, the function returns the ElementTree object. However, if the content is not valid XML, the function raises an InvalidXMLResponse exception with a descriptive message, indicating that the XML is invalid and suggesting to double-check the URLs in the configuration.\n\nInputs: \n- content: A string containing the XML content to be parsed.\n\nOutputs:\n- An ElementTree object representing the parsed XML content if the parsing is successful.\n- If the XML content is invalid, the function raises an InvalidXMLResponse exception instead.", "method_code_mask": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\n\n\ndef _parse_xml(content): [MASK]\n"}
{"method_name": "_merge_xml", "full_method_name": "_merge_xml", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/storage/dav.py", "method_code": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\ndef _merge_xml(items):\n    if not items:\n        return None\n    rv = items[0]\n    for item in items[1:]:\n        rv.extend(item.iter())\n    return rv", "test_code_list": [{"test_code": "import pytest\nfrom vdirsyncer.storage.dav import _BAD_XML_CHARS\nfrom vdirsyncer.storage.dav import _merge_xml\nfrom vdirsyncer.storage.dav import _normalize_href\nfrom vdirsyncer.storage.dav import _parse_xml\ndef test_xml_utilities():\n    x = _parse_xml(\n        b'<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\\n        <multistatus xmlns=\"DAV:\">\\n            <response>\\n                <propstat>\\n                    <status>HTTP/1.1 404 Not Found</status>\\n                    <prop>\\n                        <getcontenttype/>\\n                    </prop>\\n                </propstat>\\n                <propstat>\\n                    <prop>\\n                        <resourcetype>\\n                            <collection/>\\n                        </resourcetype>\\n                    </prop>\\n                </propstat>\\n            </response>\\n        </multistatus>\\n    '\n        )\n    response = x.find('{DAV:}response')\n    props = _merge_xml(response.findall('{DAV:}propstat/{DAV:}prop'))\n    assert props.find('{DAV:}resourcetype/{DAV:}collection') is not None\n    assert props.find('{DAV:}getcontenttype') is not None\n\ntest_xml_utilities()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Basic/vdirsyncer/tests/storage/dav/test_main.py"}], "instruction": "Functionality: The _merge_xml function is designed to merge multiple XML items into a single XML element. It takes a list of XML elements as input and combines them by appending the iter() of each subsequent element to the first element. If the input list is empty, it returns None.\n\nInputs: \n- items: A list of XML elements (from xml.etree.ElementTree as etree) that are to be merged. Each item in the list should be an instance of an XML element that can be iterated over.\n\nOutputs:\n- If the input list is not empty, the function returns a single merged XML element that contains all the elements in the input list.\n- If the input list is empty, the function returns None.", "method_code_mask": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\n\n\ndef _merge_xml(items): [MASK]\n"}
