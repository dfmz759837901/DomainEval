{"method_name": "luhn_checksum", "full_method_name": "luhn_checksum", "method_path": "../srcdata/Basic/faker/faker/utils/checksums.py", "method_code": "from typing import List\ndef luhn_checksum(number: float) ->int:\n\n    def digits_of(n: float) ->List[int]:\n        return [int(d) for d in str(n)]\n    digits = digits_of(number)\n    odd_digits = digits[-1::-2]\n    even_digits = digits[-2::-2]\n    checksum = 0\n    checksum += sum(odd_digits)\n    for d in even_digits:\n        checksum += sum(digits_of(d * 2))\n    return checksum % 10", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_valid_luhn(self):\n\t    \"\"\"\n\t        Tests if the number has a valid check digit\n\t        Example from wiki https://en.wikipedia.org/wiki/Luhn_algorithm\n\t        \"\"\"\n\t    assert luhn_checksum('79927398713') == 0\n\t\nUtilsTestCase().test_valid_luhn()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}, {"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_invalid_luhn(self):\n\t    \"\"\"\n\t        Tests a number with an invalid check digit\n\t        Example from wiki https://en.wikipedia.org/wiki/Luhn_algorithm\n\t        \"\"\"\n\t    assert luhn_checksum('79927398714') != 0\n\t\nUtilsTestCase().test_invalid_luhn()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The luhn_checksum function is designed to calculate the Luhn checksum for a given number. The Luhn algorithm, also known as the \"modulus 10\" or \"mod 10\" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the United States, and Canadian Social Insurance Numbers. This function implements the algorithm by first separating the digits of the input number into odd and even positions (from the right), doubling the digits in the even positions, summing all digits, and finally calculating the checksum as the modulus 10 of the total sum.\n\nInputs: \nnumber: float - The number for which the Luhn checksum is to be calculated. It should be a positive number, and it can contain decimal points (which will be ignored during the calculation).\n\nOutputs:\nchecksum: int - The Luhn checksum of the input number. The checksum is calculated as the modulus 10 of the total sum of digits, where digits in even positions (from the right) are doubled and then summed together with the digits in odd positions.", "method_code_mask": "from typing import List\n\n\ndef luhn_checksum(number: float) ->int: [MASK]\n"}
{"method_name": "get_path", "full_method_name": "get_path", "method_path": "../srcdata/Basic/faker/faker/utils/loading.py", "method_code": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\ndef get_path(module: ModuleType) ->str:\n    if getattr(sys, 'frozen', False):\n        if getattr(sys, '_MEIPASS', False):\n            lib_dir = Path(getattr(sys, '_MEIPASS'))\n        else:\n            lib_dir = Path(sys.executable).parent / 'lib'\n        path = lib_dir.joinpath(*module.__package__.split('.'))\n    elif module.__file__ is not None:\n        path = Path(module.__file__).parent\n    else:\n        raise RuntimeError(f\"Can't find path from module `{module}.\")\n    return str(path)", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_get_path(self):\n\t    result = get_path(faker)\n\t    assert isinstance(result, str)\n\t\nUtilsTestCase().test_get_path()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The get_path function is designed to determine the file system path of a given Python module. It is useful for discovering the location of a module's files, which can be critical for accessing data or resources that are packaged alongside the module. This function is particularly robust, as it can handle both standard Python environments and frozen environments such as those created by PyInstaller.\n\nInputs: \n1. module: The input to this function is a Python module object. This is typically obtained using the importlib.import_module function or similar methods. The module can be any loaded Python module for which you would like to find the file system path.\n\nOutputs:\n1. The function returns a string that represents the file system path of the module's directory. This path can be used for file system operations, such as reading files from disk that are located in the same directory as the module.", "method_code_mask": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\n\n\ndef get_path(module: ModuleType) ->str: [MASK]\n"}
{"method_name": "find_available_locales", "full_method_name": "find_available_locales", "method_path": "../srcdata/Basic/faker/faker/utils/loading.py", "method_code": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\ndef find_available_locales(providers: List[str]) ->List[str]:\n    available_locales = set()\n    for provider_path in providers:\n        provider_module = import_module(provider_path)\n        if getattr(provider_module, 'localized', False):\n            langs = list_module(provider_module)\n            available_locales.update(langs)\n    return sorted(available_locales)", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_find_available_locales(self):\n\t    result = find_available_locales(PROVIDERS)\n\t    assert len(result) != 0\n\t\nUtilsTestCase().test_find_available_locales()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The find_available_locales function is designed to discover all available language locales provided by a list of given provider modules. This function will inspect each provider module, check if it supports localization, and then collect all the locales (languages) it can provide. The function will ensure that the locales are returned without duplicates and in a sorted order.\n\nInputs: \n- providers: A list of strings where each string is a path to a provider module. These modules are expected to potentially have localized content or functionality.\n\nOutputs:\n- A list of strings representing all the unique available locales (languages) across the given provider modules, sorted alphabetically.", "method_code_mask": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\n\n\ndef find_available_locales(providers: List[str]) ->List[str]: [MASK]\n"}
{"method_name": "find_available_providers", "full_method_name": "find_available_providers", "method_path": "../srcdata/Basic/faker/faker/utils/loading.py", "method_code": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\ndef find_available_providers(modules: List[ModuleType]) ->List[str]:\n    available_providers = set()\n    for providers_mod in modules:\n        if providers_mod.__package__:\n            providers = ['.'.join([providers_mod.__package__, mod]) for mod in\n                list_module(providers_mod) if mod != '__pycache__']\n            available_providers.update(providers)\n    return sorted(available_providers)", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_find_available_providers(self):\n\t    modules = [import_module(path) for path in META_PROVIDERS_MODULES]\n\t    providers = find_available_providers(modules)\n\t    expected_providers = list(map(str, ['faker.providers.address',\n\t        'faker.providers.automotive', 'faker.providers.bank',\n\t        'faker.providers.barcode', 'faker.providers.color',\n\t        'faker.providers.company', 'faker.providers.credit_card',\n\t        'faker.providers.currency', 'faker.providers.date_time',\n\t        'faker.providers.emoji', 'faker.providers.file',\n\t        'faker.providers.geo', 'faker.providers.internet',\n\t        'faker.providers.isbn', 'faker.providers.job',\n\t        'faker.providers.lorem', 'faker.providers.misc',\n\t        'faker.providers.passport', 'faker.providers.person',\n\t        'faker.providers.phone_number', 'faker.providers.profile',\n\t        'faker.providers.python', 'faker.providers.sbn',\n\t        'faker.providers.ssn', 'faker.providers.user_agent']))\n\t    assert providers == expected_providers\n\t\nUtilsTestCase().test_find_available_providers()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The find_available_providers function is designed to scan through a list of Python module objects and find all the submodules (providers) that can be imported from these modules. It excludes any submodule that might be a Python bytecode storage (__pycache__). The function then returns a sorted list of strings, each representing the full path to an available provider submodule.\n\nInputs: \n- modules: A list of Python module objects. Each module is expected to possibly contain submodules (providers) that can be imported.\n\nOutputs:\n- A list of strings representing the available provider modules. Each string in the list is a full path to a provider submodule, sorted alphabetically. The path is constructed by combining the package name of the module with the submodule's name, separated by a dot ('.').", "method_code_mask": "import pkgutil\nimport sys\nfrom importlib import import_module\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import List\n\n\ndef find_available_providers(modules: List[ModuleType]) ->List[str]: [MASK]\n"}
{"method_name": "calculate_luhn", "full_method_name": "calculate_luhn", "method_path": "../srcdata/Basic/faker/faker/utils/checksums.py", "method_code": "from typing import List\ndef calculate_luhn(partial_number: float) ->int:\n    \"\"\"\n    Generates the Checksum using Luhn's algorithm\n    \"\"\"\n    check_digit = luhn_checksum(int(partial_number) * 10)\n    return check_digit if check_digit == 0 else 10 - check_digit", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_luhn_checksum(self):\n\t    \"\"\"\n\t        Tests if a valid checksum is generated\n\t        Example from wiki: https://en.wikipedia.org/wiki/Luhn_algorithm\n\t        \"\"\"\n\t    check_digit = calculate_luhn('7992739871')\n\t    assert check_digit == 3\n\t\nUtilsTestCase().test_luhn_checksum()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The calculate_luhn function is designed to calculate the check digit required to validate a partial number using Luhn's algorithm. Luhn's algorithm is commonly used to validate credit card numbers, IMEI numbers, and other similar numerical identifiers. This function specifically calculates the check digit that would make the entire number, including the partial number provided and the check digit, Luhn valid.\n\nInputs: \n1. partial_number: A float representing the partial number for which the check digit is to be calculated. The partial number should not include the check digit.\n\nOutputs:\n1. An integer representing the check digit that, when appended to the partial_number, results in a number that is valid according to Luhn's algorithm. The function returns 0 if the calculated check digit is 0, or 10 minus the calculated check digit if it is not 0.", "method_code_mask": "from typing import List\n\n\ndef calculate_luhn(partial_number: float) ->int: [MASK]\n"}
{"method_name": "add_ordereddicts", "full_method_name": "add_ordereddicts", "method_path": "../srcdata/Basic/faker/faker/utils/datasets.py", "method_code": "from itertools import chain\nfrom faker.typing import OrderedDictType\ndef add_ordereddicts(*odicts: OrderedDictType) ->OrderedDictType:\n    items = [odict.items() for odict in odicts]\n    return OrderedDictType(chain(*items))", "test_code_list": [{"test_code": "import json\nimport unittest\nfrom importlib import import_module\nfrom pathlib import Path\nimport faker\nfrom faker.config import META_PROVIDERS_MODULES\nfrom faker.config import PROVIDERS\nfrom faker.generator import random\nfrom faker.typing import OrderedDictType\nfrom faker.utils.checksums import calculate_luhn\nfrom faker.utils.checksums import luhn_checksum\nfrom faker.utils.datasets import add_ordereddicts\nfrom faker.utils.distribution import choices_distribution\nfrom faker.utils.distribution import choices_distribution_unique\nfrom faker.utils.loading import find_available_locales\nfrom faker.utils.loading import find_available_providers\nfrom faker.utils.loading import get_path\n\nclass UtilsTestCase(unittest.TestCase):\n\tdef test_add_ordereddicts(self):\n\t    d1 = OrderedDictType([('a', 1), ('b', 2)])\n\t    d2 = OrderedDictType([('c', 3), ('d', 4)])\n\t    result = add_ordereddicts(d1, d2)\n\t    assert result == OrderedDictType([('a', 1), ('b', 2), ('c', 3), ('d', 4)])\n\t\nUtilsTestCase().test_add_ordereddicts()\n", "code_start": "", "test_path": "../srcdata/Basic/faker/tests/utils/test_utils.py"}], "instruction": "Functionality: The function 'add_ordereddicts' combines multiple ordered dictionaries into a single ordered dictionary. It takes any number of ordered dictionaries as arguments, and it merges them, preserving the order of the keys as they were added in the original ordered dictionaries. In case of key collisions, the value from the last ordered dictionary with that key will be used.\n\nInputs: Any number of ordered dictionaries (OrderedDictType). The input ordered dictionaries contain key-value pairs, and the keys are unique within a single dictionary.\n\nOutputs: A single ordered dictionary (OrderedDictType) that is the result of merging all input ordered dictionaries. Keys are preserved in the order they were added in the original ordered dictionaries, and if the same key appears in multiple dictionaries, the value from the last dictionary with that key is used.", "method_code_mask": "from itertools import chain\nfrom faker.typing import OrderedDictType\n\n\ndef add_ordereddicts(*odicts: OrderedDictType) ->OrderedDictType: [MASK]\n"}
