{"method_name": "is_aware", "full_method_name": "is_aware", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\ndef is_aware(dtime: dt.datetime) ->bool:\n    \"\"\"test if a datetime instance is timezone aware\"\"\"\n    if dtime.tzinfo is not None and dtime.tzinfo.utcoffset(dtime) is not None:\n        return True\n    else:\n        return False", "test_code_list": [{"test_code": "import datetime as dt\nimport pytz\n\nclass TestIsAware():\n    def test_naive(self):\n        assert is_aware(dt.datetime.now()) is False\n    \nTestIsAware().test_naive()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/khalendar_utils_test.py"}, {"test_code": "import datetime as dt\nimport pytz\nBERLIN = pytz.timezone('Europe/Berlin')\nclass TestIsAware():\n    def test_berlin(self):\n        assert is_aware(BERLIN.localize(dt.datetime.now())) is True\nTestIsAware().test_berlin()", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/khalendar_utils_test.py"}, {"test_code": "import datetime as dt\nimport pytz\nBOGOTA = pytz.timezone('America/Bogota')\nclass TestIsAware():\n    def test_bogota(self):\n        assert is_aware(BOGOTA.localize(dt.datetime.now())) is True\nTestIsAware().test_bogota()", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/khalendar_utils_test.py"}, {"test_code": "import datetime as dt\nimport pytz\n\nclass TestIsAware():\n    def test_utc(self):\n        assert is_aware(pytz.UTC.localize(dt.datetime.now())) is True\n    \nTestIsAware().test_utc()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/khalendar_utils_test.py"}], "instruction": "Functionality: This function checks whether a given datetime instance is timezone aware or not. A datetime instance is considered timezone aware if it has timezone information associated with it, meaning it includes an offset from Coordinated Universal Time (UTC).\n\nInputs: \n- dtime: A datetime instance that needs to be checked for timezone awareness. It is of type datetime.datetime.\n\nOutputs: \n- A boolean value indicating whether the datetime instance is timezone aware or not. Returns True if the datetime instance is timezone aware, and False if it is not.", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\n\n\ndef is_aware(dtime: dt.datetime) ->bool: [MASK]\n"}
{"method_name": "guesstimedeltafstr", "full_method_name": "guesstimedeltafstr", "method_path": "../srcdata/Basic/khal/khal/parse_datetime.py", "method_code": "import datetime as dt\nimport logging\nimport re\nfrom calendar import isleap\nfrom time import strptime\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport pytz\ndef guesstimedeltafstr(delta_string: str) ->dt.timedelta:\n    \"\"\"parses a timedelta from a string\n\n    :param delta_string: string encoding time-delta, e.g. '1h 15m'\n    \"\"\"\n    tups = re.split('(-?\\\\+?\\\\d+)', delta_string)\n    if not re.match('^\\\\s*$', tups[0]):\n        raise ValueError(\n            f'Invalid beginning of timedelta string \"{delta_string}\": \"{tups[0]}\"'\n            )\n    tups = tups[1:]\n    res = dt.timedelta()\n    for num, unit in zip(tups[0::2], tups[1::2]):\n        try:\n            if num[0] == '+':\n                num = num[1:]\n            numint = int(num)\n        except ValueError:\n            raise DateTimeParseError(\n                f'Invalid number in timedelta string \"{delta_string}\": \"{num}\"'\n                )\n        ulower = unit.lower().strip()\n        if ulower == 'd' or ulower == 'day' or ulower == 'days':\n            res += dt.timedelta(days=numint)\n        elif ulower == 'h' or ulower == 'hour' or ulower == 'hours':\n            res += dt.timedelta(hours=numint)\n        elif ulower == 'm' or ulower == 'minute' or ulower == 'minutes' or ulower == 'min':\n            res += dt.timedelta(minutes=numint)\n        elif ulower == 's' or ulower == 'second' or ulower == 'seconds' or ulower == 'sec':\n            res += dt.timedelta(seconds=numint)\n        else:\n            raise ValueError(\n                f'Invalid unit in timedelta string \"{delta_string}\": \"{unit}\"')\n    return res", "test_code_list": [{"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_single(self):\n        assert dt.timedelta(minutes=10) == guesstimedeltafstr('10m')\n    \nTestGuessTimedeltafstr().test_single()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_seconds(self):\n        assert dt.timedelta(seconds=10) == guesstimedeltafstr('10s')\n    \nTestGuessTimedeltafstr().test_seconds()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_single_plus(self):\n        assert dt.timedelta(minutes=10) == guesstimedeltafstr('+10m')\n    \nTestGuessTimedeltafstr().test_single_plus()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_seconds_plus(self):\n        assert dt.timedelta(seconds=10) == guesstimedeltafstr('+10s')\n    \nTestGuessTimedeltafstr().test_seconds_plus()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_days_plus(self):\n        assert dt.timedelta(days=10) == guesstimedeltafstr('+10days')\n    \nTestGuessTimedeltafstr().test_days_plus()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_negative(self):\n        assert dt.timedelta(minutes=-10) == guesstimedeltafstr('-10m')\n    \nTestGuessTimedeltafstr().test_negative()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_multi(self):\n        assert dt.timedelta(days=1, hours=-3, minutes=10) == guesstimedeltafstr(\n            ' 1d -3H 10min ')\n    \nTestGuessTimedeltafstr().test_multi()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_multi_plus(self):\n        assert dt.timedelta(days=1, hours=3, minutes=10) == guesstimedeltafstr(\n            ' 1d +3H 10min ')\n    \nTestGuessTimedeltafstr().test_multi_plus()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_multi_plus_minus(self):\n        assert dt.timedelta(days=0, hours=21, minutes=10) == guesstimedeltafstr(\n            '+1d -3H 10min ')\n    \nTestGuessTimedeltafstr().test_multi_plus_minus()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_multi_nospace(self):\n        assert dt.timedelta(days=1, hours=-3, minutes=10) == guesstimedeltafstr(\n            '1D-3hour10m')\n    \nTestGuessTimedeltafstr().test_multi_nospace()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}, {"test_code": "import datetime as dt\nfrom collections import OrderedDict\nimport pytest\n\nclass TestGuessTimedeltafstr():\n    def test_same(self):\n        assert dt.timedelta(minutes=20) == guesstimedeltafstr('10min 10minutes')\n    \nTestGuessTimedeltafstr().test_same()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/parse_datetime_test.py"}], "instruction": "Functionality: The guesstimedeltafstr function is designed to parse a string that represents a time duration and convert it into a datetime.timedelta object. The string can contain hours, minutes, seconds, and days with various notation styles, such as '1h 15m' or '2 days 3 hours'. The function will interpret the string and return the equivalent timedelta object.\n\nInputs: \n- delta_string: A string encoding a time duration. The string should contain numbers followed by a unit indicator (such as 'd' for days, 'h' for hours, 'm' for minutes, and 's' for seconds). The unit indicator can also be the full word (e.g., 'days', 'hours') in singular or plural form, or an abbreviation. Spaces are allowed between numbers and unit indicators.\n\nOutputs:\n- A datetime.timedelta object representing the parsed time duration from the input string. If the input string is not properly formatted or contains invalid units, the function will raise a ValueError.", "method_code_mask": "import datetime as dt\nimport logging\nimport re\nfrom calendar import isleap\nfrom time import strptime\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport pytz\n\n\ndef guesstimedeltafstr(delta_string: str) ->dt.timedelta: [MASK]\n"}
{"method_name": "find_last_reset", "full_method_name": "find_last_reset", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_reset = re.compile('\\\\x1b\\\\[0m')\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ncalendarline = (\n    '\\x1b[1mNov \\x1b[0m\\x1b[1;33m31\\x1b[0m \\x1b[32m 1\\x1b[0m \\x1b[1;33m 2\\x1b[0m \\x1b[1;33m 3\\x1b[0m \\x1b[1;33m 4\\x1b[0m \\x1b[32m 5\\x1b[0m \\x1b[32m 6\\x1b[0m'\n    )\ntoday_line = '\\x1b[1mToday\\x1b[0m\\x1b[0m'\nweekheader = '\\x1b[1m    Mo Tu We Th Fr Sa Su   \\x1b[0m'\ndef test_last_reset():\n    assert find_last_reset(weekheader) == (31, 35, '\\x1b[0m')\n    assert find_last_reset(today_line) == (13, 17, '\\x1b[0m')\n    assert find_last_reset(calendarline) == (99, 103, '\\x1b[0m')\n    assert find_last_reset('Hello World') == (-2, -1, '')\ntest_last_reset()", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The find_last_reset function is designed to search through a given string for the last occurrence of an ANSI escape sequence used for resetting text formatting (e.g., color, style) in terminal interfaces. It returns the starting index, ending index, and the actual escape sequence string for the last reset event found in the string. If no reset sequence is found, it returns a specific set of values to indicate the absence of such sequences.\n\nInputs: \n- string: str - A string that may contain ANSI escape sequences for text formatting.\n\nOutputs:\n- A tuple containing:\n    - The starting index (int) of the last reset sequence found in the string.\n    - The ending index (int) of the last reset sequence found in the string.\n    - The actual reset sequence string (str) found at the specified indices.\n    If no reset sequence is found, the function returns (-2, -1, '').", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_reset = re.compile('\\\\x1b\\\\[0m')\n\n\ndef find_last_reset(string: str) ->Tuple[int, int, str]: [MASK]\n"}
{"method_name": "find_last_sgr", "full_method_name": "find_last_sgr", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ncalendarline = (\n    '\\x1b[1mNov \\x1b[0m\\x1b[1;33m31\\x1b[0m \\x1b[32m 1\\x1b[0m \\x1b[1;33m 2\\x1b[0m \\x1b[1;33m 3\\x1b[0m \\x1b[1;33m 4\\x1b[0m \\x1b[32m 5\\x1b[0m \\x1b[32m 6\\x1b[0m'\n    )\ntoday_line = '\\x1b[1mToday\\x1b[0m\\x1b[0m'\nweekheader = '\\x1b[1m    Mo Tu We Th Fr Sa Su   \\x1b[0m'\ndef test_last_sgr():\n    assert find_last_sgr(weekheader) == (0, 4, '\\x1b[1m')\n    assert find_last_sgr(today_line) == (0, 4, '\\x1b[1m')\n    assert find_last_sgr(calendarline) == (92, 97, '\\x1b[32m')\n    assert find_last_sgr('Hello World') == (-2, -1, '')\ntest_last_sgr()", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The function find_last_sgr is designed to search through a given string for the last occurrence of ANSI escape sequences used for text formatting (e.g., color, style changes). These sequences are identified by the pattern '\\x1b[...m' where '...' can be any sequence of numbers separated by semicolons. The function is expected to find the last such sequence in the string and return its starting index, ending index, and the sequence itself.\n\nInputs: \n- string: A string that potentially contains ANSI escape sequences for text formatting. The string may contain multiple occurrences of these sequences.\n\nOutputs:\n- A tuple containing three elements:\n    1. The starting index of the last ANSI escape sequence found in the string.\n    2. The ending index of the last ANSI escape sequence found in the string.\n    3. The last ANSI escape sequence found as a string.\nIf no ANSI escape sequence is found, the function should return (-2, -1, '').", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\n\n\ndef find_last_sgr(string: str) ->Tuple[int, int, str]: [MASK]\n"}
{"method_name": "find_unmatched_sgr", "full_method_name": "find_unmatched_sgr", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\nansi_reset = re.compile('\\\\x1b\\\\[0m')\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\ndef find_unmatched_sgr(string: str) ->Optional[str]:\n    reset_pos, _, _ = find_last_reset(string)\n    sgr_pos, _, sgr = find_last_sgr(string)\n    if sgr_pos > reset_pos:\n        return sgr\n    else:\n        return None", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ncalendarline = (\n    '\\x1b[1mNov \\x1b[0m\\x1b[1;33m31\\x1b[0m \\x1b[32m 1\\x1b[0m \\x1b[1;33m 2\\x1b[0m \\x1b[1;33m 3\\x1b[0m \\x1b[1;33m 4\\x1b[0m \\x1b[32m 5\\x1b[0m \\x1b[32m 6\\x1b[0m'\n    )\ntoday_line = '\\x1b[1mToday\\x1b[0m\\x1b[0m'\nweekheader = '\\x1b[1m    Mo Tu We Th Fr Sa Su   \\x1b[0m'\ndef test_find_unmatched_sgr():\n    assert find_unmatched_sgr(weekheader) is None\n    assert find_unmatched_sgr(today_line) is None\n    assert find_unmatched_sgr(calendarline) is None\n    assert find_unmatched_sgr('\\x1b[31mHello World') == '\\x1b[31m'\n    assert find_unmatched_sgr('\\x1b[31mHello\\x1b[0m \\x1b[32mWorld'\n        ) == '\\x1b[32m'\n    assert find_unmatched_sgr('foo\\x1b[1;31mbar') == '\\x1b[1;31m'\n    assert find_unmatched_sgr('\\x1b[0mfoo\\x1b[1;31m') == '\\x1b[1;31m'\ntest_find_unmatched_sgr()", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The function find_unmatched_sgr is designed to search through a given string for unmatched ANSI escape sequences used for text formatting in terminal environments. Specifically, it looks for any remaining (unmatched) Start Graphics Rendition (SGR) sequences that are not followed by a reset sequence. The SGR sequences are used to modify the appearance of text, such as changing color or style, and should always be paired with a reset sequence to return the text formatting to its default state.\n\nInputs: \n- string: A string that may contain ANSI escape sequences for text formatting.\n\nOutputs:\n- If an unmatched SGR sequence is found, the function returns the unmatched SGR sequence as a string.\n- If all SGR sequences are properly matched with reset sequences, or if there are no SGR sequences at all, the function returns None.", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\n\n\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\nansi_reset = re.compile('\\\\x1b\\\\[0m')\n\n\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\ndef find_unmatched_sgr(string: str) ->Optional[str]: [MASK]\n"}
{"method_name": "color_wrap", "full_method_name": "color_wrap", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nRESET = '\\x1b[0m'\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\nansi_reset = re.compile('\\\\x1b\\\\[0m')\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\ndef find_unmatched_sgr(string: str) ->Optional[str]:\n    reset_pos, _, _ = find_last_reset(string)\n    sgr_pos, _, sgr = find_last_sgr(string)\n    if sgr_pos > reset_pos:\n        return sgr\n    else:\n        return None\ndef color_wrap(text: str, width: int=70) ->List[str]:\n    \"\"\"A variant of wrap that takes SGR codes (somewhat) into account.\n    This doesn't actually adjust the length, but makes sure that\n    lines that enable some attribues also contain a RESET, and also adds\n    that code to the next line\n    \"\"\"\n    lines = wrap(text, width)\n    for num, _ in enumerate(lines):\n        sgr = find_unmatched_sgr(lines[num])\n        if sgr is not None:\n            lines[num] += RESET\n            if num + 1 < len(lines):\n                lines[num + 1] = sgr + lines[num + 1]\n    return lines", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ndef test_color_wrap():\n    text = (\n        'Lorem ipsum \\x1b[31mdolor sit amet, consetetur sadipscing elitr, sed diam nonumy\\x1b[0m eirmod tempor'\n        )\n    expected = ['Lorem ipsum \\x1b[31mdolor sit amet,\\x1b[0m',\n        '\\x1b[31mconsetetur sadipscing elitr, sed\\x1b[0m',\n        '\\x1b[31mdiam nonumy\\x1b[0m eirmod tempor']\n    assert color_wrap(text, 35) == expected\n\ntest_color_wrap()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}, {"test_code": "import datetime as dt\nfrom click import style\ndef test_color_wrap_256():\n    text = (\n        '\\x1b[38;2;17;255;0mLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy\\x1b[0m'\n        )\n    expected = ['\\x1b[38;2;17;255;0mLorem ipsum\\x1b[0m',\n        '\\x1b[38;2;17;255;0mdolor sit amet, consetetur\\x1b[0m',\n        '\\x1b[38;2;17;255;0msadipscing elitr, sed diam\\x1b[0m',\n        '\\x1b[38;2;17;255;0mnonumy\\x1b[0m']\n    assert color_wrap(text, 30) == expected\n\ntest_color_wrap_256()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}, {"test_code": "import datetime as dt\nfrom click import style\ndef test_color_wrap_multiple_colors_and_tabs():\n    text = (\n        '\\x1b[31m14:00-14:50    AST-1002-102 INTRO AST II/STAR GALAX (R) Classes'\n        ,\n        '15:30-16:45    PHL-2000-104 PHILOSOPHY, SOCIETY & ETHICS (R) Classes',\n        '\\x1b[38;2;255;0m17:00-18:00    Pay Ticket Deadline Calendar',\n        '09:30-10:45    PHL-1501-101 MIND, KNOWLEDGE & REALITY (R) Classes',\n        '\\x1b[38;2;255;0m11:00-14:00    Rivers Street (noodles and pizza) (R) Calendar'\n        )\n    expected = [\n        '\\x1b[31m14:00-14:50    AST-1002-102 INTRO AST II/STAR GALAX (R)\\x1b[0m'\n        , '\\x1b[31mClasses\\x1b[0m',\n        '15:30-16:45    PHL-2000-104 PHILOSOPHY, SOCIETY & ETHICS (R)',\n        'Classes',\n        '\\x1b[38;2;255;0m17:00-18:00    Pay Ticket Deadline Calendar\\x1b[0m',\n        '09:30-10:45    PHL-1501-101 MIND, KNOWLEDGE & REALITY (R)',\n        'Classes',\n        '\\x1b[38;2;255;0m11:00-14:00    Rivers Street (noodles and\\x1b[0m',\n        '\\x1b[38;2;255;0mpizza) (R) Calendar\\x1b[0m']\n    actual = []\n    for line in text:\n        actual += color_wrap(line, 60)\n    assert actual == expected\n\ntest_color_wrap_multiple_colors_and_tabs()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The color_wrap function takes a string and wraps it to a specified width, ensuring that ANSI escape codes for text styling (SGR codes) are properly terminated and reapplied at the beginning of the next line if necessary. This function is useful for formatting text with color or style codes in environments like terminals or CLI tools, where correct line wrapping and code preservation are required.\n\nInputs:\n- text: A string containing the text to be wrapped. This text may include ANSI escape codes for styling.\n- width: An optional integer specifying the maximum line width for wrapping. The default value is 70.\n\nOutputs:\n- A list of strings, where each string is a line of text from the original input, wrapped to the specified width and with SGR codes properly handled. Each line will end with a RESET code if it contains unbalanced SGR codes, and the next line will begin with the unbalanced SGR code if the line wrapping occurred mid-SGR sequence.", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nRESET = '\\x1b[0m'\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\n\n\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\nansi_reset = re.compile('\\\\x1b\\\\[0m')\n\n\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\ndef find_unmatched_sgr(string: str) ->Optional[str]:\n    reset_pos, _, _ = find_last_reset(string)\n    sgr_pos, _, sgr = find_last_sgr(string)\n    if sgr_pos > reset_pos:\n        return sgr\n    else:\n        return None\n\n\ndef color_wrap(text: str, width: int=70) ->List[str]: [MASK]\n"}
{"method_name": "get_weekday_occurrence", "full_method_name": "get_weekday_occurrence", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\ndef get_weekday_occurrence(day: dt.date) ->Tuple[int, int]:\n    \"\"\"Calculate how often this weekday has already occurred in a given month.\n\n    :returns: weekday (0=Monday, ..., 6=Sunday), occurrence\n    \"\"\"\n    xthday = 1 + (day.day - 1) // 7\n    return day.weekday(), xthday", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ndef test_get_weekday_occurrence():\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 1)) == (2, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 2)) == (3, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 3)) == (4, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 4)) == (5, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 5)) == (6, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 6)) == (0, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 7)) == (1, 1)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 8)) == (2, 2)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 9)) == (3, 2)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 10)) == (4, 2)\n    assert get_weekday_occurrence(dt.datetime(2017, 3, 31)) == (4, 5)\n    assert get_weekday_occurrence(dt.date(2017, 5, 1)) == (0, 1)\n    assert get_weekday_occurrence(dt.date(2017, 5, 7)) == (6, 1)\n    assert get_weekday_occurrence(dt.date(2017, 5, 8)) == (0, 2)\n    assert get_weekday_occurrence(dt.date(2017, 5, 28)) == (6, 4)\n    assert get_weekday_occurrence(dt.date(2017, 5, 29)) == (0, 5)\n\ntest_get_weekday_occurrence()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The function 'get_weekday_occurrence' calculates how often a specific weekday has already occurred in the month of a given date. It returns the weekday number (where Monday is 0 and Sunday is 6) and the occurrence of that weekday in the month.\n\nInputs: A date object 'day' is passed as an argument to the function. The date object should be in the datetime format.\n\nOutputs: A tuple containing two integers is returned. The first integer represents the weekday number (0 for Monday, ..., 6 for Sunday) of the input date, and the second integer represents the occurrence of that weekday in the month of the input date.", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\n\n\ndef get_weekday_occurrence(day: dt.date) ->Tuple[int, int]: [MASK]\n"}
{"method_name": "human_formatter", "full_method_name": "human_formatter", "method_path": "../srcdata/Basic/khal/khal/utils.py", "method_code": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nRESET = '\\x1b[0m'\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\nansi_reset = re.compile('\\\\x1b\\\\[0m')\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\ndef find_unmatched_sgr(string: str) ->Optional[str]:\n    reset_pos, _, _ = find_last_reset(string)\n    sgr_pos, _, sgr = find_last_sgr(string)\n    if sgr_pos > reset_pos:\n        return sgr\n    else:\n        return None\ndef color_wrap(text: str, width: int=70) ->List[str]:\n    \"\"\"A variant of wrap that takes SGR codes (somewhat) into account.\n    This doesn't actually adjust the length, but makes sure that\n    lines that enable some attribues also contain a RESET, and also adds\n    that code to the next line\n    \"\"\"\n    lines = wrap(text, width)\n    for num, _ in enumerate(lines):\n        sgr = find_unmatched_sgr(lines[num])\n        if sgr is not None:\n            lines[num] += RESET\n            if num + 1 < len(lines):\n                lines[num + 1] = sgr + lines[num + 1]\n    return lines\ndef human_formatter(format_string, width=None, colors=True):\n    \"\"\"Create a formatter that formats events to be human readable.\"\"\"\n    def fmt(rows):\n        single = isinstance(rows, dict)\n        if single:\n            rows = [rows]\n        results = []\n        for row in rows:\n            if 'calendar-color' in row:\n                row['calendar-color'] = get_color(row['calendar-color'])\n            s = format_string.format(**row)\n            if colors:\n                s += style('', reset=True)\n            if width:\n                results += color_wrap(s, width)\n            else:\n                results.append(s)\n        if single:\n            return results[0]\n        else:\n            return results\n    return fmt", "test_code_list": [{"test_code": "import datetime as dt\nfrom click import style\ndef test_human_formatter_width():\n    formatter = human_formatter('{red}{title}', width=10)\n    output = formatter({'title': 'morethan10characters', 'red': style('',\n        reset=False, fg='red')})\n    assert output.startswith('\\x1b[31mmoret\\x1b[0m')\n\ntest_human_formatter_width()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/utils_test.py"}], "instruction": "Functionality: The human_formatter function is designed to format events to be human readable, according to a specified format string. It supports the inclusion of ANSI color codes and text wrapping, making the output visually appealing and suitable for terminal display. The function can process both single dictionary entries and lists of dictionaries.\n\nInputs:\n- format_string (str): A string that contains placeholders for the keys present in the rows to be formatted. This string should follow Python's format method syntax.\n- width (Optional[int]): An optional argument that specifies the maximum width of the formatted string. If provided, the output will be wrapped to this width.\n- colors (bool): A boolean flag indicating whether to include ANSI color codes in the output. If True, color codes will be appended to each line; if False, color codes will be stripped.\n\nOutputs:\n- A function (callable) that takes a single dict or a list of dicts (rows) as its argument and returns a formatted string or a list of strings. If the input is a single dictionary, the output will be a single string; if the input is a list of dictionaries, the output will be a list of strings, each corresponding to a formatted row.", "method_code_mask": "import datetime as dt\nimport json\nimport random\nimport re\nimport string\nfrom calendar import month_abbr\nfrom calendar import timegm\nfrom textwrap import wrap\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport pytz\nfrom click import style\nRESET = '\\x1b[0m'\nansi_sgr = re.compile('\\\\x1b\\\\[(?!0m)([0-9]+;?)+m')\n\n\ndef find_last_sgr(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_sgr, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\nansi_reset = re.compile('\\\\x1b\\\\[0m')\n\n\ndef find_last_reset(string: str) ->Tuple[int, int, str]:\n    for match in re.finditer(ansi_reset, string):\n        pass\n    try:\n        return match.start(), match.end(), match.group(0)\n    except UnboundLocalError:\n        return -2, -1, ''\n\n\ndef find_unmatched_sgr(string: str) ->Optional[str]:\n    reset_pos, _, _ = find_last_reset(string)\n    sgr_pos, _, sgr = find_last_sgr(string)\n    if sgr_pos > reset_pos:\n        return sgr\n    else:\n        return None\n\n\ndef color_wrap(text: str, width: int=70) ->List[str]:\n    \"\"\"A variant of wrap that takes SGR codes (somewhat) into account.\n    This doesn't actually adjust the length, but makes sure that\n    lines that enable some attribues also contain a RESET, and also adds\n    that code to the next line\n    \"\"\"\n    lines = wrap(text, width)\n    for num, _ in enumerate(lines):\n        sgr = find_unmatched_sgr(lines[num])\n        if sgr is not None:\n            lines[num] += RESET\n            if num + 1 < len(lines):\n                lines[num + 1] = sgr + lines[num + 1]\n    return lines\n\n\ndef human_formatter(format_string, width=None, colors=True): [MASK]\n"}
{"method_name": "validate_int", "full_method_name": "validate_int", "method_path": "../srcdata/Basic/khal/khal/configwizard.py", "method_code": "import datetime as dt\nimport json\nimport logging\nfrom functools import partial\nfrom itertools import zip_longest\nfrom os import environ\nfrom os import makedirs\nfrom os.path import dirname\nfrom os.path import exists\nfrom os.path import expanduser\nfrom os.path import expandvars\nfrom os.path import isdir\nfrom os.path import join\nfrom os.path import normpath\nfrom subprocess import call\nfrom click import Choice\nfrom click import UsageError\nfrom click import confirm\nfrom click import prompt\nfrom vdirsyncer.cli import config\nfrom vdirsyncer.exceptions import UserError\ndef validate_int(input, min_value, max_value):\n    try:\n        number = int(input)\n    except ValueError:\n        raise UsageError('Input must be an integer')\n    if min_value <= number <= max_value:\n        return number\n    else:\n        raise UsageError(f'Input must be between {min_value} and {max_value}')", "test_code_list": [{"test_code": "import click\nimport pytest\ndef test_validate_int():\n    assert validate_int('3', 0, 3) == 3\n    with pytest.raises(click.UsageError):\n        validate_int('3', 0, 2)\n    with pytest.raises(click.UsageError):\n        validate_int('two', 0, 2)\n\ntest_validate_int()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/configwizard_test.py"}], "instruction": "Functionality: Validates if the input is an integer within a specified range.\nInputs: \n- input: The value to be checked, expected to be a string.\n- min_value: The minimum acceptable integer value, inclusive.\n- max_value: The maximum acceptable integer value, inclusive.\n\nOutputs:\n- If the input is a valid integer within the specified range, the function returns the integer value.\n- If the input is not a valid integer or not within the specified range, the function raises a UsageError with a relevant error message.", "method_code_mask": "import datetime as dt\nimport json\nimport logging\nfrom functools import partial\nfrom itertools import zip_longest\nfrom os import environ\nfrom os import makedirs\nfrom os.path import dirname\nfrom os.path import exists\nfrom os.path import expanduser\nfrom os.path import expandvars\nfrom os.path import isdir\nfrom os.path import join\nfrom os.path import normpath\nfrom subprocess import call\nfrom click import Choice\nfrom click import UsageError\nfrom click import confirm\nfrom click import prompt\nfrom vdirsyncer.cli import config\nfrom vdirsyncer.exceptions import UserError\n\n\ndef validate_int(input, min_value, max_value): [MASK]\n"}
{"method_name": "merge_columns", "full_method_name": "merge_columns", "method_path": "../srcdata/Basic/khal/khal/terminal.py", "method_code": "from itertools import zip_longest\nfrom typing import Dict\nfrom typing import List\nfrom typing import NamedTuple\nfrom typing import Optional\ndef merge_columns(lcolumn: List[str], rcolumn: List[str], width: int=25\n    ) ->List[str]:\n    \"\"\"merge two lists elementwise together\n\n    Wrap right columns to terminal width.\n    If the right list(column) is longer, first lengthen the left one.\n    We assume that the left column has width `width`, we cannot find\n    out its (real) width automatically since it might contain ANSI\n    escape sequences.\n    \"\"\"\n    missing = len(rcolumn) - len(lcolumn)\n    if missing > 0:\n        lcolumn = lcolumn + missing * [width * ' ']\n    return ['    '.join(one) for one in zip_longest(lcolumn, rcolumn,\n        fillvalue='')]", "test_code_list": [{"test_code": "\nclass TestMergeColumns():\n    def test_longer_right(self):\n        left = ['uiae', 'nrtd']\n        right = ['123456', '234567', '345678']\n        out = ['uiae    123456', 'nrtd    234567', '        345678']\n        assert merge_columns(left, right, width=4) == out\n    \nTestMergeColumns().test_longer_right()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/terminal_test.py"}, {"test_code": "\nclass TestMergeColumns():\n    def test_longer_left(self):\n        left = ['uiae', 'nrtd', 'xvlc']\n        right = ['123456', '234567']\n        out = ['uiae    123456', 'nrtd    234567', 'xvlc    ']\n        assert merge_columns(left, right, width=4) == out\n    \nTestMergeColumns().test_longer_left()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/terminal_test.py"}], "instruction": "Functionality: The merge_columns function merges two lists of strings (lcolumn and rcolumn) element-wise, with an optional width parameter for wrapping the right columns to a terminal width. If the right column is longer, the left column is lengthened to match the length of the right column. This function assumes a fixed width for the left column, which might contain ANSI escape sequences that cannot be automatically detected.\n\nInputs: \n- lcolumn: A list of strings representing the left column.\n- rcolumn: A list of strings representing the right column.\n- width: An optional integer representing the width of the left column. Default is 25.\n\nOutputs: \n- A list of strings where each string is the result of joining corresponding elements from lcolumn and rcolumn with three spaces in between. If one list is shorter, the remaining elements are joined with an empty string.", "method_code_mask": "from itertools import zip_longest\nfrom typing import Dict\nfrom typing import List\nfrom typing import NamedTuple\nfrom typing import Optional\n\n\ndef merge_columns(lcolumn: List[str], rcolumn: List[str], width: int=25\n    ) ->List[str]: [MASK]\n"}
{"method_name": "delete_last_word", "full_method_name": "delete_last_word", "method_path": "../srcdata/Basic/khal/khal/ui/widgets.py", "method_code": "import datetime as dt\nimport re\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef delete_last_word(text, number=1):\n    \"\"\"delete last `number` of words from text\"\"\"\n    words = re.findall('[\\\\w]+|[^\\\\w\\\\s]', text, re.UNICODE)\n    for one in range(1, number + 1):\n        text = text.rstrip()\n        if text == '':\n            return text\n        text = text[:len(text) - len(words[-one])]\n    return text", "test_code_list": [{"test_code": "def test_delete_last_word():\n    tests = [('F\u00fc1\u00fc  B\u00e4r!', 'F\u00fc1\u00fc  B\u00e4r', 1), ('F\u00fc\u00fc B\u00e4r1', 'F\u00fc\u00fc ', 1), (\n        'F\u00fc\u00fc1 B\u00e4r1', 'F\u00fc\u00fc1 ', 1), (' F\u00fc\u00fc B\u00e4r', ' F\u00fc\u00fc ', 1), ('F\u00fc\u00fc B\u00e4r.F\u00fc\u00fc',\n        'F\u00fc\u00fc B\u00e4r.', 1), ('F\u00fc\u00fc B\u00e4r.(F\u00fc\u00fc)', 'F\u00fc\u00fc B\u00e4r.(F\u00fc\u00fc', 1), ('F\u00fc\u00fc ', '', \n        1), ('F\u00fc\u00fc  ', '', 1), ('F\u00fc\u00fc', '', 1), ('', '', 1), ('F\u00fc\u00fc B\u00e4r.(F\u00fc\u00fc)',\n        'F\u00fc\u00fc B\u00e4r.', 3), ('F\u00fc\u00fc B\u00e4r1', '', 2), (\n        'Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam volest.'\n        ,\n        'Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore '\n        , 10)]\n    for org, short, number in tests:\n        assert delete_last_word(org, number) == short\n\ntest_delete_last_word()\n", "code_start": "", "test_path": "../srcdata/Basic/khal/tests/ui/test_widgets.py"}], "instruction": "Functionality: The function 'delete_last_word' is designed to delete the last 'number' of words from a given text string. It utilizes regular expressions to identify words, which includes alphanumeric characters and non-whitespace symbols, and removes them from the end of the text. If the 'number' of words to remove exceeds the total number of words in the text, the function will return an empty string.\n\nInputs: \n- text: A string from which the last 'number' of words will be removed.\n- number: An optional integer that denotes the number of words to delete from the end of the text. The default value is 1.\n\nOutputs: \n- A string with the last 'number' of words removed. If 'number' is greater than the total number of words in the text, an empty string is returned.", "method_code_mask": "import datetime as dt\nimport re\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef delete_last_word(text, number=1): [MASK]\n"}
