{"method_name": "get_formatted_value", "full_method_name": "get_formatted_value", "method_path": "../srcdata/Visualization/redash/redash/query_runner/google_search_console.py", "method_code": "import logging\nfrom base64 import b64decode\nfrom datetime import datetime\nimport google.auth\nfrom apiclient.discovery import build\nfrom apiclient.errors import HttpError\nfrom google.oauth2.service_account import Credentials\ndef get_formatted_value(column_type, value):\n    if column_type == 'number':\n        value = round(value, 2)\n    elif column_type == TYPE_DATE:\n        value = datetime.strptime(value, '%Y-%m-%d')\n    elif column_type == TYPE_DATETIME:\n        if len(value) == 10:\n            value = datetime.strptime(value, '%Y%m%d%H')\n        elif len(value) == 12:\n            value = datetime.strptime(value, '%Y%m%d%H%M')\n        else:\n            raise Exception(\"Unknown date/time format in results: '{}'\".\n                format(value))\n    return value", "test_code_list": [{"test_code": "import datetime\nfrom unittest import TestCase\n\nclass TestFormatColumnValue(TestCase):\n    def test_number_value(self):\n        column_name = 'number'\n        column_value = 25.4145\n        value = get_formatted_value(column_name, column_value)\n        self.assertEqual(value, 25.41)\n    \nTestFormatColumnValue().test_number_value()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_google_search_console.py"}], "instruction": "Functionality: The function get_formatted_value is designed to format a given value based on its specified type. It supports three types of formatting: number, date, and datetime. The function will round the value to two decimal places if the type is a number. If the type is a date or datetime, it will parse the value into a datetime object according to the date and time format. For datetime values, it supports two formats: one with only the year, month, day, and hour (10 characters long), and another with the year, month, day, hour, and minute (12 characters long). If the datetime format is not recognized, the function will raise an exception.\n\nInputs: The function takes two parameters:\n1. column_type: a string indicating the type of the value, which can be 'number', 'date', or 'datetime'.\n2. value: the value to be formatted. It can be a float, string, or datetime object.\n\nOutputs: The function returns the formatted value. If the column_type is 'number', the output will be a float rounded to two decimal places. If the column_type is 'date' or 'datetime', the output will be a datetime object. If the datetime format is not recognized, the function will raise an Exception.", "method_code_mask": "import logging\nfrom base64 import b64decode\nfrom datetime import datetime\nimport google.auth\nfrom apiclient.discovery import build\nfrom apiclient.errors import HttpError\nfrom google.oauth2.service_account import Credentials\n\n\ndef get_formatted_value(column_type, value): [MASK]\n"}
{"method_name": "parse_response", "full_method_name": "parse_response", "method_path": "../srcdata/Visualization/redash/redash/query_runner/drill.py", "method_code": "import logging\nimport os\nimport re\nfrom dateutil import parser\ndef parse_response(data):\n    cols = data['columns']\n    rows = data['rows']\n    if len(cols) == 0:\n        return {'columns': [], 'rows': []}\n    first_row = rows[0]\n    columns = []\n    types = {}\n    for c in cols:\n        columns.append({'name': c, 'type': guess_type(first_row[c]),\n            'friendly_name': c})\n    for col in columns:\n        types[col['name']] = col['type']\n    for row in rows:\n        for key, value in row.items():\n            row[key] = convert_type(value, types[key])\n    return {'columns': columns, 'rows': rows}", "test_code_list": [{"test_code": "import datetime\nfrom unittest import TestCase\nempty_response = {'columns': [], 'rows': [{}]}\nclass TestParseResponse(TestCase):\n    def test_parse_empty_reponse(self):\n        parsed = parse_response(empty_response)\n        self.assertIsInstance(parsed, dict)\n        self.assertIsNotNone(parsed['columns'])\n        self.assertIsNotNone(parsed['rows'])\n        self.assertEqual(len(parsed['columns']), 0)\n        self.assertEqual(len(parsed['rows']), 0)\nTestParseResponse().test_parse_empty_reponse()", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_drill.py"}], "instruction": "Functionality: The parse_response function is designed to process data retrieved from a database or similar data source. It takes a dictionary containing column names and row data, then enriches this data by determining the data types for each column based on the first row's values. It further converts the string values in all rows to their appropriate data types as determined by the first row.\n\nInputs: The function takes one argument: data, which is a dictionary containing two keys:\n- 'columns': a list of strings representing the names of the columns.\n- 'rows': a list of dictionaries, where each dictionary represents a row of data. Each dictionary has keys corresponding to column names and string values for the data in those columns.\n\nOutputs: The function returns a dictionary with the same structure as the input, but with two crucial differences:\n- 'columns': a list of dictionaries, where each dictionary contains the column's name, its data type as determined by the function, and a friendly name (which is the same as the name).\n- 'rows': a list of dictionaries, where each dictionary represents a row of data, but with values converted to their appropriate data types as identified by the parse_response function.", "method_code_mask": "import logging\nimport os\nimport re\nfrom dateutil import parser\n\n\ndef parse_response(data): [MASK]\n"}
{"method_name": "build_schema", "full_method_name": "build_schema", "method_path": "../srcdata/Visualization/redash/redash/query_runner/pg.py", "method_code": "import logging\nimport os\nimport select\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\nfrom uuid import uuid4\nimport boto3\ndef full_table_name(schema, name):\n    if '.' in name:\n        name = '\"{}\"'.format(name)\n    return '{}.{}'.format(schema, name)\ndef build_schema(query_result, schema):\n    table_names = set(map(lambda r: full_table_name(r['table_schema'], r[\n        'table_name']), query_result['rows']))\n    for row in query_result['rows']:\n        if row['table_schema'] != 'public':\n            table_name = full_table_name(row['table_schema'], row['table_name']\n                )\n        elif row['table_name'] in table_names:\n            table_name = full_table_name(row['table_schema'], row['table_name']\n                )\n        else:\n            table_name = row['table_name']\n        if table_name not in schema:\n            schema[table_name] = {'name': table_name, 'columns': []}\n        column = row['column_name']\n        if row.get('data_type') is not None:\n            column = {'name': row['column_name'], 'type': row['data_type']}\n        schema[table_name]['columns'].append(column)", "test_code_list": [{"test_code": "from unittest import TestCase\n\nclass TestBuildSchema(TestCase):\n    def test_handles_dups_between_public_and_other_schemas(self):\n        results = {'rows': [{'table_schema': 'public', 'table_name':\n            'main.users', 'column_name': 'id'}, {'table_schema': 'main',\n            'table_name': 'users', 'column_name': 'id'}, {'table_schema':\n            'main', 'table_name': 'users', 'column_name': 'name'}]}\n        schema = {}\n        build_schema(results, schema)\n        self.assertIn('main.users', schema.keys())\n        self.assertListEqual(schema['main.users']['columns'], ['id', 'name'])\n        self.assertIn('public.\"main.users\"', schema.keys())\n        self.assertListEqual(schema['public.\"main.users\"']['columns'], ['id'])\n    \nTestBuildSchema().test_handles_dups_between_public_and_other_schemas()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_pg.py"}], "instruction": "Functionality: The build_schema function is designed to process the results of a query that retrieves information about database tables and their columns. It takes the query result and an existing schema dictionary as inputs. The function iterates over the rows of the query result, extracts the schema name, table name, column name, and data type, and constructs a schema dictionary that represents the database schema in a structured format. The schema dictionary contains tables as keys, and each table has a 'name' attribute and a 'columns' list containing column details. If the table does not exist in the schema, it is added. If the table exists and has a unique name, the columns are appended. If the table has a duplicate name, a full table name is constructed using the schema name.\n\nInputs: \n- query_result: A dictionary containing the rows of a query result, where each row is a dictionary containing keys such as 'table_schema', 'table_name', 'column_name', and 'data_type'.\n- schema: A dictionary representing the current schema, where keys are table names and values are dictionaries containing 'name' and 'columns' keys.\n\nOutputs: \n- None. The function modifies the 'schema' dictionary in place, adding or updating tables and columns as needed. The 'schema' dictionary is not returned but should be considered an output as it is the result of processing the query results.", "method_code_mask": "import logging\nimport os\nimport select\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\nfrom uuid import uuid4\nimport boto3\n\n\ndef full_table_name(schema, name):\n    if '.' in name:\n        name = '\"{}\"'.format(name)\n    return '{}.{}'.format(schema, name)\n\n\ndef build_schema(query_result, schema): [MASK]\n"}
{"method_name": "extract_query_ids", "full_method_name": "extract_query_ids", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_query_ids(query):\n    queries = re.findall('(?:join|from)\\\\s+query_(\\\\d+)', query, re.IGNORECASE)\n    return [int(q) for q in queries]", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractQueryIds(TestCase):\n    def test_works_with_simple_query(self):\n        query = 'SELECT 1'\n        self.assertEqual([], extract_query_ids(query))\n    \nTestExtractQueryIds().test_works_with_simple_query()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractQueryIds(TestCase):\n    def test_finds_queries_to_load(self):\n        query = 'SELECT * FROM query_123'\n        self.assertEqual([123], extract_query_ids(query))\n    \nTestExtractQueryIds().test_finds_queries_to_load()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractQueryIds(TestCase):\n    def test_finds_queries_in_joins(self):\n        query = 'SELECT * FROM query_123 JOIN query_4566'\n        self.assertEqual([123, 4566], extract_query_ids(query))\n    \nTestExtractQueryIds().test_finds_queries_in_joins()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractQueryIds(TestCase):\n    def test_finds_queries_with_whitespace_characters(self):\n        query = (\n            'SELECT * FROM    query_123 a JOIN\\tquery_4566 b ON a.id=b.parent_id JOIN\\r\\nquery_78 c ON b.id=c.parent_id'\n            )\n        self.assertEqual([123, 4566, 78], extract_query_ids(query))\n    \nTestExtractQueryIds().test_finds_queries_with_whitespace_characters()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The function 'extract_query_ids' is designed to process a given SQL query string. Its primary task is to identify and extract query IDs that are referenced within the string. These IDs are typically used to reference other queries in a database context, and are embedded within the SQL statement as part of 'join' or 'from' clauses, specifically in the format 'query_####', where '####' represents the query ID as a sequence of digits.\n\nInputs: \n- query (str): A string representing an SQL query, which may contain references to other queries by their IDs embedded within 'join' or 'from' clauses.\n\nOutputs:\n- A list of integers representing the IDs of the queries referenced in the input SQL string. Each ID is extracted from instances of 'query_####' within the string, where '####' is replaced by the actual digit sequence of the query ID. The IDs are returned in the order they appear in the input string.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_query_ids(query): [MASK]\n"}
{"method_name": "create_table", "full_method_name": "create_table", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef flatten(value):\n    if isinstance(value, (list, dict)):\n        return json_dumps(value)\n    elif isinstance(value, decimal.Decimal):\n        return float(value)\n    elif isinstance(value, datetime.timedelta):\n        return str(value)\n    else:\n        return value\nlogger = logging.getLogger(__name__)\ndef fix_column_name(name):\n    return '\"{}\"'.format(re.sub('[:.\"\\\\s]', '_', name, flags=re.UNICODE))\ndef create_table(connection, table_name, query_results):\n    try:\n        columns = [column['name'] for column in query_results['columns']]\n        safe_columns = [fix_column_name(column) for column in columns]\n        column_list = ', '.join(safe_columns)\n        create_table = 'CREATE TABLE {table_name} ({column_list})'.format(\n            table_name=table_name, column_list=column_list)\n        logger.debug('CREATE TABLE query: %s', create_table)\n        connection.execute(create_table)\n    except sqlite3.OperationalError as exc:\n        raise CreateTableError('Error creating table {}: {}'.format(\n            table_name, str(exc)))\n    insert_template = (\n        'insert into {table_name} ({column_list}) values ({place_holders})'\n        .format(table_name=table_name, column_list=column_list,\n        place_holders=','.join(['?'] * len(columns))))\n    for row in query_results['rows']:\n        values = [flatten(row.get(column)) for column in columns]\n        connection.execute(insert_template, values)", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestCreateTable(TestCase):\n    def test_loads_results(self):\n        connection = sqlite3.connect(':memory:')\n        rows = [{'test1': 1, 'test2': 'test'}, {'test1': 2, 'test2': 'test2'}]\n        results = {'columns': [{'name': 'test1'}, {'name': 'test2'}], 'rows': rows}\n        table_name = 'query_123'\n        create_table(connection, table_name, results)\n        self.assertEqual(len(list(connection.execute('SELECT * FROM query_123')\n            )), 2)\n    \nTestCreateTable().test_loads_results()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The function 'create_table' is designed to create a new table in a SQLite database and populate it with data. It takes a SQLite database connection, a table name, and a dictionary representing query results to create a table with columns corresponding to the dictionary keys and populate it with the values.\n\nInputs: \n1. connection: A SQLite database connection object.\n2. table_name: A string representing the name of the table to be created.\n3. query_results: A dictionary containing 'columns' (a list of dictionaries with 'name' keys) and 'rows' (a list of dictionaries with keys corresponding to column names).\n\nOutputs:\nThe function does not return any value. It creates a table in the provided SQLite database and populates it with the given data. If the table creation fails due to a sqlite3.OperationalError, it raises a CreateTableError with a descriptive message.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef flatten(value):\n    if isinstance(value, (list, dict)):\n        return json_dumps(value)\n    elif isinstance(value, decimal.Decimal):\n        return float(value)\n    elif isinstance(value, datetime.timedelta):\n        return str(value)\n    else:\n        return value\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef fix_column_name(name):\n    return '\"{}\"'.format(re.sub('[:.\"\\\\s]', '_', name, flags=re.UNICODE))\n\n\ndef create_table(connection, table_name, query_results): [MASK]\n"}
{"method_name": "extract_cached_query_ids", "full_method_name": "extract_cached_query_ids", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_cached_query_ids(query):\n    queries = re.findall('(?:join|from)\\\\s+cached_query_(\\\\d+)', query, re.\n        IGNORECASE)\n    return [int(q) for q in queries]", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractCachedQueryIds(TestCase):\n    def test_works_with_simple_query(self):\n        query = 'SELECT 1'\n        self.assertEqual([], extract_cached_query_ids(query))\n    \nTestExtractCachedQueryIds().test_works_with_simple_query()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractCachedQueryIds(TestCase):\n    def test_finds_queries_to_load(self):\n        query = 'SELECT * FROM cached_query_123'\n        self.assertEqual([123], extract_cached_query_ids(query))\n    \nTestExtractCachedQueryIds().test_finds_queries_to_load()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractCachedQueryIds(TestCase):\n    def test_finds_queries_in_joins(self):\n        query = 'SELECT * FROM cached_query_123 JOIN cached_query_4566'\n        self.assertEqual([123, 4566], extract_cached_query_ids(query))\n    \nTestExtractCachedQueryIds().test_finds_queries_in_joins()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractCachedQueryIds(TestCase):\n    def test_finds_queries_with_whitespace_characters(self):\n        query = (\n            'SELECT * FROM    cached_query_123 a JOIN\\tcached_query_4566 b ON a.id=b.parent_id JOIN\\r\\ncached_query_78 c ON b.id=c.parent_id'\n            )\n        self.assertEqual([123, 4566, 78], extract_cached_query_ids(query))\n    \nTestExtractCachedQueryIds().test_finds_queries_with_whitespace_characters()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The function extract_cached_query_ids is designed to parse a given SQL query and extract the IDs of cached queries that are referenced within. It searches for specific patterns that indicate the use of cached queries in the input query string and returns a list of these IDs as integers.\n\nInputs: \n- query: A string representing an SQL query. This query may contain references to cached queries, which are identified by a pattern that includes the terms 'join' or 'from' followed by 'cached_query_' and a numeric ID.\n\nOutputs: \n- A list of integers representing the IDs of the cached queries found in the input query string. If no cached queries are referenced, the function should return an empty list.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_cached_query_ids(query): [MASK]\n"}
{"method_name": "extract_query_params", "full_method_name": "extract_query_params", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_query_params(query):\n    return re.findall('(?:join|from)\\\\s+param_query_(\\\\d+)_{([^}]+)}',\n        query, re.IGNORECASE)", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractParamQueryIds(TestCase):\n    def test_works_with_simple_query(self):\n        query = 'SELECT 1'\n        self.assertEqual([], extract_query_params(query))\n    \nTestExtractParamQueryIds().test_works_with_simple_query()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractParamQueryIds(TestCase):\n    def test_ignores_non_param_queries(self):\n        query = 'SELECT * FROM query_123'\n        self.assertEqual([], extract_query_params(query))\n    \nTestExtractParamQueryIds().test_ignores_non_param_queries()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractParamQueryIds(TestCase):\n    def test_ignores_cached_queries_to_load(self):\n        query = 'SELECT * FROM cached_query_123'\n        self.assertEqual([], extract_query_params(query))\n    \nTestExtractParamQueryIds().test_ignores_cached_queries_to_load()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractParamQueryIds(TestCase):\n    def test_finds_queries_to_load(self):\n        query = 'SELECT * FROM param_query_123_{token=test}'\n        self.assertEqual([('123', 'token=test')], extract_query_params(query))\n    \nTestExtractParamQueryIds().test_finds_queries_to_load()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}, {"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestExtractParamQueryIds(TestCase):\n    def test_finds_queries_in_joins(self):\n        query = (\n            'SELECT * FROM param_query_123_{token1=test1} JOIN param_query_456_{token2=test2}'\n            )\n        self.assertEqual([('123', 'token1=test1'), ('456', 'token2=test2')],\n            extract_query_params(query))\n    \nTestExtractParamQueryIds().test_finds_queries_in_joins()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The function 'extract_query_params' is designed to parse a given SQL query string and identify any specific parameters that are embedded within it. The function is particularly interested in capturing parameters that follow a certain pattern: 'join' or 'from' keywords immediately followed by 'param_query_<number>_<parameter_name>'. This pattern should be searched for case-insensitively.\n\nInputs: \n1. query: A string representing an SQL query. This string may contain one or more instances of the specified pattern.\n\nOutputs: \nThe function should return a list of tuples, where each tuple contains two elements:\n1. The first element is the number (as a string) immediately following 'param_query_'.\n2. The second element is the name of the parameter enclosed in curly braces {}.\nNote: The order of the tuples in the output list should match the order in which the patterns are encountered in the query string.\n\nExample usage is not provided to avoid revealing test cases, but the function should be able to handle various SQL queries and accurately extract all matching patterns as specified.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_query_params(query): [MASK]\n"}
{"method_name": "prepare_parameterized_query", "full_method_name": "prepare_parameterized_query", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef prepare_parameterized_query(query, query_params):\n    for params in query_params:\n        table_hash = hashlib.md5('query_{query}_{hash}'.format(query=params\n            [0], hash=params[1]).encode(), usedforsecurity=False).hexdigest()\n        key = 'param_query_{query_id}_{{{param_string}}}'.format(query_id=\n            params[0], param_string=params[1])\n        value = 'query_{query_id}_{param_hash}'.format(query_id=params[0],\n            param_hash=table_hash)\n        query = query.replace(key, value)\n    return query", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestPrepareParameterizedQuery(TestCase):\n    def test_param_query_replacement(self):\n        result = prepare_parameterized_query(\n            'SELECT * FROM param_query_123_{token=test}', [('123', 'token=test')])\n        self.assertEqual('SELECT * FROM query_123_1c5f1acad40f99b968836273d74baa89'\n            , result)\n    \nTestPrepareParameterizedQuery().test_param_query_replacement()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The prepare_parameterized_query function is designed to prepare a parameterized SQL query by replacing placeholders in the query string with hashed values based on the provided query parameters. The function aims to prevent SQL injection by ensuring that all parameters are securely hashed before being inserted into the query.\n\nInputs: \n- query: A string representing the SQL query with placeholders for parameters. These placeholders are formatted as 'param_query_{query_id}_{{{param_string}}}' where {query_id} and {param_string} are placeholders for the ID and string representation of the parameters respectively.\n- query_params: A list of tuples or lists, where each tuple or list contains two elements: the query ID and a string representation of the parameters. The function will use these parameters to create a hash for each placeholder in the query.\n\nOutputs:\n- A string representing the prepared SQL query with all placeholders replaced by their hashed values. The placeholders are replaced in such a way that the resulting query is secure against SQL injection attacks.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef prepare_parameterized_query(query, query_params): [MASK]\n"}
{"method_name": "replace_query_parameters", "full_method_name": "replace_query_parameters", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef replace_query_parameters(query_text, params):\n    qs = parse_qs(params)\n    for key, value in qs.items():\n        query_text = query_text.replace('{{{{{my_key}}}}}'.format(my_key=\n            key), value[0])\n    return query_text", "test_code_list": [{"test_code": "import datetime\nimport decimal\nimport sqlite3\nfrom unittest import TestCase\nimport pytest\n\nclass TestReplaceQueryParameters(TestCase):\n    def test_replace_query_params(self):\n        result = replace_query_parameters(\"SELECT '{{token1}}', '{{token2}}'\",\n            'token1=test1&token2=test2')\n        self.assertEqual(\"SELECT 'test1', 'test2'\", result)\n    \nTestReplaceQueryParameters().test_replace_query_params()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_query_results.py"}], "instruction": "Functionality: The replace_query_parameters function is designed to replace placeholders within a SQL query with corresponding values from a query string. It parses the query string to extract key-value pairs and replaces placeholders formatted as {{{{key}}}} in the query text with the associated value.\n\nInputs: \n1. query_text (str): A SQL query string that may contain placeholders formatted as {{{{key}}}} for substitution.\n2. params (str): A query string containing key-value pairs, where keys correspond to placeholders in the query_text.\n\nOutputs: \n1. str: The modified query string with all placeholders replaced by their corresponding values from the query string. If a placeholder does not have a corresponding key in the query string, it remains unchanged.", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef replace_query_parameters(query_text, params): [MASK]\n"}
{"method_name": "generate_ssl_options_dict", "full_method_name": "generate_ssl_options_dict", "method_path": "../srcdata/Visualization/redash/redash/query_runner/cass.py", "method_code": "import logging\nimport os\nimport ssl\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\ndef generate_ssl_options_dict(protocol, cert_path=None):\n    ssl_options = {'ssl_version': getattr(ssl, protocol)}\n    if cert_path is not None:\n        ssl_options['ca_certs'] = cert_path\n        ssl_options['cert_reqs'] = ssl.CERT_REQUIRED\n    return ssl_options", "test_code_list": [{"test_code": "import ssl\nfrom unittest import TestCase\n\nclass TestCassandra(TestCase):\n    def test_generate_ssl_options_dict_creates_plain_protocol_dict(self):\n        expected = {'ssl_version': ssl.PROTOCOL_TLSv1_2}\n        actual = generate_ssl_options_dict('PROTOCOL_TLSv1_2')\n        self.assertDictEqual(expected, actual)\n    \nTestCassandra().test_generate_ssl_options_dict_creates_plain_protocol_dict()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_cass.py"}, {"test_code": "import ssl\nfrom unittest import TestCase\n\nclass TestCassandra(TestCase):\n    def test_generate_ssl_options_dict_creates_certificate_dict(self):\n        expected = {'ssl_version': ssl.PROTOCOL_TLSv1_2, 'ca_certs':\n            'some/path', 'cert_reqs': ssl.CERT_REQUIRED}\n        actual = generate_ssl_options_dict('PROTOCOL_TLSv1_2', 'some/path')\n        self.assertDictEqual(expected, actual)\n    \nTestCassandra().test_generate_ssl_options_dict_creates_certificate_dict()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_cass.py"}], "instruction": "Functionality: This function generates an SSL options dictionary that can be used to configure SSL/TLS connections. It allows for specifying the SSL protocol version and optionally, a certificate path for additional security measures.\n\nInputs: \n1. protocol (str): A string representing the SSL protocol version (e.g., 'PROTOCOL_TLSv1_2').\n2. cert_path (str, optional): The path to the certificate file. If provided, the function will also set the 'ca_certs' and 'cert_reqs' keys in the dictionary.\n\nOutputs: \n1. ssl_options (dict): A dictionary containing the SSL options. It includes the 'ssl_version' key with the specified protocol version, and if the 'cert_path' is provided, it also includes 'ca_certs' and 'cert_reqs' keys.", "method_code_mask": "import logging\nimport os\nimport ssl\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\n\n\ndef generate_ssl_options_dict(protocol, cert_path=None): [MASK]\n"}
{"method_name": "parse_query", "full_method_name": "parse_query", "method_path": "../srcdata/Visualization/redash/redash/query_runner/google_spreadsheets.py", "method_code": "import logging\nimport re\nfrom base64 import b64decode\nfrom dateutil import parser\nfrom requests import Session\nimport google.auth\nfrom google.auth.exceptions import GoogleAuthError\nfrom google.oauth2.service_account import Credentials\ndef parse_query(query):\n    values = query.split('|')\n    key = values[0]\n    worksheet_num_or_title = 0\n    if len(values) == 2:\n        s = values[1].strip()\n        if len(s) > 0:\n            if re.match('^\\\\\"(.*?)\\\\\"$', s):\n                worksheet_num_or_title = s[1:-1]\n            else:\n                worksheet_num_or_title = int(s)\n    return key, worksheet_num_or_title", "test_code_list": [{"test_code": "import datetime\nfrom unittest import TestCase\nimport pytest\nfrom google.auth.exceptions import TransportError\n\nclass TestParseQuery(TestCase):\n    def test_parse_query(self):\n        parsed = parse_query('key|0')\n        self.assertEqual(('key', 0), parsed)\n    \nTestParseQuery().test_parse_query()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_google_spreadsheets.py"}, {"test_code": "import datetime\nfrom unittest import TestCase\nimport pytest\nfrom google.auth.exceptions import TransportError\n\nclass TestParseQuery(TestCase):\n    def test_parse_query_ignored(self):\n        parsed = parse_query('key')\n        self.assertEqual(('key', 0), parsed)\n        parsed = parse_query('key|')\n        self.assertEqual(('key', 0), parsed)\n        parsed = parse_query('key|1|')\n        self.assertEqual(('key', 0), parsed)\n    \nTestParseQuery().test_parse_query_ignored()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_google_spreadsheets.py"}, {"test_code": "import datetime\nfrom unittest import TestCase\nimport pytest\nfrom google.auth.exceptions import TransportError\n\nclass TestParseQuery(TestCase):\n    def test_parse_query_title(self):\n        parsed = parse_query('key|\"\"')\n        self.assertEqual(('key', ''), parsed)\n        parsed = parse_query('key|\"1\"')\n        self.assertEqual(('key', '1'), parsed)\n        parsed = parse_query('key|\"abc\"')\n        self.assertEqual(('key', 'abc'), parsed)\n        parsed = parse_query('key|\"\u3042\"')\n        self.assertEqual(('key', '\u3042'), parsed)\n        parsed = parse_query('key|\"1\"\"')\n        self.assertEqual(('key', '1\"'), parsed)\n        parsed = parse_query('key|\"\"')\n        self.assertEqual(('key', ''), parsed)\n    \nTestParseQuery().test_parse_query_title()\n", "code_start": "", "test_path": "../srcdata/Visualization/redash/tests/query_runner/test_google_spreadsheets.py"}], "instruction": "Functionality: The function parse_query is designed to parse and extract information from a query string. The query string is expected to be in a specific format, where it contains a key and potentially a worksheet number or title, separated by a pipe (|) character. The function aims to split the query string and return the key and the worksheet number or title if available.\n\nInputs: \n- query: A string containing the query. The format of the query string is \"key|worksheet\", where \"key\" is mandatory and \"worksheet\" is optional. If \"worksheet\" is provided, it can either be a number or a string enclosed in double quotes.\n\nOutputs:\n- A tuple containing:\n    - The first element: The key extracted from the query string.\n    - The second element: The worksheet number or title if provided in the query string, otherwise, the default value 0 is returned. If the worksheet is provided as a quoted string, the quotes are removed, and the string is returned. If it is provided as a number, it is returned as an integer.", "method_code_mask": "import logging\nimport re\nfrom base64 import b64decode\nfrom dateutil import parser\nfrom requests import Session\nimport google.auth\nfrom google.auth.exceptions import GoogleAuthError\nfrom google.oauth2.service_account import Credentials\n\n\ndef parse_query(query): [MASK]\n"}
