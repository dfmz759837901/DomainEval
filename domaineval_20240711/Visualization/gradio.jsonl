{"method_name": "is_in_or_equal", "full_method_name": "is_in_or_equal", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef abspath(path: (str | Path)) ->Path:\n    \"\"\"Returns absolute path of a str or Path path, but does not resolve symlinks.\"\"\"\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    is_symlink = path.is_symlink() or any(parent.is_symlink() for parent in\n        path.parents)\n    if is_symlink or path == path.resolve():\n        return Path.cwd() / path\n    else:\n        return path.resolve()\ndef is_in_or_equal(path_1: (str | Path), path_2: (str | Path)):\n    \"\"\"\n    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the\n    same, returns False otherwise.\n    Parameters:\n        path_1: str or Path (to file or directory)\n        path_2: str or Path (to file or directory)\n    \"\"\"\n    path_1, path_2 = abspath(path_1), abspath(path_2)\n    try:\n        relative_path = path_1.relative_to(path_2)\n        if str(relative_path) == '.':\n            return True\n        relative_path = path_1.parent.relative_to(path_2)\n        return '..' not in str(relative_path)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\ndef test_is_in_or_equal():\n    assert is_in_or_equal('files/lion.jpg', 'files/lion.jpg')\n    assert is_in_or_equal('files/lion.jpg', 'files')\n    assert is_in_or_equal('files/lion.._M.jpg', 'files')\n    assert not is_in_or_equal('files', 'files/lion.jpg')\n    assert is_in_or_equal('/home/usr/notes.txt', '/home/usr/')\n    assert not is_in_or_equal('/home/usr/subdirectory', '/home/usr/notes.txt')\n    assert not is_in_or_equal('/home/usr/../../etc/notes.txt', '/home/usr/')\n    assert not is_in_or_equal('/safe_dir/subdir/../../unsafe_file.txt',\n        '/safe_dir/')\n\ntest_is_in_or_equal()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: Determine if one path is located within or is equal to another path.\nInputs: \n    - path_1: A string or Path object representing the first path to a file or directory.\n    - path_2: A string or Path object representing the second path to a file or directory.\nOutputs: \n    - A boolean value indicating whether path_1 is a descendant of path_2 or if the paths are equal. True is returned if path_1 is located within path_2 or if the two paths are the same. False is returned otherwise.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef abspath(path: (str | Path)) ->Path:\n    \"\"\"Returns absolute path of a str or Path path, but does not resolve symlinks.\"\"\"\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    is_symlink = path.is_symlink() or any(parent.is_symlink() for parent in\n        path.parents)\n    if is_symlink or path == path.resolve():\n        return Path.cwd() / path\n    else:\n        return path.resolve()\n\n\ndef is_in_or_equal(path_1: (str | Path), path_2: (str | Path)): [MASK]\n"}
{"method_name": "_parse_file_size", "full_method_name": "_parse_file_size", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\nclass FileSize:\n    B = 1\n    KB = 1024 * B\n    MB = 1024 * KB\n    GB = 1024 * MB\n    TB = 1024 * GB\ndef _parse_file_size(size: (str | int | None)) ->(int | None):\n    if isinstance(size, int) or size is None:\n        return size\n    size = size.replace(' ', '')\n    last_digit_index = next((i for i, c in enumerate(size) if not c.isdigit\n        ()), len(size))\n    size_int, unit = int(size[:last_digit_index]), size[last_digit_index:\n        ].upper()\n    multiple = getattr(FileSize, unit, None)\n    if not multiple:\n        raise ValueError(f'Invalid file size unit: {unit}')\n    return multiple * size_int", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\ndef test_parse_file_size():\n    assert _parse_file_size('1kb') == 1 * FileSize.KB\n    assert _parse_file_size('1mb') == 1 * FileSize.MB\n    assert _parse_file_size('505 Mb') == 505 * FileSize.MB\n\ntest_parse_file_size()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The function _parse_file_size is designed to parse a string representing a file size in human-readable format and convert it into its equivalent integer value in bytes. It supports units such as B (bytes), KB (kilobytes), MB (megabytes), GB (gigabytes), and TB (terabytes). If the input is already an integer, it is returned as-is. If the input is None, the function also returns None. If the input string does not contain a valid unit or is in an incorrect format, a ValueError is raised.\n\nInputs: \n- size: A string, integer, or None. The string can represent a file size in any of the supported units (B, KB, MB, GB, TB). The integer is assumed to be the size in bytes. None is used to indicate an unspecified size.\n\nOutputs: \n- An integer representing the file size in bytes, or None if the input was None. In case of an invalid input string, a ValueError is raised, detailing the issue with the provided unit.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\nclass FileSize:\n    B = 1\n    KB = 1024 * B\n    MB = 1024 * KB\n    GB = 1024 * MB\n    TB = 1024 * GB\n\n\ndef _parse_file_size(size: (str | int | None)) ->(int | None): [MASK]\n"}
{"method_name": "download_if_url", "full_method_name": "download_if_url", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef download_if_url(article: str) ->str:\n    try:\n        result = urllib.parse.urlparse(article)\n        is_url = all([result.scheme, result.netloc, result.path])\n        is_url = is_url and result.scheme in ['http', 'https']\n    except ValueError:\n        is_url = False\n    if not is_url:\n        return article\n    try:\n        response = httpx.get(article, timeout=3)\n        if response.status_code == httpx.codes.OK:\n            article = response.text\n    except (httpx.InvalidURL, httpx.RequestError, httpx.TimeoutException):\n        pass\n    return article", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_download_if_url_doesnt_crash_on_connection_error(self):\n        in_article = 'placeholder'\n        out_article = download_if_url(in_article)\n        assert out_article == in_article\n        in_article = 'text\\twith\\rnon-printable\\nASCII\\x00characters'\n        out_article = download_if_url(in_article)\n        assert out_article == in_article\n        in_article = 'ftp://localhost/tmp/index.html'\n        out_article = download_if_url(in_article)\n        assert out_article == in_article\n        in_article = 'file:///C:/tmp/index.html'\n        out_article = download_if_url(in_article)\n        assert out_article == in_article\n        in_article = 'https://[unmatched_bracket#?:@/index.html'\n        out_article = download_if_url(in_article)\n        assert out_article == in_article\n    \nTestUtils().test_download_if_url_doesnt_crash_on_connection_error()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The download_if_url function is designed to check if the given input is a valid URL and if so, it attempts to download the content. If the input is not a URL, it returns the input as is. If the URL is valid and the download is successful, the function returns the content of the downloaded URL as a string. If the download fails or the URL is invalid, the function returns the original input.\n\nInputs: \n- article: A str representing either a URL or a non-URL string. The URL should be in a format that urllib.parse.urlparse can recognize, and it should point to an accessible resource via HTTP or HTTPS.\n\nOutputs: \n- A str containing either the original input if it was not a URL or if the URL download failed, or the content of the URL if the download was successful. The content is returned as plain text.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef download_if_url(article: str) ->str: [MASK]\n"}
{"method_name": "sagemaker_check", "full_method_name": "sagemaker_check", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef sagemaker_check() ->bool:\n    try:\n        import boto3\n        client = boto3.client('sts')\n        response = client.get_caller_identity()\n        return 'sagemaker' in response['Arn'].lower()\n    except Exception:\n        return False", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_sagemaker_check_false(self):\n        assert not sagemaker_check()\n    \nTestUtils().test_sagemaker_check_false()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_sagemaker_check_false_if_boto3_not_installed(self):\n        with patch.dict(sys.modules, {'boto3': None}, clear=True):\n            assert not sagemaker_check()\n    \nTestUtils().test_sagemaker_check_false_if_boto3_not_installed()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The sagemaker_check function determines whether the execution environment is within an AWS SageMaker instance. It achieves this by attempting to access the AWS Security Token Service (STS) using the boto3 library to fetch the caller identity. If the ARN (Amazon Resource Name) of the caller identity contains the string 'sagemaker', the function returns True, indicating that the code is being executed on an AWS SageMaker instance. Otherwise, it returns False.\n\nInputs: There are no input arguments for this function.\n\nOutputs: The function returns a boolean value, where True indicates the code is running on an AWS SageMaker instance, and False indicates it is not.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef sagemaker_check() ->bool: [MASK]\n"}
{"method_name": "kaggle_check", "full_method_name": "kaggle_check", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef kaggle_check() ->bool:\n    return bool(os.environ.get('KAGGLE_KERNEL_RUN_TYPE') or os.environ.get(\n        'GFOOTBALL_DATA_DIR'))", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_kaggle_check_false(self):\n        assert not kaggle_check()\n    \nTestUtils().test_kaggle_check_false()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_kaggle_check_true_when_run_type_set(self):\n        with patch.dict(os.environ, {'KAGGLE_KERNEL_RUN_TYPE': 'Interactive'},\n            clear=True):\n            assert kaggle_check()\n    \nTestUtils().test_kaggle_check_true_when_run_type_set()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_kaggle_check_true_when_both_set(self):\n        with patch.dict(os.environ, {'KAGGLE_KERNEL_RUN_TYPE': 'Interactive',\n            'GFOOTBALL_DATA_DIR': './'}, clear=True):\n            assert kaggle_check()\n    \nTestUtils().test_kaggle_check_true_when_both_set()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestUtils():\n    def test_kaggle_check_false_when_neither_set(self):\n        with patch.dict(os.environ, {'KAGGLE_KERNEL_RUN_TYPE': '',\n            'GFOOTBALL_DATA_DIR': ''}, clear=True):\n            assert not kaggle_check()\n    \nTestUtils().test_kaggle_check_false_when_neither_set()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The kaggle_check function is designed to verify whether the current environment is a Kaggle kernel. It checks for specific environment variables that are indicative of a Kaggle execution context. By detecting these variables, the function can determine if it's being run within the Kaggle platform.\n\nInputs: The function does not take any input arguments. Instead, it relies on the presence of certain environment variables within the current execution context.\n\nOutputs: The function returns a boolean value. It returns True if the environment variables 'KAGGLE_KERNEL_RUN_TYPE' or 'GFOOTBALL_DATA_DIR' are present in os.environ, which would signify that the code is running in a Kaggle kernel. Otherwise, it returns False.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef kaggle_check() ->bool: [MASK]\n"}
{"method_name": "format_ner_list", "full_method_name": "format_ner_list", "method_path": "../srcdata/Visualization/gradio/gradio/external_utils.py", "method_code": "from __future__ import annotations\nimport base64\nimport math\nimport re\nimport warnings\nimport yaml\nfrom huggingface_hub import InferenceClient\ndef format_ner_list(input_string: str, ner_groups: list[dict[str, str | int]]):\n    if len(ner_groups) == 0:\n        return [(input_string, None)]\n    output = []\n    end = 0\n    prev_end = 0\n    for group in ner_groups:\n        entity, start, end = group['entity_group'], group['start'], group['end'\n            ]\n        output.append((input_string[prev_end:start], None))\n        output.append((input_string[start:end], entity))\n        prev_end = end\n    output.append((input_string[end:], None))\n    return output", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestFormatNERList():\n    def test_format_ner_list_standard(self):\n        string = 'Wolfgang lives in Berlin'\n        groups = [{'entity_group': 'PER', 'start': 0, 'end': 8}, {\n            'entity_group': 'LOC', 'start': 18, 'end': 24}]\n        result = [('', None), ('Wolfgang', 'PER'), (' lives in ', None), (\n            'Berlin', 'LOC'), ('', None)]\n        assert format_ner_list(string, groups) == result\n    \nTestFormatNERList().test_format_ner_list_standard()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestFormatNERList():\n    def test_format_ner_list_empty(self):\n        string = 'I live in a city'\n        groups = []\n        result = [('I live in a city', None)]\n        assert format_ner_list(string, groups) == result\n    \nTestFormatNERList().test_format_ner_list_empty()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The function format_ner_list is designed to process a string and a list of named entity recognitions (NERs) to format the input string by tagging entities based on the NER information. It appends substrings between entities and the entities themselves with their respective types to a list, which is then returned.\n\nInputs: \n- input_string: A string representing the text from which named entities will be extracted.\n- ner_groups: A list of dictionaries, where each dictionary contains information about a named entity. Each dictionary must have the keys 'entity_group' (str), 'start' (int), and 'end' (int), representing the type of the entity, and the start and end indices of the entity within the input_string, respectively.\n\nOutputs:\n- A list of tuples, where each tuple contains a substring of the input string and either the entity type (if the substring is an entity) or None (if the substring is between entities). The list starts with the substring from the beginning of the input string up to the first entity, followed by tuples for each entity and the substrings between them, and ends with the substring from the last entity to the end of the input string.", "method_code_mask": "from __future__ import annotations\nimport base64\nimport math\nimport re\nimport warnings\nimport yaml\nfrom huggingface_hub import InferenceClient\n\n\ndef format_ner_list(input_string: str, ner_groups: list[dict[str, str | int]]\n    ): [MASK]\n"}
{"method_name": "delete_none", "full_method_name": "delete_none", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef delete_none(_dict: dict, skip_value: bool=False) ->dict:\n    \"\"\"\n    Delete keys whose values are None from a dictionary\n    \"\"\"\n    for key, value in list(_dict.items()):\n        if skip_value and key == 'value':\n            continue\n        elif value is None:\n            del _dict[key]\n    return _dict", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestDeleteNone():\n    def test_delete_none(self):\n        input = {'a': 12, 'b': 34, 'c': None, 'k': {'d': 34, 't': None, 'm': [{\n            'k': 23, 't': None}, [None, 1, 2, 3], {1, 2, None}], None: 123}}\n        truth = {'a': 12, 'b': 34, 'k': {'d': 34, 't': None, 'm': [{'k': 23,\n            't': None}, [None, 1, 2, 3], {1, 2, None}], None: 123}}\n        assert delete_none(input) == truth\n    \nTestDeleteNone().test_delete_none()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: \nThe function 'delete_none' is designed to remove any key-value pairs from a dictionary where the value is None. It provides an option to skip checking a key named 'value' if desired.\n\nInputs:\n- _dict: dict\n    A dictionary from which key-value pairs where the value is None should be removed.\n- skip_value: bool = False\n    A flag to indicate whether to skip checking the value of a key named 'value'.\n\nOutputs:\n- dict\n    The dictionary after removing key-value pairs where the value is None. If 'skip_value' is True, key-value pairs with the key 'value' are not checked for None values.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef delete_none(_dict: dict, skip_value: bool=False) ->dict: [MASK]\n"}
{"method_name": "sanitize_value_for_csv", "full_method_name": "sanitize_value_for_csv", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef sanitize_value_for_csv(value: (str | float)) ->(str | float):\n    \"\"\"\n    Sanitizes a value that is being written to a CSV file to prevent CSV injection attacks.\n    Reference: https://owasp.org/www-community/attacks/CSV_Injection\n    \"\"\"\n    if isinstance(value, (float, int)):\n        return value\n    unsafe_prefixes = ['=', '+', '-', '@', '\\t', '\\n']\n    unsafe_sequences = [',=', ',+', ',-', ',@', ',\\t', ',\\n']\n    if any(value.startswith(prefix) for prefix in unsafe_prefixes) or any(\n        sequence in value for sequence in unsafe_sequences):\n        value = f\"'{value}\"\n    return value", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestSanitizeForCSV():\n    def test_unsafe_value(self):\n        assert sanitize_value_for_csv('=OPEN()') == \"'=OPEN()\"\n        assert sanitize_value_for_csv('=1+2') == \"'=1+2\"\n        assert sanitize_value_for_csv('=1+2\";=1+2') == '\\'=1+2\";=1+2'\n    \nTestSanitizeForCSV().test_unsafe_value()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestSanitizeForCSV():\n    def test_safe_value(self):\n        assert sanitize_value_for_csv(4) == 4\n        assert sanitize_value_for_csv(-44.44) == -44.44\n        assert sanitize_value_for_csv('1+1=2') == '1+1=2'\n        assert sanitize_value_for_csv('1aaa2') == '1aaa2'\n    \nTestSanitizeForCSV().test_safe_value()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: This function sanitizes a value that is being written to a CSV file to prevent CSV injection attacks. It checks if the value is a float or an integer; if so, it returns the value as is. If the value is a string, it checks for unsafe prefixes (e.g., '=', '+', '-', '@', '\\t', '\\n') and unsafe sequences (e.g., ',=', ',+', ',-', ',@', ',\\t', ',\\n'). If any of these are found at the beginning of the string or within the string, the function will enclose the string in single quotes to prevent it from being interpreted as CSV control characters.\n\nInputs: \n- value: (str | float) The value to be sanitized. It can be a string or a float. If it's a string, it will be checked for potential CSV injection.\n\nOutputs: \n- (str | float): The sanitized value. If the input was a float or an integer, it will be returned as is. If the input was a string, it will be returned as is unless it contains an unsafe prefix or sequence, in which case it will be enclosed in single quotes.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef sanitize_value_for_csv(value: (str | float)) ->(str | float): [MASK]\n"}
{"method_name": "validate_url", "full_method_name": "validate_url", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef validate_url(possible_url: str) ->bool:\n    headers = {'User-Agent':\n        'gradio (https://gradio.app/; gradio-team@huggingface.co)'}\n    try:\n        head_request = httpx.head(possible_url, headers=headers,\n            follow_redirects=True)\n        if head_request.status_code in (403, 405):\n            return httpx.get(possible_url, headers=headers,\n                follow_redirects=True).is_success\n        return head_request.is_success\n    except Exception:\n        return False", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestValidateURL():\n    def test_invalid_urls(self):\n        assert not validate_url('C:/Users/')\n        assert not validate_url('C:\\\\Users\\\\')\n        assert not validate_url('/home/user')\n    \nTestValidateURL().test_invalid_urls()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The function validate_url is designed to check the validity of a given URL. It sends a request to the URL and verifies if the server responds with a successful status code, indicating that the URL is valid and accessible.\n\nInputs: \n- possible_url (str): A string representing the URL to be validated.\n\nOutputs: \n- bool: A boolean value indicating whether the URL is valid and accessible. True if the URL is valid, False otherwise.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef validate_url(possible_url: str) ->bool: [MASK]\n"}
{"method_name": "append_unique_suffix", "full_method_name": "append_unique_suffix", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef append_unique_suffix(name: str, list_of_names: list[str]):\n    \"\"\"Appends a numerical suffix to `name` so that it does not appear in `list_of_names`.\"\"\"\n    set_of_names: set[str] = set(list_of_names)\n    if name not in set_of_names:\n        return name\n    else:\n        suffix_counter = 1\n        new_name = f'{name}_{suffix_counter}'\n        while new_name in set_of_names:\n            suffix_counter += 1\n            new_name = f'{name}_{suffix_counter}'\n        return new_name", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestAppendUniqueSuffix():\n    def test_no_suffix(self):\n        name = 'test'\n        list_of_names = ['test_1', 'test_2']\n        assert append_unique_suffix(name, list_of_names) == name\n    \nTestAppendUniqueSuffix().test_no_suffix()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestAppendUniqueSuffix():\n    def test_first_suffix(self):\n        name = 'test'\n        list_of_names = ['test', 'test_-1']\n        assert append_unique_suffix(name, list_of_names) == 'test_1'\n    \nTestAppendUniqueSuffix().test_first_suffix()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}, {"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestAppendUniqueSuffix():\n    def test_later_suffix(self):\n        name = 'test'\n        list_of_names = ['test', 'test_1', 'test_2', 'test_3']\n        assert append_unique_suffix(name, list_of_names) == 'test_4'\n    \nTestAppendUniqueSuffix().test_later_suffix()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The function append_unique_suffix takes a string name and a list of strings list_of_names as inputs. It appends a numerical suffix to the input name in order to make it unique within the list_of_names. If the name is already unique, it returns the name unchanged. If the name is not unique, it appends an underscore and a number (starting from 1) until the new name is unique.\n\nInputs: \n- name: A string representing the base name that may or may not be unique.\n- list_of_names: A list of strings representing a collection of names that the input name should be made unique against.\n\nOutputs:\n- A string representing the original name if it is unique within the list_of_names, or the name with a numerical suffix appended to make it unique against the list_of_names.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef append_unique_suffix(name: str, list_of_names: list[str]): [MASK]\n"}
{"method_name": "abspath", "full_method_name": "abspath", "method_path": "../srcdata/Visualization/gradio/gradio/utils.py", "method_code": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\ndef abspath(path: (str | Path)) ->Path:\n    \"\"\"Returns absolute path of a str or Path path, but does not resolve symlinks.\"\"\"\n    path = Path(path)\n    if path.is_absolute():\n        return path\n    is_symlink = path.is_symlink() or any(parent.is_symlink() for parent in\n        path.parents)\n    if is_symlink or path == path.resolve():\n        return Path.cwd() / path\n    else:\n        return path.resolve()", "test_code_list": [{"test_code": "import json\nimport os\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom typing_extensions import Literal\nimport matplotlib\n\nclass TestAbspath():\n    def test_abspath_no_symlink(self):\n        resolved_path = str(abspath('../gradio/gradio/test_data/lion.jpg'))\n        assert '..' not in resolved_path\n    \nTestAbspath().test_abspath_no_symlink()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/gradio/test/test_utils.py"}], "instruction": "Functionality: The function 'abspath' is designed to return the absolute path of a given path (which can be either a string or a Path object) without resolving any symbolic links. It checks if the path is already absolute or a symlink, and handles these cases appropriately.\n\nInputs: \n- path: This is the input path for which the absolute path is to be determined. It can be of type 'str' or 'Path'. If it's a 'str', it will be converted to a 'Path' object internally.\n\nOutputs: \n- Returns a 'Path' object representing the absolute path of the input path. If the input path is already absolute, it is returned as is. If the input path is a symbolic link or resolves to the current working directory, the absolute path based on the current working directory is returned. Otherwise, the resolved path is returned.", "method_code_mask": "from __future__ import annotations\nimport ast\nimport asyncio\nimport copy\nimport functools\nimport hashlib\nimport importlib\nimport importlib.util\nimport inspect\nimport json\nimport json.decoder\nimport os\nimport pkgutil\nimport re\nimport sys\nimport tempfile\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.parse\nimport warnings\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections import OrderedDict\nfrom collections.abc import MutableMapping\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Literal\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing_extensions import ParamSpec\nfrom IPython.core.getipython import get_ipython\nimport boto3\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\ndef abspath(path: (str | Path)) ->Path: [MASK]\n"}
{"method_name": "cols_to_rows", "full_method_name": "cols_to_rows", "method_path": "../srcdata/Visualization/gradio/gradio/external_utils.py", "method_code": "from __future__ import annotations\nimport base64\nimport math\nimport re\nimport warnings\nimport yaml\nfrom huggingface_hub import InferenceClient\ndef cols_to_rows(example_data: dict[str, list[float | str] | None]) ->tuple[\n    list[str], list[list[float]]]:\n    headers = list(example_data.keys())\n    n_rows = max(len(example_data[header] or []) for header in headers)\n    data = []\n    for row_index in range(n_rows):\n        row_data = []\n        for header in headers:\n            col = example_data[header] or []\n            if row_index >= len(col):\n                row_data.append('NaN')\n            else:\n                row_data.append(col[row_index])\n        data.append(row_data)\n    return headers, data", "test_code_list": [{"test_code": "import os\nimport tempfile\nimport textwrap\nimport warnings\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom unittest.mock import patch\nimport pytest\nfrom huggingface_hub import HfFolder\ndef test_cols_to_rows():\n    assert cols_to_rows({'a': [1, 2, 'NaN'], 'b': [1, 'NaN', 3]}) == (['a',\n        'b'], [[1, 1], [2, 'NaN'], ['NaN', 3]])\n    assert cols_to_rows({'a': [1, 2, 'NaN', 4], 'b': [1, 'NaN', 3]}) == ([\n        'a', 'b'], [[1, 1], [2, 'NaN'], ['NaN', 3], [4, 'NaN']])\n    assert cols_to_rows({'a': [1, 2, 'NaN'], 'b': [1, 'NaN', 3, 5]}) == ([\n        'a', 'b'], [[1, 1], [2, 'NaN'], ['NaN', 3], ['NaN', 5]])\n    assert cols_to_rows({'a': None, 'b': [1, 'NaN', 3, 5]}) == (['a', 'b'],\n        [['NaN', 1], ['NaN', 'NaN'], ['NaN', 3], ['NaN', 5]])\n    assert cols_to_rows({'a': None, 'b': None}) == (['a', 'b'], [])\n\ntest_cols_to_rows()\n", "code_start": "", "test_path": "../srcdata/Visualization/gradio/test/test_external.py"}], "instruction": "Functionality: The cols_to_rows function is designed to convert a dictionary of lists (representing data in a column-oriented structure) into a row-oriented data structure. This is particularly useful for tabular data transformations where the input dictionary keys are column headers and the values are lists of data for each column.\n\nInputs: The function takes a single argument, example_data, which is a dictionary. The keys of this dictionary are strings representing column headers, and the values are lists of either floats or strings. The list for each column may contain None values, which should be handled appropriately.\n\nOutputs: The function returns a tuple containing two elements:\n1. The first element is a list of strings, representing the headers of the columns.\n2. The second element is a list of lists, where each inner list represents a row of data. The elements in each row list are floats or strings, depending on the original data type. If a row has no value for a particular column, it should contain the string 'NaN' instead.", "method_code_mask": "from __future__ import annotations\nimport base64\nimport math\nimport re\nimport warnings\nimport yaml\nfrom huggingface_hub import InferenceClient\n\n\ndef cols_to_rows(example_data: dict[str, list[float | str] | None]) ->tuple[\n    list[str], list[list[float]]]: [MASK]\n"}
{"method_name": "_get_version_from_file", "full_method_name": "_get_version_from_file", "method_path": "../srcdata/Visualization/gradio/gradio/cli/commands/components/publish.py", "method_code": "from __future__ import annotations\nimport re\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom typing import List\nfrom typing import Optional\nfrom huggingface_hub import HfApi\nfrom tomlkit import parse\nfrom typing_extensions import Annotated\ndef _get_version_from_file(dist_file: Path) ->Optional[str]:\n    match = re.search('-(\\\\d+\\\\.\\\\d+\\\\.\\\\d+[a-zA-Z]*\\\\d*)-', dist_file.name)\n    if match:\n        return match.group(1)", "test_code_list": [{"test_code": "import shutil\nimport textwrap\nfrom pathlib import Path\nimport pytest\ndef test_get_version_from_wheel():\n    assert _get_version_from_file(Path(\n        'gradio_textwithattachments-0.0.3-py3-none.whl')) == '0.0.3'\n    assert _get_version_from_file(Path(\n        'gradio_textwithattachments-1.0.3b12-py3-none.whl')) == '1.0.3b12'\n\ntest_get_version_from_wheel()\n", "code_start": "", "test_path": "../srcdata/Visualization/gradio/test/test_gradio_component_cli.py"}], "instruction": "Functionality: The function _get_version_from_file is designed to extract the version number from a given distribution file path. It searches for a pattern in the file name that represents the version number and returns it if found.\n\nInputs: \n- dist_file: A Path object representing the distribution file from which the version number is to be extracted.\n\nOutputs:\n- Optional[str]: The function returns the version number as a string if found within the file name. If no version number is found, it returns None.", "method_code_mask": "from __future__ import annotations\nimport re\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom typing import List\nfrom typing import Optional\nfrom huggingface_hub import HfApi\nfrom tomlkit import parse\nfrom typing_extensions import Annotated\n\n\ndef _get_version_from_file(dist_file: Path) ->Optional[str]: [MASK]\n"}
{"method_name": "convert_to_16_bit_wav", "full_method_name": "convert_to_16_bit_wav", "method_path": "../srcdata/Visualization/gradio/gradio/processing_utils.py", "method_code": "from __future__ import annotations\nimport base64\nimport hashlib\nimport json\nimport logging\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom PIL import Image\nfrom PIL import ImageOps\nfrom PIL import ImageSequence\nfrom PIL import PngImagePlugin\nimport urllib3\ndef convert_to_16_bit_wav(data):\n    warning = (\n        'Trying to convert audio automatically from {} to 16-bit int format.')\n    if data.dtype in [np.float64, np.float32, np.float16]:\n        warnings.warn(warning.format(data.dtype))\n        data = data / np.abs(data).max()\n        data = data * 32767\n        data = data.astype(np.int16)\n    elif data.dtype == np.int32:\n        warnings.warn(warning.format(data.dtype))\n        data = data / 65536\n        data = data.astype(np.int16)\n    elif data.dtype == np.int16:\n        pass\n    elif data.dtype == np.uint16:\n        warnings.warn(warning.format(data.dtype))\n        data = data - 32768\n        data = data.astype(np.int16)\n    elif data.dtype == np.uint8:\n        warnings.warn(warning.format(data.dtype))\n        data = data * 257 - 32768\n        data = data.astype(np.int16)\n    elif data.dtype == np.int8:\n        warnings.warn(warning.format(data.dtype))\n        data = data * 256\n        data = data.astype(np.int16)\n    else:\n        raise ValueError(\n            f'Audio data cannot be converted automatically from {data.dtype} to 16-bit int format.'\n            )\n    return data", "test_code_list": [{"test_code": "import os\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\nimport numpy as np\nimport pytest\nfrom PIL import Image\nfrom PIL import ImageCms\nimport matplotlib.pyplot as plt\n\nclass TestAudioPreprocessing():\n    def test_convert_to_16_bit_wav(self):\n        audio = np.random.randint(-100, 100, size=100, dtype='int16')\n        audio[0] = -32767\n        audio[1] = 32766\n        audio_ = audio.astype('float64')\n        audio_ = convert_to_16_bit_wav(audio_)\n        assert np.allclose(audio, audio_)\n        assert audio_.dtype == 'int16'\n        audio_ = audio.astype('float32')\n        audio_ = convert_to_16_bit_wav(audio_)\n        assert np.allclose(audio, audio_)\n        assert audio_.dtype == 'int16'\n        audio_ = convert_to_16_bit_wav(audio)\n        assert np.allclose(audio, audio_)\n        assert audio_.dtype == 'int16'\n    \nTestAudioPreprocessing().test_convert_to_16_bit_wav()\n", "code_start": "", "test_path": "../srcdata/Visualization/gradio/test/test_processing_utils.py"}], "instruction": "Functionality: This function converts an audio data array to 16-bit integer format. It supports various input data types including float (32, 64, 16 bits), int (32, 16, 8 bits), and uint (16, 8 bits). The function scales the input data appropriately to fit into the 16-bit range and returns the converted data.\n\nInputs: \n- data: A numpy array containing the audio data to be converted. The input data can be of type float (np.float64, np.float32, np.float16), integer (np.int32, np.int16, np.int8), or unsigned integer (np.uint16, np.uint8).\n\nOutputs: \n- A numpy array of type np.int16 containing the audio data converted to 16-bit integer format.", "method_code_mask": "from __future__ import annotations\nimport base64\nimport hashlib\nimport json\nimport logging\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom PIL import Image\nfrom PIL import ImageOps\nfrom PIL import ImageSequence\nfrom PIL import PngImagePlugin\nimport urllib3\n\n\ndef convert_to_16_bit_wav(data): [MASK]\n"}
