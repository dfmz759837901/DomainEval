{"method_name": "is_valid_aesthetic", "full_method_name": "is_valid_aesthetic", "method_path": "../srcdata/Visualization/plotnine/plotnine/mapping/aes.py", "method_code": "from __future__ import annotations\nimport re\nimport typing\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom dataclasses import fields\nfrom typing import Any\nfrom typing import Dict\nimport pandas as pd\nfrom typing import Protocol\nfrom typing import TypeVar\ndef is_valid_aesthetic(value: Any, ae: str) ->bool:\n    \"\"\"\n    Return True if `value` looks valid.\n\n    Parameters\n    ----------\n    value :\n        Value to check\n    ae :\n        Aesthetic name\n\n    Notes\n    -----\n    There are no guarantees that he value is spot on\n    valid.\n    \"\"\"\n    if ae == 'linetype':\n        named = {'solid', 'dashed', 'dashdot', 'dotted', '_', '--', '-.',\n            ':', 'none', ' ', ''}\n        if value in named:\n            return True\n        conditions = [isinstance(value, tuple), isinstance(value[0], int),\n            isinstance(value[1], tuple), len(value[1]) % 2 == 0, all(\n            isinstance(x, int) for x in value[1])]\n        if all(conditions):\n            return True\n        return False\n    elif ae == 'shape':\n        if isinstance(value, str):\n            return True\n        conditions = [isinstance(value, tuple), all(isinstance(x, int) for\n            x in value), 0 <= value[1] < 3]\n        if all(conditions):\n            return True\n        return False\n    elif ae in {'color', 'fill'}:\n        if isinstance(value, str):\n            return True\n        with suppress(TypeError):\n            if isinstance(value, (tuple, list)) and all(0 <= x <= 1 for x in\n                value):\n                return True\n        return False\n    return False", "test_code_list": [{"test_code": "from copy import deepcopy\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport io\nimport pickle\ndef test_valid_aes_linetypes():\n    assert is_valid_aesthetic('solid', 'linetype')\n    assert is_valid_aesthetic('--', 'linetype')\n    assert not is_valid_aesthetic('tada', 'linetype')\n    assert is_valid_aesthetic((0, (3, 2)), 'linetype')\n    assert not is_valid_aesthetic((0, (3, 2.0)), 'linetype')\n    assert not is_valid_aesthetic((0, (3, 2, 1)), 'linetype')\n\ntest_valid_aes_linetypes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_ggplot_internals.py"}, {"test_code": "from copy import deepcopy\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport io\nimport pickle\ndef test_valid_aes_shapes():\n    assert is_valid_aesthetic('o', 'shape')\n    assert is_valid_aesthetic((4, 1, 45), 'shape')\n    assert not is_valid_aesthetic([4, 1, 45], 'shape')\n\ntest_valid_aes_shapes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_ggplot_internals.py"}, {"test_code": "from copy import deepcopy\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport io\nimport pickle\ndef test_valid_aes_colors():\n    assert is_valid_aesthetic('red', 'color')\n    assert is_valid_aesthetic('#FF0000', 'color')\n    assert is_valid_aesthetic('#FF000080', 'color')\n    assert is_valid_aesthetic((1, 0, 0), 'color')\n    assert is_valid_aesthetic((1, 0, 0), 'color')\n    assert is_valid_aesthetic((1, 0, 0, 0.5), 'color')\n\ntest_valid_aes_colors()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_ggplot_internals.py"}], "instruction": "Functionality: The function checks if a given value is valid for a specified aesthetic attribute. It supports aesthetics like 'linetype', 'shape', 'color', and 'fill'. The function validates the value based on the aesthetic's requirements.\n\nInputs:\n    - value : Any\n        The value to be checked for validity.\n    - ae : str\n        The aesthetic name for which the value is being checked.\n\nOutputs:\n    - bool\n        True if the value is valid for the specified aesthetic, False otherwise.", "method_code_mask": "from __future__ import annotations\nimport re\nimport typing\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom dataclasses import fields\nfrom typing import Any\nfrom typing import Dict\nimport pandas as pd\nfrom typing import Protocol\nfrom typing import TypeVar\n\n\ndef is_valid_aesthetic(value: Any, ae: str) ->bool: [MASK]\n"}
{"method_name": "freedman_diaconis_bins", "full_method_name": "freedman_diaconis_bins", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef freedman_diaconis_bins(a):\n    \"\"\"\n    Calculate number of hist bins using Freedman-Diaconis rule.\n    \"\"\"\n    from scipy.stats import iqr\n    a = np.asarray(a)\n    h = 2 * iqr(a, nan_policy='omit') / len(a) ** (1 / 3)\n    if h == 0:\n        bins = np.ceil(np.sqrt(a.size))\n    else:\n        bins = np.ceil((np.nanmax(a) - np.nanmin(a)) / h)\n    return int(bins)", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\ndef test_freedman_diaconis_bins():\n    a1 = np.arange(1, 98, dtype=float)\n    a2 = np.arange(100, dtype=float)\n    a2[[0, 99]] = np.nan\n    iqr1 = freedman_diaconis_bins(a1)\n    iqr2 = freedman_diaconis_bins(a2)\n    assert iqr1 == iqr2\n\ntest_freedman_diaconis_bins()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_geom_bar_col_histogram.py"}], "instruction": "Functionality: The function calculates the number of histogram bins using the Freedman-Diaconis rule. This rule is a data-based choice for the number of bins in a histogram, which aims to decrease the variability in the binning process.\n\nInputs: \n- a: a numpy array or a list-like object that can be converted to a numpy array. This array contains the data for which the histogram bins are to be determined.\n\nOutputs:\n- int: The function returns an integer representing the number of bins for the histogram, calculated based on the Freedman-Diaconis rule. If the calculated bin width 'h' is 0, then the function returns the square root of the size of the input array, rounded up to the nearest integer.", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef freedman_diaconis_bins(a): [MASK]\n"}
{"method_name": "breaks_from_bins", "full_method_name": "breaks_from_bins", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks\ndef breaks_from_bins(x_range: TupleFloat2, bins: int=30, center: Optional[\n    float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    bins :\n        Number of bins\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if bins < 1:\n        raise PlotnineError('Need at least one bin.')\n    elif bins == 1:\n        binwidth = x_range[1] - x_range[0]\n        boundary = x_range[1]\n    else:\n        binwidth = (x_range[1] - x_range[0]) / (bins - 1)\n    return breaks_from_binwidth(x_range, binwidth, center, boundary)", "test_code_list": [{"test_code": "import numpy as np\ndef test_breaks_from_bins():\n    n = 10\n    x = list(range(n))\n    limits = min(x), max(x)\n    breaks = breaks_from_bins(limits, n)\n    breaks2 = breaks_from_bins(limits, n, center=limits[0])\n    assert len(breaks) - 1 == n\n    assert min(breaks) <= limits[0]\n    assert max(breaks) >= limits[1]\n    assert (breaks[1] + breaks[0]) / 2 == limits[0]\n    assert (breaks[-1] + breaks[-2]) / 2 == limits[1]\n    assert list(breaks) == list(breaks2)\n    breaks = breaks_from_bins(limits, n, boundary=limits[0])\n    assert list(breaks) == x\n\ntest_breaks_from_bins()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_binning.py"}], "instruction": "Functionality: The breaks_from_bins function calculates break points for binning data within a specified range. These breaks are used to define the boundaries of bins for data distribution analysis, such as in histograms. The function supports customizing the number of bins, the center of one of the bins, or a boundary between two bins.\n\nInputs:\n- x_range: A tuple of two floats representing the lower and upper bounds of the range over which to calculate the breaks. It must be of size 2.\n- bins: An optional integer specifying the number of bins. The default value is 30.\n- center: An optional float specifying the center of one of the bins.\n- boundary: An optional float specifying a boundary between two bins.\n\nOutputs:\n- out: An array-like object containing the sequence of break points. These points define the boundaries of the bins within the specified range.", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks\n\n\ndef breaks_from_bins(x_range: TupleFloat2, bins: int=30, center: Optional[\n    float]=None, boundary: Optional[float]=None): [MASK]\n"}
{"method_name": "breaks_from_binwidth", "full_method_name": "breaks_from_binwidth", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks", "test_code_list": [{"test_code": "import numpy as np\ndef test_breaks_from_binwidth():\n    n = 10\n    x = list(range(n))\n    limits = min(x), max(x)\n    breaks = breaks_from_binwidth(limits, binwidth=1)\n    breaks2 = breaks_from_binwidth(limits, binwidth=1, center=limits[0])\n    assert len(breaks) - 1 == n\n    assert min(breaks) <= limits[0]\n    assert max(breaks) >= limits[1]\n    assert (breaks[1] + breaks[0]) / 2 == limits[0]\n    assert (breaks[-1] + breaks[-2]) / 2 == limits[1]\n    assert list(breaks) == list(breaks2)\n\ntest_breaks_from_binwidth()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_binning.py"}], "instruction": "Functionality: The function breaks_from_binwidth calculates a sequence of break points for the specified range, based on a given binwidth. This is useful for creating histograms or binning data in discrete intervals.\n\nInputs:\n- x_range: A tuple of size 2, indicating the range over which to calculate the breaks.\n- binwidth: A positive float representing the separation between the breaks.\n- center: An optional float that specifies the center of one of the bins. Mutually exclusive with 'boundary'.\n- boundary: An optional float that specifies a boundary between two bins. Mutually exclusive with 'center'.\n\nOutputs:\n- out: An array-like sequence of break points that can be used to bin data within the specified range.\n\nRaises:\n- PlotnineError: If the binwidth is not positive or if both 'boundary' and 'center' are specified.", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None): [MASK]\n"}
{"method_name": "_adjust_breaks", "full_method_name": "_adjust_breaks", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef _adjust_breaks(breaks: FloatArray, right: bool) ->FloatArray:\n    epsilon = np.finfo(float).eps\n    plus = 1 + epsilon\n    minus = 1 - epsilon\n    sign = np.sign(breaks)\n    pos_idx = np.where(sign == 1)[0]\n    neg_idx = np.where(sign == -1)[0]\n    zero_idx = np.where(sign == 0)[0]\n    fuzzy = breaks.copy()\n    if right:\n        lbreak = breaks[0]\n        fuzzy[pos_idx] *= plus\n        fuzzy[neg_idx] *= minus\n        fuzzy[zero_idx] = epsilon\n        if lbreak == 0:\n            fuzzy[0] = -epsilon\n        elif lbreak < 0:\n            fuzzy[0] = lbreak * plus\n        else:\n            fuzzy[0] = lbreak * minus\n    else:\n        rbreak = breaks[-1]\n        fuzzy[pos_idx] *= minus\n        fuzzy[neg_idx] *= plus\n        fuzzy[zero_idx] = -epsilon\n        if rbreak == 0:\n            fuzzy[-1] = epsilon\n        elif rbreak > 0:\n            fuzzy[-1] = rbreak * plus\n        else:\n            fuzzy[-1] = rbreak * minus\n    return fuzzy", "test_code_list": [{"test_code": "import numpy as np\ndef test_adjust_breaks_right():\n\n    def _test(a, b):\n        assert b[0] <= a[0]\n        assert all(a[1:] <= b[1:])\n    a = np.linspace(1, 2, 11)\n    b = _adjust_breaks(a, right=True)\n    _test(a, b)\n    a = np.linspace(0, 1, 11)\n    b = _adjust_breaks(a, right=True)\n    _test(a, b)\n    a = np.linspace(-1, 0, 11)\n    b = _adjust_breaks(a, right=True)\n    _test(a, b)\n    a = np.linspace(-2, -1, 11)\n    b = _adjust_breaks(a, right=True)\n    _test(a, b)\n\ntest_adjust_breaks_right()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_binning.py"}, {"test_code": "import numpy as np\ndef test_adjust_breaks_right_False():\n\n    def _test(a, b):\n        assert a[-1] <= b[-1]\n        assert all(b[:-1] <= a[:-1])\n    a = np.linspace(1, 2, 11)\n    b = _adjust_breaks(a, right=False)\n    _test(a, b)\n    a = np.linspace(0, 1, 11)\n    b = _adjust_breaks(a, right=False)\n    _test(a, b)\n    a = np.linspace(-1, 0, 11)\n    b = _adjust_breaks(a, right=False)\n    _test(a, b)\n    a = np.linspace(-2, -1, 11)\n    b = _adjust_breaks(a, right=False)\n    _test(a, b)\n\ntest_adjust_breaks_right_False()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotnine/tests/test_binning.py"}], "instruction": "Functionality: The _adjust_breaks function modifies the input array 'breaks' by applying an epsilon adjustment to ensure that the breaks are either just above or just below the original values, depending on the 'right' parameter. This is particularly useful in histogram binning or similar applications where the boundaries of intervals need to be precisely controlled.\n\nInputs:\n- breaks: A 1D numpy array of float values representing the original breaks. These breaks are the boundaries of intervals, and the function will adjust them slightly to avoid boundary issues when comparing values to these breaks.\n- right: A boolean value indicating whether the interval includes the right boundary. If right is True, the function adjusts the breaks to ensure that values equal to the breaks will fall into the interval to the right. If right is False, the adjustment ensures values equal to the breaks will fall into the interval to the left.\n\nOutputs:\n- A 1D numpy array of float values representing the adjusted breaks. The output array will have the same shape as the input 'breaks', but its values will be slightly altered to ensure proper interval boundaries according to the 'right' parameter.", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef _adjust_breaks(breaks: FloatArray, right: bool) ->FloatArray: [MASK]\n"}
