{"method_name": "_prepare_video", "full_method_name": "_prepare_video", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/utils.py", "method_code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\ndef _prepare_video(V):\n    import numpy as np\n    b, t, c, h, w = V.shape\n    if V.dtype == np.uint8:\n        V = np.float32(V) / 255.0\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n    if not is_power2(V.shape[0]):\n        len_addition = int(2 ** V.shape[0].bit_length() - V.shape[0])\n        V = np.concatenate((V, np.zeros(shape=(len_addition, t, c, h, w))),\n            axis=0)\n    n_rows = 2 ** ((b.bit_length() - 1) // 2)\n    n_cols = V.shape[0] // n_rows\n    V = np.reshape(V, newshape=(n_rows, n_cols, t, c, h, w))\n    V = np.transpose(V, axes=(2, 0, 4, 1, 5, 3))\n    V = np.reshape(V, newshape=(t, n_rows * h, n_cols * w, c))\n    return V", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport unittest\n\nclass UtilsTest(unittest.TestCase):\n    def test_prepare_video(self):\n        np.random.seed(1)\n        V_before = np.random.random((4, 10, 3, 20, 20))\n        V_after = _prepare_video(np.copy(V_before))\n        V_before = np.swapaxes(V_before, 0, 1)\n        V_before = np.reshape(V_before, newshape=(10, -1))\n        V_after = np.reshape(V_after, newshape=(10, -1))\n        np.testing.assert_array_almost_equal(np.sum(V_before, axis=1), np.sum(\n            V_after, axis=1))\n    \nUtilsTest().test_prepare_video()\n", "code_start": "", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_utils.py"}], "instruction": "Functionality: The _prepare_video function is designed to preprocess a given 5D NumPy array representing a batch of video frames. It normalizes the pixel values to the [0, 1] range if the array is of type np.uint8. It then pads the batch to the nearest power of 2 in length, reshapes the video frames for visualization, and rearranges the axes to prepare for video generation. The function ensures that the video data is in a suitable format for further processing or visualization.\n\nInputs: \nV: A 5D numpy array of shape (batch_size, time, channels, height, width) representing a batch of video frames. The dtype of V can be either np.float32 or np.uint8.\n\nOutputs: \nA 4D numpy array of shape (time, n_rows * height, n_cols * width, channels). This array represents the preprocessed video data, where frames have been normalized and rearranged for visualization or further processing. The frames are tiled in a grid layout with n_rows rows and n_cols columns.", "method_code_mask": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\n\n\ndef _prepare_video(V): [MASK]\n"}
{"method_name": "make_np", "full_method_name": "make_np", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/x2num.py", "method_code": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\ndef make_np(x):\n    if isinstance(x, list):\n        return check_nan(np.array(x))\n    if isinstance(x, np.ndarray):\n        return check_nan(x)\n    if isinstance(x, str):\n        return check_nan(prepare_caffe2(x))\n    if np.isscalar(x):\n        return check_nan(np.array([x]))\n    if 'torch' in str(type(x)):\n        return check_nan(prepare_pytorch(x))\n    if 'chainer' in str(type(x)):\n        return check_nan(prepare_chainer(x))\n    if 'mxnet' in str(type(x)):\n        return check_nan(prepare_mxnet(x))\n    if 'jax' in str(type(x)):\n        return check_nan(np.array(x))\n    raise NotImplementedError(\n        'Got {}, but expected numpy array or torch tensor.'.format(type(x)))", "test_code_list": [{"test_code": "import torch\nimport numpy as np\nimport unittest\n\nclass PyTorchNumpyTest(unittest.TestCase):\n    def test_pytorch_np(self):\n        tensors = [torch.rand(3, 10, 10), torch.rand(1), torch.rand(1, 2, 3, 4, 5)]\n        for tensor in tensors:\n            assert isinstance(make_np(tensor), np.ndarray)\n            if torch.cuda.device_count() > 0:\n                assert isinstance(make_np(tensor.cuda()), np.ndarray)\n            assert isinstance(make_np(torch.autograd.Variable(tensor)),\n                np.ndarray)\n            if torch.cuda.device_count() > 0:\n                assert isinstance(make_np(torch.autograd.Variable(tensor)\n                    .cuda()), np.ndarray)\n        assert isinstance(make_np(0), np.ndarray)\n        assert isinstance(make_np(0.1), np.ndarray)\n    \nPyTorchNumpyTest().test_pytorch_np()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_pytorch_np.py"}, {"test_code": "import numpy as np\nimport unittest\n\nclass NumpyTest(unittest.TestCase):\n    def test_scalar(self):\n        res = make_np(1.1)\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(1 << 64 - 1)\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(np.float16(1.00000087))\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        if hasattr(np, 'float128'):\n            res = make_np(np.float128(1.00008 + 9))\n            assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(np.int64(100000000000))\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n    \nNumpyTest().test_scalar()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_numpy.py"}], "instruction": "Functionality: The make_np function is designed to convert various data types including lists, numpy arrays, strings representing paths to Caffe2 tensors, scalars, PyTorch tensors, Chainer tensors, MXNet tensors, and JAX arrays into numpy arrays. It also checks for NaN (Not a Number) or infinite values in the resulting numpy array and logs a warning if any are found.\nInputs: \n    x: The input data which can be any of the following types:\n        - list: A list of numerical values.\n        - np.ndarray: A numpy array.\n        - str: A string representing the path to a Caffe2 tensor.\n        - scalar: Any scalar value.\n        - 'torch' in str(type(x)): Any PyTorch tensor, autograd.Variable, or tensor data.\n        - 'chainer' in str(type(x)): Any Chainer tensor.\n        - 'mxnet' in str(type(x)): Any MXNet tensor.\n        - 'jax' in str(type(x)): Any JAX array.\nOutputs:\n    array: A numpy array conversion of the input 'x', with a warning logged if the array contains NaN or infinite values.", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\n\n\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\n\n\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\n\n\ndef make_np(x): [MASK]\n"}
{"method_name": "make_valid_tf_name", "full_method_name": "make_valid_tf_name", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/record_writer.py", "method_code": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\ndef make_valid_tf_name(name):\n    if not _VALID_OP_NAME_START.match(name):\n        name = '.' + name\n    return '_'.join(_VALID_OP_NAME_PART.findall(name))", "test_code_list": [{"test_code": "import unittest\nimport os\nimport boto3\nimport shutil\n\nclass RecordWriterTest(unittest.TestCase):\n    def test_make_valid_tf_name(self):\n        newname = make_valid_tf_name('$ave/&sound')\n        assert newname == '._ave/_sound'\n    \nRecordWriterTest().test_make_valid_tf_name()\n", "code_start": "", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_record_writer.py"}], "instruction": "Functionality: This function is designed to take a given name and format it to meet the naming conventions required for TensorFlow operations. It ensures that the operation name starts with an alphanumeric character or a dot and that the rest of the name consists of alphanumeric characters, underscores, periods, slashes, or hyphens. Any characters that do not match these criteria will be replaced or removed.\n\nInputs: \n    name (str): The original name of the operation that needs to be formatted to be a valid TensorFlow operation name.\n\nOutputs: \n    str: A formatted string that represents a valid TensorFlow operation name, adhering to the naming conventions specified by TensorFlow. This output can be directly used to name operations within TensorFlow without causing any syntax errors.", "method_code_mask": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\n\n\ndef make_valid_tf_name(name): [MASK]\n"}
