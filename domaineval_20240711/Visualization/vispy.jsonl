{"method_name": "requires_application", "full_method_name": "requires_application", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_application(backend=None, has=(), capable=(), force_gc=True):\n    \"\"\"Return a decorator for tests that require an application\"\"\"\n    good, msg = has_application(backend, has, capable)\n    dec_backend = skipif(not good, reason='Skipping test: %s' % msg)\n    try:\n        import pytest\n    except Exception:\n        return dec_backend\n    dec_app = pytest.mark.vispy_app_test\n    funcs = [dec_app, dec_backend]\n    if force_gc:\n        funcs.append(garbage_collect)\n    return composed(*funcs)", "test_code_list": [{"test_code": "import sys\nimport numpy as np\nfrom numpy.testing import assert_allclose\nimport pytest\nfrom vispy.app import Canvas\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import Texture3D\nfrom vispy.gloo import Program\nfrom vispy.gloo import FrameBuffer\nfrom vispy.gloo import RenderBuffer\nfrom vispy.gloo import set_viewport\nfrom vispy.gloo import clear\nfrom vispy.gloo.util import draw_texture\nfrom vispy.gloo.util import _screenshot\nfrom vispy.testing import requires_application\nfrom vispy.testing import has_pyopengl\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_equal\nfrom vispy.testing import IS_TRAVIS_CI\n@requires_application()\ndef test_use_textures():\n    \"\"\"Test using textures and FBO\"\"\"\n    assert_raises(ValueError, Texture2D, np.zeros((2, 2, 3), np.float32),\n        format='rgba')\n\ntest_use_textures()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_use_gloo.py"}, {"test_code": "import vispy.app\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_equal\nfrom vispy.testing import assert_not_equal\n@requires_application('pyside')\ndef test_use():\n    vispy.app.use_app()\n    default_app = vispy.app._default_app.default_app\n    vispy.app._default_app.default_app = None\n    app_name = default_app.backend_name.split(' ')[0]\n    try:\n        assert_raises(TypeError, vispy.use)\n        assert_equal(vispy.app._default_app.default_app, None)\n        vispy.use(gl='gl2')\n        assert_equal(vispy.app._default_app.default_app, None)\n        vispy.use(app_name)\n        assert_not_equal(vispy.app._default_app.default_app, None)\n        wrong_name = 'glfw' if app_name.lower() != 'glfw' else 'pyqt4'\n        assert_raises(RuntimeError, vispy.use, wrong_name)\n        vispy.use(app_name, 'gl2')\n    finally:\n        vispy.app._default_app.default_app = default_app\n\ntest_use()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/util/tests/test_vispy.py"}], "instruction": "Functionality: The requires_application function is a decorator that is used to mark tests that require an application to run. It checks if certain conditions are met for the application to run, such as required backend, capabilities, and whether garbage collection should be forced.\n\nInputs: \n- backend (optional): A string specifying the required backend. If not provided, the default backend will be used.\n- has (optional): A tuple of strings representing the required features or modules that should be present for the test to run.\n- capable (optional): A tuple of strings representing the capabilities that the application should have.\n- force_gc (optional): A boolean value indicating whether to force garbage collection before the test runs. Default value is True.\n\nOutputs:\n- A decorator function that can be applied to test functions. The decorator will skip the test if the conditions specified in the inputs are not met. The skip message will include a reason for the skipping of the test.", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_application(backend=None, has=(), capable=(), force_gc=True): [M\n    ASK]\n"}
{"method_name": "requires_pyopengl", "full_method_name": "requires_pyopengl", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_pyopengl():\n    skip = not has_pyopengl()\n    return skipif(skip, reason='Requires PyOpenGL')", "test_code_list": [{"test_code": "import unittest\nimport numpy as np\nimport pytest\nfrom vispy.gloo import Texture1D\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import Texture3D\nfrom vispy.gloo import TextureAtlas\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\n@requires_pyopengl()\ndef test_texture_1D():\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert T._shape == (10, 1)\n    assert 'Texture1D' in repr(T)\n    assert T.glsl_type == ('uniform', 'sampler1D')\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert T.width == 10\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    T.resize((5,))\n    assert T.shape == (5, 1)\n    glir_cmd = T._glir.clear()[-1]\n    assert glir_cmd[0] == 'SIZE'\n    assert glir_cmd[2] == (5, 1)\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert_raises(ValueError, T.resize, (5, 5, 5, 5))\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data, resizable=False)\n    assert_raises(RuntimeError, T.resize, (5,))\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    T.set_data(np.ones((20,), np.uint8))\n    assert T.shape == (20, 1)\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    T.set_data(np.ones((5,), np.uint8))\n    assert T.shape == (5, 1)\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert_raises(ValueError, T.set_data, np.ones((5,)), offset=(8,))\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert_raises(ValueError, T.set_data, np.ones((10, 10)))\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    T.set_data(np.ones((10,), np.uint8))\n    assert T.shape == (10, 1)\n    glir_cmd = T._glir.clear()[-1]\n    assert glir_cmd[0] == 'DATA'\n    shape1 = 10,\n    shape3 = 10, 3\n    data = np.zeros((10, 1), dtype=np.uint8)\n    T = Texture1D(data=data)\n    assert T.shape == (10, 1)\n    assert T._format == 'luminance'\n    T.set_data(np.zeros(shape3, np.uint8))\n    assert T.shape == (10, 3)\n    assert T._format == 'rgb'\n    T.set_data(np.zeros(shape1, np.uint8))\n    assert T.shape == (10, 1)\n    assert T._format == 'luminance'\n    T.resize(shape3)\n    assert T.shape == (10, 3)\n    assert T._format == 'rgb'\n    T.resize(shape1)\n    assert T.shape == (10, 1)\n    assert T._format == 'luminance'\n    data = np.zeros((10,), dtype=np.uint8)\n    T = Texture1D(data=data)\n    data = np.zeros((10,), dtype=np.float32)\n    T.set_data(data)\n    data = np.zeros((12,), dtype=np.int32)\n    T.set_data(data)\n\ntest_texture_1D()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_texture.py"}, {"test_code": "import unittest\nimport numpy as np\nimport pytest\nfrom vispy.gloo import Texture1D\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import Texture3D\nfrom vispy.gloo import TextureAtlas\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\n@requires_pyopengl()\ndef test_texture_3D():\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert T._shape == (10, 10, 10, 1)\n    assert 'Texture3D' in repr(T)\n    assert T.glsl_type == ('uniform', 'sampler3D')\n    data = np.zeros((10, 20, 30), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert T.width == 30\n    assert T.height == 20\n    assert T.depth == 10\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    T.resize((5, 5, 5))\n    assert T.shape == (5, 5, 5, 1)\n    glir_cmd = T._glir.clear()[-1]\n    assert glir_cmd[0] == 'SIZE'\n    assert glir_cmd[2] == (5, 5, 5, 1)\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert_raises(ValueError, T.resize, (5, 5, 5, 5))\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data, resizable=False)\n    assert_raises(RuntimeError, T.resize, (5, 5, 5))\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    T.set_data(np.ones((20, 20, 20), np.uint8))\n    assert T.shape == (20, 20, 20, 1)\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    T.set_data(np.ones((5, 5, 5), np.uint8))\n    assert T.shape == (5, 5, 5, 1)\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert_raises(ValueError, T.set_data, np.ones((5, 5, 5)), offset=(8, 8, 8))\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert_raises(ValueError, T.set_data, np.ones((10,)))\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    T.set_data(np.ones((10, 10, 10), np.uint8))\n    assert T.shape == (10, 10, 10, 1)\n    glir_cmd = T._glir.clear()[-1]\n    assert glir_cmd[0] == 'DATA'\n    shape1 = 10, 10, 10\n    shape3 = 10, 10, 10, 3\n    data = np.zeros((10, 10, 10, 1), dtype=np.uint8)\n    T = Texture3D(data=data)\n    assert T.shape == (10, 10, 10, 1)\n    assert T._format == 'luminance'\n    T.set_data(np.zeros(shape3, np.uint8))\n    assert T.shape == (10, 10, 10, 3)\n    assert T._format == 'rgb'\n    T.set_data(np.zeros(shape1, np.uint8))\n    assert T.shape == (10, 10, 10, 1)\n    assert T._format == 'luminance'\n    T.resize(shape3)\n    assert T.shape == (10, 10, 10, 3)\n    assert T._format == 'rgb'\n    T.resize(shape1)\n    assert T.shape == (10, 10, 10, 1)\n    assert T._format == 'luminance'\n    data = np.zeros((10, 10, 10), dtype=np.uint8)\n    T = Texture3D(data=data)\n    data = np.zeros((10, 11, 11), dtype=np.float32)\n    T.set_data(data)\n    data = np.zeros((12, 12, 10), dtype=np.int32)\n    T.set_data(data)\n\ntest_texture_3D()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_texture.py"}, {"test_code": "import numpy as np\nfrom vispy import scene\nfrom vispy.color import Color\nfrom vispy.geometry import create_cube\nfrom vispy.geometry import create_sphere\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.visuals.filters import ShadingFilter\nfrom vispy.visuals.filters import WireframeFilter\nfrom vispy.visuals.filters.mesh import _as_rgba\nimport pytest\nfrom vispy.visuals.transforms import STTransform\n@requires_pyopengl()\ndef test_mesh_color():\n    vertices, filled_indices, outline_indices = create_cube()\n    axis = scene.visuals.Mesh(vertices['position'], outline_indices, color=\n        'black', mode='lines')\n    axis.color = 0.1, 0.3, 0.7, 0.9\n    new_vertices = axis.mesh_data.get_vertices()\n    np.testing.assert_allclose(axis.color.rgba, (0.1, 0.3, 0.7, 0.9))\n    np.testing.assert_allclose(vertices['position'], new_vertices)\n\ntest_mesh_color()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_mesh.py"}, {"test_code": "import numpy as np\nfrom vispy import scene\nfrom vispy.color import Color\nfrom vispy.geometry import create_cube\nfrom vispy.geometry import create_sphere\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.visuals.filters import ShadingFilter\nfrom vispy.visuals.filters import WireframeFilter\nfrom vispy.visuals.filters.mesh import _as_rgba\nimport pytest\nfrom vispy.visuals.transforms import STTransform\n@requires_pyopengl()\ndef test_mesh_bounds():\n    vertices, filled_indices, outline_indices = create_cube()\n    axis = scene.visuals.Mesh(vertices['position'], outline_indices, color=\n        'black', mode='lines')\n    for i in range(3):\n        np.testing.assert_allclose(axis.bounds(i), (-1.0, 1.0))\n    axis = scene.visuals.Mesh(vertices['position'][:, :2], outline_indices,\n        color='black', mode='lines')\n    for i in range(2):\n        np.testing.assert_allclose(axis.bounds(i), (-1.0, 1.0))\n    np.testing.assert_allclose(axis.bounds(2), (0.0, 0.0))\n\ntest_mesh_bounds()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_mesh.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom vispy import scene\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import raises\nfrom vispy.testing.image_tester import assert_image_approved\nfrom vispy.testing.image_tester import downsample\nfrom vispy.testing.rendered_array_tester import compare_render\nfrom vispy.testing.rendered_array_tester import max_for_dtype\n@requires_pyopengl()\ndef test_volume():\n    vol = np.zeros((20, 20, 20), 'float32')\n    vol[8:16, 8:16, :] = 1.0\n    V = scene.visuals.Volume(vol)\n    assert V.clim == (0, 1)\n    assert V.method == 'mip'\n    assert V.interpolation == 'linear'\n    with raises(ValueError):\n        V.set_data(np.zeros((20, 20), 'float32'))\n    V.set_data(vol, (0.5, 0.8))\n    assert V.clim == (0.5, 0.8)\n    with raises(ValueError):\n        V.set_data((0.5, 0.8, 1.0))\n    V.method = 'iso'\n    assert V.method == 'iso'\n    V.interpolation = 'nearest'\n    assert V.interpolation == 'nearest'\n    V.relative_step_size = 1.1\n    assert V.relative_step_size == 1.1\n    with raises(ValueError):\n        V.relative_step_size = 0\n\ntest_volume()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_volume.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom vispy import scene\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import raises\nfrom vispy.testing.image_tester import assert_image_approved\nfrom vispy.testing.image_tester import downsample\nfrom vispy.testing.rendered_array_tester import compare_render\nfrom vispy.testing.rendered_array_tester import max_for_dtype\n@requires_pyopengl()\ndef test_volume_bounds():\n    vol = np.zeros((20, 30, 40), 'float32')\n    vol[8:16, 8:16, :] = 1.0\n    V = scene.visuals.Volume(vol)\n    assert V._compute_bounds(0, V) == (0, 40)\n    assert V._compute_bounds(1, V) == (0, 30)\n    assert V._compute_bounds(2, V) == (0, 20)\n\ntest_volume_bounds()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_volume.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom vispy import scene\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import raises\nfrom vispy.testing.image_tester import assert_image_approved\nfrom vispy.testing.image_tester import downsample\nfrom vispy.testing.rendered_array_tester import compare_render\nfrom vispy.testing.rendered_array_tester import max_for_dtype\n@requires_pyopengl()\ndef test_set_data_does_not_change_input():\n    V = scene.visuals.Volume(np.zeros((20, 20, 20), dtype=np.float32))\n    vol = np.random.randint(0, 200, (20, 20, 20))\n    for dtype in ['uint8', 'int16', 'uint16', 'float32', 'float64']:\n        vol_copy = np.array(vol, dtype=dtype, copy=True)\n        V.set_data(vol_copy, clim=(0, 200))\n        assert np.allclose(vol, vol_copy)\n    vol2 = np.array(vol, dtype=np.float32, copy=True)\n    assert np.allclose(vol, vol2)\n    V.set_data(vol2, clim=(0, 200), copy=False)\n    assert np.allclose(vol, vol2)\n\ntest_set_data_does_not_change_input()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_volume.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom vispy import scene\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import raises\nfrom vispy.testing.image_tester import assert_image_approved\nfrom vispy.testing.image_tester import downsample\nfrom vispy.testing.rendered_array_tester import compare_render\nfrom vispy.testing.rendered_array_tester import max_for_dtype\n@requires_pyopengl()\ndef test_set_data_changes_shape():\n    dtype = np.float32\n    V = scene.visuals.Volume(np.zeros((20, 20, 20), dtype=dtype))\n    vol = np.zeros((25, 25, 10), dtype=dtype)\n    V.set_data(vol)\n    assert V._vol_shape == (25, 25, 10)\n    vol2 = np.zeros((20, 20), dtype=dtype)\n    with pytest.raises(ValueError):\n        V.set_data(vol2)\n    vol2 = np.zeros((20, 20, 20, 20), dtype=dtype)\n    with pytest.raises(ValueError):\n        V.set_data(vol2)\n\ntest_set_data_changes_shape()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_volume.py"}], "instruction": "Functionality: The requires_pyopengl function is designed to determine whether the current environment has PyOpenGL installed. PyOpenGL is a library that allows Python programmers to use OpenGL, a powerful cross-language, cross-platform API for writing applications that produce 2D and 3D computer graphics. This function is typically used as a decorator to conditionally skip tests or functions that require PyOpenGL if the library is not available.\n\nInputs: There are no input arguments required for this function. It interacts with the environment to check for the presence of the PyOpenGL library.\n\nOutputs: The function returns a decorator that, when applied to a test or function, will either allow the test or function to proceed if PyOpenGL is available or skip it with a message if PyOpenGL is not present. The decorator uses the skipif function from pytest, which takes a boolean condition (in this case, the negation of the result of has_pyopengl()) and a reason for skipping if the condition is True.", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_pyopengl(): [MASK]\n"}
{"method_name": "convert_shader", "full_method_name": "convert_shader", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/glir.py", "method_code": "import os\nimport sys\nimport re\nimport json\nimport weakref\nfrom packaging.version import Version\nimport numpy as np\ndef _convert_es2_shader(shader):\n    has_version = False\n    has_prec_float = False\n    has_prec_int = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        if line_strip.startswith('#version'):\n            continue\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        if line_strip.startswith('precision '):\n            has_prec_float = has_prec_float or 'float' in line\n            has_prec_int = has_prec_int or 'int' in line\n        lines.append(line.rstrip())\n    if not has_prec_float:\n        lines.insert(has_version, 'precision highp float;')\n    if not has_prec_int:\n        lines.insert(has_version, 'precision highp int;')\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    return '\\n'.join(lines)\ndef _convert_desktop_shader(shader):\n    has_version = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        has_version = has_version or line.startswith('#version')\n        if line_strip.startswith('precision '):\n            line = ''\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        for prec in (' highp ', ' mediump ', ' lowp '):\n            line = line.replace(prec, ' ')\n        lines.append(line.rstrip())\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    if not has_version:\n        lines.insert(0, '#version 120\\n')\n    return '\\n'.join(lines)\ndef convert_shader(backend_type, shader):\n    \"\"\"Modify shader code to be compatible with `backend_type` backend.\"\"\"\n    if backend_type == 'es2':\n        return _convert_es2_shader(shader)\n    elif backend_type == 'desktop':\n        return _convert_desktop_shader(shader)\n    else:\n        raise ValueError('Cannot backend_type shaders to %r.' % backend_type)", "test_code_list": [{"test_code": "import json\nimport tempfile\nfrom unittest import mock\nfrom vispy import config\nfrom vispy.app import Canvas\nfrom vispy.gloo import glir\nfrom vispy.testing import requires_application\nfrom vispy.testing import requires_pyopengl\nfrom vispy.testing import run_tests_if_main\nimport numpy as np\ndef test_queue():\n    q = glir.GlirQueue()\n    parser = glir.GlirParser()\n    N = 5\n    for i in range(N):\n        q.command('FOO', 'BAR', i)\n    cmds = q.clear()\n    for i in range(N):\n        assert cmds[i] == ('FOO', 'BAR', i)\n    cmds1 = [('DATA', 1), ('SIZE', 1), ('FOO', 1), ('SIZE', 1), ('FOO', 1),\n        ('DATA', 1), ('DATA', 1)]\n    cmds2 = [c[0] for c in q._shared._filter(cmds1, parser)]\n    assert cmds2 == ['FOO', 'SIZE', 'FOO', 'DATA', 'DATA']\n    cmds1 = [('DATA', 1), ('SIZE', 1), ('FOO', 1), ('SIZE', 2), ('SIZE', 2),\n        ('DATA', 2), ('SIZE', 1), ('FOO', 1), ('DATA', 1), ('DATA', 1)]\n    cmds2 = q._shared._filter(cmds1, parser)\n    assert cmds2 == [('FOO', 1), ('SIZE', 2), ('DATA', 2), ('SIZE', 1), (\n        'FOO', 1), ('DATA', 1), ('DATA', 1)]\n    shader1 = (\n        \"\"\"\n        precision highp float;uniform mediump vec4 u_foo;uniform vec4 u_bar;\n        \"\"\"\n        .strip().replace(';', ';\\n'))\n    shader2 = convert_shader('desktop', shader1)\n    assert 'highp' not in shader2\n    assert 'mediump' not in shader2\n    assert 'precision' not in shader2\n    shader3 = convert_shader('es2', shader2)\n    assert 'precision highp float;' in shader3\n    assert shader3.startswith('precision')\n    shader4 = (\n        \"\"\"\n        #version 100; precision highp float;uniform mediump vec4 u_foo;uniform vec4 u_bar;\n        \"\"\"\n        .strip().replace(';', ';\\n'))\n    shader5 = convert_shader('es2', shader4)\n    assert 'precision highp float;' in shader5\n    assert shader3.startswith('precision')\n\ntest_queue()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_glir.py"}], "instruction": "Functionality: The convert_shader function modifies shader code to make it compatible with a specified graphics backend. It supports two types of backends: 'es2' (OpenGL ES 2.0) and 'desktop' (OpenGL desktop). For 'es2', it ensures the shader has the required precision qualifiers for float and int, and includes necessary extensions. For 'desktop', it removes precision qualifiers and ensures a version is specified.\n\nInputs:\n- backend_type: A string indicating the target backend ('es2' or 'desktop').\n- shader: A string containing the shader code that needs to be converted.\n\nOutputs:\n- A string containing the modified shader code that is compatible with the specified backend.", "method_code_mask": "import os\nimport sys\nimport re\nimport json\nimport weakref\nfrom packaging.version import Version\nimport numpy as np\n\n\ndef _convert_es2_shader(shader):\n    has_version = False\n    has_prec_float = False\n    has_prec_int = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        if line_strip.startswith('#version'):\n            continue\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        if line_strip.startswith('precision '):\n            has_prec_float = has_prec_float or 'float' in line\n            has_prec_int = has_prec_int or 'int' in line\n        lines.append(line.rstrip())\n    if not has_prec_float:\n        lines.insert(has_version, 'precision highp float;')\n    if not has_prec_int:\n        lines.insert(has_version, 'precision highp int;')\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    return '\\n'.join(lines)\n\n\ndef _convert_desktop_shader(shader):\n    has_version = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        has_version = has_version or line.startswith('#version')\n        if line_strip.startswith('precision '):\n            line = ''\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        for prec in (' highp ', ' mediump ', ' lowp '):\n            line = line.replace(prec, ' ')\n        lines.append(line.rstrip())\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    if not has_version:\n        lines.insert(0, '#version 120\\n')\n    return '\\n'.join(lines)\n\n\ndef convert_shader(backend_type, shader): [MASK]\n"}
{"method_name": "set_current_canvas", "full_method_name": "set_current_canvas", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/context.py", "method_code": "from copy import deepcopy\nimport weakref\ndef set_current_canvas(canvas):\n    \"\"\"Make a canvas active. Used primarily by the canvas itself.\"\"\"\n    canvas.context._do_CURRENT_command = True\n    if canvasses and canvasses[-1]() is canvas:\n        return\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    cc.append(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]", "test_code_list": [{"test_code": "import unittest\nimport numpy as np\nfrom vispy import gloo\nfrom vispy import app\nfrom vispy.gloo.program import Program\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_application\nfrom vispy.gloo.context import set_current_canvas\nfrom vispy.gloo.context import forget_canvas\nfrom vispy.gloo.program import VertexShader\nfrom vispy.gloo.program import FragmentShader\nfrom vispy.gloo import VertexBuffer\nclass DummyParser(gloo.glir.BaseGlirParser):\n\n    @property\n    def shader_compatibility(self):\n        return 'desktop'\n\n    def parse(self, commands):\n        pass\nclass DummyCanvas:\n    def __init__(self):\n        self.context = gloo.context.GLContext()\n        self.context.shared.parser = DummyParser()\n        self.context.glir.flush = lambda *args: None\nclass ProgramTest(unittest.TestCase):\n    def test_draw(self):\n        program = Program('attribute float A;', 'uniform float foo')\n        program['A'] = np.zeros((10,), np.float32)\n        dummy_canvas = DummyCanvas()\n        glir = dummy_canvas.context.glir\n        set_current_canvas(dummy_canvas)\n        try:\n            program.draw('triangles')\n            glir_cmd = glir.clear()[-1]\n            assert glir_cmd[0] == 'DRAW'\n            assert len(glir_cmd[-2]) == 2\n            indices = gloo.IndexBuffer(np.zeros(10, dtype=np.uint8))\n            program.draw('triangles', indices)\n            glir_cmd = glir.clear()[-1]\n            assert glir_cmd[0] == 'DRAW'\n            assert len(glir_cmd[-2]) == 3\n            self.assertRaises(ValueError, program.draw, 'nogeometricshape')\n            self.assertRaises(TypeError, program.draw, 'triangles', 'notindex')\n            program = Program('attribute float A;', 'uniform float foo')\n            self.assertRaises(RuntimeError, program.draw, 'triangles')\n            program = Program('attribute float A; attribute float B;', 'foo')\n            program['A'] = np.zeros((10,), np.float32)\n            program['B'] = np.zeros((11,), np.float32)\n            self.assertRaises(RuntimeError, program.draw, 'triangles')\n        finally:\n            forget_canvas(dummy_canvas)\nProgramTest().test_draw()", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_program.py"}], "instruction": "Functionality: The set_current_canvas function is designed to make a given canvas active within a set of canvases managed by the application. This is primarily used by the canvas itself when it wants to become the active canvas for rendering or interaction.\n\nInputs: \n- canvas: A canvas object which needs to be set as the current active canvas. This is the main input argument that the function requires.\n\nOutputs: \n- The function does not return any value explicitly. Its effect is to update the state of the canvases managed by the application, making the specified canvas the active one. The function updates the internal list of canvases to reflect the new active canvas and ensures that any previous instance of the same canvas in the list is moved to the end, effectively setting it as the current canvas.", "method_code_mask": "from copy import deepcopy\nimport weakref\n\n\ndef set_current_canvas(canvas): [MASK]\n"}
{"method_name": "forget_canvas", "full_method_name": "forget_canvas", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/context.py", "method_code": "from copy import deepcopy\nimport weakref\ndef forget_canvas(canvas):\n    \"\"\"Forget about the given canvas. Used by the canvas when closed.\"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]", "test_code_list": [{"test_code": "import unittest\nimport numpy as np\nfrom vispy import gloo\nfrom vispy import app\nfrom vispy.gloo.program import Program\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_application\nfrom vispy.gloo.context import set_current_canvas\nfrom vispy.gloo.context import forget_canvas\nfrom vispy.gloo.program import VertexShader\nfrom vispy.gloo.program import FragmentShader\nfrom vispy.gloo import VertexBuffer\nclass DummyParser(gloo.glir.BaseGlirParser):\n\n    @property\n    def shader_compatibility(self):\n        return 'desktop'\n\n    def parse(self, commands):\n        pass\nclass DummyCanvas:\n    def __init__(self):\n        self.context = gloo.context.GLContext()\n        self.context.shared.parser = DummyParser()\n        self.context.glir.flush = lambda *args: None\nclass ProgramTest(unittest.TestCase):\n    def test_draw(self):\n        program = Program('attribute float A;', 'uniform float foo')\n        program['A'] = np.zeros((10,), np.float32)\n        dummy_canvas = DummyCanvas()\n        glir = dummy_canvas.context.glir\n        set_current_canvas(dummy_canvas)\n        try:\n            program.draw('triangles')\n            glir_cmd = glir.clear()[-1]\n            assert glir_cmd[0] == 'DRAW'\n            assert len(glir_cmd[-2]) == 2\n            indices = gloo.IndexBuffer(np.zeros(10, dtype=np.uint8))\n            program.draw('triangles', indices)\n            glir_cmd = glir.clear()[-1]\n            assert glir_cmd[0] == 'DRAW'\n            assert len(glir_cmd[-2]) == 3\n            self.assertRaises(ValueError, program.draw, 'nogeometricshape')\n            self.assertRaises(TypeError, program.draw, 'triangles', 'notindex')\n            program = Program('attribute float A;', 'uniform float foo')\n            self.assertRaises(RuntimeError, program.draw, 'triangles')\n            program = Program('attribute float A; attribute float B;', 'foo')\n            program['A'] = np.zeros((10,), np.float32)\n            program['B'] = np.zeros((11,), np.float32)\n            self.assertRaises(RuntimeError, program.draw, 'triangles')\n        finally:\n            forget_canvas(dummy_canvas)\nProgramTest().test_draw()", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_program.py"}], "instruction": "Functionality: The function \"forget_canvas\" is designed to clean up references to a specific canvas object that is no longer needed, typically when a canvas is closed. This is achieved by iterating over a list of canvas references, removing any references to the specified canvas, and then updating the list with the new set of references. The function utilizes weak references to allow for automatic garbage collection of unused canvases.\n\nInputs: \n- canvas: A reference to the canvas object that needs to be removed from the list of canvases. This is the only input argument to the function.\n\nOutputs:\n- None: The function does not return any value. Its purpose is to modify the list of canvas references in place, removing any references to the specified canvas and ensuring that the list is updated to reflect the current state of canvas objects.", "method_code_mask": "from copy import deepcopy\nimport weakref\n\n\ndef forget_canvas(canvas): [MASK]\n"}
{"method_name": "check_enum", "full_method_name": "check_enum", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code": "\ndef check_enum(enum, name=None, valid=None):\n    \"\"\"Get lowercase string representation of enum.\"\"\"\n    name = name or 'enum'\n    res = None\n    if isinstance(enum, int):\n        if hasattr(enum, 'name') and enum.name.startswith('GL_'):\n            res = enum.name[3:].lower()\n    elif isinstance(enum, str):\n        res = enum.lower()\n    if res is None:\n        raise ValueError(\n            'Could not determine string representation forenum %r' % enum)\n    elif valid and res not in valid:\n        raise ValueError('Value of %s must be one of %r, not %r' % (name,\n            valid, enum))\n    return res", "test_code_list": [{"test_code": "from vispy.gloo import util\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\nfrom vispy.gloo import gl\ndef test_check_enum():\n    from vispy.gloo import gl\n    assert check_enum(gl.GL_RGB) == 'rgb'\n    assert check_enum(gl.GL_TRIANGLE_STRIP) == 'triangle_strip'\n    assert check_enum('RGB') == 'rgb'\n    assert check_enum('Triangle_STRIp') == 'triangle_strip'\n    assert_raises(ValueError, check_enum, int(gl.GL_RGB))\n    assert_raises(ValueError, check_enum, int(gl.GL_TRIANGLE_STRIP))\n    assert_raises(ValueError, check_enum, [])\n    check_enum('RGB', 'test', ('rgb', 'alpha')) == 'rgb'\n    check_enum(gl.GL_ALPHA, 'test', ('rgb', 'alpha')) == 'alpha'\n    assert_raises(ValueError, check_enum, 'RGB', 'test', ('a', 'b'))\n    assert_raises(ValueError, check_enum, gl.GL_ALPHA, 'test', ('a', 'b'))\n    try:\n        from OpenGL import GL\n    except ImportError:\n        return\n    assert check_enum(GL.GL_RGB) == 'rgb'\n    assert check_enum(GL.GL_TRIANGLE_STRIP) == 'triangle_strip'\n\ntest_check_enum()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_util.py"}], "instruction": "Functionality: The check_enum function is designed to convert an enumeration (enum) into its lowercase string representation. It checks if the input is an integer or a string. If it's an integer, the function verifies if it has a 'name' attribute that starts with 'GL_'. If the input is a string, it simply converts it to lowercase. The function also has a validation feature where it can compare the string representation against a list of valid values.\nInputs: \n1. enum: The input that needs to be converted to its lowercase string representation. It can be either an integer or a string. If it's an integer, it should be an enumeration with a 'name' attribute that starts with 'GL_'.\n2. name (optional): A string parameter to specify the name of the enum for error messages. Default value is 'enum'.\n3. valid (optional): A list of valid string values. If provided, the function will check if the lowercase string representation of 'enum' is one of these values. If not, it will raise a ValueError.\nOutputs:\n1. res: A lowercase string representation of the input 'enum'. It will return the lowercase version of the name attribute of the enum if 'enum' is an integer with a 'name' attribute that starts with 'GL_'. If 'enum' is a string, it returns the lowercase version of the string. If the input does not meet the above conditions, the function raises a ValueError.", "method_code_mask": "def check_enum(enum, name=None, valid=None): [MASK]\n"}
{"method_name": "check_variable", "full_method_name": "check_variable", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'\ndef check_variable(name):\n    \"\"\"\n    Return None if *name* is expected to be a valid variable name in any GLSL\n    version. Otherwise, return a string describing the problem.\n    \"\"\"\n    if len(name) > 31:\n        return (\n            'Variable names >31 characters may not function on some systems.')\n    return check_identifier(name)", "test_code_list": [{"test_code": "from vispy.gloo import util\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\nfrom vispy.gloo import gl\ndef test_check_identifier():\n    assert util.check_identifier('foo') is None\n    assert util.check_identifier('_fooBarBla') is None\n    assert util.check_identifier('_glPosition') is None\n    assert util.check_identifier('__').startswith('Identifier')\n    assert util.check_identifier('gl_').startswith('Identifier')\n    assert util.check_identifier('GL_').startswith('Identifier')\n    assert util.check_identifier('double').startswith('Identifier')\n    assert check_variable('foo') is None\n    assert check_variable('a' * 30) is None\n    assert check_variable('a' * 32)\n\ntest_check_identifier()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_util.py"}], "instruction": "Functionality: The check_variable function evaluates whether a given variable name is valid according to GLSL (Graphics Library Shader Language) standards. It checks the length of the name, ensures it does not contain double underscores, does not start with 'gl_' or 'GL_', and is not a reserved keyword in GLSL.\n\nInputs: \n- name (str): A string representing the variable name to be checked.\n\nOutputs:\n- None: If the variable name is valid according to GLSL standards.\n- str: A message describing the reason why the variable name is invalid, if any.", "method_code_mask": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\n\n\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'\n\n\ndef check_variable(name): [MASK]\n"}
{"method_name": "check_identifier", "full_method_name": "check_identifier", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'", "test_code_list": [{"test_code": "from vispy.gloo import util\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_raises\nfrom vispy.gloo import gl\ndef test_check_identifier():\n    assert check_identifier('foo') is None\n    assert check_identifier('_fooBarBla') is None\n    assert check_identifier('_glPosition') is None\n    assert check_identifier('__').startswith('Identifier')\n    assert check_identifier('gl_').startswith('Identifier')\n    assert check_identifier('GL_').startswith('Identifier')\n    assert check_identifier('double').startswith('Identifier')\n    assert util.check_variable('foo') is None\n    assert util.check_variable('a' * 30) is None\n    assert util.check_variable('a' * 32)\n\ntest_check_identifier()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/gloo/tests/test_util.py"}], "instruction": "Functionality: The check_identifier function is designed to validate a given identifier name according to specific rules. It checks the identifier against multiple conditions: it cannot contain double underscores, cannot begin with 'gl_' or 'GL_', and must not be a reserved keyword. The function returns an error message if the identifier violates any of these rules.\n\nInputs: \n    name (str): A string representing the identifier name to be checked. The name must be a valid string.\n\nOutputs:\n    str: A string message indicating whether the identifier is valid or if it violates any of the specified rules. If the identifier is valid, no message is returned, implying that the identifier has passed all checks. If the identifier is invalid, a descriptive error message is returned, explaining which rule the identifier has violated.", "method_code_mask": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\n\n\ndef check_identifier(name): [MASK]\n"}
{"method_name": "list_fonts", "full_method_name": "list_fonts", "method_path": "../srcdata/Visualization/vispy/vispy/util/fonts/_triage.py", "method_code": "import sys\ndef list_fonts():\n    \"\"\"List system fonts\n\n    Returns\n    -------\n    fonts : list of str\n        List of system fonts.\n    \"\"\"\n    vals = _list_fonts()\n    for font in _vispy_fonts:\n        vals += [font] if font not in vals else []\n    vals = sorted(vals, key=lambda s: s.lower())\n    return vals", "test_code_list": [{"test_code": "import numpy as np\nimport warnings\nfrom vispy.testing import assert_in\nfrom vispy.testing import run_tests_if_main\nfrom vispy.util.fonts import list_fonts\nfrom vispy.util.fonts import _load_glyph\nfrom vispy.util.fonts import _vispy_fonts\nimport pytest\ndef test_font_list():\n    \"\"\"Test font listing\"\"\"\n    f = list_fonts()\n    assert len(f) > 0\n    for font in _vispy_fonts:\n        assert_in(font, f)\n\ntest_font_list()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/util/fonts/tests/test_font.py"}], "instruction": "Functionality: The function 'list_fonts' is designed to retrieve and list all the system fonts available on the machine where the function is executed. It ensures a sorted list is returned, making it easier for the user to navigate through the fonts.\n\nInputs: The function does not take any input arguments. It internally uses a private function '_list_fonts' and appends the output with a predefined list '_vispy_fonts' to fetch all available fonts. Any duplicate entries in '_vispy_fonts' are filtered out before concatenation.\n\nOutputs: The output of the function is a list of strings. Each string in the list represents a font name, and the list is sorted in alphabetical order (case-insensitive). This list comprehensively contains all the system fonts identified by the function.", "method_code_mask": "import sys\n\n\ndef list_fonts(): [MASK]\n"}
{"method_name": "get_dpi", "full_method_name": "get_dpi", "method_path": "../srcdata/Visualization/vispy/vispy/util/dpi/_win32.py", "method_code": "\ndef get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    try:\n        user32.SetProcessDPIAware()\n    except AttributeError:\n        pass\n    dc = user32.GetDC(0)\n    h_size = gdi32.GetDeviceCaps(dc, HORZSIZE)\n    v_size = gdi32.GetDeviceCaps(dc, VERTSIZE)\n    h_res = gdi32.GetDeviceCaps(dc, HORZRES)\n    v_res = gdi32.GetDeviceCaps(dc, VERTRES)\n    user32.ReleaseDC(None, dc)\n    return (h_res / float(h_size) + v_res / float(v_size)) * 0.5 * 25.4", "test_code_list": [{"test_code": "from vispy.util.dpi import get_dpi\nfrom vispy.testing import run_tests_if_main\ndef test_dpi():\n    \"\"\"Test dpi support\"\"\"\n    dpi = get_dpi()\n    assert dpi > 0.0\n    assert isinstance(dpi, float)\n\ntest_dpi()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/util/dpi/tests/test_dpi.py"}], "instruction": "Functionality: The function aims to retrieve the screen DPI (dots per inch) of the primary screen from the operating system. It uses Windows API calls to determine the horizontal and vertical resolution and size of the screen to calculate the DPI.\n\nInputs: \n- raise_error : bool\n    A boolean parameter that dictates the behavior of the function in case the DPI cannot be determined. If set to True (default), the function will raise an error. If set to False, the function will not raise an error and may return a default or undefined value instead.\n\nOutputs:\n- dpi : float\n    The function returns a floating-point number representing the dots per inch of the primary screen. The DPI is calculated as the average of the horizontal and vertical resolution per size, adjusted to the standard 25.4 millimeters per inch.", "method_code_mask": "def get_dpi(raise_error=True): [MASK]\n"}
{"method_name": "stft", "full_method_name": "stft", "method_path": "../srcdata/Visualization/vispy/vispy/util/fourier.py", "method_code": "import numpy as np\ndef stft(x, n_fft=1024, step=512, fs=2 * np.pi, window='hann'):\n    \"\"\"Compute the STFT\n\n    Parameters\n    ----------\n    x : array-like\n        1D signal to operate on. ``If len(x) < n_fft``, x will be zero-padded\n        to length ``n_fft``.\n    n_fft : int\n        Number of FFT points. Much faster for powers of two.\n    step : int | None\n        Step size between calculations. If None, ``n_fft // 2``\n        will be used.\n    fs : float\n        The sample rate of the data.\n    window : str | None\n        Window function to use. Can be ``'hann'`` for Hann window, or None\n        for no windowing.\n\n    Returns\n    -------\n    stft : ndarray\n        Spectrogram of the data, shape (n_freqs, n_steps).\n\n    See also\n    --------\n    fft_freqs\n    \"\"\"\n    x = np.asarray(x, float)\n    if x.ndim != 1:\n        raise ValueError('x must be 1D')\n    if window is not None:\n        if window not in ('hann',):\n            raise ValueError('window must be \"hann\" or None')\n        w = np.hanning(n_fft)\n    else:\n        w = np.ones(n_fft)\n    n_fft = int(n_fft)\n    step = max(n_fft // 2, 1) if step is None else int(step)\n    fs = float(fs)\n    zero_pad = n_fft - len(x)\n    if zero_pad > 0:\n        x = np.concatenate((x, np.zeros(zero_pad, float)))\n    n_freqs = n_fft // 2 + 1\n    n_estimates = (len(x) - n_fft) // step + 1\n    result = np.empty((n_freqs, n_estimates), np.complex128)\n    for ii in range(n_estimates):\n        result[:, ii] = np.fft.rfft(w * x[ii * step:ii * step + n_fft]) / n_fft\n    return result", "test_code_list": [{"test_code": "import numpy as np\nfrom vispy.util.fourier import stft\nfrom vispy.util.fourier import fft_freqs\nfrom vispy.testing import assert_raises\nfrom vispy.testing import run_tests_if_main\ndef test_stft():\n    \"\"\"Test STFT calculation\"\"\"\n    assert_raises(ValueError, stft, 0)\n    assert_raises(ValueError, stft, [], window='foo')\n    assert_raises(ValueError, stft, [[]])\n    result = stft([])\n    assert np.allclose(result, np.zeros_like(result))\n    n_fft = 256\n    step = 128\n    for n_samples, n_estimates in ((256, 1), (383, 1), (384, 2), (511, 2),\n        (512, 3)):\n        result = stft(np.ones(n_samples), n_fft=n_fft, step=step, window=None)\n        assert result.shape[1] == n_estimates\n        expected = np.zeros(n_fft // 2 + 1)\n        expected[0] = 1\n        for res in result.T:\n            assert np.allclose(expected, np.abs(res))\n            assert np.allclose(expected, np.abs(res))\n    for n_pts, last_freq in zip((256, 255), (500.0, 498.0)):\n        freqs = fft_freqs(n_pts, 1000)\n        assert freqs[0] == 0\n        assert np.allclose(freqs[-1], last_freq, atol=0.1)\n\ntest_stft()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/util/tests/test_fourier.py"}], "instruction": "Functionality: The Short-Time Fourier Transform (STFT) is computed for a given 1D signal. This function calculates the frequency content of the signal over short segments, which can be useful for analyzing non-stationary signals.\n\nInputs:\n- x: An array-like 1D signal. If its length is less than `n_fft`, the signal will be zero-padded to length `n_fft`.\n- n_fft: An integer specifying the number of FFT points. It's advised to use powers of two for faster computation.\n- step: An integer or None value determining the step size between calculations. If None, `n_fft // 2` will be used.\n- fs: A float representing the sample rate of the data.\n- window: A string or None indicating the window function to use. 'hann' for Hann window, or None for no windowing.\n\nOutputs:\n- stft: A 2D numpy ndarray representing the spectrogram of the data, with shape (n_freqs, n_steps), where n_freqs is the number of frequencies, and n_steps is the number of STFT estimates.\n\nSee also\n--------\n- fft_freqs", "method_code_mask": "import numpy as np\n\n\ndef stft(x, n_fft=1024, step=512, fs=2 * np.pi, window='hann'): [MASK]\n"}
{"method_name": "get_color_names", "full_method_name": "get_color_names", "method_path": "../srcdata/Visualization/vispy/vispy/color/_color_dict.py", "method_code": "\ndef get_color_names():\n    \"\"\"Get the known color names\n\n    Returns\n    -------\n    names : list\n        List of color names known by Vispy.\n    \"\"\"\n    names = sorted(_color_dict.keys())\n    return names", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.color import Color\nfrom vispy.color import ColorArray\nfrom vispy.color import get_color_names\nfrom vispy.color import Colormap\nfrom vispy.color import get_color_dict\nfrom vispy.color import get_colormap\nfrom vispy.color import get_colormaps\nfrom vispy.visuals.shaders import Function\nfrom vispy.util import use_log_level\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_equal\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_true\nimport vispy.color.colormap as c\nfrom vispy.color.colormap import _normalize\ndef test_color_interpretation():\n    \"\"\"Test basic color interpretation API\"\"\"\n    r = ColorArray('r')\n    print(r)\n    r2 = ColorArray(r)\n    assert_equal(r, r2)\n    r2.rgb = 0, 0, 0\n    assert_equal(r2, ColorArray('black'))\n    assert_equal(r, ColorArray('r'))\n    assert_equal(r, r.copy())\n    assert_equal(r, ColorArray('#ff0000'))\n    assert_equal(r, ColorArray('#FF0000FF'))\n    assert_equal(r, ColorArray('red'))\n    assert_equal(r, ColorArray('red', alpha=1.0))\n    assert_equal(ColorArray((1, 0, 0, 0.1)), ColorArray('red', alpha=0.1))\n    assert_array_equal(r.rgb.ravel(), (1.0, 0.0, 0.0))\n    assert_array_equal(r.rgba.ravel(), (1.0, 0.0, 0.0, 1.0))\n    assert_array_equal(r.RGBA.ravel(), (255, 0, 0, 255))\n    rgb = ColorArray(list('rgb'))\n    print(rgb)\n    assert_array_equal(rgb, ColorArray(np.eye(3)))\n    rgb = ColorArray(['r', (0, 1, 0), '#0000ffff'])\n    assert_array_equal(rgb, ColorArray(np.eye(3)))\n    assert_raises(RuntimeError, ColorArray, ['r', np.eye(3)])\n    r = ColorArray('#ffff')\n    assert_equal(r, ColorArray('white'))\n    r = ColorArray('#ff000000')\n    assert_true('turquoise' in get_color_names())\n    assert_equal(r.alpha, 0)\n    r.alpha = 1.0\n    assert_equal(r, ColorArray('r'))\n    r.alpha = 0\n    r.rgb = 1, 0, 0\n    assert_equal(r.alpha, 0)\n    assert_equal(r.hex, ['#ff0000'])\n    r.alpha = 1\n    r.hex = '00ff00'\n    assert_equal(r, ColorArray('g'))\n    assert_array_equal(r.rgb.ravel(), (0.0, 1.0, 0.0))\n    r.RGB = 255, 0, 0\n    assert_equal(r, ColorArray('r'))\n    assert_array_equal(r.RGB.ravel(), (255, 0, 0))\n    r.RGBA = 255, 0, 0, 0\n    assert_equal(r, ColorArray('r', alpha=0))\n    w = ColorArray()\n    w.rgb = ColorArray('r').rgb + ColorArray('g').rgb + ColorArray('b').rgb\n    assert_equal(w, ColorArray('white'))\n    w = ColorArray('white')\n    assert_equal(w, w.darker().lighter())\n    assert_equal(w, w.darker(0.1).darker(-0.1))\n    w2 = w.darker()\n    assert_true(w != w2)\n    w.darker(copy=False)\n    assert_equal(w, w2)\n    with use_log_level('warning', record=True, print_msg=False) as w:\n        w = ColorArray('white')\n        w.value = 2\n        assert_equal(len(w), 1)\n    assert_equal(w, ColorArray('white'))\n    assert_raises(ValueError, ColorArray, '#ffii00')\n    assert_raises(ValueError, ColorArray, '#ff000')\n    assert_raises(ValueError, ColorArray, [0, 0])\n    assert_raises(ValueError, ColorArray, [2, 0, 0])\n    assert_raises(ValueError, ColorArray, [-1, 0, 0])\n    c = ColorArray([2.0, 0.0, 0.0], clip=True)\n    assert_true(np.all(c.rgb <= 1))\n    c = ColorArray([-1.0, 0.0, 0.0], clip=True)\n    assert_true(np.all(c.rgb >= 0))\n    for key in get_color_names():\n        assert_true(ColorArray(key))\n    assert_raises(ValueError, ColorArray, 'foo')\n    _color_dict = get_color_dict()\n    assert isinstance(_color_dict, dict)\n    assert set(_color_dict.keys()) == set(get_color_names())\n\ntest_color_interpretation()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/color/tests/test_color.py"}], "instruction": "Functionality: \nThe function get_color_names is designed to retrieve a list of known color names that are recognized by the Vispy library, a high-level visualization library for Python.\n\nInputs: \nThere are no input arguments for this function. It does not require any external data or parameters to perform its task.\n\nOutputs: \nThe function returns a single output:\n- names : list\n    This is a list that contains the names of all colors that the Vispy library knows. The names are sorted in alphabetical order to provide a clean and organized list for further use.", "method_code_mask": "def get_color_names(): [MASK]\n"}
{"method_name": "mix", "full_method_name": "mix", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef _mix_simple(a, b, x):\n    \"\"\"Mix b (with proportion x) with a.\"\"\"\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x) * a + x * b\ndef _find_controls(x, controls=None, clip=None):\n    x_controls = np.clip(np.searchsorted(controls, x) - 1, 0, clip)\n    return x_controls.astype(np.int32)\ndef _interpolate_multi(colors, x, controls):\n    x = x.ravel()\n    n = len(colors)\n    x_step = _find_controls(x, controls, n - 2)\n    controls_length = np.diff(controls).astype(np.float32)\n    controls_length[controls_length == 0.0] = 1.0\n    _to_clip = x - controls[x_step]\n    _to_clip /= controls_length[x_step]\n    x_rel = np.clip(_to_clip, 0.0, 1.0)\n    return colors[x_step], colors[x_step + 1], x_rel[:, None]\ndef mix(colors, x, controls=None):\n    a, b, x_rel = _interpolate_multi(colors, x, controls)\n    return _mix_simple(a, b, x_rel)", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.color import Color\nfrom vispy.color import ColorArray\nfrom vispy.color import get_color_names\nfrom vispy.color import Colormap\nfrom vispy.color import get_color_dict\nfrom vispy.color import get_colormap\nfrom vispy.color import get_colormaps\nfrom vispy.visuals.shaders import Function\nfrom vispy.util import use_log_level\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_equal\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_true\nimport vispy.color.colormap as c\nfrom vispy.color.colormap import _normalize\ndef test_colormap_interpolation():\n    \"\"\"Test interpolation routines for colormaps.\"\"\"\n    import vispy.color.colormap as c\n    assert_raises(AssertionError, c._glsl_step, [0.0, 1.0])\n    for fun in (c._glsl_step, c._glsl_mix):\n        assert_raises(AssertionError, fun, controls=[0.1, 1.0])\n        assert_raises(AssertionError, fun, controls=[0.0, 0.9])\n        assert_raises(AssertionError, fun, controls=[0.1, 0.9])\n    color_0 = np.array([1.0, 0.0, 0.0])\n    color_1 = np.array([0.0, 1.0, 0.0])\n    color_2 = np.array([0.0, 0.0, 1.0])\n    colors_00 = np.vstack((color_0, color_0))\n    colors_01 = np.vstack((color_0, color_1))\n    colors_11 = np.vstack((color_1, color_1))\n    colors_021 = np.vstack((color_0, color_2, color_1))\n    controls_2 = np.array([0.0, 1.0])\n    controls_3 = np.array([0.0, 0.25, 1.0])\n    x = np.array([-1.0, 0.0, 0.1, 0.4, 0.5, 0.6, 1.0, 2.0])[:, None]\n    mixed_2 = mix(colors_01, x, controls_2)\n    mixed_3 = mix(colors_021, x, controls_3)\n    for y in (mixed_2, mixed_3):\n        assert_allclose(y[:2, :], colors_00)\n        assert_allclose(y[-2:, :], colors_11)\n    assert_allclose(mixed_2[:, -1], np.zeros(len(y)))\n\ntest_colormap_interpolation()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/color/tests/test_color.py"}], "instruction": "Functionality: The 'mix' function is designed to blend colors based on provided color values and a mixing factor. This function is especially useful for color interpolation in graphics and visualization applications. It interpolates between multiple colors, which are defined in an array, according to a mixing factor 'x'. If 'controls' are provided, they define the points at which the color should exactly match the color in the 'colors' array.\n\nInputs:\n- colors: An array-like object of colors. Each color is represented as a triplet of RGB values or as a single float value if the colors are normalized to a 0-1 scale. The length of this array determines the number of colors to interpolate between.\n- x: A float or an array-like object of floats representing the mixing factor(s). This factor determines the degree to which each 'colors' value is blended with the next one. 'x' values should ideally range between 0 and 1.\n- controls: An optional array-like object of floats that specifies the exact points at which the color should match the corresponding color in the 'colors' array. If not provided, 'x' is assumed to be evenly distributed between the colors.\n\nOutputs:\n- The output is a single color or an array of colors, depending on whether 'x' is a single value or an array. Each output color is the result of blending colors from the 'colors' array based on the mixing factor(s) provided in 'x', taking into account the 'controls' if provided.", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef _mix_simple(a, b, x):\n    \"\"\"Mix b (with proportion x) with a.\"\"\"\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x) * a + x * b\n\n\ndef _find_controls(x, controls=None, clip=None):\n    x_controls = np.clip(np.searchsorted(controls, x) - 1, 0, clip)\n    return x_controls.astype(np.int32)\n\n\ndef _interpolate_multi(colors, x, controls):\n    x = x.ravel()\n    n = len(colors)\n    x_step = _find_controls(x, controls, n - 2)\n    controls_length = np.diff(controls).astype(np.float32)\n    controls_length[controls_length == 0.0] = 1.0\n    _to_clip = x - controls[x_step]\n    _to_clip /= controls_length[x_step]\n    x_rel = np.clip(_to_clip, 0.0, 1.0)\n    return colors[x_step], colors[x_step + 1], x_rel[:, None]\n\n\ndef mix(colors, x, controls=None): [MASK]\n"}
{"method_name": "get_colormap", "full_method_name": "get_colormap", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef get_colormap(name):\n    \"\"\"Obtain a colormap by name.\n\n    Parameters\n    ----------\n    name : str | Colormap\n        Colormap name. Can also be a Colormap for pass-through.\n\n    Examples\n    --------\n    >>> get_colormap('autumn')\n    >>> get_colormap('single_hue')\n\n    .. versionchanged: 0.7\n\n        Additional args/kwargs are no longer accepted. Colormap instances are\n        no longer created on the fly.\n\n    \"\"\"\n    if isinstance(name, BaseColormap):\n        return name\n    if not isinstance(name, str):\n        raise TypeError('colormap must be a Colormap or string name')\n    if name in _colormaps:\n        cmap = _colormaps[name]\n    elif has_matplotlib():\n        try:\n            cmap = MatplotlibColormap(name)\n        except ValueError:\n            raise KeyError('colormap name %s not found' % name)\n    else:\n        raise KeyError('colormap name %s not found' % name)\n    return cmap", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.color import Color\nfrom vispy.color import ColorArray\nfrom vispy.color import get_color_names\nfrom vispy.color import Colormap\nfrom vispy.color import get_color_dict\nfrom vispy.color import get_colormap\nfrom vispy.color import get_colormaps\nfrom vispy.visuals.shaders import Function\nfrom vispy.util import use_log_level\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_equal\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_true\nimport vispy.color.colormap as c\nfrom vispy.color.colormap import _normalize\ndef test_colormap():\n    \"\"\"Test named colormaps.\"\"\"\n    autumn = get_colormap('autumn')\n    assert autumn.glsl_map != ''\n    assert len(autumn[0.0]) == 1\n    assert len(autumn[0.5]) == 1\n    assert len(autumn[1.0]) == 1\n    assert len(autumn[[0.0, 0.5, 1.0]]) == 3\n    assert len(autumn[np.array([0.0, 0.5, 1.0])]) == 3\n    fire = get_colormap('fire')\n    assert_array_equal(fire[0].rgba, np.ones((1, 4)))\n    assert_array_equal(fire[1].rgba, np.array([[1, 0, 0, 1]]))\n    grays = get_colormap('grays')\n    assert_array_equal(grays[0.5].rgb, np.ones((1, 3)) * 0.5)\n    hot = get_colormap('hot')\n    assert_allclose(hot[0].rgba, [[0, 0, 0, 1]], 1e-06, 1e-06)\n    assert_allclose(hot[0.5].rgba, [[1, 0.52272022, 0, 1]], 1e-06, 1e-06)\n    assert_allclose(hot[1.0].rgba, [[1, 1, 1, 1]], 1e-06, 1e-06)\n    for name in get_colormaps():\n        colormap = get_colormap(name)\n        Function(colormap.glsl_map)\n        colors = colormap[np.linspace(-2.0, 2.0, 50)]\n        assert colors.rgba.min() >= 0\n        assert colors.rgba.max() <= 1\n\ntest_colormap()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/color/tests/test_color.py"}], "instruction": "Functionality: The function 'get_colormap' is designed to retrieve a colormap based on the provided name. It supports both the direct passing of a colormap object and the retrieval of a colormap by its name from a predefined list or from the Matplotlib library if available.\n\nInputs: \n- name: A string representing the name of the colormap to be retrieved. It can also accept a Colormap object directly, which will be returned without any further processing.\n\nOutputs: \n- The function returns a Colormap object. If the input is already a Colormap object, it is returned directly. If a string is provided, the function attempts to return the corresponding Colormap object from a predefined list or from Matplotlib, if the library is available and the colormap name is recognized.", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef get_colormap(name): [MASK]\n"}
{"method_name": "_normalize", "full_method_name": "_normalize", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef _normalize(x, cmin=None, cmax=None, clip=True):\n    \"\"\"Normalize an array from the range [cmin, cmax] to [0,1],\n    with optional clipping.\n    \"\"\"\n    if not isinstance(x, np.ndarray):\n        x = np.array(x)\n    if cmin is None:\n        cmin = x.min()\n    if cmax is None:\n        cmax = x.max()\n    if cmin == cmax:\n        return 0.5 * np.ones(x.shape)\n    else:\n        cmin, cmax = float(cmin), float(cmax)\n        y = (x - cmin) * 1.0 / (cmax - cmin)\n        if clip:\n            y = np.clip(y, 0.0, 1.0)\n        return y", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.color import Color\nfrom vispy.color import ColorArray\nfrom vispy.color import get_color_names\nfrom vispy.color import Colormap\nfrom vispy.color import get_color_dict\nfrom vispy.color import get_colormap\nfrom vispy.color import get_colormaps\nfrom vispy.visuals.shaders import Function\nfrom vispy.util import use_log_level\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import assert_equal\nfrom vispy.testing import assert_raises\nfrom vispy.testing import assert_true\nimport vispy.color.colormap as c\nfrom vispy.color.colormap import _normalize\ndef test_normalize():\n    \"\"\"Test the _normalize() function.\"\"\"\n    from vispy.color.colormap import _normalize\n    for x in (-1, 0.0, 0.5, 1.0, 10.0, 20):\n        assert _normalize(x) == 0.5\n    assert_allclose(_normalize((-1.0, 0.0, 1.0)), (0.0, 0.5, 1.0))\n    assert_allclose(_normalize((-1.0, 0.0, 1.0), 0.0, 1.0), (0.0, 0.0, 1.0))\n    assert_allclose(_normalize((-1.0, 0.0, 1.0), 0.0, 1.0, clip=False), (-\n        1.0, 0.0, 1.0))\n    y = _normalize(np.random.randn(100, 5), -10.0, 10.0)\n    assert_allclose([y.min(), y.max()], [0.2975, 1 - 0.2975], 0.1, 0.1)\n\ntest_normalize()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/color/tests/test_color.py"}], "instruction": "Functionality: The _normalize function is designed to normalize an input array from its original range to the range [0,1]. It can optionally clip the values to ensure they do not fall outside this interval. Normalization is a common preprocessing step in data analysis and visualization to scale data to a standard range for better processing or comparison.\n\nInputs: \n- x: The input array to be normalized. It can be a list or a numpy array.\n- cmin (optional): The minimum value of the range in the input array. If not provided, the function will use the minimum value found in the input array.\n- cmax (optional): The maximum value of the range in the input array. If not provided, the function will use the maximum value found in the input array.\n- clip (optional, boolean): Determines whether to clip the normalized values to the [0,1] range. Default is True.\n\nOutputs: \n- A numpy array where each element is normalized to the range [0,1]. If the input array's minimum and maximum values are the same, the function will return an array of the same shape as the input filled with 0.5.", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef _normalize(x, cmin=None, cmax=None, clip=True): [MASK]\n"}
{"method_name": "SkipTest", "full_method_name": "SkipTest", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef SkipTest(*args, **kwargs):\n    \"\"\"Backport for raising SkipTest that gives a better traceback.\"\"\"\n    __tracebackhide__ = True\n    import pytest\n    return pytest.skip(*args, **kwargs)", "test_code_list": [{"test_code": "from vispy import testing\nfrom vispy.visuals.graphs.layouts import get_layout\nfrom vispy.visuals.graphs.layouts.networkx_layout import NetworkxCoordinates\nimport numpy as np\nimport networkx as nx\ndef test_networkx_layout_with_graph():\n    \"\"\"Testing the various inputs to the networkx layout.\"\"\"\n    settings = dict(name='networkx_layout')\n    if nx is None:\n        return SkipTest(\"'networkx' required\")\n    graph = nx.complete_graph(5)\n    layout = np.random.rand(5, 2)\n    settings['graph'] = graph\n    settings['layout'] = layout\n    testing.assert_true(isinstance(get_layout(**settings), NetworkxCoordinates)\n        )\n    settings['layout'] = 'circular'\n    testing.assert_true(isinstance(get_layout(**settings), NetworkxCoordinates)\n        )\n    settings['layout'] = nx.circular_layout(graph)\n    testing.assert_true(isinstance(get_layout(**settings), NetworkxCoordinates)\n        )\n\ntest_networkx_layout_with_graph()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/graphs/tests/test_networkx_layout.py"}], "instruction": "Functionality: The SkipTest function is used to skip a test during the execution of test cases, typically in a testing framework. It allows the test runner to bypass a specific test when certain conditions are met, such as when a feature is not implemented or when the test is not applicable under certain environments or configurations.\n\nInputs: The SkipTest function accepts any number of positional arguments and keyword arguments, which are typically used to provide a reason for skipping the test. These arguments are generally strings describing why the test is being skipped.\n\nOutputs: The function itself does not return any value but raises a pytest.skip exception, which is caught by the testing framework. The effect of this is to mark the test as skipped and prevent its execution. The reason provided as an argument to the function is used to report why the test was skipped.", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef SkipTest(*args, **kwargs): [MASK]\n"}
{"method_name": "create_sphere", "full_method_name": "create_sphere", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/generation.py", "method_code": "from __future__ import division\nimport numpy as np\ndef create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n    subdivisions=3, method='latitude'):\n    \"\"\"Create a sphere\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows (for method='latitude' and 'cube').\n    cols : int\n        Number of columns (for method='latitude' and 'cube').\n    depth : int\n        Number of depth segments (for method='cube').\n    radius : float\n        Sphere radius.\n    offset : bool\n        Rotate each row by half a column (for method='latitude').\n    subdivisions : int\n        Number of subdivisions to perform (for method='ico')\n    method : str\n        Method for generating sphere. Accepts 'latitude' for latitude-\n        longitude, 'ico' for icosahedron, and 'cube' for cube based\n        tessellation.\n\n    Returns\n    -------\n    sphere : MeshData\n        Vertices and faces computed for a spherical surface.\n    \"\"\"\n    if method == 'latitude':\n        return _latitude(rows, cols, radius, offset)\n    elif method == 'ico':\n        return _ico(radius, subdivisions)\n    elif method == 'cube':\n        return _cube(rows, cols, depth, radius)\n    else:\n        raise Exception(\"Invalid method. Accepts: 'latitude', 'ico', 'cube'\")", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.testing import run_tests_if_main\nfrom vispy.geometry import create_box\nfrom vispy.geometry import create_cube\nfrom vispy.geometry import create_cylinder\nfrom vispy.geometry import create_sphere\nfrom vispy.geometry import create_plane\ndef test_sphere():\n    \"\"\"Test sphere function\"\"\"\n    md = create_sphere(rows=10, cols=20, radius=10, method='latitude')\n    radii = np.sqrt((md.get_vertices() ** 2).sum(axis=1))\n    assert radii.dtype.type is np.float32\n    assert_allclose(radii, np.ones_like(radii) * 10, atol=1e-06)\n    md = create_sphere(subdivisions=5, radius=10, method='ico')\n    radii = np.sqrt((md.get_vertices() ** 2).sum(axis=1))\n    assert radii.dtype.type is np.float32\n    assert_allclose(radii, np.ones_like(radii) * 10, atol=1e-06)\n    md = create_sphere(rows=20, cols=20, depth=20, radius=10, method='cube')\n    radii = np.sqrt((md.get_vertices() ** 2).sum(axis=1))\n    assert radii.dtype.type is np.float32\n    assert_allclose(radii, np.ones_like(radii) * 10, atol=1e-06)\n\ntest_sphere()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/geometry/tests/test_generation.py"}], "instruction": "Functionality: This function creates a spherical surface using different methods based on the parameters provided. It supports three methods for generating the sphere: 'latitude' for latitude-longitude, 'ico' for icosahedron, and 'cube' for cube based tessellation.\n\nInputs: \n    - rows: An integer specifying the number of rows (for method='latitude' and 'cube').\n    - cols: An integer specifying the number of columns (for method='latitude' and 'cube').\n    - depth: An integer specifying the number of depth segments (for method='cube').\n    - radius: A float representing the radius of the sphere.\n    - offset: A boolean indicating whether to rotate each row by half a column (for method='latitude').\n    - subdivisions: An integer specifying the number of subdivisions to perform (for method='ico').\n    - method: A string indicating the method for generating the sphere. It accepts 'latitude', 'ico', and 'cube'.\n\nOutputs:\n    - sphere: A MeshData object containing the vertices and faces computed for the spherical surface.", "method_code_mask": "from __future__ import division\nimport numpy as np\n\n\ndef create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n    subdivisions=3, method='latitude'): [MASK]\n"}
{"method_name": "create_cylinder", "full_method_name": "create_cylinder", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/generation.py", "method_code": "from __future__ import division\nimport numpy as np\ndef create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False):\n    \"\"\"Create a cylinder\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows.\n    cols : int\n        Number of columns.\n    radius : tuple of float\n        Cylinder radii.\n    length : float\n        Length of the cylinder.\n    offset : bool\n        Rotate each row by half a column.\n\n    Returns\n    -------\n    cylinder : MeshData\n        Vertices and faces computed for a cylindrical surface.\n    \"\"\"\n    verts = np.empty((rows + 1, cols, 3), dtype=np.float32)\n    if isinstance(radius, int):\n        radius = [radius, radius]\n    th = np.linspace(2 * np.pi, 0, cols).reshape(1, cols)\n    r = np.linspace(radius[0], radius[1], num=rows + 1, endpoint=True).reshape(\n        rows + 1, 1)\n    verts[..., 2] = np.linspace(0, length, num=rows + 1, endpoint=True\n        ).reshape(rows + 1, 1)\n    if offset:\n        th = th + np.pi / cols * np.arange(rows + 1).reshape(rows + 1, 1)\n    verts[..., 0] = r * np.cos(th)\n    verts[..., 1] = r * np.sin(th)\n    verts = verts.reshape((rows + 1) * cols, 3)\n    faces = np.empty((rows * cols * 2, 3), dtype=np.uint32)\n    rowtemplate1 = (np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 0]])\n        ) % cols + np.array([[0, 0, cols]])\n    rowtemplate2 = (np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 1]])\n        ) % cols + np.array([[cols, 0, cols]])\n    for row in range(rows):\n        start = row * cols * 2\n        faces[start:start + cols] = rowtemplate1 + row * cols\n        faces[start + cols:start + cols * 2] = rowtemplate2 + row * cols\n    return MeshData(vertices=verts, faces=faces)", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom vispy.testing import run_tests_if_main\nfrom vispy.geometry import create_box\nfrom vispy.geometry import create_cube\nfrom vispy.geometry import create_cylinder\nfrom vispy.geometry import create_sphere\nfrom vispy.geometry import create_plane\ndef test_cylinder():\n    \"\"\"Test cylinder function\"\"\"\n    md = create_cylinder(10, 20, radius=[10, 10])\n    radii = np.sqrt((md.get_vertices()[:, :2] ** 2).sum(axis=1))\n    assert_allclose(radii, np.ones_like(radii) * 10)\n\ntest_cylinder()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/geometry/tests/test_generation.py"}], "instruction": "Functionality: The create_cylinder function constructs a cylindrical surface mesh with given dimensions, radii, and orientation. The mesh data, including vertices and faces, is returned for rendering or further processing.\n\nInputs:\n- rows: An integer specifying the number of rows of vertices on the cylindrical surface.\n- cols: An integer specifying the number of columns of vertices on the cylindrical surface.\n- radius: A tuple of two floats representing the radii at the bottom and top of the cylinder, respectively. Default is [1.0, 1.0] for a uniform radius.\n- length: A float indicating the length of the cylinder. Default is 1.0.\n- offset: A boolean indicating whether to rotate each row of vertices by half a column. Default is False.\n\nOutputs:\n- cylinder: A MeshData object that contains the vertices and faces computed for the cylindrical surface. This object can be directly used in graphics applications or further manipulated for specialized use.", "method_code_mask": "from __future__ import division\nimport numpy as np\n\n\ndef create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False): [\n    MASK]\n"}
{"method_name": "resize", "full_method_name": "resize", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/calculations.py", "method_code": "import numpy as np\ndef resize(image, shape, kind='linear'):\n    \"\"\"Resize an image\n\n    Parameters\n    ----------\n    image : ndarray\n        Array of shape (N, M, ...).\n    shape : tuple\n        2-element shape.\n    kind : str\n        Interpolation, either \"linear\" or \"nearest\".\n\n    Returns\n    -------\n    scaled_image : ndarray\n        New image, will have dtype np.float64.\n    \"\"\"\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_allclose\nfrom vispy.testing import assert_raises\nfrom vispy.geometry import resize\ndef test_resize():\n    \"\"\"Test image resizing algorithms\"\"\"\n    assert_raises(ValueError, resize, np.zeros(3), (3, 3))\n    assert_raises(ValueError, resize, np.zeros((3, 3)), (3,))\n    assert_raises(ValueError, resize, np.zeros((3, 3)), (4, 4), kind='foo')\n    for kind, tol in (('nearest', 1e-05), ('linear', 0.2)):\n        shape = np.array((10, 11, 3))\n        data = np.random.RandomState(0).rand(*shape)\n        assert_allclose(data, resize(data, shape[:2], kind=kind), rtol=\n            1e-05, atol=1e-05)\n        assert_allclose(data, resize(resize(data, 2 * shape[:2], kind=kind),\n            shape[:2], kind=kind), atol=tol, rtol=tol)\n\ntest_resize()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/geometry/tests/test_calculations.py"}], "instruction": "Functionality: The resize function resizes an input image to a specified shape using either linear or nearest neighbor interpolation. The function supports multi-dimensional images and ensures the output image has a np.float64 data type.\n\nInputs: \n- image : ndarray - An array of shape (N, M, ...) representing the original image to be resized.\n- shape : tuple - A 2-element shape tuple specifying the desired dimensions (height, width) of the resized image.\n- kind : str - A string specifying the interpolation method to be used. It can be either \"linear\" for linear interpolation or \"nearest\" for nearest neighbor interpolation.\n\nOutputs:\n- scaled_image : ndarray - The resized image as a numpy array with np.float64 data type. The output image will have the dimensions specified by the 'shape' input parameter.", "method_code_mask": "import numpy as np\n\n\ndef resize(image, shape, kind='linear'): [MASK]\n"}
{"method_name": "find_program_variables", "full_method_name": "find_program_variables", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/shaders/parsing.py", "method_code": "from __future__ import division\nimport re\ndef find_program_variables(code):\n    \"\"\"\n    Return a dict describing program variables::\n\n        {'var_name': ('uniform|attribute|varying', type), ...}\n\n    \"\"\"\n    vars = {}\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match('\\\\s*' + re_prog_var_declaration + '\\\\s*(=|;)', line)\n        if m is not None:\n            vtype, dtype, names = m.groups()[:3]\n            for name in names.split(','):\n                vars[name.strip()] = vtype, dtype\n    return vars", "test_code_list": [{"test_code": "import re\nfrom vispy.visuals.shaders.parsing import re_identifier\nfrom vispy.visuals.shaders.parsing import find_program_variables\nfrom vispy.testing import run_tests_if_main\ndef test_find_variables():\n    code = \"\"\"\n    float x;\n    float y, z;\n    int w,v,u;\n    junk\n    vec4 t = vec4(0, 0, 1, 1);\n    junk junk junk;\n    uniform vec2 s;\n    attribute float r,q;\n    const mat4 p;\n    void main() {\n        vec2 float undetectable;\n    }\n    \"\"\"\n    expect = dict(x=(None, 'float'), y=(None, 'float'), z=(None, 'float'),\n        w=(None, 'int'), v=(None, 'int'), u=(None, 'int'), t=(None, 'vec4'),\n        s=('uniform', 'vec2'), q=('attribute', 'float'), r=('attribute',\n        'float'), p=('const', 'mat4'))\n    vars = find_program_variables(code)\n    for k in expect:\n        assert expect[k] == vars.pop(k)\n    assert len(vars) == 0\n\ntest_find_variables()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/shaders/tests/test_parsing.py"}], "instruction": "Functionality: The function find_program_variables is designed to parse a given string representing code and extract all program variables along with their types. It specifically looks for uniform, attribute, and varying types in the code and returns a dictionary where each key is a variable name and the value is a tuple containing the variable type (uniform, attribute, varying) and the data type.\n\nInputs: \n- code (str): A string that represents the source code of a program. This code should contain variable declarations.\n\nOutputs:\n- vars (dict): A dictionary where each key is a variable name (str) found in the code, and each value is a tuple (str, str) containing the variable type (uniform, attribute, varying) and the data type of the variable. For example, {'var_name': ('uniform', 'int'), ...}.", "method_code_mask": "from __future__ import division\nimport re\n\n\ndef find_program_variables(code): [MASK]\n"}
{"method_name": "get_default_clim_from_data", "full_method_name": "get_default_clim_from_data", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/_scalable_textures.py", "method_code": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\ndef get_default_clim_from_data(data):\n    \"\"\"Compute a reasonable clim from the min and max, taking nans into account.\n\n    If there are no non-finite values (nan, inf, -inf) this is as fast as it can be.\n    Otherwise, this functions is about 3x slower.\n    \"\"\"\n    min_value = data.min()\n    max_value = data.max()\n    min_finite = np.isfinite(min_value)\n    max_finite = np.isfinite(max_value)\n    if not (min_finite and max_finite):\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size:\n            min_value = finite_data.min()\n            max_value = finite_data.max()\n        else:\n            min_value = max_value = 0\n    return min_value, max_value", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom vispy.testing import run_tests_if_main\nfrom vispy.visuals._scalable_textures import get_default_clim_from_dtype\nfrom vispy.visuals._scalable_textures import get_default_clim_from_data\nfrom vispy.visuals._scalable_textures import CPUScaledTextureMixin\nfrom vispy.visuals._scalable_textures import GPUScaledTextureMixin\ndef test_default_clim():\n    ref_data = np.array([10, 5, 15, 25, 15])\n    data = ref_data.astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = ref_data.astype(np.int32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (-2 ** 31, 2 ** 31 - 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = ref_data.astype(np.uint8)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 255)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n\ntest_default_clim()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_scalable_textures.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom vispy.testing import run_tests_if_main\nfrom vispy.visuals._scalable_textures import get_default_clim_from_dtype\nfrom vispy.visuals._scalable_textures import get_default_clim_from_data\nfrom vispy.visuals._scalable_textures import CPUScaledTextureMixin\nfrom vispy.visuals._scalable_textures import GPUScaledTextureMixin\ndef test_default_clim_non_finite():\n    data = np.array([10, np.nan, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([10, np.inf, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([10, -np.inf, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([np.nan, np.nan, np.nan]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (0, 0)\n    data = np.array([np.nan, np.inf, -np.inf]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (0, 0)\n\ntest_default_clim_non_finite()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_scalable_textures.py"}], "instruction": "Functionality: The function 'get_default_clim_from_data' computes a reasonable range (clim) from the minimum and maximum values of the input data, considering non-finite values such as NaNs, positive infinity, and negative infinity. If the data contains no non-finite values, the function operates efficiently. If non-finite values are present, it computes the range based on the finite values only.\n\nInputs: \n- data: A numpy array from which the minimum and maximum values are extracted. This array can contain finite and non-finite values.\n\nOutputs:\n- min_value: The minimum value from the finite values in the data array.\n- max_value: The maximum value from the finite values in the data array.", "method_code_mask": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\n\n\ndef get_default_clim_from_data(data): [MASK]\n"}
{"method_name": "get_default_clim_from_dtype", "full_method_name": "get_default_clim_from_dtype", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/_scalable_textures.py", "method_code": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\ndef get_default_clim_from_dtype(dtype):\n    \"\"\"Get min and max color limits based on the range of the dtype.\"\"\"\n    if np.issubdtype(dtype, np.floating):\n        return 0, 1\n    dtype_info = np.iinfo(dtype)\n    dmin = dtype_info.min\n    dmax = dtype_info.max\n    return dmin, dmax", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom vispy.testing import run_tests_if_main\nfrom vispy.visuals._scalable_textures import get_default_clim_from_dtype\nfrom vispy.visuals._scalable_textures import get_default_clim_from_data\nfrom vispy.visuals._scalable_textures import CPUScaledTextureMixin\nfrom vispy.visuals._scalable_textures import GPUScaledTextureMixin\ndef test_default_clim():\n    ref_data = np.array([10, 5, 15, 25, 15])\n    data = ref_data.astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = ref_data.astype(np.int32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (-2 ** 31, 2 ** 31 - 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = ref_data.astype(np.uint8)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 255)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n\ntest_default_clim()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_scalable_textures.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom vispy.testing import run_tests_if_main\nfrom vispy.visuals._scalable_textures import get_default_clim_from_dtype\nfrom vispy.visuals._scalable_textures import get_default_clim_from_data\nfrom vispy.visuals._scalable_textures import CPUScaledTextureMixin\nfrom vispy.visuals._scalable_textures import GPUScaledTextureMixin\ndef test_default_clim_non_finite():\n    data = np.array([10, np.nan, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([10, np.inf, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([10, -np.inf, 5, 15, 25, 15]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (5, 25)\n    data = np.array([np.nan, np.nan, np.nan]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (0, 0)\n    data = np.array([np.nan, np.inf, -np.inf]).astype(np.float32)\n    clim = get_default_clim_from_dtype(data.dtype)\n    assert clim == (0, 1)\n    clim = get_default_clim_from_data(data)\n    assert clim == (0, 0)\n\ntest_default_clim_non_finite()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_scalable_textures.py"}], "instruction": "Functionality: This function calculates the default color limits (min and max) based on the range of the input data type (dtype). It is designed to determine the appropriate color limits for visualization purposes, depending on whether the input dtype is a floating-point or integer type.\n\nInputs: \n    - dtype: A numpy data type. This can be any valid numpy dtype, such as np.float32, np.int16, etc.\n\nOutputs:\n    - A tuple of two values representing the minimum and maximum color limits. If the input dtype is a floating-point type, the output will be (0, 1). If the dtype is of integer type, the output will be the minimum and maximum values representable by the dtype, as determined by numpy's iinfo function.", "method_code_mask": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\n\n\ndef get_default_clim_from_dtype(dtype): [MASK]\n"}
{"method_name": "_as_rgba", "full_method_name": "_as_rgba", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/filters/mesh.py", "method_code": "import numbers\nimport numpy as np\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import VertexBuffer\nfrom vispy.visuals.shaders import Function\nfrom vispy.visuals.shaders import Varying\nfrom vispy.visuals.filters import Filter\nfrom vispy.visuals.filters import PrimitivePickingFilter\ndef _as_rgba(intensity_or_color, default_rgb=(1.0, 1.0, 1.0)):\n    \"\"\"Create an RGBA color from a color or a scalar intensity.\n\n    Examples\n    --------\n    >>> # Specify the full RGBA color.\n    >>> _as_rgba((0.2, 0.3, 0.4, 0.25))\n    ... <Color: (0.2, 0.3, 0.4, 0.25)>\n    >>> # Specify an RGB color. (Default intensity `1.0` is used.)\n    >>> _as_rgba((0.2, 0.3, 0.4))\n    ... <Color: (0.2, 0.3, 0.4, 1.0)>\n    >>> # Specify an intensity only. (Default color `(1.0, 1.0, 1.0)` is used.)\n    >>> _as_rgba(0.25)\n    ... <Color: (1.0, 1.0, 1.0, 0.25)>\n    \"\"\"\n    if isinstance(intensity_or_color, numbers.Number):\n        intensity = intensity_or_color\n        return Color(default_rgb, alpha=intensity)\n    color = intensity_or_color\n    return Color(color)", "test_code_list": [{"test_code": "import numpy as np\nfrom vispy import scene\nfrom vispy.color import Color\nfrom vispy.geometry import create_cube\nfrom vispy.geometry import create_sphere\nfrom vispy.testing import TestingCanvas\nfrom vispy.testing import requires_application\nfrom vispy.testing import run_tests_if_main\nfrom vispy.testing import requires_pyopengl\nfrom vispy.visuals.filters import ShadingFilter\nfrom vispy.visuals.filters import WireframeFilter\nfrom vispy.visuals.filters.mesh import _as_rgba\nimport pytest\nfrom vispy.visuals.transforms import STTransform\ndef test_intensity_or_color_as_rgba():\n    assert _as_rgba(0.3) == Color((1.0, 1.0, 1.0, 0.3))\n    assert _as_rgba((0.3, 0.2, 0.1)) == Color((0.3, 0.2, 0.1, 1.0))\n    assert _as_rgba((0.3, 0.2, 0.1, 0.5)) == Color((0.3, 0.2, 0.1, 0.5))\n\ntest_intensity_or_color_as_rgba()\n", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/visuals/tests/test_mesh.py"}], "instruction": "Functionality: The _as_rgba function is designed to create an RGBA color representation from either a scalar intensity value or a color tuple. It supports the creation of full RGBA colors from a 4-tuple, RGB colors from a 3-tuple (where it assumes an alpha value of 1.0), and an RGBA color from a single intensity value by using a default color with the specified intensity as the alpha value.\n\nInputs: \n1. intensity_or_color (Union[numbers.Number, Tuple[float, ...]]): This parameter can be a single numeric value representing intensity or a tuple of length 3 or 4 representing a color (RGB or RGBA).\n2. default_rgb (Tuple[float, float, float], optional): A tuple representing the default color to be used when an intensity is provided. It defaults to (1.0, 1.0, 1.0).\n\nOutputs: \n1. A Color object representing the RGBA color derived from the input. The output color will have 4 components: red, green, blue, and alpha (RGBA).", "method_code_mask": "import numbers\nimport numpy as np\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import VertexBuffer\nfrom vispy.visuals.shaders import Function\nfrom vispy.visuals.shaders import Varying\nfrom vispy.visuals.filters import Filter\nfrom vispy.visuals.filters import PrimitivePickingFilter\n\n\ndef _as_rgba(intensity_or_color, default_rgb=(1.0, 1.0, 1.0)): [MASK]\n"}
{"method_name": "requires_img_lib", "full_method_name": "requires_img_lib", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_img_lib():\n    \"\"\"Decorator for tests that require an image library\"\"\"\n    from ..io import _check_img_lib\n    if sys.platform.startswith('win'):\n        has_img_lib = False\n    else:\n        has_img_lib = not all(c is None for c in _check_img_lib())\n    return skipif(not has_img_lib, reason='imageio or PIL required')", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom os import path as op\nimport warnings\nfrom vispy.io import load_crate\nfrom vispy.io import imsave\nfrom vispy.io import imread\nfrom vispy.io import read_png\nfrom vispy.io import write_png\nfrom vispy.testing import requires_img_lib\nfrom vispy.testing import run_tests_if_main\nfrom vispy.util import _TempDir\ntemp_dir = _TempDir()\n@requires_img_lib()\ndef test_read_write_image():\n    \"\"\"Test reading and writing of images\"\"\"\n    fname = op.join(temp_dir, 'out.png')\n    im1 = load_crate()\n    imsave(fname, im1, format='png')\n    with warnings.catch_warnings(record=True):\n        im2 = imread(fname)\n    assert_allclose(im1, im2)\ntest_read_write_image()", "code_start": "", "test_path": "../srcdata/Visualization/vispy/vispy/io/tests/test_image.py"}], "instruction": "Functionality: The requires_img_lib function is a decorator designed to be used on test functions that require an image library, such as imageio or PIL, to run. It checks whether any of these image libraries are available in the current environment. If the system is running on a Windows platform or if none of the image libraries are found, the decorated test function will be skipped.\n\nInputs: This function does not take any input arguments. It uses the system environment (sys.platform) and the _check_img_lib() function from the io module to determine if an image library is present.\n\nOutputs: The function returns a decorator. When applied to a test function, the decorator will either allow the test function to run if an image library is found, or it will skip the test function and mark it as skipped with the reason 'imageio or PIL required' if no image library is present.", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_img_lib(): [MASK]\n"}
