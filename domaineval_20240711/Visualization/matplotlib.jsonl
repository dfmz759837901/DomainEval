{"method_name": "_azimuth2math", "full_method_name": "_azimuth2math", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py", "method_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi", "test_code_list": [{"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z\ndef test_light_source_hillshading():\n    \"\"\"\n    Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\n    \"\"\"\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= np.ptp(intensity)\n        return intensity\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)\ntest_light_source_hillshading()", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}, {"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z\ndef test_light_source_planar_hillshading():\n    \"\"\"\n    Ensure that the illumination intensity is correct for planar surfaces.\n    \"\"\"\n    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a * x + b * y) / c\n        return z\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))\ntest_light_source_planar_hillshading()", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}], "instruction": "Functionality: The _azimuth2math function is designed to convert azimuth and elevation angles from a clockwise-from-north and up-from-horizontal convention to mathematical conventions. This involves transforming the azimuth angle (measured clockwise from the north) and the elevation angle (measured upwards from the horizontal plane) into theta and phi angles, which are commonly used in spherical coordinate systems in mathematical contexts.\n\nInputs: \n- azimuth: A floating-point number representing the azimuth angle in degrees. This angle is measured clockwise from the north.\n- elevation: A floating-point number representing the elevation angle in degrees. This angle is measured upwards from the horizontal plane.\n\nOutputs:\n- theta: A floating-point number representing the transformed azimuth angle in radians. This angle follows the mathematical convention for measuring angles in the horizontal plane (typically from the positive x-axis).\n- phi: A floating-point number representing the transformed elevation angle in radians. This angle follows the mathematical convention for measuring angles in the vertical plane (typically from the positive z-axis).", "method_code_mask": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _azimuth2math(azimuth, elevation): [MASK]\n"}
{"method_name": "_sph2cart", "full_method_name": "_sph2cart", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py", "method_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z", "test_code_list": [{"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi\ndef test_light_source_hillshading():\n    \"\"\"\n    Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\n    \"\"\"\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= np.ptp(intensity)\n        return intensity\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)\ntest_light_source_hillshading()", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}, {"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi\ndef test_light_source_planar_hillshading():\n    \"\"\"\n    Ensure that the illumination intensity is correct for planar surfaces.\n    \"\"\"\n    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a * x + b * y) / c\n        return z\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))\ntest_light_source_planar_hillshading()", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}], "instruction": "Functionality: Convert spherical coordinates to Cartesian coordinates.\nInputs: Two 1D numpy arrays, theta and phi, representing the azimuthal and polar angles of points in spherical coordinates. The angles are in radians.\nOutputs: Three 1D numpy arrays, x, y, and z, representing the Cartesian coordinates of the points. The arrays have the same length as the input arrays theta and phi.", "method_code_mask": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _sph2cart(theta, phi): [MASK]\n"}
{"method_name": "temp_style", "full_method_name": "temp_style", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py", "method_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\nVALUE = 'pink'\nPARAM = 'image.cmap'\nDUMMY_SETTINGS = {PARAM: VALUE}\n@contextmanager\ndef temp_style(style_name, settings=None):\n    \"\"\"Context manager to create a style sheet in a temporary directory.\"\"\"\n    if not settings:\n        settings = DUMMY_SETTINGS\n    temp_file = f'{style_name}.{STYLE_EXTENSION}'\n    try:\n        with TemporaryDirectory() as tmpdir:\n            Path(tmpdir, temp_file).write_text('\\n'.join(f'{k}: {v}' for k,\n                v in settings.items()), encoding='utf-8')\n            USER_LIBRARY_PATHS.append(tmpdir)\n            style.reload_library()\n            yield\n    finally:\n        style.reload_library()", "test_code_list": [{"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_available():\n    with temp_style('_test_', DUMMY_SETTINGS):\n        assert '_test_' in style.available\n\ntest_available()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_use():\n    mpl.rcParams[PARAM] = 'gray'\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context('test'):\n            assert mpl.rcParams[PARAM] == VALUE\n\ntest_use()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context():\n    mpl.rcParams[PARAM] = 'gray'\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context('test'):\n            assert mpl.rcParams[PARAM] == VALUE\n    assert mpl.rcParams[PARAM] == 'gray'\n\ntest_context()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_dict_after_namedstyle():\n    original_value = 'gray'\n    other_value = 'blue'\n    mpl.rcParams[PARAM] = original_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context(['test', {PARAM: other_value}]):\n            assert mpl.rcParams[PARAM] == other_value\n    assert mpl.rcParams[PARAM] == original_value\n\ntest_context_with_dict_after_namedstyle()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_dict_before_namedstyle():\n    original_value = 'gray'\n    other_value = 'blue'\n    mpl.rcParams[PARAM] = original_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context([{PARAM: other_value}, 'test']):\n            assert mpl.rcParams[PARAM] == VALUE\n    assert mpl.rcParams[PARAM] == original_value\n\ntest_context_with_dict_before_namedstyle()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_union_of_dict_and_namedstyle():\n    original_value = 'gray'\n    other_param = 'text.usetex'\n    other_value = True\n    d = {other_param: other_value}\n    mpl.rcParams[PARAM] = original_value\n    mpl.rcParams[other_param] = not other_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context(['test', d]):\n            assert mpl.rcParams[PARAM] == VALUE\n            assert mpl.rcParams[other_param] == other_value\n    assert mpl.rcParams[PARAM] == original_value\n    assert mpl.rcParams[other_param] == (not other_value)\n\ntest_context_with_union_of_dict_and_namedstyle()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}], "instruction": "Functionality: The temp_style function is a context manager designed to create a temporary style sheet for matplotlib plotting in a safe, isolated environment. It writes a temporary style file with specific settings and adds the directory containing this file to the user style paths for matplotlib. This allows for temporary changes to the plotting style that are localized to the context in which the function is used, without affecting the global matplotlib style settings.\n\nInputs: \n- style_name (str): The name of the temporary style to be created.\n- settings (dict, optional): A dictionary containing the style settings. If not provided, a default setting is used, which changes the 'image.cmap' parameter to 'pink'.\n\nOutputs:\n- None: The function does not return any value but creates a temporary context in which the matplotlib style is modified according to the provided settings. When the context is exited (either by the end of the 'with' block or by an exception), the temporary style is removed, and the matplotlib style is reset to its previous state.", "method_code_mask": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\nVALUE = 'pink'\nPARAM = 'image.cmap'\nDUMMY_SETTINGS = {PARAM: VALUE}\n\n\n@contextmanager\ndef temp_style(style_name, settings=None): [MASK]\n"}
{"method_name": "draw_quiver", "full_method_name": "draw_quiver", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py", "method_code": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\ndef draw_quiver(ax, **kwargs):\n    X, Y = np.meshgrid(np.arange(0, 2 * np.pi, 1), np.arange(0, 2 * np.pi, 1))\n    U = np.cos(X)\n    V = np.sin(Y)\n    Q = ax.quiver(U, V, **kwargs)\n    return Q", "test_code_list": [{"test_code": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n@pytest.mark.skipif(platform.python_implementation() != 'CPython', reason=\n    'Requires CPython')\ndef test_quiver_memory_leak():\n    fig, ax = plt.subplots()\n    Q = draw_quiver(ax)\n    ttX = Q.X\n    Q.remove()\n    del Q\n    assert sys.getrefcount(ttX) == 2\n\ntest_quiver_memory_leak()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py"}, {"test_code": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n@pytest.mark.skipif(platform.python_implementation() != 'CPython', reason=\n    'Requires CPython')\ndef test_quiver_key_memory_leak():\n    fig, ax = plt.subplots()\n    Q = draw_quiver(ax)\n    qk = ax.quiverkey(Q, 0.5, 0.92, 2, '$2 \\\\frac{m}{s}$', labelpos='W',\n        fontproperties={'weight': 'bold'})\n    assert sys.getrefcount(qk) == 3\n    qk.remove()\n    assert sys.getrefcount(qk) == 2\n\ntest_quiver_key_memory_leak()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py"}], "instruction": "Functionality: The draw_quiver function is designed to visualize vector fields by drawing quiver plots using matplotlib. It takes a set of input arguments to generate a grid of arrows, where each arrow represents the vector at that point in the grid. The function generates a grid of points over the domain [0, 2\u03c0] x [0, 2\u03c0], and computes the cosine and sine at these points to generate the U and V components of the vectors. The quiver plot is then drawn on the given matplotlib axis using the computed U and V components.\n\nInputs: \n- ax: A matplotlib axis object where the quiver plot will be drawn.\n- **kwargs: Additional keyword arguments that can be used to customize the appearance of the quiver plot. These include parameters like 'angles', 'scale', 'width', 'headwidth', 'headlength', 'headaxislength', 'minshaft', 'minlength', 'pivot', 'color', etc.\n\nOutputs:\n- Q: The quiver object returned by matplotlib's quiver function, which can be used for further customization or inspection of the quiver plot properties.", "method_code_mask": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n\n\ndef draw_quiver(ax, **kwargs): [MASK]\n"}
{"method_name": "meshgrid_triangles", "full_method_name": "meshgrid_triangles", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py", "method_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef meshgrid_triangles(n):\n    \"\"\"\n    Return (2*(N-1)**2, 3) array of triangles to mesh (N, N)-point np.meshgrid.\n    \"\"\"\n    tri = []\n    for i in range(n - 1):\n        for j in range(n - 1):\n            a = i + j * n\n            b = i + 1 + j * n\n            c = i + (j + 1) * n\n            d = i + 1 + (j + 1) * n\n            tri += [[a, b, d], [a, d, c]]\n    return np.array(tri, dtype=np.int32)", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_triinterp():\n    x, y = np.meshgrid(np.arange(4), np.arange(4))\n    x = x.ravel()\n    y = y.ravel()\n    z = 1.23 * x - 4.79 * y\n    triangles = [[0, 1, 4], [1, 5, 4], [1, 2, 5], [2, 6, 5], [2, 3, 6], [3,\n        7, 6], [4, 5, 8], [5, 9, 8], [5, 6, 9], [6, 10, 9], [6, 7, 10], [7,\n        11, 10], [8, 9, 12], [9, 13, 12], [9, 10, 13], [10, 14, 13], [10, \n        11, 14], [11, 15, 14]]\n    mask = np.zeros(len(triangles))\n    mask[8:10] = 1\n    triang = mtri.Triangulation(x, y, triangles, mask)\n    linear_interp = mtri.LinearTriInterpolator(triang, z)\n    cubic_min_E = mtri.CubicTriInterpolator(triang, z)\n    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\n    xs = np.linspace(0.25, 2.75, 6)\n    ys = [0.25, 0.75, 2.25, 2.75]\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = interp(xs, ys)\n        assert_array_almost_equal(zs, 1.23 * xs - 4.79 * ys)\n    xs = [-0.25, 1.25, 1.75, 3.25]\n    ys = xs\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = linear_interp(xs, ys)\n        assert_array_equal(zs.mask, [[True] * 4] * 4)\n    xs = np.linspace(0.25, 1.75, 6)\n    ys = [0.25, 0.75, 1.25, 1.75]\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = interp(xs, ys)\n        matest.assert_array_almost_equal(zs, 1.23 * xs - 4.79 * ys)\n        mask = (xs >= 1) * (xs <= 2) * (ys >= 1) * (ys <= 2)\n        assert_array_equal(zs.mask, mask)\n    a, b, c = 1.23, -4.79, 0.6\n\n    def quad(x, y):\n        return a * (x - 0.5) ** 2 + b * (y - 0.5) ** 2 + c * x * y\n\n    def gradient_quad(x, y):\n        return 2 * a * (x - 0.5) + c * y, 2 * b * (y - 0.5) + c * x\n    x = np.array([0.2, 0.33367, 0.669, 0.0, 1.0, 1.0, 0.0])\n    y = np.array([0.3, 0.80755, 0.4335, 0.0, 0.0, 1.0, 1.0])\n    triangles = np.array([[0, 1, 2], [3, 0, 4], [4, 0, 2], [4, 2, 5], [1, 5,\n        2], [6, 5, 1], [6, 1, 0], [6, 0, 3]])\n    triang = mtri.Triangulation(x, y, triangles)\n    z = quad(x, y)\n    dz = gradient_quad(x, y)\n    xs = np.linspace(0.0, 1.0, 5)\n    ys = np.linspace(0.0, 1.0, 5)\n    xs, ys = np.meshgrid(xs, ys)\n    cubic_user = mtri.CubicTriInterpolator(triang, z, kind='user', dz=dz)\n    interp_zs = cubic_user(xs, ys)\n    assert_array_almost_equal(interp_zs, quad(xs, ys))\n    interp_dzsdx, interp_dzsdy = cubic_user.gradient(x, y)\n    dzsdx, dzsdy = gradient_quad(x, y)\n    assert_array_almost_equal(interp_dzsdx, dzsdx)\n    assert_array_almost_equal(interp_dzsdy, dzsdy)\n    n = 11\n    x, y = np.meshgrid(np.linspace(0.0, 1.0, n + 1), np.linspace(0.0, 1.0, \n        n + 1))\n    x = x.ravel()\n    y = y.ravel()\n    z = quad(x, y)\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1))\n    xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    xs = xs.ravel()\n    ys = ys.ravel()\n    linear_interp = mtri.LinearTriInterpolator(triang, z)\n    cubic_min_E = mtri.CubicTriInterpolator(triang, z)\n    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\n    zs = quad(xs, ys)\n    diff_lin = np.abs(linear_interp(xs, ys) - zs)\n    for interp in (cubic_min_E, cubic_geom):\n        diff_cubic = np.abs(interp(xs, ys) - zs)\n        assert np.max(diff_lin) >= 10 * np.max(diff_cubic)\n        assert np.dot(diff_lin, diff_lin) >= 100 * np.dot(diff_cubic,\n            diff_cubic)\n\ntest_triinterp()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}, {"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_tritools():\n    x = np.array([0.0, 1.0, 0.5, 0.0, 2.0])\n    y = np.array([0.0, 0.0, 0.5 * np.sqrt(3.0), -1.0, 1.0])\n    triangles = np.array([[0, 1, 2], [0, 1, 3], [1, 2, 4]], dtype=np.int32)\n    mask = np.array([False, False, True], dtype=bool)\n    triang = mtri.Triangulation(x, y, triangles, mask=mask)\n    analyser = mtri.TriAnalyzer(triang)\n    assert_array_almost_equal(analyser.scale_factors, [1, 1 / (1 + 3 ** 0.5 /\n        2)])\n    assert_array_almost_equal(analyser.circle_ratios(rescale=False), np.ma.\n        masked_array([0.5, 1.0 / (1.0 + np.sqrt(2.0)), np.nan], mask))\n    x = np.array([0.0, 1.0, 2.0])\n    y = np.array([1.0, 1.0 + 3.0, 1.0 + 6.0])\n    triangles = np.array([[0, 1, 2]], dtype=np.int32)\n    triang = mtri.Triangulation(x, y, triangles)\n    analyser = mtri.TriAnalyzer(triang)\n    assert_array_almost_equal(analyser.circle_ratios(), np.array([0.0]))\n    n = 9\n\n    def power(x, a):\n        return np.abs(x) ** a * np.sign(x)\n    x = np.linspace(-1.0, 1.0, n + 1)\n    x, y = np.meshgrid(power(x, 2.0), power(x, 0.25))\n    x = x.ravel()\n    y = y.ravel()\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1))\n    analyser = mtri.TriAnalyzer(triang)\n    mask_flat = analyser.get_flat_tri_mask(0.2)\n    verif_mask = np.zeros(162, dtype=bool)\n    corners_index = [0, 1, 2, 3, 14, 15, 16, 17, 18, 19, 34, 35, 126, 127, \n        142, 143, 144, 145, 146, 147, 158, 159, 160, 161]\n    verif_mask[corners_index] = True\n    assert_array_equal(mask_flat, verif_mask)\n    mask = np.zeros(162, dtype=bool)\n    mask[80] = True\n    triang.set_mask(mask)\n    mask_flat = analyser.get_flat_tri_mask(0.2)\n    center_index = [44, 45, 62, 63, 78, 79, 80, 81, 82, 83, 98, 99, 116, 117]\n    verif_mask[center_index] = True\n    assert_array_equal(mask_flat, verif_mask)\n\ntest_tritools()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}, {"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_trirefine():\n    n = 3\n    subdiv = 2\n    x = np.linspace(-1.0, 1.0, n + 1)\n    x, y = np.meshgrid(x, x)\n    x = x.ravel()\n    y = y.ravel()\n    mask = np.zeros(2 * n ** 2, dtype=bool)\n    mask[n ** 2:] = True\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1),\n        mask=mask)\n    refiner = mtri.UniformTriRefiner(triang)\n    refi_triang = refiner.refine_triangulation(subdiv=subdiv)\n    x_refi = refi_triang.x\n    y_refi = refi_triang.y\n    n_refi = n * subdiv ** 2\n    x_verif = np.linspace(-1.0, 1.0, n_refi + 1)\n    x_verif, y_verif = np.meshgrid(x_verif, x_verif)\n    x_verif = x_verif.ravel()\n    y_verif = y_verif.ravel()\n    ind1d = np.isin(np.around(x_verif * (2.5 + y_verif), 8), np.around(\n        x_refi * (2.5 + y_refi), 8))\n    assert_array_equal(ind1d, True)\n    refi_mask = refi_triang.mask\n    refi_tri_barycenter_x = np.sum(refi_triang.x[refi_triang.triangles], axis=1\n        ) / 3.0\n    refi_tri_barycenter_y = np.sum(refi_triang.y[refi_triang.triangles], axis=1\n        ) / 3.0\n    tri_finder = triang.get_trifinder()\n    refi_tri_indices = tri_finder(refi_tri_barycenter_x, refi_tri_barycenter_y)\n    refi_tri_mask = triang.mask[refi_tri_indices]\n    assert_array_equal(refi_mask, refi_tri_mask)\n    x = np.asarray([0.0, 1.0, 0.0, 1.0])\n    y = np.asarray([0.0, 0.0, 1.0, 1.0])\n    triang = [mtri.Triangulation(x, y, [[0, 1, 3], [3, 2, 0]]), mtri.\n        Triangulation(x, y, [[0, 1, 3], [2, 0, 3]])]\n    z = np.hypot(x - 0.3, y - 0.4)\n    xyz_data = []\n    for i in range(2):\n        refiner = mtri.UniformTriRefiner(triang[i])\n        refined_triang, refined_z = refiner.refine_field(z, subdiv=1)\n        xyz = np.dstack((refined_triang.x, refined_triang.y, refined_z))[0]\n        xyz = xyz[np.lexsort((xyz[:, 1], xyz[:, 0]))]\n        xyz_data += [xyz]\n    assert_array_almost_equal(xyz_data[0], xyz_data[1])\n\ntest_trirefine()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}], "instruction": "Functionality: The function meshgrid_triangles is designed to generate a set of triangles that can be used to mesh a grid created by np.meshgrid. This is particularly useful for plotting surfaces or creating triangular meshes for finite element methods on a rectangular grid.\n\nInputs: \n- n: an integer representing the size of the grid (N x N). The grid will have N points along each dimension.\n\nOutputs: \n- A 2D NumPy array with shape (2*(N-1)**2, 3) where each row represents a triangle, given by the indices of its three vertices. The vertices correspond to the points on the (N, N)-point grid created by np.meshgrid. The array elements are of type np.int32.", "method_code_mask": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\n\n\ndef meshgrid_triangles(n): [MASK]\n"}
{"method_name": "example_plot", "full_method_name": "example_plot", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py", "method_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef example_plot(ax, fontsize=12, nodec=False):\n    ax.plot([1, 2])\n    ax.locator_params(nbins=3)\n    if not nodec:\n        ax.set_xlabel('x-label', fontsize=fontsize)\n        ax.set_ylabel('y-label', fontsize=fontsize)\n        ax.set_title('Title', fontsize=fontsize)\n    else:\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])", "test_code_list": [{"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_constrained_layout18():\n    \"\"\"Test twinx\"\"\"\n    fig, ax = plt.subplots(layout='constrained')\n    ax2 = ax.twinx()\n    example_plot(ax)\n    example_plot(ax2, fontsize=24)\n    fig.draw_without_rendering()\n    assert all(ax.get_position().extents == ax2.get_position().extents)\n\ntest_constrained_layout18()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}, {"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_constrained_layout19():\n    \"\"\"Test twiny\"\"\"\n    fig, ax = plt.subplots(layout='constrained')\n    ax2 = ax.twiny()\n    example_plot(ax)\n    example_plot(ax2, fontsize=24)\n    ax2.set_title('')\n    ax.set_title('')\n    fig.draw_without_rendering()\n    assert all(ax.get_position().extents == ax2.get_position().extents)\n\ntest_constrained_layout19()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}], "instruction": "Functionality: This function, example_plot, is designed to create a simple line plot on a given axes object (ax) from matplotlib library. It plots a line with two points [1, 2], adjusts the number of bins for the tick locator to 3, and optionally sets the x-label, y-label, and title with a specified fontsize or clears the tick labels.\n\nInputs: \n- ax: A matplotlib.axes.Axes object on which the plot will be drawn.\n- fontsize: An integer that sets the font size for labels and title. Default is 12.\n- nodec: A boolean flag that controls whether to display labels and title. If True, the x and y tick labels will be removed. If False (default), labels and title will be added to the plot.\n\nOutputs:\n- This function does not return any value explicitly but modifies the given axes object (ax) in place by plotting a line and setting labels, title, or removing tick labels based on the input parameters.", "method_code_mask": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_plot(ax, fontsize=12, nodec=False): [MASK]\n"}
{"method_name": "example_pcolor", "full_method_name": "example_pcolor", "method_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py", "method_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef example_pcolor(ax, fontsize=12):\n    dx, dy = 0.6, 0.6\n    y, x = np.mgrid[slice(-3, 3 + dy, dy), slice(-3, 3 + dx, dx)]\n    z = (1 - x / 2.0 + x ** 5 + y ** 3) * np.exp(-x ** 2 - y ** 2)\n    pcm = ax.pcolormesh(x, y, z[:-1, :-1], cmap='RdBu_r', vmin=-1.0, vmax=\n        1.0, rasterized=True)\n    ax.set_xlabel('x-label', fontsize=fontsize)\n    ax.set_ylabel('y-label', fontsize=fontsize)\n    ax.set_title('Title', fontsize=fontsize)\n    return pcm", "test_code_list": [{"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_colorbar_align():\n    for location in ['right', 'left', 'top', 'bottom']:\n        fig, axs = plt.subplots(2, 2, layout='constrained')\n        cbs = []\n        for nn, ax in enumerate(axs.flat):\n            ax.tick_params(direction='in')\n            pc = example_pcolor(ax)\n            cb = fig.colorbar(pc, ax=ax, location=location, shrink=0.6, pad\n                =0.04)\n            cbs += [cb]\n            cb.ax.tick_params(direction='in')\n            if nn != 1:\n                cb.ax.xaxis.set_ticks([])\n                cb.ax.yaxis.set_ticks([])\n                ax.set_xticklabels([])\n                ax.set_yticklabels([])\n        fig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0.1,\n            wspace=0.1)\n        fig.draw_without_rendering()\n        if location in ['left', 'right']:\n            np.testing.assert_allclose(cbs[0].ax.get_position().x0, cbs[2].\n                ax.get_position().x0)\n            np.testing.assert_allclose(cbs[1].ax.get_position().x0, cbs[3].\n                ax.get_position().x0)\n        else:\n            np.testing.assert_allclose(cbs[0].ax.get_position().y0, cbs[1].\n                ax.get_position().y0)\n            np.testing.assert_allclose(cbs[2].ax.get_position().y0, cbs[3].\n                ax.get_position().y0)\n\ntest_colorbar_align()\n", "code_start": "", "test_path": "../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}], "instruction": "Functionality: This function, example_pcolor, is designed to create a pseudocolor plot using matplotlib's pcolormesh function. It generates a grid of data points, computes a function over these points, and plots the result as a pseudocolor plot using a specified colormap and bounds.\n\nInputs:\n- ax: A matplotlib.axes.Axes object where the plot will be created.\n- fontsize (optional): An integer representing the font size for the plot's labels and title. The default value is 12.\n\nOutputs:\n- pcm: A matplotlib.collections.QuadMesh object, which is the pseudocolor plot generated by the pcolormesh function. This can be used for further customization of the plot.", "method_code_mask": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_pcolor(ax, fontsize=12): [MASK]\n"}
