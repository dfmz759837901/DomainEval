{"method_name": "get_fileno", "full_method_name": "get_fileno", "method_path": "../srcdata/Visualization/rich/rich/_fileno.py", "method_code": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\ndef get_fileno(file_like: IO[str]) ->(int | None):\n    \"\"\"Get fileno() from a file, accounting for poorly implemented file-like objects.\n\n    Args:\n        file_like (IO): A file-like object.\n\n    Returns:\n        int | None: The result of fileno if available, or None if operation failed.\n    \"\"\"\n    fileno: Callable[[], int] | None = getattr(file_like, 'fileno', None)\n    if fileno is not None:\n        try:\n            return fileno()\n        except Exception:\n            return None\n    return None", "test_code_list": [{"test_code": "def test_get_fileno():\n\n\n    class FileLike:\n\n        def fileno(self) ->int:\n            return 123\n    assert get_fileno(FileLike()) == 123\n\ntest_get_fileno()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}, {"test_code": "def test_get_fileno_missing():\n\n\n    class FileLike:\n        pass\n    assert get_fileno(FileLike()) is None\n\ntest_get_fileno_missing()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}, {"test_code": "def test_get_fileno_broken():\n\n\n    class FileLike:\n\n        def fileno(self) ->int:\n            1 / 0\n            return 123\n    assert get_fileno(FileLike()) is None\n\ntest_get_fileno_broken()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}], "instruction": "Functionality: The get_fileno function is designed to retrieve the file descriptor number (fileno) from a file-like object, handling cases where the object may not properly implement the fileno method or where the method call might raise an exception.\n\nInputs: \n- file_like: A file-like object (IO[str]) from which the file descriptor number is to be retrieved. This object should mimic the behavior of a file, and it may or may not have a properly implemented fileno method.\n\nOutputs: \n- int | None: The function returns an integer representing the file descriptor number if the fileno method is available and successfully executed. If the fileno method is not available or if its execution raises an exception, the function returns None.", "method_code_mask": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\n\n\ndef get_fileno(file_like: IO[str]) ->(int | None): [MASK]\n"}
{"method_name": "loop_first", "full_method_name": "loop_first", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first value.\"\"\"\n    iter_values = iter(values)\n    try:\n        value = next(iter_values)\n    except StopIteration:\n        return\n    yield True, value\n    for value in iter_values:\n        yield False, value", "test_code_list": [{"test_code": "def test_loop_first():\n    assert list(loop_first([])) == []\n    iterable = loop_first(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (True, 'apples')\n    assert next(iterable) == (False, 'oranges')\n    assert next(iterable) == (False, 'pears')\n    assert next(iterable) == (False, 'lemons')\n\ntest_loop_first()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "instruction": "Functionality: The loop_first function is designed to iterate over a given iterable collection and generate a tuple for each element. The tuple consists of a boolean flag and the element itself. The flag indicates whether the element is the first one in the iterable. For the first element, the flag will be True; for all subsequent elements, the flag will be False.\n\nInputs: The function takes one input argument:\n- values: An iterable collection of elements of any data type. This can include lists, tuples, sets, or any other iterable object.\n\nOutputs: The function yields an iterable of tuples. Each tuple contains:\n- A boolean value indicating whether the current element is the first in the iterable (True for the first element, False for all others).\n- The element from the input iterable.", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n"}
{"method_name": "loop_last", "full_method_name": "loop_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value", "test_code_list": [{"test_code": "def test_loop_last():\n    assert list(loop_last([])) == []\n    iterable = loop_last(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (False, 'apples')\n    assert next(iterable) == (False, 'oranges')\n    assert next(iterable) == (False, 'pears')\n    assert next(iterable) == (True, 'lemons')\n\ntest_loop_last()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "instruction": "Functionality: The function 'loop_last' is designed to iterate over an iterable collection of elements. It generates and returns a tuple for each element, where the first element of the tuple is a boolean flag indicating whether the current element is the last one in the collection, and the second element is the element itself.\n\nInputs: \n1. 'values' - This is an iterable collection of elements of any type. The elements could be of any data type, including but not limited to integers, strings, floats, etc. \n\nOutputs:\nThe function yields an iterable collection of tuples. Each tuple contains:\n1. A boolean value - 'True' if the current element is the last one in the collection, and 'False' otherwise.\n2. The current element from the input iterable collection.", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n"}
{"method_name": "loop_first_last", "full_method_name": "loop_first_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first and last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    first = True\n    for value in iter_values:\n        yield first, False, previous_value\n        first = False\n        previous_value = value\n    yield first, True, previous_value", "test_code_list": [{"test_code": "def test_loop_first_last():\n    assert list(loop_first_last([])) == []\n    iterable = loop_first_last(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (True, False, 'apples')\n    assert next(iterable) == (False, False, 'oranges')\n    assert next(iterable) == (False, False, 'pears')\n    assert next(iterable) == (False, True, 'lemons')\n\ntest_loop_first_last()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "instruction": "Functionality: The loop_first_last function is an iterator that processes a given iterable sequence of values, yielding a tuple for each value. The tuple contains a boolean indicating whether the value is the first in the sequence, a boolean indicating whether the value is the last in the sequence, and the value itself.\n\nInputs: An iterable (values) of any type T, where T is a generic type variable.\n\nOutputs: An iterator that yields tuples of type (bool, bool, T), where:\n- The first bool indicates whether the current value is the first value in the sequence.\n- The second bool indicates whether the current value is the last value in the sequence.\n- T is the current value from the input iterable.", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]: [M\n    ASK]\n"}
{"method_name": "escape", "full_method_name": "escape", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "method_code": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n    Args:\n        markup (str): Content to be inserted in to markup.\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n    def escape_backslashes(match: Match[str]) ->str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f'{backslashes}{backslashes}\\\\{text}'\n    markup = _escape(escape_backslashes, markup)\n    if markup.endswith('\\\\') and not markup.endswith('\\\\\\\\'):\n        return markup + '\\\\'\n    return markup", "test_code_list": [{"test_code": "import pytest\ndef test_escape():\n    assert escape('foo[bar]') == 'foo\\\\[bar]'\n    assert escape('foo\\\\[bar]') == 'foo\\\\\\\\\\\\[bar]'\n    assert escape('[5]') == '[5]'\n    assert escape('\\\\[5]') == '\\\\[5]'\n    assert escape('[@foo]') == '\\\\[@foo]'\n    assert escape('[@]') == '\\\\[@]'\n    assert escape('[nil, [nil]]') == '[nil, \\\\[nil]]'\n\ntest_escape()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}], "instruction": "Functionality: The function 'escape' is designed to escape text so that it won't be interpreted as markup. It ensures that any text inserted into markup is properly formatted to prevent misinterpretation as markup code. The function specifically focuses on escaping square brackets by preceding them with backslashes.\n\nInputs:\n    markup: str\n        The input string that needs to be escaped. This is the text content that will be inserted into markup and may contain characters that could be misinterpreted as markup elements.\n\nOutputs:\n    str\n        The escaped markup string. The function returns a version of the input string where square brackets have been escaped with backslashes to prevent them from being interpreted as markup elements.\n        \nNote: The function also includes a helper function 'escape_backslashes' that is used internally by 're.sub' to handle the replacement of backslashes and square brackets in the input string. The function performs additional checks to ensure that trailing backslashes are correctly escaped.", "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\n\n\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str: [MASK]\n"}
{"method_name": "_parse", "full_method_name": "_parse", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "method_code": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n    Args:\n        markup (str): A string containing console markup\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                yield start, '\\\\' * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                yield start, full_text[len(escapes):], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition('=')\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None", "test_code_list": [{"test_code": "import pytest\ndef test_parse():\n    result = list(_parse('[foo]hello[/foo][bar]world[/]\\\\[escaped]'))\n    expected = [(0, None, Tag(name='foo', parameters=None)), (10, 'hello',\n        None), (10, None, Tag(name='/foo', parameters=None)), (16, None,\n        Tag(name='bar', parameters=None)), (26, 'world', None), (26, None,\n        Tag(name='/', parameters=None)), (29, '[escaped]', None)]\n    print(repr(result))\n    assert result == expected\n\ntest_parse()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}, {"test_code": "import pytest\ndef test_parse_link():\n    result = list(_parse('[link=foo]bar[/link]'))\n    expected = [(0, None, Tag(name='link', parameters='foo')), (13, 'bar',\n        None), (13, None, Tag(name='/link', parameters=None))]\n    assert result == expected\n\ntest_parse_link()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}], "instruction": "Functionality: The _parse function is designed to parse a given string containing console markup into an iterable of tuples. Each tuple contains the position of the element in the original string, the text (if present), and a Tag object (if a markup tag is found).\n\nInputs: \n- markup (str): A string containing console markup. The string may include various tags enclosed in square brackets, such as [bold], [italic], or [color=red], among others. It can also contain escaped square brackets (\\\\[ and \\\\]) and backslashes.\n\nOutputs: \n- Iterable[Tuple[int, Optional[str], Optional[Tag]]]: An iterable of tuples, where each tuple consists of three elements:\n    - The position (int) of the element in the original markup string.\n    - The text (str) that is not part of any tag, or None if the element is a tag.\n    - A Tag object if a tag is found at the position, or None if the element is plain text.", "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\n\n\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]: [\n    MASK]\n"}
{"method_name": "decimal", "full_method_name": "decimal", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "method_code": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str:\n    \"\"\"Convert a filesize in to a string (powers of 1000, SI prefixes).\n    In this convention, ``1000 B = 1 kB``.\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = \" \").\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n    Example:\n        >>> filesize.decimal(30000)\n        '30.0 kB'\n        >>> filesize.decimal(30000, precision=2, separator=\"\")\n        '30.00kB'\n    \"\"\"\n    return _to_str(size, ('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'),\n        1000, precision=precision, separator=separator)", "test_code_list": [{"test_code": "def test_traditional():\n    assert decimal(0) == '0 bytes'\n    assert decimal(1) == '1 byte'\n    assert decimal(2) == '2 bytes'\n    assert decimal(1000) == '1.0 kB'\n    assert decimal(1.5 * 1000 * 1000) == '1.5 MB'\n    assert decimal(0, precision=2) == '0 bytes'\n    assert decimal(1111, precision=0) == '1 kB'\n    assert decimal(1111, precision=1) == '1.1 kB'\n    assert decimal(1111, precision=2) == '1.11 kB'\n    assert decimal(1111, separator='') == '1.1kB'\n\ntest_traditional()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_filesize.py"}], "instruction": "Functionality: Convert a filesize into a string with SI prefixes (powers of 1000). This function adheres to the convention where 1000 bytes equal 1 kilobyte, typically used for reporting storage capacity in USB drives and by Mac OS X since v10.6.\n\nInputs: \n    int size: The file size in bytes.\n    int precision (optional): The number of decimal places to include in the output (default = 1).\n    str separator (optional): The string to separate the value from the units (default = \" \").\n\nOutputs: \n    str: A string composed of the abbreviated file size and units, based on the input file size.", "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\n\n\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str: [MASK]\n"}
{"method_name": "pick_unit_and_suffix", "full_method_name": "pick_unit_and_suffix", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "method_code": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]:\n    \"\"\"Pick a suffix and base for the given size.\"\"\"\n    for i, suffix in enumerate(suffixes):\n        unit = base ** i\n        if size < unit * base:\n            break\n    return unit, suffix", "test_code_list": [{"test_code": "def test_pick_unit_and_suffix():\n    units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n    assert pick_unit_and_suffix(50, units, 1024) == (1, 'bytes')\n    assert pick_unit_and_suffix(2048, units, 1024) == (1024, 'KB')\n\ntest_pick_unit_and_suffix()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_filesize.py"}], "instruction": "Functionality: The pick_unit_and_suffix function is designed to select an appropriate unit and its corresponding suffix for a given size. This function is particularly useful in scenarios where data sizes need to be represented in human-readable formats, such as converting bytes to kilobytes, megabytes, etc. The function iterates through a list of suffixes, comparing the given size to units derived from the base to determine the most suitable unit and suffix.\n\nInputs: \n- size: An integer representing the size for which a unit and suffix are to be determined.\n- suffixes: A list of strings, each representing a suffix for a unit (e.g., 'B', 'KB', 'MB', 'GB').\n- base: An integer that defines the base for calculating unit sizes. For example, a base of 1024 is commonly used for binary data sizes.\n\nOutputs: \n- A tuple consisting of two elements:\n    1. An integer representing the unit size that is less than or equal to the given size but greater than the size divided by the base.\n    2. A string from the suffixes list that corresponds to the determined unit size.", "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]: [MASK]\n"}
