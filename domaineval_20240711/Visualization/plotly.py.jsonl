{"method_name": "get_non_empty_subplots", "full_method_name": "get_non_empty_subplots", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py", "method_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\ndef get_non_empty_subplots(fig, selector):\n    gr = fig._validate_get_grid_ref()\n    nrows = len(gr)\n    ncols = len(gr[0])\n    sp_addresses = product(range(nrows), range(ncols))\n    ret = list(filter(lambda sp: fig._subplot_not_empty(*\n        translate_layout_keys(sp.layout_keys), selector=selector), [gr[r][c\n        ][0] for r, c in sp_addresses]))\n    return ret", "test_code_list": [{"test_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef all_combos(it):\n    return list(reduce(lambda a, b: a + b, [list(combinations(it, r)) for r in\n        range(1, len(it))], []))\ndef test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5\n        ), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert len(selectors) == len(subplot_combos)\n    for s, spc in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert sps == spc\ntest_choose_correct_non_empty_subplots()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py"}], "instruction": "Functionality: Get non-empty subplots from a Plotly figure. This function aims to identify and return those subplots within a multi-subplot figure that contain actual trace data, based on a specified selector condition.\nInputs: \n- fig (go.Figure): A Plotly figure object. This object should contain multiple subplots.\n- selector (function): A function used to determine if a subplot should be considered non-empty. This selector function takes in the subplot's layout keys (in the form of xaxis and yaxis) and returns a boolean value indicating whether the subplot contains data.\nOutputs:\n- List of subplot elements that are deemed non-empty. Each element in the output list is a subplot from the provided Plotly figure that meets the criteria specified by the selector function.", "method_code_mask": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\n\n\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\n\n\ndef get_non_empty_subplots(fig, selector): [MASK]\n"}
{"method_name": "all_combos", "full_method_name": "all_combos", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py", "method_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef all_combos(it):\n    return list(reduce(lambda a, b: a + b, [list(combinations(it, r)) for r in\n        range(1, len(it))], []))", "test_code_list": [{"test_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\ndef get_non_empty_subplots(fig, selector):\n    gr = fig._validate_get_grid_ref()\n    nrows = len(gr)\n    ncols = len(gr[0])\n    sp_addresses = product(range(nrows), range(ncols))\n    ret = list(filter(lambda sp: fig._subplot_not_empty(*\n        translate_layout_keys(sp.layout_keys), selector=selector), [gr[r][c\n        ][0] for r, c in sp_addresses]))\n    return ret\ndef test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5\n        ), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert len(selectors) == len(subplot_combos)\n    for s, spc in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert sps == spc\ntest_choose_correct_non_empty_subplots()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py"}], "instruction": "Functionality: The function all_combos takes an iterable as input and returns a list containing all possible combinations of the elements in the iterable, with varying lengths from 1 to the length of the iterable. This means it includes combinations of all lengths from single-element to (length-1)-element combinations.\nInputs: \n    it: An iterable (like a list or a string) from which combinations are to be derived. The iterable must contain at least one element, and there is no maximum limit on the number of elements it can contain.\n\nOutputs: \n    A list of tuples, where each tuple represents a unique combination of elements from the input iterable. The list will include all possible combinations from single-element tuples to tuples containing (length-1) elements, where length is the total number of elements in the iterable.", "method_code_mask": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\n\n\ndef all_combos(it): [MASK]\n"}
{"method_name": "return_prop_descriptions", "full_method_name": "return_prop_descriptions", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py", "method_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\ndef return_prop_descriptions(prop_descrip_text):\n    raw_matches = re.findall(\"\"\"\n        [a-z]+|        [a-z]+\n\"\"\",\n        prop_descrip_text)\n    matches = []\n    for r in raw_matches:\n        r = r.replace(' ', '')\n        r = r.replace('\\n', '')\n        matches.append(r)\n    return matches", "test_code_list": [{"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    @pytest.mark.nodev\n    def test_deeply_nested_layout_attributes(self):\n        frames = Frame\n        frames.layout = [Layout()]\n        frames.layout[0].xaxis.showexponent = 'all'\n        prop_descrip_text = frames.layout[0].font._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        self.assertEqual(set(matches), {'color', 'family', 'size', 'weight',\n            'variant', 'style'})\n    \nFramesTest().test_deeply_nested_layout_attributes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}, {"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    def test_deeply_nested_data_attributes(self):\n        frames = Frame\n        frames.data = [Bar()]\n        frames.data[0].marker.color = 'red'\n        prop_descrip_text = frames.data[0].marker.line._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        matches = [m for m in matches if m != 'cmid']\n        self.assertEqual(set(matches), {'colorsrc', 'autocolorscale', 'cmin',\n            'colorscale', 'color', 'reversescale', 'width', 'cauto', 'widthsrc',\n            'cmax', 'coloraxis'})\n    \nFramesTest().test_deeply_nested_data_attributes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}, {"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    def test_frame_only_attrs(self):\n        frames = Frame\n        frames.frame = [Frame()]\n        prop_descrip_text = frames.frame[0]._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        self.assertEqual(set(matches), {'group', 'name', 'data', 'layout',\n            'baseframe', 'traces'})\n    \nFramesTest().test_frame_only_attrs()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}], "instruction": "Functionality: The function 'return_prop_descriptions' is designed to parse a given text string and extract property descriptions. It utilizes regular expressions to identify and return a list of property descriptions, stripping away any spaces or new line characters in the process.\n\nInputs: \n- prop_descrip_text: A string containing property descriptions. The property descriptions are sequences of lowercase letters that may be separated by spaces or new lines.\n\nOutputs:\n- A list of strings, where each string is a property description extracted from the input text. Spaces and new line characters are removed from the property descriptions before they are added to the list.", "method_code_mask": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\n\ndef return_prop_descriptions(prop_descrip_text): [MASK]\n"}
{"method_name": "build_invalid_fig", "full_method_name": "build_invalid_fig", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_validate.py", "method_code": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\ndef build_invalid_fig():\n    return dict(data=[{'type': 'bar', 'y': 'not_a_list', 'bogus': 23}],\n        layout_title_text='valid title', layout_colorway='not a dict')", "test_code_list": [{"test_code": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\nexpected_invalid_dict = dict(data=[{'type': 'bar', 'y': 'not_a_list',\n    'bogus': 23}], layout={'title': {'text': 'valid title'}, 'colorway':\n    'not a dict'})\ndef test_validate_false():\n    template = pio.templates.default\n    try:\n        pio.templates.default = None\n        fig = go.Figure(_validate=False, **build_invalid_fig())\n        assert json.loads(fig.to_json()) == expected_invalid_dict\n        with pytest.raises(ValueError):\n            go.Figure(_validate=True, **build_invalid_fig())\n    finally:\n        pio.templates.default = template\ntest_validate_false()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_validate.py"}], "instruction": "Functionality: The function 'build_invalid_fig' is designed to construct an invalid figure object for Plotly. This object will be used to test the robustness and error handling capabilities of the Plotly library when encountering misformatted or incorrect data structures.\n\nInputs: There are no input arguments required for this function. The function is intended to internally generate and return a misformatted figure object.\n\nOutputs: The function returns a dictionary that represents an invalid figure object for Plotly. The dictionary should include the following keys: 'data' and 'layout'. The 'data' key should contain a list with a single dictionary that represents invalid data - in this case, a 'bar' type plot with an incorrect format for the 'y' attribute and an undefined 'bogus' attribute. The 'layout' part of the dictionary is intentionally misformatted by providing a 'title_text' attribute under the 'layout' key, instead of directly under the dictionary root, and setting the 'colorway' attribute to a value that is not a dictionary, thus violating the expected data structure for Plotly figure objects.", "method_code_mask": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\n\n\ndef build_invalid_fig(): [MASK]\n"}
{"method_name": "mocked_scope", "full_method_name": "mocked_scope", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "method_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope", "test_code_list": [{"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_kaleido_engine_to_image():\n    with mocked_scope() as scope:\n        pio.to_image(fig, engine='kaleido', validate=False)\n    scope.transform.assert_called_with(fig, format=None, width=None, height\n        =None, scale=None)\ntest_kaleido_engine_to_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n    These mocks should be passed as the `file=` argument to `write_image()`.\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path\ndef test_kaleido_engine_write_image():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, engine='kaleido', validate\n                =False)\n        scope.transform.assert_called_with(fig, format=writeable_mock.\n            expected_format, width=None, height=None, scale=None)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_kaleido_engine_to_image_kwargs():\n    with mocked_scope() as scope:\n        pio.to_image(fig, format='pdf', width=700, height=600, scale=2,\n            engine='kaleido', validate=False)\n    scope.transform.assert_called_with(fig, format='pdf', width=700, height\n        =600, scale=2)\ntest_kaleido_engine_to_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n    These mocks should be passed as the `file=` argument to `write_image()`.\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path\ndef test_kaleido_engine_write_image_kwargs():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, format='jpg', width=700,\n                height=600, scale=2, engine='kaleido', validate=False)\n        scope.transform.assert_called_with(fig, format='jpg', width=700,\n            height=600, scale=2)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}], "instruction": "Functionality: The mocked_scope function is designed to temporarily replace the current scope of Plotly's IO module with a mock object for the duration of a test. This allows for testing scenarios where the behavior of the scope needs to be controlled or inspected without affecting the actual scope. The function uses a context manager to ensure that the original scope is restored after the test, maintaining the integrity of the global state.\n\nInputs: There are no input arguments for the mocked_scope function. It is a context manager that is used in a 'with' statement. When called, it yields a Mock object that temporarily replaces the scope.\n\nOutputs: The function yields a Mock object which can be used to replace the current scope of Plotly's IO module. This Mock object can be used to control and inspect the behavior of the scope during tests. After the 'with' block is executed, the original scope is automatically restored, ensuring that the test environment does not affect the global state.", "method_code_mask": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\n\n@contextmanager\ndef mocked_scope(): [MASK]\n"}
{"method_name": "make_writeable_mocks", "full_method_name": "make_writeable_mocks", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "method_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n\n    These mocks should be passed as the `file=` argument to `write_image()`.\n\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path", "test_code_list": [{"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope\ndef test_kaleido_engine_write_image():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, engine='kaleido', validate\n                =False)\n        scope.transform.assert_called_with(fig, format=writeable_mock.\n            expected_format, width=None, height=None, scale=None)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope\ndef test_kaleido_engine_write_image_kwargs():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, format='jpg', width=700,\n                height=600, scale=2, engine='kaleido', validate=False)\n        scope.transform.assert_called_with(fig, format='jpg', width=700,\n            height=600, scale=2)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}], "instruction": "Functionality: \nThe `make_writeable_mocks` function is designed to create mock objects that mimic writable file descriptors and pathlib.Path objects. These mocks are intended for use in testing the `write_image()` function. The purpose is to verify that the `write_image()` function calls the appropriate method on the mock objects and that it does so with the correct arguments, specifically for the format of the image.\n\nInputs: \nThere are no inputs required for the `make_writeable_mocks` function. It does not take any arguments.\n\nOutputs: \nThe function returns a tuple containing two mock objects:\n1. `mock_file_descriptor`: A mock object designed to imitate a writable file descriptor. It has an attribute `active_write_function` set to its `write` method, which is to be called by `write_image()`. There is also an `expected_format` attribute that should be None, as it is not expected to be used with file descriptors.\n2. `mock_pathlib_path`: A mock object designed to imitate a `pathlib.Path` object. It has an attribute `active_write_function` set to its `write_bytes` method, which is to be called by `write_image()`. It also has a `suffix` attribute set to '.png', and an `expected_format` attribute set to 'png', which should be the format argument passed to the method when `write_image()` is called.", "method_code_mask": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\n\ndef make_writeable_mocks(): [MASK]\n"}
{"method_name": "replace_div_id", "full_method_name": "replace_div_id", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_io/test_pathlib.py", "method_code": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\ndef replace_div_id(s):\n    uuid = re.search('<div id=\"([^\"]*)\"', s).groups()[0]\n    return s.replace(uuid, 'XXXX')", "test_code_list": [{"test_code": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_write_html():\n    \"\"\"Verify that various methods for producing HTML have equivalent results.\n    The results will not be identical because the div id is pseudorandom. Thus\n    we compare the results after replacing the div id.\n    We test the results of\n    - pio.to_html\n    - pio.write_html with a StringIO buffer\n    - pio.write_html with a mock pathlib Path\n    - pio.write_html with a mock file descriptor\n    \"\"\"\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert replace_div_id(html) == replace_div_id(sio_html)\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert replace_div_id(html) == replace_div_id(pl_html)\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    fd_html, = mock_file_descriptor.write.call_args[0]\n    assert replace_div_id(html) == replace_div_id(fd_html)\ntest_write_html()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_io/test_pathlib.py"}], "instruction": "Functionality: The replace_div_id function is designed to process a given string 's' that contains HTML code. It specifically searches for a 'div' tag within the HTML and replaces the unique identifier (id) of this 'div' tag with the string 'XXXX'. This is useful for anonymizing or standardizing HTML code for testing or comparison purposes.\n\nInputs: \n- s (str): A string containing HTML code. It is assumed that this string will contain at least one 'div' tag with an 'id' attribute.\n\nOutputs: \n- (str): The function returns a new string where the 'id' attribute of the first 'div' tag encountered in the input string has been replaced with 'XXXX'.", "method_code_mask": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\n\n\ndef replace_div_id(s): [MASK]\n"}
