{"method_name": "rugplot", "full_method_name": "rugplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    a = kwargs.pop('a', None)\n    axis = kwargs.pop('axis', None)\n    if a is not None:\n        data = a\n        msg = textwrap.dedent(\n            \"\"\"\n\n        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.\n        Please update your code; This will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    if axis is not None:\n        if axis == 'x':\n            x = data\n        elif axis == 'y':\n            y = data\n        data = None\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.\n        Please update your code; this will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    vertical = kwargs.pop('vertical', None)\n    if vertical is not None:\n        if vertical:\n            action_taken = 'assigning data to `y`.'\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = 'assigning data to `x`.'\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    p.plot_rug(height, expand_margins, legend, **kwargs)\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "instruction": "Functionality: The rugplot function creates a rug plot, which is a one-dimensional plot of data that uses lines to mark the positions of the data points along an axis. It can be used to represent the distribution of a single variable or the distribution of multiple variables based on a hue parameter.\n\nInputs: \n- data: An optional pandas DataFrame, array-like, or list-like object that contains the data for the rug plot.\n- x, y: Optional vectors of data that can be used instead of the 'data' argument. The 'x' or 'y' data will be plotted on the corresponding axis.\n- hue: An optional vector of values that map to different colors for the rug plot lines.\n- height: A numeric value to control the height of the lines used in the rug plot. Default is 0.025.\n- expand_margins: A boolean value that determines whether to expand the limits of the axis to accommodate the height of the rug plot lines. Default is True.\n- palette: An optional color palette to use for mapping the hue data to colors.\n- hue_order: An optional sequence to define the order of the hue levels.\n- hue_norm: An optional instance of matplotlib.colors.Normalize to map hue levels to the color space.\n- legend: A boolean value to determine if a legend should be drawn. Default is True.\n- ax: An optional matplotlib Axes object to draw the rug plot on.\n- **kwargs: Additional keyword arguments can be passed to customize the appearance of the rug plot lines (e.g., linewidth, linestyle).\n\nOutputs:\n- ax: The matplotlib Axes object with the rug plot drawn on it. This allows for further customization or display of the plot.", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"method_name": "categorical_order", "full_method_name": "categorical_order", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values.\n\n    Determine an ordered list of levels in ``values``.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the ``values`` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        if hasattr(vector, 'categories'):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                order = pd.Series(vector).unique()\n                if variable_type(vector) == 'numeric':\n                    order = np.sort(order)\n        order = filter(pd.notnull, order)\n    return list(order)", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_base.py"}], "instruction": "Functionality: The categorical_order function is designed to determine an ordered list of unique levels in a given vector of categorical values. This function is particularly useful for data analysis and visualization tasks that require ordered categorical data.\n\nInputs: \n1. vector: A list, array, Categorical, or Series representing the vector of \"categorical\" values. This can be a variety of data types, including but not limited to lists, numpy arrays, pandas Series, or pandas Categorical objects.\n2. order: An optional list-like object that specifies the desired order of category levels. If provided, it overrides the default order determined from the vector.\n\nOutputs:\n1. order: A list representing the ordered levels of the categorical data, not including any null values. This list can be used for various data processing and visualization tasks where the order of categories is relevant.", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"method_name": "kdeplot", "full_method_name": "kdeplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    if 'data2' in kwargs:\n        msg = (\n            '`data2` has been removed (replaced by `y`); please update your code.'\n            )\n        raise TypeError(msg)\n    vertical = kwargs.pop('vertical', None)\n    if vertical is not None:\n        if vertical:\n            action_taken = 'assigning data to `y`.'\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = 'assigning data to `x`.'\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    bw = kwargs.pop('bw', None)\n    if bw is not None:\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.\n        Setting `bw_method={bw}`, but please see the docs for the new parameters\n        and update your code. This will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n        bw_method = bw\n    if kwargs.pop('kernel', None) is not None:\n        msg = textwrap.dedent(\n            \"\"\"\n\n        Support for alternate kernels has been removed; using Gaussian kernel.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    shade_lowest = kwargs.pop('shade_lowest', None)\n    if shade_lowest is not None:\n        if shade_lowest:\n            thresh = 0\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    shade = kwargs.pop('shade', None)\n    if shade is not None:\n        fill = shade\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, FutureWarning, stacklevel=2)\n    levels = kwargs.pop('n_levels', levels)\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, allowed_types=['numeric', 'datetime'], log_scale=log_scale)\n    method = ax.fill_between if fill else ax.plot\n    color = _default_color(method, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    estimate_kws = dict(bw_method=bw_method, bw_adjust=bw_adjust, gridsize=\n        gridsize, cut=cut, clip=clip, cumulative=cumulative)\n    if p.univariate:\n        plot_kws = kwargs.copy()\n        p.plot_univariate_density(multiple=multiple, common_norm=\n            common_norm, common_grid=common_grid, fill=fill, color=color,\n            legend=legend, warn_singular=warn_singular, estimate_kws=\n            estimate_kws, **plot_kws)\n    else:\n        p.plot_bivariate_density(common_norm=common_norm, fill=fill, levels\n            =levels, thresh=thresh, legend=legend, color=color,\n            warn_singular=warn_singular, cbar=cbar, cbar_ax=cbar_ax,\n            cbar_kws=cbar_kws, estimate_kws=estimate_kws, **kwargs)\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "instruction": "Functionality: The kdeplot function generates a kernel density estimate (KDE) plot for one-dimensional or two-dimensional data. It can represent this estimate with a line plot for univariate data or a contour or filled plot for bivariate data. The function supports various options for kernel density estimation, including bandwidth adjustment, grid size, and the ability to cut data beyond a certain range.\n\nInputs: \n- data: pandas DataFrame or array-like, optional. Input data structure. If pandas DataFrame, columns can be referenced by name.\n- x, y: strings or vectors, optional. Input data variables; univariate or bivariate. If strings, these should correspond to variable names in the data DataFrame.\n- hue: string or vector, optional. Semantic variable that is mapped to determine the color of plot elements.\n- weights: vector, optional. Weight vector for the KDE estimation.\n- palette: color palette or dictionary, optional. Colors to use for the different levels of the hue variable.\n- hue_order: list, optional. Order for the levels of the hue variable.\n- hue_norm: `matplotlib.colors.Normalize` instance, optional. Normalize the hue variable before mapping to colors.\n- color: matplotlib color, optional. Color to use for the plot elements if a hue variable is not set.\n- fill: boolean, optional. If `True`, fill the area under the KDE curve or between the KDE curves when multiple densities are estimated.\n- multiple: {'layer', 'stack', 'fill'}, optional. How to draw multiple densities in a bivariate plot.\n- common_norm: boolean, optional. If `True`, all KDEs are normalized so that the maximum density is 1. If `False`, each density is normalized separately.\n- common_grid: boolean, optional. If `True`, a common grid is used for univariate plots.\n- cumulative: boolean, optional. If `True`, estimate a cumulative distribution function.\n- bw_method: 'scott', 'silverman', scalar, or callable, optional. Method used to calculate the estimator bandwidth.\n- bw_adjust: scalar, optional. Scalar for bandwidth adjustment. Can be 0 or negative.\n- log_scale: int or vector, optional. Apply a logarithmic transformation to the support of the estimate.\n- levels: int or vector, optional. Number of contour lines for bivariate KDE, or the contour lines to draw.\n- thresh: float, optional. Areas with a lower density than this threshold are not drawn.\n- gridsize: int, optional. Number of discrete points in the evaluation grid for each dimension.\n- cut: scalar, optional. Draw the estimate to cut * bw from the extreme data points.\n- clip: tuple or None, optional. Limit the extent of the KDE plot by clipping the evaluation grid to the given range.\n- legend: boolean, optional. If `True`, add a legend.\n- cbar: boolean, optional. If `True` and plotting a bivariate KDE, add a colorbar.\n- cbar_ax: matplotlib Axes, optional. Axes in which to draw the colorbar.\n- cbar_kws: dictionary, optional. Keyword arguments for `figure.colorbar`.\n- ax: matplotlib Axes, optional. Axes in which to draw the plot, otherwise uses the currently active Axes.\n\nOutputs:\n- ax: matplotlib Axes. The plot ax object with the KDE plot generated.", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"method_name": "light_palette", "full_method_name": "light_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ):\n    \"\"\"Make a sequential palette that blends from light to ``color``.\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n    If you are using a Jupyter notebook, you can also choose this palette\n    interactively with the :func:`choose_light_palette` function.\n    Parameters\n    ----------\n    color : base color for high values\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    diverging_palette : Create a diverging palette with two colors.\n    Examples\n    --------\n    .. include:: ../docstrings/light_palette.rst\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    hue, sat, _ = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = 0.15 * sat, 95\n    gray = _color_to_rgb((hue, gray_s, gray_l), input='husl')\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The light_palette function creates a sequential color palette that blends from a light color to a specified base color. This function is useful for creating color schemes in data visualizations where a range of sequential colors is needed, with the 'high' value color being the one provided as input. The blend can be reversed, and the output can be formatted as a list of RGB tuples or as a matplotlib ListedColormap, depending on the 'as_cmap' parameter.\n\nInputs:\n- color: The base color for high values in the palette. This can be specified using a hex code, an HTML color name, or a tuple in the 'input' space (e.g., RGB, HLS, HUSL).\n- n_colors: Optional; an integer specifying the number of colors in the palette. Default is 6.\n- reverse: Optional; a boolean indicating whether to reverse the direction of the color blend. Default is False.\n- as_cmap: Optional; a boolean indicating whether to return the palette as a matplotlib ListedColormap. Default is False.\n- input: Optional; a string specifying the color space to interpret the input color. Valid options are 'rgb', 'hls', 'husl', 'xkcd'. Default is 'rgb'.\n\nOutputs:\n- palette: A list of RGB tuples or a matplotlib ListedColormap, depending on the 'as_cmap' parameter.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"method_name": "histplot", "full_method_name": "histplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, log_scale=log_scale)\n    if p.univariate:\n        if fill:\n            method = ax.bar if element == 'bars' else ax.fill_between\n        else:\n            method = ax.plot\n        color = _default_color(method, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    if discrete is None:\n        discrete = p._default_discrete()\n    estimate_kws = dict(stat=stat, bins=bins, binwidth=binwidth, binrange=\n        binrange, discrete=discrete, cumulative=cumulative)\n    if p.univariate:\n        p.plot_univariate_histogram(multiple=multiple, element=element,\n            fill=fill, shrink=shrink, common_norm=common_norm, common_bins=\n            common_bins, kde=kde, kde_kws=kde_kws, color=color, legend=\n            legend, estimate_kws=estimate_kws, line_kws=line_kws, **kwargs)\n    else:\n        p.plot_bivariate_histogram(common_bins=common_bins, common_norm=\n            common_norm, thresh=thresh, pthresh=pthresh, pmax=pmax, color=\n            color, legend=legend, cbar=cbar, cbar_ax=cbar_ax, cbar_kws=\n            cbar_kws, estimate_kws=estimate_kws, **kwargs)\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "instruction": "Functionality: The histplot function is designed to create histograms for univariate or bivariate data analysis. It can handle various types of data inputs and offers customization in terms of binning, normalization, and visual elements like colors, legends, and cumulative histograms. The function also supports KDE (Kernel Density Estimation) plots in addition to traditional histograms.\n\nInputs: \n- data: A pandas DataFrame, Series, or array-like object containing the data to be analyzed.\n- x, y, hue: Variables to map plot aspects to data dimensions. 'x' and 'y' are used for univariate and bivariate histograms respectively. 'hue' is used for grouping the data by a categorical variable.\n- weights: Weights for each data point. This can be used to represent frequencies or other types of weights.\n- stat: Determines how data frequencies are calculated. Options include 'count', 'frequency', 'density', 'probability', etc.\n- bins: Can be a number of bins, a list of bin edges, or a string representing a binning strategy ('auto', 'sturges', 'sqrt', etc.).\n- binwidth: Desired bin width for histogram bins.\n- binrange: A tuple (min, max) or two-tuple ((min_x, max_x), (min_y, max_y)) setting the range of histogram bins.\n- discrete: Indicates if the variable is discrete. If None, it is determined automatically.\n- cumulative: If True, the histogram will be cumulative.\n- common_bins: If True and data is bivariate, bins will be common for both histograms.\n- common_norm: If True and data is bivariate, normalization will be common for both histograms.\n- multiple: Determines how to plot multiple histograms in the same figure. Options include 'layer', 'stack', 'dodge'.\n- element: Determines the type of plot to use ('bars', 'step', 'fill').\n- fill: If True, histograms will be filled.\n- shrink: Fractional value to shrink the histogram bars.\n- kde: If True, a KDE plot will be added to the histogram.\n- kde_kws, line_kws: Keyword arguments for KDE and line plots respectively.\n- thresh, pthresh, pmax: Thresholds for bivariate histograms.\n- cbar: If True, a color bar will be added to the bivariate histogram.\n- cbar_kws: Keyword arguments for color bar.\n- palette, hue_order, hue_norm: Color scheme, hue order, and hue normalization for categorical variables.\n- color: Color for the histogram bars.\n- log_scale: If True, the axes will be scaled logarithmically.\n- legend: If True, a legend will be added to the plot.\n- ax: A matplotlib axes object to plot on. If None, the current axes will be used.\n\nOutputs:\n- ax: A matplotlib axes object containing the histogram plot. This can be used for further customization or display.", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"method_name": "ecdfplot", "full_method_name": "ecdfplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, log_scale=log_scale)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    if not p.univariate:\n        raise NotImplementedError('Bivariate ECDF plots are not implemented')\n    estimate_kws = dict(stat=stat, complementary=complementary)\n    p.plot_univariate_ecdf(estimate_kws=estimate_kws, legend=legend, **kwargs)\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "instruction": "Functionality: The ecdfplot function is designed to create Empirical Cumulative Distribution Function (ECDF) plots. These plots help visualize the cumulative probability distribution of a dataset. The function supports univariate data and allows for customization such as hue mapping, log scale plotting, and adjusting the statistical properties of the ECDF (e.g., proportion, complementary).\n\nInputs:\n1. data: (optional) A pandas DataFrame or a dictionary of data.\n2. x, y: (optional) The variables representing the input data. Only one is required for the univariate ECDF plot.\n3. hue: (optional) Categorical data to separate the plot by different categories.\n4. weights: (optional) Weights for each observation in the data.\n5. stat: (default 'proportion') The statistic to plot in the ECDF. Can be 'proportion' or 'count'.\n6. complementary: (default False) Whether to plot the complementary empirical distribution function (1 - F(x)).\n7. palette: (optional) Color palette to use for the plot, if hue is used.\n8. hue_order: (optional) Order for the levels of the hue variable.\n9. hue_norm: (optional) Normalization for hue color mapping.\n10. log_scale: (optional) Apply log scale for the x or y axis.\n11. legend: (default True) If True, show the legend for the plot.\n12. ax: (optional) Axes object to draw the plot onto, otherwise uses the current axes.\n13. **kwargs: Additional keyword arguments to pass to the plotting function.\n\nOutputs:\n1. ax: The axes object with the ECDF plot.", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"method_name": "ci_to_errsize", "full_method_name": "ci_to_errsize", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef ci_to_errsize(cis, heights):\n    \"\"\"Convert intervals to error arguments relative to plot heights.\n\n    Parameters\n    ----------\n    cis : 2 x n sequence\n        sequence of confidence interval limits\n    heights : n sequence\n        sequence of plot heights\n\n    Returns\n    -------\n    errsize : 2 x n array\n        sequence of error size relative to height values in correct\n        format as argument for plt.bar\n\n    \"\"\"\n    cis = np.atleast_2d(cis).reshape(2, -1)\n    heights = np.atleast_1d(heights)\n    errsize = []\n    for i, (low, high) in enumerate(np.transpose(cis)):\n        h = heights[i]\n        elow = h - low\n        ehigh = high - h\n        errsize.append([elow, ehigh])\n    errsize = np.asarray(errsize).T\n    return errsize", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The ci_to_errsize function is designed to convert confidence intervals into error sizes that are relative to the heights of bars in a bar plot. This is useful for plotting error bars on top of bar plots, where the error size needs to be adjusted based on the height of each bar.\n\nInputs: \n- cis: A 2 x n sequence representing the confidence interval limits. This is a sequence of two arrays, where the first array contains the lower limits of the intervals, and the second array contains the upper limits.\n- heights: An n sequence representing the heights of the bars in the plot. This is a single array containing the heights of each bar.\n\nOutputs:\n- errsize: A 2 x n array representing the error size relative to the height values, in the correct format to be used as an argument for the plt.bar function in matplotlib. This array contains the lower and upper error sizes for each bar, adjusted according to the provided bar heights.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"method_name": "desaturate", "full_method_name": "desaturate", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef desaturate(color, prop):\n    \"\"\"Decrease the saturation channel of a color by some percent.\n\n    Parameters\n    ----------\n    color : matplotlib color\n        hex, rgb-tuple, or html color name\n    prop : float\n        saturation channel of color will be multiplied by this value\n\n    Returns\n    -------\n    new_color : rgb tuple\n        desaturated color code in RGB tuple representation\n\n    \"\"\"\n    if not 0 <= prop <= 1:\n        raise ValueError('prop must be between 0 and 1')\n    rgb = to_rgb(color)\n    if prop == 1:\n        return rgb\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    s *= prop\n    new_color = colorsys.hls_to_rgb(h, l, s)\n    return new_color", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The desaturate function is designed to decrease the saturation channel of a given color by a specified percentage. This is achieved by converting the input color into its Hue, Lightness, Saturation (HLS) representation, reducing the saturation by the given proportion, and then converting it back to RGB format.\n\nInputs: \n1. color : This argument should be an input color represented in one of the following formats: a hex code, an RGB tuple, or an HTML color name.\n2. prop : A float value between 0 and 1, inclusive. The saturation channel of the input color will be multiplied by this value to achieve the desired level of desaturation.\n\nOutputs: \n1. new_color : The output is a tuple representing the desaturated color in RGB format.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"method_name": "axes_ticklabels_overlap", "full_method_name": "axes_ticklabels_overlap", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Return booleans for whether the x and y ticklabels on an Axes overlap.\n    Parameters\n    ----------\n    ax : matplotlib Axes\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        True when the labels on that axis overlap.\n    \"\"\"\n    return axis_ticklabels_overlap(ax.get_xticklabels()\n        ), axis_ticklabels_overlap(ax.get_yticklabels())", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: Determine if the x and y ticklabels on a given matplotlib Axes overlap.\nInputs: \n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\nOutputs: \n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"method_name": "axis_ticklabels_overlap", "full_method_name": "axis_ticklabels_overlap", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The function axis_ticklabels_overlap is designed to determine if any of the ticklabels on a matplotlib axis overlap with each other. It takes a list of matplotlib ticklabels and checks for overlaps by comparing their window extents.\n\nInputs: \n    labels : list of matplotlib ticklabels\n        A list containing matplotlib ticklabels that are to be checked for overlaps.\n\nOutputs:\n    overlap : boolean\n        A boolean value indicating whether any of the ticklabels overlap with each other. True if there are overlaps, False otherwise.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"method_name": "locator_to_legend_entries", "full_method_name": "locator_to_legend_entries", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef locator_to_legend_entries(locator, limits, dtype):\n    \"\"\"Return levels and formatted levels for brief numeric legends.\"\"\"\n    raw_levels = locator.tick_values(*limits).astype(dtype)\n    raw_levels = [l for l in raw_levels if l >= limits[0] and l <= limits[1]]\n\n\n    class dummy_axis:\n\n        def get_view_interval(self):\n            return limits\n    if isinstance(locator, mpl.ticker.LogLocator):\n        formatter = mpl.ticker.LogFormatter()\n    else:\n        formatter = mpl.ticker.ScalarFormatter()\n        formatter.set_useOffset(False)\n        formatter.set_scientific(False)\n    formatter.axis = dummy_axis()\n    formatted_levels = formatter.format_ticks(raw_levels)\n    return raw_levels, formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The locator_to_legend_entries function is designed to generate levels and formatted levels for numeric legends, which are typically used in plots to briefly represent data ranges. This function is particularly useful in creating legends for log-scaled or linear-scaled axes.\n\nInputs: \n1. locator: A ticker locator object from matplotlib.ticker, which determines where the ticks are placed on the axes.\n2. limits: A tuple representing the lower and upper limits of the data axis range.\n3. dtype: A numpy dtype specifying the type of the output levels.\n\nOutputs: \n1. raw_levels: A list of numeric values representing the raw tick levels within the specified limits.\n2. formatted_levels: A list of strings where each string is the formatted representation of the corresponding raw level, suitable for display in a legend. The formatting is determined by the type of locator (LogLocator or ScalarFormatter) used.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"method_name": "_draw_figure", "full_method_name": "_draw_figure", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _draw_figure(fig):\n    \"\"\"Force draw of a matplotlib figure, accounting for back-compat.\"\"\"\n    fig.canvas.draw()\n    if fig.stale:\n        try:\n            fig.draw(fig.canvas.get_renderer())\n        except AttributeError:\n            pass", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "instruction": "Functionality: The function '_draw_figure' is designed to force the rendering of a matplotlib figure object. This function takes into account backward compatibility issues and ensures that the figure is properly updated and displayed. It attempts to draw the figure canvas and, if the figure is marked as stale, it tries to redraw the figure using the canvas renderer.\n\nInputs: \n- fig: A matplotlib.figure.Figure object. This is the figure that needs to be rendered and updated.\n\nOutputs: \n- None. The function updates the figure in-place and does not return any value. However, it ensures that the figure's contents are properly visualized on the screen.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"method_name": "move_legend", "full_method_name": "move_legend", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef move_legend(obj, loc, **kwargs):\n    \"\"\"\n    Recreate a plot's legend at a new location.\n\n    The name is a slight misnomer. Matplotlib legends do not expose public\n    control over their position parameters. So this function creates a new legend,\n    copying over the data from the original object, which is then removed.\n\n    Parameters\n    ----------\n    obj : the object with the plot\n        This argument can be either a seaborn or matplotlib object:\n\n        - :class:`seaborn.FacetGrid` or :class:`seaborn.PairGrid`\n        - :class:`matplotlib.axes.Axes` or :class:`matplotlib.figure.Figure`\n\n    loc : str or int\n        Location argument, as in :meth:`matplotlib.axes.Axes.legend`.\n\n    kwargs\n        Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.legend`.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/move_legend.rst\n\n    \"\"\"\n    from seaborn.axisgrid import Grid\n    if isinstance(obj, Grid):\n        old_legend = obj.legend\n        legend_func = obj.figure.legend\n    elif isinstance(obj, mpl.axes.Axes):\n        old_legend = obj.legend_\n        legend_func = obj.legend\n    elif isinstance(obj, mpl.figure.Figure):\n        if obj.legends:\n            old_legend = obj.legends[-1]\n        else:\n            old_legend = None\n        legend_func = obj.legend\n    else:\n        err = (\n            '`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.'\n            )\n        raise TypeError(err)\n    if old_legend is None:\n        err = f'{obj} has no legend attached.'\n        raise ValueError(err)\n    from seaborn._compat import get_legend_handles\n    handles = get_legend_handles(old_legend)\n    labels = [t.get_text() for t in old_legend.get_texts()]\n    if (new_labels := kwargs.pop('labels', None)) is not None:\n        if len(new_labels) != len(labels):\n            err = 'Length of new labels does not match existing legend.'\n            raise ValueError(err)\n        labels = new_labels\n    legend_kws = inspect.signature(mpl.legend.Legend).parameters\n    props = {k: v for k, v in old_legend.properties().items() if k in\n        legend_kws}\n    props.pop('bbox_to_anchor')\n    title = props.pop('title')\n    if 'title' in kwargs:\n        title.set_text(kwargs.pop('title'))\n    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith('title_')}\n    for key, val in title_kwargs.items():\n        title.set(**{key[6:]: val})\n        kwargs.pop(key)\n    kwargs.setdefault('frameon', old_legend.legendPatch.get_visible())\n    props.update(kwargs)\n    old_legend.remove()\n    new_legend = legend_func(handles, labels, loc=loc, **props)\n    new_legend.set_title(title.get_text(), title.get_fontproperties())\n    if isinstance(obj, Grid):\n        obj._legend = new_legend", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: Recreate a plot's legend at a new location. This function is designed to move the legend of a plot to a different location on the graph, effectively allowing for better customization and control over the legend's position. It works by creating a new legend and copying over the data from the original legend, which is then removed.\n\nInputs: \n- obj: The object with the plot. This can be a seaborn or matplotlib object, such as a seaborn FacetGrid or PairGrid, a matplotlib Axes, or a matplotlib Figure.\n- loc: Location argument, specifying where the new legend should be placed. This is the same as in matplotlib.axes.Axes.legend.\n- kwargs: Additional keyword arguments that are passed to matplotlib.axes.Axes.legend.\n\nOutputs:\n- The function does not return any value explicitly. Instead, it operates in-place, modifying the input object to recreate the legend at the specified new location.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"method_name": "get_legend_handles", "full_method_name": "get_legend_handles", "method_path": "../srcdata/Visualization/seaborn/seaborn/_compat.py", "method_code": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\ndef get_legend_handles(legend):\n    \"\"\"Handle legendHandles attribute rename.\"\"\"\n    if _version_predates(mpl, '3.7'):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "instruction": "Functionality: The get_legend_handles function is designed to handle the change in attribute name from 'legendHandles' to 'legend_handles' in the matplotlib library's legend object. This function ensures compatibility across different versions of matplotlib, specifically addressing the version 3.7 update where the attribute name changed.\n\nInputs: \n    legend (mpl.legend.Legend): The legend object from which the handles need to be extracted. This object is typically obtained after calling the legend() method on a matplotlib figure.\n\nOutputs:\n    legend_handles (list): A list of artist objects representing the handles (typically, line or patch objects) used in the legend. These handles correspond to the elements in the plot that the legend represents. The exact type of artist object depends on the type of plot that was used to generate the legend.", "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"method_name": "relative_luminance", "full_method_name": "relative_luminance", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef relative_luminance(color):\n    \"\"\"Calculate the relative luminance of a color according to W3C standards\n\n    Parameters\n    ----------\n    color : matplotlib color or sequence of matplotlib colors\n        Hex code, rgb-tuple, or html color name.\n\n    Returns\n    -------\n    luminance : float(s) between 0 and 1\n\n    \"\"\"\n    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]\n    rgb = np.where(rgb <= 0.03928, rgb / 12.92, ((rgb + 0.055) / 1.055) ** 2.4)\n    lum = rgb.dot([0.2126, 0.7152, 0.0722])\n    try:\n        return lum.item()\n    except ValueError:\n        return lum", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: Calculate the relative luminance of a color according to W3C standards. This function is particularly useful for ensuring that colors used in user interfaces meet accessibility guidelines by having sufficient contrast.\n\nInputs: \n    color : matplotlib color or sequence of matplotlib colors\n        The color for which the relative luminance will be calculated. This can be provided as a hex code, an RGB tuple, or an HTML color name.\n\nOutputs:\n    luminance : float(s) between 0 and 1\n        The relative luminance value(s) of the input color(s). This value is critical for assessing color contrast in user interfaces.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"method_name": "get_color_cycle", "full_method_name": "get_color_cycle", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef get_color_cycle():\n    \"\"\"Return the list of colors in the current matplotlib color cycle\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    colors : list\n        List of matplotlib colors in the current cycle, or dark gray if\n        the current color cycle is empty.\n    \"\"\"\n    cycler = mpl.rcParams['axes.prop_cycle']\n    return cycler.by_key()['color'] if 'color' in cycler.keys else ['.15']", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The function get_color_cycle retrieves the list of colors in the current matplotlib color cycle. This cycle is essentially a predefined sequence of colors that matplotlib goes through when it needs to automatically assign colors to different elements in a plot. If the current color cycle is empty, the function returns a list containing only a single dark gray color.\n\nInputs: None. The function does not require any input arguments.\n\nOutputs: colors : list\n        A list of matplotlib color specifications. Each color in the list is a string representing a color that can be recognized by matplotlib. If the current color cycle is empty, the list will contain only one element: a string representing a dark gray color ('.15').", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"method_name": "_assign_default_kwargs", "full_method_name": "_assign_default_kwargs", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _assign_default_kwargs(kws, call_func, source_func):\n    \"\"\"Assign default kwargs for call_func using values from source_func.\"\"\"\n    needed = inspect.signature(call_func).parameters\n    defaults = inspect.signature(source_func).parameters\n    for param in needed:\n        if param in defaults and param not in kws:\n            kws[param] = defaults[param].default\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The _assign_default_kwargs function is designed to update and return a dictionary of keyword arguments (kws) for a caller function (call_func) by assigning default values from a source function (source_func). This is particularly useful when the caller function requires certain keyword arguments that it does not explicitly define, and these arguments have default values in the source function.\n\nInputs: \n- kws: a dictionary containing the keyword arguments that need to be updated or populated with default values if they are not already present.\n- call_func: a function for which the keyword arguments are being prepared. The signature of this function is inspected to determine which keyword arguments are required.\n- source_func: a function whose signature is inspected to determine default values for the keyword arguments. These defaults will be used to populate the kws dictionary if a given argument is not already present.\n\nOutputs:\n- A dictionary of keyword arguments (kws) that has been updated to include default values from source_func for any key that is required by call_func and not already present in kws.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"method_name": "_check_argument", "full_method_name": "_check_argument", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _check_argument(param, options, value, prefix=False):\n    \"\"\"Raise if value for param is not in options.\"\"\"\n    if prefix and value is not None:\n        failure = not any(value.startswith(p) for p in options if\n            isinstance(p, str))\n    else:\n        failure = value not in options\n    if failure:\n        raise ValueError(\n            f'The value for `{param}` must be one of {options}, but {repr(value)} was passed.'\n            )\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The _check_argument function is designed to validate a given argument against a set of options. It ensures that the argument value is either exactly within the provided options or, if the prefix flag is set to True, that the argument value starts with any of the option prefixes. This function is particularly useful for validating parameters in functions where a specific set of values is allowed.\n\nInputs: \n- param: A string representing the name of the parameter being checked.\n- options: A list or tuple containing valid options for the parameter.\n- value: The value of the parameter to be checked.\n- prefix: A boolean flag that determines if the check should be for exact matches (False) or if the value should be allowed to start with any of the option prefixes (True).\n\nOutputs:\n- The function returns the validated value of the parameter if it passes the check. However, it raises a ValueError if the value does not meet the criteria, providing a helpful error message to the user indicating the allowed values and the invalid value passed.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"method_name": "_deprecate_ci", "full_method_name": "_deprecate_ci", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _deprecate_ci(errorbar, ci):\n    \"\"\"\n    Warn on usage of ci= and convert to appropriate errorbar= arg.\n\n    ci was deprecated when errorbar was added in 0.12. It should not be removed\n    completely for some time, but it can be moved out of function definitions\n    (and extracted from kwargs) after one cycle.\n\n    \"\"\"\n    if ci is not deprecated and ci != 'deprecated':\n        if ci is None:\n            errorbar = None\n        elif ci == 'sd':\n            errorbar = 'sd'\n        else:\n            errorbar = 'ci', ci\n        msg = f\"\"\"\n\nThe `ci` parameter is deprecated. Use `errorbar={repr(errorbar)}` for the same effect.\n\"\"\"\n        warnings.warn(msg, FutureWarning, stacklevel=3)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: The _deprecate_ci function is designed to handle the deprecation of the 'ci' parameter in favor of 'errorbar'. It checks if the 'ci' parameter is used and, if so, issues a warning and converts the 'ci' parameter to the equivalent 'errorbar' parameter usage. This function is a part of the deprecation process in the seaborn library, guiding users to update their code to the new parameter standard.\n\nInputs:\n- errorbar: A string, None, or a tuple. This parameter already specifies the error bar style in the new function signature. If 'ci' is not deprecated and used, this function will modify 'errorbar' to reflect the transition from 'ci'.\n- ci: A deprecated parameter, either 'sd', a number representing the confidence interval, None, or 'deprecated'. This parameter is being phased out in favor of 'errorbar'.\n\nOutputs:\n- errorbar: The modified 'errorbar' parameter that reflects the transition from 'ci'. If 'ci' is None, 'errorbar' is set to None. If 'ci' is 'sd', 'errorbar' is set to 'sd'. Otherwise, 'errorbar' is set to a tuple ('ci', ci), where 'ci' is the numerical value or 'deprecated' if the 'ci' parameter was explicitly set to 'deprecated'. A FutureWarning is issued when the 'ci' parameter is used, directing the user to use the 'errorbar' parameter for the same effect.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"method_name": "despine", "full_method_name": "despine", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False):\n    \"\"\"Remove the top and right spines from plot(s).\n\n    fig : matplotlib figure, optional\n        Figure to despine all axes of, defaults to the current figure.\n    ax : matplotlib axes, optional\n        Specific axes object to despine. Ignored if fig is provided.\n    top, right, left, bottom : boolean, optional\n        If True, remove that spine.\n    offset : int or dict, optional\n        Absolute distance, in points, spines should be moved away\n        from the axes (negative values move spines inward). A single value\n        applies to all spines; a dict can be used to set offset values per\n        side.\n    trim : bool, optional\n        If True, limit spines to the smallest and largest major tick\n        on each non-despined axis.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if fig is None and ax is None:\n        axes = plt.gcf().axes\n    elif fig is not None:\n        axes = fig.axes\n    elif ax is not None:\n        axes = [ax]\n    for ax_i in axes:\n        for side in ['top', 'right', 'left', 'bottom']:\n            is_visible = not locals()[side]\n            ax_i.spines[side].set_visible(is_visible)\n            if offset is not None and is_visible:\n                try:\n                    val = offset.get(side, 0)\n                except AttributeError:\n                    val = offset\n                ax_i.spines[side].set_position(('outward', val))\n        if left and not right:\n            maj_on = any(t.tick1line.get_visible() for t in ax_i.yaxis.\n                majorTicks)\n            min_on = any(t.tick1line.get_visible() for t in ax_i.yaxis.\n                minorTicks)\n            ax_i.yaxis.set_ticks_position('right')\n            for t in ax_i.yaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.yaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n        if bottom and not top:\n            maj_on = any(t.tick1line.get_visible() for t in ax_i.xaxis.\n                majorTicks)\n            min_on = any(t.tick1line.get_visible() for t in ax_i.xaxis.\n                minorTicks)\n            ax_i.xaxis.set_ticks_position('top')\n            for t in ax_i.xaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.xaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n        if trim:\n            xticks = np.asarray(ax_i.get_xticks())\n            if xticks.size:\n                firsttick = np.compress(xticks >= min(ax_i.get_xlim()), xticks\n                    )[0]\n                lasttick = np.compress(xticks <= max(ax_i.get_xlim()), xticks)[\n                    -1]\n                ax_i.spines['bottom'].set_bounds(firsttick, lasttick)\n                ax_i.spines['top'].set_bounds(firsttick, lasttick)\n                newticks = xticks.compress(xticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_xticks(newticks)\n            yticks = np.asarray(ax_i.get_yticks())\n            if yticks.size:\n                firsttick = np.compress(yticks >= min(ax_i.get_ylim()), yticks\n                    )[0]\n                lasttick = np.compress(yticks <= max(ax_i.get_ylim()), yticks)[\n                    -1]\n                ax_i.spines['left'].set_bounds(firsttick, lasttick)\n                ax_i.spines['right'].set_bounds(firsttick, lasttick)\n                newticks = yticks.compress(yticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_yticks(newticks)", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_utils.py"}], "instruction": "Functionality: Remove the top and right spines from plot(s) and optionally adjust left and bottom spines. The function can handle individual axes, all axes of a given figure, or the current figure if none are specified.\n\nInputs:\n- fig: matplotlib figure (optional) - Figure to despine all axes of, defaults to the current figure.\n- ax: matplotlib axes (optional) - Specific axes object to despine. Ignored if fig is provided.\n- top: boolean (optional) - If True, remove the top spine.\n- right: boolean (optional) - If True, remove the right spine.\n- left: boolean (optional) - If True, remove the left spine.\n- bottom: boolean (optional) - If True, remove the bottom spine.\n- offset: int or dict (optional) - Absolute distance, in points, spines should be moved away from the axes (negative values move spines inward). A single value applies to all spines; a dict can be used to set offset values per side.\n- trim: boolean (optional) - If True, limit spines to the smallest and largest major tick on each non-despined axis.\n\nOutputs:\n- None: The function modifies the spines of the plot(s) in place and does not return any value.", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"method_name": "scatterplot", "full_method_name": "scatterplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/relational.py", "method_code": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    p = _ScatterPlotter(data=data, variables=dict(x=x, y=y, hue=hue, size=\n        size, style=style), legend=legend)\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, order=style_order)\n    if ax is None:\n        ax = plt.gca()\n    if not p.has_xy_data:\n        return ax\n    p._attach(ax)\n    color = kwargs.pop('color', None)\n    kwargs['color'] = _default_color(ax.scatter, hue, color, kwargs)\n    p.plot(ax, kwargs)\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}], "instruction": "Functionality: The scatterplot function generates a scatter plot based on input data, allowing for the visualization of relationships between variables. It supports mapping of variables to different aesthetic properties like color (hue), size, and marker style.\n\nInputs:\n- data: A pandas DataFrame, long-form / tidy format, wide-form, or array-like.\n- x, y: Names of variables in data or vector data. Determines the position of each point.\n- hue: Variable that will determine the color of the points.\n- size: Variable that will determine the size of the points.\n- style: Variable that will determine the shape (marker) of the points.\n- palette: Colors to use for the different levels of the hue variable.\n- hue_order: Order for the levels of the hue variable.\n- hue_norm: Normalize object to map the hue values onto the color space.\n- sizes: Range or values for the size of the points.\n- size_order: Order for the levels of the size variable.\n- size_norm: Normalize object to map the size values onto the size of the points.\n- markers: List of markers to use for the different levels of the style variable.\n- style_order: Order for the levels of the style variable.\n- legend: If the legend should be drawn.\n- ax: Axes in which to draw the plot, otherwise use the currently-active Axes.\n- Additional keyword arguments (kwargs) for matplotlib's scatter function.\n\nOutputs:\n- ax: The Axes object with the scatter plot drawn.", "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"method_name": "lineplot", "full_method_name": "lineplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/relational.py", "method_code": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    errorbar = _deprecate_ci(errorbar, ci)\n    p = _LinePlotter(data=data, variables=dict(x=x, y=y, hue=hue, size=size,\n        style=style, units=units, weight=weights), estimator=estimator,\n        n_boot=n_boot, seed=seed, errorbar=errorbar, sort=sort, orient=\n        orient, err_style=err_style, err_kws=err_kws, legend=legend)\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, dashes=dashes, order=style_order)\n    if ax is None:\n        ax = plt.gca()\n    if 'style' not in p.variables and not {'ls', 'linestyle'} & set(kwargs):\n        kwargs['dashes'] = '' if dashes is None or isinstance(dashes, bool\n            ) else dashes\n    if not p.has_xy_data:\n        return ax\n    p._attach(ax)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    p.plot(ax, kwargs)\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_relational.py"}], "instruction": "Functionality: The lineplot function generates a line plot from data in a pandas DataFrame. It supports various attributes like hue, size, style, and error bars, enabling complex data visualizations. This function allows for data aggregation using a specified estimator and can handle categorical data for grouping.\n\nInputs: \n- data: A pandas DataFrame containing the data to be plotted.\n- x, y: Variables for data values to be plotted on the x and y axes.\n- hue, size, style, units, weights: Variables for categorizing data, adjusting line size, style, grouping within subplots, and weighting data points respectively.\n- palette, hue_order, hue_norm: For setting color palette, order, and normalization for categorical variables.\n- sizes, size_order, size_norm: For controlling the size of plot elements.\n- dashes, markers, style_order: For controlling line style and marker types.\n- estimator, errorbar, n_boot, seed: Parameters for data aggregation and error bar calculation.\n- orient, sort: Determines orientation and sorting behavior.\n- err_style, err_kws: For controlling error bar style.\n- legend: Determines the legend display.\n- ci: Deprecated parameter, replaced by errorbar.\n- ax: The axes to plot on.\n- **kwargs: Additional keyword arguments to be passed to matplotlib's plot function.\n\nOutputs:\n- ax: The matplotlib axis object with the line plot generated. The function returns the axis on which the plot was created, enabling further customization.", "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"method_name": "unique_markers", "full_method_name": "unique_markers", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef unique_markers(n):\n    \"\"\"Build an arbitrarily long list of unique marker styles for points.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique marker specs to generate.\n\n    Returns\n    -------\n    markers : list of string or tuples\n        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.\n        All markers will be filled.\n\n    \"\"\"\n    markers = ['o', 'X', (4, 0, 45), 'P', (4, 0, 0), (4, 1, 0), '^', (4, 1,\n        45), 'v']\n    s = 5\n    while len(markers) < n:\n        a = 360 / (s + 1) / 2\n        markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])\n        s += 1\n    return markers[:n]", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_base.py"}], "instruction": "Functionality: The unique_markers function generates a list of unique marker styles for plotting points in matplotlib. The function ensures that all markers are filled and can be used to create visually distinct data representations in plots.\n\nInputs: \n- n: An integer representing the number of unique marker specifications to generate. This argument determines the length of the output list.\n\nOutputs: \n- markers: A list of strings or tuples that define the marker styles. Each element in the list corresponds to a unique marker style that can be used to create a MarkerStyle object in matplotlib. The list will contain exactly 'n' elements, ensuring each marker is distinct.", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"method_name": "get_colormap", "full_method_name": "get_colormap", "method_path": "../srcdata/Visualization/seaborn/seaborn/_compat.py", "method_code": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\ndef get_colormap(name):\n    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"\n    try:\n        return mpl.colormaps[name]\n    except AttributeError:\n        return mpl.cm.get_cmap(name)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The function 'get_colormap' is designed to fetch a colormap from the matplotlib library in Python. It is specifically crafted to handle changes in the matplotlib colormap interface that occurred in version 3.6. The function aims to ensure compatibility and smooth operation across different versions of matplotlib.\n\nInputs: \n1. name: a string representing the name of the colormap to be fetched. This is a required argument, and the user must provide the exact name of the colormap they wish to use.\n\nOutputs: \n1. A colormap object: The function returns a colormap object from matplotlib, which can be used for various data visualization purposes such as color mapping in plots and figures. If the specified colormap is available in the current version of matplotlib, the function will return the colormap object. If the specified colormap is not available due to changes in the matplotlib library, the function will attempt to retrieve the colormap using an alternative method to ensure compatibility.", "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"method_name": "unique_dashes", "full_method_name": "unique_dashes", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef unique_dashes(n):\n    \"\"\"Build an arbitrarily long list of unique dash styles for lines.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique dash specs to generate.\n\n    Returns\n    -------\n    dashes : list of strings or tuples\n        Valid arguments for the ``dashes`` parameter on\n        :class:`matplotlib.lines.Line2D`. The first spec is a solid\n        line (``\"\"``), the remainder are sequences of long and short\n        dashes.\n\n    \"\"\"\n    dashes = ['', (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1)]\n    p = 3\n    while len(dashes) < n:\n        a = itertools.combinations_with_replacement([3, 1.25], p)\n        b = itertools.combinations_with_replacement([4, 1], p)\n        segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1])\n            )\n        for segments in segment_list:\n            gap = min(segments)\n            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))\n            dashes.append(spec)\n        p += 1\n    return dashes[:n]", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_base.py"}], "instruction": "Functionality: The function 'unique_dashes' is designed to generate a list of unique dash styles for lines that can be used as arguments for the 'dashes' parameter on matplotlib's Line2D objects. These dash styles are essential for visually distinguishing lines in plots, especially when multiple lines are present.\n\nInputs: \n- n : int\n    The argument 'n' represents the number of unique dash specifications the function should generate. This value determines the length of the output list.\n\nOutputs: \n- dashes : list of strings or tuples\n    The function returns a list containing dash specifications. The first element of the list is always a solid line, represented by an empty string (''). The subsequent elements are sequences of long and short dashes, represented as tuples. Each tuple in the list is a valid argument for the 'dashes' parameter of matplotlib's Line2D object, providing a unique dash pattern for line styling.", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"method_name": "variable_type", "full_method_name": "variable_type", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef variable_type(vector, boolean_type='numeric'):\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in two ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric' or 'categorical'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n    vector = pd.Series(vector)\n    if isinstance(vector.dtype, pd.CategoricalDtype):\n        return VariableType('categorical')\n    if pd.isna(vector).all():\n        return VariableType('numeric')\n    vector = vector.dropna()\n    with warnings.catch_warnings():\n        warnings.simplefilter(action='ignore', category=(FutureWarning,\n            DeprecationWarning))\n        try:\n            if np.isin(vector, [0, 1]).all():\n                return VariableType(boolean_type)\n        except TypeError:\n            pass\n    if pd.api.types.is_numeric_dtype(vector):\n        return VariableType('numeric')\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VariableType('datetime')\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n    if all_numeric(vector):\n        return VariableType('numeric')\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n    if all_datetime(vector):\n        return VariableType('datetime')\n    return VariableType('categorical')", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_base.py"}], "instruction": "Functionality: Determine whether a vector contains numeric, categorical, or datetime data. This function considers Python sequences or object-typed PyData objects as numeric if all entries are numeric, and string or mixed-type data as categorical even if not explicitly represented as a categorical type.\n\nInputs:\nvector: A pandas.Series, numpy.ndarray, or Python sequence. This is the input data to test.\nboolean_type: A string ('numeric' or 'categorical') specifying the type to use for vectors containing only 0s and 1s (and NAs).\n\nOutputs:\nvar_type: A string ('numeric', 'categorical', or 'datetime') identifying the type of data in the vector.", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"method_name": "infer_orient", "full_method_name": "infer_orient", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    \"\"\"Determine how the plot should be oriented based on the data.\n\n    For historical reasons, the convention is to call a plot \"horizontally\"\n    or \"vertically\" oriented based on the axis representing its dependent\n    variable. Practically, this is used when determining the axis for\n    numerical aggregation.\n\n    Parameters\n    ----------\n    x, y : Vector data or None\n        Positional data vectors for the plot.\n    orient : string or None\n        Specified orientation. If not None, can be \"x\" or \"y\", or otherwise\n        must start with \"v\" or \"h\".\n    require_numeric : bool\n        If set, raise when the implied dependent variable is not numeric.\n\n    Returns\n    -------\n    orient : \"x\" or \"y\"\n\n    Raises\n    ------\n    ValueError: When `orient` is an unknown string.\n    TypeError: When dependent variable is not numeric, with `require_numeric`\n\n    \"\"\"\n    x_type = None if x is None else variable_type(x)\n    y_type = None if y is None else variable_type(y)\n    nonnumeric_dv_error = '{} orientation requires numeric `{}` variable.'\n    single_var_warning = '{} orientation ignored with only `{}` specified.'\n    if x is None:\n        if str(orient).startswith('h'):\n            warnings.warn(single_var_warning.format('Horizontal', 'y'))\n        if require_numeric and y_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Vertical', 'y'))\n        return 'x'\n    elif y is None:\n        if str(orient).startswith('v'):\n            warnings.warn(single_var_warning.format('Vertical', 'x'))\n        if require_numeric and x_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Horizontal', 'x'))\n        return 'y'\n    elif str(orient).startswith('v') or orient == 'x':\n        if require_numeric and y_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Vertical', 'y'))\n        return 'x'\n    elif str(orient).startswith('h') or orient == 'y':\n        if require_numeric and x_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Horizontal', 'x'))\n        return 'y'\n    elif orient is not None:\n        err = (\n            f\"`orient` must start with 'v' or 'h' or be None, but `{repr(orient)}` was passed.\"\n            )\n        raise ValueError(err)\n    elif x_type != 'categorical' and y_type == 'categorical':\n        return 'y'\n    elif x_type != 'numeric' and y_type == 'numeric':\n        return 'x'\n    elif x_type == 'numeric' and y_type != 'numeric':\n        return 'y'\n    elif require_numeric and 'numeric' not in (x_type, y_type):\n        err = 'Neither the `x` nor `y` variable appears to be numeric.'\n        raise TypeError(err)\n    else:\n        return 'x'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_base.py"}], "instruction": "Functionality: The infer_orient function is designed to determine the orientation of a plot (either horizontal or vertical) based on the type of data provided for x and y axes. This decision is crucial for determining the axis on which numerical aggregation will occur. The function also validates the orientation based on the user's input and ensures that the dependent variable is numeric if the require_numeric parameter is set to True.\n\nInputs: \n- x: Vector data or None. This represents the data for the x-axis of the plot.\n- y: Vector data or None. This represents the data for the y-axis of the plot.\n- orient: string or None. This is the specified orientation by the user. If not None, it should be \"x\" or \"y\", or start with \"v\" or \"h\".\n- require_numeric: bool. This flag determines if the function should raise an error when the dependent variable is not numeric. Default is True.\n\nOutputs: \n- orient: \"x\" or \"y\". This represents the orientation of the plot that has been determined by the function.\n\nThe function raises two types of exceptions:\n- ValueError: When the `orient` parameter is an unknown string.\n- TypeError: When the dependent variable is not numeric, and `require_numeric` is set to True.", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"method_name": "plotting_context", "full_method_name": "plotting_context", "method_path": "../srcdata/Visualization/seaborn/seaborn/rcmod.py", "method_code": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\nclass _RCAesthetics(dict):\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\ndef plotting_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Get the parameters that control the scaling of plot elements.\n    These parameters correspond to label size, line thickness, etc. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n    This function can also be used as a context manager to temporarily\n    alter the global defaults. See :func:`set_theme` or :func:`set_context`\n    to modify the global defaults for all plots.\n    Parameters\n    ----------\n    context : None, dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n    Examples\n    --------\n    .. include:: ../docstrings/plotting_context.rst\n    \"\"\"\n    if context is None:\n        context_dict = {k: mpl.rcParams[k] for k in _context_keys}\n    elif isinstance(context, dict):\n        context_dict = context\n    else:\n        contexts = ['paper', 'notebook', 'talk', 'poster']\n        if context not in contexts:\n            raise ValueError(f\"context must be in {', '.join(contexts)}\")\n        texts_base_context = {'font.size': 12, 'axes.labelsize': 12,\n            'axes.titlesize': 12, 'xtick.labelsize': 11, 'ytick.labelsize':\n            11, 'legend.fontsize': 11, 'legend.title_fontsize': 12}\n        base_context = {'axes.linewidth': 1.25, 'grid.linewidth': 1,\n            'lines.linewidth': 1.5, 'lines.markersize': 6,\n            'patch.linewidth': 1, 'xtick.major.width': 1.25,\n            'ytick.major.width': 1.25, 'xtick.minor.width': 1,\n            'ytick.minor.width': 1, 'xtick.major.size': 6,\n            'ytick.major.size': 6, 'xtick.minor.size': 4, 'ytick.minor.size': 4\n            }\n        base_context.update(texts_base_context)\n        scaling = dict(paper=0.8, notebook=1, talk=1.5, poster=2)[context]\n        context_dict = {k: (v * scaling) for k, v in base_context.items()}\n        font_keys = texts_base_context.keys()\n        font_dict = {k: (context_dict[k] * font_scale) for k in font_keys}\n        context_dict.update(font_dict)\n    if rc is not None:\n        rc = {k: v for k, v in rc.items() if k in _context_keys}\n        context_dict.update(rc)\n    context_object = _PlottingContext(context_dict)\n    return context_object", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "instruction": "Functionality:\nThe plotting_context function is designed to get the parameters that control the scaling of various plot elements such as label sizes, line thickness, and other visual aspects. It allows for the customization of plot aesthetics, making it easier to tailor plots for different contexts such as paper, notebook, talk, or poster presentations. The function can also be used as a context manager to temporarily alter the global defaults.\n\nInputs:\n- context: None, dict, or one of {paper, notebook, talk, poster}\n  A dictionary of parameters or the name of a preconfigured set. If None, the current context is returned.\n- font_scale: float, optional\n  A separate scaling factor to independently scale the size of the font elements. Default is 1.\n- rc: dict, optional\n  Parameter mappings to override the values in the preset seaborn context dictionaries. This only updates parameters considered part of the context definition.\n\nOutputs:\n- context_object: _PlottingContext object\n  A light wrapper on a dictionary that can be used to set the context temporarily or returned as is. It contains the scaled parameters for plot elements based on the specified context and scaling factors.", "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"method_name": "set_palette", "full_method_name": "set_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/rcmod.py", "method_code": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    \"\"\"Set the matplotlib color cycle using a seaborn palette.\n\n    Parameters\n    ----------\n    palette : seaborn color palette | matplotlib colormap | hls | husl\n        Palette definition. Should be something :func:`color_palette` can process.\n    n_colors : int\n        Number of colors in the cycle. The default number of colors will depend\n        on the format of ``palette``, see the :func:`color_palette`\n        documentation for more information.\n    desat : float\n        Proportion to desaturate each color by.\n    color_codes : bool\n        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand\n        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.\n\n    See Also\n    --------\n    color_palette : build a color palette or set the color cycle temporarily\n                    in a ``with`` statement.\n    set_context : set parameters to scale plot elements\n    set_style : set the default parameters for figure style\n\n    \"\"\"\n    colors = palettes.color_palette(palette, n_colors, desat)\n    cyl = cycler('color', colors)\n    mpl.rcParams['axes.prop_cycle'] = cyl\n    if color_codes:\n        try:\n            palettes.set_color_codes(palette)\n        except (ValueError, TypeError):\n            pass", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The set_palette function enables users to set the color cycle for matplotlib plots using a seaborn palette, a matplotlib colormap, or predefined systems like hls or husl. It can adjust the number of colors, desaturate colors, and remap shorthand color codes to the selected palette.\n\nInputs: \n1. palette: A seaborn color palette, a matplotlib colormap, \"hls\", or \"husl\". This defines the palette that will be used.\n2. n_colors: An optional integer specifying the number of colors in the color cycle. The default number depends on the format of the palette.\n3. desat: An optional float representing the proportion to desaturate each color by.\n4. color_codes: A boolean. If True and palette is a seaborn palette, it remaps the shorthand color codes to the colors from this palette.\n\nOutputs: \nThe function does not return any output; instead, it sets the color cycle for matplotlib and remaps color codes if applicable. ", "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"method_name": "_validate_errorbar_arg", "full_method_name": "_validate_errorbar_arg", "method_path": "../srcdata/Visualization/seaborn/seaborn/_statistics.py", "method_code": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\ndef _validate_errorbar_arg(arg):\n    \"\"\"Check type and value of errorbar argument and assign default level.\"\"\"\n    DEFAULT_LEVELS = {'ci': 95, 'pi': 95, 'se': 1, 'sd': 1}\n    usage = '`errorbar` must be a callable, string, or (string, number) tuple'\n    if arg is None:\n        return None, None\n    elif callable(arg):\n        return arg, None\n    elif isinstance(arg, str):\n        method = arg\n        level = DEFAULT_LEVELS.get(method, None)\n    else:\n        try:\n            method, level = arg\n        except (ValueError, TypeError) as err:\n            raise err.__class__(usage) from err\n    _check_argument('errorbar', list(DEFAULT_LEVELS), method)\n    if level is not None and not isinstance(level, Number):\n        raise TypeError(usage)\n    return method, level", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "instruction": "Functionality: The _validate_errorbar_arg function is designed to validate and process the argument provided for error bar calculation methods in data visualization. It checks the type and value of the given argument, ensures it conforms to the expected format, and assigns default confidence levels where necessary. This function is crucial for preprocessing input before error bars are calculated and plotted.\n\nInputs:\n- arg: This can be None, a callable function, a string representing the error bar calculation method, or a tuple. If a tuple, it should contain a string and a number, where the string is the method and the number is the confidence level or number of standard deviations/standard errors associated with the method.\n\nOutputs:\n- Returns a tuple (method, level) where:\n  - method: A string representing the method of calculating the error bars ('ci' for confidence interval, 'pi' for prediction interval, 'se' for standard error, 'sd' for standard deviation, or a custom method if provided as a callable).\n  - level: A number representing the confidence level or number of standard deviations/standard errors. If the method is predefined ('ci', 'pi', 'se', 'sd') and no level is specified, a default level is assigned based on the method.", "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"method_name": "palplot", "full_method_name": "palplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/miscplot.py", "method_code": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\ndef palplot(pal, size=1):\n    \"\"\"Plot the values in a color palette as a horizontal array.\n\n    Parameters\n    ----------\n    pal : sequence of matplotlib colors\n        colors, i.e. as returned by seaborn.color_palette()\n    size :\n        scaling factor for size of plot\n\n    \"\"\"\n    n = len(pal)\n    _, ax = plt.subplots(1, 1, figsize=(n * size, size))\n    ax.imshow(np.arange(n).reshape(1, n), cmap=mpl.colors.ListedColormap(\n        list(pal)), interpolation='nearest', aspect='auto')\n    ax.set_xticks(np.arange(n) - 0.5)\n    ax.set_yticks([-0.5, 0.5])\n    ax.set_xticklabels(['' for _ in range(n)])\n    ax.yaxis.set_major_locator(ticker.NullLocator())", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "instruction": "Functionality: The 'palplot' function is designed to visualize a color palette as a horizontal array for better understanding and comparison of colors. It takes a sequence of matplotlib colors and optionally a scaling factor to adjust the size of the plot. The function then creates a plot where the colors are shown in a horizontal sequence, making it easier to inspect and compare individual colors within the palette.\n\nInputs:\n- pal : A sequence of matplotlib colors (e.g., as obtained from seaborn.color_palette())\n- size : A scaling factor for the size of the plot (default is 1)\n\nOutputs:\n- None directly, but it generates a matplotlib plot which displays the color palette horizontally. The plot's size can be adjusted using the 'size' parameter, and it includes a horizontal array of colors with their respective labels hidden. The vertical axis is hidden to focus solely on the horizontal color representation.", "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"method_name": "_matrix_mask", "full_method_name": "_matrix_mask", "method_path": "../srcdata/Visualization/seaborn/seaborn/matrix.py", "method_code": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\ndef _matrix_mask(data, mask):\n    \"\"\"Ensure that data and mask are compatible and add missing values.\n\n    Values will be plotted for cells where ``mask`` is ``False``.\n\n    ``data`` is expected to be a DataFrame; ``mask`` can be an array or\n    a DataFrame.\n\n    \"\"\"\n    if mask is None:\n        mask = np.zeros(data.shape, bool)\n    if isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError('Mask must have the same shape as data.')\n        mask = pd.DataFrame(mask, index=data.index, columns=data.columns,\n            dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if not mask.index.equals(data.index) and mask.columns.equals(data.\n            columns):\n            err = 'Mask must have the same index and columns as data.'\n            raise ValueError(err)\n    mask = mask | pd.isnull(data)\n    return mask", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "instruction": "Functionality: The _matrix_mask function ensures that a given data and mask are compatible and adds missing values to the mask where necessary. It is designed to prepare data for visualization where only non-masked (False) values will be plotted. The function supports both DataFrame and ndarray inputs for the mask, ensuring it matches the data's shape and indices.\n\nInputs: \n- data: A pandas DataFrame containing the data to be masked.\n- mask: An optional input that can be a numpy ndarray or a pandas DataFrame. If not provided, a zero-filled mask of the same shape as 'data' is created. The mask should denote which data elements should be plotted (False) and which should be ignored (True).\n\nOutputs:\n- A pandas DataFrame representing the updated mask, where missing values in the 'data' DataFrame are automatically marked as True in the mask DataFrame. This ensures that only valid data points are available for plotting when the mask is applied.", "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"method_name": "bootstrap", "full_method_name": "bootstrap", "method_path": "../srcdata/Visualization/seaborn/seaborn/algorithms.py", "method_code": "import numpy as np\nimport warnings\ndef bootstrap(*args, **kwargs):\n    \"\"\"Resample one or more arrays with replacement and store aggregate values.\n\n    Positional arguments are a sequence of arrays to bootstrap along the first\n    axis and pass to a summary function.\n\n    Keyword arguments:\n        n_boot : int, default=10000\n            Number of iterations\n        axis : int, default=None\n            Will pass axis to ``func`` as a keyword argument.\n        units : array, default=None\n            Array of sampling unit IDs. When used the bootstrap resamples units\n            and then observations within units instead of individual\n            datapoints.\n        func : string or callable, default=\"mean\"\n            Function to call on the args that are passed in. If string, uses as\n            name of function in the numpy namespace. If nans are present in the\n            data, will try to use nan-aware version of named function.\n        seed : Generator | SeedSequence | RandomState | int | None\n            Seed for the random number generator; useful if you want\n            reproducible resamples.\n\n    Returns\n    -------\n    boot_dist: array\n        array of bootstrapped statistic values\n\n    \"\"\"\n    if len(np.unique(list(map(len, args)))) > 1:\n        raise ValueError('All input arrays must have the same length')\n    n = len(args[0])\n    n_boot = kwargs.get('n_boot', 10000)\n    func = kwargs.get('func', 'mean')\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    random_seed = kwargs.get('random_seed', None)\n    if random_seed is not None:\n        msg = '`random_seed` has been renamed to `seed` and will be removed'\n        warnings.warn(msg)\n    seed = kwargs.get('seed', random_seed)\n    if axis is None:\n        func_kwargs = dict()\n    else:\n        func_kwargs = dict(axis=axis)\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    else:\n        rng = np.random.default_rng(seed)\n    args = list(map(np.asarray, args))\n    if units is not None:\n        units = np.asarray(units)\n    if isinstance(func, str):\n        f = getattr(np, func)\n        missing_data = np.isnan(np.sum(np.column_stack(args)))\n        if missing_data and not func.startswith('nan'):\n            nanf = getattr(np, f'nan{func}', None)\n            if nanf is None:\n                msg = (\n                    f'Data contain nans but no nan-aware version of `{func}` found'\n                    )\n                warnings.warn(msg, UserWarning)\n            else:\n                f = nanf\n    else:\n        f = func\n    try:\n        integers = rng.integers\n    except AttributeError:\n        integers = rng.randint\n    if units is not None:\n        return _structured_bootstrap(args, n_boot, units, f, func_kwargs,\n            integers)\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n, n, dtype=np.intp)\n        sample = [a.take(resampler, axis=0) for a in args]\n        boot_dist.append(f(*sample, **func_kwargs))\n    return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "instruction": "Functionality: The bootstrap function allows for the resampling of one or more arrays with replacement to calculate the distribution of a statistic. This function is particularly useful for estimating the sampling distribution of a statistic in situations where the data does not follow a known distribution.\n\nInputs:\n- Positional arguments: A sequence of arrays to bootstrap along the first axis and pass to a summary function.\n- Keyword arguments:\n  - n_boot : int (default=10000) - Number of bootstrap iterations.\n  - axis : int (default=None) - Axis to pass to the 'func' as a keyword argument, typically for applying the function over specific axes.\n  - units : array (default=None) - Array of sampling unit IDs for structured resampling.\n  - func : string or callable (default=\"mean\") - Function to apply to the resampled data. Can be a string naming a NumPy function or a callable function.\n  - seed : (default=None) - Seed for the random number generator for reproducibility. Can be a Generator, SeedSequence, RandomState, integer, or None.\n\nOutputs:\n- boot_dist : array - An array of bootstrapped statistic values obtained from applying 'func' across the input arrays for each bootstrap iteration.", "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"method_name": "bootstrap", "full_method_name": "bootstrap", "method_path": "../srcdata/Visualization/seaborn/seaborn/algorithms.py", "method_code": "import numpy as np\nimport warnings\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\ndef bootstrap(*args, **kwargs):\n    \"\"\"Resample one or more arrays with replacement and store aggregate values.\n    Positional arguments are a sequence of arrays to bootstrap along the first\n    axis and pass to a summary function.\n    Keyword arguments:\n        n_boot : int, default=10000\n            Number of iterations\n        axis : int, default=None\n            Will pass axis to ``func`` as a keyword argument.\n        units : array, default=None\n            Array of sampling unit IDs. When used the bootstrap resamples units\n            and then observations within units instead of individual\n            datapoints.\n        func : string or callable, default=\"mean\"\n            Function to call on the args that are passed in. If string, uses as\n            name of function in the numpy namespace. If nans are present in the\n            data, will try to use nan-aware version of named function.\n        seed : Generator | SeedSequence | RandomState | int | None\n            Seed for the random number generator; useful if you want\n            reproducible resamples.\n    Returns\n    -------\n    boot_dist: array\n        array of bootstrapped statistic values\n    \"\"\"\n    if len(np.unique(list(map(len, args)))) > 1:\n        raise ValueError('All input arrays must have the same length')\n    n = len(args[0])\n    n_boot = kwargs.get('n_boot', 10000)\n    func = kwargs.get('func', 'mean')\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    random_seed = kwargs.get('random_seed', None)\n    if random_seed is not None:\n        msg = '`random_seed` has been renamed to `seed` and will be removed'\n        warnings.warn(msg)\n    seed = kwargs.get('seed', random_seed)\n    if axis is None:\n        func_kwargs = dict()\n    else:\n        func_kwargs = dict(axis=axis)\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    else:\n        rng = np.random.default_rng(seed)\n    args = list(map(np.asarray, args))\n    if units is not None:\n        units = np.asarray(units)\n    if isinstance(func, str):\n        f = getattr(np, func)\n        missing_data = np.isnan(np.sum(np.column_stack(args)))\n        if missing_data and not func.startswith('nan'):\n            nanf = getattr(np, f'nan{func}', None)\n            if nanf is None:\n                msg = (\n                    f'Data contain nans but no nan-aware version of `{func}` found'\n                    )\n                warnings.warn(msg, UserWarning)\n            else:\n                f = nanf\n    else:\n        f = func\n    try:\n        integers = rng.integers\n    except AttributeError:\n        integers = rng.randint\n    if units is not None:\n        return _structured_bootstrap(args, n_boot, units, f, func_kwargs,\n            integers)\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n, n, dtype=np.intp)\n        sample = [a.take(resampler, axis=0) for a in args]\n        boot_dist.append(f(*sample, **func_kwargs))\n    return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "instruction": "Functionality: The bootstrap function is used to resample one or more arrays with replacement and store aggregate values, which is useful for estimating the statistical properties of a dataset through resampling. It can also resample based on units, instead of individual data points, and applies a specified summary function to the resampled data.\n\nInputs: \n- *args (positional): A sequence of arrays to bootstrap along the first axis and pass to a summary function.\n- **kwargs (keyword arguments): \n  - n_boot: An integer representing the number of bootstrap iterations (default: 10000).\n  - axis: An integer specifying the axis to pass to the summary function (default: None).\n  - units: An array indicating sampling unit IDs for resampling at the unit level (default: None).\n  - func: A string or callable function that defines the summary function to apply to the resampled data (default: \"mean\").\n  - seed: A seed for the random number generator, which can be a Generator, SeedSequence, RandomState, an integer, or None (default: None).\n\nOutputs: \n- boot_dist: An array containing the bootstrapped statistic values obtained by applying the summary function to the resampled data.", "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"method_name": "hls_palette", "full_method_name": "hls_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"\n    Return hues with constant lightness and saturation in the HLS system.\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n    The `h`, `l`, and `s` values should be between 0 and 1.\n    .. note::\n        While the separation of the resulting colors will be mathematically\n        constant, the HLS system does not construct a perceptually-uniform space,\n        so their apparent intensity will vary.\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    husl_palette : Make a palette using evenly spaced hues in the HUSL system.\n    Examples\n    --------\n    .. include:: ../docstrings/hls_palette.rst\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues -= hues.astype(int)\n    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, 'hls')\n    else:\n        return _ColorPalette(palette)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: \nThe hls_palette function generates a color palette with a specified number of colors, where each color has constant lightness and saturation in the HLS color system. The hues are evenly distributed along a circular path, making the palette suitable for categorical or cyclical data. The function supports specifying the number of colors, the starting hue, and the lightness and saturation values. It can return either a list of RGB tuples or a matplotlib colormap object based on the as_cmap parameter.\n\nInputs:\n- n_colors: An integer representing the number of colors in the palette (default is 6).\n- h: A float value representing the hue for the first color in the palette, which cycles continuously (default is 0.01).\n- l: A float value specifying the lightness of colors (default is 0.6).\n- s: A float value specifying the saturation of colors (default is 0.65).\n- as_cmap: A boolean value that, if set to True, returns a matplotlib colormap object instead of a list of RGB tuples (default is False).\n\nOutputs:\n- A list of RGB tuples or a matplotlib colormap object, depending on the value of as_cmap. The output represents a color palette with the specified number of colors, each having the defined lightness and saturation.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"method_name": "husl_palette", "full_method_name": "husl_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"\n    Return hues with constant lightness and saturation in the HUSL system.\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n    The `h`, `l`, and `s` values should be between 0 and 1.\n    This function is similar to :func:`hls_palette`, but it uses a nonlinear color\n    space that is more perceptually uniform.\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    hls_palette : Make a palette using evenly spaced hues in the HSL system.\n    Examples\n    --------\n    .. include:: ../docstrings/husl_palette.rst\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues *= 359\n    s *= 99\n    l *= 99\n    palette = [_color_to_rgb((h_i, s, l), input='husl') for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, 'hsl')\n    else:\n        return _ColorPalette(palette)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: Generate a color palette with hues sampled evenly in the HUSL color space, ensuring colors have perceptually uniform lightness and saturation. This palette is suitable for categorical or cyclical data visualization.\n\nInputs:\n- n_colors: int, optional (default=6), the number of colors in the palette.\n- h: float, optional (default=0.01), the starting hue value, should be between 0 and 1.\n- s: float, optional (default=0.9), the saturation value, should be between 0 and 1.\n- l: float, optional (default=0.65), the lightness value, should be between 0 and 1.\n- as_cmap: bool, optional (default=False), if True, returns a matplotlib colormap object instead of a list of colors.\n\nOutputs:\n- palette: a list of RGB tuples or a matplotlib colormap object, depending on the value of as_cmap.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"method_name": "mpl_palette", "full_method_name": "mpl_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    \"\"\"\n    Return a palette or colormap from the matplotlib registry.\n    For continuous palettes, evenly-spaced discrete samples are chosen while\n    excluding the minimum and maximum value in the colormap to provide better\n    contrast at the extremes.\n    For qualitative palettes (e.g. those from colorbrewer), exact values are\n    indexed (rather than interpolated), but fewer than `n_colors` can be returned\n    if the palette does not define that many.\n    Parameters\n    ----------\n    name : string\n        Name of the palette. This should be a named matplotlib colormap.\n    n_colors : int\n        Number of discrete colors in the palette.\n    Returns\n    -------\n    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include:: ../docstrings/mpl_palette.rst\n    \"\"\"\n    if name.endswith('_d'):\n        sub_name = name[:-2]\n        if sub_name.endswith('_r'):\n            reverse = True\n            sub_name = sub_name[:-2]\n        else:\n            reverse = False\n        pal = color_palette(sub_name, 2) + ['#333333']\n        if reverse:\n            pal = pal[::-1]\n        cmap = blend_palette(pal, n_colors, as_cmap=True)\n    else:\n        cmap = get_colormap(name)\n    if name in MPL_QUAL_PALS:\n        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]\n    else:\n        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]\n    palette = list(map(tuple, cmap(bins)[:, :3]))\n    if as_cmap:\n        return cmap\n    else:\n        return _ColorPalette(palette)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The mpl_palette function generates a color palette or colormap from the matplotlib registry, which can be used for various visualization purposes in data analysis and plotting.\n\nInputs:\n- name: A string representing the name of the palette. This should be a named matplotlib colormap.\n- n_colors: An integer specifying the number of discrete colors in the palette. Default is 6.\n- as_cmap: A boolean indicating whether to return the result as a matplotlib ListedColormap (True) or a list of RGB tuples (False). Default is False.\n\nOutputs:\n- If as_cmap is False, returns a _ColorPalette object containing a list of RGB tuples representing the colors in the palette.\n- If as_cmap is True, returns a matplotlib colors ListedColormap object representing the palette.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"method_name": "_color_to_rgb", "full_method_name": "_color_to_rgb", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The function _color_to_rgb converts a given color to its RGB representation. It supports various color input formats including HLS, HUSL, and XKCD color names. The function aims to provide flexibility in handling different color representation methods, ultimately converting them to a standardized RGB format that can be easily utilized in various graphical or visual applications.\n\nInputs: \n- color: A single color argument which can be in the form of an HLS tuple, a HUSL tuple, an XKCD color name, or any color representation that can be recognized by the Matplotlib library.\n- input: A string specifying the input color space ('hls', 'husl', or 'xkcd').\n\nOutputs:\n- Returns a tuple representing the RGB values of the input color. The RGB values are in the range of 0 to 1, following the convention used by Matplotlib for color representation.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"method_name": "dark_palette", "full_method_name": "dark_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Make a sequential palette that blends from dark to ``color``.\n    This kind of palette is good for data that range between relatively\n    uninteresting low values and interesting high values.\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n    If you are using the IPython notebook, you can also choose this palette\n    interactively with the :func:`choose_dark_palette` function.\n    Parameters\n    ----------\n    color : base color for high values\n        hex, rgb-tuple, or html color name\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette with two colors.\n    Examples\n    --------\n    .. include:: ../docstrings/dark_palette.rst\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    hue, sat, _ = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = 0.15 * sat, 15\n    gray = _color_to_rgb((hue, gray_s, gray_l), input='husl')\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The function 'dark_palette' is designed to create a sequential color palette that blends from a dark shade to a specified color. This palette is particularly useful for visualizing data where low values are less significant and high values are more interesting. The function supports various color input formats and can generate the palette in reverse order or as a matplotlib colormap.\n\nInputs: \n1. color: The base color for high values in the palette. This can be specified as a hex code, RGB tuple, or HTML color name.\n2. n_colors (optional): An integer value indicating the number of colors in the palette. Default is 6.\n3. reverse (optional): A boolean value. If True, the direction of the blend is reversed, starting from the specified color to a darker shade. Default is False.\n4. as_cmap (optional): A boolean value. If True, the function returns a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n5. input (optional): A string indicating the color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n\nOutputs:\n1. palette: A list of RGB tuples representing the color palette, or a matplotlib ListedColormap, depending on the 'as_cmap' parameter.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"method_name": "blend_palette", "full_method_name": "blend_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The blend_palette function creates a color palette by blending between a list of specified colors. It can return either a list of RGB tuples representing the blended colors or a matplotlib colormap, depending on the parameters provided.\n\nInputs:\n- colors: A sequence of colors provided in various formats, such as hex codes, HTML color names, or tuples in the color space specified by the 'input' parameter.\n- n_colors: An optional integer that determines the number of colors in the palette. The default value is 6.\n- as_cmap: An optional boolean indicating whether to return a matplotlib colormap. The default is False, which means the function will return a list of RGB tuples.\n- input: An optional string specifying the color space of the input colors. The default is 'rgb'. Other possible values include 'hls', 'husl', and 'xkcd'.\n\nOutputs:\n- palette: The function returns either a list of RGB tuples or a matplotlib colormap, depending on the value of the 'as_cmap' parameter. If as_cmap is False (default), the output is a list of RGB tuples representing the blended colors. If as_cmap is True, the output is a matplotlib colormap that can be used for color mapping in plots.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"method_name": "cubehelix_palette", "full_method_name": "cubehelix_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \"\"\"Make a sequential palette from the cubehelix system.\n    This produces a colormap with linearly-decreasing (or increasing)\n    brightness. That means that information will be preserved if printed to\n    black and white or viewed by someone who is colorblind.  \"cubehelix\" is\n    also available as a matplotlib-based palette, but this function gives the\n    user more control over the look of the palette and has a different set of\n    defaults.\n    In addition to using this function, it is also possible to generate a\n    cubehelix palette generally in seaborn using a string starting with\n    `ch:` and containing other parameters (e.g. `\"ch:s=.25,r=-.5\"`).\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    start : float, 0 <= start <= 3\n        The hue value at the start of the helix.\n    rot : float\n        Rotations around the hue wheel over the range of the palette.\n    gamma : float 0 <= gamma\n        Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors.\n    hue : float, 0 <= hue <= 1\n        Saturation of the colors.\n    dark : float 0 <= dark <= 1\n        Intensity of the darkest color in the palette.\n    light : float 0 <= light <= 1\n        Intensity of the lightest color in the palette.\n    reverse : bool\n        If True, the palette will go from dark to light.\n    as_cmap : bool\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    choose_cubehelix_palette : Launch an interactive widget to select cubehelix\n                               palette parameters.\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    References\n    ----------\n    Green, D. A. (2011). \"A colour scheme for the display of astronomical\n    intensity images\". Bulletin of the Astromical Society of India, Vol. 39,\n    p. 289-295.\n    Examples\n    --------\n    .. include:: ../docstrings/cubehelix_palette.rst\n    \"\"\"\n    def get_color_function(p0, p1):\n        def color(x):\n            xg = x ** gamma\n            a = hue * xg * (1 - xg) / 2\n            phi = 2 * np.pi * (start / 3 + rot * x)\n            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))\n        return color\n    cdict = {'red': get_color_function(-0.14861, 1.78277), 'green':\n        get_color_function(-0.29227, -0.90649), 'blue': get_color_function(\n        1.97294, 0.0)}\n    cmap = mpl.colors.LinearSegmentedColormap('cubehelix', cdict)\n    x = np.linspace(light, dark, int(n_colors))\n    pal = cmap(x)[:, :3].tolist()\n    if reverse:\n        pal = pal[::-1]\n    if as_cmap:\n        x_256 = np.linspace(light, dark, 256)\n        if reverse:\n            x_256 = x_256[::-1]\n        pal_256 = cmap(x_256)\n        cmap = mpl.colors.ListedColormap(pal_256, 'seaborn_cubehelix')\n        return cmap\n    else:\n        return _ColorPalette(pal)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The function 'cubehelix_palette' creates a sequential color palette based on the Cubehelix color system. This system ensures that the colors have linearly decreasing or increasing brightness, which helps in preserving information when printed to black and white or viewed by someone who is colorblind. The function allows for detailed control over the look of the palette, including parameters to adjust hue, saturation, lightness, and direction of the color gradient.\n\nInputs: \n- n_colors: An integer that specifies the number of colors in the palette.\n- start: A float in the range [0, 3] that represents the hue value at the start of the helix.\n- rot: A float that determines the number of rotations around the hue wheel over the range of the palette.\n- gamma: A float, 0 <= gamma, that controls the nonlinearity of the palette to emphasize darker or lighter colors.\n- hue: A float in the range [0, 1] that sets the saturation of the colors.\n- dark: A float in the range [0, 1] that determines the intensity of the darkest color in the palette.\n- light: A float in the range [0, 1] that determines the intensity of the lightest color in the palette.\n- reverse: A boolean that indicates whether the palette should go from dark to light or light to dark.\n- as_cmap: A boolean that, if True, returns a matplotlib colors ListedColormap instead of a list of RGB tuples.\n\nOutputs: \n- A list of RGB tuples or a matplotlib colors ListedColormap, depending on the value of 'as_cmap'.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"method_name": "set_color_codes", "full_method_name": "set_color_codes", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\ndef set_color_codes(palette='deep'):\n    \"\"\"Change how matplotlib color shorthands are interpreted.\n    Calling this will change how shorthand codes like \"b\" or \"g\"\n    are interpreted by matplotlib in subsequent plots.\n    Parameters\n    ----------\n    palette : {deep, muted, pastel, dark, bright, colorblind}\n        Named seaborn palette to use as the source of colors.\n    See Also\n    --------\n    set : Color codes can be set through the high-level seaborn style\n          manager.\n    set_palette : Color codes can also be set through the function that\n                  sets the matplotlib color cycle.\n    \"\"\"\n    if palette == 'reset':\n        colors = [(0.0, 0.0, 1.0), (0.0, 0.5, 0.0), (1.0, 0.0, 0.0), (0.75,\n            0.0, 0.75), (0.75, 0.75, 0.0), (0.0, 0.75, 0.75), (0.0, 0.0, 0.0)]\n    elif not isinstance(palette, str):\n        err = 'set_color_codes requires a named seaborn palette'\n        raise TypeError(err)\n    elif palette in SEABORN_PALETTES:\n        if not palette.endswith('6'):\n            palette = palette + '6'\n        colors = SEABORN_PALETTES[palette] + [(0.1, 0.1, 0.1)]\n    else:\n        err = f\"Cannot set colors with palette '{palette}'\"\n        raise ValueError(err)\n    for code, color in zip('bgrmyck', colors):\n        rgb = mpl.colors.colorConverter.to_rgb(color)\n        mpl.colors.colorConverter.colors[code] = rgb", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: The set_color_codes function changes how matplotlib color shorthands are interpreted for subsequent plots. It updates the color codes, such as \"b\" or \"g\", to represent colors from a chosen seaborn palette.\n\nInputs: \n- palette: a string representing a named seaborn color palette. Valid values are 'deep', 'muted', 'pastel', 'dark', 'bright', 'colorblind', or 'reset'. If 'reset' is provided, the default matplotlib color codes will be restored. If a palette name is given, the function will use the corresponding colors for the shorthand codes.\n\nOutputs:\n- The function does not return any value. Its effect is to modify the matplotlib color code mappings, so that shorthand codes like \"b\" or \"g\" correspond to colors from the specified seaborn palette. This change is global and will affect all subsequent plots created using matplotlib.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"method_name": "_patch_colormap_display", "full_method_name": "_patch_colormap_display", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\ndef _patch_colormap_display():\n    \"\"\"Simplify the rich display of matplotlib color maps in a notebook.\"\"\"\n\n    def _repr_png_(self):\n        \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n        import io\n        from PIL import Image\n        import numpy as np\n        IMAGE_SIZE = 400, 50\n        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))\n        pixels = self(X, bytes=True)\n        png_bytes = io.BytesIO()\n        Image.fromarray(pixels).save(png_bytes, format='png')\n        return png_bytes.getvalue()\n\n    def _repr_html_(self):\n        \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n        import base64\n        png_bytes = self._repr_png_()\n        png_base64 = base64.b64encode(png_bytes).decode('ascii')\n        return ('<img ' + 'alt=\"' + self.name + ' color map\" ' + 'title=\"' +\n            self.name + '\"' + 'src=\"data:image/png;base64,' + png_base64 + '\">'\n            )\n    mpl.colors.Colormap._repr_png_ = _repr_png_\n    mpl.colors.Colormap._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "instruction": "Functionality: This function, _patch_colormap_display, enhances the display of matplotlib color maps in a Jupyter notebook environment. It adds methods to the Colormap class to generate and return representations of the colormap as PNG images and HTML code. This allows for a more visually rich display of colormaps when using the notebook's display system.\n\nInputs: There are no direct input arguments to this function. However, it operates on the matplotlib's Colormap class by patching it with additional methods.\n\nOutputs: The function does not return any value directly. Its effect is to modify the behavior of the Colormap class by adding two methods: _repr_png_ and _repr_html_, which return a PNG image and HTML code respectively, representing the colormap.", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"method_name": "countplot", "full_method_name": "countplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/categorical.py", "method_code": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs):\n    if x is None and y is not None:\n        orient = 'y'\n        x = 1 if list(y) else None\n    elif x is not None and y is None:\n        orient = 'x'\n        y = 1 if list(x) else None\n    elif x is not None and y is not None:\n        raise TypeError('Cannot pass values for both `x` and `y`.')\n    p = _CategoricalAggPlotter(data=data, variables=dict(x=x, y=y, hue=hue),\n        order=order, orient=orient, color=color, legend=legend)\n    if ax is None:\n        ax = plt.gca()\n    if p.plot_data.empty:\n        return ax\n    if dodge == 'auto':\n        dodge = p._dodge_needed()\n    if p.var_types.get(p.orient) == 'categorical' or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n    p._attach(ax, log_scale=log_scale)\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n    saturation = saturation if fill else 1\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=\n        saturation)\n    color = _default_color(ax.bar, hue, color, kwargs, saturation)\n    count_axis = {'x': 'y', 'y': 'x'}[p.orient]\n    if p.input_format == 'wide':\n        p.plot_data[count_axis] = 1\n    _check_argument('stat', ['count', 'percent', 'probability',\n        'proportion'], stat)\n    p.variables[count_axis] = stat\n    if stat != 'count':\n        denom = 100 if stat == 'percent' else 1\n        p.plot_data[count_axis] /= len(p.plot_data) / denom\n    aggregator = EstimateAggregator('sum', errorbar=None)\n    p.plot_bars(aggregator=aggregator, dodge=dodge, width=width, gap=gap,\n        color=color, fill=fill, capsize=0, err_kws={}, plot_kws=kwargs)\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n    return ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "instruction": "Functionality: The countplot function in seaborn library is used to show the counts of observations in each categorical bin using bars. It can handle both univariate and bivariate categorical data.\n\nInputs: \n- data: pandas DataFrame, Series, or array-like. Input data structure.\n- x, y: strings, optional. Keys in data. Only one can be None.\n- hue: string, optional. Grouping variable that will produce lines with different colors.\n- order, hue_order: lists, optional. Order to plot the categorical levels in, otherwise the categories sorted in the order they first appear in the data.\n- orient: 'v' | 'h', optional. Orientation of the plot (vertical or horizontal).\n- color: matplotlib color, optional. Color for all of the elements, or seed for a gradient palette.\n- palette: palette name, list, or dict, optional. Colors to use for the different levels of the hue variable. Should be something that can be interpreted by color_palette.\n- saturation: float, optional. Proportion of the original saturation to draw colors at. Large patches often look better with slightly desaturated colors, but set this to 1 if you want the plot colors to perfectly match the input color spec.\n- fill: bool, optional. If True, fill the bars with the respective colors.\n- hue_norm: 2-tuple or `matplotlib.colors.Normalize` instance, optional. If this is specified, the hue values will be transformed before being assigned to the mapping of color codes.\n- stat: string, optional. The statistical transformation to use on the data for this plot, either \"count\", \"percent\", \"probability\", or \"proportion\".\n- width: float, optional. Width of a full element when not using hue nesting, or width of all the elements for one level of the major grouping variable.\n- dodge: 'auto' | bool, optional. Whether to separately shift the centers of the bars for each level of the hue variable.\n- gap: float, optional. Size of the gap (relative to the size of the plot elements) that separates elements with different levels of the hue variable.\n- log_scale: bool or 2-tuple, optional. If True, set the axes to a log scale.\n- native_scale: bool, optional. If True, and the data is in a long-form format, each bin will be scaled independently; otherwise the count will be computed across the full dataset.\n- formatter: function, optional. A function to convert the values of the counts to strings.\n- legend: string, optional. Controls the drawing of a legend for the hue variable. If 'brief', only the variable name will be shown. If 'full', individual labels will be provided for each level. If False, no legend data is added and any existing legend will be removed.\n- ax: matplotlib Axes, optional. Axes object to draw the plot onto, otherwise uses the current Axes.\n- **kwargs: Other keyword arguments are passed to the matplotlib function to draw the bars.\n\nOutputs:\n- ax: matplotlib Axes. Returns the Axes object with the plot drawn onto it.", "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"method_name": "categorical_order", "full_method_name": "categorical_order", "method_path": "../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "method_code": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\ndef categorical_order(vector: Series, order: (list | None)=None) ->list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        return order\n    if vector.dtype.name == 'category':\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(pd.Series(order)) == 'numeric':\n            order.sort()\n    return order", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "instruction": "Functionality: The categorical_order function is designed to return a list of unique data values ordered according to seaborn's rules for categorical data. It is capable of handling various types of input vectors and can sort them in a specific order if required.\n\nInputs: \n- vector: A pandas Series containing categorical data that needs to be sorted. This vector can contain different types of categorical values, including strings and numbers.\n- order: (Optional) A list specifying the desired order of category levels. If provided, the function will sort the data according to this custom order, overriding any inherent order determined from the data.\n\nOutputs:\n- order: A list of ordered category levels, excluding null values. The output list will contain the unique data values from the input vector, sorted according to seaborn's rules or the custom order provided by the user.", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"method_name": "variable_type", "full_method_name": "variable_type", "method_path": "../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "method_code": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False) ->VarType:\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in a few ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n    - There is some flexibility about how to treat binary / boolean data.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric', 'categorical', or 'boolean'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n    strict_boolean : bool\n        If True, only consider data to be boolean when the dtype is bool or Boolean.\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n    if isinstance(getattr(vector, 'dtype', None), pd.CategoricalDtype):\n        return VarType('categorical')\n    if pd.isna(vector).all():\n        return VarType('numeric')\n    vector = vector.dropna()\n    with warnings.catch_warnings():\n        warnings.simplefilter(action='ignore', category=(FutureWarning,\n            DeprecationWarning))\n        if strict_boolean:\n            if isinstance(vector.dtype, pd.core.dtypes.base.ExtensionDtype):\n                boolean_dtypes = ['bool', 'boolean']\n            else:\n                boolean_dtypes = ['bool']\n            boolean_vector = vector.dtype in boolean_dtypes\n        else:\n            try:\n                boolean_vector = bool(np.isin(vector, [0, 1]).all())\n            except TypeError:\n                boolean_vector = False\n        if boolean_vector:\n            return VarType(boolean_type)\n    if pd.api.types.is_numeric_dtype(vector):\n        return VarType('numeric')\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VarType('datetime')\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n    if all_numeric(vector):\n        return VarType('numeric')\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n    if all_datetime(vector):\n        return VarType('datetime')\n    return VarType('categorical')", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "instruction": "Functionality: Determine the type of data contained within a given vector, categorizing it as either numeric, categorical, or datetime.\n\nInputs:\n- vector: A pandas Series, numpy ndarray, or Python sequence. This is the input data to be tested.\n- boolean_type: A string literal with possible values 'numeric', 'categorical', or 'boolean'. It specifies how vectors containing only 0s and 1s (and NAs) should be classified. Default is 'numeric'.\n- strict_boolean: A boolean value. If True, data is considered boolean only when the dtype is bool or Boolean. Default is False.\n\nOutputs:\n- var_type: A string indicating the type of data in the vector. Possible return values are 'numeric', 'categorical', or 'datetime'. This is returned as an instance of the VarType class.", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
