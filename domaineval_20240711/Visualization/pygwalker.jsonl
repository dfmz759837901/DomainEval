{"method_name": "get_formated_spec_params_code", "full_method_name": "get_formated_spec_params_code", "method_path": "../srcdata/Visualization/pygwalker/pygwalker/services/format_invoke_walk_code.py", "method_code": "from typing import Optional\nfrom typing import List\nfrom types import FrameType\nimport logging\nimport inspect\nimport ast\nfrom astor.source_repr import split_lines\nimport astor\n_MAX_LINE = 150\ndef _private_astor_pretty_source(source: List[str]) ->str:\n    return ''.join(split_lines(source, maxline=_MAX_LINE))\ndef _repalce_spec_params_code(func: 'ast.Call') ->str:\n    replace_value = ast.Constant(value='____pyg_walker_spec_params____')\n    spec_index = -1\n    for index, keyword in enumerate(func.keywords):\n        if keyword.arg == 'spec':\n            spec_index = index\n    if spec_index != -1:\n        func.keywords[spec_index].value = replace_value\n    else:\n        func.keywords.insert(0, ast.keyword(arg='spec', value=replace_value))\n    return astor.to_source(func, pretty_source=_private_astor_pretty_source)\ndef _find_walk_func_node(code: str) ->Optional['ast.Call']:\n    node_list = [ast.parse(code)]\n    while node_list:\n        cur_node = node_list.pop()\n        if isinstance(cur_node, ast.Call):\n            if isinstance(cur_node.func, ast.Name):\n                func_name = cur_node.func.id\n            else:\n                func_name = cur_node.func.attr\n            if func_name == 'walk':\n                return cur_node\n        for node_info in astor.iter_node(cur_node):\n            if isinstance(node_info[0], list):\n                nodes = node_info[0]\n            else:\n                nodes = [node_info[0]]\n            for children_node in nodes:\n                node_list.append(children_node)\ndef get_formated_spec_params_code(code: str) ->str:\n    call_func = _find_walk_func_node(code.strip())\n    if call_func is None:\n        return ''\n    return _repalce_spec_params_code(call_func)", "test_code_list": [{"test_code": "def test_get_formated_spec_params_code():\n    empty_code = ''\n    assert get_formated_spec_params_code(empty_code) == ''\n    normal_code = \"pygwalker.walk(df, env='Streamlit')\"\n    normal_code_result = \"\"\"pygwalker.walk(df, spec='____pyg_walker_spec_params____', env='Streamlit')\n\"\"\"\n    assert get_formated_spec_params_code(normal_code) == normal_code_result\n    new_line_code = \"\\t\\n\\npygwalker.walk(df, \\n\\tenv='Streamlit')\\n\\n\"\n    new_line_code_result = \"\"\"pygwalker.walk(df, spec='____pyg_walker_spec_params____', env='Streamlit')\n\"\"\"\n    assert get_formated_spec_params_code(new_line_code) == new_line_code_result\n\ntest_get_formated_spec_params_code()\n", "code_start": "", "test_path": "../srcdata/Visualization/pygwalker/tests/test_format_invoke_walk_code.py"}], "instruction": "Functionality: The get_formated_spec_params_code function is designed to locate and modify a specific function call within a given code string. It searches for the 'walk' function call and updates the 'spec' keyword argument, if present, to a predefined value. If the 'spec' argument is not found, it adds a new keyword argument 'spec' with the predefined value. The function ensures that the code string is formatted properly after the modifications.\n\nInputs: \n- code: A string containing Python code. This string should not be empty and must contain at least one 'walk' function call.\n\nOutputs:\n- Returns a string with the modified 'walk' function call. If the 'walk' function call is not found, it returns an empty string.", "method_code_mask": "from typing import Optional\nfrom typing import List\nfrom types import FrameType\nimport logging\nimport inspect\nimport ast\nfrom astor.source_repr import split_lines\nimport astor\n_MAX_LINE = 150\n\n\ndef _private_astor_pretty_source(source: List[str]) ->str:\n    return ''.join(split_lines(source, maxline=_MAX_LINE))\n\n\ndef _repalce_spec_params_code(func: 'ast.Call') ->str:\n    replace_value = ast.Constant(value='____pyg_walker_spec_params____')\n    spec_index = -1\n    for index, keyword in enumerate(func.keywords):\n        if keyword.arg == 'spec':\n            spec_index = index\n    if spec_index != -1:\n        func.keywords[spec_index].value = replace_value\n    else:\n        func.keywords.insert(0, ast.keyword(arg='spec', value=replace_value))\n    return astor.to_source(func, pretty_source=_private_astor_pretty_source)\n\n\ndef _find_walk_func_node(code: str) ->Optional['ast.Call']:\n    node_list = [ast.parse(code)]\n    while node_list:\n        cur_node = node_list.pop()\n        if isinstance(cur_node, ast.Call):\n            if isinstance(cur_node.func, ast.Name):\n                func_name = cur_node.func.id\n            else:\n                func_name = cur_node.func.attr\n            if func_name == 'walk':\n                return cur_node\n        for node_info in astor.iter_node(cur_node):\n            if isinstance(node_info[0], list):\n                nodes = node_info[0]\n            else:\n                nodes = [node_info[0]]\n            for children_node in nodes:\n                node_list.append(children_node)\n\n\ndef get_formated_spec_params_code(code: str) ->str: [MASK]\n"}
{"method_name": "base36encode", "full_method_name": "base36encode", "method_path": "../srcdata/Visualization/pygwalker/pygwalker/services/fname_encodings.py", "method_code": "from typing import List\nfrom math import ceil\nfrom collections import defaultdict\ndef base36encode(s: str) ->str:\n    \"\"\"Converts an string to a base36 string.\"\"\"\n    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    number = int.from_bytes(s.encode(), 'big')\n    if not isinstance(number, int):\n        raise TypeError('number must be an integer')\n    base36 = ''\n    if 0 <= number < len(alphabet):\n        return alphabet[number]\n    while number != 0:\n        number, i = divmod(number, len(alphabet))\n        base36 = alphabet[i] + base36\n    return base36", "test_code_list": [{"test_code": "def test_base36_encode():\n    assert base36encode('hello') == '5PZCSZU7'\n    assert base36encode('hello world') == 'FUVRSIVVNFRBJWAJO'\n    assert base36encode('') == '0'\n\ntest_base36_encode()\n", "code_start": "", "test_path": "../srcdata/Visualization/pygwalker/tests/test_fname_encodings.py"}], "instruction": "Functionality: The function base36encode is designed to convert an input string to a base36 representation. Base36 encoding uses digits (0-9) and uppercase alphabets (A-Z) to represent numbers. The encoding process involves converting the input string to an integer and then converting that integer to a base36 string using the specified alphabet.\n\nInputs: \n- s: A string that is to be converted to base36. The string can consist of any characters, but the encoding process will treat it as a sequence of bytes.\n\nOutputs: \n- A string representing the base36 encoded value of the input string. The output string will consist of characters from the base36 alphabet (0-9, A-Z).", "method_code_mask": "from typing import List\nfrom math import ceil\nfrom collections import defaultdict\n\n\ndef base36encode(s: str) ->str: [MASK]\n"}
{"method_name": "base36decode", "full_method_name": "base36decode", "method_path": "../srcdata/Visualization/pygwalker/pygwalker/services/fname_encodings.py", "method_code": "from typing import List\nfrom math import ceil\nfrom collections import defaultdict\ndef base36decode(s: str) ->str:\n    \"\"\"Converts a base36 string to an string.\"\"\"\n    number = int(s, 36)\n    return number.to_bytes(ceil(number.bit_length() / 8), 'big').decode()", "test_code_list": [{"test_code": "def test_base36_decode():\n    assert base36decode('5PZCSZU7') == 'hello'\n    assert base36decode('FUVRSIVVNFRBJWAJO') == 'hello world'\n    assert base36decode('0') == ''\n\ntest_base36_decode()\n", "code_start": "", "test_path": "../srcdata/Visualization/pygwalker/tests/test_fname_encodings.py"}], "instruction": "Functionality: The function base36decode is designed to convert a string that is encoded in base36 back to its original string format. Base36 is a numeral system that uses 36 symbols - the numbers 0-9 and the letters A-Z (in uppercase) to represent values. This function will take the base36 encoded string, convert it to a number, then convert that number back into the original string format.\n\nInputs: \n- s: str - A string that is encoded in base36. The input string will only consist of valid base36 characters.\n\nOutputs: \n- str - The original string that was encoded in base36. The output will be the decoded string.\n\nPlease note that the function provided is for reference only, and you are free to implement this functionality in any way you see fit, as long as it meets the requirements outlined in this documentation. \n\nThe interviewers will evaluate your solution based on its correctness, efficiency, and clarity of implementation.", "method_code_mask": "from typing import List\nfrom math import ceil\nfrom collections import defaultdict\n\n\ndef base36decode(s: str) ->str: [MASK]\n"}
