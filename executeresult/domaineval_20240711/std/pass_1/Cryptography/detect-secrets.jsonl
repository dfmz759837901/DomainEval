{"result": "passed", "model_name": "std", "repository": "detect-secrets", "full_method_name": "is_sequential_string", "method_path": "../srcdata/Cryptography/detect-secrets/detect_secrets/filters/heuristic.py", "method_code_mask": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\n\n\ndef is_sequential_string(secret: str) ->bool: [MASK]\n", "response": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\ndef is_sequential_string(secret: str) ->bool:\n    sequences = (string.ascii_uppercase + string.ascii_uppercase + string.\n        digits + '+/', string.digits + string.ascii_uppercase + string.\n        ascii_uppercase + '+/', (string.digits + string.ascii_uppercase) * \n        2, string.digits * 2, string.hexdigits.upper() + string.hexdigits.\n        upper(), string.ascii_uppercase + '=/')\n    uppercase = secret.upper()\n    for sequential_string in sequences:\n        if uppercase in sequential_string:\n            return True\n    return False"}
{"result": "passed", "model_name": "std", "repository": "detect-secrets", "full_method_name": "get_code_snippet", "method_path": "../srcdata/Cryptography/detect-secrets/detect_secrets/util/code_snippet.py", "method_code_mask": "from typing import Generator\nfrom typing import List\n\n\nclass CodeSnippet:\n\n    def __init__(self, snippet: List[str], start_line: int, target_index: int\n        ) ->None:\n        \"\"\"\n        :param snippet: lines of code extracted from file\n        :param start_line: first line number in segment\n        :param target_index: index in snippet of target line\n        \"\"\"\n        self.lines = snippet\n        self.start_line = start_line\n        self.target_index = target_index\n\n    @property\n    def target_line(self) ->str:\n        return self.lines[self.target_index]\n\n    @target_line.setter\n    def target_line(self, value: str) ->None:\n        self.lines[self.target_index] = value\n\n    @property\n    def previous_line(self) ->str:\n        if self.target_index == 0 or len(self.lines) < self.target_index:\n            return ''\n        return self.lines[self.target_index - 1]\n\n    def add_line_numbers(self) ->'CodeSnippet':\n        for index, line in enumerate(self.lines):\n            self.lines[index] = u'{}:{}'.format(self.get_line_number(self.\n                start_line + index + 1), line)\n        return self\n\n    def highlight_line(self, payload: str) ->'CodeSnippet':\n        \"\"\"\n        :param payload: string to highlight, on chosen line\n        \"\"\"\n        try:\n            index_of_payload = self.target_line.lower().index(payload.lower())\n            end_of_payload = index_of_payload + len(payload)\n            self.target_line = u'{}{}{}'.format(self.target_line[:\n                index_of_payload], self.apply_highlight(self.target_line[\n                index_of_payload:end_of_payload]), self.target_line[\n                end_of_payload:])\n            return self\n        except ValueError:\n            raise SecretNotFoundOnSpecifiedLineError(self.target_index)\n\n    def get_line_number(self, line_number: int) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(str(line_number), AnsiColor.LIGHT_GREEN)\n\n    def apply_highlight(self, payload: str) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(payload, AnsiColor.RED_BACKGROUND)\n\n    def __str__(self) ->str:\n        return '\\n'.join(self.lines)\n\n    def __iter__(self) ->Generator[str, None, None]:\n        yield from self.lines\n\n\ndef get_code_snippet(lines: List[str], line_number: int, lines_of_context:\n    int=5) ->'CodeSnippet': [MASK]\n", "response": "from typing import Generator\nfrom typing import List\nclass CodeSnippet:\n\n    def __init__(self, snippet: List[str], start_line: int, target_index: int\n        ) ->None:\n        \"\"\"\n        :param snippet: lines of code extracted from file\n        :param start_line: first line number in segment\n        :param target_index: index in snippet of target line\n        \"\"\"\n        self.lines = snippet\n        self.start_line = start_line\n        self.target_index = target_index\n\n    @property\n    def target_line(self) ->str:\n        return self.lines[self.target_index]\n\n    @target_line.setter\n    def target_line(self, value: str) ->None:\n        self.lines[self.target_index] = value\n\n    @property\n    def previous_line(self) ->str:\n        if self.target_index == 0 or len(self.lines) < self.target_index:\n            return ''\n        return self.lines[self.target_index - 1]\n\n    def add_line_numbers(self) ->'CodeSnippet':\n        for index, line in enumerate(self.lines):\n            self.lines[index] = u'{}:{}'.format(self.get_line_number(self.\n                start_line + index + 1), line)\n        return self\n\n    def highlight_line(self, payload: str) ->'CodeSnippet':\n        \"\"\"\n        :param payload: string to highlight, on chosen line\n        \"\"\"\n        try:\n            index_of_payload = self.target_line.lower().index(payload.lower())\n            end_of_payload = index_of_payload + len(payload)\n            self.target_line = u'{}{}{}'.format(self.target_line[:\n                index_of_payload], self.apply_highlight(self.target_line[\n                index_of_payload:end_of_payload]), self.target_line[\n                end_of_payload:])\n            return self\n        except ValueError:\n            raise SecretNotFoundOnSpecifiedLineError(self.target_index)\n\n    def get_line_number(self, line_number: int) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(str(line_number), AnsiColor.LIGHT_GREEN)\n\n    def apply_highlight(self, payload: str) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(payload, AnsiColor.RED_BACKGROUND)\n\n    def __str__(self) ->str:\n        return '\\n'.join(self.lines)\n\n    def __iter__(self) ->Generator[str, None, None]:\n        yield from self.lines\ndef get_code_snippet(lines: List[str], line_number: int, lines_of_context:\n    int=5) ->'CodeSnippet':\n    \"\"\"\n    :param lines: an iterator of lines in the file\n    :param line_number: line which you want to focus on\n    :param lines_of_context: how many lines to display around the line you want\n        to focus on.\n    \"\"\"\n    target_line_index = line_number - 1\n    end_line_index = target_line_index + lines_of_context + 1\n    if target_line_index <= lines_of_context:\n        start_line_index = 0\n    else:\n        start_line_index = target_line_index - lines_of_context\n        target_line_index = lines_of_context\n    return CodeSnippet(snippet=lines[start_line_index:end_line_index],\n        start_line=start_line_index, target_index=target_line_index)"}
