{"result": "passed", "model_name": "std", "repository": "python-paillier", "full_method_name": "powmod", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n_USE_MOD_FROM_GMP_SIZE = 1 << 8 * 2\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\n\n\ndef powmod(a, b, c): [MASK]\n", "response": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n_USE_MOD_FROM_GMP_SIZE = 1 << 8 * 2\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\ndef powmod(a, b, c):\n    \"\"\"\n    Uses GMP, if available, to do a^b mod c where a, b, c\n    are integers.\n    :return int: (a ** b) % c\n    \"\"\"\n    if a == 1:\n        return 1\n    if not HAVE_GMP or max(a, b, c) < _USE_MOD_FROM_GMP_SIZE:\n        return pow(a, b, c)\n    else:\n        return int(gmpy2.powmod(a, b, c))"}
{"result": "passed", "model_name": "std", "repository": "python-paillier", "full_method_name": "extended_euclidean_algorithm", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\n\n\ndef extended_euclidean_algorithm(a, b): [MASK]\n", "response": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ndef extended_euclidean_algorithm(a, b):\n    \"\"\"Extended Euclidean algorithm\n\n    Returns r, s, t such that r = s*a + t*b and r is gcd(a, b)\n\n    See <https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm>\n    \"\"\"\n    r0, r1 = a, b\n    s0, s1 = 1, 0\n    t0, t1 = 0, 1\n    while r1 != 0:\n        q = r0 // r1\n        r0, r1 = r1, r0 - q * r1\n        s0, s1 = s1, s0 - q * s1\n        t0, t1 = t1, t0 - q * t1\n    return r0, s0, t0"}
{"result": "passed", "model_name": "std", "repository": "python-paillier", "full_method_name": "invert", "method_path": "../srcdata/Cryptography/python-paillier/phe/util.py", "method_code_mask": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\n\n\ndef invert(a, b): [MASK]\n", "response": "import os\nimport random\nfrom base64 import urlsafe_b64encode\nfrom base64 import urlsafe_b64decode\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport gmpy2\nfrom Crypto.Util import number\ntry:\n    import gmpy2\n    HAVE_GMP = True\nexcept ImportError:\n    HAVE_GMP = False\ndef invert(a, b):\n    \"\"\"\n    The multiplicitive inverse of a in the integers modulo b.\n    :return int: x, where a * x == 1 mod b\n    \"\"\"\n    if HAVE_GMP:\n        s = int(gmpy2.invert(a, b))\n        if s == 0:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s\n    else:\n        r, s, _ = extended_euclidean_algorithm(a, b)\n        if r != 1:\n            raise ZeroDivisionError('invert() no inverse exists')\n        return s % b"}
