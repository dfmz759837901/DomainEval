{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "remove_sequence", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\ndef remove_sequence(string): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\ndef remove_sequence(string):\n    if not string:\n        raise UnexpectedDER('Empty string does not encode a sequence')\n    if string[:1] != b'0':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'sequence' (0x30), got 0x%02x\" % n)\n    length, lengthlength = read_length(string[1:])\n    if length > len(string) - 1 - lengthlength:\n        raise UnexpectedDER('Length longer than the provided buffer')\n    endseq = 1 + lengthlength + length\n    return string[1 + lengthlength:endseq], string[endseq:]"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "sigdecode_strings", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/util.py", "method_code_mask": "from __future__ import division\nimport os\nimport math\nimport binascii\nimport sys\nfrom hashlib import sha256\nfrom six import PY2\nfrom six import int2byte\nfrom six import next\n\n\nclass MalformedSignature(Exception):\n    \"\"\"\n    Raised by decoding functions when the signature is malformed.\n\n    Malformed in this context means that the relevant strings or integers\n    do not match what a signature over provided curve would create. Either\n    because the byte strings have incorrect lengths or because the encoded\n    values are too large.\n    \"\"\"\n    pass\n\n\ndef sigdecode_strings(rs_strings, order): [MASK]\n", "response": "from __future__ import division\nimport os\nimport math\nimport binascii\nimport sys\nfrom hashlib import sha256\nfrom six import PY2\nfrom six import int2byte\nfrom six import next\nclass MalformedSignature(Exception):\n    \"\"\"\n    Raised by decoding functions when the signature is malformed.\n\n    Malformed in this context means that the relevant strings or integers\n    do not match what a signature over provided curve would create. Either\n    because the byte strings have incorrect lengths or because the encoded\n    values are too large.\n    \"\"\"\n    pass\ndef sigdecode_strings(rs_strings, order):\n    \"\"\"\n    Decode the signature from two strings.\n    First string needs to be a big endian encoding of ``r``, second needs to\n    be a big endian encoding of the ``s`` parameter of an ECDSA signature.\n    It's expected that this function will be used as the ``sigdecode=``\n    parameter to the :func:`ecdsa.keys.VerifyingKey.verify` method.\n    :param list rs_strings: list of two bytes-like objects, each encoding one\n        parameter of signature\n    :param int order: order of the curve over which the signature was computed\n    :raises MalformedSignature: when the encoding of the signature is invalid\n    :return: tuple with decoded ``r`` and ``s`` values of signature\n    :rtype: tuple of ints\n    \"\"\"\n    if not len(rs_strings) == 2:\n        raise MalformedSignature(\n            'Invalid number of strings provided: {0}, expected 2'.format(\n            len(rs_strings)))\n    r_str, s_str = rs_strings\n    r_str = normalise_bytes(r_str)\n    s_str = normalise_bytes(s_str)\n    l = orderlen(order)\n    if not len(r_str) == l:\n        raise MalformedSignature(\n            \"Invalid length of first string ('r' parameter), expected {0} bytes long, provided string is {1} bytes long\"\n            .format(l, len(r_str)))\n    if not len(s_str) == l:\n        raise MalformedSignature(\n            \"Invalid length of second string ('s' parameter), expected {0} bytes long, provided string is {1} bytes long\"\n            .format(l, len(s_str)))\n    r = string_to_number_fixedlen(r_str, order)\n    s = string_to_number_fixedlen(s_str, order)\n    return r, s"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "remove_integer", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef remove_integer(string): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\nclass UnexpectedDER(Exception):\n    pass\ndef remove_integer(string):\n    if not string:\n        raise UnexpectedDER('Empty string is an invalid encoding of an integer'\n            )\n    if string[:1] != b'\\x02':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'integer' (0x02), got 0x%02x\" % n)\n    length, llen = read_length(string[1:])\n    if length > len(string) - 1 - llen:\n        raise UnexpectedDER('Length longer than provided buffer')\n    if length == 0:\n        raise UnexpectedDER('0-byte long encoding of integer')\n    numberbytes = string[1 + llen:1 + llen + length]\n    rest = string[1 + llen + length:]\n    msb = str_idx_as_int(numberbytes, 0)\n    if not msb < 128:\n        raise UnexpectedDER('Negative integers are not supported')\n    if length > 1 and not msb:\n        smsb = str_idx_as_int(numberbytes, 1)\n        if smsb < 128:\n            raise UnexpectedDER(\n                'Invalid encoding of integer, unnecessary zero padding bytes')\n    return int(binascii.hexlify(numberbytes), 16), rest"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "read_length", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "remove_bitstring", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\n_sentry = object()\n\n\ndef remove_bitstring(string, expect_unused=_sentry): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\n_sentry = object()\ndef remove_bitstring(string, expect_unused=_sentry):\n    \"\"\"\n    Remove a BIT STRING object from `string` following :term:`DER`.\n    The `expect_unused` can be used to specify if the bit string should\n    have the amount of unused bits decoded or not. If it's an integer, any\n    read BIT STRING that has number of unused bits different from specified\n    value will cause UnexpectedDER exception to be raised (this is especially\n    useful when decoding BIT STRINGS that have DER encoded object in them;\n    DER encoding is byte oriented, so the unused bits will always equal 0).\n    If the `expect_unused` is specified as None, the first element returned\n    will be a tuple, with the first value being the extracted bit string\n    while the second value will be the decoded number of unused bits.\n    If the `expect_unused` is unspecified, the decoding of byte with\n    number of unused bits will not be attempted and the bit string will be\n    returned as-is, the callee will be required to decode it and verify its\n    correctness.\n    Future version of python will require the `expected_unused` parameter\n    to be specified.\n    :param string: string of bytes to extract the BIT STRING from\n    :type string: bytes like object\n    :param expect_unused: number of bits that should be unused in the BIT\n        STRING, or None, to return it to caller\n    :type expect_unused: int or None\n    :raises UnexpectedDER: when the encoding does not follow DER.\n    :return: a tuple with first element being the extracted bit string and\n        the second being the remaining bytes in the string (if any); if the\n        `expect_unused` is specified as None, the first element of the returned\n        tuple will be a tuple itself, with first element being the bit string\n        as bytes and the second element being the number of unused bits at the\n        end of the byte array as an integer\n    :rtype: tuple\n    \"\"\"\n    if not string:\n        raise UnexpectedDER('Empty string does not encode a bitstring')\n    if expect_unused is _sentry:\n        warnings.warn(\n            'Legacy call convention used, expect_unused= needs to be specified'\n            , DeprecationWarning)\n    num = str_idx_as_int(string, 0)\n    if string[:1] != b'\\x03':\n        raise UnexpectedDER('wanted bitstring (0x03), got 0x%02x' % num)\n    length, llen = read_length(string[1:])\n    if not length:\n        raise UnexpectedDER(\"Invalid length of bit string, can't be 0\")\n    body = string[1 + llen:1 + llen + length]\n    rest = string[1 + llen + length:]\n    if expect_unused is not _sentry:\n        unused = str_idx_as_int(body, 0)\n        if not 0 <= unused <= 7:\n            raise UnexpectedDER('Invalid encoding of unused bits')\n        if expect_unused is not None and expect_unused != unused:\n            raise UnexpectedDER('Unexpected number of unused bits')\n        body = body[1:]\n        if unused:\n            if not body:\n                raise UnexpectedDER('Invalid encoding of empty bit string')\n            last = str_idx_as_int(body, -1)\n            if last & 2 ** unused - 1:\n                raise UnexpectedDER('Non zero padding bits in bit string')\n        if expect_unused is None:\n            body = body, unused\n    return body, rest"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "gcd", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\n\n\ndef gcd(*a): [MASK]\n", "response": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "lcm", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\n\n\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]\n\n\ndef lcm2(a, b):\n    \"\"\"Least common multiple of two integers.\"\"\"\n    return a * b // gcd(a, b)\n\n\ndef lcm(*a): [MASK]\n", "response": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ntry:\n    gcd2 = math.gcd\nexcept AttributeError:\n\n    def gcd2(a, b):\n        \"\"\"Greatest common divisor using Euclid's algorithm.\"\"\"\n        while a:\n            a, b = b % a, a\n        return b\ndef gcd(*a):\n    \"\"\"Greatest common divisor.\n    Usage: gcd([ 2, 4, 6 ])\n    or:    gcd(2, 4, 6)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(gcd2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(gcd2, a[0])\n    return a[0]\ndef lcm2(a, b):\n    \"\"\"Least common multiple of two integers.\"\"\"\n    return a * b // gcd(a, b)\ndef lcm(*a):\n    \"\"\"Least common multiple.\n    Usage: lcm([ 3, 4, 5 ])\n    or:    lcm(3, 4, 5)\n    \"\"\"\n    if len(a) > 1:\n        return reduce(lcm2, a)\n    if hasattr(a[0], '__iter__'):\n        return reduce(lcm2, a[0])\n    return a[0]"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "remove_object", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\nclass UnexpectedDER(Exception):\n    pass\n\n\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\n\n\ndef remove_object(string): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\nclass UnexpectedDER(Exception):\n    pass\ndef read_length(string):\n    if not string:\n        raise UnexpectedDER(\"Empty string can't encode valid length value\")\n    num = str_idx_as_int(string, 0)\n    if not num & 128:\n        return num & 127, 1\n    llen = num & 127\n    if not llen:\n        raise UnexpectedDER('Invalid length encoding, length of length is 0')\n    if llen > len(string) - 1:\n        raise UnexpectedDER('Length of length longer than provided buffer')\n    msb = str_idx_as_int(string, 1)\n    if not msb or llen == 1 and msb < 128:\n        raise UnexpectedDER('Not minimal encoding of length')\n    return int(binascii.hexlify(string[1:1 + llen]), 16), 1 + llen\ndef remove_object(string):\n    if not string:\n        raise UnexpectedDER('Empty string does not encode an object identifier'\n            )\n    if string[:1] != b'\\x06':\n        n = str_idx_as_int(string, 0)\n        raise UnexpectedDER(\"wanted type 'object' (0x06), got 0x%02x\" % n)\n    length, lengthlength = read_length(string[1:])\n    body = string[1 + lengthlength:1 + lengthlength + length]\n    rest = string[1 + lengthlength + length:]\n    if not body:\n        raise UnexpectedDER('Empty object identifier')\n    if len(body) != length:\n        raise UnexpectedDER(\n            'Length of object identifier longer than the provided buffer')\n    numbers = []\n    while body:\n        n, ll = read_number(body)\n        numbers.append(n)\n        body = body[ll:]\n    n0 = numbers.pop(0)\n    if n0 < 80:\n        first = n0 // 40\n    else:\n        first = 2\n    second = n0 - 40 * first\n    numbers.insert(0, first)\n    numbers.insert(1, second)\n    return tuple(numbers), rest"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "jacobi", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/numbertheory.py", "method_code_mask": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\n\n\ndef jacobi(a, n): [MASK]\n", "response": "from __future__ import division\nimport sys\nfrom six import integer_types\nfrom six import PY2\nfrom six.moves import reduce\nfrom gmpy2 import powmod\nfrom gmpy2 import mpz\nimport math\nimport warnings\nimport random\ndef jacobi(a, n):\n    \"\"\"Jacobi symbol\"\"\"\n    if not n >= 3:\n        raise JacobiError('n must be larger than 2')\n    if not n % 2 == 1:\n        raise JacobiError('n must be odd')\n    a = a % n\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    a1, e = a, 0\n    while a1 % 2 == 0:\n        a1, e = a1 // 2, e + 1\n    if e % 2 == 0 or n % 8 == 1 or n % 8 == 7:\n        s = 1\n    else:\n        s = -1\n    if a1 == 1:\n        return s\n    if n % 4 == 3 and a1 % 4 == 3:\n        s = -s\n    return s * jacobi(n % a1, a1)"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "str_idx_as_int", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/_compat.py", "method_code_mask": "import sys\nimport re\nimport binascii\nfrom six import integer_types\nimport platform\n\n\ndef str_idx_as_int(string, index): [MASK]\n", "response": "import sys\nimport re\nimport binascii\nfrom six import integer_types\nimport platform\ndef str_idx_as_int(string, index):\n    \"\"\"Take index'th byte from string, return as integer\"\"\"\n    val = string[index]\n    if isinstance(val, integer_types):\n        return val\n    return ord(val)"}
{"result": "passed", "model_name": "std", "repository": "python-ecdsa", "full_method_name": "encode_bitstring", "method_path": "../srcdata/Cryptography/python-ecdsa/src/ecdsa/der.py", "method_code_mask": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\n\n\ndef encode_length(l):\n    assert l >= 0\n    if l < 128:\n        return int2byte(l)\n    s = ('%x' % l).encode()\n    if len(s) % 2:\n        s = b'0' + s\n    s = binascii.unhexlify(s)\n    llen = len(s)\n    return int2byte(128 | llen) + s\n\n\n_sentry = object()\n\n\ndef encode_bitstring(s, unused=_sentry): [MASK]\n", "response": "from __future__ import division\nimport binascii\nimport base64\nimport warnings\nfrom itertools import chain\nfrom six import int2byte\nfrom six import text_type\ndef encode_length(l):\n    assert l >= 0\n    if l < 128:\n        return int2byte(l)\n    s = ('%x' % l).encode()\n    if len(s) % 2:\n        s = b'0' + s\n    s = binascii.unhexlify(s)\n    llen = len(s)\n    return int2byte(128 | llen) + s\n_sentry = object()\ndef encode_bitstring(s, unused=_sentry):\n    \"\"\"\n    Encode a binary string as a BIT STRING using :term:`DER` encoding.\n    Note, because there is no native Python object that can encode an actual\n    bit string, this function only accepts byte strings as the `s` argument.\n    The byte string is the actual bit string that will be encoded, padded\n    on the right (least significant bits, looking from big endian perspective)\n    to the first full byte. If the bit string has a bit length that is multiple\n    of 8, then the padding should not be included. For correct DER encoding\n    the padding bits MUST be set to 0.\n    Number of bits of padding need to be provided as the `unused` parameter.\n    In case they are specified as None, it means the number of unused bits\n    is already encoded in the string as the first byte.\n    The deprecated call convention specifies just the `s` parameters and\n    encodes the number of unused bits as first parameter (same convention\n    as with None).\n    Empty string must be encoded with `unused` specified as 0.\n    Future version of python-ecdsa will make specifying the `unused` argument\n    mandatory.\n    :param s: bytes to encode\n    :type s: bytes like object\n    :param unused: number of bits at the end of `s` that are unused, must be\n        between 0 and 7 (inclusive)\n    :type unused: int or None\n    :raises ValueError: when `unused` is too large or too small\n    :return: `s` encoded using DER\n    :rtype: bytes\n    \"\"\"\n    encoded_unused = b''\n    len_extra = 0\n    if unused is _sentry:\n        warnings.warn(\n            'Legacy call convention used, unused= needs to be specified',\n            DeprecationWarning)\n    elif unused is not None:\n        if not 0 <= unused <= 7:\n            raise ValueError('unused must be integer between 0 and 7')\n        if unused:\n            if not s:\n                raise ValueError('unused is non-zero but s is empty')\n            last = str_idx_as_int(s, -1)\n            if last & 2 ** unused - 1:\n                raise ValueError('unused bits must be zeros in DER')\n        encoded_unused = int2byte(unused)\n        len_extra = 1\n    return b'\\x03' + encode_length(len(s) + len_extra) + encoded_unused + s"}
