{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_ed25519_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_ed25519_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_ed25519_vectors(vector_data):\n    data = []\n    for line in vector_data:\n        secret_key, public_key, message, signature, _ = line.split(':')\n        secret_key = secret_key[0:64]\n        signature = signature[0:128]\n        data.append({'secret_key': secret_key, 'public_key': public_key,\n            'message': message, 'signature': signature})\n    return data"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_hash_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nKeyedHashVector = collections.namedtuple('KeyedHashVector', ['message',\n    'digest', 'key'])\nHashVector = collections.namedtuple('HashVector', ['message', 'digest'])\n\n\ndef load_hash_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nKeyedHashVector = collections.namedtuple('KeyedHashVector', ['message',\n    'digest', 'key'])\nHashVector = collections.namedtuple('HashVector', ['message', 'digest'])\ndef load_hash_vectors(vector_data):\n    vectors: typing.List[typing.Union[KeyedHashVector, HashVector]] = []\n    key = None\n    msg = None\n    md = None\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#') or line.startswith('['):\n            continue\n        if line.startswith('Len'):\n            length = int(line.split(' = ')[1])\n        elif line.startswith('Key'):\n            key = line.split(' = ')[1].encode('ascii')\n        elif line.startswith('Msg'):\n            msg = line.split(' = ')[1].encode('ascii') if length > 0 else b''\n        elif line.startswith('MD') or line.startswith('Output'):\n            md = line.split(' = ')[1]\n            if key is not None:\n                vectors.append(KeyedHashVector(msg, md, key))\n                key = None\n                msg = None\n                md = None\n            else:\n                vectors.append(HashVector(msg, md))\n                msg = None\n                md = None\n        else:\n            raise ValueError('Unknown line in hash vector')\n    return vectors"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_hash_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nHashVector = collections.namedtuple('HashVector', ['message', 'digest'])\n\n\ndef load_hash_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nHashVector = collections.namedtuple('HashVector', ['message', 'digest'])\ndef load_hash_vectors(vector_data):\n    vectors: typing.List[typing.Union[KeyedHashVector, HashVector]] = []\n    key = None\n    msg = None\n    md = None\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#') or line.startswith('['):\n            continue\n        if line.startswith('Len'):\n            length = int(line.split(' = ')[1])\n        elif line.startswith('Key'):\n            key = line.split(' = ')[1].encode('ascii')\n        elif line.startswith('Msg'):\n            msg = line.split(' = ')[1].encode('ascii') if length > 0 else b''\n        elif line.startswith('MD') or line.startswith('Output'):\n            md = line.split(' = ')[1]\n            if key is not None:\n                vectors.append(KeyedHashVector(msg, md, key))\n                key = None\n                msg = None\n                md = None\n            else:\n                vectors.append(HashVector(msg, md))\n                msg = None\n                md = None\n        else:\n            raise ValueError('Unknown line in hash vector')\n    return vectors"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_nist_kbkdf_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_nist_kbkdf_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_nist_kbkdf_vectors(vector_data):\n    \"\"\"\n    Load NIST SP 800-108 KDF Vectors\n    \"\"\"\n    vectors = []\n    test_data = None\n    tag = {}\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if line.startswith('[') and line.endswith(']'):\n            tag_data = line[1:-1]\n            name, value = (c.strip() for c in tag_data.split('='))\n            if value.endswith('_BITS'):\n                value = int(value.split('_')[0])\n                tag.update({name.lower(): value})\n                continue\n            tag.update({name.lower(): value.lower()})\n        elif line.startswith('COUNT='):\n            test_data = {}\n            test_data.update(tag)\n            vectors.append(test_data)\n        elif line.startswith(('L', 'DataBeforeCtrLen', 'DataAfterCtrLen')):\n            name, value = (c.strip() for c in line.split('='))\n            test_data[name.lower()] = int(value)\n        else:\n            name, value = (c.strip() for c in line.split('='))\n            test_data[name.lower()] = value.encode('ascii')\n    return vectors"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_cryptrec_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_cryptrec_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_cryptrec_vectors(vector_data):\n    cryptrec_list = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if line.startswith('K'):\n            key = line.split(' : ')[1].replace(' ', '').encode('ascii')\n        elif line.startswith('P'):\n            pt = line.split(' : ')[1].replace(' ', '').encode('ascii')\n        elif line.startswith('C'):\n            ct = line.split(' : ')[1].replace(' ', '').encode('ascii')\n            cryptrec_list.append({'key': key, 'plaintext': pt, 'ciphertext':\n                ct})\n        else:\n            raise ValueError(f\"Invalid line in file '{line}'\")\n    return cryptrec_list"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_fips_dsa_key_pair_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_fips_dsa_key_pair_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_fips_dsa_key_pair_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS DSA KeyPair vector files.\n    \"\"\"\n    vectors = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#') or line.startswith('[mod'):\n            continue\n        if line.startswith('P'):\n            vectors.append({'p': int(line.split('=')[1], 16)})\n        elif line.startswith('Q'):\n            vectors[-1]['q'] = int(line.split('=')[1], 16)\n        elif line.startswith('G'):\n            vectors[-1]['g'] = int(line.split('=')[1], 16)\n        elif line.startswith('X') and 'x' not in vectors[-1]:\n            vectors[-1]['x'] = int(line.split('=')[1], 16)\n        elif line.startswith('X') and 'x' in vectors[-1]:\n            vectors.append({'p': vectors[-1]['p'], 'q': vectors[-1]['q'],\n                'g': vectors[-1]['g'], 'x': int(line.split('=')[1], 16)})\n        elif line.startswith('Y'):\n            vectors[-1]['y'] = int(line.split('=')[1], 16)\n    return vectors"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_fips_dsa_sig_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nFIPS_SHA_REGEX = re.compile(\n    '\\\\[mod = L=...., N=..., SHA-(?P<sha>1|224|256|384|512)\\\\]')\n\n\ndef load_fips_dsa_sig_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\nFIPS_SHA_REGEX = re.compile(\n    '\\\\[mod = L=...., N=..., SHA-(?P<sha>1|224|256|384|512)\\\\]')\ndef load_fips_dsa_sig_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS DSA SigVer vector files.\n    \"\"\"\n    vectors = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        sha_match = FIPS_SHA_REGEX.match(line)\n        if sha_match:\n            digest_algorithm = 'SHA-{}'.format(sha_match.group('sha'))\n        if line.startswith('[mod'):\n            continue\n        name, value = (c.strip() for c in line.split('='))\n        if name == 'P':\n            vectors.append({'p': int(value, 16), 'digest_algorithm':\n                digest_algorithm})\n        elif name == 'Q':\n            vectors[-1]['q'] = int(value, 16)\n        elif name == 'G':\n            vectors[-1]['g'] = int(value, 16)\n        elif name == 'Msg' and 'msg' not in vectors[-1]:\n            hexmsg = value.strip().encode('ascii')\n            vectors[-1]['msg'] = binascii.unhexlify(hexmsg)\n        elif name == 'Msg' and 'msg' in vectors[-1]:\n            hexmsg = value.strip().encode('ascii')\n            vectors.append({'p': vectors[-1]['p'], 'q': vectors[-1]['q'],\n                'g': vectors[-1]['g'], 'digest_algorithm': vectors[-1][\n                'digest_algorithm'], 'msg': binascii.unhexlify(hexmsg)})\n        elif name == 'X':\n            vectors[-1]['x'] = int(value, 16)\n        elif name == 'Y':\n            vectors[-1]['y'] = int(value, 16)\n        elif name == 'R':\n            vectors[-1]['r'] = int(value, 16)\n        elif name == 'S':\n            vectors[-1]['s'] = int(value, 16)\n        elif name == 'Result':\n            vectors[-1]['result'] = value.split('(')[0].strip()\n    return vectors"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_nist_ccm_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_nist_ccm_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_nist_ccm_vectors(vector_data):\n    test_data = {}\n    section_data = None\n    global_data = {}\n    new_section = False\n    data = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#'):\n            continue\n        if line.startswith(('Alen', 'Plen', 'Nlen', 'Tlen')):\n            name, value = (c.strip() for c in line.split('='))\n            global_data[name.lower()] = int(value)\n            continue\n        if line.startswith('['):\n            new_section = True\n            section_data = {}\n            section = line[1:-1]\n            items = [c.strip() for c in section.split(',')]\n            for item in items:\n                name, value = (c.strip() for c in item.split('='))\n                section_data[name.lower()] = int(value)\n            continue\n        name, value = (c.strip() for c in line.split('='))\n        if name.lower() in ('key', 'nonce') and new_section:\n            section_data[name.lower()] = value.encode('ascii')\n            continue\n        new_section = False\n        if name.lower() == 'payload':\n            section_data[name.lower()] = value.encode('ascii')\n        if name.lower() == 'result':\n            if value.lower() == 'pass':\n                test_data['fail'] = False\n            else:\n                test_data['fail'] = True\n            continue\n        if name.lower() == 'count':\n            test_data = {}\n            test_data.update(global_data)\n            test_data.update(section_data)\n            data.append(test_data)\n            continue\n        else:\n            test_data[name.lower()] = value.encode('ascii')\n    return data"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_rsa_nist_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_rsa_nist_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_rsa_nist_vectors(vector_data):\n    test_data: typing.Dict[str, typing.Any] = {}\n    p = None\n    salt_length = None\n    data = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('['):\n            continue\n        if line.startswith('# Salt len:'):\n            salt_length = int(line.split(':')[1].strip())\n            continue\n        elif line.startswith('#'):\n            continue\n        name, value = (c.strip() for c in line.split('='))\n        if name == 'n':\n            n = int(value, 16)\n        elif name == 'e' and p is None:\n            e = int(value, 16)\n        elif name == 'p':\n            p = int(value, 16)\n        elif name == 'q':\n            q = int(value, 16)\n        elif name == 'SHAAlg':\n            if p is None:\n                test_data = {'modulus': n, 'public_exponent': e,\n                    'salt_length': salt_length, 'algorithm': value, 'fail':\n                    False}\n            else:\n                test_data = {'modulus': n, 'p': p, 'q': q, 'algorithm': value}\n                if salt_length is not None:\n                    test_data['salt_length'] = salt_length\n            data.append(test_data)\n        elif name == 'e' and p is not None:\n            test_data['public_exponent'] = int(value, 16)\n        elif name == 'd':\n            test_data['private_exponent'] = int(value, 16)\n        elif name == 'Result':\n            test_data['fail'] = value.startswith('F')\n        else:\n            test_data[name.lower()] = value.encode('ascii')\n    return data"}
{"result": "passed", "model_name": "std", "repository": "cryptography", "full_method_name": "load_nist_vectors", "method_path": "../srcdata/Cryptography/cryptography/tests/utils.py", "method_code_mask": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\n\ndef load_nist_vectors(vector_data): [MASK]\n", "response": "import binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\nimport pytest\nfrom cryptography.exceptions import UnsupportedAlgorithm\ndef load_nist_vectors(vector_data):\n    test_data = {}\n    data = []\n    for line in vector_data:\n        line = line.strip()\n        if not line or line.startswith('#') or line.startswith('['\n            ) and line.endswith(']'):\n            continue\n        if line.strip() == 'FAIL':\n            test_data['fail'] = True\n            continue\n        name, value = (c.strip() for c in line.split('='))\n        value = value.replace('\\\\0', '\\x00')\n        if name.upper() == 'COUNT':\n            test_data = {}\n            data.append(test_data)\n            continue\n        else:\n            test_data[name.lower()] = value.encode('ascii')\n    return data"}
