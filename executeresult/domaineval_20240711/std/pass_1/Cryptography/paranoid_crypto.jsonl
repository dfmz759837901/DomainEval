{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "InverseSqrt2exp", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]: [MASK]\n", "response": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Returns a, such that 1 == a * a * n % 2**k or None if no solution exists.\n\n  Args:\n    n: the value for which the inverse square root is computed\n    k: the bit-size of the result.\n  \"\"\"\n    if k < 3:\n        for a in range(2 ** k):\n            if a * a * n % 2 ** k == 1:\n                return a\n        return None\n    if n % 8 != 1:\n        return None\n    a = 1\n    t = 3\n    while t < k:\n        t = min(k, 2 * t - 2)\n        a = gmpy.f_mod_2exp(a * (3 - a * a * n) // 2, t)\n    return a"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "Pollardpm1", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util.py", "method_code_mask": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Pollardpm1(n: int, m: Optional[int]=None, gcd_bound: int=2 ** 60) ->tuple[\n    bool, list[int]]: [MASK]\n", "response": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\ndef Pollardpm1(n: int, m: Optional[int]=None, gcd_bound: int=2 ** 60) ->tuple[\n    bool, list[int]]:\n    \"\"\"Checks if an RSA modulus is factorable by pollard p-1 method.\n\n  Pollard's p-1 algorithm finds factors when the number preceding the factor,\n  p - 1, is powersmooth. A number X is called B-powersmooth if all prime powers\n  r^v dividing X satisfy: r ^ v <= B. For example, 720 (2^4 * 3^2 *5) is\n  5-smooth (largest prime is 5) and 16-powersmooth (greatest prime factor power\n  is 2^4 = 16).\n\n  The algorithm works due Fermat's little theorem. Let N = p*q. For all\n  integers a, coprime to p and for all positive integers K, if b = a ^ (K*(p-1))\n  is congruent to 1 mod p, then the factor p is gcd(b - 1, N).\n\n  Motivation:\n  For high speed, some key generators may use much smaller numbers to compose\n  the key. For example, https://www.umopit.ru/CompLab/primes32eng.htm contains\n  a list of all 32-bit prime numbers and it states that this list \"can be used\n  for manual picking of a prime number (e.g. as a base for effective\n  cryptography)\".\n\n  When factorization fails:\n  The factorization fails when p-1 is not enough powersmooth (for the given m\n  value). m with more and larger factors can be chosen, but this function takes\n  much longer to return.\n  Args:\n      n: An RSA modulus to check.\n      m: A pre-calculated guess for K*(p-1).\n      gcd_bound: For efficiency, the test runs only when gcd(n-1, m) >\n        gcd_bound. This is based on the assumption that when both p-1 and q-1\n        are smooth, so is their gcd. Rough experiments suggest that gcd_bound =\n        2**60 is a reasonable value to skip possible true random keys. A\n        drawback is that it can also skip the test when only p-1 (but not q-1)\n        is smooth enough.\n\n  Returns:\n      A tuple (weak, factors), where the value weak is True if the modulus\n      is weak, and a list of factors that were found. When both p-1 and q-1 are\n      smooth enough, the function returns True but an empty list of factors.\n      In that case, divisors of m can be tried instead.\n  \"\"\"\n    if gmpy.gcd(n - 1, m) >= gcd_bound:\n        a = pow(2, n - 1, n)\n        p = gmpy.gcd(pow(a, m, n) - 1, n)\n        if 1 < p < n:\n            return True, [p, n // p]\n        if p == n:\n            return True, []\n    return False, []"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "solve_right", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]:\n    \"\"\"Solves a matrix equation a*x = b, with a being an upper triangular matrix.\n\n  Given an integer upper triangular matrix 'a' with m rows and m columns, and an\n  integer vector b of size m, this function finds the vector of rationals\n  (gmpy.mpq) x for the equation a*x = b.\n\n  Args:\n    a: upper triangular matrix of integers with m rows and m columns.\n    b: vector of integers of size m.\n\n  Returns:\n    A solution x for a*x == b over the rationals if found. If a zero on the\n      diagonal is found it returns None.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if nrows != ncols:\n        raise ValueError('Matrix must be square.')\n    if nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    xs = [0] * ncols\n    for i in range(nrows - 1, -1, -1):\n        den = a[i][i]\n        if den == 0:\n            return None\n        num = b[i] - sum(a[i][j] * xs[j] for j in range(i + 1, ncols))\n        xs[i] = gmpy.mpq(num, den)\n    return xs\n\n\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int:\n    \"\"\"Puts the matrix of integers a in row echelon form.\n  All the operations are over the integers. Only exact divisions are performed.\n  Thus, this function is useful when working over the integers.\n  This is an adapted implementation of the proposal of Peter R. Turner,\n  'A Simplified Fraction-Free Integer Gauss Elimination Algorithm', U. S. Naval\n  Academy, 1995. The difference is that the original algorithm doesn't perform\n  row swapping to the bottom when linear dependent rows are found, and fails\n  when encounters zero pivots.\n  It is interesting to note that the last element of the matrix in echelon form\n  through this algorithm is the determinat of the original matrix.\n  In order to work with Integers only, comparing with original gaussian\n  elimination, it requires twice multiplications and divisions are increased\n  from O(n^2) to O(n^3). The author, however, shows that working with Rationals\n  wouldn't provide any improvement, and would require additional GCD\n  computations.\n  The b parameter can be provided for the useful cases when solving a linear\n  system. I.e., it will be equivalent of performing gaussian elimination on the\n  augmented matrix a||b.\n  The changes on a and b are in place. Thus, if one wants to preserve the\n  original a and b, one should pass copies of them to this function. The return\n  value is the rank of the matrix a.\n  Args:\n    a: matrix of integers with m rows and n columns, with m >= n.\n    b: optional vector of integers of size m. Useful when solving a system.\n  Returns:\n    rank of a.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if b and nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    n = min(nrows, ncols)\n    rank = 1\n    i = 0\n    while i < n - 1:\n        pivots = i\n        while pivots < n - 1 and a[i][i] == 0:\n            if b:\n                b.insert(nrows, b.pop(i))\n            a.insert(nrows, a.pop(i))\n            pivots += 1\n        j = i + 1\n        while j < nrows:\n            if b:\n                b[j] = a[i][i] * b[j] - a[j][i] * b[i]\n            all_zeros = True\n            for k in range(i + 1, ncols):\n                a[j][k] = a[i][i] * a[j][k] - a[j][i] * a[i][k]\n                if all_zeros and a[j][k] != 0:\n                    all_zeros = False\n            a[j][i] = 0\n            if all_zeros:\n                if b:\n                    b.insert(nrows, b.pop(j))\n                a.insert(nrows, a.pop(j))\n                nrows -= 1\n            else:\n                if rank < n:\n                    rank += 1\n                j += 1\n        if i >= 1:\n            for j in range(i + 1, nrows):\n                if b:\n                    b[j] //= a[i - 1][i - 1]\n                for k in range(i + 1, ncols):\n                    a[j][k] //= a[i - 1][i - 1]\n        i += 1\n    if all([(v == 0) for v in a[nrows - 1]]):\n        rank -= 1\n    return rank\n\n\ndef solve_right(a: list[list[int]], b: list[int]) ->Optional[list[gmpy.mpq]]: [\n    MASK]\n", "response": "from typing import Optional\nimport gmpy2 as gmpy\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]:\n    \"\"\"Solves a matrix equation a*x = b, with a being an upper triangular matrix.\n\n  Given an integer upper triangular matrix 'a' with m rows and m columns, and an\n  integer vector b of size m, this function finds the vector of rationals\n  (gmpy.mpq) x for the equation a*x = b.\n\n  Args:\n    a: upper triangular matrix of integers with m rows and m columns.\n    b: vector of integers of size m.\n\n  Returns:\n    A solution x for a*x == b over the rationals if found. If a zero on the\n      diagonal is found it returns None.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if nrows != ncols:\n        raise ValueError('Matrix must be square.')\n    if nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    xs = [0] * ncols\n    for i in range(nrows - 1, -1, -1):\n        den = a[i][i]\n        if den == 0:\n            return None\n        num = b[i] - sum(a[i][j] * xs[j] for j in range(i + 1, ncols))\n        xs[i] = gmpy.mpq(num, den)\n    return xs\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int:\n    \"\"\"Puts the matrix of integers a in row echelon form.\n  All the operations are over the integers. Only exact divisions are performed.\n  Thus, this function is useful when working over the integers.\n  This is an adapted implementation of the proposal of Peter R. Turner,\n  'A Simplified Fraction-Free Integer Gauss Elimination Algorithm', U. S. Naval\n  Academy, 1995. The difference is that the original algorithm doesn't perform\n  row swapping to the bottom when linear dependent rows are found, and fails\n  when encounters zero pivots.\n  It is interesting to note that the last element of the matrix in echelon form\n  through this algorithm is the determinat of the original matrix.\n  In order to work with Integers only, comparing with original gaussian\n  elimination, it requires twice multiplications and divisions are increased\n  from O(n^2) to O(n^3). The author, however, shows that working with Rationals\n  wouldn't provide any improvement, and would require additional GCD\n  computations.\n  The b parameter can be provided for the useful cases when solving a linear\n  system. I.e., it will be equivalent of performing gaussian elimination on the\n  augmented matrix a||b.\n  The changes on a and b are in place. Thus, if one wants to preserve the\n  original a and b, one should pass copies of them to this function. The return\n  value is the rank of the matrix a.\n  Args:\n    a: matrix of integers with m rows and n columns, with m >= n.\n    b: optional vector of integers of size m. Useful when solving a system.\n  Returns:\n    rank of a.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if b and nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    n = min(nrows, ncols)\n    rank = 1\n    i = 0\n    while i < n - 1:\n        pivots = i\n        while pivots < n - 1 and a[i][i] == 0:\n            if b:\n                b.insert(nrows, b.pop(i))\n            a.insert(nrows, a.pop(i))\n            pivots += 1\n        j = i + 1\n        while j < nrows:\n            if b:\n                b[j] = a[i][i] * b[j] - a[j][i] * b[i]\n            all_zeros = True\n            for k in range(i + 1, ncols):\n                a[j][k] = a[i][i] * a[j][k] - a[j][i] * a[i][k]\n                if all_zeros and a[j][k] != 0:\n                    all_zeros = False\n            a[j][i] = 0\n            if all_zeros:\n                if b:\n                    b.insert(nrows, b.pop(j))\n                a.insert(nrows, a.pop(j))\n                nrows -= 1\n            else:\n                if rank < n:\n                    rank += 1\n                j += 1\n        if i >= 1:\n            for j in range(i + 1, nrows):\n                if b:\n                    b[j] //= a[i - 1][i - 1]\n                for k in range(i + 1, ncols):\n                    a[j][k] //= a[i - 1][i - 1]\n        i += 1\n    if all([(v == 0) for v in a[nrows - 1]]):\n        rank -= 1\n    return rank\ndef solve_right(a: list[list[int]], b: list[int]) ->Optional[list[gmpy.mpq]]:\n    \"\"\"Solves a matrix equation a*x = b.\n  Given an integer matrix 'a' of m rows and n columns, with m >= n and an\n  integer vector b of size m, this function finds the vector of rationals\n  (gmpy.mpq) x for the equation a*x = b.\n  Args:\n    a: matrix of integers with m rows and n columns, with m >= n.\n    b: vector of integers of size m.\n  Returns:\n    A solution x for a*x == b over the rationals if found. None for the case of\n      not enough linear independent rows provided.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    if nrows < ncols:\n        raise ValueError('Not enough rows/equations to solve the system.')\n    rank = echelon_form(a, b)\n    if rank != ncols:\n        return None\n    return upper_triangular_solve(a[:rank], b[:rank])"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "Inverse2exp", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Inverse2exp(n: int, k: int) ->Optional[int]: [MASK]\n", "response": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\ndef Inverse2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Computes the inverse of n modulo 2**k.\n\n  Args:\n    n: an odd value that is inverted\n    k: the exponent of the modulus 2**k\n\n  Returns:\n    a, such that 1 == a * n % 2**k or None if no inverse extists.\n  \"\"\"\n    if n % 2 == 0:\n        return None\n    a = n % 4\n    t = 2\n    while t < k:\n        t = min(k, 2 * t)\n        a = gmpy.f_mod_2exp(a * (2 - a * n), t)\n    return a"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "echelon_form", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int: [MASK]\n", "response": "from typing import Optional\nimport gmpy2 as gmpy\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int:\n    \"\"\"Puts the matrix of integers a in row echelon form.\n\n  All the operations are over the integers. Only exact divisions are performed.\n  Thus, this function is useful when working over the integers.\n\n  This is an adapted implementation of the proposal of Peter R. Turner,\n  'A Simplified Fraction-Free Integer Gauss Elimination Algorithm', U. S. Naval\n  Academy, 1995. The difference is that the original algorithm doesn't perform\n  row swapping to the bottom when linear dependent rows are found, and fails\n  when encounters zero pivots.\n\n  It is interesting to note that the last element of the matrix in echelon form\n  through this algorithm is the determinat of the original matrix.\n\n  In order to work with Integers only, comparing with original gaussian\n  elimination, it requires twice multiplications and divisions are increased\n  from O(n^2) to O(n^3). The author, however, shows that working with Rationals\n  wouldn't provide any improvement, and would require additional GCD\n  computations.\n\n  The b parameter can be provided for the useful cases when solving a linear\n  system. I.e., it will be equivalent of performing gaussian elimination on the\n  augmented matrix a||b.\n\n  The changes on a and b are in place. Thus, if one wants to preserve the\n  original a and b, one should pass copies of them to this function. The return\n  value is the rank of the matrix a.\n\n  Args:\n    a: matrix of integers with m rows and n columns, with m >= n.\n    b: optional vector of integers of size m. Useful when solving a system.\n\n  Returns:\n    rank of a.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if b and nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    n = min(nrows, ncols)\n    rank = 1\n    i = 0\n    while i < n - 1:\n        pivots = i\n        while pivots < n - 1 and a[i][i] == 0:\n            if b:\n                b.insert(nrows, b.pop(i))\n            a.insert(nrows, a.pop(i))\n            pivots += 1\n        j = i + 1\n        while j < nrows:\n            if b:\n                b[j] = a[i][i] * b[j] - a[j][i] * b[i]\n            all_zeros = True\n            for k in range(i + 1, ncols):\n                a[j][k] = a[i][i] * a[j][k] - a[j][i] * a[i][k]\n                if all_zeros and a[j][k] != 0:\n                    all_zeros = False\n            a[j][i] = 0\n            if all_zeros:\n                if b:\n                    b.insert(nrows, b.pop(j))\n                a.insert(nrows, a.pop(j))\n                nrows -= 1\n            else:\n                if rank < n:\n                    rank += 1\n                j += 1\n        if i >= 1:\n            for j in range(i + 1, nrows):\n                if b:\n                    b[j] //= a[i - 1][i - 1]\n                for k in range(i + 1, ncols):\n                    a[j][k] //= a[i - 1][i - 1]\n        i += 1\n    if all([(v == 0) for v in a[nrows - 1]]):\n        rank -= 1\n    return rank"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "upper_triangular_solve", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]: [MASK]\n", "response": "from typing import Optional\nimport gmpy2 as gmpy\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]:\n    \"\"\"Solves a matrix equation a*x = b, with a being an upper triangular matrix.\n\n  Given an integer upper triangular matrix 'a' with m rows and m columns, and an\n  integer vector b of size m, this function finds the vector of rationals\n  (gmpy.mpq) x for the equation a*x = b.\n\n  Args:\n    a: upper triangular matrix of integers with m rows and m columns.\n    b: vector of integers of size m.\n\n  Returns:\n    A solution x for a*x == b over the rationals if found. If a zero on the\n      diagonal is found it returns None.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if nrows != ncols:\n        raise ValueError('Matrix must be square.')\n    if nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    xs = [0] * ncols\n    for i in range(nrows - 1, -1, -1):\n        den = a[i][i]\n        if den == 0:\n            return None\n        num = b[i] - sum(a[i][j] * xs[j] for j in range(i + 1, ncols))\n        xs[i] = gmpy.mpq(num, den)\n    return xs"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "Sqrt2exp", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Inverse2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Computes the inverse of n modulo 2**k.\n\n  Args:\n    n: an odd value that is inverted\n    k: the exponent of the modulus 2**k\n\n  Returns:\n    a, such that 1 == a * n % 2**k or None if no inverse extists.\n  \"\"\"\n    if n % 2 == 0:\n        return None\n    a = n % 4\n    t = 2\n    while t < k:\n        t = min(k, 2 * t)\n        a = gmpy.f_mod_2exp(a * (2 - a * n), t)\n    return a\n\n\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Returns a, such that 1 == a * a * n % 2**k or None if no solution exists.\n  Args:\n    n: the value for which the inverse square root is computed\n    k: the bit-size of the result.\n  \"\"\"\n    if k < 3:\n        for a in range(2 ** k):\n            if a * a * n % 2 ** k == 1:\n                return a\n        return None\n    if n % 8 != 1:\n        return None\n    a = 1\n    t = 3\n    while t < k:\n        t = min(k, 2 * t - 2)\n        a = gmpy.f_mod_2exp(a * (3 - a * a * n) // 2, t)\n    return a\n\n\ndef Sqrt2exp(n: int, k: int) ->list[int]: [MASK]\n", "response": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\ndef Inverse2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Computes the inverse of n modulo 2**k.\n\n  Args:\n    n: an odd value that is inverted\n    k: the exponent of the modulus 2**k\n\n  Returns:\n    a, such that 1 == a * n % 2**k or None if no inverse extists.\n  \"\"\"\n    if n % 2 == 0:\n        return None\n    a = n % 4\n    t = 2\n    while t < k:\n        t = min(k, 2 * t)\n        a = gmpy.f_mod_2exp(a * (2 - a * n), t)\n    return a\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Returns a, such that 1 == a * a * n % 2**k or None if no solution exists.\n  Args:\n    n: the value for which the inverse square root is computed\n    k: the bit-size of the result.\n  \"\"\"\n    if k < 3:\n        for a in range(2 ** k):\n            if a * a * n % 2 ** k == 1:\n                return a\n        return None\n    if n % 8 != 1:\n        return None\n    a = 1\n    t = 3\n    while t < k:\n        t = min(k, 2 * t - 2)\n        a = gmpy.f_mod_2exp(a * (3 - a * a * n) // 2, t)\n    return a\ndef Sqrt2exp(n: int, k: int) ->list[int]:\n    \"\"\"Returns all square roots of n modulo 2**k, where n is odd.\n  This function is restricted to odd inputs n, since only this case\n  is needed and since otherwise the number of solutions can be large.\n  E.g. the equation x**2 = 0 (mod 2**256) has 2**128 solutions, since\n  any multiple of 2**128 is a solution.\n  Args:\n    n: an odd integer\n    k: exponent of the modulus\n  Returns:\n    all x mod 2**k with x * x % 2**k == n % 2**k\n  \"\"\"\n    if n % 2 == 0 or k < 0:\n        raise ValueError('Not implemented for even inputs or negative k')\n    if k < 3:\n        return [x for x in range(2 ** k) if (x * x - n) % 2 ** k == 0]\n    s = InverseSqrt2exp(n, k)\n    if s is None:\n        return []\n    r = Inverse2exp(s, k)\n    roots = [r, int(2 ** k - r), gmpy.f_mod_2exp(2 ** (k - 1) - r, k), gmpy\n        .f_mod_2exp(2 ** (k - 1) + r, k)]\n    return roots"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "PseudoAverage", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/lattice_suite.py", "method_code_mask": "import math\nfrom typing import Optional\n\n\ndef PseudoAverage(a: list[int], n: int) ->int: [MASK]\n", "response": "import math\nfrom typing import Optional\ndef PseudoAverage(a: list[int], n: int) ->int:\n    \"\"\"Finds a integer that is \"closest\" to a modulo n.\n\n  The goal of this function is to define some sort of average\n  for residues modulo n. For example if n = 10 and a =\n  [0, 6, 7, 8, 9] then the result should be 8, since this one\n  0 == 10 (mod 10) and the integers 6, 7, 8, 9, 10 are close to\n  each other.\n\n  This function does essentially the following:\n  From each pair (a[i], a[i] + n) an element b[i] is selected,\n  such that the variance of the elements b[i] is minimal.\n  The result is then the mean of the elements b[i] modulo n.\n\n  Args:\n    a: a list of integers\n    n: the modulus\n\n  Returns:\n    an integer close to all elements of a modulo n (as defined above).\n  \"\"\"\n    a = sorted(a)\n    sum_a = sum(a)\n    m = len(a)\n    best_j = 0\n    best_diff = 0\n    const_j = n * m - 2 * sum_a\n    sx = 0\n    for i in range(m):\n        j = i + 1\n        sx += a[i]\n        diff = 2 * sx * m + j * (const_j - j * n)\n        if diff < best_diff:\n            best_j, best_diff = j, diff\n    pseudo_average = (sum_a + n * best_j + m // 2) // m % n\n    return pseudo_average"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "FermatFactor", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util.py", "method_code_mask": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef FermatFactor(n: int, max_steps: int) ->Optional[tuple[int, int]]: [MASK]\n", "response": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\ndef FermatFactor(n: int, max_steps: int) ->Optional[tuple[int, int]]:\n    \"\"\"Returns p and q such as n = p*q.\n\n  Fermat's factorization method is based on the representation of an odd\n  integer as the difference of two squares:\n    n = a**2 - b**2.\n  That difference is algebraically factorable as n = pq = (a + b)(a - b).\n  See https://en.wikipedia.org/wiki/Fermat%27s_factorization_method.\n\n  Args:\n    n: Value to factorize;\n    max_steps: Max of steps to try to find the square number.\n  \"\"\"\n    if n % 2 == 0:\n        return 2, n // 2\n    a = gmpy.isqrt(n)\n    if a * a == n:\n        return a, a\n    a += 1\n    b2 = a * a - n\n    for _ in range(max_steps):\n        if gmpy.is_square(b2):\n            return a + gmpy.isqrt(b2), a - gmpy.isqrt(b2)\n        b2 += a\n        a += 1\n        b2 += a\n    return None"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "RankDistribution", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef RankDistribution(r: int, c: int, k: int, allow_approximation: bool=True\n    ) ->list[float]: [MASK]\n", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\ndef RankDistribution(r: int, c: int, k: int, allow_approximation: bool=True\n    ) ->list[float]:\n    \"\"\"Returns the distribution of the rank of binary r*c matrices.\n\n  Args:\n    r: the number of rows of the matrix\n    c: the number of columns of the matrix\n    k: the last probability of the result is the sum of the probabilities of\n      getting a rank 0 .. r - k\n    allow_approximation: if True then approximations for large r and c might be\n      returned.\n\n  Returns:\n    a list of probabilities [p_0 .. p_k], where\n    p_k is the probability of getting a rank 0 .. r - k, otherwise p_i is\n    the probability that a random row * cols matrix has rank m - i.\n  \"\"\"\n    if allow_approximation:\n        if r == c and r >= 31 and k <= 5:\n            precomputed = [0.28878809, 0.57757619, 0.12835026, 0.00523879, \n                4.657e-05, 1e-07]\n            return precomputed[:k] + [sum(precomputed[k:])]\n    res = [0] * (r + 1)\n    res[0] = 1.0\n    for _ in range(c):\n        for j in range(r - 1, -1, -1):\n            prob_dependent = 2 ** (j - r)\n            res[j + 1] += res[j] * (1 - prob_dependent)\n            res[j] *= prob_dependent\n    return res[-k:][::-1] + [sum(res[:-k])]"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "LongestRunOfOnes", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef LongestRunOfOnes(seq: int) ->int: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef LongestRunOfOnes(seq: int) ->int:\n    \"\"\"Returns the longest run of 1's in a bit sequence.\n\n  Args:\n    seq: the bit-sequence\n\n  Returns:\n    the largest number of consecutive 1-bits.\n  \"\"\"\n    if seq == 0:\n        return 0\n    s = seq\n    longest_run = 1\n    while True:\n        s2 = s & s >> longest_run\n        if s2 == 0:\n            break\n        s = s2\n        longest_run *= 2\n    n = longest_run // 2\n    while n:\n        s2 = s & s >> n\n        if s2:\n            s = s2\n            longest_run += n\n        n //= 2\n    return longest_run"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "RandomExcursionsDistribution", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef RandomExcursionsDistribution(x: int, max_cnt: int=5) ->list[float]: [MASK]\n", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\ndef RandomExcursionsDistribution(x: int, max_cnt: int=5) ->list[float]:\n    \"\"\"Returns the probability distribution for the random excursions test.\n\n  The probability distribution is described in Section 3.14 of NIST SP 800-22.\n\n  Args:\n    x: the state\n    max_cnt: maximal number of visits of a state used in the test.\n\n  Returns:\n    a list of max_cnt + 1 probabilities. The last element of this\n    list is the sum of all probabilities for k >= max_cnt.\n  \"\"\"\n    pi = [0] * (max_cnt + 1)\n    t = 1 / (2 * abs(x))\n    pi[0] = 1 - t\n    for k in range(1, max_cnt):\n        pi[k] = t ** 2 * (1 - t) ** (k - 1)\n    pi[max_cnt] = t * (1 - t) ** (max_cnt - 1)\n    return pi"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "OverlappingTemplateMatchingDistribution", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef OverlappingTemplateMatchingMatrix(m: int, k: int) ->list[list[float]]:\n    \"\"\"Returns a transition probability matrix for the overlapping template test.\n\n  The overlapping template test counts the number of runs of 1s of size m in a\n  bit sequence. To compute the distribution of the number of runs of 1s we use\n  a Markov chain with k * m + 1 states. A bit string with i runs of 1s ending\n  with j 1s corresponds to state min(k * m, i * m + min(k - 1, j)).\n  The Markov chain described here stops counting after seeing k runs of size m.\n  I.e., state k*m is used for any case where k or more runs have occurred.\n  The matrix M returned describes the transition probability of adding a random\n  bit to a bit string. That is M[i][j] is the probability that appending a bit\n  to a bit string in state i gives a bit string in state j.\n\n  Args:\n    m: the length of the runs of 1s.\n    k: the upper bound on the number of runs of 1s of length m.\n\n  Returns:\n    the transition probability matrix.\n  \"\"\"\n    size = k * m + 1\n    mat = [([0] * size) for _ in range(size)]\n    for occurrences in range(k):\n        for run in range(m):\n            i = occurrences * m + run\n            mat[i][occurrences * m] += 0.5\n            if run < m - 1:\n                mat[i][i + 1] += 0.5\n            elif occurrences < k - 1:\n                mat[i][i + m] += 0.5\n            else:\n                mat[i][k * m] += 0.5\n    mat[k * m][k * m] = 1.0\n    return mat\n\n\ndef OverlappingTemplateMatchingDistribution(n: int, m: int, k: int) ->list[\n    float]: [MASK]\n", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\ndef OverlappingTemplateMatchingMatrix(m: int, k: int) ->list[list[float]]:\n    \"\"\"Returns a transition probability matrix for the overlapping template test.\n\n  The overlapping template test counts the number of runs of 1s of size m in a\n  bit sequence. To compute the distribution of the number of runs of 1s we use\n  a Markov chain with k * m + 1 states. A bit string with i runs of 1s ending\n  with j 1s corresponds to state min(k * m, i * m + min(k - 1, j)).\n  The Markov chain described here stops counting after seeing k runs of size m.\n  I.e., state k*m is used for any case where k or more runs have occurred.\n  The matrix M returned describes the transition probability of adding a random\n  bit to a bit string. That is M[i][j] is the probability that appending a bit\n  to a bit string in state i gives a bit string in state j.\n\n  Args:\n    m: the length of the runs of 1s.\n    k: the upper bound on the number of runs of 1s of length m.\n\n  Returns:\n    the transition probability matrix.\n  \"\"\"\n    size = k * m + 1\n    mat = [([0] * size) for _ in range(size)]\n    for occurrences in range(k):\n        for run in range(m):\n            i = occurrences * m + run\n            mat[i][occurrences * m] += 0.5\n            if run < m - 1:\n                mat[i][i + 1] += 0.5\n            elif occurrences < k - 1:\n                mat[i][i + m] += 0.5\n            else:\n                mat[i][k * m] += 0.5\n    mat[k * m][k * m] = 1.0\n    return mat\ndef OverlappingTemplateMatchingDistribution(n: int, m: int, k: int) ->list[\n    float]:\n    \"\"\"The expected probability distribution of an overlapping matching test.\n  Args:\n    n: the size of the bit string\n    m: the length of the template\n    k: the maximal number of occurrences\n  Returns:\n    a list of size k+1. If i < k then the i-th element is the probability that\n    a random bit string of size n contains k runs of 1s of size m. These runs\n    may overlap. The k-th element is the probability that a random bit string\n    of size n has k or more runs of 1s of size m.\n  \"\"\"\n    mat = OverlappingTemplateMatchingMatrix(m, k)\n    matn = numpy.linalg.matrix_power(mat, n)\n    row_0 = matn[0]\n    pi = [sum(row_0[i * m:(i + 1) * m]) for i in range(k + 1)]\n    return pi"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "UniversalDistribution", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef UniversalDistribution(block_size: int, k: int) ->tuple[float, float]: [MASK\n    ]\n", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\ndef UniversalDistribution(block_size: int, k: int) ->tuple[float, float]:\n    \"\"\"Returns expected value and standard deviation of a universal test.\n\n  Args:\n    block_size: the size of the blocks in bits\n    k: the number of blocks used in the test\n\n  Returns:\n    A tuple (expected, std) containing the expected value for f and\n    its standard deviation, where f is the value computed by the universal\n    test with k blocks of size block_size.\n  \"\"\"\n    distribution_table = {(1): (0.7326495, 0.69), (2): (1.5374383, 1.338),\n        (3): (2.4016068, 1.901), (4): (3.3112247, 2.358), (5): (4.2534266, \n        2.705), (6): (5.2177052, 2.954), (7): (6.1962507, 3.125), (8): (\n        7.1836656, 3.238), (9): (8.1764248, 3.311), (10): (9.1723243, 3.356\n        ), (11): (10.170032, 3.384), (12): (11.168765, 3.401), (13): (\n        12.16807, 3.41), (14): (13.167693, 3.416), (15): (14.167488, 3.419),\n        (16): (15.167379, 3.421)}\n    if block_size not in distribution_table:\n        raise ValueError('block_size not supported')\n    mean, variance = distribution_table[block_size]\n    c = 0.7 - 0.8 / block_size + (4 + 32 / block_size) * (k ** (-3 /\n        block_size) / 15)\n    std = c * math.sqrt(variance / k)\n    return mean, std"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "CombinedPValue", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef Igamc(a: float, x: float) ->float:\n    \"\"\"Computes the regularized upper incomplete gamma function.\n\n  NIST defines the function in section 5.5.3 of NIST SP-800 22 and calls\n  it igmac. Wikipedia denotes the function as Q(a, x).\n\n  The function is mainly used to compute p-values for statistical tests.\n  The result does not have to be very precise (e.g. 6 digits of precision are\n  more than enough). However, the implementation is expected to handle\n  floating point underflows and return 0 in such cases.\n\n  Args:\n    a: a positive floating point number\n    x: floating point number that is 0 or positive\n\n  Returns:\n    a p-value\n  \"\"\"\n    return scipy_special.gammaincc(a, x)\n\n\ndef CombinedPValue(pvalues: list[float]) ->float: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef Igamc(a: float, x: float) ->float:\n    \"\"\"Computes the regularized upper incomplete gamma function.\n\n  NIST defines the function in section 5.5.3 of NIST SP-800 22 and calls\n  it igmac. Wikipedia denotes the function as Q(a, x).\n\n  The function is mainly used to compute p-values for statistical tests.\n  The result does not have to be very precise (e.g. 6 digits of precision are\n  more than enough). However, the implementation is expected to handle\n  floating point underflows and return 0 in such cases.\n\n  Args:\n    a: a positive floating point number\n    x: floating point number that is 0 or positive\n\n  Returns:\n    a p-value\n  \"\"\"\n    return scipy_special.gammaincc(a, x)\ndef CombinedPValue(pvalues: list[float]) ->float:\n    \"\"\"Computes a combined p-value for a list of p-values.\n  When tests are repeated then the result of these tests is a list of p-values.\n  Thus we have to decide whether contains sufficiently small p-values to reject\n  the null hypothesis (i.e. reject the assumption that the pseudo random numbers\n  are indistinguishable from random data).\n  The method here computes s = -sum(math.log(p) for p in pvalues) and returns\n  the probability that a list of uniformly distributed p-values results in a\n  larger sum. This method was proposed by Fisher in 1934.\n  If the p-values are uniformly distributed (as they ideally should)\n  then the value s = -sum(math.log(p) for p in pvalues) has an Erlang\n  distribution. https://en.wikipedia.org/wiki/Erlang_distribution.\n  The survival function of the Erlang distribution with rate 1 is a special\n  case of Igamc.\n  Different proposals to combine p-values are compared in the paper\n  \"Choosing Between Methods of Combining p-values\" by N. A. Heard and\n  P. Rubin-Delanchy, https://arxiv.org/pdf/1707.06897.pdf .\n  A criterion used here is that the method should be sensitive to small\n  p-values. A pseudo random number generator that sometimes generates weak\n  output and sometimes does not is still a weak random number generator.\n  Args:\n    pvalues: a list of p-values from independent test runs.\n  Returns:\n    a combined p-value\n  \"\"\"\n    if not pvalues:\n        raise ValueError('empty sample')\n    elif len(pvalues) == 1:\n        return pvalues[0]\n    elif min(pvalues) == 0:\n        return 0\n    else:\n        s = sum(-math.log(p) for p in pvalues)\n        return Igamc(len(pvalues), s)"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "UniformSumCdf", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef NormalCdf(x: float, mean: float, variance: float) ->float:\n    \"\"\"Cumulative distribution function of the normal distribution.\n\n  See en.wikipedia.org/wiki/Normal_distribution\n  NIST SP 800-22a defines in Section 5.5.3 a function Cdf. This is\n  the same as NormalCdf with mean 0.0 and variance 1.0.\n\n  Args:\n    x: a value in the range -infinity .. infinity\n    mean: the mean value of the distribution\n    variance: the variance of the distribtuion\n\n  Returns:\n    a p-value\n  \"\"\"\n    return (1 + math.erf((x - mean) / math.sqrt(2 * variance))) / 2\n\n\ndef UniformSumCdf(n: int, x: float) ->float: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef NormalCdf(x: float, mean: float, variance: float) ->float:\n    \"\"\"Cumulative distribution function of the normal distribution.\n\n  See en.wikipedia.org/wiki/Normal_distribution\n  NIST SP 800-22a defines in Section 5.5.3 a function Cdf. This is\n  the same as NormalCdf with mean 0.0 and variance 1.0.\n\n  Args:\n    x: a value in the range -infinity .. infinity\n    mean: the mean value of the distribution\n    variance: the variance of the distribtuion\n\n  Returns:\n    a p-value\n  \"\"\"\n    return (1 + math.erf((x - mean) / math.sqrt(2 * variance))) / 2\ndef UniformSumCdf(n: int, x: float) ->float:\n    \"\"\"Cumulative distribution function of the Irwing-Hall distribution.\n  Args:\n    n: the number of random variables\n    x: the bound\n  Returns:\n    the probability that the sum of n uniform variables in the range 0..1\n    is smaller than x.\n  \"\"\"\n    if x <= 0:\n        return 0.0\n    elif 2 * x > n:\n        return 1.0 - UniformSumCdf(n, n - x)\n    elif n > 36:\n        return NormalCdf(x, n / 2, n / 12)\n    else:\n        p_value = 0.0\n        sign = 1\n        binom = 1\n        f = math.factorial(n)\n        for k in range(math.floor(x) + 1):\n            t = sign * binom / f * (x - k) ** n\n            p_value += t\n            sign = -sign\n            binom = binom * (n - k) // (k + 1)\n        return p_value"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "SplitSequence", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef SplitSequence(seq: int, length: int, m: int) ->list[int]: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef SplitSequence(seq: int, length: int, m: int) ->list[int]:\n    \"\"\"Splits a bit sequence into non-overlapping blocks of size m.\n\n  The splitting starts with the least significant bits. If the length\n  of the bit-sequence is not divisible by m then the last block will be\n  ignored.\n\n\n  Args:\n    seq: the bit-sequence to split\n    length: the length of the bit-sequence\n    m: the size of blocks in bits\n\n  Returns:\n    a list of blocks\n  \"\"\"\n    n = length // m\n    res = [0] * n\n    size = max((seq.bit_length() + 7) // 8, m * n // 8)\n    ba = seq.to_bytes(size, 'little')\n    if m % 8 == 0:\n        for i in range(n):\n            res[i] = int.from_bytes(ba[i * m // 8:(i + 1) * m // 8], 'little')\n    else:\n        mask = (1 << m) - 1\n        for i in range(n):\n            val = int.from_bytes(ba[i * m // 8:(i + 1) * m // 8 + 1], 'little')\n            val >>= i * m & 7\n            res[i] = val & mask\n    return res"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "Scatter", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef Scatter(seq: int, m: int) ->list[int]: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef Scatter(seq: int, m: int) ->list[int]:\n    \"\"\"Divides the bits of seq into m interleaved bit strings.\n\n  Args:\n    seq: the bit string\n    m: the number of interleaved bit strings\n\n  Returns:\n    a list of bit strings, where the i-th value of the result contains the bits\n    i, i+m, i+2*m, ... of the input seq.\n  \"\"\"\n    if seq.bit_length() < m:\n        return [(seq >> i & 1) for i in range(m)]\n    bits = format(seq, 'b')\n    res = []\n    offset = (len(bits) - 1) % m\n    for i in range(m):\n        start = (offset - i) % m\n        res.append(int(bits[start::m], 2))\n    return res"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "ReverseBits", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef _ReversedBytes() ->bytes:\n    \"\"\"Returns a table to reverse bits in a byte array.\n\n  The result of this function can be used to reverse the bits in each byte by\n  using bytes.translate() or bytearray.translate().\n\n  Returns:\n    the translation table\n  \"\"\"\n    res = bytearray(256)\n    for j in range(1, 256):\n        res[j] = res[j >> 1] >> 1 ^ (j & 1) << 7\n    return bytes(res)\n\n\n_REVERSE_BITS = _ReversedBytes()\n\n\ndef ReverseBits(seq: int, length: int) ->int: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef _ReversedBytes() ->bytes:\n    \"\"\"Returns a table to reverse bits in a byte array.\n\n  The result of this function can be used to reverse the bits in each byte by\n  using bytes.translate() or bytearray.translate().\n\n  Returns:\n    the translation table\n  \"\"\"\n    res = bytearray(256)\n    for j in range(1, 256):\n        res[j] = res[j >> 1] >> 1 ^ (j & 1) << 7\n    return bytes(res)\n_REVERSE_BITS = _ReversedBytes()\ndef ReverseBits(seq: int, length: int) ->int:\n    \"\"\"Reverses the bits in a bit string.\n  Args:\n    seq: the bit string\n    length: the length of the bit string\n  Returns:\n    the integer with the bits in reverse order\n  \"\"\"\n    a = seq.to_bytes((length + 7) // 8, 'little').translate(_REVERSE_BITS)\n    b = int.from_bytes(a, 'big')\n    c = b >> -length % 8\n    return c"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "Runs", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\n\n\ndef Runs(s: int, length: int) ->int: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\ndef Runs(s: int, length: int) ->int:\n    \"\"\"Computes the number of runs of a bit-sequence.\n  A run is a continuous sequence of 0's or a a continuous sequence\n  of 1's.\n  Args:\n    s: the bit-sequence\n    length: the length of the bit-sequence\n  Returns:\n    the number of runs.\n  \"\"\"\n    runs = BitCount(s ^ s >> 1)\n    if length and s >> length - 1 == 0:\n        runs += 1\n    return runs"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "OverlappingRunsOfOnes", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\n\n\ndef OverlappingRunsOfOnes(seq: int, m: int) ->int: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\ndef OverlappingRunsOfOnes(seq: int, m: int) ->int:\n    \"\"\"Returns the number of possibly overlapping runs of 1's of length m.\n  Example: if seq = 011101111100 and m = 3. Then this function returns\n  the number of subsequences of seq that are equal to 111. Since there are\n  such subsequences starting at positions 1, 5, 6, and 7 the result would be 4.\n  Args:\n    seq: the bit string to search\n    m: the length of the runs of 1s to search.\n  Returns:\n    the number of runs of 1's of length m in seq.\n  \"\"\"\n    k = 1\n    m -= 1\n    while m:\n        t = min(k, m)\n        seq = seq & seq >> t\n        m -= t\n        k *= 2\n    return BitCount(seq)"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "BinaryMatrixRank", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef _BinaryMatrixRankSmall(matrix: list[int]) ->int:\n    \"\"\"Computes the rank of a binary matrix.\n\n  This implementation is used for small matrices.\n\n  Args:\n    matrix: the binary matrix represented as a list of rows.\n\n  Returns:\n    the rank of the matrix\n  \"\"\"\n    m = matrix[:]\n    rank = 0\n    for i in range(len(m)):\n        if m[i]:\n            rank += 1\n            msb = 1 << m[i].bit_length() - 1\n            for j in range(i + 1, len(m)):\n                if m[j] & msb:\n                    m[j] ^= m[i]\n    return rank\n\n\ndef BinaryMatrixRank(matrix: list[int]) ->int: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef _BinaryMatrixRankSmall(matrix: list[int]) ->int:\n    \"\"\"Computes the rank of a binary matrix.\n\n  This implementation is used for small matrices.\n\n  Args:\n    matrix: the binary matrix represented as a list of rows.\n\n  Returns:\n    the rank of the matrix\n  \"\"\"\n    m = matrix[:]\n    rank = 0\n    for i in range(len(m)):\n        if m[i]:\n            rank += 1\n            msb = 1 << m[i].bit_length() - 1\n            for j in range(i + 1, len(m)):\n                if m[j] & msb:\n                    m[j] ^= m[i]\n    return rank\ndef BinaryMatrixRank(matrix: list[int]) ->int:\n    \"\"\"Computes the rank of a binary matrix.\n  The rank of a matrix is the number of linearly independent rows.\n  Args:\n    matrix: the binary matrix represented as a list of rows.\n  Returns:\n    the rank of the matrix\n  \"\"\"\n    for r in matrix:\n        if r < 0:\n            raise ValueError('rows cannot be negative')\n    if len(matrix) < 50:\n        return _BinaryMatrixRankSmall(matrix)\n    else:\n        return _BinaryMatrixRankLarge(matrix)"}
{"result": "passed", "model_name": "std", "repository": "paranoid_crypto", "full_method_name": "SubSequences", "method_path": "../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef SubSequences(seq: int, length: int, m: int, wrap: bool=True) ->Iterator[int\n    ]: [MASK]\n", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\ndef SubSequences(seq: int, length: int, m: int, wrap: bool=True) ->Iterator[int\n    ]:\n    \"\"\"Yields all m-bit subsequences of seq.\n\n  The order of the subsequences is not defined. The same subsequence\n  is returned multiple times if it occurs multiple times in seq.\n\n  Args:\n    seq: a bit-sequence represented as an integer\n    length: the length of seq\n    m: the length of the subsequence\n    wrap: if True allows bit sequences consisting of k least significant bits\n      followed by m-k most significant bits\n\n  Yields:\n    subsequences of size m\n  \"\"\"\n    if m <= 0:\n        raise ValueError('m must be positive')\n    if length < 0:\n        raise ValueError('length must not be negative')\n    if seq.bit_length() > length:\n        raise ValueError('seq has too many bits')\n    if m > length:\n        raise ValueError('m must not be larger than length')\n    ba = seq.to_bytes((length + 7) // 8, 'little')\n    mask = (1 << m) - 1\n    if wrap:\n        start = 0\n        s = seq >> length - m & mask\n    else:\n        start = m\n        s = int.from_bytes(ba[:(start + 7) // 8], 'little')\n        yield s & mask\n    for i in range(start, length):\n        if i & 7 == 0:\n            s ^= ba[i // 8] << m\n        s >>= 1\n        yield s & mask"}
