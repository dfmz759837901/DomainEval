{"result": "passed", "model_name": "std", "repository": "mpyc", "full_method_name": "SymmetricGroup", "method_path": "../srcdata/Cryptography/mpyc/mpyc/fingroups.py", "method_code_mask": "import math\nimport decimal\nimport functools\n\n\nclass FiniteGroupElement:\n    \"\"\"Abstract base class for finite groups.\n\n    Overview Python operators for group operation, inverse, and repeated operation:\n\n        - default notation: @, ~, ^ (matmul, invert, xor).\n        - additive notation: +, -, * (add, sub, mul)\n        - multiplicative notation: *, 1/ (or, **-1), ** (mul, truediv (or, pow), pow)\n    \"\"\"\n    __slots__ = 'value'\n    value: object\n    order = None\n    is_additive = False\n    is_multiplicative = False\n    identity = None\n    is_abelian = None\n    is_cyclic = None\n    generator = None\n\n    def __matmul__(self, other):\n        group = type(self)\n        if self is other:\n            return group.operation2(self)\n        if isinstance(other, group):\n            return group.operation(self, other)\n        return NotImplemented\n\n    def __invert__(self):\n        group = type(self)\n        return group.inversion(self)\n\n    def __xor__(self, other):\n        if isinstance(other, int):\n            group = type(self)\n            return group.repeat(self, other)\n        return NotImplemented\n\n    def __add__(self, other):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__matmul__(self, other)\n\n    def __neg__(self):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__invert__(self)\n\n    def __sub__(self, other):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__matmul__(self, group.__invert__(other))\n\n    def __mul__(self, other):\n        group = type(self)\n        if group.is_multiplicative:\n            return group.__matmul__(self, other)\n        if group.is_additive:\n            return NotImplemented\n        raise TypeError('* not defined for group')\n\n    def __rmul__(self, other):\n        group = type(self)\n        if group.is_multiplicative:\n            if group.is_abelian:\n                return group.__matmul__(self, other)\n            return group.__matmul__(group(other), self)\n        if group.is_additive:\n            return group.__xor__(self, other)\n        raise TypeError('* not defined for group')\n\n    def __truediv__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        return group.__matmul__(self, group.__invert__(other))\n\n    def __rtruediv__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        if other != 1:\n            raise TypeError('only 1/. supported')\n        return group.__invert__(self)\n\n    def __pow__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        return group.__xor__(self, other)\n\n    def __eq__(self, other):\n        group = type(self)\n        if not isinstance(other, group):\n            return NotImplemented\n        return group.equality(self, other)\n\n    def __hash__(self):\n        \"\"\"Make finite group elements hashable (e.g., for LRU caching).\"\"\"\n        return hash((type(self).__name__, self.value))\n\n    def __repr__(self):\n        return repr(self.value)\n\n    @classmethod\n    def operation(cls, a, b, /):\n        \"\"\"Return a @ b.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def operation2(cls, a, /):\n        \"\"\"Return a @ a.\"\"\"\n        return cls.operation(a, a)\n\n    @classmethod\n    def inversion(cls, a, /):\n        \"\"\"Return @-inverse of a (written ~a).\"\"\"\n        raise NotImplementedError\n\n    def inverse(self):\n        \"\"\"For convenience.\"\"\"\n        return type(self).inversion(self)\n\n    @classmethod\n    def equality(cls, a, b, /):\n        \"\"\"Return a == b.\"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def repeat(a, n):\n        \"\"\"Return nth @-power of a (written a^n), for any integer n.\"\"\"\n        cls = type(a)\n        if n < 0:\n            a = cls.inversion(a)\n            n = -n\n        d = a\n        c = cls.identity\n        for i in range(n.bit_length() - 1):\n            if n >> i & 1:\n                c = cls.operation(c, d)\n            d = cls.operation2(d)\n        if n:\n            c = cls.operation(c, d)\n        return c\n\n\nclass SymmetricGroupElement(FiniteGroupElement):\n    \"\"\"Common base class for symmetric groups.\n    Symmetric groups contains all permutations of a fixed length (degree).\n    Permutations of {0,...,n-1} represented as length-n tuples with unique\n    entries in {0,...,n-1}, n>=0.\n    \"\"\"\n    __slots__ = ()\n    degree = None\n\n    def __init__(self, value=None, check=True):\n        if value is None:\n            value = tuple(range(self.degree))\n        elif isinstance(value, list):\n            value = tuple(value)\n        if check:\n            if len(value) != self.degree or set(value) != set(range(self.\n                degree)):\n                raise ValueError(\n                    f'valid length-{self.degree} permutation required')\n        self.value = value\n\n    @classmethod\n    def operation(cls, p, q, /):\n        \"\"\"First p then q.\"\"\"\n        return cls(tuple(q.value[j] for j in p.value), check=False)\n\n    @classmethod\n    def inversion(cls, p, /):\n        n = len(p.value)\n        q = [None] * n\n        for i in range(n):\n            q[p.value[i]] = i\n        return cls(tuple(q), check=False)\n\n    @classmethod\n    def equality(cls, p, q, /):\n        return p.value == q.value\n\n\n@functools.cache\ndef SymmetricGroup(n): [MASK]\n", "response": "import math\nimport decimal\nimport functools\nclass FiniteGroupElement:\n    \"\"\"Abstract base class for finite groups.\n\n    Overview Python operators for group operation, inverse, and repeated operation:\n\n        - default notation: @, ~, ^ (matmul, invert, xor).\n        - additive notation: +, -, * (add, sub, mul)\n        - multiplicative notation: *, 1/ (or, **-1), ** (mul, truediv (or, pow), pow)\n    \"\"\"\n    __slots__ = 'value'\n    value: object\n    order = None\n    is_additive = False\n    is_multiplicative = False\n    identity = None\n    is_abelian = None\n    is_cyclic = None\n    generator = None\n\n    def __matmul__(self, other):\n        group = type(self)\n        if self is other:\n            return group.operation2(self)\n        if isinstance(other, group):\n            return group.operation(self, other)\n        return NotImplemented\n\n    def __invert__(self):\n        group = type(self)\n        return group.inversion(self)\n\n    def __xor__(self, other):\n        if isinstance(other, int):\n            group = type(self)\n            return group.repeat(self, other)\n        return NotImplemented\n\n    def __add__(self, other):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__matmul__(self, other)\n\n    def __neg__(self):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__invert__(self)\n\n    def __sub__(self, other):\n        group = type(self)\n        if not group.is_additive:\n            raise TypeError('group not additive')\n        return group.__matmul__(self, group.__invert__(other))\n\n    def __mul__(self, other):\n        group = type(self)\n        if group.is_multiplicative:\n            return group.__matmul__(self, other)\n        if group.is_additive:\n            return NotImplemented\n        raise TypeError('* not defined for group')\n\n    def __rmul__(self, other):\n        group = type(self)\n        if group.is_multiplicative:\n            if group.is_abelian:\n                return group.__matmul__(self, other)\n            return group.__matmul__(group(other), self)\n        if group.is_additive:\n            return group.__xor__(self, other)\n        raise TypeError('* not defined for group')\n\n    def __truediv__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        return group.__matmul__(self, group.__invert__(other))\n\n    def __rtruediv__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        if other != 1:\n            raise TypeError('only 1/. supported')\n        return group.__invert__(self)\n\n    def __pow__(self, other):\n        group = type(self)\n        if not group.is_multiplicative:\n            raise TypeError('group not multiplicative')\n        return group.__xor__(self, other)\n\n    def __eq__(self, other):\n        group = type(self)\n        if not isinstance(other, group):\n            return NotImplemented\n        return group.equality(self, other)\n\n    def __hash__(self):\n        \"\"\"Make finite group elements hashable (e.g., for LRU caching).\"\"\"\n        return hash((type(self).__name__, self.value))\n\n    def __repr__(self):\n        return repr(self.value)\n\n    @classmethod\n    def operation(cls, a, b, /):\n        \"\"\"Return a @ b.\"\"\"\n        raise NotImplementedError\n\n    @classmethod\n    def operation2(cls, a, /):\n        \"\"\"Return a @ a.\"\"\"\n        return cls.operation(a, a)\n\n    @classmethod\n    def inversion(cls, a, /):\n        \"\"\"Return @-inverse of a (written ~a).\"\"\"\n        raise NotImplementedError\n\n    def inverse(self):\n        \"\"\"For convenience.\"\"\"\n        return type(self).inversion(self)\n\n    @classmethod\n    def equality(cls, a, b, /):\n        \"\"\"Return a == b.\"\"\"\n        raise NotImplementedError\n\n    @staticmethod\n    def repeat(a, n):\n        \"\"\"Return nth @-power of a (written a^n), for any integer n.\"\"\"\n        cls = type(a)\n        if n < 0:\n            a = cls.inversion(a)\n            n = -n\n        d = a\n        c = cls.identity\n        for i in range(n.bit_length() - 1):\n            if n >> i & 1:\n                c = cls.operation(c, d)\n            d = cls.operation2(d)\n        if n:\n            c = cls.operation(c, d)\n        return c\nclass SymmetricGroupElement(FiniteGroupElement):\n    \"\"\"Common base class for symmetric groups.\n    Symmetric groups contains all permutations of a fixed length (degree).\n    Permutations of {0,...,n-1} represented as length-n tuples with unique\n    entries in {0,...,n-1}, n>=0.\n    \"\"\"\n    __slots__ = ()\n    degree = None\n    def __init__(self, value=None, check=True):\n        if value is None:\n            value = tuple(range(self.degree))\n        elif isinstance(value, list):\n            value = tuple(value)\n        if check:\n            if len(value) != self.degree or set(value) != set(range(self.\n                degree)):\n                raise ValueError(\n                    f'valid length-{self.degree} permutation required')\n        self.value = value\n    @classmethod\n    def operation(cls, p, q, /):\n        \"\"\"First p then q.\"\"\"\n        return cls(tuple(q.value[j] for j in p.value), check=False)\n    @classmethod\n    def inversion(cls, p, /):\n        n = len(p.value)\n        q = [None] * n\n        for i in range(n):\n            q[p.value[i]] = i\n        return cls(tuple(q), check=False)\n    @classmethod\n    def equality(cls, p, q, /):\n        return p.value == q.value\n@functools.cache\ndef SymmetricGroup(n):\n    \"\"\"Create type for symmetric group of degree n, n>=0.\"\"\"\n    name = f'Sym({n})'\n    Sym = type(name, (SymmetricGroupElement,), {'__slots__': ()})\n    Sym.degree = n\n    Sym.order = math.factorial(n)\n    Sym.is_abelian = n <= 2\n    Sym.is_cyclic = n <= 2\n    Sym.identity = Sym()\n    globals()[name] = Sym\n    return Sym"}
