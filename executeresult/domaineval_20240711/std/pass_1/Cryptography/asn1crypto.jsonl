{"result": "passed", "model_name": "std", "repository": "asn1crypto", "full_method_name": "_int_to_bit_tuple", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/core.py", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\n\n\ndef _int_to_bit_tuple(value, bits): [MASK]\n", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\ndef _int_to_bit_tuple(value, bits):\n    \"\"\"\n    Format value as a tuple of 1s and 0s.\n\n    :param value:\n        A non-negative integer to format\n\n    :param bits:\n        Number of bits in the output\n\n    :return:\n        A tuple of 1s and 0s with bits members.\n    \"\"\"\n    if not value and not bits:\n        return ()\n    result = tuple(map(int, format(value, '0{0}b'.format(bits))))\n    if len(result) != bits:\n        raise ValueError('Result too large: {0} > {1}'.format(len(result),\n            bits))\n    return result"}
{"result": "passed", "model_name": "std", "repository": "asn1crypto", "full_method_name": "walk_ast", "method_path": "../srcdata/Cryptography/asn1crypto/tests/test_init.py", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\n\n\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\n\n\ndef walk_ast(parent_node, modname, imports): [MASK]\n", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\ndef walk_ast(parent_node, modname, imports):\n    \"\"\"\n    Walks the AST for a module finding any imports and recording them\n    :param parent_node:\n        A node from the _ast module\n    :param modname:\n        A unicode string of the module we are walking the AST of\n    :param imports:\n        A set of unicode strings of the imports that have been found so far\n    \"\"\"\n    for node in ast.iter_child_nodes(parent_node):\n        if isinstance(node, _ast.Import):\n            if node.names[0].name.startswith(module.__name__):\n                add_mod(node.names[0].name, imports)\n        elif isinstance(node, _ast.ImportFrom):\n            if node.level > 0:\n                if modname == module.__name__:\n                    base_mod = module.__name__\n                else:\n                    base_mod = '.'.join(modname.split('.')[:-node.level])\n                if node.module:\n                    base_mod += '.' + node.module\n            else:\n                base_mod = node.module\n            if not base_mod.startswith(module.__name__):\n                continue\n            if node.level > 0 and not node.module:\n                for n in node.names:\n                    add_mod(base_mod + '.' + n.name, imports)\n            else:\n                add_mod(base_mod, imports)\n        elif isinstance(node, _ast.If):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info >= (3, 3) and isinstance(node, _ast.Try):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryFinally):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryExcept):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)"}
{"result": "passed", "model_name": "std", "repository": "asn1crypto", "full_method_name": "create_timezone", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/util.py", "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\n\n\ndef create_timezone(offset): [MASK]\n", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\ndef create_timezone(offset):\n    \"\"\"\n    Returns a new datetime.timezone object with the given offset.\n    Uses cached objects if possible.\n    :param offset:\n        A datetime.timedelta object; It needs to be in full minutes and between -23:59 and +23:59.\n    :return:\n        A datetime.timezone object\n    \"\"\"\n    try:\n        tz = _timezone_cache[offset]\n    except KeyError:\n        tz = _timezone_cache[offset] = timezone(offset)\n    return tz"}
