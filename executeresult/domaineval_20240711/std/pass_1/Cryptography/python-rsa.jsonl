{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "_markers", "method_path": "../srcdata/Cryptography/python-rsa/rsa/pem.py", "method_code_mask": "import base64\nimport typing\nFlexiText = typing.Union[str, bytes]\n\n\ndef _markers(pem_marker: FlexiText) ->typing.Tuple[bytes, bytes]: [MASK]\n", "response": "import base64\nimport typing\nFlexiText = typing.Union[str, bytes]\ndef _markers(pem_marker: FlexiText) ->typing.Tuple[bytes, bytes]:\n    \"\"\"\n    Returns the start and end PEM markers, as bytes.\n    \"\"\"\n    if not isinstance(pem_marker, bytes):\n        pem_marker = pem_marker.encode('ascii')\n    return (b'-----BEGIN ' + pem_marker + b'-----', b'-----END ' +\n        pem_marker + b'-----')"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "inverse", "method_path": "../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef inverse(x: int, n: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\ndef inverse(x: int, n: int) ->int:\n    \"\"\"Returns the inverse of x % n under multiplication, a.k.a x^-1 (mod n)\n\n    >>> inverse(7, 4)\n    3\n    >>> (inverse(143, 4) * 143) % 4\n    1\n    \"\"\"\n    divider, inv, _ = extended_gcd(x, n)\n    if divider != 1:\n        raise NotRelativePrimeError(x, n, divider)\n    return inv"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "byte_size", "method_path": "../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef byte_size(number: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\ndef byte_size(number: int) ->int:\n    \"\"\"\n    Returns the number of bytes required to hold a specific long number.\n\n    The number of bytes is rounded up.\n\n    Usage::\n\n        >>> byte_size(1 << 1023)\n        128\n        >>> byte_size((1 << 1024) - 1)\n        128\n        >>> byte_size(1 << 1024)\n        129\n\n    :param number:\n        An unsigned integer\n    :returns:\n        The number of bytes required to hold a specific long number.\n    \"\"\"\n    if number == 0:\n        return 1\n    return ceil_div(bit_size(number), 8)"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "gen_keys", "method_path": "../srcdata/Cryptography/python-rsa/rsa/key.py", "method_code_mask": "import abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\nfrom pyasn1.codec.der import decoder\nfrom rsa.asn1 import AsnPubKey\nfrom pyasn1.codec.der import encoder\nfrom rsa.asn1 import OpenSSLPubKey\nfrom pyasn1.type import univ\nfrom pyasn1.type import namedtype\nfrom rsa import parallel\nimport doctest\n\n\ndef calculate_keys_custom_exponent(p: int, q: int, exponent: int, rs:\n    typing.Optional[typing.List[int]]=None) ->typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n    phi_n = math.prod([(x - 1) for x in [p, q] + ([] if rs is None else rs)])\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(exponent, phi_n, ex.d, msg=\n            'e (%d) and phi_n (%d) are not relatively prime (divider=%i)' %\n            (exponent, phi_n, ex.d)) from ex\n    if exponent * d % phi_n != 1:\n        raise ValueError(\n            'e (%d) and d (%d) are not mult. inv. modulo phi_n (%d)' % (\n            exponent, d, phi_n))\n    return exponent, d\n\n\ndef find_p_q(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True) ->typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n        *Introduced in Python-RSA 3.1*\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n    When not in accurate mode, the number of bits can be slightly less\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n    \"\"\"\n    total_bits = nbits * 2\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n\n    def is_acceptable(p: int, q: int) ->bool:\n        \"\"\"Returns True iff p and q are acceptable:\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n        if p == q:\n            return False\n        if not accurate:\n            return True\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n    change_p = False\n    while not is_acceptable(p, q):\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n        change_p = not change_p\n    return max(p, q), min(p, q)\n\n\ndef find_primes(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True, nprimes: int=2) ->typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1] * rem + [quo] * (nprimes - rem)\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n    return list(reversed(sorted(primes)))\n\n\nDEFAULT_EXPONENT = 65537\n\n\ndef gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],\n    accurate: bool=True, exponent: int=DEFAULT_EXPONENT, nprimes: int=2\n    ) ->typing.Tuple: [MASK]\n", "response": "import abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\nfrom pyasn1.codec.der import decoder\nfrom rsa.asn1 import AsnPubKey\nfrom pyasn1.codec.der import encoder\nfrom rsa.asn1 import OpenSSLPubKey\nfrom pyasn1.type import univ\nfrom pyasn1.type import namedtype\nfrom rsa import parallel\nimport doctest\ndef calculate_keys_custom_exponent(p: int, q: int, exponent: int, rs:\n    typing.Optional[typing.List[int]]=None) ->typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n    phi_n = math.prod([(x - 1) for x in [p, q] + ([] if rs is None else rs)])\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(exponent, phi_n, ex.d, msg=\n            'e (%d) and phi_n (%d) are not relatively prime (divider=%i)' %\n            (exponent, phi_n, ex.d)) from ex\n    if exponent * d % phi_n != 1:\n        raise ValueError(\n            'e (%d) and d (%d) are not mult. inv. modulo phi_n (%d)' % (\n            exponent, d, phi_n))\n    return exponent, d\ndef find_p_q(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True) ->typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n        *Introduced in Python-RSA 3.1*\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n    When not in accurate mode, the number of bits can be slightly less\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n    \"\"\"\n    total_bits = nbits * 2\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n    def is_acceptable(p: int, q: int) ->bool:\n        \"\"\"Returns True iff p and q are acceptable:\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n        if p == q:\n            return False\n        if not accurate:\n            return True\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n    change_p = False\n    while not is_acceptable(p, q):\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n        change_p = not change_p\n    return max(p, q), min(p, q)\ndef find_primes(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True, nprimes: int=2) ->typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1] * rem + [quo] * (nprimes - rem)\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n    return list(reversed(sorted(primes)))\nDEFAULT_EXPONENT = 65537\ndef gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],\n    accurate: bool=True, exponent: int=DEFAULT_EXPONENT, nprimes: int=2\n    ) ->typing.Tuple:\n    \"\"\"Generate RSA keys of nbits bits. Returns (p, q, e, d) or (p, q, e, d, rs).\n    Note: this can take a long time, depending on the key size.\n    :param nbits: the total number of bits in ``p`` and ``q``. Both ``p`` and\n        ``q`` will use ``nbits/2`` bits.\n    :param getprime_func: either :py:func:`rsa.prime.getprime` or a function\n        with similar signature.\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param nprimes: the number of prime factors comprising the modulus.\n    \"\"\"\n    while True:\n        primes = find_primes(nbits, getprime_func, accurate, nprimes)\n        p, q, rs = primes[0], primes[1], primes[2:]\n        try:\n            e, d = calculate_keys_custom_exponent(p, q, exponent=exponent,\n                rs=rs)\n            break\n        except ValueError:\n            pass\n    if rs:\n        return p, q, e, d, rs\n    else:\n        return p, q, e, d"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "mgf1", "method_path": "../srcdata/Cryptography/python-rsa/rsa/pkcs1_v2.py", "method_code_mask": "from rsa import common\nfrom rsa import pkcs1\nfrom rsa import transform\nimport doctest\n\n\ndef mgf1(seed: bytes, length: int, hasher: str='SHA-1') ->bytes: [MASK]\n", "response": "from rsa import common\nfrom rsa import pkcs1\nfrom rsa import transform\nimport doctest\ndef mgf1(seed: bytes, length: int, hasher: str='SHA-1') ->bytes:\n    \"\"\"\n    MGF1 is a Mask Generation Function based on a hash function.\n\n    A mask generation function takes an octet string of variable length and a\n    desired output length as input, and outputs an octet string of the desired\n    length. The plaintext-awareness of RSAES-OAEP relies on the random nature of\n    the output of the mask generation function, which in turn relies on the\n    random nature of the underlying hash.\n\n    :param bytes seed: seed from which mask is generated, an octet string\n    :param int length: intended length in octets of the mask, at most 2^32(hLen)\n    :param str hasher: hash function (hLen denotes the length in octets of the hash\n        function output)\n\n    :return: mask, an octet string of length `length`\n    :rtype: bytes\n\n    :raise OverflowError: when `length` is too large for the specified `hasher`\n    :raise ValueError: when specified `hasher` is invalid\n    \"\"\"\n    try:\n        hash_length = pkcs1.HASH_METHODS[hasher]().digest_size\n    except KeyError as ex:\n        raise ValueError(\n            'Invalid `hasher` specified. Please select one of: {hash_list}'\n            .format(hash_list=', '.join(sorted(pkcs1.HASH_METHODS.keys())))\n            ) from ex\n    if length > 2 ** 32 * hash_length:\n        raise OverflowError(\n            \"Desired length should be at most 2**32 times the hasher's output length ({hash_length} for {hasher} function)\"\n            .format(hash_length=hash_length, hasher=hasher))\n    output = b''.join(pkcs1.compute_hash(seed + transform.int2bytes(counter,\n        fill_size=4), method_name=hasher) for counter in range(common.\n        ceil_div(length, hash_length) + 1))\n    return output[:length]"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "cleanup_files", "method_path": "../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\ndef remove_if_exists(fname):\n    \"\"\"Removes a file if it exists.\"\"\"\n    if os.path.exists(fname):\n        os.unlink(fname)\n\n\ndef cleanup_files(*filenames): [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\ndef remove_if_exists(fname):\n    \"\"\"Removes a file if it exists.\"\"\"\n    if os.path.exists(fname):\n        os.unlink(fname)\ndef cleanup_files(*filenames):\n    \"\"\"Makes sure the files don't exist when the test runs, and deletes them afterward.\"\"\"\n    def remove():\n        for fname in filenames:\n            remove_if_exists(fname)\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            remove()\n            try:\n                return func(*args, **kwargs)\n            finally:\n                remove()\n        return wrapper\n    return decorator"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "int2bytes", "method_path": "../srcdata/Cryptography/python-rsa/rsa/transform.py", "method_code_mask": "import math\nimport doctest\n\n\ndef int2bytes(number: int, fill_size: int=0) ->bytes: [MASK]\n", "response": "import math\nimport doctest\ndef int2bytes(number: int, fill_size: int=0) ->bytes:\n    \"\"\"\n    Convert an unsigned integer to bytes (big-endian)::\n\n    Does not preserve leading zeros if you don't specify a fill size.\n\n    :param number:\n        Integer value\n    :param fill_size:\n        If the optional fill size is given the length of the resulting\n        byte string is expected to be the fill size and will be padded\n        with prefix zero bytes to satisfy that length.\n    :returns:\n        Raw bytes (base-256 representation).\n    :raises:\n        ``OverflowError`` when fill_size is given and the number takes up more\n        bytes than fit into the block. This requires the ``overflow``\n        argument to this function to be set to ``False`` otherwise, no\n        error will be raised.\n    \"\"\"\n    if number < 0:\n        raise ValueError('Number must be an unsigned integer: %d' % number)\n    bytes_required = max(1, math.ceil(number.bit_length() / 8))\n    if fill_size > 0:\n        return number.to_bytes(fill_size, 'big')\n    return number.to_bytes(bytes_required, 'big')"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "bit_size", "method_path": "../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef bit_size(num: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\ndef bit_size(num: int) ->int:\n    \"\"\"\n    Number of bits needed to represent a integer excluding any prefix\n    0 bits.\n\n    Usage::\n\n        >>> bit_size(1023)\n        10\n        >>> bit_size(1024)\n        11\n        >>> bit_size(1025)\n        11\n\n    :param num:\n        Integer value. If num is 0, returns 0. Only the absolute value of the\n        number is considered. Therefore, signed integers will be abs(num)\n        before the number's bit length is determined.\n    :returns:\n        Returns the number of bits in the integer.\n    \"\"\"\n    try:\n        return num.bit_length()\n    except AttributeError as ex:\n        raise TypeError('bit_size(num) only supports integers, not %r' %\n            type(num)) from ex"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "cli_args", "method_path": "../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef cli_args(*new_argv): [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n@contextmanager\ndef cli_args(*new_argv):\n    \"\"\"Updates sys.argv[1:] for a single test.\"\"\"\n    old_args = sys.argv[:]\n    sys.argv[1:] = [str(arg) for arg in new_argv]\n    try:\n        yield\n    finally:\n        sys.argv[1:] = old_args"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "captured_output", "method_path": "../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef captured_output() ->typing.Generator: [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n@contextmanager\ndef captured_output() ->typing.Generator:\n    \"\"\"Captures output to stdout and stderr\"\"\"\n    buf_out = io.StringIO()\n    buf_out.buffer = io.BytesIO()\n    buf_err = io.StringIO()\n    buf_err.buffer = io.BytesIO()\n    with redirect_stdout(buf_out), redirect_stderr(buf_err):\n        yield buf_out, buf_err"}
{"result": "passed", "model_name": "std", "repository": "python-rsa", "full_method_name": "is_prime", "method_path": "../srcdata/Cryptography/python-rsa/rsa/prime.py", "method_code_mask": "import rsa.common\nimport rsa.randnum\nimport doctest\n\n\ndef miller_rabin_primality_testing(n: int, k: int) ->bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n    if n < 2:\n        return False\n    d = n - 1\n    r = 0\n    while not d & 1:\n        r += 1\n        d >>= 1\n    for _ in range(k):\n        a = rsa.randnum.randint(n - 3) + 1\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n\ndef get_primality_testing_rounds(number: int) ->int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n    bitsize = rsa.common.bit_size(number)\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    return 10\n\n\ndef is_prime(number: int) ->bool: [MASK]\n", "response": "import rsa.common\nimport rsa.randnum\nimport doctest\ndef miller_rabin_primality_testing(n: int, k: int) ->bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n    if n < 2:\n        return False\n    d = n - 1\n    r = 0\n    while not d & 1:\n        r += 1\n        d >>= 1\n    for _ in range(k):\n        a = rsa.randnum.randint(n - 3) + 1\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\ndef get_primality_testing_rounds(number: int) ->int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n    bitsize = rsa.common.bit_size(number)\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    return 10\ndef is_prime(number: int) ->bool:\n    \"\"\"Returns True if the number is prime, and False otherwise.\n    >>> is_prime(2)\n    True\n    >>> is_prime(42)\n    False\n    >>> is_prime(41)\n    True\n    \"\"\"\n    if number < 10:\n        return number in {2, 3, 5, 7}\n    if not number & 1:\n        return False\n    k = get_primality_testing_rounds(number)\n    return miller_rabin_primality_testing(number, k + 1)"}
