{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "triangulate", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef triangulate(geom, tolerance=0.0, edges=False): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef triangulate(geom, tolerance=0.0, edges=False):\n    \"\"\"Creates the Delaunay triangulation and returns a list of geometries\n\n    The source may be any geometry type. All vertices of the geometry will be\n    used as the points of the triangulation.\n\n    From the GEOS documentation:\n    tolerance is the snapping tolerance used to improve the robustness of\n    the triangulation computation. A tolerance of 0.0 specifies that no\n    snapping will take place.\n\n    If edges is False, a list of Polygons (triangles) will be returned.\n    Otherwise the list of LineString edges is returned.\n\n    \"\"\"\n    collection = shapely.delaunay_triangles(geom, tolerance=tolerance,\n        only_edges=edges)\n    return [g for g in collection.geoms]"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "nearest_points", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef nearest_points(g1, g2): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef nearest_points(g1, g2):\n    \"\"\"Returns the calculated nearest points in the input geometries\n\n    The points are returned in the same order as the input geometries.\n    \"\"\"\n    seq = shapely.shortest_line(g1, g2)\n    if seq is None:\n        if g1.is_empty:\n            raise ValueError('The first input geometry is empty')\n        else:\n            raise ValueError('The second input geometry is empty')\n    p1 = shapely.get_point(seq, 0)\n    p2 = shapely.get_point(seq, 1)\n    return p1, p2"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "make_valid", "method_path": "../srcdata/Computation/shapely/shapely/validation.py", "method_code_mask": "import shapely\n\n\ndef make_valid(ob): [MASK]\n", "response": "import shapely\ndef make_valid(ob):\n    \"\"\"\n    Make the input geometry valid according to the GEOS MakeValid algorithm.\n\n    If the input geometry is already valid, then it will be returned.\n\n    If the geometry must be split into multiple parts of the same type to be made valid,\n    then a multi-part geometry will be returned.\n\n    If the geometry must be split into multiple parts of different types to be made valid,\n    then a GeometryCollection will be returned.\n\n    Parameters\n    ----------\n    ob : Geometry\n        A shapely geometry object which should be made valid. If the object is already valid,\n        it will be returned as-is.\n\n    Returns\n    -------\n    Geometry\n        The input geometry, made valid according to the GEOS MakeValid algorithm.\n\n    \"\"\"\n    if ob.is_valid:\n        return ob\n    return shapely.make_valid(ob)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "dumps", "method_path": "../srcdata/Computation/shapely/shapely/wkb.py", "method_code_mask": "import shapely\n\n\ndef dumps(ob, hex=False, srid=None, **kw): [MASK]\n", "response": "import shapely\ndef dumps(ob, hex=False, srid=None, **kw):\n    \"\"\"Dump a WKB representation of a geometry to a byte string, or a\n    hex-encoded string if ``hex=True``.\n\n    Parameters\n    ----------\n    ob : geometry\n        The geometry to export to well-known binary (WKB) representation\n    hex : bool\n        If true, export the WKB as a hexadecimal string. The default is to\n        return a binary string/bytes object.\n    srid : int\n        Spatial reference system ID to include in the output. The default value\n        means no SRID is included.\n    **kw : kwargs, optional\n        Keyword output options passed to :func:`~shapely.to_wkb`.\n    \"\"\"\n    if srid is not None:\n        ob = shapely.set_srid(ob, srid)\n        kw['include_srid'] = True\n    if 'big_endian' in kw:\n        big_endian = kw.pop('big_endian')\n        byte_order = 0 if big_endian else 1\n        kw.update(byte_order=byte_order)\n    return shapely.to_wkb(ob, hex=hex, **kw)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "orient", "method_path": "../srcdata/Computation/shapely/shapely/geometry/polygon.py", "method_code_mask": "import numpy as np\nimport shapely\nfrom shapely.algorithms.cga import is_ccw_impl\nfrom shapely.algorithms.cga import signed_area\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.point import Point\n\n\ndef orient(polygon, sign=1.0): [MASK]\n", "response": "import numpy as np\nimport shapely\nfrom shapely.algorithms.cga import is_ccw_impl\nfrom shapely.algorithms.cga import signed_area\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.point import Point\ndef orient(polygon, sign=1.0):\n    s = float(sign)\n    rings = []\n    ring = polygon.exterior\n    if signed_area(ring) / s >= 0.0:\n        rings.append(ring)\n    else:\n        rings.append(list(ring.coords)[::-1])\n    for ring in polygon.interiors:\n        if signed_area(ring) / s <= 0.0:\n            rings.append(ring)\n        else:\n            rings.append(list(ring.coords)[::-1])\n    return Polygon(rings[0], rings[1:])"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "box", "method_path": "../srcdata/Computation/shapely/shapely/geometry/geo.py", "method_code_mask": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\n\n\ndef box(minx, miny, maxx, maxy, ccw=True): [MASK]\n", "response": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\ndef box(minx, miny, maxx, maxy, ccw=True):\n    \"\"\"Returns a rectangular polygon with configurable normal vector\"\"\"\n    coords = [(maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny)]\n    if not ccw:\n        coords = coords[::-1]\n    return Polygon(coords)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "plot_points", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_points(geom, ax=None, color=None, marker='o', **kwargs): [MASK]\n", "response": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_points(geom, ax=None, color=None, marker='o', **kwargs):\n    \"\"\"\n    Plot a Point/MultiPoint or the vertices of any other geometry type.\n\n    Parameters\n    ----------\n    geom : shapely.Geometry\n        Any shapely Geometry object, from which all vertices are extracted\n        and plotted.\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    color : matplotlib color specification\n        Color for the filled points. You can use `markeredgecolor` and\n        `markerfacecolor` to have different edge and fill colors.\n    marker : str, default \"o\"\n        The matplotlib marker for the points.\n    **kwargs\n        Additional keyword arguments passed to matplotlib `plot` (Line2D).\n\n    Returns\n    -------\n    Matplotlib artist (Line2D)\n    \"\"\"\n    if ax is None:\n        ax = _default_ax()\n    coords = shapely.get_coordinates(geom)\n    line, = ax.plot(coords[:, 0], coords[:, 1], linestyle='', marker=marker,\n        color=color, **kwargs)\n    return line"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "tree.query", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_strtree.py", "method_code_mask": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\n\n\n@pytest.fixture(scope='session')\ndef tree(): [MASK]\n", "response": "import itertools\nimport math\nimport pickle\nimport subprocess\nimport sys\nfrom concurrent.futures import ThreadPoolExecutor\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nimport shapely\nfrom shapely import box\nfrom shapely import geos_version\nfrom shapely import LineString\nfrom shapely import MultiPoint\nfrom shapely import Point\nfrom shapely import STRtree\nfrom shapely.errors import UnsupportedGEOSVersionError\nfrom shapely.testing import assert_geometries_equal\nfrom shapely.tests.common import empty\nfrom shapely.tests.common import empty_line_string\nfrom shapely.tests.common import empty_point\nfrom shapely.tests.common import ignore_invalid\nfrom shapely.tests.common import point\nimport gc\n@pytest.fixture(scope='session')\ndef tree():\n    geoms = shapely.points(np.arange(10), np.arange(10))\n    yield STRtree(geoms)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "plot_line", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_line(line, ax=None, add_points=True, color=None, linewidth=2, **kwargs\n    ): [MASK]\n", "response": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_line(line, ax=None, add_points=True, color=None, linewidth=2, **kwargs\n    ):\n    \"\"\"\n    Plot a (Multi)LineString/LinearRing.\n\n    Note: this function is experimental, and mainly targeting (interactive)\n    exploration, debugging and illustration purposes.\n\n    Parameters\n    ----------\n    line : shapely.LineString or shapely.LinearRing\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    add_points : bool, default True\n        If True, also plot the coordinates (vertices) as points.\n    color : matplotlib color specification\n        Color for the line (edgecolor under the hood) and points.\n    linewidth : float, default 2\n        The line width for the polygon boundary.\n    **kwargs\n        Additional keyword arguments passed to the matplotlib Patch.\n\n    Returns\n    -------\n    Matplotlib artist (PathPatch)\n    \"\"\"\n    from matplotlib.patches import PathPatch\n    from matplotlib.path import Path\n    if ax is None:\n        ax = _default_ax()\n    if color is None:\n        color = 'C0'\n    if isinstance(line, shapely.MultiLineString):\n        path = Path.make_compound_path(*[Path(np.asarray(mline.coords)[:, :\n            2]) for mline in line.geoms])\n    else:\n        path = Path(np.asarray(line.coords)[:, :2])\n    patch = PathPatch(path, facecolor='none', edgecolor=color, linewidth=\n        linewidth, **kwargs)\n    ax.add_patch(patch)\n    ax.autoscale_view()\n    if add_points:\n        line = plot_points(line, ax=ax, color=color)\n        return patch, line\n    return patch"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "set_first_element", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_misc.py", "method_code_mask": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\n\n\n@multithreading_enabled\ndef set_first_element(value, *args, **kwargs): [MASK]\n", "response": "import os\nimport sys\nfrom inspect import cleandoc\nfrom itertools import chain\nfrom string import ascii_letters\nfrom string import digits\nfrom unittest import mock\nimport numpy as np\nimport pytest\nimport shapely\nfrom shapely.decorators import multithreading_enabled\nfrom shapely.decorators import requires_geos\n@multithreading_enabled\ndef set_first_element(value, *args, **kwargs):\n    for arg in chain(args, kwargs.values()):\n        if hasattr(arg, '__setitem__'):\n            arg[0] = value\n            return arg"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "shape", "method_path": "../srcdata/Computation/shapely/shapely/geometry/geo.py", "method_code_mask": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\n\n\ndef shape(context): [MASK]\n", "response": "import numpy as np\nfrom shapely.errors import GeometryTypeError\nfrom shapely.geometry.collection import GeometryCollection\nfrom shapely.geometry.linestring import LineString\nfrom shapely.geometry.multilinestring import MultiLineString\nfrom shapely.geometry.multipoint import MultiPoint\nfrom shapely.geometry.multipolygon import MultiPolygon\nfrom shapely.geometry.point import Point\nfrom shapely.geometry.polygon import LinearRing\nfrom shapely.geometry.polygon import Polygon\ndef shape(context):\n    \"\"\"\n    Returns a new, independent geometry with coordinates *copied* from the\n    context. Changes to the original context will not be reflected in the\n    geometry object.\n\n    Parameters\n    ----------\n    context :\n        a GeoJSON-like dict, which provides a \"type\" member describing the type\n        of the geometry and \"coordinates\" member providing a list of coordinates,\n        or an object which implements __geo_interface__.\n\n    Returns\n    -------\n    Geometry object\n\n    Examples\n    --------\n    Create a Point from GeoJSON, and then create a copy using __geo_interface__.\n\n    >>> context = {'type': 'Point', 'coordinates': [0, 1]}\n    >>> geom = shape(context)\n    >>> geom.geom_type == 'Point'\n    True\n    >>> geom.wkt\n    'POINT (0 1)'\n    >>> geom2 = shape(geom)\n    >>> geom == geom2\n    True\n    \"\"\"\n    if hasattr(context, '__geo_interface__'):\n        ob = context.__geo_interface__\n    else:\n        ob = context\n    geom_type = ob.get('type').lower()\n    if geom_type == 'feature':\n        ob = ob['geometry']\n        geom_type = ob.get('type').lower()\n    if 'coordinates' in ob and _is_coordinates_empty(ob['coordinates']):\n        return _empty_shape_for_no_coordinates(geom_type)\n    elif geom_type == 'point':\n        return Point(ob['coordinates'])\n    elif geom_type == 'linestring':\n        return LineString(ob['coordinates'])\n    elif geom_type == 'linearring':\n        return LinearRing(ob['coordinates'])\n    elif geom_type == 'polygon':\n        return Polygon(ob['coordinates'][0], ob['coordinates'][1:])\n    elif geom_type == 'multipoint':\n        return MultiPoint(ob['coordinates'])\n    elif geom_type == 'multilinestring':\n        return MultiLineString(ob['coordinates'])\n    elif geom_type == 'multipolygon':\n        return MultiPolygon([[c[0], c[1:]] for c in ob['coordinates']])\n    elif geom_type == 'geometrycollection':\n        geoms = [shape(g) for g in ob.get('geometries', [])]\n        return GeometryCollection(geoms)\n    else:\n        raise GeometryTypeError(f'Unknown geometry type: {geom_type!r}')"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "shared_paths", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef shared_paths(g1, g2): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef shared_paths(g1, g2):\n    \"\"\"Find paths shared between the two given lineal geometries\n\n    Returns a GeometryCollection with two elements:\n     - First element is a MultiLineString containing shared paths with the\n       same direction for both inputs.\n     - Second element is a MultiLineString containing shared paths with the\n       opposite direction for the two inputs.\n\n    Parameters\n    ----------\n    g1 : geometry\n        The first geometry\n    g2 : geometry\n        The second geometry\n    \"\"\"\n    if not isinstance(g1, LineString):\n        raise GeometryTypeError('First geometry must be a LineString')\n    if not isinstance(g2, LineString):\n        raise GeometryTypeError('Second geometry must be a LineString')\n    return shapely.shared_paths(g1, g2)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "skew", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef skew(geom, xs=0.0, ys=0.0, origin='center', use_radians=False): [MASK]\n", "response": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef skew(geom, xs=0.0, ys=0.0, origin='center', use_radians=False):\n    \"\"\"Returns a skewed geometry, sheared by angles along x and y dimensions.\n\n    The shear angle can be specified in either degrees (default) or radians\n    by setting ``use_radians=True``.\n\n    The point of origin can be a keyword 'center' for the bounding box\n    center (default), 'centroid' for the geometry's centroid, a Point object\n    or a coordinate tuple (x0, y0).\n\n    The general 2D affine transformation matrix for skewing is:\n\n        /   1    tan(xs) xoff \\\\\n        | tan(ys)  1     yoff |\n        \\\\   0      0       1  /\n\n    where the offsets are calculated from the origin Point(x0, y0):\n\n        xoff = -y0 * tan(xs)\n        yoff = -x0 * tan(ys)\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if not use_radians:\n        xs = xs * pi / 180.0\n        ys = ys * pi / 180.0\n    tanx = tan(xs)\n    tany = tan(ys)\n    if abs(tanx) < 2.5e-16:\n        tanx = 0.0\n    if abs(tany) < 2.5e-16:\n        tany = 0.0\n    x0, y0 = interpret_origin(geom, origin, 2)\n    matrix = (1.0, tanx, 0.0, tany, 1.0, 0.0, 0.0, 0.0, 1.0, -y0 * tanx, -\n        x0 * tany, 0.0)\n    return affine_transform(geom, matrix)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "rotate", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef rotate(geom, angle, origin='center', use_radians=False): [MASK]\n", "response": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef rotate(geom, angle, origin='center', use_radians=False):\n    \"\"\"Returns a rotated geometry on a 2D plane.\n\n    The angle of rotation can be specified in either degrees (default) or\n    radians by setting ``use_radians=True``. Positive angles are\n    counter-clockwise and negative are clockwise rotations.\n\n    The point of origin can be a keyword 'center' for the bounding box\n    center (default), 'centroid' for the geometry's centroid, a Point object\n    or a coordinate tuple (x0, y0).\n\n    The affine transformation matrix for 2D rotation is:\n\n      / cos(r) -sin(r) xoff \\\\\n      | sin(r)  cos(r) yoff |\n      \\\\   0       0      1  /\n\n    where the offsets are calculated from the origin Point(x0, y0):\n\n        xoff = x0 - x0 * cos(r) + y0 * sin(r)\n        yoff = y0 - x0 * sin(r) - y0 * cos(r)\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if not use_radians:\n        angle = angle * pi / 180.0\n    cosp = cos(angle)\n    sinp = sin(angle)\n    if abs(cosp) < 2.5e-16:\n        cosp = 0.0\n    if abs(sinp) < 2.5e-16:\n        sinp = 0.0\n    x0, y0 = interpret_origin(geom, origin, 2)\n    matrix = (cosp, -sinp, 0.0, sinp, cosp, 0.0, 0.0, 0.0, 1.0, x0 - x0 *\n        cosp + y0 * sinp, y0 - x0 * sinp - y0 * cosp, 0.0)\n    return affine_transform(geom, matrix)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "scale", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef scale(geom, xfact=1.0, yfact=1.0, zfact=1.0, origin='center'): [MASK]\n", "response": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef scale(geom, xfact=1.0, yfact=1.0, zfact=1.0, origin='center'):\n    \"\"\"Returns a scaled geometry, scaled by factors along each dimension.\n\n    The point of origin can be a keyword 'center' for the 2D bounding box\n    center (default), 'centroid' for the geometry's 2D centroid, a Point\n    object or a coordinate tuple (x0, y0, z0).\n\n    Negative scale factors will mirror or reflect coordinates.\n\n    The general 3D affine transformation matrix for scaling is:\n\n        / xfact  0    0   xoff \\\\\n        |   0  yfact  0   yoff |\n        |   0    0  zfact zoff |\n        \\\\   0    0    0     1  /\n\n    where the offsets are calculated from the origin Point(x0, y0, z0):\n\n        xoff = x0 - x0 * xfact\n        yoff = y0 - y0 * yfact\n        zoff = z0 - z0 * zfact\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    x0, y0, z0 = interpret_origin(geom, origin, 3)\n    matrix = (xfact, 0.0, 0.0, 0.0, yfact, 0.0, 0.0, 0.0, zfact, x0 - x0 *\n        xfact, y0 - y0 * yfact, z0 - z0 * zfact)\n    return affine_transform(geom, matrix)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "translate", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef translate(geom, xoff=0.0, yoff=0.0, zoff=0.0): [MASK]\n", "response": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef translate(geom, xoff=0.0, yoff=0.0, zoff=0.0):\n    \"\"\"Returns a translated geometry shifted by offsets along each dimension.\n\n    The general 3D affine transformation matrix for translation is:\n\n        / 1  0  0 xoff \\\\\n        | 0  1  0 yoff |\n        | 0  0  1 zoff |\n        \\\\ 0  0  0   1  /\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    matrix = 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, xoff, yoff, zoff\n    return affine_transform(geom, matrix)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "polylabel", "method_path": "../srcdata/Computation/shapely/shapely/algorithms/polylabel.py", "method_code_mask": "from heapq import heappop\nfrom heapq import heappush\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import Point\n\n\ndef polylabel(polygon, tolerance=1.0): [MASK]\n", "response": "from heapq import heappop\nfrom heapq import heappush\nfrom shapely.errors import TopologicalError\nfrom shapely.geometry import Point\ndef polylabel(polygon, tolerance=1.0):\n    \"\"\"Finds pole of inaccessibility for a given polygon. Based on\n    Vladimir Agafonkin's https://github.com/mapbox/polylabel\n\n    Parameters\n    ----------\n    polygon : shapely.geometry.Polygon\n    tolerance : int or float, optional\n                `tolerance` represents the highest resolution in units of the\n                input geometry that will be considered for a solution. (default\n                value is 1.0).\n\n    Returns\n    -------\n    shapely.geometry.Point\n        A point representing the pole of inaccessibility for the given input\n        polygon.\n\n    Raises\n    ------\n    shapely.errors.TopologicalError\n        If the input polygon is not a valid geometry.\n\n    Example\n    -------\n    >>> from shapely import LineString\n    >>> polygon = LineString([(0, 0), (50, 200), (100, 100), (20, 50),\n    ... (-100, -20), (-150, -200)]).buffer(100)\n    >>> polylabel(polygon, tolerance=10).wkt\n    'POINT (59.35615556364569 121.83919629746435)'\n    \"\"\"\n    if not polygon.is_valid:\n        raise TopologicalError('Invalid polygon')\n    minx, miny, maxx, maxy = polygon.bounds\n    width = maxx - minx\n    height = maxy - miny\n    cell_size = min(width, height)\n    h = cell_size / 2.0\n    cell_queue = []\n    x, y = polygon.centroid.coords[0]\n    best_cell = Cell(x, y, 0, polygon)\n    bbox_cell = Cell(minx + width / 2.0, miny + height / 2, 0, polygon)\n    if bbox_cell.distance > best_cell.distance:\n        best_cell = bbox_cell\n    x = minx\n    while x < maxx:\n        y = miny\n        while y < maxy:\n            heappush(cell_queue, Cell(x + h, y + h, h, polygon))\n            y += cell_size\n        x += cell_size\n    while cell_queue:\n        cell = heappop(cell_queue)\n        if cell.distance > best_cell.distance:\n            best_cell = cell\n        if cell.max_distance - best_cell.distance <= tolerance:\n            continue\n        h = cell.h / 2.0\n        heappush(cell_queue, Cell(cell.x - h, cell.y - h, h, polygon))\n        heappush(cell_queue, Cell(cell.x + h, cell.y - h, h, polygon))\n        heappush(cell_queue, Cell(cell.x - h, cell.y + h, h, polygon))\n        heappush(cell_queue, Cell(cell.x + h, cell.y + h, h, polygon))\n    return best_cell.centroid"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "plot_polygon", "method_path": "../srcdata/Computation/shapely/shapely/plotting.py", "method_code_mask": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\n\n\ndef plot_polygon(polygon, ax=None, add_points=True, color=None, facecolor=\n    None, edgecolor=None, linewidth=None, **kwargs): [MASK]\n", "response": "import numpy as np\nimport shapely\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.patches import PathPatch\nfrom matplotlib import colors\ndef plot_polygon(polygon, ax=None, add_points=True, color=None, facecolor=\n    None, edgecolor=None, linewidth=None, **kwargs):\n    \"\"\"\n    Plot a (Multi)Polygon.\n\n    Note: this function is experimental, and mainly targeting (interactive)\n    exploration, debugging and illustration purposes.\n\n    Parameters\n    ----------\n    polygon : shapely.Polygon or shapely.MultiPolygon\n    ax : matplotlib Axes, default None\n        The axes on which to draw the plot. If not specified, will get the\n        current active axes or create a new figure.\n    add_points : bool, default True\n        If True, also plot the coordinates (vertices) as points.\n    color : matplotlib color specification\n        Color for both the polygon fill (face) and boundary (edge). By default,\n        the fill is using an alpha of 0.3. You can specify `facecolor` and\n        `edgecolor` separately for greater control.\n    facecolor : matplotlib color specification\n        Color for the polygon fill.\n    edgecolor : matplotlib color specification\n        Color for the polygon boundary.\n    linewidth : float\n        The line width for the polygon boundary.\n    **kwargs\n        Additional keyword arguments passed to the matplotlib Patch.\n\n    Returns\n    -------\n    Matplotlib artist (PathPatch), if `add_points` is false.\n    A tuple of Matplotlib artists (PathPatch, Line2D), if `add_points` is true.\n    \"\"\"\n    from matplotlib import colors\n    if ax is None:\n        ax = _default_ax()\n    if color is None:\n        color = 'C0'\n    color = colors.to_rgba(color)\n    if facecolor is None:\n        facecolor = list(color)\n        facecolor[-1] = 0.3\n        facecolor = tuple(facecolor)\n    if edgecolor is None:\n        edgecolor = color\n    patch = patch_from_polygon(polygon, facecolor=facecolor, edgecolor=\n        edgecolor, linewidth=linewidth, **kwargs)\n    ax.add_patch(patch)\n    ax.autoscale_view()\n    if add_points:\n        line = plot_points(polygon, ax=ax, color=color)\n        return patch, line\n    return patch"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "affine_transform", "method_path": "../srcdata/Computation/shapely/shapely/affinity.py", "method_code_mask": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\n\n\ndef affine_transform(geom, matrix): [MASK]\n", "response": "from math import cos\nfrom math import pi\nfrom math import sin\nfrom math import tan\nimport numpy as np\nimport shapely\ndef affine_transform(geom, matrix):\n    \"\"\"Return a transformed geometry using an affine transformation matrix.\n\n    The coefficient matrix is provided as a list or tuple with 6 or 12 items\n    for 2D or 3D transformations, respectively.\n\n    For 2D affine transformations, the 6 parameter matrix is::\n\n        [a, b, d, e, xoff, yoff]\n\n    which represents the augmented matrix::\n\n        [x']   / a  b xoff \\\\ [x]\n        [y'] = | d  e yoff | [y]\n        [1 ]   \\\\ 0  0   1  / [1]\n\n    or the equations for the transformed coordinates::\n\n        x' = a * x + b * y + xoff\n        y' = d * x + e * y + yoff\n\n    For 3D affine transformations, the 12 parameter matrix is::\n\n        [a, b, c, d, e, f, g, h, i, xoff, yoff, zoff]\n\n    which represents the augmented matrix::\n\n        [x']   / a  b  c xoff \\\\ [x]\n        [y'] = | d  e  f yoff | [y]\n        [z']   | g  h  i zoff | [z]\n        [1 ]   \\\\ 0  0  0   1  / [1]\n\n    or the equations for the transformed coordinates::\n\n        x' = a * x + b * y + c * z + xoff\n        y' = d * x + e * y + f * z + yoff\n        z' = g * x + h * y + i * z + zoff\n    \"\"\"\n    if len(matrix) == 6:\n        ndim = 2\n        a, b, d, e, xoff, yoff = matrix\n        if geom.has_z:\n            ndim = 3\n            i = 1.0\n            c = f = g = h = zoff = 0.0\n    elif len(matrix) == 12:\n        ndim = 3\n        a, b, c, d, e, f, g, h, i, xoff, yoff, zoff = matrix\n        if not geom.has_z:\n            ndim = 2\n    else:\n        raise ValueError(\"'matrix' expects either 6 or 12 coefficients\")\n    if ndim == 2:\n        A = np.array([[a, b], [d, e]], dtype=float)\n        off = np.array([xoff, yoff], dtype=float)\n    else:\n        A = np.array([[a, b, c], [d, e, f], [g, h, i]], dtype=float)\n        off = np.array([xoff, yoff, zoff], dtype=float)\n\n    def _affine_coords(coords):\n        return np.matmul(A, coords.T).T + off\n    return shapely.transform(geom, _affine_coords, include_z=ndim == 3)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "orient", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef orient(geom, sign=1.0): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef orient(geom, sign=1.0):\n    \"\"\"A properly oriented copy of the given geometry.\n\n    The signed area of the result will have the given sign. A sign of\n    1.0 means that the coordinates of the product's exterior rings will\n    be oriented counter-clockwise.\n\n    Parameters\n    ----------\n    geom : Geometry\n        The original geometry. May be a Polygon, MultiPolygon, or\n        GeometryCollection.\n    sign : float, optional.\n        The sign of the result's signed area.\n\n    Returns\n    -------\n    Geometry\n\n    \"\"\"\n    if isinstance(geom, BaseMultipartGeometry):\n        return geom.__class__(list(map(lambda geom: orient(geom, sign),\n            geom.geoms)))\n    if isinstance(geom, (Polygon,)):\n        return orient_(geom, sign)\n    return geom"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "transform", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef transform(func, geom): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef transform(func, geom):\n    \"\"\"Applies `func` to all coordinates of `geom` and returns a new\n    geometry of the same type from the transformed coordinates.\n\n    `func` maps x, y, and optionally z to output xp, yp, zp. The input\n    parameters may iterable types like lists or arrays or single values.\n    The output shall be of the same type. Scalars in, scalars out.\n    Lists in, lists out.\n\n    For example, here is an identity function applicable to both types\n    of input.\n\n      def id_func(x, y, z=None):\n          return tuple(filter(None, [x, y, z]))\n\n      g2 = transform(id_func, g1)\n\n    Using pyproj >= 2.1, this example will accurately project Shapely geometries:\n\n      import pyproj\n\n      wgs84 = pyproj.CRS('EPSG:4326')\n      utm = pyproj.CRS('EPSG:32618')\n\n      project = pyproj.Transformer.from_crs(wgs84, utm, always_xy=True).transform\n\n      g2 = transform(project, g1)\n\n    Note that the always_xy kwarg is required here as Shapely geometries only support\n    X,Y coordinate ordering.\n\n    Lambda expressions such as the one in\n\n      g2 = transform(lambda x, y, z=None: (x+1.0, y+1.0), g1)\n\n    also satisfy the requirements for `func`.\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    if geom.geom_type in ('Point', 'LineString', 'LinearRing', 'Polygon'):\n        try:\n            if geom.geom_type in ('Point', 'LineString', 'LinearRing'):\n                return type(geom)(zip(*func(*zip(*geom.coords))))\n            elif geom.geom_type == 'Polygon':\n                shell = type(geom.exterior)(zip(*func(*zip(*geom.exterior.\n                    coords))))\n                holes = list(type(ring)(zip(*func(*zip(*ring.coords)))) for\n                    ring in geom.interiors)\n                return type(geom)(shell, holes)\n        except TypeError:\n            if geom.geom_type in ('Point', 'LineString', 'LinearRing'):\n                return type(geom)([func(*c) for c in geom.coords])\n            elif geom.geom_type == 'Polygon':\n                shell = type(geom.exterior)([func(*c) for c in geom.\n                    exterior.coords])\n                holes = list(type(ring)([func(*c) for c in ring.coords]) for\n                    ring in geom.interiors)\n                return type(geom)(shell, holes)\n    elif geom.geom_type.startswith('Multi'\n        ) or geom.geom_type == 'GeometryCollection':\n        return type(geom)([transform(func, part) for part in geom.geoms])\n    else:\n        raise GeometryTypeError(f'Type {geom.geom_type!r} not recognized')"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "ignore_invalid", "method_path": "../srcdata/Computation/shapely/shapely/tests/common.py", "method_code_mask": "import warnings\nfrom contextlib import contextmanager\nimport numpy as np\nimport pytest\nimport shapely\n\n\n@contextmanager\ndef ignore_invalid(condition=True): [MASK]\n", "response": "import warnings\nfrom contextlib import contextmanager\nimport numpy as np\nimport pytest\nimport shapely\n@contextmanager\ndef ignore_invalid(condition=True):\n    if condition:\n        with np.errstate(invalid='ignore'):\n            yield\n    else:\n        yield"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "equal_color", "method_path": "../srcdata/Computation/shapely/shapely/tests/test_plotting.py", "method_code_mask": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\n\n\ndef equal_color(actual, expected, alpha=None): [MASK]\n", "response": "import pytest\nfrom numpy.testing import assert_allclose\nfrom shapely import box\nfrom shapely import get_coordinates\nfrom shapely import LineString\nfrom shapely import MultiLineString\nfrom shapely import Point\nfrom shapely.plotting import patch_from_polygon\nfrom shapely.plotting import plot_line\nfrom shapely.plotting import plot_points\nfrom shapely.plotting import plot_polygon\nimport matplotlib.colors as colors\ndef equal_color(actual, expected, alpha=None):\n    import matplotlib.colors as colors\n    conv = colors.colorConverter\n    return actual == conv.to_rgba(expected, alpha=alpha)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "voronoi_diagram", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef voronoi_diagram(geom, envelope=None, tolerance=0.0, edges=False): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef voronoi_diagram(geom, envelope=None, tolerance=0.0, edges=False):\n    \"\"\"\n    Constructs a Voronoi Diagram [1] from the given geometry.\n    Returns a list of geometries.\n\n    Parameters\n    ----------\n    geom: geometry\n        the input geometry whose vertices will be used to calculate\n        the final diagram.\n    envelope: geometry, None\n        clipping envelope for the returned diagram, automatically\n        determined if None. The diagram will be clipped to the larger\n        of this envelope or an envelope surrounding the sites.\n    tolerance: float, 0.0\n        sets the snapping tolerance used to improve the robustness\n        of the computation. A tolerance of 0.0 specifies that no\n        snapping will take place.\n    edges: bool, False\n        If False, return regions as polygons. Else, return only\n        edges e.g. LineStrings.\n\n    GEOS documentation can be found at [2]\n\n    Returns\n    -------\n    GeometryCollection\n        geometries representing the Voronoi regions.\n\n    Notes\n    -----\n    The tolerance `argument` can be finicky and is known to cause the\n    algorithm to fail in several cases. If you're using `tolerance`\n    and getting a failure, try removing it. The test cases in\n    tests/test_voronoi_diagram.py show more details.\n\n\n    References\n    ----------\n    [1] https://en.wikipedia.org/wiki/Voronoi_diagram\n    [2] https://geos.osgeo.org/doxygen/geos__c_8h_source.html  (line 730)\n    \"\"\"\n    try:\n        result = shapely.voronoi_polygons(geom, tolerance=tolerance,\n            extend_to=envelope, only_edges=edges)\n    except shapely.GEOSException as err:\n        errstr = 'Could not create Voronoi Diagram with the specified inputs '\n        errstr += f'({err!s}).'\n        if tolerance:\n            errstr += ' Try running again with default tolerance value.'\n        raise ValueError(errstr) from err\n    if result.geom_type != 'GeometryCollection':\n        return GeometryCollection([result])\n    return result"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "dumps", "method_path": "../srcdata/Computation/shapely/shapely/wkt.py", "method_code_mask": "import shapely\n\n\ndef dumps(ob, trim=False, rounding_precision=-1, **kw): [MASK]\n", "response": "import shapely\ndef dumps(ob, trim=False, rounding_precision=-1, **kw):\n    \"\"\"\n    Dump a WKT representation of a geometry to a string.\n\n    Parameters\n    ----------\n    ob :\n        A geometry object of any type to be dumped to WKT.\n    trim : bool, default False\n        Remove excess decimals from the WKT.\n    rounding_precision : int, default -1\n        Round output to the specified number of digits.\n        Default behavior returns full precision.\n    **kw : kwargs, optional\n        Keyword output options passed to :func:`~shapely.to_wkt`.\n\n    Returns\n    -------\n    input geometry as WKT string\n    \"\"\"\n    return shapely.to_wkt(ob, trim=trim, rounding_precision=\n        rounding_precision, **kw)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "to_wkt", "method_path": "../srcdata/Computation/shapely/shapely/io.py", "method_code_mask": "import numpy as np\nfrom shapely import geos_version\nfrom shapely import lib\nfrom shapely._enum import ParamEnum\nfrom shapely._ragged_array import from_ragged_array\nfrom shapely._ragged_array import to_ragged_array\nfrom shapely.decorators import requires_geos\nfrom shapely.errors import UnsupportedGEOSVersionError\n\n\ndef to_wkt(geometry, rounding_precision=6, trim=True, output_dimension=None,\n    old_3d=False, **kwargs): [MASK]\n", "response": "import numpy as np\nfrom shapely import geos_version\nfrom shapely import lib\nfrom shapely._enum import ParamEnum\nfrom shapely._ragged_array import from_ragged_array\nfrom shapely._ragged_array import to_ragged_array\nfrom shapely.decorators import requires_geos\nfrom shapely.errors import UnsupportedGEOSVersionError\ndef to_wkt(geometry, rounding_precision=6, trim=True, output_dimension=None,\n    old_3d=False, **kwargs):\n    \"\"\"\n    Converts to the Well-Known Text (WKT) representation of a Geometry.\n\n    The Well-known Text format is defined in the `OGC Simple Features\n    Specification for SQL <https://www.opengeospatial.org/standards/sfs>`__.\n\n    The following limitations apply to WKT serialization:\n\n    - for GEOS <= 3.8 a multipoint with an empty sub-geometry will raise an exception\n    - for GEOS <= 3.8 empty geometries are always serialized to 2D\n    - for GEOS >= 3.9 only simple empty geometries can be 3D, collections are still\n      always 2D\n\n    Parameters\n    ----------\n    geometry : Geometry or array_like\n    rounding_precision : int, default 6\n        The rounding precision when writing the WKT string. Set to a value of\n        -1 to indicate the full precision.\n    trim : bool, default True\n        If True, trim unnecessary decimals (trailing zeros).\n    output_dimension : int, default None\n        The output dimension for the WKT string. Supported values are 2, 3 and\n        4 for GEOS 3.12+. Default None will automatically choose 3 or 4,\n        depending on the version of GEOS.\n        Specifying 3 means that up to 3 dimensions will be written but 2D\n        geometries will still be represented as 2D in the WKT string.\n    old_3d : bool, default False\n        Enable old style 3D/4D WKT generation. By default, new style 3D/4D WKT\n        (ie. \"POINT Z (10 20 30)\") is returned, but with ``old_3d=True``\n        the WKT will be formatted in the style \"POINT (10 20 30)\".\n    **kwargs\n        See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\n    Examples\n    --------\n    >>> from shapely import Point\n    >>> to_wkt(Point(0, 0))\n    'POINT (0 0)'\n    >>> to_wkt(Point(0, 0), rounding_precision=3, trim=False)\n    'POINT (0.000 0.000)'\n    >>> to_wkt(Point(0, 0), rounding_precision=-1, trim=False)\n    'POINT (0.0000000000000000 0.0000000000000000)'\n    >>> to_wkt(Point(1, 2, 3), trim=True)\n    'POINT Z (1 2 3)'\n    >>> to_wkt(Point(1, 2, 3), trim=True, output_dimension=2)\n    'POINT (1 2)'\n    >>> to_wkt(Point(1, 2, 3), trim=True, old_3d=True)\n    'POINT (1 2 3)'\n\n    Notes\n    -----\n    The defaults differ from the default of the GEOS library. To mimic this,\n    use::\n\n        to_wkt(geometry, rounding_precision=-1, trim=False, output_dimension=2)\n\n    \"\"\"\n    if not np.isscalar(rounding_precision):\n        raise TypeError('rounding_precision only accepts scalar values')\n    if not np.isscalar(trim):\n        raise TypeError('trim only accepts scalar values')\n    if output_dimension is None:\n        output_dimension = 3 if geos_version < (3, 12, 0) else 4\n    elif not np.isscalar(output_dimension):\n        raise TypeError('output_dimension only accepts scalar values')\n    if not np.isscalar(old_3d):\n        raise TypeError('old_3d only accepts scalar values')\n    return lib.to_wkt(geometry, np.intc(rounding_precision), np.bool_(trim),\n        np.intc(output_dimension), np.bool_(old_3d), **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "shapely", "full_method_name": "clip_by_rect", "method_path": "../srcdata/Computation/shapely/shapely/ops.py", "method_code_mask": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\n\n\ndef clip_by_rect(geom, xmin, ymin, xmax, ymax): [MASK]\n", "response": "from warnings import warn\nimport shapely\nfrom shapely.algorithms.polylabel import polylabel\nfrom shapely.errors import GeometryTypeError\nfrom shapely.errors import ShapelyDeprecationWarning\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LineString\nfrom shapely.geometry import MultiLineString\nfrom shapely.geometry import MultiPoint\nfrom shapely.geometry import Point\nfrom shapely.geometry import Polygon\nfrom shapely.geometry import shape\nfrom shapely.geometry.base import BaseGeometry\nfrom shapely.geometry.base import BaseMultipartGeometry\nfrom shapely.geometry.polygon import orient as orient_\nfrom shapely.prepared import prep\ndef clip_by_rect(geom, xmin, ymin, xmax, ymax):\n    \"\"\"Returns the portion of a geometry within a rectangle\n\n    The geometry is clipped in a fast but possibly dirty way. The output is\n    not guaranteed to be valid. No exceptions will be raised for topological\n    errors.\n\n    Parameters\n    ----------\n    geom : geometry\n        The geometry to be clipped\n    xmin : float\n        Minimum x value of the rectangle\n    ymin : float\n        Minimum y value of the rectangle\n    xmax : float\n        Maximum x value of the rectangle\n    ymax : float\n        Maximum y value of the rectangle\n\n    Notes\n    -----\n    New in 1.7.\n    \"\"\"\n    if geom.is_empty:\n        return geom\n    return shapely.clip_by_rect(geom, xmin, ymin, xmax, ymax)"}
