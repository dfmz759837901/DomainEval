{"result": "passed", "model_name": "std", "repository": "tensorflow", "full_method_name": "_get_object_count_by_type", "method_path": "../srcdata/AI_and_SE/tensorflow/tensorflow/python/framework/test_util.py", "method_code_mask": "import collections\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Sequence\nimport contextlib\nimport functools\nimport gc\nimport itertools\nimport math\nimport os\nimport random\nimport re\nimport tempfile\nimport threading\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom typing import Union\nfrom typing import Optional\nfrom typing import overload\nfrom typing import TypeVar\nimport unittest\nimport numpy as np\n\n\ndef _get_object_count_by_type(exclude: Iterable[Any]=()) ->collections.Counter[\n    str]: [MASK]\n", "response": "import collections\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Sequence\nimport contextlib\nimport functools\nimport gc\nimport itertools\nimport math\nimport os\nimport random\nimport re\nimport tempfile\nimport threading\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom typing import Union\nfrom typing import Optional\nfrom typing import overload\nfrom typing import TypeVar\nimport unittest\nimport numpy as np\ndef _get_object_count_by_type(exclude: Iterable[Any]=()) ->collections.Counter[\n    str]:\n    return collections.Counter([type(obj).__name__ for obj in gc.get_objects()]\n        ) - collections.Counter([type(obj).__name__ for obj in exclude])"}
{"result": "passed", "model_name": "std", "repository": "tensorflow", "full_method_name": "make_decorator", "method_path": "../srcdata/AI_and_SE/tensorflow/tensorflow/python/util/tf_decorator.py", "method_code_mask": "import inspect\nfrom typing import Dict\nfrom typing import Any\n\n\ndef make_decorator(target, decorator_func, decorator_name=None,\n    decorator_doc='', decorator_argspec=None): [MASK]\n", "response": "import inspect\nfrom typing import Dict\nfrom typing import Any\ndef make_decorator(target, decorator_func, decorator_name=None,\n    decorator_doc='', decorator_argspec=None):\n    \"\"\"Make a decorator from a wrapper and a target.\n\n  Args:\n    target: The final callable to be wrapped.\n    decorator_func: The wrapper function.\n    decorator_name: The name of the decorator. If `None`, the name of the\n      function calling make_decorator.\n    decorator_doc: Documentation specific to this application of\n      `decorator_func` to `target`.\n    decorator_argspec: Override the signature using FullArgSpec.\n\n  Returns:\n    The `decorator_func` argument with new metadata attached.\n  \"\"\"\n    if decorator_name is None:\n        decorator_name = inspect.currentframe().f_back.f_code.co_name\n    decorator = TFDecorator(decorator_name, target, decorator_doc,\n        decorator_argspec)\n    setattr(decorator_func, '_tf_decorator', decorator)\n    if hasattr(target, '__name__'):\n        decorator_func.__name__ = target.__name__\n    if hasattr(target, '__qualname__'):\n        decorator_func.__qualname__ = target.__qualname__\n    if hasattr(target, '__module__'):\n        decorator_func.__module__ = target.__module__\n    if hasattr(target, '__dict__'):\n        for name in target.__dict__:\n            if name not in decorator_func.__dict__:\n                decorator_func.__dict__[name] = target.__dict__[name]\n    if hasattr(target, '__doc__'):\n        decorator_func.__doc__ = decorator.__doc__\n    decorator_func.__wrapped__ = target\n    decorator_func.__original_wrapped__ = target\n    if decorator_argspec:\n        decorator_func.__signature__ = fullargspec_to_signature(\n            decorator_argspec)\n    elif callable(target):\n        try:\n            signature = inspect.signature(target)\n        except (TypeError, ValueError):\n            pass\n        else:\n            bound_instance = _get_bound_instance(target)\n            if bound_instance and 'self' in signature.parameters:\n                signature = inspect.Signature(list(signature.parameters.\n                    values())[1:])\n                decorator_func.__self__ = bound_instance\n            decorator_func.__signature__ = signature\n    return decorator_func"}
