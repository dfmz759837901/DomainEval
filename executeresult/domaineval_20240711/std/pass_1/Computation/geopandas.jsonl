{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "import_optional_dependency", "method_path": "../srcdata/Computation/geopandas/geopandas/_compat.py", "method_code_mask": "import importlib\nfrom packaging.version import Version\nimport pandas as pd\nimport shapely\nimport shapely.geos\nimport pyproj\n\n\ndef import_optional_dependency(name: str, extra: str=''): [MASK]\n", "response": "import importlib\nfrom packaging.version import Version\nimport pandas as pd\nimport shapely\nimport shapely.geos\nimport pyproj\ndef import_optional_dependency(name: str, extra: str=''):\n    \"\"\"\n    Import an optional dependency.\n\n    Adapted from pandas.compat._optional::import_optional_dependency\n\n    Raises a formatted ImportError if the module is not present.\n\n    Parameters\n    ----------\n    name : str\n        The module name.\n    extra : str\n        Additional text to include in the ImportError message.\n    Returns\n    -------\n    module\n    \"\"\"\n    msg = (\n        \"\"\"Missing optional dependency '{name}'. {extra}  \"\n        \"Use pip or conda to install {name}.\"\"\"\n        .format(name=name, extra=extra))\n    if not isinstance(name, str):\n        raise ValueError(\"Invalid module name: '{name}'; must be a string\".\n            format(name=name))\n    try:\n        module = importlib.import_module(name)\n    except ImportError:\n        raise ImportError(msg) from None\n    return module"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "pd14_compat_index", "method_path": "../srcdata/Computation/geopandas/geopandas/tests/test_pandas_methods.py", "method_code_mask": "import os\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nimport geopandas\nimport geopandas._compat as compat\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas.array import from_shapely\nimport pytest\nfrom geopandas.testing import assert_geodataframe_equal\nfrom geopandas.testing import assert_geoseries_equal\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_frame_equal\nfrom pandas.testing import assert_series_equal\n\n\ndef pd14_compat_index(index): [MASK]\n", "response": "import os\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nimport geopandas\nimport geopandas._compat as compat\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas.array import from_shapely\nimport pytest\nfrom geopandas.testing import assert_geodataframe_equal\nfrom geopandas.testing import assert_geoseries_equal\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_frame_equal\nfrom pandas.testing import assert_series_equal\ndef pd14_compat_index(index):\n    if compat.PANDAS_GE_14:\n        return from_shapely(index)\n    else:\n        return index"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "infer_schema", "method_path": "../srcdata/Computation/geopandas/geopandas/io/file.py", "method_code_mask": "from __future__ import annotations\nimport os\nimport urllib.request\nimport warnings\nfrom io import IOBase\nfrom packaging.version import Version\nfrom pathlib import Path\nfrom urllib.parse import urlparse as parse_url\nfrom urllib.parse import uses_netloc\nfrom urllib.parse import uses_params\nfrom urllib.parse import uses_relative\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.types import is_integer_dtype\nimport shapely\nfrom shapely.geometry import mapping\nfrom shapely.geometry.base import BaseGeometry\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas._compat import PANDAS_GE_20\nimport fiona\nfrom fiona import Env as fiona_env\nfrom fiona import drivers as fiona_env\nimport geopandas\nfrom pyproj import CRS\nfrom collections import OrderedDict\n\n\ndef infer_schema(df): [MASK]\n", "response": "from __future__ import annotations\nimport os\nimport urllib.request\nimport warnings\nfrom io import IOBase\nfrom packaging.version import Version\nfrom pathlib import Path\nfrom urllib.parse import urlparse as parse_url\nfrom urllib.parse import uses_netloc\nfrom urllib.parse import uses_params\nfrom urllib.parse import uses_relative\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.types import is_integer_dtype\nimport shapely\nfrom shapely.geometry import mapping\nfrom shapely.geometry.base import BaseGeometry\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas._compat import PANDAS_GE_20\nimport fiona\nfrom fiona import Env as fiona_env\nfrom fiona import drivers as fiona_env\nimport geopandas\nfrom pyproj import CRS\nfrom collections import OrderedDict\ndef infer_schema(df):\n    from collections import OrderedDict\n    types = {'Int32': 'int32', 'int32': 'int32', 'Int64': 'int', 'string':\n        'str', 'boolean': 'bool'}\n\n    def convert_type(column, in_type):\n        if in_type == object:\n            return 'str'\n        if in_type.name.startswith('datetime64'):\n            return 'datetime'\n        if str(in_type) in types:\n            out_type = types[str(in_type)]\n        else:\n            out_type = type(np.zeros(1, in_type).item()).__name__\n        if out_type == 'long':\n            out_type = 'int'\n        return out_type\n    properties = OrderedDict([(col, convert_type(col, _type)) for col,\n        _type in zip(df.columns, df.dtypes) if col != df._geometry_column_name]\n        )\n    if df.empty:\n        warnings.warn(\n            'You are attempting to write an empty DataFrame to file. For some drivers, this operation may fail.'\n            , UserWarning, stacklevel=3)\n    geom_types = _geometry_types(df)\n    schema = {'geometry': geom_types, 'properties': properties}\n    return schema"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_convert_bbox_to_parquet_filter", "method_path": "../srcdata/Computation/geopandas/geopandas/io/arrow.py", "method_code_mask": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\n\n\ndef _convert_bbox_to_parquet_filter(bbox, bbox_column_name): [MASK]\n", "response": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\ndef _convert_bbox_to_parquet_filter(bbox, bbox_column_name):\n    import pyarrow.compute as pc\n    return ~((pc.field((bbox_column_name, 'xmin')) > bbox[2]) | (pc.field((\n        bbox_column_name, 'ymin')) > bbox[3]) | (pc.field((bbox_column_name,\n        'xmax')) < bbox[0]) | (pc.field((bbox_column_name, 'ymax')) < bbox[1]))"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_decode_metadata", "method_path": "../srcdata/Computation/geopandas/geopandas/io/arrow.py", "method_code_mask": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\n\n\ndef _decode_metadata(metadata_str): [MASK]\n", "response": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\ndef _decode_metadata(metadata_str):\n    \"\"\"Decode a UTF-8 encoded JSON string to dict\n\n    Parameters\n    ----------\n    metadata_str : string (UTF-8 encoded)\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    if metadata_str is None:\n        return None\n    return json.loads(metadata_str.decode('utf-8'))"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_remove_id_from_member_of_ensembles", "method_path": "../srcdata/Computation/geopandas/geopandas/io/arrow.py", "method_code_mask": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\n\n\ndef _remove_id_from_member_of_ensembles(json_dict): [MASK]\n", "response": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\ndef _remove_id_from_member_of_ensembles(json_dict):\n    \"\"\"\n    Older PROJ versions will not recognize IDs of datum ensemble members that\n    were added in more recent PROJ database versions.\n\n    Cf https://github.com/opengeospatial/geoparquet/discussions/110\n    and https://github.com/OSGeo/PROJ/pull/3221\n\n    Mimicking the patch to GDAL from https://github.com/OSGeo/gdal/pull/5872\n    \"\"\"\n    for key, value in json_dict.items():\n        if isinstance(value, dict):\n            _remove_id_from_member_of_ensembles(value)\n        elif key == 'members' and isinstance(value, list):\n            for member in value:\n                member.pop('id', None)"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_get_filesystem_path", "method_path": "../srcdata/Computation/geopandas/geopandas/io/arrow.py", "method_code_mask": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\n\n\ndef _get_filesystem_path(path, filesystem=None, storage_options=None): [MASK]\n", "response": "import json\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nimport shapely\nimport geopandas\nfrom geopandas import GeoDataFrame\nfrom geopandas._compat import import_optional_dependency\nfrom geopandas.array import from_shapely\nfrom geopandas.array import from_wkb\nfrom pyarrow import StructArray\nimport pyarrow\nfrom pyarrow.fs import FileSystem\nfrom pyarrow import fs\nimport fsspec\nfrom pyarrow import parquet\nimport pyarrow.compute as pc\ndef _get_filesystem_path(path, filesystem=None, storage_options=None):\n    \"\"\"\n    Get the filesystem and path for a given filesystem and path.\n\n    If the filesystem is not None then it's just returned as is.\n    \"\"\"\n    import pyarrow\n    if isinstance(path, str\n        ) and storage_options is None and filesystem is None and Version(\n        pyarrow.__version__) >= Version('5.0.0'):\n        try:\n            from pyarrow.fs import FileSystem\n            filesystem, path = FileSystem.from_uri(path)\n        except Exception:\n            pass\n    if _is_fsspec_url(path) and filesystem is None:\n        fsspec = import_optional_dependency('fsspec', extra=\n            \"fsspec is requred for 'storage_options'.\")\n        filesystem, path = fsspec.core.url_to_fs(path, **storage_options or {})\n    if filesystem is None and storage_options:\n        raise ValueError(\n            \"Cannot provide 'storage_options' with non-fsspec path '{}'\".\n            format(path))\n    return filesystem, path"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_get_sys_info", "method_path": "../srcdata/Computation/geopandas/geopandas/tools/_show_versions.py", "method_code_mask": "import importlib\nimport platform\nimport sys\nimport pyproj\nfrom shapely import geos_version_string\nimport fiona\n\n\ndef _get_sys_info(): [MASK]\n", "response": "import importlib\nimport platform\nimport sys\nimport pyproj\nfrom shapely import geos_version_string\nimport fiona\ndef _get_sys_info():\n    \"\"\"System information\n\n    Returns\n    -------\n    sys_info : dict\n        system and Python version information\n    \"\"\"\n    python = sys.version.replace('\\n', ' ')\n    blob = [('python', python), ('executable', sys.executable), ('machine',\n        platform.platform())]\n    return dict(blob)"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_get_C_info", "method_path": "../srcdata/Computation/geopandas/geopandas/tools/_show_versions.py", "method_code_mask": "import importlib\nimport platform\nimport sys\nimport pyproj\nfrom shapely import geos_version_string\nimport fiona\n\n\ndef _get_C_info(): [MASK]\n", "response": "import importlib\nimport platform\nimport sys\nimport pyproj\nfrom shapely import geos_version_string\nimport fiona\ndef _get_C_info():\n    \"\"\"Information on system PROJ, GDAL, GEOS\n    Returns\n    -------\n    c_info: dict\n        system PROJ information\n    \"\"\"\n    try:\n        import pyproj\n        proj_version = pyproj.proj_version_str\n    except Exception:\n        proj_version = None\n    try:\n        import pyproj\n        proj_dir = pyproj.datadir.get_data_dir()\n    except Exception:\n        proj_dir = None\n    try:\n        import shapely._buildcfg\n        geos_version = '{}.{}.{}'.format(*shapely._buildcfg.geos_version)\n        geos_dir = shapely._buildcfg.geos_library_path\n    except Exception:\n        try:\n            from shapely import geos_version_string\n            geos_version = geos_version_string\n            geos_dir = None\n        except Exception:\n            geos_version = None\n            geos_dir = None\n    try:\n        import pyogrio\n        gdal_version = pyogrio.__gdal_version_string__\n        gdal_dir = pyogrio.get_gdal_data_path()\n    except Exception:\n        gdal_version = None\n        gdal_dir = None\n    if gdal_version is None:\n        try:\n            import fiona\n            gdal_version = fiona.env.get_gdal_release_name()\n        except Exception:\n            gdal_version = None\n        try:\n            import fiona\n            gdal_dir = fiona.env.GDALDataFinder().search()\n        except Exception:\n            gdal_dir = None\n    blob = [('GEOS', geos_version), ('GEOS lib', geos_dir), ('GDAL',\n        gdal_version), ('GDAL data dir', gdal_dir), ('PROJ', proj_version),\n        ('PROJ data dir', proj_dir)]\n    return dict(blob)"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "_PolygonPatch", "method_path": "../srcdata/Computation/geopandas/geopandas/plotting.py", "method_code_mask": "import warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nfrom pandas import CategoricalDtype\nfrom pandas.plotting import PlotAccessor\nimport geopandas\nfrom typing import Iterable\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.colors import Normalize\nfrom matplotlib.lines import Line2D\n\n\ndef _PolygonPatch(polygon, **kwargs): [MASK]\n", "response": "import warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nfrom pandas import CategoricalDtype\nfrom pandas.plotting import PlotAccessor\nimport geopandas\nfrom typing import Iterable\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.patches import PathPatch\nfrom matplotlib.path import Path\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.colors import Normalize\nfrom matplotlib.lines import Line2D\ndef _PolygonPatch(polygon, **kwargs):\n    \"\"\"Constructs a matplotlib patch from a Polygon geometry\n\n    The `kwargs` are those supported by the matplotlib.patches.PathPatch class\n    constructor. Returns an instance of matplotlib.patches.PathPatch.\n\n    Example (using Shapely Point and a matplotlib axes)::\n\n        b = shapely.geometry.Point(0, 0).buffer(1.0)\n        patch = _PolygonPatch(b, fc='blue', ec='blue', alpha=0.5)\n        ax.add_patch(patch)\n\n    GeoPandas originally relied on the descartes package by Sean Gillies\n    (BSD license, https://pypi.org/project/descartes) for PolygonPatch, but\n    this dependency was removed in favor of the below matplotlib code.\n    \"\"\"\n    from matplotlib.patches import PathPatch\n    from matplotlib.path import Path\n    path = Path.make_compound_path(Path(np.asarray(polygon.exterior.coords)\n        [:, :2]), *[Path(np.asarray(ring.coords)[:, :2]) for ring in\n        polygon.interiors])\n    return PathPatch(path, **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "sjoin_nearest", "method_path": "../srcdata/Computation/geopandas/geopandas/tools/sjoin.py", "method_code_mask": "import warnings\nfrom functools import partial\nfrom typing import Optional\nimport numpy as np\nimport pandas as pd\nfrom geopandas import GeoDataFrame\nfrom geopandas.array import _check_crs\nfrom geopandas.array import _crs_mismatch_warn\n\n\ndef sjoin_nearest(left_df: GeoDataFrame, right_df: GeoDataFrame, how: str=\n    'inner', max_distance: Optional[float]=None, lsuffix: str='left',\n    rsuffix: str='right', distance_col: Optional[str]=None, exclusive: bool\n    =False) ->GeoDataFrame: [MASK]\n", "response": "import warnings\nfrom functools import partial\nfrom typing import Optional\nimport numpy as np\nimport pandas as pd\nfrom geopandas import GeoDataFrame\nfrom geopandas.array import _check_crs\nfrom geopandas.array import _crs_mismatch_warn\ndef sjoin_nearest(left_df: GeoDataFrame, right_df: GeoDataFrame, how: str=\n    'inner', max_distance: Optional[float]=None, lsuffix: str='left',\n    rsuffix: str='right', distance_col: Optional[str]=None, exclusive: bool\n    =False) ->GeoDataFrame:\n    \"\"\"Spatial join of two GeoDataFrames based on the distance between their geometries.\n\n    Results will include multiple output records for a single input record\n    where there are multiple equidistant nearest or intersected neighbors.\n\n    Distance is calculated in CRS units and can be returned using the\n    `distance_col` parameter.\n\n    See the User Guide page\n    https://geopandas.readthedocs.io/en/latest/docs/user_guide/mergingdata.html\n    for more details.\n\n\n    Parameters\n    ----------\n    left_df, right_df : GeoDataFrames\n    how : string, default 'inner'\n        The type of join:\n\n        * 'left': use keys from left_df; retain only left_df geometry column\n        * 'right': use keys from right_df; retain only right_df geometry column\n        * 'inner': use intersection of keys from both dfs; retain only\n          left_df geometry column\n    max_distance : float, default None\n        Maximum distance within which to query for nearest geometry.\n        Must be greater than 0.\n        The max_distance used to search for nearest items in the tree may have a\n        significant impact on performance by reducing the number of input\n        geometries that are evaluated for nearest items in the tree.\n    lsuffix : string, default 'left'\n        Suffix to apply to overlapping column names (left GeoDataFrame).\n    rsuffix : string, default 'right'\n        Suffix to apply to overlapping column names (right GeoDataFrame).\n    distance_col : string, default None\n        If set, save the distances computed between matching geometries under a\n        column of this name in the joined GeoDataFrame.\n    exclusive : bool, default False\n        If True, the nearest geometries that are equal to the input geometry\n        will not be returned, default False.\n\n    Examples\n    --------\n    >>> import geodatasets\n    >>> groceries = geopandas.read_file(\n    ...     geodatasets.get_path(\"geoda.groceries\")\n    ... )\n    >>> chicago = geopandas.read_file(\n    ...     geodatasets.get_path(\"geoda.chicago_health\")\n    ... ).to_crs(groceries.crs)\n\n    >>> chicago.head()  # doctest: +SKIP\n       ComAreaID  ...                                           geometry\n    0         35  ...  POLYGON ((-87.60914 41.84469, -87.60915 41.844...\n    1         36  ...  POLYGON ((-87.59215 41.81693, -87.59231 41.816...\n    2         37  ...  POLYGON ((-87.62880 41.80189, -87.62879 41.801...\n    3         38  ...  POLYGON ((-87.60671 41.81681, -87.60670 41.816...\n    4         39  ...  POLYGON ((-87.59215 41.81693, -87.59215 41.816...\n    [5 rows x 87 columns]\n\n    >>> groceries.head()  # doctest: +SKIP\n       OBJECTID     Ycoord  ...  Category                           geometry\n    0        16  41.973266  ...       NaN  MULTIPOINT ((-87.65661 41.97321))\n    1        18  41.696367  ...       NaN  MULTIPOINT ((-87.68136 41.69713))\n    2        22  41.868634  ...       NaN  MULTIPOINT ((-87.63918 41.86847))\n    3        23  41.877590  ...       new  MULTIPOINT ((-87.65495 41.87783))\n    4        27  41.737696  ...       NaN  MULTIPOINT ((-87.62715 41.73623))\n    [5 rows x 8 columns]\n\n    >>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago)\n    >>> groceries_w_communities[[\"Chain\", \"community\", \"geometry\"]].head(2)\n                   Chain    community                                geometry\n    0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n    1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\n    To include the distances:\n\n    >>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n    >>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n                   Chain    community  distances\n    0     VIET HOA PLAZA       UPTOWN        0.0\n    1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\n    In the following example, we get multiple groceries for Uptown because all\n    results are equidistant (in this case zero because they intersect).\n    In fact, we get 4 results in total:\n\n    >>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n    >>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n    >>> uptown_results[[\"Chain\", \"community\"]]\n                Chain community\n    30  VIET HOA PLAZA    UPTOWN\n    30      JEWEL OSCO    UPTOWN\n    30          TARGET    UPTOWN\n    30       Mariano's    UPTOWN\n\n    See also\n    --------\n    sjoin : binary predicate joins\n    GeoDataFrame.sjoin_nearest : equivalent method\n\n    Notes\n    -----\n    Since this join relies on distances, results will be inaccurate\n    if your geometries are in a geographic CRS.\n\n    Every operation in GeoPandas is planar, i.e. the potential third\n    dimension is not taken into account.\n    \"\"\"\n    _basic_checks(left_df, right_df, how, lsuffix, rsuffix)\n    left_df.geometry.values.check_geographic_crs(stacklevel=1)\n    right_df.geometry.values.check_geographic_crs(stacklevel=1)\n    return_distance = distance_col is not None\n    indices, distances = _nearest_query(left_df, right_df, max_distance,\n        how, return_distance, exclusive)\n    joined, distances = _frame_join(left_df, right_df, indices, distances,\n        how, lsuffix, rsuffix, None)\n    if return_distance:\n        joined[distance_col] = distances\n    return joined"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "points_from_xy", "method_path": "../srcdata/Computation/geopandas/geopandas/array.py", "method_code_mask": "import inspect\nimport numbers\nimport operator\nimport warnings\nfrom functools import lru_cache\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.extensions import ExtensionArray\nfrom pandas.api.extensions import ExtensionDtype\nfrom pandas.api.extensions import register_extension_dtype\nimport shapely\nimport shapely.affinity\nimport shapely.geometry\nimport shapely.ops\nimport shapely.wkt\nfrom shapely.geometry.base import BaseGeometry\nfrom pyproj import Transformer\nfrom pyproj import CRS\nfrom pyproj.aoi import AreaOfInterest\nfrom pyproj.database import query_utm_crs_info\nfrom pandas.api.extensions import take\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import factorize\nfrom geopandas.tools.hilbert_curve import _hilbert_distance\nimport geopandas\n\n\ndef points_from_xy(x, y, z=None, crs=None): [MASK]\n", "response": "import inspect\nimport numbers\nimport operator\nimport warnings\nfrom functools import lru_cache\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.extensions import ExtensionArray\nfrom pandas.api.extensions import ExtensionDtype\nfrom pandas.api.extensions import register_extension_dtype\nimport shapely\nimport shapely.affinity\nimport shapely.geometry\nimport shapely.ops\nimport shapely.wkt\nfrom shapely.geometry.base import BaseGeometry\nfrom pyproj import Transformer\nfrom pyproj import CRS\nfrom pyproj.aoi import AreaOfInterest\nfrom pyproj.database import query_utm_crs_info\nfrom pandas.api.extensions import take\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import factorize\nfrom geopandas.tools.hilbert_curve import _hilbert_distance\nimport geopandas\ndef points_from_xy(x, y, z=None, crs=None):\n    \"\"\"\n    Generate GeometryArray of shapely Point geometries from x, y(, z) coordinates.\n\n    In case of geographic coordinates, it is assumed that longitude is captured by\n    ``x`` coordinates and latitude by ``y``.\n\n    Parameters\n    ----------\n    x, y, z : iterable\n    crs : value, optional\n        Coordinate Reference System of the geometry objects. Can be anything accepted by\n        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,\n        such as an authority string (eg \"EPSG:4326\") or a WKT string.\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> df = pd.DataFrame({'x': [0, 1, 2], 'y': [0, 1, 2], 'z': [0, 1, 2]})\n    >>> df\n       x  y  z\n    0  0  0  0\n    1  1  1  1\n    2  2  2  2\n    >>> geometry = geopandas.points_from_xy(x=[1, 0], y=[0, 1])\n    >>> geometry = geopandas.points_from_xy(df['x'], df['y'], df['z'])\n    >>> gdf = geopandas.GeoDataFrame(\n    ...     df, geometry=geopandas.points_from_xy(df['x'], df['y']))\n\n    Having geographic coordinates:\n\n    >>> df = pd.DataFrame({'longitude': [-140, 0, 123], 'latitude': [-65, 1, 48]})\n    >>> df\n       longitude  latitude\n    0       -140       -65\n    1          0         1\n    2        123        48\n    >>> geometry = geopandas.points_from_xy(df.longitude, df.latitude, crs=\"EPSG:4326\")\n\n    Returns\n    -------\n    output : GeometryArray\n    \"\"\"\n    x = np.asarray(x, dtype='float64')\n    y = np.asarray(y, dtype='float64')\n    if z is not None:\n        z = np.asarray(z, dtype='float64')\n    return GeometryArray(shapely.points(x, y, z), crs=crs)"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "df._repr_html_", "method_path": "../srcdata/Computation/geopandas/geopandas/tests/test_pandas_methods.py", "method_code_mask": "import os\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nimport geopandas\nimport geopandas._compat as compat\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas.array import from_shapely\nimport pytest\nfrom geopandas.testing import assert_geodataframe_equal\nfrom geopandas.testing import assert_geoseries_equal\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_frame_equal\nfrom pandas.testing import assert_series_equal\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "import os\nimport warnings\nfrom packaging.version import Version\nimport numpy as np\nimport pandas as pd\nimport shapely\nfrom shapely.geometry import GeometryCollection\nfrom shapely.geometry import LinearRing\nfrom shapely.geometry import LineString\nfrom shapely.geometry import Point\nimport geopandas\nimport geopandas._compat as compat\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom geopandas.array import from_shapely\nimport pytest\nfrom geopandas.testing import assert_geodataframe_equal\nfrom geopandas.testing import assert_geoseries_equal\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_frame_equal\nfrom pandas.testing import assert_series_equal\n@pytest.fixture\ndef df():\n    return GeoDataFrame({'geometry': [Point(x, x) for x in range(3)],\n        'value1': np.arange(3, dtype='int64'), 'value2': np.array([1, 2, 1],\n        dtype='int64')})"}
{"result": "passed", "model_name": "std", "repository": "geopandas", "full_method_name": "from_shapely", "method_path": "../srcdata/Computation/geopandas/geopandas/array.py", "method_code_mask": "import inspect\nimport numbers\nimport operator\nimport warnings\nfrom functools import lru_cache\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.extensions import ExtensionArray\nfrom pandas.api.extensions import ExtensionDtype\nfrom pandas.api.extensions import register_extension_dtype\nimport shapely\nimport shapely.affinity\nimport shapely.geometry\nimport shapely.ops\nimport shapely.wkt\nfrom shapely.geometry.base import BaseGeometry\nfrom pyproj import Transformer\nfrom pyproj import CRS\nfrom pyproj.aoi import AreaOfInterest\nfrom pyproj.database import query_utm_crs_info\nfrom pandas.api.extensions import take\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import factorize\nfrom geopandas.tools.hilbert_curve import _hilbert_distance\nimport geopandas\n\n\ndef from_shapely(data, crs=None): [MASK]\n", "response": "import inspect\nimport numbers\nimport operator\nimport warnings\nfrom functools import lru_cache\nimport numpy as np\nimport pandas as pd\nfrom pandas.api.extensions import ExtensionArray\nfrom pandas.api.extensions import ExtensionDtype\nfrom pandas.api.extensions import register_extension_dtype\nimport shapely\nimport shapely.affinity\nimport shapely.geometry\nimport shapely.ops\nimport shapely.wkt\nfrom shapely.geometry.base import BaseGeometry\nfrom pyproj import Transformer\nfrom pyproj import CRS\nfrom pyproj.aoi import AreaOfInterest\nfrom pyproj.database import query_utm_crs_info\nfrom pandas.api.extensions import take\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import factorize\nfrom geopandas.tools.hilbert_curve import _hilbert_distance\nimport geopandas\ndef from_shapely(data, crs=None):\n    \"\"\"\n    Convert a list or array of shapely objects to a GeometryArray.\n\n    Validates the elements.\n\n    Parameters\n    ----------\n    data : array-like\n        list or array of shapely objects\n    crs : value, optional\n        Coordinate Reference System of the geometry objects. Can be anything accepted by\n        :meth:`pyproj.CRS.from_user_input() <pyproj.crs.CRS.from_user_input>`,\n        such as an authority string (eg \"EPSG:4326\") or a WKT string.\n\n    \"\"\"\n    if not isinstance(data, np.ndarray):\n        arr = np.empty(len(data), dtype=object)\n        arr[:] = data\n    else:\n        arr = data\n    if not shapely.is_valid_input(arr).all():\n        out = []\n        for geom in data:\n            if isinstance(geom, BaseGeometry):\n                out.append(geom)\n            elif hasattr(geom, '__geo_interface__'):\n                geom = shapely.geometry.shape(geom)\n                out.append(geom)\n            elif isna(geom):\n                out.append(None)\n            else:\n                raise TypeError('Input must be valid geometry objects: {0}'\n                    .format(geom))\n        arr = np.array(out, dtype=object)\n    return GeometryArray(arr, crs=crs)"}
