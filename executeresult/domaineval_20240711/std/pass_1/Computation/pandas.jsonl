{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "to_time", "method_path": "../srcdata/Computation/pandas/pandas/core/tools/times.py", "method_code_mask": "from __future__ import annotations\nfrom datetime import datetime\nfrom datetime import time\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs.lib import is_list_like\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import notna\nfrom pandas._typing import DateTimeErrorChoices\n\n\ndef to_time(arg, format: (str | None)=None, infer_time_format: bool=False,\n    errors: DateTimeErrorChoices='raise'): [MASK]\n", "response": "from __future__ import annotations\nfrom datetime import datetime\nfrom datetime import time\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs.lib import is_list_like\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import notna\nfrom pandas._typing import DateTimeErrorChoices\ndef to_time(arg, format: (str | None)=None, infer_time_format: bool=False,\n    errors: DateTimeErrorChoices='raise'):\n    \"\"\"\n    Parse time strings to time objects using fixed strptime formats (\"%H:%M\",\n    \"%H%M\", \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n    \"%I%M%S%p\")\n\n    Use infer_time_format if all the strings are in the same format to speed\n    up conversion.\n\n    Parameters\n    ----------\n    arg : string in time format, datetime.time, list, tuple, 1-d array,  Series\n    format : str, default None\n        Format used to convert arg into a time object.  If None, fixed formats\n        are used.\n    infer_time_format: bool, default False\n        Infer the time format based on the first non-NaN element.  If all\n        strings are in the same format, this will speed up conversion.\n    errors : {'raise', 'coerce'}, default 'raise'\n        - If 'raise', then invalid parsing will raise an exception\n        - If 'coerce', then invalid parsing will be set as None\n\n    Returns\n    -------\n    datetime.time\n    \"\"\"\n    if errors not in ('raise', 'coerce'):\n        raise ValueError(\"errors must be one of 'raise', or 'coerce'.\")\n\n    def _convert_listlike(arg, format):\n        if isinstance(arg, (list, tuple)):\n            arg = np.array(arg, dtype='O')\n        elif getattr(arg, 'ndim', 1) > 1:\n            raise TypeError(\n                'arg must be a string, datetime, list, tuple, 1-d array, or Series'\n                )\n        arg = np.asarray(arg, dtype='O')\n        if infer_time_format and format is None:\n            format = _guess_time_format_for_array(arg)\n        times: list[time | None] = []\n        if format is not None:\n            for element in arg:\n                try:\n                    times.append(datetime.strptime(element, format).time())\n                except (ValueError, TypeError) as err:\n                    if errors == 'raise':\n                        msg = (\n                            f'Cannot convert {element} to a time with given format {format}'\n                            )\n                        raise ValueError(msg) from err\n                    times.append(None)\n        else:\n            formats = _time_formats[:]\n            format_found = False\n            for element in arg:\n                time_object = None\n                try:\n                    time_object = time.fromisoformat(element)\n                except (ValueError, TypeError):\n                    for time_format in formats:\n                        try:\n                            time_object = datetime.strptime(element,\n                                time_format).time()\n                            if not format_found:\n                                fmt = formats.pop(formats.index(time_format))\n                                formats.insert(0, fmt)\n                                format_found = True\n                            break\n                        except (ValueError, TypeError):\n                            continue\n                if time_object is not None:\n                    times.append(time_object)\n                elif errors == 'raise':\n                    raise ValueError(f'Cannot convert arg {arg} to a time')\n                else:\n                    times.append(None)\n        return times\n    if arg is None:\n        return arg\n    elif isinstance(arg, time):\n        return arg\n    elif isinstance(arg, ABCSeries):\n        values = _convert_listlike(arg._values, format)\n        return arg._constructor(values, index=arg.index, name=arg.name)\n    elif isinstance(arg, ABCIndex):\n        return _convert_listlike(arg, format)\n    elif is_list_like(arg):\n        return _convert_listlike(arg, format)\n    return _convert_listlike(np.array([arg]), format)[0]"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "standardize_mapping", "method_path": "../srcdata/Computation/pandas/pandas/core/common.py", "method_code_mask": "from __future__ import annotations\nimport builtins\nfrom collections import abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nimport contextlib\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat.numpy import np_version_gte1p24\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import iterable_not_string\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import NpDtype\nfrom pandas._typing import RandomState\nfrom pandas._typing import T\nfrom pandas import Index\n\n\ndef standardize_mapping(into): [MASK]\n", "response": "from __future__ import annotations\nimport builtins\nfrom collections import abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nimport contextlib\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat.numpy import np_version_gte1p24\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import iterable_not_string\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import NpDtype\nfrom pandas._typing import RandomState\nfrom pandas._typing import T\nfrom pandas import Index\ndef standardize_mapping(into):\n    \"\"\"\n    Helper function to standardize a supplied mapping.\n\n    Parameters\n    ----------\n    into : instance or subclass of collections.abc.Mapping\n        Must be a class, an initialized collections.defaultdict,\n        or an instance of a collections.abc.Mapping subclass.\n\n    Returns\n    -------\n    mapping : a collections.abc.Mapping subclass or other constructor\n        a callable object that can accept an iterator to create\n        the desired Mapping.\n\n    See Also\n    --------\n    DataFrame.to_dict\n    Series.to_dict\n    \"\"\"\n    if not inspect.isclass(into):\n        if isinstance(into, defaultdict):\n            return partial(defaultdict, into.default_factory)\n        into = type(into)\n    if not issubclass(into, abc.Mapping):\n        raise TypeError(f'unsupported type: {into}')\n    if into == defaultdict:\n        raise TypeError('to_dict() only accepts initialized defaultdicts')\n    return into"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_bool_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_bool_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_bool_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a boolean dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a boolean dtype.\n\n    Notes\n    -----\n    An ExtensionArray is considered boolean when the ``_is_boolean``\n    attribute is set to True.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_bool_dtype\n    >>> is_bool_dtype(str)\n    False\n    >>> is_bool_dtype(int)\n    False\n    >>> is_bool_dtype(bool)\n    True\n    >>> is_bool_dtype(np.bool_)\n    True\n    >>> is_bool_dtype(np.array([\"a\", \"b\"]))\n    False\n    >>> is_bool_dtype(pd.Series([1, 2]))\n    False\n    >>> is_bool_dtype(np.array([True, False]))\n    True\n    >>> is_bool_dtype(pd.Categorical([True, False]))\n    True\n    >>> is_bool_dtype(pd.arrays.SparseArray([True, False]))\n    True\n    \"\"\"\n    if arr_or_dtype is None:\n        return False\n    try:\n        dtype = _get_dtype(arr_or_dtype)\n    except (TypeError, ValueError):\n        return False\n    if isinstance(dtype, CategoricalDtype):\n        arr_or_dtype = dtype.categories\n    if isinstance(arr_or_dtype, ABCIndex):\n        if arr_or_dtype.inferred_type == 'boolean':\n            if not is_bool_dtype(arr_or_dtype.dtype):\n                warnings.warn(\n                    'The behavior of is_bool_dtype with an object-dtype Index of bool objects is deprecated. In a future version, this will return False. Cast the Index to a bool dtype instead.'\n                    , DeprecationWarning, stacklevel=2)\n            return True\n        return False\n    elif isinstance(dtype, ExtensionDtype):\n        return getattr(dtype, '_is_boolean', False)\n    return issubclass(dtype.type, np.bool_)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_hashable", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/inference.py", "method_code_mask": "from __future__ import annotations\nfrom collections import abc\nfrom numbers import Number\nimport re\nfrom re import Pattern\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs import lib\nfrom collections.abc import Hashable\nimport dataclasses\n\n\ndef is_hashable(obj: object) ->TypeGuard[Hashable]: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import abc\nfrom numbers import Number\nimport re\nfrom re import Pattern\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs import lib\nfrom collections.abc import Hashable\nimport dataclasses\ndef is_hashable(obj: object) ->TypeGuard[Hashable]:\n    \"\"\"\n    Return True if hash(obj) will succeed, False otherwise.\n\n    Some types will pass a test against collections.abc.Hashable but fail when\n    they are actually hashed with hash().\n\n    Distinguish between these and other types by trying the call to hash() and\n    seeing if they raise TypeError.\n\n    Returns\n    -------\n    bool\n\n    Examples\n    --------\n    >>> import collections\n    >>> from pandas.api.types import is_hashable\n    >>> a = ([],)\n    >>> isinstance(a, collections.abc.Hashable)\n    True\n    >>> is_hashable(a)\n    False\n    \"\"\"\n    try:\n        hash(obj)\n    except TypeError:\n        return False\n    else:\n        return True"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "isin", "method_path": "../srcdata/Computation/pandas/pandas/core/algorithms.py", "method_code_mask": "from __future__ import annotations\nimport decimal\nimport operator\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos\nfrom pandas._libs import hashtable as htable\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import TakeIndexer\nfrom pandas._typing import npt\nfrom pandas.util._decorators import doc\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.common import ensure_float64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_complex_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDatetimeArray\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.array_algos.take import take_nd\nfrom pandas.core.construction import array as pd_array\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import validate_indices\nfrom pandas import Categorical\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.reshape.tile import cut\nfrom pandas.core.internals.construction import to_arrays\nfrom pandas.core.sorting import lexsort_indexer\n\n\ndef isin(comps: ListLike, values: ListLike) ->npt.NDArray[np.bool_]: [MASK]\n", "response": "from __future__ import annotations\nimport decimal\nimport operator\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos\nfrom pandas._libs import hashtable as htable\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import TakeIndexer\nfrom pandas._typing import npt\nfrom pandas.util._decorators import doc\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.common import ensure_float64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_complex_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDatetimeArray\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.array_algos.take import take_nd\nfrom pandas.core.construction import array as pd_array\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import validate_indices\nfrom pandas import Categorical\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.reshape.tile import cut\nfrom pandas.core.internals.construction import to_arrays\nfrom pandas.core.sorting import lexsort_indexer\ndef isin(comps: ListLike, values: ListLike) ->npt.NDArray[np.bool_]:\n    \"\"\"\n    Compute the isin boolean array.\n\n    Parameters\n    ----------\n    comps : list-like\n    values : list-like\n\n    Returns\n    -------\n    ndarray[bool]\n        Same length as `comps`.\n    \"\"\"\n    if not is_list_like(comps):\n        raise TypeError(\n            f'only list-like objects are allowed to be passed to isin(), you passed a `{type(comps).__name__}`'\n            )\n    if not is_list_like(values):\n        raise TypeError(\n            f'only list-like objects are allowed to be passed to isin(), you passed a `{type(values).__name__}`'\n            )\n    if not isinstance(values, (ABCIndex, ABCSeries, ABCExtensionArray, np.\n        ndarray)):\n        orig_values = list(values)\n        values = _ensure_arraylike(orig_values, func_name='isin-targets')\n        if len(values\n            ) > 0 and values.dtype.kind in 'iufcb' and not is_signed_integer_dtype(\n            comps):\n            values = construct_1d_object_array_from_listlike(orig_values)\n    elif isinstance(values, ABCMultiIndex):\n        values = np.array(values)\n    else:\n        values = extract_array(values, extract_numpy=True, extract_range=True)\n    comps_array = _ensure_arraylike(comps, func_name='isin')\n    comps_array = extract_array(comps_array, extract_numpy=True)\n    if not isinstance(comps_array, np.ndarray):\n        return comps_array.isin(values)\n    elif needs_i8_conversion(comps_array.dtype):\n        return pd_array(comps_array).isin(values)\n    elif needs_i8_conversion(values.dtype) and not is_object_dtype(comps_array\n        .dtype):\n        return np.zeros(comps_array.shape, dtype=bool)\n    elif needs_i8_conversion(values.dtype):\n        return isin(comps_array, values.astype(object))\n    elif isinstance(values.dtype, ExtensionDtype):\n        return isin(np.asarray(comps_array), np.asarray(values))\n    if len(comps_array) > _MINIMUM_COMP_ARR_LEN and len(values\n        ) <= 26 and comps_array.dtype != object:\n        if isna(values).any():\n\n            def f(c, v):\n                return np.logical_or(np.isin(c, v).ravel(), np.isnan(c))\n        else:\n            f = lambda a, b: np.isin(a, b).ravel()\n    else:\n        common = np_find_common_type(values.dtype, comps_array.dtype)\n        values = values.astype(common, copy=False)\n        comps_array = comps_array.astype(common, copy=False)\n        f = htable.ismember\n    return f(comps_array, values)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "value_counts_internal", "method_path": "../srcdata/Computation/pandas/pandas/core/algorithms.py", "method_code_mask": "from __future__ import annotations\nimport decimal\nimport operator\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos\nfrom pandas._libs import hashtable as htable\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import TakeIndexer\nfrom pandas._typing import npt\nfrom pandas.util._decorators import doc\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.common import ensure_float64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_complex_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDatetimeArray\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.array_algos.take import take_nd\nfrom pandas.core.construction import array as pd_array\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import validate_indices\nfrom pandas import Categorical\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.reshape.tile import cut\nfrom pandas.core.internals.construction import to_arrays\nfrom pandas.core.sorting import lexsort_indexer\n\n\ndef value_counts_internal(values, sort: bool=True, ascending: bool=False,\n    normalize: bool=False, bins=None, dropna: bool=True) ->Series: [MASK]\n", "response": "from __future__ import annotations\nimport decimal\nimport operator\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos\nfrom pandas._libs import hashtable as htable\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import TakeIndexer\nfrom pandas._typing import npt\nfrom pandas.util._decorators import doc\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.common import ensure_float64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_complex_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDatetimeArray\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.array_algos.take import take_nd\nfrom pandas.core.construction import array as pd_array\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import validate_indices\nfrom pandas import Categorical\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.reshape.tile import cut\nfrom pandas.core.internals.construction import to_arrays\nfrom pandas.core.sorting import lexsort_indexer\ndef value_counts_internal(values, sort: bool=True, ascending: bool=False,\n    normalize: bool=False, bins=None, dropna: bool=True) ->Series:\n    from pandas import Index, Series\n    index_name = getattr(values, 'name', None)\n    name = 'proportion' if normalize else 'count'\n    if bins is not None:\n        from pandas.core.reshape.tile import cut\n        if isinstance(values, Series):\n            values = values._values\n        try:\n            ii = cut(values, bins, include_lowest=True)\n        except TypeError as err:\n            raise TypeError('bins argument only works with numeric data.'\n                ) from err\n        result = ii.value_counts(dropna=dropna)\n        result.name = name\n        result = result[result.index.notna()]\n        result.index = result.index.astype('interval')\n        result = result.sort_index()\n        if dropna and (result._values == 0).all():\n            result = result.iloc[0:0]\n        counts = np.array([len(ii)])\n    elif is_extension_array_dtype(values):\n        result = Series(values, copy=False)._values.value_counts(dropna=dropna)\n        result.name = name\n        result.index.name = index_name\n        counts = result._values\n        if not isinstance(counts, np.ndarray):\n            counts = np.asarray(counts)\n    elif isinstance(values, ABCMultiIndex):\n        levels = list(range(values.nlevels))\n        result = Series(index=values, name=name).groupby(level=levels,\n            dropna=dropna).size()\n        result.index.names = values.names\n        counts = result._values\n    else:\n        values = _ensure_arraylike(values, func_name='value_counts')\n        keys, counts, _ = value_counts_arraylike(values, dropna)\n        if keys.dtype == np.float16:\n            keys = keys.astype(np.float32)\n        idx = Index(keys, dtype=keys.dtype, name=index_name)\n        result = Series(counts, index=idx, name=name, copy=False)\n    if sort:\n        result = result.sort_values(ascending=ascending)\n    if normalize:\n        result = result / counts.sum()\n    return result"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_float_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_float_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_float_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether the provided array or dtype is of a float dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of a float dtype.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_float_dtype\n    >>> is_float_dtype(str)\n    False\n    >>> is_float_dtype(int)\n    False\n    >>> is_float_dtype(float)\n    True\n    >>> is_float_dtype(np.array([\"a\", \"b\"]))\n    False\n    >>> is_float_dtype(pd.Series([1, 2]))\n    False\n    >>> is_float_dtype(pd.Index([1, 2.0]))\n    True\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, classes(np.floating)) or _is_dtype(\n        arr_or_dtype, lambda typ: isinstance(typ, ExtensionDtype) and typ.\n        kind in 'f')"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_integer_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_integer_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_integer_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether the provided array or dtype is of an integer dtype.\n\n    Unlike in `is_any_int_dtype`, timedelta64 instances will return False.\n\n    The nullable Integer dtypes (e.g. pandas.Int64Dtype) are also considered\n    as integer by this function.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of an integer dtype and\n        not an instance of timedelta64.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_integer_dtype\n    >>> is_integer_dtype(str)\n    False\n    >>> is_integer_dtype(int)\n    True\n    >>> is_integer_dtype(float)\n    False\n    >>> is_integer_dtype(np.uint64)\n    True\n    >>> is_integer_dtype(\"int8\")\n    True\n    >>> is_integer_dtype(\"Int8\")\n    True\n    >>> is_integer_dtype(pd.Int8Dtype)\n    True\n    >>> is_integer_dtype(np.datetime64)\n    False\n    >>> is_integer_dtype(np.timedelta64)\n    False\n    >>> is_integer_dtype(np.array([\"a\", \"b\"]))\n    False\n    >>> is_integer_dtype(pd.Series([1, 2]))\n    True\n    >>> is_integer_dtype(np.array([], dtype=np.timedelta64))\n    False\n    >>> is_integer_dtype(pd.Index([1, 2.0]))  # float\n    False\n    \"\"\"\n    return _is_dtype_type(arr_or_dtype, _classes_and_not_datetimelike(np.\n        integer)) or _is_dtype(arr_or_dtype, lambda typ: isinstance(typ,\n        ExtensionDtype) and typ.kind in 'iu')"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_guess_datetime_format_for_array", "method_path": "../srcdata/Computation/pandas/pandas/core/tools/datetimes.py", "method_code_mask": "from __future__ import annotations\nfrom collections import abc\nfrom datetime import date\nfrom functools import partial\nfrom itertools import islice\nfrom typing import TYPE_CHECKING\nfrom typing import TypedDict\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import tslib\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import astype_overflowsafe\nfrom pandas._libs.tslibs import timezones as libtimezones\nfrom pandas._libs.tslibs.dtypes import NpyDatetimeUnit\nfrom pandas._libs.tslibs.parsing import DateParseError\nfrom pandas._libs.tslibs.parsing import guess_datetime_format\nfrom pandas._libs.tslibs.strptime import array_strptime\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DateTimeErrorChoices\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.arrays import DatetimeArray\nfrom pandas.arrays import IntegerArray\nfrom pandas.core.algorithms import unique\nfrom pandas.core.arrays import ArrowExtensionArray\nfrom pandas.core.arrays.base import ExtensionArray\nfrom pandas.core.arrays.datetimes import maybe_convert_dtype\nfrom pandas.core.arrays.datetimes import tz_to_dtype\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.datetimes import DatetimeIndex\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom pandas._libs.tslibs.nattype import NaTType\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import to_numeric\nfrom pandas import to_timedelta\n\n\ndef _guess_datetime_format_for_array(arr, dayfirst: (bool | None)=False) ->(str\n     | None): [MASK]\n", "response": "from __future__ import annotations\nfrom collections import abc\nfrom datetime import date\nfrom functools import partial\nfrom itertools import islice\nfrom typing import TYPE_CHECKING\nfrom typing import TypedDict\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import tslib\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import astype_overflowsafe\nfrom pandas._libs.tslibs import timezones as libtimezones\nfrom pandas._libs.tslibs.dtypes import NpyDatetimeUnit\nfrom pandas._libs.tslibs.parsing import DateParseError\nfrom pandas._libs.tslibs.parsing import guess_datetime_format\nfrom pandas._libs.tslibs.strptime import array_strptime\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DateTimeErrorChoices\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.arrays import DatetimeArray\nfrom pandas.arrays import IntegerArray\nfrom pandas.core.algorithms import unique\nfrom pandas.core.arrays import ArrowExtensionArray\nfrom pandas.core.arrays.base import ExtensionArray\nfrom pandas.core.arrays.datetimes import maybe_convert_dtype\nfrom pandas.core.arrays.datetimes import tz_to_dtype\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.datetimes import DatetimeIndex\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom pandas._libs.tslibs.nattype import NaTType\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import to_numeric\nfrom pandas import to_timedelta\ndef _guess_datetime_format_for_array(arr, dayfirst: (bool | None)=False) ->(str\n     | None):\n    if (first_non_null := tslib.first_non_null(arr)) != -1:\n        if type((first_non_nan_element := arr[first_non_null])) is str:\n            guessed_format = guess_datetime_format(first_non_nan_element,\n                dayfirst=dayfirst)\n            if guessed_format is not None:\n                return guessed_format\n            if tslib.first_non_null(arr[first_non_null + 1:]) != -1:\n                warnings.warn(\n                    'Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.'\n                    , UserWarning, stacklevel=find_stack_level())\n    return None"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_bool_indexer", "method_path": "../srcdata/Computation/pandas/pandas/core/common.py", "method_code_mask": "from __future__ import annotations\nimport builtins\nfrom collections import abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nimport contextlib\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat.numpy import np_version_gte1p24\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import iterable_not_string\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import NpDtype\nfrom pandas._typing import RandomState\nfrom pandas._typing import T\nfrom pandas import Index\n\n\ndef is_bool_indexer(key: Any) ->bool: [MASK]\n", "response": "from __future__ import annotations\nimport builtins\nfrom collections import abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Collection\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nimport contextlib\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat.numpy import np_version_gte1p24\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import iterable_not_string\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import NpDtype\nfrom pandas._typing import RandomState\nfrom pandas._typing import T\nfrom pandas import Index\ndef is_bool_indexer(key: Any) ->bool:\n    \"\"\"\n    Check whether `key` is a valid boolean indexer.\n\n    Parameters\n    ----------\n    key : Any\n        Only list-likes may be considered boolean indexers.\n        All other types are not considered a boolean indexer.\n        For array-like input, boolean ndarrays or ExtensionArrays\n        with ``_is_boolean`` set are considered boolean indexers.\n\n    Returns\n    -------\n    bool\n        Whether `key` is a valid boolean indexer.\n\n    Raises\n    ------\n    ValueError\n        When the array is an object-dtype ndarray or ExtensionArray\n        and contains missing values.\n\n    See Also\n    --------\n    check_array_indexer : Check that `key` is a valid array to index,\n        and convert to an ndarray.\n    \"\"\"\n    if isinstance(key, (ABCSeries, np.ndarray, ABCIndex, ABCExtensionArray)\n        ) and not isinstance(key, ABCMultiIndex):\n        if key.dtype == np.object_:\n            key_array = np.asarray(key)\n            if not lib.is_bool_array(key_array):\n                na_msg = (\n                    'Cannot mask with non-boolean array containing NA / NaN values'\n                    )\n                if lib.is_bool_array(key_array, skipna=True):\n                    raise ValueError(na_msg)\n                return False\n            return True\n        elif is_bool_dtype(key.dtype):\n            return True\n    elif isinstance(key, list):\n        if len(key) > 0:\n            if type(key) is not list:\n                key = list(key)\n            return lib.is_bool_list(key)\n    return False"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_timedelta64_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_timedelta64_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_timedelta64_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the timedelta64 dtype.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the timedelta64 dtype.\n\n    See Also\n    --------\n    api.types.is_timedelta64_ns_dtype : Check whether the provided array or dtype is\n        of the timedelta64[ns] dtype.\n    api.types.is_period_dtype : Check whether an array-like or dtype is of the\n        Period dtype.\n\n    Examples\n    --------\n    >>> from pandas.core.dtypes.common import is_timedelta64_dtype\n    >>> is_timedelta64_dtype(object)\n    False\n    >>> is_timedelta64_dtype(np.timedelta64)\n    True\n    >>> is_timedelta64_dtype([1, 2, 3])\n    False\n    >>> is_timedelta64_dtype(pd.Series([], dtype=\"timedelta64[ns]\"))\n    True\n    >>> is_timedelta64_dtype(\"0 days\")\n    False\n    \"\"\"\n    if isinstance(arr_or_dtype, np.dtype):\n        return arr_or_dtype.kind == 'm'\n    return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_string_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_string_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_string_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether the provided array or dtype is of the string dtype.\n\n    If an array is passed with an object dtype, the elements must be\n    inferred as strings.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array or dtype is of the string dtype.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_string_dtype\n    >>> is_string_dtype(str)\n    True\n    >>> is_string_dtype(object)\n    True\n    >>> is_string_dtype(int)\n    False\n    >>> is_string_dtype(np.array([\"a\", \"b\"]))\n    True\n    >>> is_string_dtype(pd.Series([1, 2]))\n    False\n    >>> is_string_dtype(pd.Series([1, 2], dtype=object))\n    False\n    \"\"\"\n    if hasattr(arr_or_dtype, 'dtype') and _get_dtype(arr_or_dtype).kind == 'O':\n        return is_all_strings(arr_or_dtype)\n\n    def condition(dtype) ->bool:\n        if is_string_or_object_np_dtype(dtype):\n            return True\n        try:\n            return dtype == 'string'\n        except TypeError:\n            return False\n    return _is_dtype(arr_or_dtype, condition)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "pandas_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef pandas_dtype(dtype) ->DtypeObj: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef pandas_dtype(dtype) ->DtypeObj:\n    \"\"\"\n    Convert input into a pandas only dtype object or a numpy dtype object.\n\n    Parameters\n    ----------\n    dtype : object to be converted\n\n    Returns\n    -------\n    np.dtype or a pandas dtype\n\n    Raises\n    ------\n    TypeError if not a dtype\n\n    Examples\n    --------\n    >>> pd.api.types.pandas_dtype(int)\n    dtype('int64')\n    \"\"\"\n    if isinstance(dtype, np.ndarray):\n        return dtype.dtype\n    elif isinstance(dtype, (np.dtype, ExtensionDtype)):\n        return dtype\n    result = registry.find(dtype)\n    if result is not None:\n        if isinstance(result, type):\n            warnings.warn(\n                f'Instantiating {result.__name__} without any arguments.Pass a {result.__name__} instance to silence this warning.'\n                , UserWarning, stacklevel=find_stack_level())\n            result = result()\n        return result\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('always', DeprecationWarning)\n            npdtype = np.dtype(dtype)\n    except SyntaxError as err:\n        raise TypeError(f\"data type '{dtype}' not understood\") from err\n    if is_hashable(dtype) and dtype in [object, np.object_, 'object', 'O',\n        'object_']:\n        return npdtype\n    elif npdtype.kind == 'O':\n        raise TypeError(f\"dtype '{dtype}' not understood\")\n    return npdtype"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_ensure_numeric", "method_path": "../srcdata/Computation/pandas/pandas/core/nanops.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import NaT\nfrom pandas._libs import NaTType\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import CorrelationMethod\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import F\nfrom pandas._typing import Scalar\nfrom pandas._typing import Shape\nfrom pandas._typing import npt\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom collections.abc import Callable\nfrom scipy.stats import kendalltau\nfrom scipy.stats import spearmanr\n\n\ndef _ensure_numeric(x): [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import NaT\nfrom pandas._libs import NaTType\nfrom pandas._libs import iNaT\nfrom pandas._libs import lib\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import CorrelationMethod\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import F\nfrom pandas._typing import Scalar\nfrom pandas._typing import Shape\nfrom pandas._typing import npt\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom collections.abc import Callable\nfrom scipy.stats import kendalltau\nfrom scipy.stats import spearmanr\ndef _ensure_numeric(x):\n    if isinstance(x, np.ndarray):\n        if x.dtype.kind in 'biu':\n            x = x.astype(np.float64)\n        elif x.dtype == object:\n            inferred = lib.infer_dtype(x)\n            if inferred in ['string', 'mixed']:\n                raise TypeError(f'Could not convert {x} to numeric')\n            try:\n                x = x.astype(np.complex128)\n            except (TypeError, ValueError):\n                try:\n                    x = x.astype(np.float64)\n                except ValueError as err:\n                    raise TypeError(f'Could not convert {x} to numeric'\n                        ) from err\n            else:\n                if not np.any(np.imag(x)):\n                    x = x.real\n    elif not (is_float(x) or is_integer(x) or is_complex(x)):\n        if isinstance(x, str):\n            raise TypeError(f\"Could not convert string '{x}' to numeric\")\n        try:\n            x = float(x)\n        except (TypeError, ValueError):\n            try:\n                x = complex(x)\n            except ValueError as err:\n                raise TypeError(f'Could not convert {x} to numeric') from err\n    return x"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "needs_i8_conversion", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef needs_i8_conversion(dtype: (DtypeObj | None)) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef needs_i8_conversion(dtype: (DtypeObj | None)) ->bool:\n    \"\"\"\n    Check whether the dtype should be converted to int64.\n\n    Dtype \"needs\" such a conversion if the dtype is of a datetime-like dtype\n\n    Parameters\n    ----------\n    dtype : np.dtype, ExtensionDtype, or None\n\n    Returns\n    -------\n    boolean\n        Whether or not the dtype should be converted to int64.\n\n    Examples\n    --------\n    >>> needs_i8_conversion(str)\n    False\n    >>> needs_i8_conversion(np.int64)\n    False\n    >>> needs_i8_conversion(np.datetime64)\n    False\n    >>> needs_i8_conversion(np.dtype(np.datetime64))\n    True\n    >>> needs_i8_conversion(np.array([\"a\", \"b\"]))\n    False\n    >>> needs_i8_conversion(pd.Series([1, 2]))\n    False\n    >>> needs_i8_conversion(pd.Series([], dtype=\"timedelta64[ns]\"))\n    False\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    False\n    >>> needs_i8_conversion(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\").dtype)\n    True\n    \"\"\"\n    if isinstance(dtype, np.dtype):\n        return dtype.kind in 'mM'\n    return isinstance(dtype, (PeriodDtype, DatetimeTZDtype))"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_numeric_v_string_like", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_numeric_v_string_like(a: ArrayLike, b) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_numeric_v_string_like(a: ArrayLike, b) ->bool:\n    \"\"\"\n    Check if we are comparing a string-like object to a numeric ndarray.\n    NumPy doesn't like to compare such objects, especially numeric arrays\n    and scalar string-likes.\n\n    Parameters\n    ----------\n    a : array-like, scalar\n        The first object to check.\n    b : array-like, scalar\n        The second object to check.\n\n    Returns\n    -------\n    boolean\n        Whether we return a comparing a string-like object to a numeric array.\n\n    Examples\n    --------\n    >>> is_numeric_v_string_like(np.array([1]), \"foo\")\n    True\n    >>> is_numeric_v_string_like(np.array([1, 2]), np.array([\"foo\"]))\n    True\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([1, 2]))\n    True\n    >>> is_numeric_v_string_like(np.array([1]), np.array([2]))\n    False\n    >>> is_numeric_v_string_like(np.array([\"foo\"]), np.array([\"foo\"]))\n    False\n    \"\"\"\n    is_a_array = isinstance(a, np.ndarray)\n    is_b_array = isinstance(b, np.ndarray)\n    is_a_numeric_array = is_a_array and a.dtype.kind in ('u', 'i', 'f', 'c',\n        'b')\n    is_b_numeric_array = is_b_array and b.dtype.kind in ('u', 'i', 'f', 'c',\n        'b')\n    is_a_string_array = is_a_array and a.dtype.kind in ('S', 'U')\n    is_b_string_array = is_b_array and b.dtype.kind in ('S', 'U')\n    is_b_scalar_string_like = not is_b_array and isinstance(b, str)\n    return (is_a_numeric_array and is_b_scalar_string_like or \n        is_a_numeric_array and is_b_string_array or is_b_numeric_array and\n        is_a_string_array)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_categorical_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_categorical_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_categorical_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Categorical dtype.\n\n    .. deprecated:: 2.2.0\n        Use isinstance(dtype, pd.CategoricalDtype) instead.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Categorical dtype.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_categorical_dtype\n    >>> from pandas import CategoricalDtype\n    >>> is_categorical_dtype(object)\n    False\n    >>> is_categorical_dtype(CategoricalDtype())\n    True\n    >>> is_categorical_dtype([1, 2, 3])\n    False\n    >>> is_categorical_dtype(pd.Categorical([1, 2, 3]))\n    True\n    >>> is_categorical_dtype(pd.CategoricalIndex([1, 2, 3]))\n    True\n    \"\"\"\n    warnings.warn(\n        'is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, pd.CategoricalDtype) instead'\n        , DeprecationWarning, stacklevel=2)\n    if isinstance(arr_or_dtype, ExtensionDtype):\n        return arr_or_dtype.name == 'category'\n    if arr_or_dtype is None:\n        return False\n    return CategoricalDtype.is_dtype(arr_or_dtype)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_period_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_period_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_period_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether an array-like or dtype is of the Period dtype.\n\n    .. deprecated:: 2.2.0\n        Use isinstance(dtype, pd.Period) instead.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of the Period dtype.\n\n    Examples\n    --------\n    >>> from pandas.core.dtypes.common import is_period_dtype\n    >>> is_period_dtype(object)\n    False\n    >>> is_period_dtype(pd.PeriodDtype(freq=\"D\"))\n    True\n    >>> is_period_dtype([1, 2, 3])\n    False\n    >>> is_period_dtype(pd.Period(\"2017-01-01\"))\n    False\n    >>> is_period_dtype(pd.PeriodIndex([], freq=\"Y\"))\n    True\n    \"\"\"\n    warnings.warn(\n        'is_period_dtype is deprecated and will be removed in a future version. Use `isinstance(dtype, pd.PeriodDtype)` instead'\n        , DeprecationWarning, stacklevel=2)\n    if isinstance(arr_or_dtype, ExtensionDtype):\n        return arr_or_dtype.type is Period\n    if arr_or_dtype is None:\n        return False\n    return PeriodDtype.is_dtype(arr_or_dtype)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "concat_compat", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/concat.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.core.dtypes.astype import astype_array\nfrom pandas.core.dtypes.cast import common_dtype_categorical_compat\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.generic import ABCCategoricalIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom collections.abc import Sequence\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas import Categorical\nfrom pandas.core.arrays.categorical import recode_for_categories\nfrom pandas.core.algorithms import take_nd\n\n\ndef concat_compat(to_concat: Sequence[ArrayLike], axis: AxisInt=0,\n    ea_compat_axis: bool=False) ->ArrayLike: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.core.dtypes.astype import astype_array\nfrom pandas.core.dtypes.cast import common_dtype_categorical_compat\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.cast import np_find_common_type\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.generic import ABCCategoricalIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom collections.abc import Sequence\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeObj\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas import Categorical\nfrom pandas.core.arrays.categorical import recode_for_categories\nfrom pandas.core.algorithms import take_nd\ndef concat_compat(to_concat: Sequence[ArrayLike], axis: AxisInt=0,\n    ea_compat_axis: bool=False) ->ArrayLike:\n    \"\"\"\n    provide concatenation of an array of arrays each of which is a single\n    'normalized' dtypes (in that for example, if it's object, then it is a\n    non-datetimelike and provide a combined dtype for the resulting array that\n    preserves the overall dtype if possible)\n\n    Parameters\n    ----------\n    to_concat : sequence of arrays\n    axis : axis to provide concatenation\n    ea_compat_axis : bool, default False\n        For ExtensionArray compat, behave as if axis == 1 when determining\n        whether to drop empty arrays.\n\n    Returns\n    -------\n    a single array, preserving the combined dtypes\n    \"\"\"\n    if len(to_concat) and lib.dtypes_all_equal([obj.dtype for obj in to_concat]\n        ):\n        obj = to_concat[0]\n        if isinstance(obj, np.ndarray):\n            to_concat_arrs = cast('Sequence[np.ndarray]', to_concat)\n            return np.concatenate(to_concat_arrs, axis=axis)\n        to_concat_eas = cast('Sequence[ExtensionArray]', to_concat)\n        if ea_compat_axis:\n            return obj._concat_same_type(to_concat_eas)\n        elif axis == 0:\n            return obj._concat_same_type(to_concat_eas)\n        else:\n            return obj._concat_same_type(to_concat_eas, axis=axis)\n    non_empties = [x for x in to_concat if _is_nonempty(x, axis)]\n    any_ea, kinds, target_dtype = _get_result_dtype(to_concat, non_empties)\n    if target_dtype is not None:\n        to_concat = [astype_array(arr, target_dtype, copy=False) for arr in\n            to_concat]\n    if not isinstance(to_concat[0], np.ndarray):\n        to_concat_eas = cast('Sequence[ExtensionArray]', to_concat)\n        cls = type(to_concat[0])\n        if ea_compat_axis or axis == 0:\n            return cls._concat_same_type(to_concat_eas)\n        else:\n            return cls._concat_same_type(to_concat_eas, axis=axis)\n    else:\n        to_concat_arrs = cast('Sequence[np.ndarray]', to_concat)\n        result = np.concatenate(to_concat_arrs, axis=axis)\n        if not any_ea and 'b' in kinds and result.dtype.kind in 'iuf':\n            result = result.astype(object, copy=False)\n    return result"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "validate_all_hashable", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef validate_all_hashable(*args, error_name: (str | None)=None) ->None: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef validate_all_hashable(*args, error_name: (str | None)=None) ->None:\n    \"\"\"\n    Return None if all args are hashable, else raise a TypeError.\n\n    Parameters\n    ----------\n    *args\n        Arguments to validate.\n    error_name : str, optional\n        The name to use if error\n\n    Raises\n    ------\n    TypeError : If an argument is not hashable\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if not all(is_hashable(arg) for arg in args):\n        if error_name:\n            raise TypeError(f'{error_name} must be a hashable type')\n        raise TypeError('All elements must be hashable')"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "maybe_mangle_lambdas", "method_path": "../srcdata/Computation/pandas/pandas/core/apply.py", "method_code_mask": "from __future__ import annotations\nimport abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nimport functools\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs.internals import BlockValuesRefs\nfrom pandas._typing import AggFuncType\nfrom pandas._typing import AggFuncTypeBase\nfrom pandas._typing import AggFuncTypeDict\nfrom pandas._typing import AggObjType\nfrom pandas._typing import Axis\nfrom pandas._typing import AxisInt\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import npt\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import SpecificationError\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.core.dtypes.cast import is_nested_object\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_sequence\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCNDFrame\nfrom pandas.core.dtypes.generic import ABCSeries\nimport pandas.core.common as com\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.util.numba_ import get_jit_arguments\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.groupby import GroupBy\nfrom pandas.core.resample import Resampler\nfrom pandas.core.window.rolling import BaseWindow\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.groupby.generic import DataFrameGroupBy\nfrom pandas.core.groupby.generic import SeriesGroupBy\nfrom pandas.core.indexes.base import Index\n\n\ndef maybe_mangle_lambdas(agg_spec: Any) ->Any: [MASK]\n", "response": "from __future__ import annotations\nimport abc\nfrom collections import defaultdict\nfrom collections.abc import Callable\nimport functools\nfrom functools import partial\nimport inspect\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs.internals import BlockValuesRefs\nfrom pandas._typing import AggFuncType\nfrom pandas._typing import AggFuncTypeBase\nfrom pandas._typing import AggFuncTypeDict\nfrom pandas._typing import AggObjType\nfrom pandas._typing import Axis\nfrom pandas._typing import AxisInt\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import npt\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import SpecificationError\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.core.dtypes.cast import is_nested_object\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_extension_array_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_sequence\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCNDFrame\nfrom pandas.core.dtypes.generic import ABCSeries\nimport pandas.core.common as com\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.util.numba_ import get_jit_arguments\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.groupby import GroupBy\nfrom pandas.core.resample import Resampler\nfrom pandas.core.window.rolling import BaseWindow\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.groupby.generic import DataFrameGroupBy\nfrom pandas.core.groupby.generic import SeriesGroupBy\nfrom pandas.core.indexes.base import Index\ndef maybe_mangle_lambdas(agg_spec: Any) ->Any:\n    \"\"\"\n    Make new lambdas with unique names.\n\n    Parameters\n    ----------\n    agg_spec : Any\n        An argument to GroupBy.agg.\n        Non-dict-like `agg_spec` are pass through as is.\n        For dict-like `agg_spec` a new spec is returned\n        with name-mangled lambdas.\n\n    Returns\n    -------\n    mangled : Any\n        Same type as the input.\n\n    Examples\n    --------\n    >>> maybe_mangle_lambdas(\"sum\")\n    'sum'\n    >>> maybe_mangle_lambdas([lambda: 1, lambda: 2])  # doctest: +SKIP\n    [<function __main__.<lambda_0>,\n     <function pandas...._make_lambda.<locals>.f(*args, **kwargs)>]\n    \"\"\"\n    is_dict = is_dict_like(agg_spec)\n    if not (is_dict or is_list_like(agg_spec)):\n        return agg_spec\n    mangled_aggspec = type(agg_spec)()\n    if is_dict:\n        for key, aggfuncs in agg_spec.items():\n            if is_list_like(aggfuncs) and not is_dict_like(aggfuncs):\n                mangled_aggfuncs = _managle_lambda_list(aggfuncs)\n            else:\n                mangled_aggfuncs = aggfuncs\n            mangled_aggspec[key] = mangled_aggfuncs\n    else:\n        mangled_aggspec = _managle_lambda_list(agg_spec)\n    return mangled_aggspec"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_valid_na_for_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/missing.py", "method_code_mask": "from __future__ import annotations\nfrom decimal import Decimal\nfrom typing import TYPE_CHECKING\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nimport pandas._libs.missing as libmissing\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import iNaT\nfrom pandas.core.dtypes.common import DT64NS_DTYPE\nfrom pandas.core.dtypes.common import TD64NS_DTYPE\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_or_object_np_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom re import Pattern\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Series\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.construction import sanitize_array\n\n\ndef is_valid_na_for_dtype(obj, dtype: DtypeObj) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom decimal import Decimal\nfrom typing import TYPE_CHECKING\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nimport pandas._libs.missing as libmissing\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import iNaT\nfrom pandas.core.dtypes.common import DT64NS_DTYPE\nfrom pandas.core.dtypes.common import TD64NS_DTYPE\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_or_object_np_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom re import Pattern\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Series\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.construction import sanitize_array\ndef is_valid_na_for_dtype(obj, dtype: DtypeObj) ->bool:\n    \"\"\"\n    isna check that excludes incompatible dtypes\n\n    Parameters\n    ----------\n    obj : object\n    dtype : np.datetime64, np.timedelta64, DatetimeTZDtype, or PeriodDtype\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if not lib.is_scalar(obj) or not isna(obj):\n        return False\n    elif dtype.kind == 'M':\n        if isinstance(dtype, np.dtype):\n            return not isinstance(obj, (np.timedelta64, Decimal))\n        return not isinstance(obj, (np.timedelta64, np.datetime64, Decimal))\n    elif dtype.kind == 'm':\n        return not isinstance(obj, (np.datetime64, Decimal))\n    elif dtype.kind in 'iufc':\n        return obj is not NaT and not isinstance(obj, (np.datetime64, np.\n            timedelta64))\n    elif dtype.kind == 'b':\n        return lib.is_float(obj) or obj is None or obj is libmissing.NA\n    elif dtype == _dtype_str:\n        return not isinstance(obj, (np.datetime64, np.timedelta64, Decimal,\n            float))\n    elif dtype == _dtype_object:\n        return True\n    elif isinstance(dtype, PeriodDtype):\n        return not isinstance(obj, (np.datetime64, np.timedelta64, Decimal))\n    elif isinstance(dtype, IntervalDtype):\n        return lib.is_float(obj) or obj is None or obj is libmissing.NA\n    elif isinstance(dtype, CategoricalDtype):\n        return is_valid_na_for_dtype(obj, dtype.categories.dtype)\n    return not isinstance(obj, (np.datetime64, np.timedelta64, Decimal))"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "can_hold_element", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/cast.py", "method_code_mask": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\n\n\ndef can_hold_element(arr: ArrayLike, element: Any) ->bool: [MASK]\n", "response": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\ndef can_hold_element(arr: ArrayLike, element: Any) ->bool:\n    \"\"\"\n    Can we do an inplace setitem with this element in an array with this dtype?\n\n    Parameters\n    ----------\n    arr : np.ndarray or ExtensionArray\n    element : Any\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    dtype = arr.dtype\n    if not isinstance(dtype, np.dtype) or dtype.kind in 'mM':\n        if isinstance(dtype, (PeriodDtype, IntervalDtype, DatetimeTZDtype,\n            np.dtype)):\n            arr = cast(\n                'PeriodArray | DatetimeArray | TimedeltaArray | IntervalArray',\n                arr)\n            try:\n                arr._validate_setitem_value(element)\n                return True\n            except (ValueError, TypeError):\n                return False\n        return True\n    try:\n        np_can_hold_element(dtype, element)\n        return True\n    except (TypeError, LossySetitemError):\n        return False"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "is_datetime64tz_dtype", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/common.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\n\n\ndef is_datetime64tz_dtype(arr_or_dtype) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import algos\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import conversion\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_complex\nfrom pandas.core.dtypes.inference import is_dataclass\nfrom pandas.core.dtypes.inference import is_decimal\nfrom pandas.core.dtypes.inference import is_dict_like\nfrom pandas.core.dtypes.inference import is_file_like\nfrom pandas.core.dtypes.inference import is_float\nfrom pandas.core.dtypes.inference import is_hashable\nfrom pandas.core.dtypes.inference import is_integer\nfrom pandas.core.dtypes.inference import is_iterator\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.inference import is_named_tuple\nfrom pandas.core.dtypes.inference import is_nested_list_like\nfrom pandas.core.dtypes.inference import is_number\nfrom pandas.core.dtypes.inference import is_re\nfrom pandas.core.dtypes.inference import is_re_compilable\nfrom pandas.core.dtypes.inference import is_scalar\nfrom pandas.core.dtypes.inference import is_sequence\nfrom collections.abc import Callable\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom scipy.sparse import issparse as _is_scipy_sparse\ndef is_datetime64tz_dtype(arr_or_dtype) ->bool:\n    \"\"\"\n    Check whether an array-like or dtype is of a DatetimeTZDtype dtype.\n\n    .. deprecated:: 2.1.0\n        Use isinstance(dtype, pd.DatetimeTZDtype) instead.\n\n    Parameters\n    ----------\n    arr_or_dtype : array-like or dtype\n        The array-like or dtype to check.\n\n    Returns\n    -------\n    boolean\n        Whether or not the array-like or dtype is of a DatetimeTZDtype dtype.\n\n    Examples\n    --------\n    >>> from pandas.api.types import is_datetime64tz_dtype\n    >>> is_datetime64tz_dtype(object)\n    False\n    >>> is_datetime64tz_dtype([1, 2, 3])\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3]))  # tz-naive\n    False\n    >>> is_datetime64tz_dtype(pd.DatetimeIndex([1, 2, 3], tz=\"US/Eastern\"))\n    True\n\n    >>> from pandas.core.dtypes.dtypes import DatetimeTZDtype\n    >>> dtype = DatetimeTZDtype(\"ns\", tz=\"US/Eastern\")\n    >>> s = pd.Series([], dtype=dtype)\n    >>> is_datetime64tz_dtype(dtype)\n    True\n    >>> is_datetime64tz_dtype(s)\n    True\n    \"\"\"\n    warnings.warn(\n        'is_datetime64tz_dtype is deprecated and will be removed in a future version. Check `isinstance(dtype, pd.DatetimeTZDtype)` instead.'\n        , DeprecationWarning, stacklevel=2)\n    if isinstance(arr_or_dtype, DatetimeTZDtype):\n        return True\n    if arr_or_dtype is None:\n        return False\n    return DatetimeTZDtype.is_dtype(arr_or_dtype)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "mgr.iget", "method_path": "../srcdata/Computation/pandas/pandas/tests/internals/test_internals.py", "method_code_mask": "from datetime import date\nfrom datetime import datetime\nimport itertools\nimport re\nimport numpy as np\nimport pytest\nfrom pandas._libs.internals import BlockPlacement\nfrom pandas.compat import IS64\nfrom pandas.core.dtypes.common import is_scalar\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import Series\nfrom pandas import Timedelta\nfrom pandas import Timestamp\nfrom pandas import period_range\nimport pandas._testing as tm\nimport pandas.core.algorithms as algos\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import SparseArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.internals import BlockManager\nfrom pandas.core.internals import SingleBlockManager\nfrom pandas.core.internals import make_block\nfrom pandas.core.internals.blocks import ensure_block_shape\nfrom pandas.core.internals.blocks import maybe_coerce_values\nfrom pandas.core.internals.blocks import new_block\n\n\n@pytest.fixture\ndef mgr(): [MASK]\n", "response": "from datetime import date\nfrom datetime import datetime\nimport itertools\nimport re\nimport numpy as np\nimport pytest\nfrom pandas._libs.internals import BlockPlacement\nfrom pandas.compat import IS64\nfrom pandas.core.dtypes.common import is_scalar\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import Series\nfrom pandas import Timedelta\nfrom pandas import Timestamp\nfrom pandas import period_range\nimport pandas._testing as tm\nimport pandas.core.algorithms as algos\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import SparseArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.internals import BlockManager\nfrom pandas.core.internals import SingleBlockManager\nfrom pandas.core.internals import make_block\nfrom pandas.core.internals.blocks import ensure_block_shape\nfrom pandas.core.internals.blocks import maybe_coerce_values\nfrom pandas.core.internals.blocks import new_block\n@pytest.fixture\ndef mgr():\n    return create_mgr(\n        'a: f8; b: object; c: f8; d: object; e: f8;f: bool; g: i8; h: complex; i: datetime-1; j: datetime-2;k: M8[ns, US/Eastern]; l: M8[ns, CET];'\n        )"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "f", "method_path": "../srcdata/Computation/pandas/pandas/tests/util/test_assert_produces_warning.py", "method_code_mask": "import warnings\nimport pytest\nfrom pandas.errors import DtypeWarning\nfrom pandas.errors import PerformanceWarning\nimport pandas._testing as tm\n\n\ndef f(): [MASK]\n", "response": "import warnings\nimport pytest\nfrom pandas.errors import DtypeWarning\nfrom pandas.errors import PerformanceWarning\nimport pandas._testing as tm\ndef f():\n    warnings.warn('f1', FutureWarning)\n    warnings.warn('f2', RuntimeWarning)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "construct_1d_object_array_from_listlike", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/cast.py", "method_code_mask": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\n\n\ndef construct_1d_object_array_from_listlike(values: Sized) ->np.ndarray: [MASK]\n", "response": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\ndef construct_1d_object_array_from_listlike(values: Sized) ->np.ndarray:\n    \"\"\"\n    Transform any list-like object in a 1-dimensional numpy array of object\n    dtype.\n\n    Parameters\n    ----------\n    values : any iterable which has a len()\n\n    Raises\n    ------\n    TypeError\n        * If `values` does not have a len()\n\n    Returns\n    -------\n    1-dimensional numpy array of dtype object\n    \"\"\"\n    result = np.empty(len(values), dtype='object')\n    result[:] = values\n    return result"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "construct_1d_arraylike_from_scalar", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/cast.py", "method_code_mask": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\n\n\ndef construct_1d_arraylike_from_scalar(value: Scalar, length: int, dtype: (\n    DtypeObj | None)) ->ArrayLike: [MASK]\n", "response": "from __future__ import annotations\nimport datetime as dt\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import Interval\nfrom pandas._libs import Period\nfrom pandas._libs import lib\nfrom pandas._libs.missing import NA\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.missing import checknull\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import OutOfBoundsDatetime\nfrom pandas._libs.tslibs import OutOfBoundsTimedelta\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs.timedeltas import array_to_timedelta64\nfrom pandas.errors import IntCastingNaNError\nfrom pandas.errors import LossySetitemError\nfrom pandas.core.dtypes.common import ensure_int8\nfrom pandas.core.dtypes.common import ensure_int16\nfrom pandas.core.dtypes.common import ensure_int32\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import ensure_str\nfrom pandas.core.dtypes.common import is_bool\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype as pandas_dtype_func\nfrom pandas.core.dtypes.dtypes import BaseMaskedDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PandasExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.io._util import _arrow_dtype_mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Sized\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NumpyIndexT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Index\nfrom pandas.core.arrays import Categorical\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.string_ import StringDtype\nfrom pandas.core.arrays.arrow.array import to_pyarrow_type\nimport pyarrow as pa\nfrom pandas.core.arrays.datetimes import DatetimeArray\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\ndef construct_1d_arraylike_from_scalar(value: Scalar, length: int, dtype: (\n    DtypeObj | None)) ->ArrayLike:\n    \"\"\"\n    create a np.ndarray / pandas type of specified shape and dtype\n    filled with values\n\n    Parameters\n    ----------\n    value : scalar value\n    length : int\n    dtype : pandas_dtype or np.dtype\n\n    Returns\n    -------\n    np.ndarray / pandas type of length, filled with value\n\n    \"\"\"\n    if dtype is None:\n        try:\n            dtype, value = infer_dtype_from_scalar(value)\n        except OutOfBoundsDatetime:\n            dtype = _dtype_obj\n    if isinstance(dtype, ExtensionDtype):\n        cls = dtype.construct_array_type()\n        seq = [] if length == 0 else [value]\n        return cls._from_sequence(seq, dtype=dtype).repeat(length)\n    if length and dtype.kind in 'iu' and isna(value):\n        dtype = np.dtype('float64')\n    elif lib.is_np_dtype(dtype, 'US'):\n        dtype = np.dtype('object')\n        if not isna(value):\n            value = ensure_str(value)\n    elif dtype.kind in 'mM':\n        value = _maybe_box_and_unbox_datetimelike(value, dtype)\n    subarr = np.empty(length, dtype=dtype)\n    if length:\n        subarr.fill(value)\n    return subarr"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "new_block", "method_path": "../srcdata/Computation/pandas/pandas/core/internals/blocks.py", "method_code_mask": "from __future__ import annotations\nimport inspect\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import final\nimport warnings\nimport weakref\nimport numpy as np\nfrom pandas._libs import NaT\nfrom pandas._libs import internals as libinternals\nfrom pandas._libs import lib\nfrom pandas._libs.internals import BlockPlacement\nfrom pandas._libs.internals import BlockValuesRefs\nfrom pandas._libs.missing import NA\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeBackend\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import FillnaOptions\nfrom pandas._typing import IgnoreRaise\nfrom pandas._typing import QuantileInterpolation\nfrom pandas._typing import Shape\nfrom pandas._typing import npt\nfrom pandas.errors import AbstractMethodError\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.util._validators import validate_bool_kwarg\nfrom pandas.core.dtypes.astype import astype_array_safe\nfrom pandas.core.dtypes.astype import astype_is_view\nfrom pandas.core.dtypes.cast import LossySetitemError\nfrom pandas.core.dtypes.cast import can_hold_element\nfrom pandas.core.dtypes.cast import convert_dtypes\nfrom pandas.core.dtypes.cast import find_result_type\nfrom pandas.core.dtypes.cast import np_can_hold_element\nfrom pandas.core.dtypes.common import is_1d_only_ea_dtype\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core import missing\nimport pandas.core.algorithms as algos\nfrom pandas.core.array_algos.putmask import extract_bool_array\nfrom pandas.core.array_algos.putmask import putmask_inplace\nfrom pandas.core.array_algos.putmask import putmask_without_repeat\nfrom pandas.core.array_algos.putmask import setitem_datetimelike_compat\nfrom pandas.core.array_algos.putmask import validate_putmask\nfrom pandas.core.array_algos.quantile import quantile_compat\nfrom pandas.core.array_algos.replace import compare_or_regex_search\nfrom pandas.core.array_algos.replace import replace_regex\nfrom pandas.core.array_algos.replace import should_use_regex\nfrom pandas.core.array_algos.transforms import shift\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.computation import expressions\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import check_setitem_lengths\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom pandas.core.api import Index\nfrom pandas.core.arrays._mixins import NDArrayBackedExtensionArray\n\n\ndef new_block(values, placement: BlockPlacement, *, ndim: int, refs: (\n    BlockValuesRefs | None)=None) ->Block: [MASK]\n", "response": "from __future__ import annotations\nimport inspect\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import final\nimport warnings\nimport weakref\nimport numpy as np\nfrom pandas._libs import NaT\nfrom pandas._libs import internals as libinternals\nfrom pandas._libs import lib\nfrom pandas._libs.internals import BlockPlacement\nfrom pandas._libs.internals import BlockValuesRefs\nfrom pandas._libs.missing import NA\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AxisInt\nfrom pandas._typing import DtypeBackend\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import FillnaOptions\nfrom pandas._typing import IgnoreRaise\nfrom pandas._typing import QuantileInterpolation\nfrom pandas._typing import Shape\nfrom pandas._typing import npt\nfrom pandas.errors import AbstractMethodError\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.util._validators import validate_bool_kwarg\nfrom pandas.core.dtypes.astype import astype_array_safe\nfrom pandas.core.dtypes.astype import astype_is_view\nfrom pandas.core.dtypes.cast import LossySetitemError\nfrom pandas.core.dtypes.cast import can_hold_element\nfrom pandas.core.dtypes.cast import convert_dtypes\nfrom pandas.core.dtypes.cast import find_result_type\nfrom pandas.core.dtypes.cast import np_can_hold_element\nfrom pandas.core.dtypes.common import is_1d_only_ea_dtype\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core import missing\nimport pandas.core.algorithms as algos\nfrom pandas.core.array_algos.putmask import extract_bool_array\nfrom pandas.core.array_algos.putmask import putmask_inplace\nfrom pandas.core.array_algos.putmask import putmask_without_repeat\nfrom pandas.core.array_algos.putmask import setitem_datetimelike_compat\nfrom pandas.core.array_algos.putmask import validate_putmask\nfrom pandas.core.array_algos.quantile import quantile_compat\nfrom pandas.core.array_algos.replace import compare_or_regex_search\nfrom pandas.core.array_algos.replace import replace_regex\nfrom pandas.core.array_algos.replace import should_use_regex\nfrom pandas.core.array_algos.transforms import shift\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import ExtensionArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.computation import expressions\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import check_setitem_lengths\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom pandas.core.api import Index\nfrom pandas.core.arrays._mixins import NDArrayBackedExtensionArray\ndef new_block(values, placement: BlockPlacement, *, ndim: int, refs: (\n    BlockValuesRefs | None)=None) ->Block:\n    klass = get_block_type(values.dtype)\n    return klass(values, ndim=ndim, placement=placement, refs=refs)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "length_of_indexer", "method_path": "../srcdata/Computation/pandas/pandas/core/indexers/utils.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.core.dtypes.common import is_array_like\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas._typing import AnyArrayLike\nfrom pandas.core.frame import DataFrame\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.construction import array as pd_array\n\n\ndef length_of_indexer(indexer, target=None) ->int: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.core.dtypes.common import is_array_like\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas._typing import AnyArrayLike\nfrom pandas.core.frame import DataFrame\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.construction import array as pd_array\ndef length_of_indexer(indexer, target=None) ->int:\n    \"\"\"\n    Return the expected length of target[indexer]\n\n    Returns\n    -------\n    int\n    \"\"\"\n    if target is not None and isinstance(indexer, slice):\n        target_len = len(target)\n        start = indexer.start\n        stop = indexer.stop\n        step = indexer.step\n        if start is None:\n            start = 0\n        elif start < 0:\n            start += target_len\n        if stop is None or stop > target_len:\n            stop = target_len\n        elif stop < 0:\n            stop += target_len\n        if step is None:\n            step = 1\n        elif step < 0:\n            start, stop = stop + 1, start + 1\n            step = -step\n        return (stop - start + step - 1) // step\n    elif isinstance(indexer, (ABCSeries, ABCIndex, np.ndarray, list)):\n        if isinstance(indexer, list):\n            indexer = np.array(indexer)\n        if indexer.dtype == bool:\n            return indexer.sum()\n        return len(indexer)\n    elif isinstance(indexer, range):\n        return (indexer.stop - indexer.start) // indexer.step\n    elif not is_list_like_indexer(indexer):\n        return 1\n    raise AssertionError('cannot find the length of the indexer')"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "set_locale", "method_path": "../srcdata/Computation/pandas/pandas/_config/localization.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport locale\nimport platform\nimport re\nimport subprocess\nfrom typing import TYPE_CHECKING\nfrom typing import cast\nfrom pandas._config.config import options\nfrom collections.abc import Generator\n\n\n@contextmanager\ndef set_locale(new_locale: (str | tuple[str, str]), lc_var: int=locale.LC_ALL\n    ) ->Generator[str | tuple[str, str], None, None]: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport locale\nimport platform\nimport re\nimport subprocess\nfrom typing import TYPE_CHECKING\nfrom typing import cast\nfrom pandas._config.config import options\nfrom collections.abc import Generator\n@contextmanager\ndef set_locale(new_locale: (str | tuple[str, str]), lc_var: int=locale.LC_ALL\n    ) ->Generator[str | tuple[str, str], None, None]:\n    \"\"\"\n    Context manager for temporarily setting a locale.\n\n    Parameters\n    ----------\n    new_locale : str or tuple\n        A string of the form <language_country>.<encoding>. For example to set\n        the current locale to US English with a UTF8 encoding, you would pass\n        \"en_US.UTF-8\".\n    lc_var : int, default `locale.LC_ALL`\n        The category of the locale being set.\n\n    Notes\n    -----\n    This is useful when you want to run a particular block of code under a\n    particular locale, without globally setting the locale. This probably isn't\n    thread-safe.\n    \"\"\"\n    current_locale = locale.setlocale(lc_var)\n    try:\n        locale.setlocale(lc_var, new_locale)\n        normalized_code, normalized_encoding = locale.getlocale()\n        if normalized_code is not None and normalized_encoding is not None:\n            yield f'{normalized_code}.{normalized_encoding}'\n        else:\n            yield new_locale\n    finally:\n        locale.setlocale(lc_var, current_locale)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "reset_option", "method_path": "../srcdata/Computation/pandas/pandas/_config/config.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\n\n\ndef reset_option(pat: str) ->None: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\ndef reset_option(pat: str) ->None:\n    \"\"\"\n    Reset one or more options to their default value.\n\n    Parameters\n    ----------\n    pat : str/regex\n        If specified only options matching ``pat*`` will be reset.\n        Pass ``\"all\"`` as argument to reset all options.\n\n        .. warning::\n\n            Partial matches are supported for convenience, but unless you\n            use the full option name (e.g. x.y.z.option_name), your code may break\n            in future versions if new options with similar names are introduced.\n\n    Returns\n    -------\n    None\n        No return value.\n\n    See Also\n    --------\n    get_option : Retrieve the value of the specified option.\n    set_option : Set the value of the specified option or options.\n    describe_option : Print the description for one or more registered options.\n\n    Notes\n    -----\n    For all available options, please view the\n    :ref:`User Guide <options.available>`.\n\n    Examples\n    --------\n    >>> pd.reset_option(\"display.max_columns\")  # doctest: +SKIP\n    \"\"\"\n    keys = _select_options(pat)\n    if len(keys) == 0:\n        raise OptionError(f'No such keys(s) for pat={pat!r}')\n    if len(keys) > 1 and len(pat) < 4 and pat != 'all':\n        raise ValueError(\n            'You must specify at least 4 characters when resetting multiple keys, use the special keyword \"all\" to reset all the options to their default value'\n            )\n    for k in keys:\n        set_option(k, _registered_options[k].defval)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "get_datevalue", "method_path": "../srcdata/Computation/pandas/pandas/plotting/_matplotlib/converter.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime as pydt\nfrom datetime import datetime\nfrom datetime import tzinfo\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport matplotlib as mpl\nimport matplotlib.dates as mdates\nimport matplotlib.units as munits\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs.dtypes import FreqGroup\nfrom pandas._libs.tslibs.dtypes import periods_per_day\nfrom pandas._typing import F\nfrom pandas._typing import npt\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_nested_list_like\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import get_option\nimport pandas.core.common as com\nfrom pandas.core.indexes.datetimes import date_range\nfrom pandas.core.indexes.period import Period\nfrom pandas.core.indexes.period import PeriodIndex\nfrom pandas.core.indexes.period import period_range\nimport pandas.core.tools.datetimes as tools\nfrom collections.abc import Generator\nfrom matplotlib.axis import Axis\nfrom pandas._libs.tslibs.offsets import BaseOffset\n\n\ndef get_datevalue(date, freq): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime as pydt\nfrom datetime import datetime\nfrom datetime import tzinfo\nimport functools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport matplotlib as mpl\nimport matplotlib.dates as mdates\nimport matplotlib.units as munits\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs.dtypes import FreqGroup\nfrom pandas._libs.tslibs.dtypes import periods_per_day\nfrom pandas._typing import F\nfrom pandas._typing import npt\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_float_dtype\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_nested_list_like\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas import get_option\nimport pandas.core.common as com\nfrom pandas.core.indexes.datetimes import date_range\nfrom pandas.core.indexes.period import Period\nfrom pandas.core.indexes.period import PeriodIndex\nfrom pandas.core.indexes.period import period_range\nimport pandas.core.tools.datetimes as tools\nfrom collections.abc import Generator\nfrom matplotlib.axis import Axis\nfrom pandas._libs.tslibs.offsets import BaseOffset\ndef get_datevalue(date, freq):\n    if isinstance(date, Period):\n        return date.asfreq(freq).ordinal\n    elif isinstance(date, (str, datetime, pydt.date, pydt.time, np.datetime64)\n        ):\n        return Period(date, freq).ordinal\n    elif is_integer(date) or is_float(date) or isinstance(date, (np.ndarray,\n        Index)) and date.size == 1:\n        return date\n    elif date is None:\n        return None\n    raise ValueError(f\"Unrecognizable date '{date}'\")"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.copy", "method_path": "../srcdata/Computation/pandas/pandas/tests/indexing/test_categorical.py", "method_code_mask": "import re\nimport numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalDtype\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Interval\nfrom pandas import Series\nfrom pandas import Timedelta\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "import re\nimport numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalDtype\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Interval\nfrom pandas import Series\nfrom pandas import Timedelta\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\n@pytest.fixture\ndef df():\n    return DataFrame({'A': np.arange(6, dtype='int64')}, index=\n        CategoricalIndex(list('aabbca'), dtype=CategoricalDtype(list('cab')\n        ), name='B'))"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "pprint_thing", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/printing.py", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nimport sys\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import Union\nfrom unicodedata import east_asian_width\nfrom pandas._config import get_option\nfrom pandas.core.dtypes.inference import is_sequence\nfrom pandas.io.formats.console import get_console_size\nfrom IPython import get_ipython\nfrom IPython.core.formatters import BaseFormatter\nfrom traitlets import ObjectName\n\n\ndef pprint_thing(thing: object, _nest_lvl: int=0, escape_chars: (\n    EscapeChars | None)=None, default_escapes: bool=False, quote_strings:\n    bool=False, max_seq_items: (int | None)=None) ->str: [MASK]\n", "response": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nimport sys\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\nfrom typing import Union\nfrom unicodedata import east_asian_width\nfrom pandas._config import get_option\nfrom pandas.core.dtypes.inference import is_sequence\nfrom pandas.io.formats.console import get_console_size\nfrom IPython import get_ipython\nfrom IPython.core.formatters import BaseFormatter\nfrom traitlets import ObjectName\ndef pprint_thing(thing: object, _nest_lvl: int=0, escape_chars: (\n    EscapeChars | None)=None, default_escapes: bool=False, quote_strings:\n    bool=False, max_seq_items: (int | None)=None) ->str:\n    \"\"\"\n    This function is the sanctioned way of converting objects\n    to a string representation and properly handles nested sequences.\n\n    Parameters\n    ----------\n    thing : anything to be formatted\n    _nest_lvl : internal use only. pprint_thing() is mutually-recursive\n        with pprint_sequence, this argument is used to keep track of the\n        current nesting level, and limit it.\n    escape_chars : list[str] or Mapping[str, str], optional\n        Characters to escape. If a Mapping is passed the values are the\n        replacements\n    default_escapes : bool, default False\n        Whether the input escape characters replaces or adds to the defaults\n    max_seq_items : int or None, default None\n        Pass through to other pretty printers to limit sequence printing\n\n    Returns\n    -------\n    str\n    \"\"\"\n\n    def as_escaped_string(thing: Any, escape_chars: (EscapeChars | None)=\n        escape_chars) ->str:\n        translate = {'\\t': '\\\\t', '\\n': '\\\\n', '\\r': '\\\\r'}\n        if isinstance(escape_chars, Mapping):\n            if default_escapes:\n                translate.update(escape_chars)\n            else:\n                translate = escape_chars\n            escape_chars = list(escape_chars.keys())\n        else:\n            escape_chars = escape_chars or ()\n        result = str(thing)\n        for c in escape_chars:\n            result = result.replace(c, translate[c])\n        return result\n    if hasattr(thing, '__next__'):\n        return str(thing)\n    elif isinstance(thing, Mapping) and _nest_lvl < get_option(\n        'display.pprint_nest_depth'):\n        result = _pprint_dict(thing, _nest_lvl, quote_strings=True,\n            max_seq_items=max_seq_items)\n    elif is_sequence(thing) and _nest_lvl < get_option(\n        'display.pprint_nest_depth'):\n        result = _pprint_seq(thing, _nest_lvl, escape_chars=escape_chars,\n            quote_strings=quote_strings, max_seq_items=max_seq_items)\n    elif isinstance(thing, str) and quote_strings:\n        result = f\"'{as_escaped_string(thing)}'\"\n    else:\n        result = as_escaped_string(thing)\n    return result"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "get_option", "method_path": "../srcdata/Computation/pandas/pandas/_config/config.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\n\n\ndef get_option(pat: str) ->Any: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\ndef get_option(pat: str) ->Any:\n    \"\"\"\n    Retrieve the value of the specified option.\n\n    Parameters\n    ----------\n    pat : str\n        Regexp which should match a single option.\n\n        .. warning::\n\n            Partial matches are supported for convenience, but unless you use the\n            full option name (e.g. x.y.z.option_name), your code may break in future\n            versions if new options with similar names are introduced.\n\n    Returns\n    -------\n    Any\n        The value of the option.\n\n    Raises\n    ------\n    OptionError : if no such option exists\n\n    See Also\n    --------\n    set_option : Set the value of the specified option or options.\n    reset_option : Reset one or more options to their default value.\n    describe_option : Print the description for one or more registered options.\n\n    Notes\n    -----\n    For all available options, please view the :ref:`User Guide <options.available>`\n    or use ``pandas.describe_option()``.\n\n    Examples\n    --------\n    >>> pd.get_option(\"display.max_columns\")  # doctest: +SKIP\n    4\n    \"\"\"\n    key = _get_single_key(pat)\n    root, k = _get_root(key)\n    return root[k]"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "array_equivalent", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/missing.py", "method_code_mask": "from __future__ import annotations\nfrom decimal import Decimal\nfrom typing import TYPE_CHECKING\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nimport pandas._libs.missing as libmissing\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import iNaT\nfrom pandas.core.dtypes.common import DT64NS_DTYPE\nfrom pandas.core.dtypes.common import TD64NS_DTYPE\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_or_object_np_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom re import Pattern\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Series\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.construction import sanitize_array\n\n\ndef array_equivalent(left, right, strict_nan: bool=False, dtype_equal: bool\n    =False) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom decimal import Decimal\nfrom typing import TYPE_CHECKING\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nimport pandas._libs.missing as libmissing\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import iNaT\nfrom pandas.core.dtypes.common import DT64NS_DTYPE\nfrom pandas.core.dtypes.common import TD64NS_DTYPE\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_string_or_object_np_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import IntervalDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCDataFrame\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCMultiIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.inference import is_list_like\nfrom re import Pattern\nfrom pandas._libs.missing import NAType\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NDFrameT\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas import Series\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.construction import sanitize_array\ndef array_equivalent(left, right, strict_nan: bool=False, dtype_equal: bool\n    =False) ->bool:\n    \"\"\"\n    True if two arrays, left and right, have equal non-NaN elements, and NaNs\n    in corresponding locations.  False otherwise. It is assumed that left and\n    right are NumPy arrays of the same dtype. The behavior of this function\n    (particularly with respect to NaNs) is not defined if the dtypes are\n    different.\n\n    Parameters\n    ----------\n    left, right : ndarrays\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n    dtype_equal : bool, default False\n        Whether `left` and `right` are known to have the same dtype\n        according to `is_dtype_equal`. Some methods like `BlockManager.equals`.\n        require that the dtypes match. Setting this to ``True`` can improve\n        performance, but will give different results for arrays that are\n        equal but different dtypes.\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equivalent.\n\n    Examples\n    --------\n    >>> array_equivalent(np.array([1, 2, np.nan]), np.array([1, 2, np.nan]))\n    True\n    >>> array_equivalent(np.array([1, np.nan, 2]), np.array([1, 2, np.nan]))\n    False\n    \"\"\"\n    left, right = np.asarray(left), np.asarray(right)\n    if left.shape != right.shape:\n        return False\n    if dtype_equal:\n        if left.dtype.kind in 'fc':\n            return _array_equivalent_float(left, right)\n        elif left.dtype.kind in 'mM':\n            return _array_equivalent_datetimelike(left, right)\n        elif is_string_or_object_np_dtype(left.dtype):\n            return _array_equivalent_object(left, right, strict_nan)\n        else:\n            return np.array_equal(left, right)\n    if left.dtype.kind in 'OSU' or right.dtype.kind in 'OSU':\n        return _array_equivalent_object(left, right, strict_nan)\n    if left.dtype.kind in 'fc':\n        if not (left.size and right.size):\n            return True\n        return ((left == right) | isna(left) & isna(right)).all()\n    elif left.dtype.kind in 'mM' or right.dtype.kind in 'mM':\n        if left.dtype != right.dtype:\n            return False\n        left = left.view('i8')\n        right = right.view('i8')\n    if (left.dtype.type is np.void or right.dtype.type is np.void\n        ) and left.dtype != right.dtype:\n        return False\n    return np.array_equal(left, right)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.melt", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/test_melt.py", "method_code_mask": "import re\nimport numpy as np\nimport pytest\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import date_range\nfrom pandas import lreshape\nfrom pandas import melt\nfrom pandas import wide_to_long\nimport pandas._testing as tm\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "import re\nimport numpy as np\nimport pytest\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import date_range\nfrom pandas import lreshape\nfrom pandas import melt\nfrom pandas import wide_to_long\nimport pandas._testing as tm\n@pytest.fixture\ndef df():\n    res = DataFrame(np.random.default_rng(2).standard_normal((10, 4)),\n        columns=Index(list('ABCD'), dtype=object), index=date_range(\n        '2000-01-01', periods=10, freq='B'))\n    res['id1'] = (res['A'] > 0).astype(np.int64)\n    res['id2'] = (res['B'] > 0).astype(np.int64)\n    return res"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_join_by_hand", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/merge/test_join.py", "method_code_mask": "import re\nimport numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import bdate_range\nfrom pandas import concat\nfrom pandas import merge\nfrom pandas import option_context\nimport pandas._testing as tm\n\n\ndef _join_by_hand(a, b, how='left'): [MASK]\n", "response": "import re\nimport numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import bdate_range\nfrom pandas import concat\nfrom pandas import merge\nfrom pandas import option_context\nimport pandas._testing as tm\ndef _join_by_hand(a, b, how='left'):\n    join_index = a.index.join(b.index, how=how)\n    a_re = a.reindex(join_index)\n    b_re = b.reindex(join_index)\n    result_columns = a.columns.append(b.columns)\n    for col, s in b_re.items():\n        a_re[col] = s\n    return a_re.reindex(columns=result_columns)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "period_range", "method_path": "../srcdata/Computation/pandas/pandas/core/indexes/period.py", "method_code_mask": "from __future__ import annotations\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs import index as libindex\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import Period\nfrom pandas._libs.tslibs import Resolution\nfrom pandas._libs.tslibs import Tick\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.arrays.period import PeriodArray\nfrom pandas.core.arrays.period import period_array\nfrom pandas.core.arrays.period import raise_on_incompatible\nfrom pandas.core.arrays.period import validate_dtype_freq\nimport pandas.core.common as com\nimport pandas.core.indexes.base as ibase\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin\nfrom pandas.core.indexes.datetimes import DatetimeIndex\nfrom pandas.core.indexes.datetimes import Index\nfrom pandas.core.indexes.extension import inherit_names\nfrom collections.abc import Hashable\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import npt\n\n\ndef period_range(start=None, end=None, periods: (int | None)=None, freq=\n    None, name: (Hashable | None)=None) ->PeriodIndex: [MASK]\n", "response": "from __future__ import annotations\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas._libs import index as libindex\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import Period\nfrom pandas._libs.tslibs import Resolution\nfrom pandas._libs.tslibs import Tick\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.arrays.period import PeriodArray\nfrom pandas.core.arrays.period import period_array\nfrom pandas.core.arrays.period import raise_on_incompatible\nfrom pandas.core.arrays.period import validate_dtype_freq\nimport pandas.core.common as com\nimport pandas.core.indexes.base as ibase\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin\nfrom pandas.core.indexes.datetimes import DatetimeIndex\nfrom pandas.core.indexes.datetimes import Index\nfrom pandas.core.indexes.extension import inherit_names\nfrom collections.abc import Hashable\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import npt\ndef period_range(start=None, end=None, periods: (int | None)=None, freq=\n    None, name: (Hashable | None)=None) ->PeriodIndex:\n    \"\"\"\n    Return a fixed frequency PeriodIndex.\n\n    The day (calendar) is the default frequency.\n\n    Parameters\n    ----------\n    start : str, datetime, date, pandas.Timestamp, or period-like, default None\n        Left bound for generating periods.\n    end : str, datetime, date, pandas.Timestamp, or period-like, default None\n        Right bound for generating periods.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, optional\n        Frequency alias. By default the freq is taken from `start` or `end`\n        if those are Period objects. Otherwise, the default is ``\"D\"`` for\n        daily frequency.\n    name : str, default None\n        Name of the resulting PeriodIndex.\n\n    Returns\n    -------\n    PeriodIndex\n\n    Notes\n    -----\n    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two\n    must be specified.\n\n    To learn more about the frequency strings, please see\n    :ref:`this link<timeseries.offset_aliases>`.\n\n    Examples\n    --------\n    >>> pd.period_range(start=\"2017-01-01\", end=\"2018-01-01\", freq=\"M\")\n    PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05', '2017-06',\n             '2017-07', '2017-08', '2017-09', '2017-10', '2017-11', '2017-12',\n             '2018-01'],\n            dtype='period[M]')\n\n    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor\n    endpoints for a ``PeriodIndex`` with frequency matching that of the\n    ``period_range`` constructor.\n\n    >>> pd.period_range(\n    ...     start=pd.Period(\"2017Q1\", freq=\"Q\"),\n    ...     end=pd.Period(\"2017Q2\", freq=\"Q\"),\n    ...     freq=\"M\",\n    ... )\n    PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'],\n                dtype='period[M]')\n    \"\"\"\n    if com.count_not_none(start, end, periods) != 2:\n        raise ValueError(\n            'Of the three parameters: start, end, and periods, exactly two must be specified'\n            )\n    if freq is None and (not isinstance(start, Period) and not isinstance(\n        end, Period)):\n        freq = 'D'\n    data, freq = PeriodArray._generate_range(start, end, periods, freq)\n    dtype = PeriodDtype(freq)\n    data = PeriodArray(data, dtype=dtype)\n    return PeriodIndex(data, name=name)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "table", "method_path": "../srcdata/Computation/pandas/pandas/plotting/_misc.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom pandas.plotting._core import _get_plot_backend\nfrom collections.abc import Generator\nfrom collections.abc import Mapping\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Colormap\nfrom matplotlib.figure import Figure\nfrom matplotlib.table import Table\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\n\n\ndef table(ax: Axes, data: (DataFrame | Series), **kwargs) ->Table: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom pandas.plotting._core import _get_plot_backend\nfrom collections.abc import Generator\nfrom collections.abc import Mapping\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Colormap\nfrom matplotlib.figure import Figure\nfrom matplotlib.table import Table\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\ndef table(ax: Axes, data: (DataFrame | Series), **kwargs) ->Table:\n    \"\"\"\n    Helper function to convert DataFrame and Series to matplotlib.table.\n\n    Parameters\n    ----------\n    ax : Matplotlib axes object\n        The axes on which to draw the table.\n    data : DataFrame or Series\n        Data for table contents.\n    **kwargs\n        Keyword arguments to be passed to matplotlib.table.table.\n        If `rowLabels` or `colLabels` is not specified, data index or column\n        name will be used.\n\n    Returns\n    -------\n    matplotlib table object\n        The created table as a matplotlib Table object.\n\n    See Also\n    --------\n    DataFrame.plot : Make plots of DataFrame using matplotlib.\n    matplotlib.pyplot.table : Create a table from data in a Matplotlib plot.\n\n    Examples\n    --------\n\n    .. plot::\n            :context: close-figs\n\n            >>> import matplotlib.pyplot as plt\n            >>> df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\n            >>> fix, ax = plt.subplots()\n            >>> ax.axis(\"off\")\n            (0.0, 1.0, 0.0, 1.0)\n            >>> table = pd.plotting.table(\n            ...     ax, df, loc=\"center\", cellLoc=\"center\", colWidths=list([0.2, 0.2])\n            ... )\n    \"\"\"\n    plot_backend = _get_plot_backend('matplotlib')\n    return plot_backend.table(ax=ax, data=data, rowLabels=None, colLabels=\n        None, **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "from_dataframe", "method_path": "../srcdata/Computation/pandas/pandas/core/interchange/from_dataframe.py", "method_code_mask": "from __future__ import annotations\nimport ctypes\nimport re\nfrom typing import Any\nfrom typing import overload\nimport numpy as np\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas.core.interchange.dataframe_protocol import Buffer\nfrom pandas.core.interchange.dataframe_protocol import Column\nfrom pandas.core.interchange.dataframe_protocol import ColumnNullType\nfrom pandas.core.interchange.dataframe_protocol import DataFrame as DataFrameXchg\nfrom pandas.core.interchange.dataframe_protocol import DtypeKind\nfrom pandas.core.interchange.utils import ArrowCTypes\nfrom pandas.core.interchange.utils import Endianness\n\n\ndef from_dataframe(df, allow_copy: bool=True) ->pd.DataFrame: [MASK]\n", "response": "from __future__ import annotations\nimport ctypes\nimport re\nfrom typing import Any\nfrom typing import overload\nimport numpy as np\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas.core.interchange.dataframe_protocol import Buffer\nfrom pandas.core.interchange.dataframe_protocol import Column\nfrom pandas.core.interchange.dataframe_protocol import ColumnNullType\nfrom pandas.core.interchange.dataframe_protocol import DataFrame as DataFrameXchg\nfrom pandas.core.interchange.dataframe_protocol import DtypeKind\nfrom pandas.core.interchange.utils import ArrowCTypes\nfrom pandas.core.interchange.utils import Endianness\ndef from_dataframe(df, allow_copy: bool=True) ->pd.DataFrame:\n    \"\"\"\n    Build a ``pd.DataFrame`` from any DataFrame supporting the interchange protocol.\n\n    Parameters\n    ----------\n    df : DataFrameXchg\n        Object supporting the interchange protocol, i.e. `__dataframe__` method.\n    allow_copy : bool, default: True\n        Whether to allow copying the memory to perform the conversion\n        (if false then zero-copy approach is requested).\n\n    Returns\n    -------\n    pd.DataFrame\n\n    Examples\n    --------\n    >>> df_not_necessarily_pandas = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]})\n    >>> interchange_object = df_not_necessarily_pandas.__dataframe__()\n    >>> interchange_object.column_names()\n    Index(['A', 'B'], dtype='object')\n    >>> df_pandas = pd.api.interchange.from_dataframe(\n    ...     interchange_object.select_columns_by_name([\"A\"])\n    ... )\n    >>> df_pandas\n         A\n    0    1\n    1    2\n\n    These methods (``column_names``, ``select_columns_by_name``) should work\n    for any dataframe library which implements the interchange protocol.\n    \"\"\"\n    if isinstance(df, pd.DataFrame):\n        return df\n    if not hasattr(df, '__dataframe__'):\n        raise ValueError('`df` does not support __dataframe__')\n    return _from_dataframe(df.__dataframe__(allow_copy=allow_copy),\n        allow_copy=allow_copy)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "right.copy", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/merge/test_merge.py", "method_code_mask": "from datetime import date\nfrom datetime import datetime\nfrom datetime import timedelta\nimport re\nimport numpy as np\nimport pytest\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import MultiIndex\nfrom pandas import PeriodIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import TimedeltaIndex\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import MergeError\nfrom pandas.core.reshape.merge import merge\n\n\n@pytest.fixture\ndef right(): [MASK]\n", "response": "from datetime import date\nfrom datetime import datetime\nfrom datetime import timedelta\nimport re\nimport numpy as np\nimport pytest\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import MultiIndex\nfrom pandas import PeriodIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import TimedeltaIndex\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import MergeError\nfrom pandas.core.reshape.merge import merge\n@pytest.fixture\ndef right():\n    return DataFrame({'X': Series(['foo', 'bar']).astype(CategoricalDtype([\n        'foo', 'bar'])), 'Z': [1, 2]})"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "coerce_to_array", "method_path": "../srcdata/Computation/pandas/pandas/core/arrays/boolean.py", "method_code_mask": "from __future__ import annotations\nimport numbers\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import missing as libmissing\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import register_extension_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core import ops\nfrom pandas.core.array_algos import masked_accumulations\nfrom pandas.core.arrays.masked import BaseMaskedArray\nfrom pandas.core.arrays.masked import BaseMaskedDtype\nimport pyarrow\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import npt\nfrom pandas._typing import type_t\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.arrays import IntegerArray\n\n\ndef coerce_to_array(values, mask=None, copy: bool=False) ->tuple[np.ndarray,\n    np.ndarray]: [MASK]\n", "response": "from __future__ import annotations\nimport numbers\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import cast\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import missing as libmissing\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import register_extension_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core import ops\nfrom pandas.core.array_algos import masked_accumulations\nfrom pandas.core.arrays.masked import BaseMaskedArray\nfrom pandas.core.arrays.masked import BaseMaskedDtype\nimport pyarrow\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import npt\nfrom pandas._typing import type_t\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.arrays import IntegerArray\ndef coerce_to_array(values, mask=None, copy: bool=False) ->tuple[np.ndarray,\n    np.ndarray]:\n    \"\"\"\n    Coerce the input values array to numpy arrays with a mask.\n\n    Parameters\n    ----------\n    values : 1D list-like\n    mask : bool 1D array, optional\n    copy : bool, default False\n        if True, copy the input\n\n    Returns\n    -------\n    tuple of (values, mask)\n    \"\"\"\n    if isinstance(values, BooleanArray):\n        if mask is not None:\n            raise ValueError('cannot pass mask for BooleanArray input')\n        values, mask = values._data, values._mask\n        if copy:\n            values = values.copy()\n            mask = mask.copy()\n        return values, mask\n    mask_values = None\n    if isinstance(values, np.ndarray) and values.dtype == np.bool_:\n        if copy:\n            values = values.copy()\n    elif isinstance(values, np.ndarray) and values.dtype.kind in 'iufcb':\n        mask_values = isna(values)\n        values_bool = np.zeros(len(values), dtype=bool)\n        values_bool[~mask_values] = values[~mask_values].astype(bool)\n        if not np.all(values_bool[~mask_values].astype(values.dtype) ==\n            values[~mask_values]):\n            raise TypeError('Need to pass bool-like values')\n        values = values_bool\n    else:\n        values_object = np.asarray(values, dtype=object)\n        inferred_dtype = lib.infer_dtype(values_object, skipna=True)\n        integer_like = 'floating', 'integer', 'mixed-integer-float'\n        if inferred_dtype not in ('boolean', 'empty') + integer_like:\n            raise TypeError('Need to pass bool-like values')\n        mask_values = cast('npt.NDArray[np.bool_]', isna(values_object))\n        values = np.zeros(len(values), dtype=bool)\n        values[~mask_values] = values_object[~mask_values].astype(bool)\n        if inferred_dtype in integer_like and not np.all(values[~\n            mask_values].astype(float) == values_object[~mask_values].\n            astype(float)):\n            raise TypeError('Need to pass bool-like values')\n    if mask is None and mask_values is None:\n        mask = np.zeros(values.shape, dtype=bool)\n    elif mask is None:\n        mask = mask_values\n    elif isinstance(mask, np.ndarray) and mask.dtype == np.bool_:\n        if mask_values is not None:\n            mask = mask | mask_values\n        elif copy:\n            mask = mask.copy()\n    else:\n        mask = np.array(mask, dtype=bool)\n        if mask_values is not None:\n            mask = mask | mask_values\n    if values.shape != mask.shape:\n        raise ValueError('values.shape and mask.shape must match')\n    return values, mask"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "NumpyEADtype.construct_from_string", "method_path": "../srcdata/Computation/pandas/pandas/core/dtypes/dtypes.py", "method_code_mask": "from __future__ import annotations\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom decimal import Decimal\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport numpy as np\nimport pytz\nfrom pandas._config.config import get_option\nfrom pandas._libs import lib\nfrom pandas._libs import missing as libmissing\nfrom pandas._libs.interval import Interval\nfrom pandas._libs.properties import cache_readonly\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._libs.tslibs import Period\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import timezones\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs import tz_compare\nfrom pandas._libs.tslibs.dtypes import PeriodDtypeBase\nfrom pandas._libs.tslibs.dtypes import abbrev_to_npy_unit\nfrom pandas._libs.tslibs.offsets import BDay\nfrom pandas.errors import PerformanceWarning\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import ExtensionDtype\nfrom pandas.core.dtypes.base import StorageExtensionDtype\nfrom pandas.core.dtypes.base import register_extension_dtype\nfrom pandas.core.dtypes.generic import ABCCategoricalIndex\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCRangeIndex\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_list_like\nimport pyarrow as pa\nfrom collections.abc import MutableMapping\nfrom datetime import tzinfo\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import IntervalClosedType\nfrom pandas._typing import Ordered\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas._typing import type_t\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import PeriodIndex\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import SparseArray\nfrom pandas.core.arrays.arrow import ArrowExtensionArray\nfrom pandas.core.util.hashing import combine_hash_arrays\nfrom pandas.core.util.hashing import hash_array\nfrom pandas.core.util.hashing import hash_tuples\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.cast import find_common_type\nimport pyarrow\nfrom pandas.core.arrays.arrow._arrow_utils import pyarrow_array_to_numpy_and_mask\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.arrays.boolean import BooleanDtype\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.cast import can_hold_element\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas import isna\nfrom pandas.core.arrays.sparse.array import SparseArray\nfrom pandas.core.dtypes.astype import astype_array\nfrom pandas.core.dtypes.cast import np_find_common_type\n\n\nclass NumpyEADtype(ExtensionDtype):\n    \"\"\"\n    A Pandas ExtensionDtype for NumPy dtypes.\n\n    This is mostly for internal compatibility, and is not especially\n    useful on its own.\n\n    Parameters\n    ----------\n    dtype : object\n        Object to be converted to a NumPy data type object.\n\n    See Also\n    --------\n    numpy.dtype\n    \"\"\"\n    _metadata = '_dtype',\n    _supports_2d = False\n    _can_fast_transpose = False\n\n    def __init__(self, dtype: (npt.DTypeLike | NumpyEADtype | None)) ->None:\n        if isinstance(dtype, NumpyEADtype):\n            dtype = dtype.numpy_dtype\n        self._dtype = np.dtype(dtype)\n\n    def __repr__(self) ->str:\n        return f'NumpyEADtype({self.name!r})'\n\n    @property\n    def numpy_dtype(self) ->np.dtype:\n        \"\"\"\n        The NumPy dtype this NumpyEADtype wraps.\n        \"\"\"\n        return self._dtype\n\n    @property\n    def name(self) ->str:\n        \"\"\"\n        A bit-width name for this data-type.\n        \"\"\"\n        return self._dtype.name\n\n    @property\n    def type(self) ->type[np.generic]:\n        \"\"\"\n        The type object used to instantiate a scalar of this NumPy data-type.\n        \"\"\"\n        return self._dtype.type\n\n    @property\n    def _is_numeric(self) ->bool:\n        return self.kind in set('biufc')\n\n    @property\n    def _is_boolean(self) ->bool:\n        return self.kind == 'b'\n\n    @classmethod\n    def construct_from_string(cls, string: str) ->NumpyEADtype: [MASK]\n\n    @classmethod\n    def construct_array_type(cls) ->type_t[NumpyExtensionArray]:\n        \"\"\"\n        Return the array type associated with this dtype.\n\n        Returns\n        -------\n        type\n        \"\"\"\n        from pandas.core.arrays import NumpyExtensionArray\n        return NumpyExtensionArray\n\n    @property\n    def kind(self) ->str:\n        \"\"\"\n        A character code (one of 'biufcmMOSUV') identifying the general kind of data.\n        \"\"\"\n        return self._dtype.kind\n\n    @property\n    def itemsize(self) ->int:\n        \"\"\"\n        The element size of this data-type object.\n        \"\"\"\n        return self._dtype.itemsize\n", "response": "from __future__ import annotations\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom decimal import Decimal\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nimport numpy as np\nimport pytz\nfrom pandas._config.config import get_option\nfrom pandas._libs import lib\nfrom pandas._libs import missing as libmissing\nfrom pandas._libs.interval import Interval\nfrom pandas._libs.properties import cache_readonly\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._libs.tslibs import Period\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import Timestamp\nfrom pandas._libs.tslibs import timezones\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs import tz_compare\nfrom pandas._libs.tslibs.dtypes import PeriodDtypeBase\nfrom pandas._libs.tslibs.dtypes import abbrev_to_npy_unit\nfrom pandas._libs.tslibs.offsets import BDay\nfrom pandas.errors import PerformanceWarning\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import ExtensionDtype\nfrom pandas.core.dtypes.base import StorageExtensionDtype\nfrom pandas.core.dtypes.base import register_extension_dtype\nfrom pandas.core.dtypes.generic import ABCCategoricalIndex\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCRangeIndex\nfrom pandas.core.dtypes.inference import is_bool\nfrom pandas.core.dtypes.inference import is_list_like\nimport pyarrow as pa\nfrom collections.abc import MutableMapping\nfrom datetime import tzinfo\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import IntervalClosedType\nfrom pandas._typing import Ordered\nfrom pandas._typing import Scalar\nfrom pandas._typing import npt\nfrom pandas._typing import type_t\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import PeriodIndex\nfrom pandas.core.arrays import BaseMaskedArray\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import IntervalArray\nfrom pandas.core.arrays import PeriodArray\nfrom pandas.core.arrays import SparseArray\nfrom pandas.core.arrays.arrow import ArrowExtensionArray\nfrom pandas.core.util.hashing import combine_hash_arrays\nfrom pandas.core.util.hashing import hash_array\nfrom pandas.core.util.hashing import hash_tuples\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.cast import find_common_type\nimport pyarrow\nfrom pandas.core.arrays.arrow._arrow_utils import pyarrow_array_to_numpy_and_mask\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.arrays.boolean import BooleanDtype\nfrom pandas.core.dtypes.missing import na_value_for_dtype\nfrom pandas.core.dtypes.cast import can_hold_element\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas import isna\nfrom pandas.core.arrays.sparse.array import SparseArray\nfrom pandas.core.dtypes.astype import astype_array\nfrom pandas.core.dtypes.cast import np_find_common_type\nclass NumpyEADtype(ExtensionDtype):\n    \"\"\"\n    A Pandas ExtensionDtype for NumPy dtypes.\n\n    This is mostly for internal compatibility, and is not especially\n    useful on its own.\n\n    Parameters\n    ----------\n    dtype : object\n        Object to be converted to a NumPy data type object.\n\n    See Also\n    --------\n    numpy.dtype\n    \"\"\"\n    _metadata = '_dtype',\n    _supports_2d = False\n    _can_fast_transpose = False\n\n    def __init__(self, dtype: (npt.DTypeLike | NumpyEADtype | None)) ->None:\n        if isinstance(dtype, NumpyEADtype):\n            dtype = dtype.numpy_dtype\n        self._dtype = np.dtype(dtype)\n\n    def __repr__(self) ->str:\n        return f'NumpyEADtype({self.name!r})'\n\n    @property\n    def numpy_dtype(self) ->np.dtype:\n        \"\"\"\n        The NumPy dtype this NumpyEADtype wraps.\n        \"\"\"\n        return self._dtype\n\n    @property\n    def name(self) ->str:\n        \"\"\"\n        A bit-width name for this data-type.\n        \"\"\"\n        return self._dtype.name\n\n    @property\n    def type(self) ->type[np.generic]:\n        \"\"\"\n        The type object used to instantiate a scalar of this NumPy data-type.\n        \"\"\"\n        return self._dtype.type\n\n    @property\n    def _is_numeric(self) ->bool:\n        return self.kind in set('biufc')\n\n    @property\n    def _is_boolean(self) ->bool:\n        return self.kind == 'b'\n\n    @classmethod\n    def construct_from_string(cls, string: str) ->NumpyEADtype:\n        try:\n            dtype = np.dtype(string)\n        except TypeError as err:\n            if not isinstance(string, str):\n                msg = (\n                    f\"'construct_from_string' expects a string, got {type(string)}\"\n                    )\n            else:\n                msg = f\"Cannot construct a 'NumpyEADtype' from '{string}'\"\n            raise TypeError(msg) from err\n        return cls(dtype)\n\n    @classmethod\n    def construct_array_type(cls) ->type_t[NumpyExtensionArray]:\n        \"\"\"\n        Return the array type associated with this dtype.\n\n        Returns\n        -------\n        type\n        \"\"\"\n        from pandas.core.arrays import NumpyExtensionArray\n        return NumpyExtensionArray\n\n    @property\n    def kind(self) ->str:\n        \"\"\"\n        A character code (one of 'biufcmMOSUV') identifying the general kind of data.\n        \"\"\"\n        return self._dtype.kind\n\n    @property\n    def itemsize(self) ->int:\n        \"\"\"\n        The element size of this data-type object.\n        \"\"\"\n        return self._dtype.itemsize"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "parallel_coordinates", "method_path": "../srcdata/Computation/pandas/pandas/plotting/_misc.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom pandas.plotting._core import _get_plot_backend\nfrom collections.abc import Generator\nfrom collections.abc import Mapping\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Colormap\nfrom matplotlib.figure import Figure\nfrom matplotlib.table import Table\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\n\n\ndef parallel_coordinates(frame: DataFrame, class_column: str, cols: (list[\n    str] | None)=None, ax: (Axes | None)=None, color: (list[str] | tuple[\n    str, ...] | None)=None, use_columns: bool=False, xticks: (list | tuple |\n    None)=None, colormap: (Colormap | str | None)=None, axvlines: bool=True,\n    axvlines_kwds: (Mapping[str, Any] | None)=None, sort_labels: bool=False,\n    **kwargs) ->Axes: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom pandas.plotting._core import _get_plot_backend\nfrom collections.abc import Generator\nfrom collections.abc import Mapping\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Colormap\nfrom matplotlib.figure import Figure\nfrom matplotlib.table import Table\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\ndef parallel_coordinates(frame: DataFrame, class_column: str, cols: (list[\n    str] | None)=None, ax: (Axes | None)=None, color: (list[str] | tuple[\n    str, ...] | None)=None, use_columns: bool=False, xticks: (list | tuple |\n    None)=None, colormap: (Colormap | str | None)=None, axvlines: bool=True,\n    axvlines_kwds: (Mapping[str, Any] | None)=None, sort_labels: bool=False,\n    **kwargs) ->Axes:\n    \"\"\"\n    Parallel coordinates plotting.\n\n    Parameters\n    ----------\n    frame : DataFrame\n        The DataFrame to be plotted.\n    class_column : str\n        Column name containing class names.\n    cols : list, optional\n        A list of column names to use.\n    ax : matplotlib.axis, optional\n        Matplotlib axis object.\n    color : list or tuple, optional\n        Colors to use for the different classes.\n    use_columns : bool, optional\n        If true, columns will be used as xticks.\n    xticks : list or tuple, optional\n        A list of values to use for xticks.\n    colormap : str or matplotlib colormap, default None\n        Colormap to use for line colors.\n    axvlines : bool, optional\n        If true, vertical lines will be added at each xtick.\n    axvlines_kwds : keywords, optional\n        Options to be passed to axvline method for vertical lines.\n    sort_labels : bool, default False\n        Sort class_column labels, useful when assigning colors.\n    **kwargs\n        Options to pass to matplotlib plotting method.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The matplotlib axes containing the parallel coordinates plot.\n\n    See Also\n    --------\n    plotting.andrews_curves : Generate a matplotlib plot for visualizing clusters\n        of multivariate data.\n    plotting.radviz : Plot a multidimensional dataset in 2D.\n\n    Examples\n    --------\n\n    .. plot::\n        :context: close-figs\n\n        >>> df = pd.read_csv(\n        ...     \"https://raw.githubusercontent.com/pandas-dev/\"\n        ...     \"pandas/main/pandas/tests/io/data/csv/iris.csv\"\n        ... )\n        >>> pd.plotting.parallel_coordinates(\n        ...     df, \"Name\", color=(\"#556270\", \"#4ECDC4\", \"#C7F464\")\n        ... )  # doctest: +SKIP\n    \"\"\"\n    plot_backend = _get_plot_backend('matplotlib')\n    return plot_backend.parallel_coordinates(frame=frame, class_column=\n        class_column, cols=cols, ax=ax, color=color, use_columns=\n        use_columns, xticks=xticks, colormap=colormap, axvlines=axvlines,\n        axvlines_kwds=axvlines_kwds, sort_labels=sort_labels, **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "index_view", "method_path": "../srcdata/Computation/pandas/pandas/tests/copy_view/index/test_index.py", "method_code_mask": "import numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nimport pandas._testing as tm\nfrom pandas.tests.copy_view.util import get_array\n\n\ndef index_view(index_data): [MASK]\n", "response": "import numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nimport pandas._testing as tm\nfrom pandas.tests.copy_view.util import get_array\ndef index_view(index_data):\n    df = DataFrame({'a': index_data, 'b': 1.5})\n    view = df[:]\n    df = df.set_index('a', drop=True)\n    idx = df.index\n    return idx, view"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "recode_for_categories", "method_path": "../srcdata/Computation/pandas/pandas/core/arrays/categorical.py", "method_code_mask": "from __future__ import annotations\nfrom csv import QUOTE_NONNUMERIC\nfrom functools import partial\nimport operator\nfrom shutil import get_terminal_size\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import NaT\nfrom pandas._libs import algos as libalgos\nfrom pandas._libs import lib\nfrom pandas._libs.arrays import NDArrayBacked\nfrom pandas.compat.numpy import function as nv\nfrom pandas.util._validators import validate_bool_kwarg\nfrom pandas.core.dtypes.cast import coerce_indexer_dtype\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_any_real_numeric_dtype\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_hashable\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtypeType\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core import algorithms\nfrom pandas.core import arraylike\nfrom pandas.core import ops\nfrom pandas.core.accessor import PandasDelegate\nfrom pandas.core.accessor import delegate_names\nfrom pandas.core.algorithms import factorize\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.arrays._mixins import NDArrayBackedExtensionArray\nfrom pandas.core.arrays._mixins import ravel_compat\nfrom pandas.core.base import ExtensionArray\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.construction import extract_array\nfrom pandas.core.construction import sanitize_array\nfrom pandas.core.ops.common import unpack_zerodim_and_defer\nfrom pandas.core.sorting import nargsort\nfrom pandas.core.strings.object_array import ObjectStringArrayMixin\nfrom pandas.io.formats import console\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Sequence\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AstypeArg\nfrom pandas._typing import AxisInt\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NpDtype\nfrom pandas._typing import Ordered\nfrom pandas._typing import Shape\nfrom pandas._typing import SortKind\nfrom pandas._typing import npt\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.indexes.range import RangeIndex\nfrom pandas import to_datetime\nfrom pandas import to_numeric\nfrom pandas import to_timedelta\nfrom pandas import CategoricalIndex\nfrom pandas.core.util.hashing import hash_array\nfrom pandas.io.formats import format as fmt\nfrom pandas.core.dtypes.concat import union_categoricals\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.groupby.ops import WrappedCythonOp\n\n\ndef recode_for_categories(codes: np.ndarray, old_categories, new_categories,\n    copy: bool=True) ->np.ndarray: [MASK]\n", "response": "from __future__ import annotations\nfrom csv import QUOTE_NONNUMERIC\nfrom functools import partial\nimport operator\nfrom shutil import get_terminal_size\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import NaT\nfrom pandas._libs import algos as libalgos\nfrom pandas._libs import lib\nfrom pandas._libs.arrays import NDArrayBacked\nfrom pandas.compat.numpy import function as nv\nfrom pandas.util._validators import validate_bool_kwarg\nfrom pandas.core.dtypes.cast import coerce_indexer_dtype\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.common import ensure_int64\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import is_any_real_numeric_dtype\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_hashable\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import needs_i8_conversion\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtypeType\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_na_for_dtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core import algorithms\nfrom pandas.core import arraylike\nfrom pandas.core import ops\nfrom pandas.core.accessor import PandasDelegate\nfrom pandas.core.accessor import delegate_names\nfrom pandas.core.algorithms import factorize\nfrom pandas.core.algorithms import take_nd\nfrom pandas.core.arrays._mixins import NDArrayBackedExtensionArray\nfrom pandas.core.arrays._mixins import ravel_compat\nfrom pandas.core.base import ExtensionArray\nfrom pandas.core.base import NoNewAttributesMixin\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.construction import extract_array\nfrom pandas.core.construction import sanitize_array\nfrom pandas.core.ops.common import unpack_zerodim_and_defer\nfrom pandas.core.sorting import nargsort\nfrom pandas.core.strings.object_array import ObjectStringArrayMixin\nfrom pandas.io.formats import console\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Sequence\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import AstypeArg\nfrom pandas._typing import AxisInt\nfrom pandas._typing import Dtype\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import NpDtype\nfrom pandas._typing import Ordered\nfrom pandas._typing import Shape\nfrom pandas._typing import SortKind\nfrom pandas._typing import npt\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import Series\nfrom pandas.core.indexes.range import RangeIndex\nfrom pandas import to_datetime\nfrom pandas import to_numeric\nfrom pandas import to_timedelta\nfrom pandas import CategoricalIndex\nfrom pandas.core.util.hashing import hash_array\nfrom pandas.io.formats import format as fmt\nfrom pandas.core.dtypes.concat import union_categoricals\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.groupby.ops import WrappedCythonOp\ndef recode_for_categories(codes: np.ndarray, old_categories, new_categories,\n    copy: bool=True) ->np.ndarray:\n    \"\"\"\n    Convert a set of codes for to a new set of categories\n\n    Parameters\n    ----------\n    codes : np.ndarray\n    old_categories, new_categories : Index\n    copy: bool, default True\n        Whether to copy if the codes are unchanged.\n\n    Returns\n    -------\n    new_codes : np.ndarray[np.int64]\n\n    Examples\n    --------\n    >>> old_cat = pd.Index([\"b\", \"a\", \"c\"])\n    >>> new_cat = pd.Index([\"a\", \"b\"])\n    >>> codes = np.array([0, 1, 1, 2])\n    >>> recode_for_categories(codes, old_cat, new_cat)\n    array([ 1,  0,  0, -1], dtype=int8)\n    \"\"\"\n    if len(old_categories) == 0:\n        if copy:\n            return codes.copy()\n        return codes\n    elif new_categories.equals(old_categories):\n        if copy:\n            return codes.copy()\n        return codes\n    indexer = coerce_indexer_dtype(new_categories.get_indexer_for(\n        old_categories), new_categories)\n    new_codes = take_nd(indexer, codes, fill_value=-1)\n    return new_codes"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "period_array", "method_path": "../srcdata/Computation/pandas/pandas/core/arrays/period.py", "method_code_mask": "from __future__ import annotations\nfrom datetime import timedelta\nimport operator\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos as libalgos\nfrom pandas._libs import lib\nfrom pandas._libs.arrays import NDArrayBacked\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import astype_overflowsafe\nfrom pandas._libs.tslibs import dt64arr_to_periodarr as c_dt64arr_to_periodarr\nfrom pandas._libs.tslibs import get_unit_from_dtype\nfrom pandas._libs.tslibs import iNaT\nfrom pandas._libs.tslibs import parsing\nfrom pandas._libs.tslibs import period as libperiod\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs.dtypes import FreqGroup\nfrom pandas._libs.tslibs.dtypes import PeriodDtypeBase\nfrom pandas._libs.tslibs.fields import isleapyear_arr\nfrom pandas._libs.tslibs.offsets import Tick\nfrom pandas._libs.tslibs.offsets import delta_to_tick\nfrom pandas._libs.tslibs.period import DIFFERENT_FREQ\nfrom pandas._libs.tslibs.period import IncompatibleFrequency\nfrom pandas._libs.tslibs.period import Period\nfrom pandas._libs.tslibs.period import get_period_field_arr\nfrom pandas._libs.tslibs.period import period_asfreq_arr\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCPeriodIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.arrays import datetimelike as dtl\nimport pandas.core.common as com\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import FillnaOptions\nfrom pandas._typing import NpDtype\nfrom pandas._typing import npt\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.base import ExtensionArray\nimport pyarrow\nfrom pandas.core.arrays.arrow.extension_types import ArrowPeriodType\n\n\ndef period_array(data: (Sequence[Period | str | None] | AnyArrayLike), freq:\n    (str | Tick | BaseOffset | None)=None, copy: bool=False) ->PeriodArray: [M\n    ASK]\n", "response": "from __future__ import annotations\nfrom datetime import timedelta\nimport operator\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import algos as libalgos\nfrom pandas._libs import lib\nfrom pandas._libs.arrays import NDArrayBacked\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import NaT\nfrom pandas._libs.tslibs import NaTType\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import astype_overflowsafe\nfrom pandas._libs.tslibs import dt64arr_to_periodarr as c_dt64arr_to_periodarr\nfrom pandas._libs.tslibs import get_unit_from_dtype\nfrom pandas._libs.tslibs import iNaT\nfrom pandas._libs.tslibs import parsing\nfrom pandas._libs.tslibs import period as libperiod\nfrom pandas._libs.tslibs import to_offset\nfrom pandas._libs.tslibs.dtypes import FreqGroup\nfrom pandas._libs.tslibs.dtypes import PeriodDtypeBase\nfrom pandas._libs.tslibs.fields import isleapyear_arr\nfrom pandas._libs.tslibs.offsets import Tick\nfrom pandas._libs.tslibs.offsets import delta_to_tick\nfrom pandas._libs.tslibs.period import DIFFERENT_FREQ\nfrom pandas._libs.tslibs.period import IncompatibleFrequency\nfrom pandas._libs.tslibs.period import Period\nfrom pandas._libs.tslibs.period import get_period_field_arr\nfrom pandas._libs.tslibs.period import period_asfreq_arr\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCPeriodIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.generic import ABCTimedeltaArray\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.arrays import datetimelike as dtl\nimport pandas.core.common as com\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import Dtype\nfrom pandas._typing import FillnaOptions\nfrom pandas._typing import NpDtype\nfrom pandas._typing import npt\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import TimedeltaArray\nfrom pandas.core.arrays.base import ExtensionArray\nimport pyarrow\nfrom pandas.core.arrays.arrow.extension_types import ArrowPeriodType\ndef period_array(data: (Sequence[Period | str | None] | AnyArrayLike), freq:\n    (str | Tick | BaseOffset | None)=None, copy: bool=False) ->PeriodArray:\n    \"\"\"\n    Construct a new PeriodArray from a sequence of Period scalars.\n\n    Parameters\n    ----------\n    data : Sequence of Period objects\n        A sequence of Period objects. These are required to all have\n        the same ``freq.`` Missing values can be indicated by ``None``\n        or ``pandas.NaT``.\n    freq : str, Tick, or Offset\n        The frequency of every element of the array. This can be specified\n        to avoid inferring the `freq` from `data`.\n    copy : bool, default False\n        Whether to ensure a copy of the data is made.\n\n    Returns\n    -------\n    PeriodArray\n\n    See Also\n    --------\n    PeriodArray\n    pandas.PeriodIndex\n\n    Examples\n    --------\n    >>> period_array([pd.Period(\"2017\", freq=\"Y\"), pd.Period(\"2018\", freq=\"Y\")])\n    <PeriodArray>\n    ['2017', '2018']\n    Length: 2, dtype: period[Y-DEC]\n\n    >>> period_array([pd.Period(\"2017\", freq=\"Y\"), pd.Period(\"2018\", freq=\"Y\"), pd.NaT])\n    <PeriodArray>\n    ['2017', '2018', 'NaT']\n    Length: 3, dtype: period[Y-DEC]\n\n    Integers that look like years are handled\n\n    >>> period_array([2000, 2001, 2002], freq=\"D\")\n    <PeriodArray>\n    ['2000-01-01', '2001-01-01', '2002-01-01']\n    Length: 3, dtype: period[D]\n\n    Datetime-like strings may also be passed\n\n    >>> period_array([\"2000-Q1\", \"2000-Q2\", \"2000-Q3\", \"2000-Q4\"], freq=\"Q\")\n    <PeriodArray>\n    ['2000Q1', '2000Q2', '2000Q3', '2000Q4']\n    Length: 4, dtype: period[Q-DEC]\n    \"\"\"\n    data_dtype = getattr(data, 'dtype', None)\n    if lib.is_np_dtype(data_dtype, 'M'):\n        return PeriodArray._from_datetime64(data, freq)\n    if isinstance(data_dtype, PeriodDtype):\n        out = PeriodArray(data)\n        if freq is not None:\n            if freq == data_dtype.freq:\n                return out\n            return out.asfreq(freq)\n        return out\n    if not isinstance(data, (np.ndarray, list, tuple, ABCSeries)):\n        data = list(data)\n    arrdata = np.asarray(data)\n    dtype: PeriodDtype | None\n    if freq:\n        dtype = PeriodDtype(freq)\n    else:\n        dtype = None\n    if arrdata.dtype.kind == 'f' and len(arrdata) > 0:\n        raise TypeError(\n            'PeriodIndex does not allow floating point in construction')\n    if arrdata.dtype.kind in 'iu':\n        arr = arrdata.astype(np.int64, copy=False)\n        ordinals = libperiod.from_ordinals(arr, freq)\n        return PeriodArray(ordinals, dtype=dtype)\n    data = ensure_object(arrdata)\n    if freq is None:\n        freq = libperiod.extract_freq(data)\n    dtype = PeriodDtype(freq)\n    return PeriodArray._from_sequence(data, dtype=dtype)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "cartesian_product", "method_path": "../srcdata/Computation/pandas/pandas/core/reshape/util.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas._typing import NumpyIndexT\n\n\ndef cartesian_product(X) ->list[np.ndarray]: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas._typing import NumpyIndexT\ndef cartesian_product(X) ->list[np.ndarray]:\n    \"\"\"\n    Numpy version of itertools.product.\n    Sometimes faster (for large inputs)...\n\n    Parameters\n    ----------\n    X : list-like of list-likes\n\n    Returns\n    -------\n    product : list of ndarrays\n\n    Examples\n    --------\n    >>> cartesian_product([list(\"ABC\"), [1, 2]])\n    [array(['A', 'A', 'B', 'B', 'C', 'C'], dtype='<U1'), array([1, 2, 1, 2, 1, 2])]\n\n    See Also\n    --------\n    itertools.product : Cartesian product of input iterables.  Equivalent to\n        nested for-loops.\n    \"\"\"\n    msg = 'Input must be a list-like of list-likes'\n    if not is_list_like(X):\n        raise TypeError(msg)\n    for x in X:\n        if not is_list_like(x):\n            raise TypeError(msg)\n    if len(X) == 0:\n        return []\n    lenX = np.fromiter((len(x) for x in X), dtype=np.intp)\n    cumprodX = np.cumprod(lenX)\n    if np.any(cumprodX < 0):\n        raise ValueError('Product space too large to allocate arrays!')\n    a = np.roll(cumprodX, 1)\n    a[0] = 1\n    if cumprodX[-1] != 0:\n        b = cumprodX[-1] / cumprodX\n    else:\n        b = np.zeros_like(cumprodX)\n    return [tile_compat(np.repeat(x, b[i]), np.prod(a[i])) for i, x in\n        enumerate(X)]"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "skip_if_installed", "method_path": "../srcdata/Computation/pandas/pandas/util/_test_decorators.py", "method_code_mask": "from __future__ import annotations\nimport locale\nfrom typing import TYPE_CHECKING\nimport pytest\nfrom collections.abc import Callable\nfrom pandas._typing import F\nfrom pandas.compat import IS64\nfrom pandas.compat import is_platform_windows\nfrom pandas.compat._optional import import_optional_dependency\n\n\ndef skip_if_installed(package: str) ->pytest.MarkDecorator: [MASK]\n", "response": "from __future__ import annotations\nimport locale\nfrom typing import TYPE_CHECKING\nimport pytest\nfrom collections.abc import Callable\nfrom pandas._typing import F\nfrom pandas.compat import IS64\nfrom pandas.compat import is_platform_windows\nfrom pandas.compat._optional import import_optional_dependency\ndef skip_if_installed(package: str) ->pytest.MarkDecorator:\n    \"\"\"\n    Skip a test if a package is installed.\n\n    Parameters\n    ----------\n    package : str\n        The name of the package.\n\n    Returns\n    -------\n    pytest.MarkDecorator\n        a pytest.mark.skipif to use as either a test decorator or a\n        parametrization mark.\n    \"\"\"\n    return pytest.mark.skipif(bool(import_optional_dependency(package,\n        errors='ignore')), reason=f'Skipping because {package} is installed.')"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "right.reset_index", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/merge/test_multi.py", "method_code_mask": "import numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import merge\n\n\n@pytest.fixture\ndef right(multiindex_dataframe_random_data): [MASK]\n", "response": "import numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import merge\n@pytest.fixture\ndef right(multiindex_dataframe_random_data):\n    \"\"\"right dataframe (multi-indexed) for multi-index join tests\"\"\"\n    df = multiindex_dataframe_random_data\n    df.index.names = ['key1', 'key2']\n    df.columns = ['j_one', 'j_two', 'j_three']\n    return df"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "get_engine", "method_path": "../srcdata/Computation/pandas/pandas/io/sql.py", "method_code_mask": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom contextlib import ExitStack\nfrom contextlib import contextmanager\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import AbstractMethodError\nfrom pandas.errors import DatabaseError\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.util._validators import check_dtype_backend\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas import get_option\nfrom pandas.core.api import DataFrame\nfrom pandas.core.api import Series\nfrom pandas.core.arrays import ArrowExtensionArray\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.common import maybe_make_list\nfrom pandas.core.internals.construction import convert_object_array\nfrom pandas.core.tools.datetimes import to_datetime\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom sqlalchemy import Table\nfrom sqlalchemy.sql.expression import Select\nfrom sqlalchemy.sql.expression import TextClause\nfrom pandas._typing import DtypeArg\nfrom pandas._typing import DtypeBackend\nfrom pandas._typing import IndexLabel\nfrom pandas import Index\nimport sqlite3\nfrom sqlalchemy.schema import CreateTable\nfrom sqlalchemy import insert\nimport pyarrow as pa\nfrom sqlalchemy import select\nfrom sqlalchemy import Column\nfrom sqlalchemy import PrimaryKeyConstraint\nfrom sqlalchemy.schema import MetaData\nfrom sqlalchemy.types import TIMESTAMP\nfrom sqlalchemy.types import BigInteger\nfrom sqlalchemy.types import Boolean\nfrom sqlalchemy.types import Date\nfrom sqlalchemy.types import DateTime\nfrom sqlalchemy.types import Float\nfrom sqlalchemy.types import Integer\nfrom sqlalchemy.types import SmallInteger\nfrom sqlalchemy.types import Text\nfrom sqlalchemy.types import Time\nfrom sqlalchemy import exc\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.types import TypeEngine\nfrom sqlalchemy import inspect as sqlalchemy_inspect\nfrom sqlalchemy import Numeric\nfrom pandas.io._util import _arrow_dtype_mapping\n\n\ndef get_engine(engine: str) ->BaseEngine: [MASK]\n", "response": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom contextlib import ExitStack\nfrom contextlib import contextmanager\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import AbstractMethodError\nfrom pandas.errors import DatabaseError\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.util._validators import check_dtype_backend\nfrom pandas.core.dtypes.common import is_dict_like\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.missing import isna\nfrom pandas import get_option\nfrom pandas.core.api import DataFrame\nfrom pandas.core.api import Series\nfrom pandas.core.arrays import ArrowExtensionArray\nfrom pandas.core.base import PandasObject\nimport pandas.core.common as com\nfrom pandas.core.common import maybe_make_list\nfrom pandas.core.internals.construction import convert_object_array\nfrom pandas.core.tools.datetimes import to_datetime\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom sqlalchemy import Table\nfrom sqlalchemy.sql.expression import Select\nfrom sqlalchemy.sql.expression import TextClause\nfrom pandas._typing import DtypeArg\nfrom pandas._typing import DtypeBackend\nfrom pandas._typing import IndexLabel\nfrom pandas import Index\nimport sqlite3\nfrom sqlalchemy.schema import CreateTable\nfrom sqlalchemy import insert\nimport pyarrow as pa\nfrom sqlalchemy import select\nfrom sqlalchemy import Column\nfrom sqlalchemy import PrimaryKeyConstraint\nfrom sqlalchemy.schema import MetaData\nfrom sqlalchemy.types import TIMESTAMP\nfrom sqlalchemy.types import BigInteger\nfrom sqlalchemy.types import Boolean\nfrom sqlalchemy.types import Date\nfrom sqlalchemy.types import DateTime\nfrom sqlalchemy.types import Float\nfrom sqlalchemy.types import Integer\nfrom sqlalchemy.types import SmallInteger\nfrom sqlalchemy.types import Text\nfrom sqlalchemy.types import Time\nfrom sqlalchemy import exc\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy.types import TypeEngine\nfrom sqlalchemy import inspect as sqlalchemy_inspect\nfrom sqlalchemy import Numeric\nfrom pandas.io._util import _arrow_dtype_mapping\ndef get_engine(engine: str) ->BaseEngine:\n    \"\"\"return our implementation\"\"\"\n    if engine == 'auto':\n        engine = get_option('io.sql.engine')\n    if engine == 'auto':\n        engine_classes = [SQLAlchemyEngine]\n        error_msgs = ''\n        for engine_class in engine_classes:\n            try:\n                return engine_class()\n            except ImportError as err:\n                error_msgs += '\\n - ' + str(err)\n        raise ImportError(\n            f\"\"\"Unable to find a usable engine; tried using: 'sqlalchemy'.\nA suitable version of sqlalchemy is required for sql I/O support.\nTrying to import the above resulted in these errors:{error_msgs}\"\"\"\n            )\n    if engine == 'sqlalchemy':\n        return SQLAlchemyEngine()\n    raise ValueError(\"engine must be one of 'auto', 'sqlalchemy'\")"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "styler.to_html", "method_path": "../srcdata/Computation/pandas/pandas/tests/io/formats/style/test_style.py", "method_code_mask": "import contextlib\nimport copy\nimport re\nfrom textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _get_level_lengths\nfrom pandas.io.formats.style_render import _get_trimming_maximums\nfrom pandas.io.formats.style_render import maybe_convert_css_to_tuples\nfrom pandas.io.formats.style_render import non_reducing_slice\n\n\n@pytest.fixture\ndef styler(df): [MASK]\n", "response": "import contextlib\nimport copy\nimport re\nfrom textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _get_level_lengths\nfrom pandas.io.formats.style_render import _get_trimming_maximums\nfrom pandas.io.formats.style_render import maybe_convert_css_to_tuples\nfrom pandas.io.formats.style_render import non_reducing_slice\n@pytest.fixture\ndef styler(df):\n    df = DataFrame({'A': [0, 1], 'B': np.random.default_rng(2).\n        standard_normal(2)})\n    return Styler(df)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "maybe_convert_css_to_tuples", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef maybe_convert_css_to_tuples(style: CSSProperties) ->CSSList: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef maybe_convert_css_to_tuples(style: CSSProperties) ->CSSList:\n    \"\"\"\n    Convert css-string to sequence of tuples format if needed.\n    'color:red; border:1px solid black;' -> [('color', 'red'),\n                                             ('border','1px solid red')]\n    \"\"\"\n    if isinstance(style, str):\n        s = style.split(';')\n        try:\n            return [(x.split(':')[0].strip(), x.split(':')[1].strip()) for\n                x in s if x.strip() != '']\n        except IndexError as err:\n            raise ValueError(\n                f\"Styles supplied as string must follow CSS rule formats, for example 'attr: val;'. '{style}' was given.\"\n                ) from err\n    return style"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "left.merge", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/merge/test_merge.py", "method_code_mask": "from datetime import date\nfrom datetime import datetime\nfrom datetime import timedelta\nimport re\nimport numpy as np\nimport pytest\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import MultiIndex\nfrom pandas import PeriodIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import TimedeltaIndex\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import MergeError\nfrom pandas.core.reshape.merge import merge\n\n\n@pytest.fixture\ndef left(): [MASK]\n", "response": "from datetime import date\nfrom datetime import datetime\nfrom datetime import timedelta\nimport re\nimport numpy as np\nimport pytest\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nimport pandas as pd\nfrom pandas import Categorical\nfrom pandas import CategoricalIndex\nfrom pandas import DataFrame\nfrom pandas import DatetimeIndex\nfrom pandas import Index\nfrom pandas import IntervalIndex\nfrom pandas import MultiIndex\nfrom pandas import PeriodIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import TimedeltaIndex\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import MergeError\nfrom pandas.core.reshape.merge import merge\n@pytest.fixture\ndef left():\n    return DataFrame({'X': Series(np.random.default_rng(2).choice(['foo',\n        'bar'], size=(10,))).astype(CategoricalDtype(['foo', 'bar'])), 'Y':\n        np.random.default_rng(2).choice(['one', 'two', 'three'], size=(10,))})"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "build_table_schema", "method_path": "../srcdata/Computation/pandas/pandas/io/json/_table_schema.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import timezones\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas import DataFrame\nimport pandas.core.common as com\nfrom pandas.tseries.frequencies import to_offset\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import JSONSerializable\nfrom pandas import Series\nfrom pandas.core.indexes.multi import MultiIndex\n\n\ndef build_table_schema(data: (DataFrame | Series), index: bool=True,\n    primary_key: (bool | None)=None, version: bool=True) ->dict[str,\n    JSONSerializable]: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import timezones\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas import DataFrame\nimport pandas.core.common as com\nfrom pandas.tseries.frequencies import to_offset\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import JSONSerializable\nfrom pandas import Series\nfrom pandas.core.indexes.multi import MultiIndex\ndef build_table_schema(data: (DataFrame | Series), index: bool=True,\n    primary_key: (bool | None)=None, version: bool=True) ->dict[str,\n    JSONSerializable]:\n    \"\"\"\n    Create a Table schema from ``data``.\n\n    Parameters\n    ----------\n    data : Series, DataFrame\n    index : bool, default True\n        Whether to include ``data.index`` in the schema.\n    primary_key : bool or None, default True\n        Column names to designate as the primary key.\n        The default `None` will set `'primaryKey'` to the index\n        level or levels if the index is unique.\n    version : bool, default True\n        Whether to include a field `pandas_version` with the version\n        of pandas that last revised the table schema. This version\n        can be different from the installed pandas version.\n\n    Returns\n    -------\n    dict\n\n    Notes\n    -----\n    See `Table Schema\n    <https://pandas.pydata.org/docs/user_guide/io.html#table-schema>`__ for\n    conversion types.\n    Timedeltas as converted to ISO8601 duration format with\n    9 decimal places after the seconds field for nanosecond precision.\n\n    Categoricals are converted to the `any` dtype, and use the `enum` field\n    constraint to list the allowed values. The `ordered` attribute is included\n    in an `ordered` field.\n\n    Examples\n    --------\n    >>> from pandas.io.json._table_schema import build_table_schema\n    >>> df = pd.DataFrame(\n    ...     {'A': [1, 2, 3],\n    ...      'B': ['a', 'b', 'c'],\n    ...      'C': pd.date_range('2016-01-01', freq='D', periods=3),\n    ...      }, index=pd.Index(range(3), name='idx'))\n    >>> build_table_schema(df)\n    {'fields': [{'name': 'idx', 'type': 'integer'}, {'name': 'A', 'type': 'integer'}, {'name': 'B', 'type': 'string'}, {'name': 'C', 'type': 'datetime'}], 'primaryKey': ['idx'], 'pandas_version': '1.4.0'}\n    \"\"\"\n    if index is True:\n        data = set_default_names(data)\n    schema: dict[str, Any] = {}\n    fields = []\n    if index:\n        if data.index.nlevels > 1:\n            data.index = cast('MultiIndex', data.index)\n            for level, name in zip(data.index.levels, data.index.names):\n                new_field = convert_pandas_type_to_json_field(level)\n                new_field['name'] = name\n                fields.append(new_field)\n        else:\n            fields.append(convert_pandas_type_to_json_field(data.index))\n    if data.ndim > 1:\n        for column, s in data.items():\n            fields.append(convert_pandas_type_to_json_field(s))\n    else:\n        fields.append(convert_pandas_type_to_json_field(data))\n    schema['fields'] = fields\n    if index and data.index.is_unique and primary_key is None:\n        if data.index.nlevels == 1:\n            schema['primaryKey'] = [data.index.name]\n        else:\n            schema['primaryKey'] = data.index.names\n    elif primary_key is not None:\n        schema['primaryKey'] = primary_key\n    if version:\n        schema['pandas_version'] = TABLE_SCHEMA_VERSION\n    return schema"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "round_trip_pathlib", "method_path": "../srcdata/Computation/pandas/pandas/_testing/_io.py", "method_code_mask": "from __future__ import annotations\nimport gzip\nimport io\nimport pathlib\nimport tarfile\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport uuid\nimport zipfile\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas._testing.contexts import ensure_clean\nfrom collections.abc import Callable\nfrom pandas._typing import FilePath\nfrom pandas._typing import ReadPickleBuffer\nfrom pandas import DataFrame\nfrom pandas import Series\nimport bz2\nimport lzma\n\n\ndef round_trip_pathlib(writer, reader, path: (str | None)=None): [MASK]\n", "response": "from __future__ import annotations\nimport gzip\nimport io\nimport pathlib\nimport tarfile\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport uuid\nimport zipfile\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas._testing.contexts import ensure_clean\nfrom collections.abc import Callable\nfrom pandas._typing import FilePath\nfrom pandas._typing import ReadPickleBuffer\nfrom pandas import DataFrame\nfrom pandas import Series\nimport bz2\nimport lzma\ndef round_trip_pathlib(writer, reader, path: (str | None)=None):\n    \"\"\"\n    Write an object to file specified by a pathlib.Path and read it back\n\n    Parameters\n    ----------\n    writer : callable bound to pandas object\n        IO writing function (e.g. DataFrame.to_csv )\n    reader : callable\n        IO reading function (e.g. pd.read_csv )\n    path : str, default None\n        The path where the object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was serialized and then re-read.\n    \"\"\"\n    Path = pathlib.Path\n    if path is None:\n        path = '___pathlib___'\n    with ensure_clean(path) as path:\n        writer(Path(path))\n        obj = reader(Path(path))\n    return obj"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_parse_latex_header_span", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef _parse_latex_header_span(cell: dict[str, Any], multirow_align: str,\n    multicol_align: str, wrap: bool=False, convert_css: bool=False) ->str: [M\n    ASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef _parse_latex_header_span(cell: dict[str, Any], multirow_align: str,\n    multicol_align: str, wrap: bool=False, convert_css: bool=False) ->str:\n    \"\"\"\n    Refactor the cell `display_value` if a 'colspan' or 'rowspan' attribute is present.\n\n    'rowspan' and 'colspan' do not occur simultaneouly. If they are detected then\n    the `display_value` is altered to a LaTeX `multirow` or `multicol` command\n    respectively, with the appropriate cell-span.\n\n    ``wrap`` is used to enclose the `display_value` in braces which is needed for\n    column headers using an siunitx package.\n\n    Requires the package {multirow}, whereas multicol support is usually built in\n    to the {tabular} environment.\n\n    Examples\n    --------\n    >>> cell = {\"cellstyle\": \"\", \"display_value\": \"text\", \"attributes\": 'colspan=\"3\"'}\n    >>> _parse_latex_header_span(cell, \"t\", \"c\")\n    '\\\\\\\\multicolumn{3}{c}{text}'\n    \"\"\"\n    display_val = _parse_latex_cell_styles(cell['cellstyle'], cell[\n        'display_value'], convert_css)\n    if 'attributes' in cell:\n        attrs = cell['attributes']\n        if 'colspan=\"' in attrs:\n            colspan = attrs[attrs.find('colspan=\"') + 9:]\n            colspan = int(colspan[:colspan.find('\"')])\n            if 'naive-l' == multicol_align:\n                out = f'{{{display_val}}}' if wrap else f'{display_val}'\n                blanks = ' & {}' if wrap else ' &'\n                return out + blanks * (colspan - 1)\n            elif 'naive-r' == multicol_align:\n                out = f'{{{display_val}}}' if wrap else f'{display_val}'\n                blanks = '{} & ' if wrap else '& '\n                return blanks * (colspan - 1) + out\n            return (\n                f'\\\\multicolumn{{{colspan}}}{{{multicol_align}}}{{{display_val}}}'\n                )\n        elif 'rowspan=\"' in attrs:\n            if multirow_align == 'naive':\n                return display_val\n            rowspan = attrs[attrs.find('rowspan=\"') + 9:]\n            rowspan = int(rowspan[:rowspan.find('\"')])\n            return (\n                f'\\\\multirow[{multirow_align}]{{{rowspan}}}{{*}}{{{display_val}}}'\n                )\n    if wrap:\n        return f'{{{display_val}}}'\n    else:\n        return display_val"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_parse_latex_cell_styles", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef _parse_latex_cell_styles(latex_styles: CSSList, display_value: str,\n    convert_css: bool=False) ->str: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef _parse_latex_cell_styles(latex_styles: CSSList, display_value: str,\n    convert_css: bool=False) ->str:\n    \"\"\"\n    Mutate the ``display_value`` string including LaTeX commands from ``latex_styles``.\n\n    This method builds a recursive latex chain of commands based on the\n    CSSList input, nested around ``display_value``.\n\n    If a CSS style is given as ('<command>', '<options>') this is translated to\n    '\\\\<command><options>{display_value}', and this value is treated as the\n    display value for the next iteration.\n\n    The most recent style forms the inner component, for example for styles:\n    `[('c1', 'o1'), ('c2', 'o2')]` this returns: `\\\\c1o1{\\\\c2o2{display_value}}`\n\n    Sometimes latex commands have to be wrapped with curly braces in different ways:\n    We create some parsing flags to identify the different behaviours:\n\n     - `--rwrap`        : `\\\\<command><options>{<display_value>}`\n     - `--wrap`         : `{\\\\<command><options> <display_value>}`\n     - `--nowrap`       : `\\\\<command><options> <display_value>`\n     - `--lwrap`        : `{\\\\<command><options>} <display_value>`\n     - `--dwrap`        : `{\\\\<command><options>}{<display_value>}`\n\n    For example for styles:\n    `[('c1', 'o1--wrap'), ('c2', 'o2')]` this returns: `{\\\\c1o1 \\\\c2o2{display_value}}\n    \"\"\"\n    if convert_css:\n        latex_styles = _parse_latex_css_conversion(latex_styles)\n    for command, options in latex_styles[::-1]:\n        formatter = {'--wrap': f'{{\\\\{command}--to_parse {display_value}}}',\n            '--nowrap': f'\\\\{command}--to_parse {display_value}', '--lwrap':\n            f'{{\\\\{command}--to_parse}} {display_value}', '--rwrap':\n            f'\\\\{command}--to_parse{{{display_value}}}', '--dwrap':\n            f'{{\\\\{command}--to_parse}}{{{display_value}}}'}\n        display_value = f'\\\\{command}{options} {display_value}'\n        for arg in ['--nowrap', '--wrap', '--lwrap', '--rwrap', '--dwrap']:\n            if arg in str(options):\n                display_value = formatter[arg].replace('--to_parse',\n                    _parse_latex_options_strip(value=options, arg=arg))\n                break\n    return display_value"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.style.format", "method_path": "../srcdata/Computation/pandas/pandas/tests/io/formats/style/test_to_latex.py", "method_code_mask": "from textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _parse_latex_cell_styles\nfrom pandas.io.formats.style_render import _parse_latex_css_conversion\nfrom pandas.io.formats.style_render import _parse_latex_header_span\nfrom pandas.io.formats.style_render import _parse_latex_table_styles\nfrom pandas.io.formats.style_render import _parse_latex_table_wrapping\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "from textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _parse_latex_cell_styles\nfrom pandas.io.formats.style_render import _parse_latex_css_conversion\nfrom pandas.io.formats.style_render import _parse_latex_header_span\nfrom pandas.io.formats.style_render import _parse_latex_table_styles\nfrom pandas.io.formats.style_render import _parse_latex_table_wrapping\n@pytest.fixture\ndef df():\n    return DataFrame({'A': [0, 1], 'B': [-0.61, -1.22], 'C': Series(['ab',\n        'cd'], dtype=object)})"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "non_reducing_slice", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef non_reducing_slice(slice_: Subset): [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef non_reducing_slice(slice_: Subset):\n    \"\"\"\n    Ensure that a slice doesn't reduce to a Series or Scalar.\n\n    Any user-passed `subset` should have this called on it\n    to make sure we're always working with DataFrames.\n    \"\"\"\n    kinds = ABCSeries, np.ndarray, Index, list, str\n    if isinstance(slice_, kinds):\n        slice_ = IndexSlice[:, slice_]\n\n    def pred(part) ->bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            True if slice does *not* reduce,\n            False if `part` is a tuple.\n        \"\"\"\n        if isinstance(part, tuple):\n            return any(isinstance(s, slice) or is_list_like(s) for s in part)\n        else:\n            return isinstance(part, slice) or is_list_like(part)\n    if not is_list_like(slice_):\n        if not isinstance(slice_, slice):\n            slice_ = [[slice_]]\n        else:\n            slice_ = [slice_]\n    else:\n        slice_ = [(p if pred(p) else [p]) for p in slice_]\n    return tuple(slice_)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "index_large.intersection", "method_path": "../srcdata/Computation/pandas/pandas/tests/indexes/numeric/test_setops.py", "method_code_mask": "from datetime import datetime\nfrom datetime import timedelta\nimport numpy as np\nimport pytest\nimport pandas._testing as tm\nfrom pandas.core.indexes.api import Index\nfrom pandas.core.indexes.api import RangeIndex\n\n\n@pytest.fixture\ndef index_large(): [MASK]\n", "response": "from datetime import datetime\nfrom datetime import timedelta\nimport numpy as np\nimport pytest\nimport pandas._testing as tm\nfrom pandas.core.indexes.api import Index\nfrom pandas.core.indexes.api import RangeIndex\n@pytest.fixture\ndef index_large():\n    large = [2 ** 63, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20, 2 ** 63 + 25]\n    return Index(large, dtype=np.uint64)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "comparison_op", "method_path": "../srcdata/Computation/pandas/pandas/core/ops/array_ops.py", "method_code_mask": "from __future__ import annotations\nimport datetime\nfrom functools import partial\nimport operator\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom pandas._libs import NaT\nfrom pandas._libs import Timedelta\nfrom pandas._libs import Timestamp\nfrom pandas._libs import lib\nfrom pandas._libs import ops as libops\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import is_unitless\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_v_string_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.core import roperator\nfrom pandas.core.computation import expressions\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.ops import missing\nfrom pandas.core.ops.dispatch import should_extension_dispatch\nfrom pandas.core.ops.invalid import invalid_comparison\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Shape\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import TimedeltaArray\n\n\ndef comparison_op(left: ArrayLike, right: Any, op) ->ArrayLike: [MASK]\n", "response": "from __future__ import annotations\nimport datetime\nfrom functools import partial\nimport operator\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom pandas._libs import NaT\nfrom pandas._libs import Timedelta\nfrom pandas._libs import Timestamp\nfrom pandas._libs import lib\nfrom pandas._libs import ops as libops\nfrom pandas._libs.tslibs import BaseOffset\nfrom pandas._libs.tslibs import is_unitless\nfrom pandas.core.dtypes.cast import construct_1d_object_array_from_listlike\nfrom pandas.core.dtypes.cast import find_common_type\nfrom pandas.core.dtypes.common import ensure_object\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_list_like\nfrom pandas.core.dtypes.common import is_numeric_v_string_like\nfrom pandas.core.dtypes.common import is_object_dtype\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.generic import ABCExtensionArray\nfrom pandas.core.dtypes.generic import ABCIndex\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.dtypes.missing import isna\nfrom pandas.core.dtypes.missing import notna\nfrom pandas.core import roperator\nfrom pandas.core.computation import expressions\nfrom pandas.core.construction import ensure_wrapped_if_datetimelike\nfrom pandas.core.ops import missing\nfrom pandas.core.ops.dispatch import should_extension_dispatch\nfrom pandas.core.ops.invalid import invalid_comparison\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import Shape\nfrom pandas.core.arrays import DatetimeArray\nfrom pandas.core.arrays import TimedeltaArray\ndef comparison_op(left: ArrayLike, right: Any, op) ->ArrayLike:\n    \"\"\"\n    Evaluate a comparison operation `=`, `!=`, `>=`, `>`, `<=`, or `<`.\n\n    Note: the caller is responsible for ensuring that numpy warnings are\n    suppressed (with np.errstate(all=\"ignore\")) if needed.\n\n    Parameters\n    ----------\n    left : np.ndarray or ExtensionArray\n    right : object\n        Cannot be a DataFrame, Series, or Index.\n    op : {operator.eq, operator.ne, operator.gt, operator.ge, operator.lt, operator.le}\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n    \"\"\"\n    lvalues = ensure_wrapped_if_datetimelike(left)\n    rvalues = ensure_wrapped_if_datetimelike(right)\n    rvalues = lib.item_from_zerodim(rvalues)\n    if isinstance(rvalues, list):\n        rvalues = np.asarray(rvalues)\n    if isinstance(rvalues, (np.ndarray, ABCExtensionArray)):\n        if len(lvalues) != len(rvalues):\n            raise ValueError('Lengths must match to compare', lvalues.shape,\n                rvalues.shape)\n    if should_extension_dispatch(lvalues, rvalues) or (isinstance(rvalues,\n        (Timedelta, BaseOffset, Timestamp)) or right is NaT\n        ) and lvalues.dtype != object:\n        res_values = op(lvalues, rvalues)\n    elif is_scalar(rvalues) and isna(rvalues):\n        if op is operator.ne:\n            res_values = np.ones(lvalues.shape, dtype=bool)\n        else:\n            res_values = np.zeros(lvalues.shape, dtype=bool)\n    elif is_numeric_v_string_like(lvalues, rvalues):\n        return invalid_comparison(lvalues, rvalues, op)\n    elif lvalues.dtype == object or isinstance(rvalues, str):\n        res_values = comp_method_OBJECT_ARRAY(op, lvalues, rvalues)\n    else:\n        res_values = _na_arithmetic_op(lvalues, rvalues, op, is_cmp=True)\n    return res_values"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "min_fitting_element", "method_path": "../srcdata/Computation/pandas/pandas/core/indexes/range.py", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom datetime import timedelta\nimport operator\nfrom sys import getsizeof\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom pandas._libs import index as libindex\nfrom pandas._libs import lib\nfrom pandas._libs.lib import no_default\nfrom pandas.compat.numpy import function as nv\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.base import ExtensionDtype\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import ensure_python_int\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.generic import ABCTimedeltaIndex\nfrom pandas.core import ops\nimport pandas.core.common as com\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import check_array_indexer\nimport pandas.core.indexes.base as ibase\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.ops.common import unpack_zerodim_and_defer\nfrom pandas._typing import Axis\nfrom pandas._typing import Dtype\nfrom pandas._typing import JoinHow\nfrom pandas._typing import NaPosition\nfrom pandas._typing import npt\nfrom pandas import Series\n\n\ndef min_fitting_element(start: int, step: int, lower_limit: int) ->int: [MASK]\n", "response": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom datetime import timedelta\nimport operator\nfrom sys import getsizeof\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom pandas._libs import index as libindex\nfrom pandas._libs import lib\nfrom pandas._libs.lib import no_default\nfrom pandas.compat.numpy import function as nv\nfrom pandas.util._decorators import cache_readonly\nfrom pandas.util._decorators import doc\nfrom pandas.core.dtypes.base import ExtensionDtype\nfrom pandas.core.dtypes.common import ensure_platform_int\nfrom pandas.core.dtypes.common import ensure_python_int\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import is_signed_integer_dtype\nfrom pandas.core.dtypes.generic import ABCTimedeltaIndex\nfrom pandas.core import ops\nimport pandas.core.common as com\nfrom pandas.core.construction import extract_array\nfrom pandas.core.indexers import check_array_indexer\nimport pandas.core.indexes.base as ibase\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.ops.common import unpack_zerodim_and_defer\nfrom pandas._typing import Axis\nfrom pandas._typing import Dtype\nfrom pandas._typing import JoinHow\nfrom pandas._typing import NaPosition\nfrom pandas._typing import npt\nfrom pandas import Series\ndef min_fitting_element(start: int, step: int, lower_limit: int) ->int:\n    \"\"\"Returns the smallest element greater than or equal to the limit\"\"\"\n    no_steps = -(-(lower_limit - start) // abs(step))\n    return start + abs(step) * no_steps"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_parse_latex_css_conversion", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef _parse_latex_css_conversion(styles: CSSList) ->CSSList: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef _parse_latex_css_conversion(styles: CSSList) ->CSSList:\n    \"\"\"\n    Convert CSS (attribute,value) pairs to equivalent LaTeX (command,options) pairs.\n\n    Ignore conversion if tagged with `--latex` option, skipped if no conversion found.\n    \"\"\"\n\n    def font_weight(value, arg) ->(tuple[str, str] | None):\n        if value in ('bold', 'bolder'):\n            return 'bfseries', f'{arg}'\n        return None\n\n    def font_style(value, arg) ->(tuple[str, str] | None):\n        if value == 'italic':\n            return 'itshape', f'{arg}'\n        if value == 'oblique':\n            return 'slshape', f'{arg}'\n        return None\n\n    def color(value, user_arg, command, comm_arg):\n        \"\"\"\n        CSS colors have 5 formats to process:\n\n         - 6 digit hex code: \"#ff23ee\"     --> [HTML]{FF23EE}\n         - 3 digit hex code: \"#f0e\"        --> [HTML]{FF00EE}\n         - rgba: rgba(128, 255, 0, 0.5)    --> [rgb]{0.502, 1.000, 0.000}\n         - rgb: rgb(128, 255, 0,)          --> [rbg]{0.502, 1.000, 0.000}\n         - string: red                     --> {red}\n\n        Additionally rgb or rgba can be expressed in % which is also parsed.\n        \"\"\"\n        arg = user_arg if user_arg != '' else comm_arg\n        if value[0] == '#' and len(value) == 7:\n            return command, f'[HTML]{{{value[1:].upper()}}}{arg}'\n        if value[0] == '#' and len(value) == 4:\n            val = (\n                f'{value[1].upper() * 2}{value[2].upper() * 2}{value[3].upper() * 2}'\n                )\n            return command, f'[HTML]{{{val}}}{arg}'\n        elif value[:3] == 'rgb':\n            r = re.findall('(?<=\\\\()[0-9\\\\s%]+(?=,)', value)[0].strip()\n            r = float(r[:-1]) / 100 if '%' in r else int(r) / 255\n            g = re.findall('(?<=,)[0-9\\\\s%]+(?=,)', value)[0].strip()\n            g = float(g[:-1]) / 100 if '%' in g else int(g) / 255\n            if value[3] == 'a':\n                b = re.findall('(?<=,)[0-9\\\\s%]+(?=,)', value)[1].strip()\n            else:\n                b = re.findall('(?<=,)[0-9\\\\s%]+(?=\\\\))', value)[0].strip()\n            b = float(b[:-1]) / 100 if '%' in b else int(b) / 255\n            return command, f'[rgb]{{{r:.3f}, {g:.3f}, {b:.3f}}}{arg}'\n        else:\n            return command, f'{{{value}}}{arg}'\n    CONVERTED_ATTRIBUTES: dict[str, Callable] = {'font-weight': font_weight,\n        'background-color': partial(color, command='cellcolor', comm_arg=\n        '--lwrap'), 'color': partial(color, command='color', comm_arg=''),\n        'font-style': font_style}\n    latex_styles: CSSList = []\n    for attribute, value in styles:\n        if isinstance(value, str) and '--latex' in value:\n            latex_styles.append((attribute, value.replace('--latex', '')))\n        if attribute in CONVERTED_ATTRIBUTES:\n            arg = ''\n            for x in ['--wrap', '--nowrap', '--lwrap', '--dwrap', '--rwrap']:\n                if x in str(value):\n                    arg, value = x, _parse_latex_options_strip(value, x)\n                    break\n            latex_style = CONVERTED_ATTRIBUTES[attribute](value, arg)\n            if latex_style is not None:\n                latex_styles.extend([latex_style])\n    return latex_styles"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "as_json_table_type", "method_path": "../srcdata/Computation/pandas/pandas/io/json/_table_schema.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import timezones\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas import DataFrame\nimport pandas.core.common as com\nfrom pandas.tseries.frequencies import to_offset\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import JSONSerializable\nfrom pandas import Series\nfrom pandas.core.indexes.multi import MultiIndex\n\n\ndef as_json_table_type(x: DtypeObj) ->str: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import cast\nimport warnings\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import timezones\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.base import _registry as registry\nfrom pandas.core.dtypes.common import is_bool_dtype\nfrom pandas.core.dtypes.common import is_integer_dtype\nfrom pandas.core.dtypes.common import is_numeric_dtype\nfrom pandas.core.dtypes.common import is_string_dtype\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.dtypes.dtypes import DatetimeTZDtype\nfrom pandas.core.dtypes.dtypes import ExtensionDtype\nfrom pandas.core.dtypes.dtypes import PeriodDtype\nfrom pandas import DataFrame\nimport pandas.core.common as com\nfrom pandas.tseries.frequencies import to_offset\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import JSONSerializable\nfrom pandas import Series\nfrom pandas.core.indexes.multi import MultiIndex\ndef as_json_table_type(x: DtypeObj) ->str:\n    \"\"\"\n    Convert a NumPy / pandas type to its corresponding json_table.\n\n    Parameters\n    ----------\n    x : np.dtype or ExtensionDtype\n\n    Returns\n    -------\n    str\n        the Table Schema data types\n\n    Notes\n    -----\n    This table shows the relationship between NumPy / pandas dtypes,\n    and Table Schema dtypes.\n\n    ==============  =================\n    Pandas type     Table Schema type\n    ==============  =================\n    int64           integer\n    float64         number\n    bool            boolean\n    datetime64[ns]  datetime\n    timedelta64[ns] duration\n    object          str\n    categorical     any\n    =============== =================\n    \"\"\"\n    if is_integer_dtype(x):\n        return 'integer'\n    elif is_bool_dtype(x):\n        return 'boolean'\n    elif is_numeric_dtype(x):\n        return 'number'\n    elif lib.is_np_dtype(x, 'M') or isinstance(x, (DatetimeTZDtype,\n        PeriodDtype)):\n        return 'datetime'\n    elif lib.is_np_dtype(x, 'm'):\n        return 'duration'\n    elif isinstance(x, ExtensionDtype):\n        return 'any'\n    elif is_string_dtype(x):\n        return 'string'\n    else:\n        return 'any'"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "ensure_dtype_objs", "method_path": "../srcdata/Computation/pandas/pandas/io/parsers/c_parser_wrapper.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import parsers\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import DtypeWarning\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.concat import union_categoricals\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.indexes.api import ensure_index_from_sequences\nfrom pandas.io.common import dedup_names\nfrom pandas.io.common import is_potential_multi_index\nfrom pandas.io.parsers.base_parser import ParserBase\nfrom pandas.io.parsers.base_parser import ParserError\nfrom pandas.io.parsers.base_parser import is_index_col\nfrom collections.abc import Hashable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeArg\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import ReadCsvBuffer\nfrom pandas import Index\nfrom pandas import MultiIndex\n\n\ndef ensure_dtype_objs(dtype: (DtypeArg | dict[Hashable, DtypeArg] | None)) ->(\n    DtypeObj | dict[Hashable, DtypeObj] | None): [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING\nimport warnings\nimport numpy as np\nfrom pandas._libs import lib\nfrom pandas._libs import parsers\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.errors import DtypeWarning\nfrom pandas.util._exceptions import find_stack_level\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.concat import union_categoricals\nfrom pandas.core.dtypes.dtypes import CategoricalDtype\nfrom pandas.core.indexes.api import ensure_index_from_sequences\nfrom pandas.io.common import dedup_names\nfrom pandas.io.common import is_potential_multi_index\nfrom pandas.io.parsers.base_parser import ParserBase\nfrom pandas.io.parsers.base_parser import ParserError\nfrom pandas.io.parsers.base_parser import is_index_col\nfrom collections.abc import Hashable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom pandas._typing import AnyArrayLike\nfrom pandas._typing import ArrayLike\nfrom pandas._typing import DtypeArg\nfrom pandas._typing import DtypeObj\nfrom pandas._typing import ReadCsvBuffer\nfrom pandas import Index\nfrom pandas import MultiIndex\ndef ensure_dtype_objs(dtype: (DtypeArg | dict[Hashable, DtypeArg] | None)) ->(\n    DtypeObj | dict[Hashable, DtypeObj] | None):\n    \"\"\"\n    Ensure we have either None, a dtype object, or a dictionary mapping to\n    dtype objects.\n    \"\"\"\n    if isinstance(dtype, defaultdict):\n        default_dtype = pandas_dtype(dtype.default_factory())\n        dtype_converted: defaultdict = defaultdict(lambda : default_dtype)\n        for key in dtype.keys():\n            dtype_converted[key] = pandas_dtype(dtype[key])\n        return dtype_converted\n    elif isinstance(dtype, dict):\n        return {k: pandas_dtype(dtype[k]) for k in dtype}\n    elif dtype is not None:\n        return pandas_dtype(dtype)\n    return dtype"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "skip_if_no", "method_path": "../srcdata/Computation/pandas/pandas/util/_test_decorators.py", "method_code_mask": "from __future__ import annotations\nimport locale\nfrom typing import TYPE_CHECKING\nimport pytest\nfrom collections.abc import Callable\nfrom pandas._typing import F\nfrom pandas.compat import IS64\nfrom pandas.compat import is_platform_windows\nfrom pandas.compat._optional import import_optional_dependency\n\n\ndef skip_if_no(package: str, min_version: (str | None)=None\n    ) ->pytest.MarkDecorator: [MASK]\n", "response": "from __future__ import annotations\nimport locale\nfrom typing import TYPE_CHECKING\nimport pytest\nfrom collections.abc import Callable\nfrom pandas._typing import F\nfrom pandas.compat import IS64\nfrom pandas.compat import is_platform_windows\nfrom pandas.compat._optional import import_optional_dependency\ndef skip_if_no(package: str, min_version: (str | None)=None\n    ) ->pytest.MarkDecorator:\n    \"\"\"\n    Generic function to help skip tests when required packages are not\n    present on the testing system.\n\n    This function returns a pytest mark with a skip condition that will be\n    evaluated during test collection. An attempt will be made to import the\n    specified ``package`` and optionally ensure it meets the ``min_version``\n\n    The mark can be used as either a decorator for a test class or to be\n    applied to parameters in pytest.mark.parametrize calls or parametrized\n    fixtures. Use pytest.importorskip if an imported moduled is later needed\n    or for test functions.\n\n    If the import and version check are unsuccessful, then the test function\n    (or test case when used in conjunction with parametrization) will be\n    skipped.\n\n    Parameters\n    ----------\n    package: str\n        The name of the required package.\n    min_version: str or None, default None\n        Optional minimum version of the package.\n\n    Returns\n    -------\n    pytest.MarkDecorator\n        a pytest.mark.skipif to use as either a test decorator or a\n        parametrization mark.\n    \"\"\"\n    msg = f\"Could not import '{package}'\"\n    if min_version:\n        msg += f' satisfying a min_version of {min_version}'\n    return pytest.mark.skipif(not bool(import_optional_dependency(package,\n        errors='ignore', min_version=min_version)), reason=msg)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "_get_level_lengths", "method_path": "../srcdata/Computation/pandas/pandas/io/formats/style_render.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\n\n\ndef _get_level_lengths(index: Index, sparsify: bool, max_index: int,\n    hidden_elements: (Sequence[int] | None)=None): [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Callable\nfrom collections.abc import Sequence\nfrom functools import partial\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import DefaultDict\nfrom typing import Optional\nfrom typing import TypedDict\nfrom typing import Union\nfrom uuid import uuid4\nimport numpy as np\nfrom pandas._config import get_option\nfrom pandas._libs import lib\nfrom pandas.compat._optional import import_optional_dependency\nfrom pandas.core.dtypes.common import is_complex\nfrom pandas.core.dtypes.common import is_float\nfrom pandas.core.dtypes.common import is_integer\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import isna\nfrom pandas.api.types import is_list_like\nimport pandas.core.common as com\nfrom pandas._typing import Axis\nfrom pandas._typing import Level\nfrom markupsafe import escape as escape_html\ndef _get_level_lengths(index: Index, sparsify: bool, max_index: int,\n    hidden_elements: (Sequence[int] | None)=None):\n    \"\"\"\n    Given an index, find the level length for each element.\n\n    Parameters\n    ----------\n    index : Index\n        Index or columns to determine lengths of each element\n    sparsify : bool\n        Whether to hide or show each distinct element in a MultiIndex\n    max_index : int\n        The maximum number of elements to analyse along the index due to trimming\n    hidden_elements : sequence of int\n        Index positions of elements hidden from display in the index affecting\n        length\n\n    Returns\n    -------\n    Dict :\n        Result is a dictionary of (level, initial_position): span\n    \"\"\"\n    if isinstance(index, MultiIndex):\n        levels = index._format_multi(sparsify=lib.no_default, include_names\n            =False)\n    else:\n        levels = index._format_flat(include_name=False)\n    if hidden_elements is None:\n        hidden_elements = []\n    lengths = {}\n    if not isinstance(index, MultiIndex):\n        for i, value in enumerate(levels):\n            if i not in hidden_elements:\n                lengths[0, i] = 1\n        return lengths\n    for i, lvl in enumerate(levels):\n        visible_row_count = 0\n        for j, row in enumerate(lvl):\n            if visible_row_count > max_index:\n                break\n            if not sparsify:\n                if j not in hidden_elements:\n                    lengths[i, j] = 1\n                    visible_row_count += 1\n            elif row is not lib.no_default and j not in hidden_elements:\n                last_label = j\n                lengths[i, last_label] = 1\n                visible_row_count += 1\n            elif row is not lib.no_default:\n                last_label = j\n                lengths[i, last_label] = 0\n            elif j not in hidden_elements:\n                visible_row_count += 1\n                if visible_row_count > max_index:\n                    break\n                if lengths[i, last_label] == 0:\n                    last_label = j\n                    lengths[i, last_label] = 1\n                else:\n                    lengths[i, last_label] += 1\n    non_zero_lengths = {element: length for element, length in lengths.\n        items() if length >= 1}\n    return non_zero_lengths"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "round_trip_pickle", "method_path": "../srcdata/Computation/pandas/pandas/_testing/_io.py", "method_code_mask": "from __future__ import annotations\nimport gzip\nimport io\nimport pathlib\nimport tarfile\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport uuid\nimport zipfile\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas._testing.contexts import ensure_clean\nfrom collections.abc import Callable\nfrom pandas._typing import FilePath\nfrom pandas._typing import ReadPickleBuffer\nfrom pandas import DataFrame\nfrom pandas import Series\nimport bz2\nimport lzma\n\n\ndef round_trip_pickle(obj: Any, path: (FilePath | ReadPickleBuffer | None)=None\n    ) ->(DataFrame | Series): [MASK]\n", "response": "from __future__ import annotations\nimport gzip\nimport io\nimport pathlib\nimport tarfile\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport uuid\nimport zipfile\nfrom pandas.compat._optional import import_optional_dependency\nimport pandas as pd\nfrom pandas._testing.contexts import ensure_clean\nfrom collections.abc import Callable\nfrom pandas._typing import FilePath\nfrom pandas._typing import ReadPickleBuffer\nfrom pandas import DataFrame\nfrom pandas import Series\nimport bz2\nimport lzma\ndef round_trip_pickle(obj: Any, path: (FilePath | ReadPickleBuffer | None)=None\n    ) ->(DataFrame | Series):\n    \"\"\"\n    Pickle an object and then read it again.\n\n    Parameters\n    ----------\n    obj : any object\n        The object to pickle and then re-read.\n    path : str, path object or file-like object, default None\n        The path where the pickled object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was pickled and then re-read.\n    \"\"\"\n    _path = path\n    if _path is None:\n        _path = f'__{uuid.uuid4()}__.pickle'\n    with ensure_clean(_path) as temp_path:\n        pd.to_pickle(obj, temp_path)\n        return pd.read_pickle(temp_path)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "timedelta_range", "method_path": "../srcdata/Computation/pandas/pandas/core/indexes/timedeltas.py", "method_code_mask": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom pandas._libs import index as libindex\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import Resolution\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import to_offset\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\nimport pandas.core.common as com\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.indexes.datetimelike import DatetimeTimedeltaMixin\nfrom pandas.core.indexes.extension import inherit_names\nfrom pandas._libs import NaTType\nfrom pandas._typing import DtypeObj\n\n\ndef timedelta_range(start=None, end=None, periods: (int | None)=None, freq=\n    None, name=None, closed=None, *, unit: (str | None)=None\n    ) ->TimedeltaIndex: [MASK]\n", "response": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom pandas._libs import index as libindex\nfrom pandas._libs import lib\nfrom pandas._libs.tslibs import Resolution\nfrom pandas._libs.tslibs import Timedelta\nfrom pandas._libs.tslibs import to_offset\nfrom pandas.core.dtypes.common import is_scalar\nfrom pandas.core.dtypes.common import pandas_dtype\nfrom pandas.core.dtypes.generic import ABCSeries\nfrom pandas.core.arrays.timedeltas import TimedeltaArray\nimport pandas.core.common as com\nfrom pandas.core.indexes.base import Index\nfrom pandas.core.indexes.base import maybe_extract_name\nfrom pandas.core.indexes.datetimelike import DatetimeTimedeltaMixin\nfrom pandas.core.indexes.extension import inherit_names\nfrom pandas._libs import NaTType\nfrom pandas._typing import DtypeObj\ndef timedelta_range(start=None, end=None, periods: (int | None)=None, freq=\n    None, name=None, closed=None, *, unit: (str | None)=None) ->TimedeltaIndex:\n    \"\"\"\n    Return a fixed frequency TimedeltaIndex with day as the default.\n\n    Parameters\n    ----------\n    start : str or timedelta-like, default None\n        Left bound for generating timedeltas.\n    end : str or timedelta-like, default None\n        Right bound for generating timedeltas.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str, Timedelta, datetime.timedelta, or DateOffset, default 'D'\n        Frequency strings can have multiples, e.g. '5h'.\n    name : str, default None\n        Name of the resulting TimedeltaIndex.\n    closed : str, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None).\n    unit : str, default None\n        Specify the desired resolution of the result.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    TimedeltaIndex\n        Fixed frequency, with day as the default.\n\n    See Also\n    --------\n    date_range : Return a fixed frequency DatetimeIndex.\n    period_range : Return a fixed frequency PeriodIndex.\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``TimedeltaIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end`` (closed on both sides).\n\n    To learn more about the frequency strings, please see\n    :ref:`this link<timeseries.offset_aliases>`.\n\n    Examples\n    --------\n    >>> pd.timedelta_range(start=\"1 day\", periods=4)\n    TimedeltaIndex(['1 days', '2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``closed`` parameter specifies which endpoint is included.  The default\n    behavior is to include both endpoints.\n\n    >>> pd.timedelta_range(start=\"1 day\", periods=4, closed=\"right\")\n    TimedeltaIndex(['2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``freq`` parameter specifies the frequency of the TimedeltaIndex.\n    Only fixed frequencies can be passed, non-fixed frequencies such as\n    'M' (month end) will raise.\n\n    >>> pd.timedelta_range(start=\"1 day\", end=\"2 days\", freq=\"6h\")\n    TimedeltaIndex(['1 days 00:00:00', '1 days 06:00:00', '1 days 12:00:00',\n                    '1 days 18:00:00', '2 days 00:00:00'],\n                   dtype='timedelta64[ns]', freq='6h')\n\n    Specify ``start``, ``end``, and ``periods``; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.timedelta_range(start=\"1 day\", end=\"5 days\", periods=4)\n    TimedeltaIndex(['1 days 00:00:00', '2 days 08:00:00', '3 days 16:00:00',\n                    '5 days 00:00:00'],\n                   dtype='timedelta64[ns]', freq=None)\n\n    **Specify a unit**\n\n    >>> pd.timedelta_range(\"1 Day\", periods=3, freq=\"100000D\", unit=\"s\")\n    TimedeltaIndex(['1 days', '100001 days', '200001 days'],\n                   dtype='timedelta64[s]', freq='100000D')\n    \"\"\"\n    if freq is None and com.any_none(periods, start, end):\n        freq = 'D'\n    freq = to_offset(freq)\n    tdarr = TimedeltaArray._generate_range(start, end, periods, freq,\n        closed=closed, unit=unit)\n    return TimedeltaIndex._simple_new(tdarr, name=name)"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.groupby", "method_path": "../srcdata/Computation/pandas/pandas/tests/resample/test_resample_api.py", "method_code_mask": "from datetime import datetime\nimport re\nimport numpy as np\nimport pytest\nfrom pandas._libs import lib\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import NamedAgg\nfrom pandas import Series\nimport pandas._testing as tm\nfrom pandas.core.indexes.datetimes import date_range\n\n\n@pytest.fixture\ndef df(index): [MASK]\n", "response": "from datetime import datetime\nimport re\nimport numpy as np\nimport pytest\nfrom pandas._libs import lib\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import NamedAgg\nfrom pandas import Series\nimport pandas._testing as tm\nfrom pandas.core.indexes.datetimes import date_range\n@pytest.fixture\ndef df(index):\n    frame = DataFrame(np.random.default_rng(2).random((10, 2)), columns=\n        list('AB'), index=index)\n    return frame"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "left.join", "method_path": "../srcdata/Computation/pandas/pandas/tests/reshape/merge/test_multi.py", "method_code_mask": "import numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import merge\n\n\n@pytest.fixture\ndef left(): [MASK]\n", "response": "import numpy as np\nimport pytest\nimport pandas.util._test_decorators as td\nimport pandas as pd\nfrom pandas import DataFrame\nfrom pandas import Index\nfrom pandas import MultiIndex\nfrom pandas import RangeIndex\nfrom pandas import Series\nfrom pandas import Timestamp\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.core.reshape.concat import concat\nfrom pandas.core.reshape.merge import merge\n@pytest.fixture\ndef left():\n    \"\"\"left dataframe (not multi-indexed) for multi-index join tests\"\"\"\n    key1 = ['bar', 'bar', 'bar', 'foo', 'foo', 'baz', 'baz', 'qux', 'qux',\n        'snap']\n    key2 = ['two', 'one', 'three', 'one', 'two', 'one', 'two', 'two',\n        'three', 'one']\n    data = np.random.default_rng(2).standard_normal(len(key1))\n    return DataFrame({'key1': key1, 'key2': key2, 'data': data})"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.style.format", "method_path": "../srcdata/Computation/pandas/pandas/tests/io/formats/style/test_format.py", "method_code_mask": "import numpy as np\nimport pytest\nfrom pandas import NA\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import NaT\nfrom pandas import Timestamp\nfrom pandas import option_context\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _str_escape\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "import numpy as np\nimport pytest\nfrom pandas import NA\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import NaT\nfrom pandas import Timestamp\nfrom pandas import option_context\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _str_escape\n@pytest.fixture\ndef df():\n    return DataFrame(data=[[0, -0.609], [1, -1.228]], columns=['A', 'B'],\n        index=['x', 'y'])"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "df.style._translate", "method_path": "../srcdata/Computation/pandas/pandas/tests/io/formats/style/test_style.py", "method_code_mask": "import contextlib\nimport copy\nimport re\nfrom textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _get_level_lengths\nfrom pandas.io.formats.style_render import _get_trimming_maximums\nfrom pandas.io.formats.style_render import maybe_convert_css_to_tuples\nfrom pandas.io.formats.style_render import non_reducing_slice\n\n\n@pytest.fixture\ndef df(): [MASK]\n", "response": "import contextlib\nimport copy\nimport re\nfrom textwrap import dedent\nimport numpy as np\nimport pytest\nfrom pandas import DataFrame\nfrom pandas import IndexSlice\nfrom pandas import MultiIndex\nfrom pandas import Series\nfrom pandas import option_context\nimport pandas._testing as tm\nfrom pandas.io.formats.style import Styler\nfrom pandas.io.formats.style_render import _get_level_lengths\nfrom pandas.io.formats.style_render import _get_trimming_maximums\nfrom pandas.io.formats.style_render import maybe_convert_css_to_tuples\nfrom pandas.io.formats.style_render import non_reducing_slice\n@pytest.fixture\ndef df():\n    df = DataFrame({'A': [0, 1], 'B': np.random.default_rng(2).\n        standard_normal(2)})\n    return df"}
{"result": "passed", "model_name": "std", "repository": "pandas", "full_method_name": "option_context", "method_path": "../srcdata/Computation/pandas/pandas/_config/config.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\n\n\n@contextmanager\ndef option_context(*args) ->Generator[None, None, None]: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import contextmanager\nimport re\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import cast\nimport warnings\nfrom pandas._typing import F\nfrom pandas.util._exceptions import find_stack_level\nfrom collections.abc import Callable\nfrom collections.abc import Generator\nfrom collections.abc import Sequence\nimport keyword\nimport tokenize\n@contextmanager\ndef option_context(*args) ->Generator[None, None, None]:\n    \"\"\"\n    Context manager to temporarily set options in a ``with`` statement.\n\n    Parameters\n    ----------\n    *args : str | object\n        An even amount of arguments provided in pairs which will be\n        interpreted as (pattern, value) pairs.\n\n    Returns\n    -------\n    None\n        No return value.\n\n    See Also\n    --------\n    get_option : Retrieve the value of the specified option.\n    set_option : Set the value of the specified option.\n    reset_option : Reset one or more options to their default value.\n    describe_option : Print the description for one or more registered options.\n\n    Notes\n    -----\n    For all available options, please view the :ref:`User Guide <options.available>`\n    or use ``pandas.describe_option()``.\n\n    Examples\n    --------\n    >>> from pandas import option_context\n    >>> with option_context(\"display.max_rows\", 10, \"display.max_columns\", 5):\n    ...     pass\n    \"\"\"\n    if len(args) % 2 != 0 or len(args) < 2:\n        raise ValueError(\n            'Provide an even amount of arguments as option_context(pat, val, pat, val...).'\n            )\n    ops = tuple(zip(args[::2], args[1::2]))\n    try:\n        undo = tuple((pat, get_option(pat)) for pat, val in ops)\n        for pat, val in ops:\n            set_option(pat, val)\n        yield\n    finally:\n        for pat, val in undo:\n            set_option(pat, val)"}
