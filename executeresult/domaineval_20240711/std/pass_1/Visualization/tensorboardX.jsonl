{"result": "passed", "model_name": "std", "repository": "tensorboardX", "full_method_name": "make_valid_tf_name", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/record_writer.py", "method_code_mask": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\n\n\ndef make_valid_tf_name(name): [MASK]\n", "response": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\ndef make_valid_tf_name(name):\n    if not _VALID_OP_NAME_START.match(name):\n        name = '.' + name\n    return '_'.join(_VALID_OP_NAME_PART.findall(name))"}
{"result": "passed", "model_name": "std", "repository": "tensorboardX", "full_method_name": "_prepare_video", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/utils.py", "method_code_mask": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\n\n\ndef _prepare_video(V): [MASK]\n", "response": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\ndef _prepare_video(V):\n    import numpy as np\n    b, t, c, h, w = V.shape\n    if V.dtype == np.uint8:\n        V = np.float32(V) / 255.0\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n    if not is_power2(V.shape[0]):\n        len_addition = int(2 ** V.shape[0].bit_length() - V.shape[0])\n        V = np.concatenate((V, np.zeros(shape=(len_addition, t, c, h, w))),\n            axis=0)\n    n_rows = 2 ** ((b.bit_length() - 1) // 2)\n    n_cols = V.shape[0] // n_rows\n    V = np.reshape(V, newshape=(n_rows, n_cols, t, c, h, w))\n    V = np.transpose(V, axes=(2, 0, 4, 1, 5, 3))\n    V = np.reshape(V, newshape=(t, n_rows * h, n_cols * w, c))\n    return V"}
{"result": "passed", "model_name": "std", "repository": "tensorboardX", "full_method_name": "make_np", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/x2num.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\n\n\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\n\n\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\n\n\ndef make_np(x): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\ndef make_np(x):\n    if isinstance(x, list):\n        return check_nan(np.array(x))\n    if isinstance(x, np.ndarray):\n        return check_nan(x)\n    if isinstance(x, str):\n        return check_nan(prepare_caffe2(x))\n    if np.isscalar(x):\n        return check_nan(np.array([x]))\n    if 'torch' in str(type(x)):\n        return check_nan(prepare_pytorch(x))\n    if 'chainer' in str(type(x)):\n        return check_nan(prepare_chainer(x))\n    if 'mxnet' in str(type(x)):\n        return check_nan(prepare_mxnet(x))\n    if 'jax' in str(type(x)):\n        return check_nan(np.array(x))\n    raise NotImplementedError(\n        'Got {}, but expected numpy array or torch tensor.'.format(type(x)))"}
