{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef ci_to_errsize(cis, heights):\n    \"\"\"Convert intervals to error arguments relative to plot heights.\n\n    Parameters\n    ----------\n    cis : 2 x n sequence\n        sequence of confidence interval limits\n    heights : n sequence\n        sequence of plot heights\n\n    Returns\n    -------\n    errsize : 2 x n array\n        sequence of error size relative to height values in correct\n        format as argument for plt.bar\n\n    \"\"\"\n    cis = np.atleast_2d(cis).reshape(2, -1)\n    heights = np.atleast_1d(heights)\n    errsize = []\n    for i, (low, high) in enumerate(np.transpose(cis)):\n        h = heights[i]\n        elow = h - low\n        ehigh = high - h\n        errsize.append([elow, ehigh])\n    errsize = np.asarray(errsize).T\n    return errsize"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef relative_luminance(color):\n    \"\"\"Calculate the relative luminance of a color according to W3C standards\n\n    Parameters\n    ----------\n    color : matplotlib color or sequence of matplotlib colors\n        Hex code, rgb-tuple, or html color name.\n\n    Returns\n    -------\n    luminance : float(s) between 0 and 1\n\n    \"\"\"\n    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]\n    rgb = np.where(rgb <= 0.03928, rgb / 12.92, ((rgb + 0.055) / 1.055) ** 2.4)\n    lum = rgb.dot([0.2126, 0.7152, 0.0722])\n    try:\n        return lum.item()\n    except ValueError:\n        return lum"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, log_scale=log_scale)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    if not p.univariate:\n        raise NotImplementedError('Bivariate ECDF plots are not implemented')\n    estimate_kws = dict(stat=stat, complementary=complementary)\n    p.plot_univariate_ecdf(estimate_kws=estimate_kws, legend=legend, **kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef categorical_order(vector, order=None):\n    \"\"\"Return a list of unique data values.\n\n    Determine an ordered list of levels in ``values``.\n\n    Parameters\n    ----------\n    vector : list, array, Categorical, or Series\n        Vector of \"categorical\" values\n    order : list-like, optional\n        Desired order of category levels to override the order determined\n        from the ``values`` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is None:\n        if hasattr(vector, 'categories'):\n            order = vector.categories\n        else:\n            try:\n                order = vector.cat.categories\n            except (TypeError, AttributeError):\n                order = pd.Series(vector).unique()\n                if variable_type(vector) == 'numeric':\n                    order = np.sort(order)\n        order = filter(pd.notnull, order)\n    return list(order)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Return booleans for whether the x and y ticklabels on an Axes overlap.\n    Parameters\n    ----------\n    ax : matplotlib Axes\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        True when the labels on that axis overlap.\n    \"\"\"\n    return axis_ticklabels_overlap(ax.get_xticklabels()\n        ), axis_ticklabels_overlap(ax.get_yticklabels())"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef locator_to_legend_entries(locator, limits, dtype):\n    \"\"\"Return levels and formatted levels for brief numeric legends.\"\"\"\n    raw_levels = locator.tick_values(*limits).astype(dtype)\n    raw_levels = [l for l in raw_levels if l >= limits[0] and l <= limits[1]]\n\n\n    class dummy_axis:\n\n        def get_view_interval(self):\n            return limits\n    if isinstance(locator, mpl.ticker.LogLocator):\n        formatter = mpl.ticker.LogFormatter()\n    else:\n        formatter = mpl.ticker.ScalarFormatter()\n        formatter.set_useOffset(False)\n        formatter.set_scientific(False)\n    formatter.axis = dummy_axis()\n    formatted_levels = formatter.format_ticks(raw_levels)\n    return raw_levels, formatted_levels"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef move_legend(obj, loc, **kwargs):\n    \"\"\"\n    Recreate a plot's legend at a new location.\n\n    The name is a slight misnomer. Matplotlib legends do not expose public\n    control over their position parameters. So this function creates a new legend,\n    copying over the data from the original object, which is then removed.\n\n    Parameters\n    ----------\n    obj : the object with the plot\n        This argument can be either a seaborn or matplotlib object:\n\n        - :class:`seaborn.FacetGrid` or :class:`seaborn.PairGrid`\n        - :class:`matplotlib.axes.Axes` or :class:`matplotlib.figure.Figure`\n\n    loc : str or int\n        Location argument, as in :meth:`matplotlib.axes.Axes.legend`.\n\n    kwargs\n        Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.legend`.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/move_legend.rst\n\n    \"\"\"\n    from seaborn.axisgrid import Grid\n    if isinstance(obj, Grid):\n        old_legend = obj.legend\n        legend_func = obj.figure.legend\n    elif isinstance(obj, mpl.axes.Axes):\n        old_legend = obj.legend_\n        legend_func = obj.legend\n    elif isinstance(obj, mpl.figure.Figure):\n        if obj.legends:\n            old_legend = obj.legends[-1]\n        else:\n            old_legend = None\n        legend_func = obj.legend\n    else:\n        err = (\n            '`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.'\n            )\n        raise TypeError(err)\n    if old_legend is None:\n        err = f'{obj} has no legend attached.'\n        raise ValueError(err)\n    from seaborn._compat import get_legend_handles\n    handles = get_legend_handles(old_legend)\n    labels = [t.get_text() for t in old_legend.get_texts()]\n    if (new_labels := kwargs.pop('labels', None)) is not None:\n        if len(new_labels) != len(labels):\n            err = 'Length of new labels does not match existing legend.'\n            raise ValueError(err)\n        labels = new_labels\n    legend_kws = inspect.signature(mpl.legend.Legend).parameters\n    props = {k: v for k, v in old_legend.properties().items() if k in\n        legend_kws}\n    props.pop('bbox_to_anchor')\n    title = props.pop('title')\n    if 'title' in kwargs:\n        title.set_text(kwargs.pop('title'))\n    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith('title_')}\n    for key, val in title_kwargs.items():\n        title.set(**{key[6:]: val})\n        kwargs.pop(key)\n    kwargs.setdefault('frameon', old_legend.legendPatch.get_visible())\n    props.update(kwargs)\n    old_legend.remove()\n    new_legend = legend_func(handles, labels, loc=loc, **props)\n    new_legend.set_title(title.get_text(), title.get_fontproperties())\n    if isinstance(obj, Grid):\n        obj._legend = new_legend"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _check_argument(param, options, value, prefix=False):\n    \"\"\"Raise if value for param is not in options.\"\"\"\n    if prefix and value is not None:\n        failure = not any(value.startswith(p) for p in options if\n            isinstance(p, str))\n    else:\n        failure = value not in options\n    if failure:\n        raise ValueError(\n            f'The value for `{param}` must be one of {options}, but {repr(value)} was passed.'\n            )\n    return value"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _assign_default_kwargs(kws, call_func, source_func):\n    \"\"\"Assign default kwargs for call_func using values from source_func.\"\"\"\n    needed = inspect.signature(call_func).parameters\n    defaults = inspect.signature(source_func).parameters\n    for param in needed:\n        if param in defaults and param not in kws:\n            kws[param] = defaults[param].default\n    return kws"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _deprecate_ci(errorbar, ci):\n    \"\"\"\n    Warn on usage of ci= and convert to appropriate errorbar= arg.\n\n    ci was deprecated when errorbar was added in 0.12. It should not be removed\n    completely for some time, but it can be moved out of function definitions\n    (and extracted from kwargs) after one cycle.\n\n    \"\"\"\n    if ci is not deprecated and ci != 'deprecated':\n        if ci is None:\n            errorbar = None\n        elif ci == 'sd':\n            errorbar = 'sd'\n        else:\n            errorbar = 'ci', ci\n        msg = f\"\"\"\n\nThe `ci` parameter is deprecated. Use `errorbar={repr(errorbar)}` for the same effect.\n\"\"\"\n        warnings.warn(msg, FutureWarning, stacklevel=3)\n    return errorbar"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    a = kwargs.pop('a', None)\n    axis = kwargs.pop('axis', None)\n    if a is not None:\n        data = a\n        msg = textwrap.dedent(\n            \"\"\"\n\n        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.\n        Please update your code; This will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    if axis is not None:\n        if axis == 'x':\n            x = data\n        elif axis == 'y':\n            y = data\n        data = None\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.\n        Please update your code; this will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    vertical = kwargs.pop('vertical', None)\n    if vertical is not None:\n        if vertical:\n            action_taken = 'assigning data to `y`.'\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = 'assigning data to `x`.'\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    p.plot_rug(height, expand_margins, legend, **kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef desaturate(color, prop):\n    \"\"\"Decrease the saturation channel of a color by some percent.\n\n    Parameters\n    ----------\n    color : matplotlib color\n        hex, rgb-tuple, or html color name\n    prop : float\n        saturation channel of color will be multiplied by this value\n\n    Returns\n    -------\n    new_color : rgb tuple\n        desaturated color code in RGB tuple representation\n\n    \"\"\"\n    if not 0 <= prop <= 1:\n        raise ValueError('prop must be between 0 and 1')\n    rgb = to_rgb(color)\n    if prop == 1:\n        return rgb\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n    s *= prop\n    new_color = colorsys.hls_to_rgb(h, l, s)\n    return new_color"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ):\n    \"\"\"Make a sequential palette that blends from light to ``color``.\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n    If you are using a Jupyter notebook, you can also choose this palette\n    interactively with the :func:`choose_light_palette` function.\n    Parameters\n    ----------\n    color : base color for high values\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    dark_palette : Create a sequential palette with dark low values.\n    diverging_palette : Create a diverging palette with two colors.\n    Examples\n    --------\n    .. include:: ../docstrings/light_palette.rst\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    hue, sat, _ = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = 0.15 * sat, 95\n    gray = _color_to_rgb((hue, gray_s, gray_l), input='husl')\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef unique_markers(n):\n    \"\"\"Build an arbitrarily long list of unique marker styles for points.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique marker specs to generate.\n\n    Returns\n    -------\n    markers : list of string or tuples\n        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.\n        All markers will be filled.\n\n    \"\"\"\n    markers = ['o', 'X', (4, 0, 45), 'P', (4, 0, 0), (4, 1, 0), '^', (4, 1,\n        45), 'v']\n    s = 5\n    while len(markers) < n:\n        a = 360 / (s + 1) / 2\n        markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])\n        s += 1\n    return markers[:n]"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "../srcdata/Visualization/seaborn/seaborn/_compat.py", "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\ndef get_colormap(name):\n    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"\n    try:\n        return mpl.colormaps[name]\n    except AttributeError:\n        return mpl.cm.get_cmap(name)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef unique_dashes(n):\n    \"\"\"Build an arbitrarily long list of unique dash styles for lines.\n\n    Parameters\n    ----------\n    n : int\n        Number of unique dash specs to generate.\n\n    Returns\n    -------\n    dashes : list of strings or tuples\n        Valid arguments for the ``dashes`` parameter on\n        :class:`matplotlib.lines.Line2D`. The first spec is a solid\n        line (``\"\"``), the remainder are sequences of long and short\n        dashes.\n\n    \"\"\"\n    dashes = ['', (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1)]\n    p = 3\n    while len(dashes) < n:\n        a = itertools.combinations_with_replacement([3, 1.25], p)\n        b = itertools.combinations_with_replacement([4, 1], p)\n        segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1])\n            )\n        for segments in segment_list:\n            gap = min(segments)\n            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))\n            dashes.append(spec)\n        p += 1\n    return dashes[:n]"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef variable_type(vector, boolean_type='numeric'):\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in two ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric' or 'categorical'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n    vector = pd.Series(vector)\n    if isinstance(vector.dtype, pd.CategoricalDtype):\n        return VariableType('categorical')\n    if pd.isna(vector).all():\n        return VariableType('numeric')\n    vector = vector.dropna()\n    with warnings.catch_warnings():\n        warnings.simplefilter(action='ignore', category=(FutureWarning,\n            DeprecationWarning))\n        try:\n            if np.isin(vector, [0, 1]).all():\n                return VariableType(boolean_type)\n        except TypeError:\n            pass\n    if pd.api.types.is_numeric_dtype(vector):\n        return VariableType('numeric')\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VariableType('datetime')\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n    if all_numeric(vector):\n        return VariableType('numeric')\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n    if all_datetime(vector):\n        return VariableType('datetime')\n    return VariableType('categorical')"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "palplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/miscplot.py", "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\ndef palplot(pal, size=1):\n    \"\"\"Plot the values in a color palette as a horizontal array.\n\n    Parameters\n    ----------\n    pal : sequence of matplotlib colors\n        colors, i.e. as returned by seaborn.color_palette()\n    size :\n        scaling factor for size of plot\n\n    \"\"\"\n    n = len(pal)\n    _, ax = plt.subplots(1, 1, figsize=(n * size, size))\n    ax.imshow(np.arange(n).reshape(1, n), cmap=mpl.colors.ListedColormap(\n        list(pal)), interpolation='nearest', aspect='auto')\n    ax.set_xticks(np.arange(n) - 0.5)\n    ax.set_yticks([-0.5, 0.5])\n    ax.set_xticklabels(['' for _ in range(n)])\n    ax.yaxis.set_major_locator(ticker.NullLocator())"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "../srcdata/Visualization/seaborn/seaborn/_base.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    \"\"\"Determine how the plot should be oriented based on the data.\n\n    For historical reasons, the convention is to call a plot \"horizontally\"\n    or \"vertically\" oriented based on the axis representing its dependent\n    variable. Practically, this is used when determining the axis for\n    numerical aggregation.\n\n    Parameters\n    ----------\n    x, y : Vector data or None\n        Positional data vectors for the plot.\n    orient : string or None\n        Specified orientation. If not None, can be \"x\" or \"y\", or otherwise\n        must start with \"v\" or \"h\".\n    require_numeric : bool\n        If set, raise when the implied dependent variable is not numeric.\n\n    Returns\n    -------\n    orient : \"x\" or \"y\"\n\n    Raises\n    ------\n    ValueError: When `orient` is an unknown string.\n    TypeError: When dependent variable is not numeric, with `require_numeric`\n\n    \"\"\"\n    x_type = None if x is None else variable_type(x)\n    y_type = None if y is None else variable_type(y)\n    nonnumeric_dv_error = '{} orientation requires numeric `{}` variable.'\n    single_var_warning = '{} orientation ignored with only `{}` specified.'\n    if x is None:\n        if str(orient).startswith('h'):\n            warnings.warn(single_var_warning.format('Horizontal', 'y'))\n        if require_numeric and y_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Vertical', 'y'))\n        return 'x'\n    elif y is None:\n        if str(orient).startswith('v'):\n            warnings.warn(single_var_warning.format('Vertical', 'x'))\n        if require_numeric and x_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Horizontal', 'x'))\n        return 'y'\n    elif str(orient).startswith('v') or orient == 'x':\n        if require_numeric and y_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Vertical', 'y'))\n        return 'x'\n    elif str(orient).startswith('h') or orient == 'y':\n        if require_numeric and x_type != 'numeric':\n            raise TypeError(nonnumeric_dv_error.format('Horizontal', 'x'))\n        return 'y'\n    elif orient is not None:\n        err = (\n            f\"`orient` must start with 'v' or 'h' or be None, but `{repr(orient)}` was passed.\"\n            )\n        raise ValueError(err)\n    elif x_type != 'categorical' and y_type == 'categorical':\n        return 'y'\n    elif x_type != 'numeric' and y_type == 'numeric':\n        return 'x'\n    elif x_type == 'numeric' and y_type != 'numeric':\n        return 'y'\n    elif require_numeric and 'numeric' not in (x_type, y_type):\n        err = 'Neither the `x` nor `y` variable appears to be numeric.'\n        raise TypeError(err)\n    else:\n        return 'x'"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "../srcdata/Visualization/seaborn/seaborn/_statistics.py", "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\ndef _validate_errorbar_arg(arg):\n    \"\"\"Check type and value of errorbar argument and assign default level.\"\"\"\n    DEFAULT_LEVELS = {'ci': 95, 'pi': 95, 'se': 1, 'sd': 1}\n    usage = '`errorbar` must be a callable, string, or (string, number) tuple'\n    if arg is None:\n        return None, None\n    elif callable(arg):\n        return arg, None\n    elif isinstance(arg, str):\n        method = arg\n        level = DEFAULT_LEVELS.get(method, None)\n    else:\n        try:\n            method, level = arg\n        except (ValueError, TypeError) as err:\n            raise err.__class__(usage) from err\n    _check_argument('errorbar', list(DEFAULT_LEVELS), method)\n    if level is not None and not isinstance(level, Number):\n        raise TypeError(usage)\n    return method, level"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "histplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, log_scale=log_scale)\n    if p.univariate:\n        if fill:\n            method = ax.bar if element == 'bars' else ax.fill_between\n        else:\n            method = ax.plot\n        color = _default_color(method, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    if discrete is None:\n        discrete = p._default_discrete()\n    estimate_kws = dict(stat=stat, bins=bins, binwidth=binwidth, binrange=\n        binrange, discrete=discrete, cumulative=cumulative)\n    if p.univariate:\n        p.plot_univariate_histogram(multiple=multiple, element=element,\n            fill=fill, shrink=shrink, common_norm=common_norm, common_bins=\n            common_bins, kde=kde, kde_kws=kde_kws, color=color, legend=\n            legend, estimate_kws=estimate_kws, line_kws=line_kws, **kwargs)\n    else:\n        p.plot_bivariate_histogram(common_bins=common_bins, common_norm=\n            common_norm, thresh=thresh, pthresh=pthresh, pmax=pmax, color=\n            color, legend=legend, cbar=cbar, cbar_ax=cbar_ax, cbar_kws=\n            cbar_kws, estimate_kws=estimate_kws, **kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "../srcdata/Visualization/seaborn/seaborn/matrix.py", "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\ndef _matrix_mask(data, mask):\n    \"\"\"Ensure that data and mask are compatible and add missing values.\n\n    Values will be plotted for cells where ``mask`` is ``False``.\n\n    ``data`` is expected to be a DataFrame; ``mask`` can be an array or\n    a DataFrame.\n\n    \"\"\"\n    if mask is None:\n        mask = np.zeros(data.shape, bool)\n    if isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError('Mask must have the same shape as data.')\n        mask = pd.DataFrame(mask, index=data.index, columns=data.columns,\n            dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if not mask.index.equals(data.index) and mask.columns.equals(data.\n            columns):\n            err = 'Mask must have the same index and columns as data.'\n            raise ValueError(err)\n    mask = mask | pd.isnull(data)\n    return mask"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "despine", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False):\n    \"\"\"Remove the top and right spines from plot(s).\n\n    fig : matplotlib figure, optional\n        Figure to despine all axes of, defaults to the current figure.\n    ax : matplotlib axes, optional\n        Specific axes object to despine. Ignored if fig is provided.\n    top, right, left, bottom : boolean, optional\n        If True, remove that spine.\n    offset : int or dict, optional\n        Absolute distance, in points, spines should be moved away\n        from the axes (negative values move spines inward). A single value\n        applies to all spines; a dict can be used to set offset values per\n        side.\n    trim : bool, optional\n        If True, limit spines to the smallest and largest major tick\n        on each non-despined axis.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if fig is None and ax is None:\n        axes = plt.gcf().axes\n    elif fig is not None:\n        axes = fig.axes\n    elif ax is not None:\n        axes = [ax]\n    for ax_i in axes:\n        for side in ['top', 'right', 'left', 'bottom']:\n            is_visible = not locals()[side]\n            ax_i.spines[side].set_visible(is_visible)\n            if offset is not None and is_visible:\n                try:\n                    val = offset.get(side, 0)\n                except AttributeError:\n                    val = offset\n                ax_i.spines[side].set_position(('outward', val))\n        if left and not right:\n            maj_on = any(t.tick1line.get_visible() for t in ax_i.yaxis.\n                majorTicks)\n            min_on = any(t.tick1line.get_visible() for t in ax_i.yaxis.\n                minorTicks)\n            ax_i.yaxis.set_ticks_position('right')\n            for t in ax_i.yaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.yaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n        if bottom and not top:\n            maj_on = any(t.tick1line.get_visible() for t in ax_i.xaxis.\n                majorTicks)\n            min_on = any(t.tick1line.get_visible() for t in ax_i.xaxis.\n                minorTicks)\n            ax_i.xaxis.set_ticks_position('top')\n            for t in ax_i.xaxis.majorTicks:\n                t.tick2line.set_visible(maj_on)\n            for t in ax_i.xaxis.minorTicks:\n                t.tick2line.set_visible(min_on)\n        if trim:\n            xticks = np.asarray(ax_i.get_xticks())\n            if xticks.size:\n                firsttick = np.compress(xticks >= min(ax_i.get_xlim()), xticks\n                    )[0]\n                lasttick = np.compress(xticks <= max(ax_i.get_xlim()), xticks)[\n                    -1]\n                ax_i.spines['bottom'].set_bounds(firsttick, lasttick)\n                ax_i.spines['top'].set_bounds(firsttick, lasttick)\n                newticks = xticks.compress(xticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_xticks(newticks)\n            yticks = np.asarray(ax_i.get_yticks())\n            if yticks.size:\n                firsttick = np.compress(yticks >= min(ax_i.get_ylim()), yticks\n                    )[0]\n                lasttick = np.compress(yticks <= max(ax_i.get_ylim()), yticks)[\n                    -1]\n                ax_i.spines['left'].set_bounds(firsttick, lasttick)\n                ax_i.spines['right'].set_bounds(firsttick, lasttick)\n                newticks = yticks.compress(yticks <= lasttick)\n                newticks = newticks.compress(newticks >= firsttick)\n                ax_i.set_yticks(newticks)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    \"\"\"\n    Return a palette or colormap from the matplotlib registry.\n    For continuous palettes, evenly-spaced discrete samples are chosen while\n    excluding the minimum and maximum value in the colormap to provide better\n    contrast at the extremes.\n    For qualitative palettes (e.g. those from colorbrewer), exact values are\n    indexed (rather than interpolated), but fewer than `n_colors` can be returned\n    if the palette does not define that many.\n    Parameters\n    ----------\n    name : string\n        Name of the palette. This should be a named matplotlib colormap.\n    n_colors : int\n        Number of discrete colors in the palette.\n    Returns\n    -------\n    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include:: ../docstrings/mpl_palette.rst\n    \"\"\"\n    if name.endswith('_d'):\n        sub_name = name[:-2]\n        if sub_name.endswith('_r'):\n            reverse = True\n            sub_name = sub_name[:-2]\n        else:\n            reverse = False\n        pal = color_palette(sub_name, 2) + ['#333333']\n        if reverse:\n            pal = pal[::-1]\n        cmap = blend_palette(pal, n_colors, as_cmap=True)\n    else:\n        cmap = get_colormap(name)\n    if name in MPL_QUAL_PALS:\n        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]\n    else:\n        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]\n    palette = list(map(tuple, cmap(bins)[:, :3]))\n    if as_cmap:\n        return cmap\n    else:\n        return _ColorPalette(palette)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "../srcdata/Visualization/seaborn/seaborn/_compat.py", "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\ndef get_legend_handles(legend):\n    \"\"\"Handle legendHandles attribute rename.\"\"\"\n    if _version_predates(mpl, '3.7'):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Make a sequential palette that blends from dark to ``color``.\n    This kind of palette is good for data that range between relatively\n    uninteresting low values and interesting high values.\n    The ``color`` parameter can be specified in a number of ways, including\n    all options for defining a color in matplotlib and several additional\n    color spaces that are handled by seaborn. You can also use the database\n    of named colors from the XKCD color survey.\n    If you are using the IPython notebook, you can also choose this palette\n    interactively with the :func:`choose_dark_palette` function.\n    Parameters\n    ----------\n    color : base color for high values\n        hex, rgb-tuple, or html color name\n    n_colors : int, optional\n        number of colors in the palette\n    reverse : bool, optional\n        if True, reverse the direction of the blend\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    input : {'rgb', 'hls', 'husl', xkcd'}\n        Color space to interpret the input color. The first three options\n        apply to tuple inputs and the latter applies to string inputs.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    light_palette : Create a sequential palette with bright low values.\n    diverging_palette : Create a diverging palette with two colors.\n    Examples\n    --------\n    .. include:: ../docstrings/dark_palette.rst\n    \"\"\"\n    rgb = _color_to_rgb(color, input)\n    hue, sat, _ = husl.rgb_to_husl(*rgb)\n    gray_s, gray_l = 0.15 * sat, 15\n    gray = _color_to_rgb((hue, gray_s, gray_l), input='husl')\n    colors = [rgb, gray] if reverse else [gray, rgb]\n    return blend_palette(colors, n_colors, as_cmap)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"\n    Return hues with constant lightness and saturation in the HLS system.\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n    The `h`, `l`, and `s` values should be between 0 and 1.\n    .. note::\n        While the separation of the resulting colors will be mathematically\n        constant, the HLS system does not construct a perceptually-uniform space,\n        so their apparent intensity will vary.\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    husl_palette : Make a palette using evenly spaced hues in the HUSL system.\n    Examples\n    --------\n    .. include:: ../docstrings/hls_palette.rst\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues -= hues.astype(int)\n    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, 'hls')\n    else:\n        return _ColorPalette(palette)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/rcmod.py", "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    \"\"\"Set the matplotlib color cycle using a seaborn palette.\n\n    Parameters\n    ----------\n    palette : seaborn color palette | matplotlib colormap | hls | husl\n        Palette definition. Should be something :func:`color_palette` can process.\n    n_colors : int\n        Number of colors in the cycle. The default number of colors will depend\n        on the format of ``palette``, see the :func:`color_palette`\n        documentation for more information.\n    desat : float\n        Proportion to desaturate each color by.\n    color_codes : bool\n        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand\n        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.\n\n    See Also\n    --------\n    color_palette : build a color palette or set the color cycle temporarily\n                    in a ``with`` statement.\n    set_context : set parameters to scale plot elements\n    set_style : set the default parameters for figure style\n\n    \"\"\"\n    colors = palettes.color_palette(palette, n_colors, desat)\n    cyl = cycler('color', colors)\n    mpl.rcParams['axes.prop_cycle'] = cyl\n    if color_codes:\n        try:\n            palettes.set_color_codes(palette)\n        except (ValueError, TypeError):\n            pass"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef get_color_cycle():\n    \"\"\"Return the list of colors in the current matplotlib color cycle\n\n    Parameters\n    ----------\n    None\n\n    Returns\n    -------\n    colors : list\n        List of matplotlib colors in the current cycle, or dark gray if\n        the current color cycle is empty.\n    \"\"\"\n    cycler = mpl.rcParams['axes.prop_cycle']\n    return cycler.by_key()['color'] if 'color' in cycler.keys else ['.15']"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/relational.py", "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    errorbar = _deprecate_ci(errorbar, ci)\n    p = _LinePlotter(data=data, variables=dict(x=x, y=y, hue=hue, size=size,\n        style=style, units=units, weight=weights), estimator=estimator,\n        n_boot=n_boot, seed=seed, errorbar=errorbar, sort=sort, orient=\n        orient, err_style=err_style, err_kws=err_kws, legend=legend)\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, dashes=dashes, order=style_order)\n    if ax is None:\n        ax = plt.gca()\n    if 'style' not in p.variables and not {'ls', 'linestyle'} & set(kwargs):\n        kwargs['dashes'] = '' if dashes is None or isinstance(dashes, bool\n            ) else dashes\n    if not p.has_xy_data:\n        return ax\n    p._attach(ax)\n    color = kwargs.pop('color', kwargs.pop('c', None))\n    kwargs['color'] = _default_color(ax.plot, hue, color, kwargs)\n    p.plot(ax, kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/distributions.py", "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    if 'data2' in kwargs:\n        msg = (\n            '`data2` has been removed (replaced by `y`); please update your code.'\n            )\n        raise TypeError(msg)\n    vertical = kwargs.pop('vertical', None)\n    if vertical is not None:\n        if vertical:\n            action_taken = 'assigning data to `y`.'\n            if x is None:\n                data, y = y, data\n            else:\n                x, y = y, x\n        else:\n            action_taken = 'assigning data to `x`.'\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `vertical` parameter is deprecated; {action_taken}\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    bw = kwargs.pop('bw', None)\n    if bw is not None:\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.\n        Setting `bw_method={bw}`, but please see the docs for the new parameters\n        and update your code. This will become an error in seaborn v0.14.0.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n        bw_method = bw\n    if kwargs.pop('kernel', None) is not None:\n        msg = textwrap.dedent(\n            \"\"\"\n\n        Support for alternate kernels has been removed; using Gaussian kernel.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    shade_lowest = kwargs.pop('shade_lowest', None)\n    if shade_lowest is not None:\n        if shade_lowest:\n            thresh = 0\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, UserWarning, stacklevel=2)\n    shade = kwargs.pop('shade', None)\n    if shade is not None:\n        fill = shade\n        msg = textwrap.dedent(\n            f\"\"\"\n\n        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.\n        This will become an error in seaborn v0.14.0; please update your code.\n        \"\"\"\n            )\n        warnings.warn(msg, FutureWarning, stacklevel=2)\n    levels = kwargs.pop('n_levels', levels)\n    p = _DistributionPlotter(data=data, variables=dict(x=x, y=y, hue=hue,\n        weights=weights))\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    if ax is None:\n        ax = plt.gca()\n    p._attach(ax, allowed_types=['numeric', 'datetime'], log_scale=log_scale)\n    method = ax.fill_between if fill else ax.plot\n    color = _default_color(method, hue, color, kwargs)\n    if not p.has_xy_data:\n        return ax\n    estimate_kws = dict(bw_method=bw_method, bw_adjust=bw_adjust, gridsize=\n        gridsize, cut=cut, clip=clip, cumulative=cumulative)\n    if p.univariate:\n        plot_kws = kwargs.copy()\n        p.plot_univariate_density(multiple=multiple, common_norm=\n            common_norm, common_grid=common_grid, fill=fill, color=color,\n            legend=legend, warn_singular=warn_singular, estimate_kws=\n            estimate_kws, **plot_kws)\n    else:\n        p.plot_bivariate_density(common_norm=common_norm, fill=fill, levels\n            =levels, thresh=thresh, legend=legend, color=color,\n            warn_singular=warn_singular, cbar=cbar, cbar_ax=cbar_ax,\n            cbar_kws=cbar_kws, estimate_kws=estimate_kws, **kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "../srcdata/Visualization/seaborn/seaborn/rcmod.py", "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\nclass _RCAesthetics(dict):\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\ndef plotting_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Get the parameters that control the scaling of plot elements.\n    These parameters correspond to label size, line thickness, etc. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n    This function can also be used as a context manager to temporarily\n    alter the global defaults. See :func:`set_theme` or :func:`set_context`\n    to modify the global defaults for all plots.\n    Parameters\n    ----------\n    context : None, dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n    Examples\n    --------\n    .. include:: ../docstrings/plotting_context.rst\n    \"\"\"\n    if context is None:\n        context_dict = {k: mpl.rcParams[k] for k in _context_keys}\n    elif isinstance(context, dict):\n        context_dict = context\n    else:\n        contexts = ['paper', 'notebook', 'talk', 'poster']\n        if context not in contexts:\n            raise ValueError(f\"context must be in {', '.join(contexts)}\")\n        texts_base_context = {'font.size': 12, 'axes.labelsize': 12,\n            'axes.titlesize': 12, 'xtick.labelsize': 11, 'ytick.labelsize':\n            11, 'legend.fontsize': 11, 'legend.title_fontsize': 12}\n        base_context = {'axes.linewidth': 1.25, 'grid.linewidth': 1,\n            'lines.linewidth': 1.5, 'lines.markersize': 6,\n            'patch.linewidth': 1, 'xtick.major.width': 1.25,\n            'ytick.major.width': 1.25, 'xtick.minor.width': 1,\n            'ytick.minor.width': 1, 'xtick.major.size': 6,\n            'ytick.major.size': 6, 'xtick.minor.size': 4, 'ytick.minor.size': 4\n            }\n        base_context.update(texts_base_context)\n        scaling = dict(paper=0.8, notebook=1, talk=1.5, poster=2)[context]\n        context_dict = {k: (v * scaling) for k, v in base_context.items()}\n        font_keys = texts_base_context.keys()\n        font_dict = {k: (context_dict[k] * font_scale) for k in font_keys}\n        context_dict.update(font_dict)\n    if rc is not None:\n        rc = {k: v for k, v in rc.items() if k in _context_keys}\n        context_dict.update(rc)\n    context_object = _PlottingContext(context_dict)\n    return context_object"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\ndef _patch_colormap_display():\n    \"\"\"Simplify the rich display of matplotlib color maps in a notebook.\"\"\"\n\n    def _repr_png_(self):\n        \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n        import io\n        from PIL import Image\n        import numpy as np\n        IMAGE_SIZE = 400, 50\n        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))\n        pixels = self(X, bytes=True)\n        png_bytes = io.BytesIO()\n        Image.fromarray(pixels).save(png_bytes, format='png')\n        return png_bytes.getvalue()\n\n    def _repr_html_(self):\n        \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n        import base64\n        png_bytes = self._repr_png_()\n        png_base64 = base64.b64encode(png_bytes).decode('ascii')\n        return ('<img ' + 'alt=\"' + self.name + ' color map\" ' + 'title=\"' +\n            self.name + '\"' + 'src=\"data:image/png;base64,' + png_base64 + '\">'\n            )\n    mpl.colors.Colormap._repr_png_ = _repr_png_\n    mpl.colors.Colormap._repr_html_ = _repr_html_"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\ndef set_color_codes(palette='deep'):\n    \"\"\"Change how matplotlib color shorthands are interpreted.\n    Calling this will change how shorthand codes like \"b\" or \"g\"\n    are interpreted by matplotlib in subsequent plots.\n    Parameters\n    ----------\n    palette : {deep, muted, pastel, dark, bright, colorblind}\n        Named seaborn palette to use as the source of colors.\n    See Also\n    --------\n    set : Color codes can be set through the high-level seaborn style\n          manager.\n    set_palette : Color codes can also be set through the function that\n                  sets the matplotlib color cycle.\n    \"\"\"\n    if palette == 'reset':\n        colors = [(0.0, 0.0, 1.0), (0.0, 0.5, 0.0), (1.0, 0.0, 0.0), (0.75,\n            0.0, 0.75), (0.75, 0.75, 0.0), (0.0, 0.75, 0.75), (0.0, 0.0, 0.0)]\n    elif not isinstance(palette, str):\n        err = 'set_color_codes requires a named seaborn palette'\n        raise TypeError(err)\n    elif palette in SEABORN_PALETTES:\n        if not palette.endswith('6'):\n            palette = palette + '6'\n        colors = SEABORN_PALETTES[palette] + [(0.1, 0.1, 0.1)]\n    else:\n        err = f\"Cannot set colors with palette '{palette}'\"\n        raise ValueError(err)\n    for code, color in zip('bgrmyck', colors):\n        rgb = mpl.colors.colorConverter.to_rgb(color)\n        mpl.colors.colorConverter.colors[code] = rgb"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\ndef categorical_order(vector: Series, order: (list | None)=None) ->list:\n    \"\"\"\n    Return a list of unique data values using seaborn's ordering rules.\n\n    Parameters\n    ----------\n    vector : Series\n        Vector of \"categorical\" values\n    order : list\n        Desired order of category levels to override the order determined\n        from the `data` object.\n\n    Returns\n    -------\n    order : list\n        Ordered list of category levels not including null values.\n\n    \"\"\"\n    if order is not None:\n        return order\n    if vector.dtype.name == 'category':\n        order = list(vector.cat.categories)\n    else:\n        order = list(filter(pd.notnull, vector.unique()))\n        if variable_type(pd.Series(order)) == 'numeric':\n            order.sort()\n    return order"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"\n    Return hues with constant lightness and saturation in the HUSL system.\n    The hues are evenly sampled along a circular path. The resulting palette will be\n    appropriate for categorical or cyclical data.\n    The `h`, `l`, and `s` values should be between 0 and 1.\n    This function is similar to :func:`hls_palette`, but it uses a nonlinear color\n    space that is more perceptually uniform.\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    h : float\n        The value of the first hue.\n    l : float\n        The lightness value.\n    s : float\n        The saturation intensity.\n    as_cmap : bool\n        If True, return a matplotlib colormap object.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    hls_palette : Make a palette using evenly spaced hues in the HSL system.\n    Examples\n    --------\n    .. include:: ../docstrings/husl_palette.rst\n    \"\"\"\n    if as_cmap:\n        n_colors = 256\n    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]\n    hues += h\n    hues %= 1\n    hues *= 359\n    s *= 99\n    l *= 99\n    palette = [_color_to_rgb((h_i, s, l), input='husl') for h_i in hues]\n    if as_cmap:\n        return mpl.colors.ListedColormap(palette, 'hsl')\n    else:\n        return _ColorPalette(palette)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False) ->VarType:\n    \"\"\"\n    Determine whether a vector contains numeric, categorical, or datetime data.\n\n    This function differs from the pandas typing API in a few ways:\n\n    - Python sequences or object-typed PyData objects are considered numeric if\n      all of their entries are numeric.\n    - String or mixed-type data are considered categorical even if not\n      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.\n    - There is some flexibility about how to treat binary / boolean data.\n\n    Parameters\n    ----------\n    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence\n        Input data to test.\n    boolean_type : 'numeric', 'categorical', or 'boolean'\n        Type to use for vectors containing only 0s and 1s (and NAs).\n    strict_boolean : bool\n        If True, only consider data to be boolean when the dtype is bool or Boolean.\n\n    Returns\n    -------\n    var_type : 'numeric', 'categorical', or 'datetime'\n        Name identifying the type of data in the vector.\n    \"\"\"\n    if isinstance(getattr(vector, 'dtype', None), pd.CategoricalDtype):\n        return VarType('categorical')\n    if pd.isna(vector).all():\n        return VarType('numeric')\n    vector = vector.dropna()\n    with warnings.catch_warnings():\n        warnings.simplefilter(action='ignore', category=(FutureWarning,\n            DeprecationWarning))\n        if strict_boolean:\n            if isinstance(vector.dtype, pd.core.dtypes.base.ExtensionDtype):\n                boolean_dtypes = ['bool', 'boolean']\n            else:\n                boolean_dtypes = ['bool']\n            boolean_vector = vector.dtype in boolean_dtypes\n        else:\n            try:\n                boolean_vector = bool(np.isin(vector, [0, 1]).all())\n            except TypeError:\n                boolean_vector = False\n        if boolean_vector:\n            return VarType(boolean_type)\n    if pd.api.types.is_numeric_dtype(vector):\n        return VarType('numeric')\n    if pd.api.types.is_datetime64_dtype(vector):\n        return VarType('datetime')\n\n    def all_numeric(x):\n        for x_i in x:\n            if not isinstance(x_i, Number):\n                return False\n        return True\n    if all_numeric(vector):\n        return VarType('numeric')\n\n    def all_datetime(x):\n        for x_i in x:\n            if not isinstance(x_i, (datetime, np.datetime64)):\n                return False\n        return True\n    if all_datetime(vector):\n        return VarType('datetime')\n    return VarType('categorical')"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/relational.py", "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    p = _ScatterPlotter(data=data, variables=dict(x=x, y=y, hue=hue, size=\n        size, style=style), legend=legend)\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n    p.map_style(markers=markers, order=style_order)\n    if ax is None:\n        ax = plt.gca()\n    if not p.has_xy_data:\n        return ax\n    p._attach(ax)\n    color = kwargs.pop('color', None)\n    kwargs['color'] = _default_color(ax.scatter, hue, color, kwargs)\n    p.plot(ax, kwargs)\n    return ax"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "../srcdata/Visualization/seaborn/seaborn/palettes.py", "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \"\"\"Make a sequential palette from the cubehelix system.\n    This produces a colormap with linearly-decreasing (or increasing)\n    brightness. That means that information will be preserved if printed to\n    black and white or viewed by someone who is colorblind.  \"cubehelix\" is\n    also available as a matplotlib-based palette, but this function gives the\n    user more control over the look of the palette and has a different set of\n    defaults.\n    In addition to using this function, it is also possible to generate a\n    cubehelix palette generally in seaborn using a string starting with\n    `ch:` and containing other parameters (e.g. `\"ch:s=.25,r=-.5\"`).\n    Parameters\n    ----------\n    n_colors : int\n        Number of colors in the palette.\n    start : float, 0 <= start <= 3\n        The hue value at the start of the helix.\n    rot : float\n        Rotations around the hue wheel over the range of the palette.\n    gamma : float 0 <= gamma\n        Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors.\n    hue : float, 0 <= hue <= 1\n        Saturation of the colors.\n    dark : float 0 <= dark <= 1\n        Intensity of the darkest color in the palette.\n    light : float 0 <= light <= 1\n        Intensity of the lightest color in the palette.\n    reverse : bool\n        If True, the palette will go from dark to light.\n    as_cmap : bool\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    See Also\n    --------\n    choose_cubehelix_palette : Launch an interactive widget to select cubehelix\n                               palette parameters.\n    dark_palette : Create a sequential palette with dark low values.\n    light_palette : Create a sequential palette with bright low values.\n    References\n    ----------\n    Green, D. A. (2011). \"A colour scheme for the display of astronomical\n    intensity images\". Bulletin of the Astromical Society of India, Vol. 39,\n    p. 289-295.\n    Examples\n    --------\n    .. include:: ../docstrings/cubehelix_palette.rst\n    \"\"\"\n    def get_color_function(p0, p1):\n        def color(x):\n            xg = x ** gamma\n            a = hue * xg * (1 - xg) / 2\n            phi = 2 * np.pi * (start / 3 + rot * x)\n            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))\n        return color\n    cdict = {'red': get_color_function(-0.14861, 1.78277), 'green':\n        get_color_function(-0.29227, -0.90649), 'blue': get_color_function(\n        1.97294, 0.0)}\n    cmap = mpl.colors.LinearSegmentedColormap('cubehelix', cdict)\n    x = np.linspace(light, dark, int(n_colors))\n    pal = cmap(x)[:, :3].tolist()\n    if reverse:\n        pal = pal[::-1]\n    if as_cmap:\n        x_256 = np.linspace(light, dark, 256)\n        if reverse:\n            x_256 = x_256[::-1]\n        pal_256 = cmap(x_256)\n        cmap = mpl.colors.ListedColormap(pal_256, 'seaborn_cubehelix')\n        return cmap\n    else:\n        return _ColorPalette(pal)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "../srcdata/Visualization/seaborn/seaborn/utils.py", "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\ndef _draw_figure(fig):\n    \"\"\"Force draw of a matplotlib figure, accounting for back-compat.\"\"\"\n    fig.canvas.draw()\n    if fig.stale:\n        try:\n            fig.draw(fig.canvas.get_renderer())\n        except AttributeError:\n            pass"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "../srcdata/Visualization/seaborn/seaborn/algorithms.py", "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n", "response": "import numpy as np\nimport warnings\ndef bootstrap(*args, **kwargs):\n    \"\"\"Resample one or more arrays with replacement and store aggregate values.\n\n    Positional arguments are a sequence of arrays to bootstrap along the first\n    axis and pass to a summary function.\n\n    Keyword arguments:\n        n_boot : int, default=10000\n            Number of iterations\n        axis : int, default=None\n            Will pass axis to ``func`` as a keyword argument.\n        units : array, default=None\n            Array of sampling unit IDs. When used the bootstrap resamples units\n            and then observations within units instead of individual\n            datapoints.\n        func : string or callable, default=\"mean\"\n            Function to call on the args that are passed in. If string, uses as\n            name of function in the numpy namespace. If nans are present in the\n            data, will try to use nan-aware version of named function.\n        seed : Generator | SeedSequence | RandomState | int | None\n            Seed for the random number generator; useful if you want\n            reproducible resamples.\n\n    Returns\n    -------\n    boot_dist: array\n        array of bootstrapped statistic values\n\n    \"\"\"\n    if len(np.unique(list(map(len, args)))) > 1:\n        raise ValueError('All input arrays must have the same length')\n    n = len(args[0])\n    n_boot = kwargs.get('n_boot', 10000)\n    func = kwargs.get('func', 'mean')\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    random_seed = kwargs.get('random_seed', None)\n    if random_seed is not None:\n        msg = '`random_seed` has been renamed to `seed` and will be removed'\n        warnings.warn(msg)\n    seed = kwargs.get('seed', random_seed)\n    if axis is None:\n        func_kwargs = dict()\n    else:\n        func_kwargs = dict(axis=axis)\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    else:\n        rng = np.random.default_rng(seed)\n    args = list(map(np.asarray, args))\n    if units is not None:\n        units = np.asarray(units)\n    if isinstance(func, str):\n        f = getattr(np, func)\n        missing_data = np.isnan(np.sum(np.column_stack(args)))\n        if missing_data and not func.startswith('nan'):\n            nanf = getattr(np, f'nan{func}', None)\n            if nanf is None:\n                msg = (\n                    f'Data contain nans but no nan-aware version of `{func}` found'\n                    )\n                warnings.warn(msg, UserWarning)\n            else:\n                f = nanf\n    else:\n        f = func\n    try:\n        integers = rng.integers\n    except AttributeError:\n        integers = rng.randint\n    if units is not None:\n        return _structured_bootstrap(args, n_boot, units, f, func_kwargs,\n            integers)\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n, n, dtype=np.intp)\n        sample = [a.take(resampler, axis=0) for a in args]\n        boot_dist.append(f(*sample, **func_kwargs))\n    return np.array(boot_dist)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "../srcdata/Visualization/seaborn/seaborn/algorithms.py", "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n", "response": "import numpy as np\nimport warnings\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\ndef bootstrap(*args, **kwargs):\n    \"\"\"Resample one or more arrays with replacement and store aggregate values.\n    Positional arguments are a sequence of arrays to bootstrap along the first\n    axis and pass to a summary function.\n    Keyword arguments:\n        n_boot : int, default=10000\n            Number of iterations\n        axis : int, default=None\n            Will pass axis to ``func`` as a keyword argument.\n        units : array, default=None\n            Array of sampling unit IDs. When used the bootstrap resamples units\n            and then observations within units instead of individual\n            datapoints.\n        func : string or callable, default=\"mean\"\n            Function to call on the args that are passed in. If string, uses as\n            name of function in the numpy namespace. If nans are present in the\n            data, will try to use nan-aware version of named function.\n        seed : Generator | SeedSequence | RandomState | int | None\n            Seed for the random number generator; useful if you want\n            reproducible resamples.\n    Returns\n    -------\n    boot_dist: array\n        array of bootstrapped statistic values\n    \"\"\"\n    if len(np.unique(list(map(len, args)))) > 1:\n        raise ValueError('All input arrays must have the same length')\n    n = len(args[0])\n    n_boot = kwargs.get('n_boot', 10000)\n    func = kwargs.get('func', 'mean')\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    random_seed = kwargs.get('random_seed', None)\n    if random_seed is not None:\n        msg = '`random_seed` has been renamed to `seed` and will be removed'\n        warnings.warn(msg)\n    seed = kwargs.get('seed', random_seed)\n    if axis is None:\n        func_kwargs = dict()\n    else:\n        func_kwargs = dict(axis=axis)\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    else:\n        rng = np.random.default_rng(seed)\n    args = list(map(np.asarray, args))\n    if units is not None:\n        units = np.asarray(units)\n    if isinstance(func, str):\n        f = getattr(np, func)\n        missing_data = np.isnan(np.sum(np.column_stack(args)))\n        if missing_data and not func.startswith('nan'):\n            nanf = getattr(np, f'nan{func}', None)\n            if nanf is None:\n                msg = (\n                    f'Data contain nans but no nan-aware version of `{func}` found'\n                    )\n                warnings.warn(msg, UserWarning)\n            else:\n                f = nanf\n    else:\n        f = func\n    try:\n        integers = rng.integers\n    except AttributeError:\n        integers = rng.randint\n    if units is not None:\n        return _structured_bootstrap(args, n_boot, units, f, func_kwargs,\n            integers)\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n, n, dtype=np.intp)\n        sample = [a.take(resampler, axis=0) for a in args]\n        boot_dist.append(f(*sample, **func_kwargs))\n    return np.array(boot_dist)"}
{"result": "passed", "model_name": "std", "repository": "seaborn", "full_method_name": "countplot", "method_path": "../srcdata/Visualization/seaborn/seaborn/categorical.py", "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs):\n    if x is None and y is not None:\n        orient = 'y'\n        x = 1 if list(y) else None\n    elif x is not None and y is None:\n        orient = 'x'\n        y = 1 if list(x) else None\n    elif x is not None and y is not None:\n        raise TypeError('Cannot pass values for both `x` and `y`.')\n    p = _CategoricalAggPlotter(data=data, variables=dict(x=x, y=y, hue=hue),\n        order=order, orient=orient, color=color, legend=legend)\n    if ax is None:\n        ax = plt.gca()\n    if p.plot_data.empty:\n        return ax\n    if dodge == 'auto':\n        dodge = p._dodge_needed()\n    if p.var_types.get(p.orient) == 'categorical' or not native_scale:\n        p.scale_categorical(p.orient, order=order, formatter=formatter)\n    p._attach(ax, log_scale=log_scale)\n    hue_order = p._palette_without_hue_backcompat(palette, hue_order)\n    palette, hue_order = p._hue_backcompat(color, palette, hue_order)\n    saturation = saturation if fill else 1\n    p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=\n        saturation)\n    color = _default_color(ax.bar, hue, color, kwargs, saturation)\n    count_axis = {'x': 'y', 'y': 'x'}[p.orient]\n    if p.input_format == 'wide':\n        p.plot_data[count_axis] = 1\n    _check_argument('stat', ['count', 'percent', 'probability',\n        'proportion'], stat)\n    p.variables[count_axis] = stat\n    if stat != 'count':\n        denom = 100 if stat == 'percent' else 1\n        p.plot_data[count_axis] /= len(p.plot_data) / denom\n    aggregator = EstimateAggregator('sum', errorbar=None)\n    p.plot_bars(aggregator=aggregator, dodge=dodge, width=width, gap=gap,\n        color=color, fill=fill, capsize=0, err_kws={}, plot_kws=kwargs)\n    p._add_axis_labels(ax)\n    p._adjust_cat_axis(ax, axis=p.orient)\n    return ax"}
