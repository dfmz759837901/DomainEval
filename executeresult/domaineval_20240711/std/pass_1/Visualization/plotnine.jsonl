{"result": "passed", "model_name": "std", "repository": "plotnine", "full_method_name": "breaks_from_binwidth", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None): [MASK]\n", "response": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks"}
{"result": "passed", "model_name": "std", "repository": "plotnine", "full_method_name": "freedman_diaconis_bins", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef freedman_diaconis_bins(a): [MASK]\n", "response": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef freedman_diaconis_bins(a):\n    \"\"\"\n    Calculate number of hist bins using Freedman-Diaconis rule.\n    \"\"\"\n    from scipy.stats import iqr\n    a = np.asarray(a)\n    h = 2 * iqr(a, nan_policy='omit') / len(a) ** (1 / 3)\n    if h == 0:\n        bins = np.ceil(np.sqrt(a.size))\n    else:\n        bins = np.ceil((np.nanmax(a) - np.nanmin(a)) / h)\n    return int(bins)"}
{"result": "passed", "model_name": "std", "repository": "plotnine", "full_method_name": "breaks_from_bins", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks\n\n\ndef breaks_from_bins(x_range: TupleFloat2, bins: int=30, center: Optional[\n    float]=None, boundary: Optional[float]=None): [MASK]\n", "response": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef breaks_from_binwidth(x_range: TupleFloat2, binwidth: float, center:\n    Optional[float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    binwidth :\n        Separation between the breaks\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if binwidth <= 0:\n        raise PlotnineError(\"The 'binwidth' must be positive.\")\n    if boundary is not None and center is not None:\n        raise PlotnineError(\n            \"Only one of 'boundary' and 'center' may be specified.\")\n    elif boundary is None:\n        boundary = binwidth / 2\n        if center is not None:\n            boundary = center - boundary\n    epsilon = np.finfo(float).eps\n    shift = np.floor((x_range[0] - boundary) / binwidth)\n    origin = boundary + shift * binwidth\n    max_x = x_range[1] + binwidth * (1 - epsilon)\n    breaks = np.arange(origin, max_x, binwidth)\n    return breaks\ndef breaks_from_bins(x_range: TupleFloat2, bins: int=30, center: Optional[\n    float]=None, boundary: Optional[float]=None):\n    \"\"\"\n    Calculate breaks given binwidth\n    Parameters\n    ----------\n    x_range :\n        Range over with to calculate the breaks. Must be\n        of size 2.\n    bins :\n        Number of bins\n    center :\n        The center of one of the bins\n    boundary :\n        A boundary between two bins\n    Returns\n    -------\n    out : array_like\n        Sequence of break points.\n    \"\"\"\n    if bins < 1:\n        raise PlotnineError('Need at least one bin.')\n    elif bins == 1:\n        binwidth = x_range[1] - x_range[0]\n        boundary = x_range[1]\n    else:\n        binwidth = (x_range[1] - x_range[0]) / (bins - 1)\n    return breaks_from_binwidth(x_range, binwidth, center, boundary)"}
{"result": "passed", "model_name": "std", "repository": "plotnine", "full_method_name": "_adjust_breaks", "method_path": "../srcdata/Visualization/plotnine/plotnine/stats/binning.py", "method_code_mask": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\n\n\ndef _adjust_breaks(breaks: FloatArray, right: bool) ->FloatArray: [MASK]\n", "response": "from __future__ import annotations\nimport typing\nimport numpy as np\nimport pandas as pd\nfrom typing import Literal\nfrom typing import Optional\nfrom scipy.stats import iqr\ndef _adjust_breaks(breaks: FloatArray, right: bool) ->FloatArray:\n    epsilon = np.finfo(float).eps\n    plus = 1 + epsilon\n    minus = 1 - epsilon\n    sign = np.sign(breaks)\n    pos_idx = np.where(sign == 1)[0]\n    neg_idx = np.where(sign == -1)[0]\n    zero_idx = np.where(sign == 0)[0]\n    fuzzy = breaks.copy()\n    if right:\n        lbreak = breaks[0]\n        fuzzy[pos_idx] *= plus\n        fuzzy[neg_idx] *= minus\n        fuzzy[zero_idx] = epsilon\n        if lbreak == 0:\n            fuzzy[0] = -epsilon\n        elif lbreak < 0:\n            fuzzy[0] = lbreak * plus\n        else:\n            fuzzy[0] = lbreak * minus\n    else:\n        rbreak = breaks[-1]\n        fuzzy[pos_idx] *= minus\n        fuzzy[neg_idx] *= plus\n        fuzzy[zero_idx] = -epsilon\n        if rbreak == 0:\n            fuzzy[-1] = epsilon\n        elif rbreak > 0:\n            fuzzy[-1] = rbreak * plus\n        else:\n            fuzzy[-1] = rbreak * minus\n    return fuzzy"}
{"result": "passed", "model_name": "std", "repository": "plotnine", "full_method_name": "is_valid_aesthetic", "method_path": "../srcdata/Visualization/plotnine/plotnine/mapping/aes.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport typing\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom dataclasses import fields\nfrom typing import Any\nfrom typing import Dict\nimport pandas as pd\nfrom typing import Protocol\nfrom typing import TypeVar\n\n\ndef is_valid_aesthetic(value: Any, ae: str) ->bool: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport typing\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom copy import deepcopy\nfrom dataclasses import fields\nfrom typing import Any\nfrom typing import Dict\nimport pandas as pd\nfrom typing import Protocol\nfrom typing import TypeVar\ndef is_valid_aesthetic(value: Any, ae: str) ->bool:\n    \"\"\"\n    Return True if `value` looks valid.\n\n    Parameters\n    ----------\n    value :\n        Value to check\n    ae :\n        Aesthetic name\n\n    Notes\n    -----\n    There are no guarantees that he value is spot on\n    valid.\n    \"\"\"\n    if ae == 'linetype':\n        named = {'solid', 'dashed', 'dashdot', 'dotted', '_', '--', '-.',\n            ':', 'none', ' ', ''}\n        if value in named:\n            return True\n        conditions = [isinstance(value, tuple), isinstance(value[0], int),\n            isinstance(value[1], tuple), len(value[1]) % 2 == 0, all(\n            isinstance(x, int) for x in value[1])]\n        if all(conditions):\n            return True\n        return False\n    elif ae == 'shape':\n        if isinstance(value, str):\n            return True\n        conditions = [isinstance(value, tuple), all(isinstance(x, int) for\n            x in value), 0 <= value[1] < 3]\n        if all(conditions):\n            return True\n        return False\n    elif ae in {'color', 'fill'}:\n        if isinstance(value, str):\n            return True\n        with suppress(TypeError):\n            if isinstance(value, (tuple, list)) and all(0 <= x <= 1 for x in\n                value):\n                return True\n        return False\n    return False"}
