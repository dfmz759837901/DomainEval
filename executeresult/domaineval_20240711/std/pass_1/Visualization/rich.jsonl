{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "loop_first", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first value.\"\"\"\n    iter_values = iter(values)\n    try:\n        value = next(iter_values)\n    except StopIteration:\n        return\n    yield True, value\n    for value in iter_values:\n        yield False, value"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "loop_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "loop_first_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]: [M\n    ASK]\n", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first and last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    first = True\n    for value in iter_values:\n        yield first, False, previous_value\n        first = False\n        previous_value = value\n    yield first, True, previous_value"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "pick_unit_and_suffix", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]: [MASK]\n", "response": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]:\n    \"\"\"Pick a suffix and base for the given size.\"\"\"\n    for i, suffix in enumerate(suffixes):\n        unit = base ** i\n        if size < unit * base:\n            break\n    return unit, suffix"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "decimal", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\n\n\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str: [MASK]\n", "response": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str:\n    \"\"\"Convert a filesize in to a string (powers of 1000, SI prefixes).\n    In this convention, ``1000 B = 1 kB``.\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = \" \").\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n    Example:\n        >>> filesize.decimal(30000)\n        '30.0 kB'\n        >>> filesize.decimal(30000, precision=2, separator=\"\")\n        '30.00kB'\n    \"\"\"\n    return _to_str(size, ('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'),\n        1000, precision=precision, separator=separator)"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "get_fileno", "method_path": "../srcdata/Visualization/rich/rich/_fileno.py", "method_code_mask": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\n\n\ndef get_fileno(file_like: IO[str]) ->(int | None): [MASK]\n", "response": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\ndef get_fileno(file_like: IO[str]) ->(int | None):\n    \"\"\"Get fileno() from a file, accounting for poorly implemented file-like objects.\n\n    Args:\n        file_like (IO): A file-like object.\n\n    Returns:\n        int | None: The result of fileno if available, or None if operation failed.\n    \"\"\"\n    fileno: Callable[[], int] | None = getattr(file_like, 'fileno', None)\n    if fileno is not None:\n        try:\n            return fileno()\n        except Exception:\n            return None\n    return None"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "escape", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\n\n\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str: [MASK]\n", "response": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n    Args:\n        markup (str): Content to be inserted in to markup.\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n    def escape_backslashes(match: Match[str]) ->str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f'{backslashes}{backslashes}\\\\{text}'\n    markup = _escape(escape_backslashes, markup)\n    if markup.endswith('\\\\') and not markup.endswith('\\\\\\\\'):\n        return markup + '\\\\'\n    return markup"}
{"result": "passed", "model_name": "std", "repository": "rich", "full_method_name": "_parse", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\n\n\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]: [\n    MASK]\n", "response": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n    Args:\n        markup (str): A string containing console markup\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                yield start, '\\\\' * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                yield start, full_text[len(escapes):], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition('=')\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None"}
