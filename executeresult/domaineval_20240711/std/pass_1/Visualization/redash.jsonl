{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "parse_response", "method_path": "../srcdata/Visualization/redash/redash/query_runner/drill.py", "method_code_mask": "import logging\nimport os\nimport re\nfrom dateutil import parser\n\n\ndef parse_response(data): [MASK]\n", "response": "import logging\nimport os\nimport re\nfrom dateutil import parser\ndef parse_response(data):\n    cols = data['columns']\n    rows = data['rows']\n    if len(cols) == 0:\n        return {'columns': [], 'rows': []}\n    first_row = rows[0]\n    columns = []\n    types = {}\n    for c in cols:\n        columns.append({'name': c, 'type': guess_type(first_row[c]),\n            'friendly_name': c})\n    for col in columns:\n        types[col['name']] = col['type']\n    for row in rows:\n        for key, value in row.items():\n            row[key] = convert_type(value, types[key])\n    return {'columns': columns, 'rows': rows}"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "generate_ssl_options_dict", "method_path": "../srcdata/Visualization/redash/redash/query_runner/cass.py", "method_code_mask": "import logging\nimport os\nimport ssl\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\n\n\ndef generate_ssl_options_dict(protocol, cert_path=None): [MASK]\n", "response": "import logging\nimport os\nimport ssl\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\ndef generate_ssl_options_dict(protocol, cert_path=None):\n    ssl_options = {'ssl_version': getattr(ssl, protocol)}\n    if cert_path is not None:\n        ssl_options['ca_certs'] = cert_path\n        ssl_options['cert_reqs'] = ssl.CERT_REQUIRED\n    return ssl_options"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "prepare_parameterized_query", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef prepare_parameterized_query(query, query_params): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef prepare_parameterized_query(query, query_params):\n    for params in query_params:\n        table_hash = hashlib.md5('query_{query}_{hash}'.format(query=params\n            [0], hash=params[1]).encode(), usedforsecurity=False).hexdigest()\n        key = 'param_query_{query_id}_{{{param_string}}}'.format(query_id=\n            params[0], param_string=params[1])\n        value = 'query_{query_id}_{param_hash}'.format(query_id=params[0],\n            param_hash=table_hash)\n        query = query.replace(key, value)\n    return query"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "replace_query_parameters", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef replace_query_parameters(query_text, params): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef replace_query_parameters(query_text, params):\n    qs = parse_qs(params)\n    for key, value in qs.items():\n        query_text = query_text.replace('{{{{{my_key}}}}}'.format(my_key=\n            key), value[0])\n    return query_text"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "create_table", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef flatten(value):\n    if isinstance(value, (list, dict)):\n        return json_dumps(value)\n    elif isinstance(value, decimal.Decimal):\n        return float(value)\n    elif isinstance(value, datetime.timedelta):\n        return str(value)\n    else:\n        return value\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef fix_column_name(name):\n    return '\"{}\"'.format(re.sub('[:.\"\\\\s]', '_', name, flags=re.UNICODE))\n\n\ndef create_table(connection, table_name, query_results): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef flatten(value):\n    if isinstance(value, (list, dict)):\n        return json_dumps(value)\n    elif isinstance(value, decimal.Decimal):\n        return float(value)\n    elif isinstance(value, datetime.timedelta):\n        return str(value)\n    else:\n        return value\nlogger = logging.getLogger(__name__)\ndef fix_column_name(name):\n    return '\"{}\"'.format(re.sub('[:.\"\\\\s]', '_', name, flags=re.UNICODE))\ndef create_table(connection, table_name, query_results):\n    try:\n        columns = [column['name'] for column in query_results['columns']]\n        safe_columns = [fix_column_name(column) for column in columns]\n        column_list = ', '.join(safe_columns)\n        create_table = 'CREATE TABLE {table_name} ({column_list})'.format(\n            table_name=table_name, column_list=column_list)\n        logger.debug('CREATE TABLE query: %s', create_table)\n        connection.execute(create_table)\n    except sqlite3.OperationalError as exc:\n        raise CreateTableError('Error creating table {}: {}'.format(\n            table_name, str(exc)))\n    insert_template = (\n        'insert into {table_name} ({column_list}) values ({place_holders})'\n        .format(table_name=table_name, column_list=column_list,\n        place_holders=','.join(['?'] * len(columns))))\n    for row in query_results['rows']:\n        values = [flatten(row.get(column)) for column in columns]\n        connection.execute(insert_template, values)"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "get_formatted_value", "method_path": "../srcdata/Visualization/redash/redash/query_runner/google_search_console.py", "method_code_mask": "import logging\nfrom base64 import b64decode\nfrom datetime import datetime\nimport google.auth\nfrom apiclient.discovery import build\nfrom apiclient.errors import HttpError\nfrom google.oauth2.service_account import Credentials\n\n\ndef get_formatted_value(column_type, value): [MASK]\n", "response": "import logging\nfrom base64 import b64decode\nfrom datetime import datetime\nimport google.auth\nfrom apiclient.discovery import build\nfrom apiclient.errors import HttpError\nfrom google.oauth2.service_account import Credentials\ndef get_formatted_value(column_type, value):\n    if column_type == 'number':\n        value = round(value, 2)\n    elif column_type == TYPE_DATE:\n        value = datetime.strptime(value, '%Y-%m-%d')\n    elif column_type == TYPE_DATETIME:\n        if len(value) == 10:\n            value = datetime.strptime(value, '%Y%m%d%H')\n        elif len(value) == 12:\n            value = datetime.strptime(value, '%Y%m%d%H%M')\n        else:\n            raise Exception(\"Unknown date/time format in results: '{}'\".\n                format(value))\n    return value"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "build_schema", "method_path": "../srcdata/Visualization/redash/redash/query_runner/pg.py", "method_code_mask": "import logging\nimport os\nimport select\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\nfrom uuid import uuid4\nimport boto3\n\n\ndef full_table_name(schema, name):\n    if '.' in name:\n        name = '\"{}\"'.format(name)\n    return '{}.{}'.format(schema, name)\n\n\ndef build_schema(query_result, schema): [MASK]\n", "response": "import logging\nimport os\nimport select\nfrom base64 import b64decode\nfrom tempfile import NamedTemporaryFile\nfrom uuid import uuid4\nimport boto3\ndef full_table_name(schema, name):\n    if '.' in name:\n        name = '\"{}\"'.format(name)\n    return '{}.{}'.format(schema, name)\ndef build_schema(query_result, schema):\n    table_names = set(map(lambda r: full_table_name(r['table_schema'], r[\n        'table_name']), query_result['rows']))\n    for row in query_result['rows']:\n        if row['table_schema'] != 'public':\n            table_name = full_table_name(row['table_schema'], row['table_name']\n                )\n        elif row['table_name'] in table_names:\n            table_name = full_table_name(row['table_schema'], row['table_name']\n                )\n        else:\n            table_name = row['table_name']\n        if table_name not in schema:\n            schema[table_name] = {'name': table_name, 'columns': []}\n        column = row['column_name']\n        if row.get('data_type') is not None:\n            column = {'name': row['column_name'], 'type': row['data_type']}\n        schema[table_name]['columns'].append(column)"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "extract_query_ids", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_query_ids(query): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_query_ids(query):\n    queries = re.findall('(?:join|from)\\\\s+query_(\\\\d+)', query, re.IGNORECASE)\n    return [int(q) for q in queries]"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "extract_cached_query_ids", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_cached_query_ids(query): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_cached_query_ids(query):\n    queries = re.findall('(?:join|from)\\\\s+cached_query_(\\\\d+)', query, re.\n        IGNORECASE)\n    return [int(q) for q in queries]"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "parse_query", "method_path": "../srcdata/Visualization/redash/redash/query_runner/google_spreadsheets.py", "method_code_mask": "import logging\nimport re\nfrom base64 import b64decode\nfrom dateutil import parser\nfrom requests import Session\nimport google.auth\nfrom google.auth.exceptions import GoogleAuthError\nfrom google.oauth2.service_account import Credentials\n\n\ndef parse_query(query): [MASK]\n", "response": "import logging\nimport re\nfrom base64 import b64decode\nfrom dateutil import parser\nfrom requests import Session\nimport google.auth\nfrom google.auth.exceptions import GoogleAuthError\nfrom google.oauth2.service_account import Credentials\ndef parse_query(query):\n    values = query.split('|')\n    key = values[0]\n    worksheet_num_or_title = 0\n    if len(values) == 2:\n        s = values[1].strip()\n        if len(s) > 0:\n            if re.match('^\\\\\"(.*?)\\\\\"$', s):\n                worksheet_num_or_title = s[1:-1]\n            else:\n                worksheet_num_or_title = int(s)\n    return key, worksheet_num_or_title"}
{"result": "passed", "model_name": "std", "repository": "redash", "full_method_name": "extract_query_params", "method_path": "../srcdata/Visualization/redash/redash/query_runner/query_results.py", "method_code_mask": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\n\n\ndef extract_query_params(query): [MASK]\n", "response": "import datetime\nimport decimal\nimport hashlib\nimport logging\nimport re\nimport sqlite3\nfrom urllib.parse import parse_qs\ndef extract_query_params(query):\n    return re.findall('(?:join|from)\\\\s+param_query_(\\\\d+)_{([^}]+)}',\n        query, re.IGNORECASE)"}
