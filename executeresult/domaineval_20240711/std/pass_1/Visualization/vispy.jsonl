{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "get_dpi", "method_path": "../srcdata/Visualization/vispy/vispy/util/dpi/_win32.py", "method_code_mask": "def get_dpi(raise_error=True): [MASK]\n", "response": "\ndef get_dpi(raise_error=True):\n    \"\"\"Get screen DPI from the OS\n\n    Parameters\n    ----------\n    raise_error : bool\n        If True, raise an error if DPI could not be determined.\n\n    Returns\n    -------\n    dpi : float\n        Dots per inch of the primary screen.\n    \"\"\"\n    try:\n        user32.SetProcessDPIAware()\n    except AttributeError:\n        pass\n    dc = user32.GetDC(0)\n    h_size = gdi32.GetDeviceCaps(dc, HORZSIZE)\n    v_size = gdi32.GetDeviceCaps(dc, VERTSIZE)\n    h_res = gdi32.GetDeviceCaps(dc, HORZRES)\n    v_res = gdi32.GetDeviceCaps(dc, VERTRES)\n    user32.ReleaseDC(None, dc)\n    return (h_res / float(h_size) + v_res / float(v_size)) * 0.5 * 25.4"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "stft", "method_path": "../srcdata/Visualization/vispy/vispy/util/fourier.py", "method_code_mask": "import numpy as np\n\n\ndef stft(x, n_fft=1024, step=512, fs=2 * np.pi, window='hann'): [MASK]\n", "response": "import numpy as np\ndef stft(x, n_fft=1024, step=512, fs=2 * np.pi, window='hann'):\n    \"\"\"Compute the STFT\n\n    Parameters\n    ----------\n    x : array-like\n        1D signal to operate on. ``If len(x) < n_fft``, x will be zero-padded\n        to length ``n_fft``.\n    n_fft : int\n        Number of FFT points. Much faster for powers of two.\n    step : int | None\n        Step size between calculations. If None, ``n_fft // 2``\n        will be used.\n    fs : float\n        The sample rate of the data.\n    window : str | None\n        Window function to use. Can be ``'hann'`` for Hann window, or None\n        for no windowing.\n\n    Returns\n    -------\n    stft : ndarray\n        Spectrogram of the data, shape (n_freqs, n_steps).\n\n    See also\n    --------\n    fft_freqs\n    \"\"\"\n    x = np.asarray(x, float)\n    if x.ndim != 1:\n        raise ValueError('x must be 1D')\n    if window is not None:\n        if window not in ('hann',):\n            raise ValueError('window must be \"hann\" or None')\n        w = np.hanning(n_fft)\n    else:\n        w = np.ones(n_fft)\n    n_fft = int(n_fft)\n    step = max(n_fft // 2, 1) if step is None else int(step)\n    fs = float(fs)\n    zero_pad = n_fft - len(x)\n    if zero_pad > 0:\n        x = np.concatenate((x, np.zeros(zero_pad, float)))\n    n_freqs = n_fft // 2 + 1\n    n_estimates = (len(x) - n_fft) // step + 1\n    result = np.empty((n_freqs, n_estimates), np.complex128)\n    for ii in range(n_estimates):\n        result[:, ii] = np.fft.rfft(w * x[ii * step:ii * step + n_fft]) / n_fft\n    return result"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "forget_canvas", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/context.py", "method_code_mask": "from copy import deepcopy\nimport weakref\n\n\ndef forget_canvas(canvas): [MASK]\n", "response": "from copy import deepcopy\nimport weakref\ndef forget_canvas(canvas):\n    \"\"\"Forget about the given canvas. Used by the canvas when closed.\"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "list_fonts", "method_path": "../srcdata/Visualization/vispy/vispy/util/fonts/_triage.py", "method_code_mask": "import sys\n\n\ndef list_fonts(): [MASK]\n", "response": "import sys\ndef list_fonts():\n    \"\"\"List system fonts\n\n    Returns\n    -------\n    fonts : list of str\n        List of system fonts.\n    \"\"\"\n    vals = _list_fonts()\n    for font in _vispy_fonts:\n        vals += [font] if font not in vals else []\n    vals = sorted(vals, key=lambda s: s.lower())\n    return vals"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "convert_shader", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/glir.py", "method_code_mask": "import os\nimport sys\nimport re\nimport json\nimport weakref\nfrom packaging.version import Version\nimport numpy as np\n\n\ndef _convert_es2_shader(shader):\n    has_version = False\n    has_prec_float = False\n    has_prec_int = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        if line_strip.startswith('#version'):\n            continue\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        if line_strip.startswith('precision '):\n            has_prec_float = has_prec_float or 'float' in line\n            has_prec_int = has_prec_int or 'int' in line\n        lines.append(line.rstrip())\n    if not has_prec_float:\n        lines.insert(has_version, 'precision highp float;')\n    if not has_prec_int:\n        lines.insert(has_version, 'precision highp int;')\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    return '\\n'.join(lines)\n\n\ndef _convert_desktop_shader(shader):\n    has_version = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        has_version = has_version or line.startswith('#version')\n        if line_strip.startswith('precision '):\n            line = ''\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        for prec in (' highp ', ' mediump ', ' lowp '):\n            line = line.replace(prec, ' ')\n        lines.append(line.rstrip())\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    if not has_version:\n        lines.insert(0, '#version 120\\n')\n    return '\\n'.join(lines)\n\n\ndef convert_shader(backend_type, shader): [MASK]\n", "response": "import os\nimport sys\nimport re\nimport json\nimport weakref\nfrom packaging.version import Version\nimport numpy as np\ndef _convert_es2_shader(shader):\n    has_version = False\n    has_prec_float = False\n    has_prec_int = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        if line_strip.startswith('#version'):\n            continue\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        if line_strip.startswith('precision '):\n            has_prec_float = has_prec_float or 'float' in line\n            has_prec_int = has_prec_int or 'int' in line\n        lines.append(line.rstrip())\n    if not has_prec_float:\n        lines.insert(has_version, 'precision highp float;')\n    if not has_prec_int:\n        lines.insert(has_version, 'precision highp int;')\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    return '\\n'.join(lines)\ndef _convert_desktop_shader(shader):\n    has_version = False\n    lines = []\n    extensions = []\n    for line in shader.lstrip().splitlines():\n        line_strip = line.lstrip()\n        has_version = has_version or line.startswith('#version')\n        if line_strip.startswith('precision '):\n            line = ''\n        if line_strip.startswith('#extension'):\n            extensions.append(line_strip)\n            line = ''\n        for prec in (' highp ', ' mediump ', ' lowp '):\n            line = line.replace(prec, ' ')\n        lines.append(line.rstrip())\n    if extensions:\n        for ext_line in extensions:\n            lines.insert(has_version, ext_line)\n    if not has_version:\n        lines.insert(0, '#version 120\\n')\n    return '\\n'.join(lines)\ndef convert_shader(backend_type, shader):\n    \"\"\"Modify shader code to be compatible with `backend_type` backend.\"\"\"\n    if backend_type == 'es2':\n        return _convert_es2_shader(shader)\n    elif backend_type == 'desktop':\n        return _convert_desktop_shader(shader)\n    else:\n        raise ValueError('Cannot backend_type shaders to %r.' % backend_type)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "check_enum", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code_mask": "def check_enum(enum, name=None, valid=None): [MASK]\n", "response": "\ndef check_enum(enum, name=None, valid=None):\n    \"\"\"Get lowercase string representation of enum.\"\"\"\n    name = name or 'enum'\n    res = None\n    if isinstance(enum, int):\n        if hasattr(enum, 'name') and enum.name.startswith('GL_'):\n            res = enum.name[3:].lower()\n    elif isinstance(enum, str):\n        res = enum.lower()\n    if res is None:\n        raise ValueError(\n            'Could not determine string representation forenum %r' % enum)\n    elif valid and res not in valid:\n        raise ValueError('Value of %s must be one of %r, not %r' % (name,\n            valid, enum))\n    return res"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "check_variable", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code_mask": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\n\n\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'\n\n\ndef check_variable(name): [MASK]\n", "response": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'\ndef check_variable(name):\n    \"\"\"\n    Return None if *name* is expected to be a valid variable name in any GLSL\n    version. Otherwise, return a string describing the problem.\n    \"\"\"\n    if len(name) > 31:\n        return (\n            'Variable names >31 characters may not function on some systems.')\n    return check_identifier(name)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "set_current_canvas", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/context.py", "method_code_mask": "from copy import deepcopy\nimport weakref\n\n\ndef set_current_canvas(canvas): [MASK]\n", "response": "from copy import deepcopy\nimport weakref\ndef set_current_canvas(canvas):\n    \"\"\"Make a canvas active. Used primarily by the canvas itself.\"\"\"\n    canvas.context._do_CURRENT_command = True\n    if canvasses and canvasses[-1]() is canvas:\n        return\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    cc.append(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "check_identifier", "method_path": "../srcdata/Visualization/vispy/vispy/gloo/util.py", "method_code_mask": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\n\n\ndef check_identifier(name): [MASK]\n", "response": "KEYWORDS = set(['active', 'asm', 'cast', 'class', 'common', 'default',\n    'double', 'dvec2', 'dvec3', 'dvec4', 'enum', 'extern', 'external',\n    'filter', 'fixed', 'flat', 'fvec2', 'fvec3', 'fvec4', 'goto', 'half',\n    'hvec2', 'hvec3', 'hvec4', 'iimage1D', 'iimage1DArray', 'iimage2D',\n    'iimage2DArray', 'iimage3D', 'iimageBuffer', 'iimageCube', 'image1D',\n    'image1DArray', 'image1DArrayShadow', 'image1DShadow', 'image2D',\n    'image2DArray', 'image2DArrayShadow', 'image2DShadow', 'image3D',\n    'imageBuffer', 'imageCube', 'inline', 'input', 'interface', 'long',\n    'namespace', 'noinline', 'output', 'packed', 'partition', 'public',\n    'row_major', 'sampler1D', 'sampler1DShadow', 'sampler2DRect',\n    'sampler2DRectShadow', 'sampler2DShadow', 'sampler3D', 'sampler3DRect',\n    'short', 'sizeof', 'static', 'superp', 'switch', 'template', 'this',\n    'typedef', 'uimage1D', 'uimage1DArray', 'uimage2D', 'uimage2DArray',\n    'uimage3D', 'uimageBuffer', 'uimageCube', 'union', 'unsigned', 'using',\n    'volatile'])\ndef check_identifier(name):\n    if '__' in name:\n        return 'Identifiers may not contain double-underscores.'\n    if name[:3] == 'gl_' or name[:3] == 'GL_':\n        return 'Identifiers may not begin with gl_ or GL_.'\n    if name in KEYWORDS:\n        return 'Identifier is a reserved keyword.'"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "get_color_names", "method_path": "../srcdata/Visualization/vispy/vispy/color/_color_dict.py", "method_code_mask": "def get_color_names(): [MASK]\n", "response": "\ndef get_color_names():\n    \"\"\"Get the known color names\n\n    Returns\n    -------\n    names : list\n        List of color names known by Vispy.\n    \"\"\"\n    names = sorted(_color_dict.keys())\n    return names"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "mix", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef _mix_simple(a, b, x):\n    \"\"\"Mix b (with proportion x) with a.\"\"\"\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x) * a + x * b\n\n\ndef _find_controls(x, controls=None, clip=None):\n    x_controls = np.clip(np.searchsorted(controls, x) - 1, 0, clip)\n    return x_controls.astype(np.int32)\n\n\ndef _interpolate_multi(colors, x, controls):\n    x = x.ravel()\n    n = len(colors)\n    x_step = _find_controls(x, controls, n - 2)\n    controls_length = np.diff(controls).astype(np.float32)\n    controls_length[controls_length == 0.0] = 1.0\n    _to_clip = x - controls[x_step]\n    _to_clip /= controls_length[x_step]\n    x_rel = np.clip(_to_clip, 0.0, 1.0)\n    return colors[x_step], colors[x_step + 1], x_rel[:, None]\n\n\ndef mix(colors, x, controls=None): [MASK]\n", "response": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef _mix_simple(a, b, x):\n    \"\"\"Mix b (with proportion x) with a.\"\"\"\n    x = np.clip(x, 0.0, 1.0)\n    return (1.0 - x) * a + x * b\ndef _find_controls(x, controls=None, clip=None):\n    x_controls = np.clip(np.searchsorted(controls, x) - 1, 0, clip)\n    return x_controls.astype(np.int32)\ndef _interpolate_multi(colors, x, controls):\n    x = x.ravel()\n    n = len(colors)\n    x_step = _find_controls(x, controls, n - 2)\n    controls_length = np.diff(controls).astype(np.float32)\n    controls_length[controls_length == 0.0] = 1.0\n    _to_clip = x - controls[x_step]\n    _to_clip /= controls_length[x_step]\n    x_rel = np.clip(_to_clip, 0.0, 1.0)\n    return colors[x_step], colors[x_step + 1], x_rel[:, None]\ndef mix(colors, x, controls=None):\n    a, b, x_rel = _interpolate_multi(colors, x, controls)\n    return _mix_simple(a, b, x_rel)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "resize", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/calculations.py", "method_code_mask": "import numpy as np\n\n\ndef resize(image, shape, kind='linear'): [MASK]\n", "response": "import numpy as np\ndef resize(image, shape, kind='linear'):\n    \"\"\"Resize an image\n\n    Parameters\n    ----------\n    image : ndarray\n        Array of shape (N, M, ...).\n    shape : tuple\n        2-element shape.\n    kind : str\n        Interpolation, either \"linear\" or \"nearest\".\n\n    Returns\n    -------\n    scaled_image : ndarray\n        New image, will have dtype np.float64.\n    \"\"\"\n    image = np.array(image, float)\n    shape = np.array(shape, int)\n    if shape.ndim != 1 or shape.size != 2:\n        raise ValueError('shape must have two elements')\n    if image.ndim < 2:\n        raise ValueError('image must have two dimensions')\n    if not isinstance(kind, str) or kind not in ('nearest', 'linear'):\n        raise ValueError('mode must be \"nearest\" or \"linear\"')\n    r = np.linspace(0, image.shape[0] - 1, shape[0])\n    c = np.linspace(0, image.shape[1] - 1, shape[1])\n    if kind == 'linear':\n        r_0 = np.floor(r).astype(int)\n        c_0 = np.floor(c).astype(int)\n        r_1 = r_0 + 1\n        c_1 = c_0 + 1\n        top = (r_1 - r)[:, np.newaxis]\n        bot = (r - r_0)[:, np.newaxis]\n        lef = (c - c_0)[np.newaxis, :]\n        rig = (c_1 - c)[np.newaxis, :]\n        c_1 = np.minimum(c_1, image.shape[1] - 1)\n        r_1 = np.minimum(r_1, image.shape[0] - 1)\n        for arr in (top, bot, lef, rig):\n            arr.shape = arr.shape + (1,) * (image.ndim - 2)\n        out = top * rig * image[r_0][:, c_0, ...]\n        out += bot * rig * image[r_1][:, c_0, ...]\n        out += top * lef * image[r_0][:, c_1, ...]\n        out += bot * lef * image[r_1][:, c_1, ...]\n    else:\n        r = np.round(r).astype(int)\n        c = np.round(c).astype(int)\n        out = image[r][:, c, ...]\n    return out"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "_normalize", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef _normalize(x, cmin=None, cmax=None, clip=True): [MASK]\n", "response": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef _normalize(x, cmin=None, cmax=None, clip=True):\n    \"\"\"Normalize an array from the range [cmin, cmax] to [0,1],\n    with optional clipping.\n    \"\"\"\n    if not isinstance(x, np.ndarray):\n        x = np.array(x)\n    if cmin is None:\n        cmin = x.min()\n    if cmax is None:\n        cmax = x.max()\n    if cmin == cmax:\n        return 0.5 * np.ones(x.shape)\n    else:\n        cmin, cmax = float(cmin), float(cmax)\n        y = (x - cmin) * 1.0 / (cmax - cmin)\n        if clip:\n            y = np.clip(y, 0.0, 1.0)\n        return y"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "get_colormap", "method_path": "../srcdata/Visualization/vispy/vispy/color/colormap.py", "method_code_mask": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\n\n\ndef get_colormap(name): [MASK]\n", "response": "from __future__ import division\nimport warnings\nimport numpy as np\nfrom hsluv import hsluv_to_rgb\nimport vispy.gloo\nfrom matplotlib.cm import ScalarMappable\ndef get_colormap(name):\n    \"\"\"Obtain a colormap by name.\n\n    Parameters\n    ----------\n    name : str | Colormap\n        Colormap name. Can also be a Colormap for pass-through.\n\n    Examples\n    --------\n    >>> get_colormap('autumn')\n    >>> get_colormap('single_hue')\n\n    .. versionchanged: 0.7\n\n        Additional args/kwargs are no longer accepted. Colormap instances are\n        no longer created on the fly.\n\n    \"\"\"\n    if isinstance(name, BaseColormap):\n        return name\n    if not isinstance(name, str):\n        raise TypeError('colormap must be a Colormap or string name')\n    if name in _colormaps:\n        cmap = _colormaps[name]\n    elif has_matplotlib():\n        try:\n            cmap = MatplotlibColormap(name)\n        except ValueError:\n            raise KeyError('colormap name %s not found' % name)\n    else:\n        raise KeyError('colormap name %s not found' % name)\n    return cmap"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "create_cylinder", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/generation.py", "method_code_mask": "from __future__ import division\nimport numpy as np\n\n\ndef create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False): [\n    MASK]\n", "response": "from __future__ import division\nimport numpy as np\ndef create_cylinder(rows, cols, radius=[1.0, 1.0], length=1.0, offset=False):\n    \"\"\"Create a cylinder\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows.\n    cols : int\n        Number of columns.\n    radius : tuple of float\n        Cylinder radii.\n    length : float\n        Length of the cylinder.\n    offset : bool\n        Rotate each row by half a column.\n\n    Returns\n    -------\n    cylinder : MeshData\n        Vertices and faces computed for a cylindrical surface.\n    \"\"\"\n    verts = np.empty((rows + 1, cols, 3), dtype=np.float32)\n    if isinstance(radius, int):\n        radius = [radius, radius]\n    th = np.linspace(2 * np.pi, 0, cols).reshape(1, cols)\n    r = np.linspace(radius[0], radius[1], num=rows + 1, endpoint=True).reshape(\n        rows + 1, 1)\n    verts[..., 2] = np.linspace(0, length, num=rows + 1, endpoint=True\n        ).reshape(rows + 1, 1)\n    if offset:\n        th = th + np.pi / cols * np.arange(rows + 1).reshape(rows + 1, 1)\n    verts[..., 0] = r * np.cos(th)\n    verts[..., 1] = r * np.sin(th)\n    verts = verts.reshape((rows + 1) * cols, 3)\n    faces = np.empty((rows * cols * 2, 3), dtype=np.uint32)\n    rowtemplate1 = (np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 0]])\n        ) % cols + np.array([[0, 0, cols]])\n    rowtemplate2 = (np.arange(cols).reshape(cols, 1) + np.array([[0, 1, 1]])\n        ) % cols + np.array([[cols, 0, cols]])\n    for row in range(rows):\n        start = row * cols * 2\n        faces[start:start + cols] = rowtemplate1 + row * cols\n        faces[start + cols:start + cols * 2] = rowtemplate2 + row * cols\n    return MeshData(vertices=verts, faces=faces)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "create_sphere", "method_path": "../srcdata/Visualization/vispy/vispy/geometry/generation.py", "method_code_mask": "from __future__ import division\nimport numpy as np\n\n\ndef create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n    subdivisions=3, method='latitude'): [MASK]\n", "response": "from __future__ import division\nimport numpy as np\ndef create_sphere(rows=10, cols=10, depth=10, radius=1.0, offset=True,\n    subdivisions=3, method='latitude'):\n    \"\"\"Create a sphere\n\n    Parameters\n    ----------\n    rows : int\n        Number of rows (for method='latitude' and 'cube').\n    cols : int\n        Number of columns (for method='latitude' and 'cube').\n    depth : int\n        Number of depth segments (for method='cube').\n    radius : float\n        Sphere radius.\n    offset : bool\n        Rotate each row by half a column (for method='latitude').\n    subdivisions : int\n        Number of subdivisions to perform (for method='ico')\n    method : str\n        Method for generating sphere. Accepts 'latitude' for latitude-\n        longitude, 'ico' for icosahedron, and 'cube' for cube based\n        tessellation.\n\n    Returns\n    -------\n    sphere : MeshData\n        Vertices and faces computed for a spherical surface.\n    \"\"\"\n    if method == 'latitude':\n        return _latitude(rows, cols, radius, offset)\n    elif method == 'ico':\n        return _ico(radius, subdivisions)\n    elif method == 'cube':\n        return _cube(rows, cols, depth, radius)\n    else:\n        raise Exception(\"Invalid method. Accepts: 'latitude', 'ico', 'cube'\")"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "find_program_variables", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/shaders/parsing.py", "method_code_mask": "from __future__ import division\nimport re\n\n\ndef find_program_variables(code): [MASK]\n", "response": "from __future__ import division\nimport re\ndef find_program_variables(code):\n    \"\"\"\n    Return a dict describing program variables::\n\n        {'var_name': ('uniform|attribute|varying', type), ...}\n\n    \"\"\"\n    vars = {}\n    lines = code.split('\\n')\n    for line in lines:\n        m = re.match('\\\\s*' + re_prog_var_declaration + '\\\\s*(=|;)', line)\n        if m is not None:\n            vtype, dtype, names = m.groups()[:3]\n            for name in names.split(','):\n                vars[name.strip()] = vtype, dtype\n    return vars"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "_as_rgba", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/filters/mesh.py", "method_code_mask": "import numbers\nimport numpy as np\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import VertexBuffer\nfrom vispy.visuals.shaders import Function\nfrom vispy.visuals.shaders import Varying\nfrom vispy.visuals.filters import Filter\nfrom vispy.visuals.filters import PrimitivePickingFilter\n\n\ndef _as_rgba(intensity_or_color, default_rgb=(1.0, 1.0, 1.0)): [MASK]\n", "response": "import numbers\nimport numpy as np\nfrom vispy.gloo import Texture2D\nfrom vispy.gloo import VertexBuffer\nfrom vispy.visuals.shaders import Function\nfrom vispy.visuals.shaders import Varying\nfrom vispy.visuals.filters import Filter\nfrom vispy.visuals.filters import PrimitivePickingFilter\ndef _as_rgba(intensity_or_color, default_rgb=(1.0, 1.0, 1.0)):\n    \"\"\"Create an RGBA color from a color or a scalar intensity.\n\n    Examples\n    --------\n    >>> # Specify the full RGBA color.\n    >>> _as_rgba((0.2, 0.3, 0.4, 0.25))\n    ... <Color: (0.2, 0.3, 0.4, 0.25)>\n    >>> # Specify an RGB color. (Default intensity `1.0` is used.)\n    >>> _as_rgba((0.2, 0.3, 0.4))\n    ... <Color: (0.2, 0.3, 0.4, 1.0)>\n    >>> # Specify an intensity only. (Default color `(1.0, 1.0, 1.0)` is used.)\n    >>> _as_rgba(0.25)\n    ... <Color: (1.0, 1.0, 1.0, 0.25)>\n    \"\"\"\n    if isinstance(intensity_or_color, numbers.Number):\n        intensity = intensity_or_color\n        return Color(default_rgb, alpha=intensity)\n    color = intensity_or_color\n    return Color(color)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "SkipTest", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef SkipTest(*args, **kwargs): [MASK]\n", "response": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef SkipTest(*args, **kwargs):\n    \"\"\"Backport for raising SkipTest that gives a better traceback.\"\"\"\n    __tracebackhide__ = True\n    import pytest\n    return pytest.skip(*args, **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "get_default_clim_from_data", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/_scalable_textures.py", "method_code_mask": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\n\n\ndef get_default_clim_from_data(data): [MASK]\n", "response": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\ndef get_default_clim_from_data(data):\n    \"\"\"Compute a reasonable clim from the min and max, taking nans into account.\n\n    If there are no non-finite values (nan, inf, -inf) this is as fast as it can be.\n    Otherwise, this functions is about 3x slower.\n    \"\"\"\n    min_value = data.min()\n    max_value = data.max()\n    min_finite = np.isfinite(min_value)\n    max_finite = np.isfinite(max_value)\n    if not (min_finite and max_finite):\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size:\n            min_value = finite_data.min()\n            max_value = finite_data.max()\n        else:\n            min_value = max_value = 0\n    return min_value, max_value"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "requires_img_lib", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_img_lib(): [MASK]\n", "response": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_img_lib():\n    \"\"\"Decorator for tests that require an image library\"\"\"\n    from ..io import _check_img_lib\n    if sys.platform.startswith('win'):\n        has_img_lib = False\n    else:\n        has_img_lib = not all(c is None for c in _check_img_lib())\n    return skipif(not has_img_lib, reason='imageio or PIL required')"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "get_default_clim_from_dtype", "method_path": "../srcdata/Visualization/vispy/vispy/visuals/_scalable_textures.py", "method_code_mask": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\n\n\ndef get_default_clim_from_dtype(dtype): [MASK]\n", "response": "import warnings\nimport numpy as np\nfrom vispy.gloo.texture import Texture2D\nfrom vispy.gloo.texture import Texture3D\nfrom vispy.gloo.texture import convert_dtype_and_clip\nfrom vispy.util import np_copy_if_needed\ndef get_default_clim_from_dtype(dtype):\n    \"\"\"Get min and max color limits based on the range of the dtype.\"\"\"\n    if np.issubdtype(dtype, np.floating):\n        return 0, 1\n    dtype_info = np.iinfo(dtype)\n    dmin = dtype_info.min\n    dmax = dtype_info.max\n    return dmin, dmax"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "requires_application", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_application(backend=None, has=(), capable=(), force_gc=True): [M\n    ASK]\n", "response": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_application(backend=None, has=(), capable=(), force_gc=True):\n    \"\"\"Return a decorator for tests that require an application\"\"\"\n    good, msg = has_application(backend, has, capable)\n    dec_backend = skipif(not good, reason='Skipping test: %s' % msg)\n    try:\n        import pytest\n    except Exception:\n        return dec_backend\n    dec_app = pytest.mark.vispy_app_test\n    funcs = [dec_app, dec_backend]\n    if force_gc:\n        funcs.append(garbage_collect)\n    return composed(*funcs)"}
{"result": "passed", "model_name": "std", "repository": "vispy", "full_method_name": "requires_pyopengl", "method_path": "../srcdata/Visualization/vispy/vispy/testing/_testing.py", "method_code_mask": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\n\n\ndef requires_pyopengl(): [MASK]\n", "response": "from __future__ import print_function\nimport numpy as np\nimport sys\nimport os\nimport inspect\nimport gc\nimport pytest\nimport functools\nfrom packaging.version import Version\nimport IPython\nimport scipy\nfrom vispy.app import use_app\nimport faulthandler\nimport __main__\ndef requires_pyopengl():\n    skip = not has_pyopengl()\n    return skipif(skip, reason='Requires PyOpenGL')"}
