{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "calculate_avail_vmem", "method_path": "../srcdata/System/psutil/psutil/_pslinux.py", "method_code_mask": "from __future__ import division\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\nimport enum\nfrom resource import prlimit\nimport ctypes\n\n\ndef calculate_avail_vmem(mems): [MASK]\n", "response": "from __future__ import division\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\nimport enum\nfrom resource import prlimit\nimport ctypes\ndef calculate_avail_vmem(mems):\n    \"\"\"Fallback for kernels < 3.14 where /proc/meminfo does not provide\n    \"MemAvailable\", see:\n    https://blog.famzah.net/2014/09/24/.\n\n    This code reimplements the algorithm outlined here:\n    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n        commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n\n    We use this function also when \"MemAvailable\" returns 0 (possibly a\n    kernel bug, see: https://github.com/giampaolo/psutil/issues/1915).\n    In that case this routine matches \"free\" CLI tool result (\"available\"\n    column).\n\n    XXX: on recent kernels this calculation may differ by ~1.5% compared\n    to \"MemAvailable:\", as it's calculated slightly differently.\n    It is still way more realistic than doing (free + cached) though.\n    See:\n    * https://gitlab.com/procps-ng/procps/issues/42\n    * https://github.com/famzah/linux-memavailable-procfs/issues/2\n    \"\"\"\n    free = mems[b'MemFree:']\n    fallback = free + mems.get(b'Cached:', 0)\n    try:\n        lru_active_file = mems[b'Active(file):']\n        lru_inactive_file = mems[b'Inactive(file):']\n        slab_reclaimable = mems[b'SReclaimable:']\n    except KeyError as err:\n        debug(\n            '%s is missing from /proc/meminfo; using an approximation for calculating available memory'\n             % err.args[0])\n        return fallback\n    try:\n        f = open_binary('%s/zoneinfo' % get_procfs_path())\n    except IOError:\n        return fallback\n    watermark_low = 0\n    with f:\n        for line in f:\n            line = line.strip()\n            if line.startswith(b'low'):\n                watermark_low += int(line.split()[1])\n    watermark_low *= PAGESIZE\n    avail = free - watermark_low\n    pagecache = lru_active_file + lru_inactive_file\n    pagecache -= min(pagecache / 2, watermark_low)\n    avail += pagecache\n    avail += slab_reclaimable - min(slab_reclaimable / 2.0, watermark_low)\n    return int(avail)"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "get_ipv4_netmask", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFNETMASK = 35099\n\n\ndef get_ipv4_netmask(ifname): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFNETMASK = 35099\ndef get_ipv4_netmask(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFNETMASK,\n            struct.pack('256s', ifname))[20:24])"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "get_mac_address", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\n\n\ndef get_mac_address(ifname): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFHWADDR = 35111\ndef get_mac_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(s.fileno(), SIOCGIFHWADDR, struct.pack('256s',\n            ifname))\n        if PY3:\n            def ord(x):\n                return x\n        else:\n            import __builtin__\n            ord = __builtin__.ord\n        return ''.join([('%02x:' % ord(char)) for char in info[18:24]])[:-1]"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "parse_environ_block", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef parse_environ_block(data): [MASK]\n", "response": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef parse_environ_block(data):\n    \"\"\"Parse a C environ block of environment variables into a dictionary.\"\"\"\n    ret = {}\n    pos = 0\n    WINDOWS_ = WINDOWS\n    while True:\n        next_pos = data.find('\\x00', pos)\n        if next_pos <= pos:\n            break\n        equal_pos = data.find('=', pos, next_pos)\n        if equal_pos > pos:\n            key = data[pos:equal_pos]\n            value = data[equal_pos + 1:next_pos]\n            if WINDOWS_:\n                key = key.upper()\n            ret[key] = value\n        pos = next_pos + 1\n    return ret"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "get_ipv4_broadcast", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFBRDADDR = 35097\n\n\ndef get_ipv4_broadcast(ifname): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFBRDADDR = 35097\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFBRDADDR,\n            struct.pack('256s', ifname))[20:24])"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "get_ipv4_address", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFADDR = 35093\n\n\ndef get_ipv4_address(ifname): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\nSIOCGIFADDR = 35093\ndef get_ipv4_address(ifname):\n    import fcntl\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct\n            .pack('256s', ifname))[20:24])"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "sysctl", "method_path": "../srcdata/System/psutil/psutil/tests/test_bsd.py", "method_code_mask": "import datetime\nimport os\nimport re\nimport time\nimport unittest\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\nfrom psutil._psutil_posix import getpagesize\nfrom psutil.tests.runner import run_from_name\n\n\ndef sysctl(cmdline): [MASK]\n", "response": "import datetime\nimport os\nimport re\nimport time\nimport unittest\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\nfrom psutil._psutil_posix import getpagesize\nfrom psutil.tests.runner import run_from_name\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    result = sh('sysctl ' + cmdline)\n    if FREEBSD:\n        result = result[result.find(': ') + 2:]\n    elif OPENBSD or NETBSD:\n        result = result[result.find('=') + 1:]\n    try:\n        return int(result)\n    except ValueError:\n        return result"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "supports_ipv6", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = args, frozenset(sorted(kwargs.items()))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\n\n@memoize\ndef supports_ipv6(): [MASK]\n", "response": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = args, frozenset(sorted(kwargs.items()))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n@memoize\ndef supports_ipv6():\n    \"\"\"Return True if IPv6 is supported on this platform.\"\"\"\n    if not socket.has_ipv6 or AF_INET6 is None:\n        return False\n    try:\n        sock = socket.socket(AF_INET6, socket.SOCK_STREAM)\n        with contextlib.closing(sock):\n            sock.bind(('::1', 0))\n        return True\n    except socket.error:\n        return False"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "wrap_numbers", "method_path": "../srcdata/System/psutil/psutil/_common.py", "method_code_mask": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\n\n\ndef wrap_numbers(input_dict, name): [MASK]\n", "response": "from __future__ import division\nfrom __future__ import print_function\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\nfrom socket import AF_INET6\nfrom socket import AF_UNIX\nimport enum\nimport curses\nimport ctypes\nimport inspect\ndef wrap_numbers(input_dict, name):\n    \"\"\"Given an `input_dict` and a function `name`, adjust the numbers\n    which \"wrap\" (restart from zero) across different calls by adding\n    \"old value\" to \"new value\" and return an updated dict.\n    \"\"\"\n    with _wn.lock:\n        return _wn.run(input_dict, name)"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "get_free_version_info", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef get_free_version_info(): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef get_free_version_info():\n    out = sh(['free', '-V']).strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, re.findall('\\\\d+', out.split()[-1])))"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "free_swap", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef free_swap(): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef free_swap():\n    \"\"\"Parse 'free' cmd and return swap memory's s total, used and free\n    values.\n    \"\"\"\n    out = sh(['free', '-b'], env={'LANG': 'C.UTF-8'})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Swap'):\n            _, total, used, free = line.split()\n            nt = collections.namedtuple('free', 'total used free')\n            return nt(int(total), int(used), int(free))\n    raise ValueError(\"can't find 'Swap' in 'free' output:\\n%s\" % '\\n'.join(\n        lines))"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "free_physmem", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef free_physmem(): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef free_physmem():\n    \"\"\"Parse 'free' cmd and return physical memory's total, used\n    and free values.\n    \"\"\"\n    out = sh(['free', '-b'], env={'LANG': 'C.UTF-8'})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Mem'):\n            total, used, free, shared = (int(x) for x in line.split()[1:5])\n            nt = collections.namedtuple('free', 'total used free shared output'\n                )\n            return nt(total, used, free, shared, out)\n    raise ValueError(\"can't find 'Mem' in 'free' output:\\n%s\" % '\\n'.join(\n        lines))"}
{"result": "passed", "model_name": "std", "repository": "psutil", "full_method_name": "vmstat", "method_path": "../srcdata/System/psutil/psutil/tests/test_linux.py", "method_code_mask": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\n\n\ndef vmstat(stat): [MASK]\n", "response": "from __future__ import division\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\nfrom psutil._pslinux import CLOCK_TICKS\nfrom psutil._pslinux import RootFsDeviceFinder\nfrom psutil._pslinux import calculate_avail_vmem\nfrom psutil._pslinux import open_binary\nimport fcntl\nimport psutil._psutil_linux as cext\nimport psutil._pslinux\nfrom psutil.tests.runner import run_from_name\ndef vmstat(stat):\n    out = sh(['vmstat', '-s'], env={'LANG': 'C.UTF-8'})\n    for line in out.split('\\n'):\n        line = line.strip()\n        if stat in line:\n            return int(line.split(' ')[0])\n    raise ValueError(\"can't find %r in 'vmstat' output\" % stat)"}
