{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "get_unique_repo_name", "method_path": "../srcdata/System/anaconda/pyanaconda/ui/gui/spokes/lib/installation_source_helpers.py", "method_code_mask": "import os\nimport re\nimport signal\nfrom functools import partial\n\n\ndef get_unique_repo_name(existing_names=None): [MASK]\n", "response": "import os\nimport re\nimport signal\nfrom functools import partial\ndef get_unique_repo_name(existing_names=None):\n    \"\"\"Return a unique repo name.\n\n    The returned name will be 1 greater than any other entry in the store\n    with a _%d at the end of it.\n\n    :param [str] existing_names: a list of existing names\n    :returns: a unique repo name\n    \"\"\"\n    existing_names = existing_names or []\n    name = 'New_Repository'\n    if name not in existing_names:\n        return name\n    match = re.match('(.*)_\\\\d+$', name)\n    if match:\n        name = match.group(1)\n    name_re = re.compile('(' + re.escape(name) + ')_(\\\\d+)')\n    matches = tuple(map(name_re.match, existing_names))\n    matches = [int(m.group(2)) for m in matches if m is not None]\n    highest_index = max(matches) if matches else 0\n    return name + '_%d' % (highest_index + 1)"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "check_ip_address", "method_path": "../srcdata/System/anaconda/pyanaconda/network.py", "method_code_mask": "import shutil\nimport socket\nimport itertools\nimport os\nimport time\nimport threading\nimport re\nimport ipaddress\n\n\ndef check_ip_address(address, version=None): [MASK]\n", "response": "import shutil\nimport socket\nimport itertools\nimport os\nimport time\nimport threading\nimport re\nimport ipaddress\ndef check_ip_address(address, version=None):\n    \"\"\"Check if the given IP address is valid in given version if set.\n\n    :param str address: IP address for testing\n    :param int version: ``4`` for IPv4, ``6`` for IPv6 or\n                        ``None`` to allow either format\n    :returns: ``True`` if IP address is valid or ``False`` if not\n    :rtype: bool\n    \"\"\"\n    try:\n        if version == 4:\n            ipaddress.IPv4Address(address)\n        elif version == 6:\n            ipaddress.IPv6Address(address)\n        elif not version:\n            ipaddress.ip_address(address)\n        else:\n            log.error('IP version %s is not supported', version)\n            return False\n        return True\n    except ValueError:\n        return False"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "upcase_first_letter", "method_path": "../srcdata/System/anaconda/pyanaconda/core/string.py", "method_code_mask": "import string\nimport unicodedata\n\n\ndef upcase_first_letter(text): [MASK]\n", "response": "import string\nimport unicodedata\ndef upcase_first_letter(text):\n    \"\"\"Upcase first letter of a string.\n\n    Helper function that upcases the first letter of the string. Python's\n    standard string.capitalize() not only upcases the first letter but also\n    lowercases all the others. string.title() capitalizes all words in the\n    string.\n\n    Note: Never use on translated strings!\n\n    :param str text: text to upcase\n    :return str: the given text with the first letter upcased\n    \"\"\"\n    if not text:\n        return text\n    elif len(text) == 1:\n        return text.upper()\n    else:\n        return text[0].upper() + text[1:]"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "_match_field", "method_path": "../srcdata/System/anaconda/pyanaconda/modules/subscription/system_purpose.py", "method_code_mask": "import os\nimport json\n\n\ndef _normalize_field(raw_field):\n    \"\"\"Normalize a field for matching.\n\n    Fields specified in free form by users can have different case or trailing white space,\n    while still technically being a match on a valid field.\n\n    So convert the field to lower case and strip any trailing white space and return the result.\n\n    :param str raw_field: raw not normalized field\n    :return: normalized field suitable for matching\n    :rtype: str\n    \"\"\"\n    return raw_field.strip().lower()\n\n\ndef _match_field(raw_field, valid_fields): [MASK]\n", "response": "import os\nimport json\ndef _normalize_field(raw_field):\n    \"\"\"Normalize a field for matching.\n\n    Fields specified in free form by users can have different case or trailing white space,\n    while still technically being a match on a valid field.\n\n    So convert the field to lower case and strip any trailing white space and return the result.\n\n    :param str raw_field: raw not normalized field\n    :return: normalized field suitable for matching\n    :rtype: str\n    \"\"\"\n    return raw_field.strip().lower()\ndef _match_field(raw_field, valid_fields):\n    \"\"\"Try to match the field on an item in a list of fields.\n    If a match is found return the first matching item from the list.\n    If no match is found, return None.\n    :param raw_field str: field to match\n    :param list valid_fields: list of valid fields to match against\n    :return: a matching valid field or None if no match is found\n    :rtype: str or None\n    \"\"\"\n    matching_valid_field = None\n    normalized_field = _normalize_field(raw_field)\n    for valid_field in valid_fields:\n        if normalized_field == _normalize_field(valid_field):\n            matching_valid_field = valid_field\n            break\n    return matching_valid_field"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "is_tar", "method_path": "../srcdata/System/anaconda/pyanaconda/modules/payloads/source/utils.py", "method_code_mask": "import os\nimport os.path\nimport stat\n\n\ndef is_tar(url): [MASK]\n", "response": "import os\nimport os.path\nimport stat\ndef is_tar(url):\n    \"\"\"Is the given URL a path to the tarball?\n\n    :param url: a string with URL\n    :return: True or False\n    \"\"\"\n    if not url:\n        return False\n    tar_suffixes = ('.tar', '.tbz', '.tgz', '.txz', '.tar.bz2', '.tar.gz',\n        '.tar.xz')\n    return any(url.endswith(s) for s in tar_suffixes)"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "trim_product_version_for_ui", "method_path": "../srcdata/System/anaconda/pyanaconda/core/product.py", "method_code_mask": "import os\nimport configparser\nfrom functools import cache\nfrom collections import namedtuple\n\n\ndef trim_product_version_for_ui(version): [MASK]\n", "response": "import os\nimport configparser\nfrom functools import cache\nfrom collections import namedtuple\ndef trim_product_version_for_ui(version):\n    \"\"\"Trim off parts of version that should not be displayed in UI.\n\n    Example: 8.0.1 -> 8.0\n\n    :param str version: Version as read from the system\n    :return str: Shortened version\n    \"\"\"\n    if version.count('.') >= 2:\n        version = '.'.join(version.split('.')[:2])\n    if version == 'development':\n        version = 'rawhide'\n    return version"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "shorten_product_name", "method_path": "../srcdata/System/anaconda/pyanaconda/core/product.py", "method_code_mask": "import os\nimport configparser\nfrom functools import cache\nfrom collections import namedtuple\n\n\ndef shorten_product_name(long_name): [MASK]\n", "response": "import os\nimport configparser\nfrom functools import cache\nfrom collections import namedtuple\ndef shorten_product_name(long_name):\n    \"\"\"Shorten a product name.\n\n    This is used in device names. eg. \"fedora\", \"rhel\".\n\n    :param str long_name: Name of the product, as read from the system\n    :return str: Short name for the product\n    \"\"\"\n    product_short_name = long_name.lower()\n    if long_name.count(' '):\n        product_short_name = ''.join(s[0] for s in product_short_name.split())\n    return product_short_name"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "split_protocol", "method_path": "../srcdata/System/anaconda/pyanaconda/core/payload.py", "method_code_mask": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\n\n\ndef split_protocol(url): [MASK]\n", "response": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\ndef split_protocol(url):\n    \"\"\"Split protocol from url\n\n    The function will look for ://.\n\n    - If found more than once in the url then raising an error.\n    - If found exactly once it will return tuple with [protocol, rest_of_url].\n    - If an empty string is given it will return tuple with empty strings (\"\", \"\").\n\n    :param str url: base url we want to split protocol from\n    :return: tuple of (protocol, rest of url)\n    :raise: ValueError if url is invalid\n    \"\"\"\n    ret = url.split('://')\n    if len(ret) > 2:\n        raise ValueError(\"Invalid url to split protocol '{}'\".format(url))\n    if len(ret) == 2:\n        return ret[0] + '://', ret[1]\n    if len(ret) == 1:\n        return '', ret[0]\n    return '', ''"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "parse_nfs_url", "method_path": "../srcdata/System/anaconda/pyanaconda/core/payload.py", "method_code_mask": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nNFSUrl = namedtuple('NFSUrl', ['options', 'host', 'path'])\n\n\ndef parse_nfs_url(nfs_url): [MASK]\n", "response": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\nNFSUrl = namedtuple('NFSUrl', ['options', 'host', 'path'])\ndef parse_nfs_url(nfs_url):\n    \"\"\"Parse NFS URL into components.\n    :param str nfs_url: a URL with the nfs: or nfs:// prefix\n    :return NFSUrl: a tuple with options, host and path\n    \"\"\"\n    host, path, options = '', '', ''\n    if nfs_url.startswith('nfs://'):\n        args = nfs_url.removeprefix('nfs://').split(':')\n        if len(args) >= 2:\n            host, path = args[:2]\n        elif len(args) >= 1:\n            host = args[0]\n    elif nfs_url.startswith('nfs:'):\n        args = nfs_url.removeprefix('nfs:').split(':')\n        if len(args) >= 3:\n            options, host, path = args[:3]\n        elif len(args) >= 2:\n            host, path = args[:2]\n        elif len(args) >= 1:\n            host = args[0]\n    return NFSUrl(options=options, host=host, path=path)"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "join_layout_variant", "method_path": "../srcdata/System/anaconda/pyanaconda/keyboard.py", "method_code_mask": "import re\n\n\ndef join_layout_variant(layout, variant=''): [MASK]\n", "response": "import re\ndef join_layout_variant(layout, variant=''):\n    \"\"\"\n    Join layout and variant to form the commonly used 'layout (variant)'\n    or 'layout' (if variant is missing) format.\n\n    :type layout: string\n    :type variant: string\n    :return: 'layout (variant)' or 'layout' string\n    :rtype: string\n\n    \"\"\"\n    if variant:\n        return '%s (%s)' % (layout, variant)\n    else:\n        return layout"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "create_hdd_url", "method_path": "../srcdata/System/anaconda/pyanaconda/core/payload.py", "method_code_mask": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\n\n\ndef create_hdd_url(device, path=None): [MASK]\n", "response": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\ndef create_hdd_url(device, path=None):\n    \"\"\"Compose the HDD URL from components.\n\n    :param str device: a device spec\n    :param str path: a path or None\n    \"\"\"\n    if not device:\n        return ''\n    if path:\n        return ':'.join(['hd', device, path])\n    else:\n        return ':'.join(['hd', device])"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "create_nfs_url", "method_path": "../srcdata/System/anaconda/pyanaconda/core/payload.py", "method_code_mask": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\n\n\ndef create_nfs_url(host, path, options=None): [MASK]\n", "response": "from collections import namedtuple\nfrom functools import cmp_to_key\nfrom urllib.parse import quote\nfrom urllib.parse import unquote\ndef create_nfs_url(host, path, options=None):\n    \"\"\"Compose NFS url from components.\n\n    :param str host: NFS server\n    :param str path: path on the NFS server to the shared folder\n    :param options: NFS mount options\n    :type options: str or None if not set\n    :return: NFS url created from the components given\n    :rtype: str\n    \"\"\"\n    if not host:\n        return ''\n    if options:\n        return ':'.join(['nfs', options, host, path])\n    elif path:\n        return ':'.join(['nfs', host, path])\n    else:\n        return ':'.join(['nfs', host])"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "normalize_layout_variant", "method_path": "../srcdata/System/anaconda/pyanaconda/keyboard.py", "method_code_mask": "import re\n\n\ndef join_layout_variant(layout, variant=''):\n    \"\"\"\n    Join layout and variant to form the commonly used 'layout (variant)'\n    or 'layout' (if variant is missing) format.\n\n    :type layout: string\n    :type variant: string\n    :return: 'layout (variant)' or 'layout' string\n    :rtype: string\n\n    \"\"\"\n    if variant:\n        return '%s (%s)' % (layout, variant)\n    else:\n        return layout\n\n\nLAYOUT_VARIANT_RE = re.compile(\n    '^\\\\s*([/\\\\w]+)\\\\s*(?:(?:\\\\(\\\\s*([-\\\\w]+)\\\\s*\\\\))|(?:$))\\\\s*')\n\n\ndef parse_layout_variant(layout_variant_str):\n    \"\"\"\n    Parse layout and variant from the string that may look like 'layout' or\n    'layout (variant)'.\n    :param layout_variant_str: keyboard layout and variant string specification\n    :type layout_variant_str: str\n    :return: the (layout, variant) pair, where variant can be \"\"\n    :rtype: tuple\n    :raise InvalidLayoutVariantSpec: if the given string isn't a valid layout\n                                     and variant specification string\n    \"\"\"\n    match = LAYOUT_VARIANT_RE.match(layout_variant_str)\n    if not match:\n        msg = (\n            \"'%s' is not a valid keyboard layout and variant specification\" %\n            layout_variant_str)\n        raise InvalidLayoutVariantSpec(msg)\n    layout, variant = match.groups()\n    return layout, variant or ''\n\n\ndef normalize_layout_variant(layout_str): [MASK]\n", "response": "import re\ndef join_layout_variant(layout, variant=''):\n    \"\"\"\n    Join layout and variant to form the commonly used 'layout (variant)'\n    or 'layout' (if variant is missing) format.\n\n    :type layout: string\n    :type variant: string\n    :return: 'layout (variant)' or 'layout' string\n    :rtype: string\n\n    \"\"\"\n    if variant:\n        return '%s (%s)' % (layout, variant)\n    else:\n        return layout\nLAYOUT_VARIANT_RE = re.compile(\n    '^\\\\s*([/\\\\w]+)\\\\s*(?:(?:\\\\(\\\\s*([-\\\\w]+)\\\\s*\\\\))|(?:$))\\\\s*')\ndef parse_layout_variant(layout_variant_str):\n    \"\"\"\n    Parse layout and variant from the string that may look like 'layout' or\n    'layout (variant)'.\n    :param layout_variant_str: keyboard layout and variant string specification\n    :type layout_variant_str: str\n    :return: the (layout, variant) pair, where variant can be \"\"\n    :rtype: tuple\n    :raise InvalidLayoutVariantSpec: if the given string isn't a valid layout\n                                     and variant specification string\n    \"\"\"\n    match = LAYOUT_VARIANT_RE.match(layout_variant_str)\n    if not match:\n        msg = (\n            \"'%s' is not a valid keyboard layout and variant specification\" %\n            layout_variant_str)\n        raise InvalidLayoutVariantSpec(msg)\n    layout, variant = match.groups()\n    return layout, variant or ''\ndef normalize_layout_variant(layout_str):\n    \"\"\"\n    Normalize keyboard layout and variant specification given as a single\n    string. E.g. for a 'layout(variant) string missing the space between the\n    left parenthesis return 'layout (variant)' which is a proper layout and\n    variant specification we use.\n    :param layout_str: a string specifying keyboard layout and its variant\n    :type layout_str: string\n    \"\"\"\n    layout, variant = parse_layout_variant(layout_str)\n    return join_layout_variant(layout, variant)"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "split_in_two", "method_path": "../srcdata/System/anaconda/pyanaconda/core/string.py", "method_code_mask": "import string\nimport unicodedata\n\n\ndef split_in_two(text, delimiter=None): [MASK]\n", "response": "import string\nimport unicodedata\ndef split_in_two(text, delimiter=None):\n    \"\"\"Split the given string into two strings.\n\n    This function is useful for safe tuple unpacking.\n    The functionality is similar to str.partition(),\n    but it supports the delimiter of str.split().\n\n    If the delimiter is None, the string is split by\n    a group of whitespace characters that are treated\n    as a single separator.\n\n    For example:\n\n        first, second = split_in_two(text)\n\n    :param text: a string to split\n    :param delimiter: a delimiter for splitting\n    :return: a tuple of exactly two strings\n    \"\"\"\n    items = iter(text.split(sep=delimiter, maxsplit=1))\n    return next(items, ''), next(items, '')"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "have_word_match", "method_path": "../srcdata/System/anaconda/pyanaconda/core/string.py", "method_code_mask": "import string\nimport unicodedata\n\n\ndef have_word_match(str1, str2): [MASK]\n", "response": "import string\nimport unicodedata\ndef have_word_match(str1, str2):\n    \"\"\"Tells if all words from str1 exist in str2 or not.\n\n    :param str str1: list of words to look for\n    :param str str2: list of words to search in\n    :return bool: does str2 contain all the words from str1\n    \"\"\"\n    if str1 is None or str2 is None:\n        return False\n    if str1 == '':\n        return True\n    if str2 == '':\n        return False\n    str1 = str1.lower()\n    str1_words = str1.split()\n    str2 = str2.lower()\n    return all(word in str2 for word in str1_words)"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "_to_ascii", "method_path": "../srcdata/System/anaconda/pyanaconda/core/string.py", "method_code_mask": "import string\nimport unicodedata\n\n\ndef _to_ascii(s): [MASK]\n", "response": "import string\nimport unicodedata\ndef _to_ascii(s):\n    \"\"\"Convert a unicode string to ASCII\n\n    :param str s: input string\n    :return str: string with only ASCII characters\n    \"\"\"\n    if isinstance(s, str):\n        s = unicodedata.normalize('NFKD', s).encode('ascii', 'ignore').decode(\n            'ascii')\n    elif not isinstance(s, bytes):\n        s = ''\n    return s"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "isConsoleOnVirtualTerminal", "method_path": "../srcdata/System/anaconda/pyanaconda/core/util.py", "method_code_mask": "import os\nimport os.path\nimport subprocess\nimport tempfile\nimport re\nimport signal\nimport sys\nimport types\nimport inspect\nimport functools\nimport importlib.util\nimport importlib.machinery\nimport requests\n\n\ndef get_active_console(dev='console'):\n    \"\"\"Find the active console device.\n\n    Some tty devices (/dev/console, /dev/tty0) aren't actual devices;\n    they just redirect input and output to the real console device(s).\n\n    These 'fake' ttys have an 'active' sysfs attribute, which lists the real\n    console device(s). (If there's more than one, the *last* one in the list\n    is the primary console.)\n    \"\"\"\n    while os.path.exists('/sys/class/tty/%s/active' % dev):\n        console_path = '/sys/class/tty/%s/active' % dev\n        active = open(console_path, 'rt').read()\n        if active.split():\n            dev = active.split()[-1]\n        else:\n            log.warning('%s is empty while console name is expected',\n                console_path)\n            dev = ''\n            break\n    return dev\n\n\ndef isConsoleOnVirtualTerminal(dev='console'): [MASK]\n", "response": "import os\nimport os.path\nimport subprocess\nimport tempfile\nimport re\nimport signal\nimport sys\nimport types\nimport inspect\nimport functools\nimport importlib.util\nimport importlib.machinery\nimport requests\ndef get_active_console(dev='console'):\n    \"\"\"Find the active console device.\n\n    Some tty devices (/dev/console, /dev/tty0) aren't actual devices;\n    they just redirect input and output to the real console device(s).\n\n    These 'fake' ttys have an 'active' sysfs attribute, which lists the real\n    console device(s). (If there's more than one, the *last* one in the list\n    is the primary console.)\n    \"\"\"\n    while os.path.exists('/sys/class/tty/%s/active' % dev):\n        console_path = '/sys/class/tty/%s/active' % dev\n        active = open(console_path, 'rt').read()\n        if active.split():\n            dev = active.split()[-1]\n        else:\n            log.warning('%s is empty while console name is expected',\n                console_path)\n            dev = ''\n            break\n    return dev\ndef isConsoleOnVirtualTerminal(dev='console'):\n    console = get_active_console(dev)\n    consoletype = console.rstrip('0123456789')\n    return consoletype == 'tty'"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "item_counter", "method_path": "../srcdata/System/anaconda/pyanaconda/core/util.py", "method_code_mask": "import os\nimport os.path\nimport subprocess\nimport tempfile\nimport re\nimport signal\nimport sys\nimport types\nimport inspect\nimport functools\nimport importlib.util\nimport importlib.machinery\nimport requests\n\n\ndef item_counter(item_count): [MASK]\n", "response": "import os\nimport os.path\nimport subprocess\nimport tempfile\nimport re\nimport signal\nimport sys\nimport types\nimport inspect\nimport functools\nimport importlib.util\nimport importlib.machinery\nimport requests\ndef item_counter(item_count):\n    \"\"\"A generator for easy counting of items.\n\n    :param int item_count: number of items\n\n    The general idea is to initialize the generator with the number\n    of items and then activating it every time an item is being\n    processed.\n\n    The generator produces strings in the <index>/<item count> format,\n    for example:\n    1/20\n    2/20\n    3/20\n    And so on.\n\n    Such strings can be easily used to add a current/total counter\n    to log messages when tasks and task queues are processed.\n    \"\"\"\n    if item_count < 0:\n        raise ValueError(\"Item count can't be negative.\")\n    index = 1\n    while index <= item_count:\n        yield '%d/%d' % (index, item_count)\n        index += 1"}
{"result": "passed", "model_name": "std", "repository": "anaconda", "full_method_name": "strip_accents", "method_path": "../srcdata/System/anaconda/pyanaconda/core/string.py", "method_code_mask": "import string\nimport unicodedata\n\n\ndef strip_accents(s): [MASK]\n", "response": "import string\nimport unicodedata\ndef strip_accents(s):\n    \"\"\"Remove diacritics from a string.\n\n    This function takes arbitrary unicode string and returns it with all the diacritics removed.\n\n    :param str s: arbitrary string\n    :return str: s with diacritics removed\n    \"\"\"\n    return ''.join(c for c in unicodedata.normalize('NFD', s) if \n        unicodedata.category(c) != 'Mn')"}
