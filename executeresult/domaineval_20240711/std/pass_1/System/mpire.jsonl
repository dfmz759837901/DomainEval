{"result": "passed", "model_name": "std", "repository": "mpire", "full_method_name": "make_single_arguments", "method_path": "../srcdata/System/mpire/mpire/utils.py", "method_code_mask": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\n\n\ndef make_single_arguments(iterable_of_args: Iterable, generator: bool=True\n    ) ->Union[List, Generator]: [MASK]\n", "response": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\ndef make_single_arguments(iterable_of_args: Iterable, generator: bool=True\n    ) ->Union[List, Generator]:\n    \"\"\"\n    Converts an iterable of single arguments to an iterable of single argument tuples\n\n    :param iterable_of_args: A numpy array or an iterable containing tuples of arguments to pass to a worker, which\n        passes it to the function\n    :param generator: Whether or not to return a generator, otherwise a materialized list will be returned\n    :return: Iterable of single argument tuples\n    \"\"\"\n    gen = ((arg,) for arg in iterable_of_args)\n    return gen if generator else list(gen)"}
{"result": "passed", "model_name": "std", "repository": "mpire", "full_method_name": "get_number_of_tasks", "method_path": "../srcdata/System/mpire/mpire/params.py", "method_code_mask": "import itertools\nimport math\nimport multiprocessing as mp\nimport warnings\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sized\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom tqdm import TqdmKeyError\n\n\ndef get_number_of_tasks(iterable_of_args: Union[Sized, Iterable],\n    iterable_len: Optional[int]) ->Optional[int]: [MASK]\n", "response": "import itertools\nimport math\nimport multiprocessing as mp\nimport warnings\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sized\nfrom typing import Tuple\nfrom typing import Type\nfrom typing import Union\nfrom tqdm import TqdmKeyError\ndef get_number_of_tasks(iterable_of_args: Union[Sized, Iterable],\n    iterable_len: Optional[int]) ->Optional[int]:\n    \"\"\"\n    Get the number of tasks to process. If iterable_len is provided, it will be used. Otherwise, if iterable_of_args\n    is a Sized object, len(iterable_of_args) will be used. Otherwise, None will be returned.\n\n    :param iterable_of_args: A numpy array or an iterable containing tuples of arguments to pass to a worker\n    :param iterable_len: Number of elements in the ``iterable_of_args``\n    :return: Number of tasks to process\n    \"\"\"\n    if iterable_len is not None:\n        return iterable_len\n    if hasattr(iterable_of_args, '__len__'):\n        return len(iterable_of_args)\n    return None"}
{"result": "passed", "model_name": "std", "repository": "mpire", "full_method_name": "chunk_tasks", "method_path": "../srcdata/System/mpire/mpire/utils.py", "method_code_mask": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\n\n\ndef chunk_tasks(iterable_of_args: Iterable, iterable_len: Optional[int]=\n    None, chunk_size: Optional[Union[int, float]]=None, n_splits: Optional[\n    int]=None) ->Generator[Collection, None, None]: [MASK]\n", "response": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\ndef chunk_tasks(iterable_of_args: Iterable, iterable_len: Optional[int]=\n    None, chunk_size: Optional[Union[int, float]]=None, n_splits: Optional[\n    int]=None) ->Generator[Collection, None, None]:\n    \"\"\"\n    Chunks tasks such that individual workers will receive chunks of tasks rather than individual ones, which can\n    speed up processing drastically.\n\n    :param iterable_of_args: A numpy array or an iterable containing tuples of arguments to pass to a worker, which\n        passes it to the function\n    :param iterable_len: Number of tasks available in ``iterable_of_args``. Only needed when ``iterable_of_args`` is a\n        generator\n    :param chunk_size: Number of simultaneous tasks to give to a worker. If ``None``, will use ``n_splits`` to determine\n        the chunk size\n    :param n_splits: Number of splits to use when ``chunk_size`` is ``None``\n    :return: Generator of chunked task arguments\n    \"\"\"\n    if chunk_size is None and n_splits is None:\n        raise ValueError('chunk_size and n_splits cannot both be None')\n    if chunk_size is None:\n        if iterable_len is not None:\n            n_tasks = iterable_len\n        elif hasattr(iterable_of_args, '__len__'):\n            n_tasks = len(iterable_of_args)\n        else:\n            raise ValueError(\n                'Either iterable_len or an iterable with a len() function should be provided when chunk_size and n_splits are None'\n                )\n        chunk_size = n_tasks / n_splits\n    args_iter = iter(iterable_of_args)\n    current_chunk_size = chunk_size\n    n_elements_returned = 0\n    while True:\n        if NUMPY_INSTALLED and isinstance(iterable_of_args, np.ndarray):\n            chunk = iterable_of_args[n_elements_returned:\n                n_elements_returned + max(1, math.ceil(current_chunk_size))]\n        else:\n            chunk = tuple(itertools.islice(args_iter, max(1, math.ceil(\n                current_chunk_size))))\n        if len(chunk) == 0:\n            return\n        if iterable_len is not None and n_elements_returned + len(chunk\n            ) > iterable_len:\n            chunk = chunk[:iterable_len - n_elements_returned]\n            if chunk:\n                yield chunk\n            return\n        yield chunk\n        current_chunk_size = current_chunk_size + chunk_size - math.ceil(\n            current_chunk_size)\n        n_elements_returned += len(chunk)"}
{"result": "passed", "model_name": "std", "repository": "mpire", "full_method_name": "format_seconds", "method_path": "../srcdata/System/mpire/mpire/utils.py", "method_code_mask": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\n\n\ndef format_seconds(seconds: Optional[Union[int, float]], with_milliseconds:\n    bool) ->str: [MASK]\n", "response": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\ndef format_seconds(seconds: Optional[Union[int, float]], with_milliseconds:\n    bool) ->str:\n    \"\"\"\n    Format seconds to a string, optionally with or without milliseconds\n\n    :param seconds: Number of seconds\n    :param with_milliseconds: Whether to display milliseconds as well\n    :return: String formatted time\n    \"\"\"\n    if seconds is None:\n        return ''\n    duration = str(timedelta(seconds=seconds)).rsplit('.', 1)\n    if with_milliseconds and len(duration) > 1:\n        duration = f'{duration[0]}.{duration[1][:3]}'\n    else:\n        duration = duration[0]\n    return duration"}
{"result": "passed", "model_name": "std", "repository": "mpire", "full_method_name": "chunk_tasks", "method_path": "../srcdata/System/mpire/mpire/utils.py", "method_code_mask": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\ntry:\n    import numpy as np\n    NUMPY_INSTALLED = True\nexcept ImportError:\n    np = None\n    NUMPY_INSTALLED = False\n\n\ndef chunk_tasks(iterable_of_args: Iterable, iterable_len: Optional[int]=\n    None, chunk_size: Optional[Union[int, float]]=None, n_splits: Optional[\n    int]=None) ->Generator[Collection, None, None]: [MASK]\n", "response": "import heapq\nimport itertools\nimport math\nimport os\nimport time\nfrom datetime import timedelta\nfrom multiprocessing import cpu_count\nfrom multiprocessing.managers import SyncManager\nfrom multiprocessing.sharedctypes import SynchronizedArray\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Generator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\ntry:\n    import numpy as np\n    NUMPY_INSTALLED = True\nexcept ImportError:\n    np = None\n    NUMPY_INSTALLED = False\ndef chunk_tasks(iterable_of_args: Iterable, iterable_len: Optional[int]=\n    None, chunk_size: Optional[Union[int, float]]=None, n_splits: Optional[\n    int]=None) ->Generator[Collection, None, None]:\n    \"\"\"\n    Chunks tasks such that individual workers will receive chunks of tasks rather than individual ones, which can\n    speed up processing drastically.\n    :param iterable_of_args: A numpy array or an iterable containing tuples of arguments to pass to a worker, which\n        passes it to the function\n    :param iterable_len: Number of tasks available in ``iterable_of_args``. Only needed when ``iterable_of_args`` is a\n        generator\n    :param chunk_size: Number of simultaneous tasks to give to a worker. If ``None``, will use ``n_splits`` to determine\n        the chunk size\n    :param n_splits: Number of splits to use when ``chunk_size`` is ``None``\n    :return: Generator of chunked task arguments\n    \"\"\"\n    if chunk_size is None and n_splits is None:\n        raise ValueError('chunk_size and n_splits cannot both be None')\n    if chunk_size is None:\n        if iterable_len is not None:\n            n_tasks = iterable_len\n        elif hasattr(iterable_of_args, '__len__'):\n            n_tasks = len(iterable_of_args)\n        else:\n            raise ValueError(\n                'Either iterable_len or an iterable with a len() function should be provided when chunk_size and n_splits are None'\n                )\n        chunk_size = n_tasks / n_splits\n    args_iter = iter(iterable_of_args)\n    current_chunk_size = chunk_size\n    n_elements_returned = 0\n    while True:\n        if NUMPY_INSTALLED and isinstance(iterable_of_args, np.ndarray):\n            chunk = iterable_of_args[n_elements_returned:\n                n_elements_returned + max(1, math.ceil(current_chunk_size))]\n        else:\n            chunk = tuple(itertools.islice(args_iter, max(1, math.ceil(\n                current_chunk_size))))\n        if len(chunk) == 0:\n            return\n        if iterable_len is not None and n_elements_returned + len(chunk\n            ) > iterable_len:\n            chunk = chunk[:iterable_len - n_elements_returned]\n            if chunk:\n                yield chunk\n            return\n        yield chunk\n        current_chunk_size = current_chunk_size + chunk_size - math.ceil(\n            current_chunk_size)\n        n_elements_returned += len(chunk)"}
