{"result": "passed", "model_name": "std", "repository": "pandapower", "full_method_name": "get_indices", "method_path": "../srcdata/System/pandapower/pandapower/auxiliary.py", "method_code_mask": "import copy\nfrom collections.abc import MutableMapping\nimport warnings\nfrom importlib.metadata import version as version_str\nfrom importlib.metadata import PackageNotFoundError\nfrom typing_extensions import deprecated\nimport numpy as np\nimport pandas as pd\nimport scipy as sp\nimport numbers\nfrom packaging.version import Version\nimport logging\nfrom numba import jit\n\n\ndef get_indices(selection, lookup, fused_indices=True): [MASK]\n", "response": "import copy\nfrom collections.abc import MutableMapping\nimport warnings\nfrom importlib.metadata import version as version_str\nfrom importlib.metadata import PackageNotFoundError\nfrom typing_extensions import deprecated\nimport numpy as np\nimport pandas as pd\nimport scipy as sp\nimport numbers\nfrom packaging.version import Version\nimport logging\nfrom numba import jit\ndef get_indices(selection, lookup, fused_indices=True):\n    \"\"\"\n    Helper function during pd2mpc conversion. It resolves the mapping from a\n    given selection of indices to the actual indices, using a dict lookup being\n    passed as well.\n\n    :param selection: Indices we want to select\n    :param lookup: The mapping itself\n    :param fused_indices: Flag which way the conversion is working.\n    :return:\n    \"\"\"\n    if fused_indices:\n        return np.array([lookup[k] for k in selection], dtype=np.int64)\n    else:\n        return np.array([lookup['before_fuse'][k] for k in selection],\n            dtype=np.int64)"}
{"result": "passed", "model_name": "std", "repository": "pandapower", "full_method_name": "_convert_xy_epsg", "method_path": "../srcdata/System/pandapower/pandapower/plotting/geo.py", "method_code_mask": "from typing import List\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import Dict\nfrom typing import Any\nfrom typing import Union\nimport numpy as np\nfrom typing_extensions import deprecated\nimport sys\nimport math\nimport pandas as pd\nfrom numpy import array\nimport logging\nfrom shapely.geometry import Point\nfrom shapely.geometry import LineString\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom pyproj import Transformer\ntry:\n    from pyproj import Transformer\n    pyproj_INSTALLED = True\nexcept ImportError:\n    pyproj_INSTALLED = False\n\n\ndef _convert_xy_epsg(x, y, epsg_in=4326, epsg_out=31467): [MASK]\n", "response": "from typing import List\nfrom typing import Tuple\nfrom typing import TYPE_CHECKING\nfrom typing import Dict\nfrom typing import Any\nfrom typing import Union\nimport numpy as np\nfrom typing_extensions import deprecated\nimport sys\nimport math\nimport pandas as pd\nfrom numpy import array\nimport logging\nfrom shapely.geometry import Point\nfrom shapely.geometry import LineString\nfrom geopandas import GeoDataFrame\nfrom geopandas import GeoSeries\nfrom pyproj import Transformer\ntry:\n    from pyproj import Transformer\n    pyproj_INSTALLED = True\nexcept ImportError:\n    pyproj_INSTALLED = False\ndef _convert_xy_epsg(x, y, epsg_in=4326, epsg_out=31467):\n    \"\"\"\n    Converts the given x and y coordinates according to the defined epsg projections.\n    :param x: x-values of coordinates\n    :type x: iterable\n    :param y: y-values of coordinates\n    :type y: iterable\n    :param epsg_in: current epsg projection\n    :type epsg_in: int, default 4326 (= WGS84)\n    :param epsg_out: epsg projection to be transformed to\n    :type epsg_out: int, default 31467 (= Gauss-Kr\u00fcger Zone 3)\n    :return: transformed_coords - x and y values in new coordinate system\n    \"\"\"\n    if not pyproj_INSTALLED:\n        soft_dependency_error(str(sys._getframe().f_code.co_name) + '()',\n            'pyproj')\n    transformer = Transformer.from_crs(f'EPSG:{epsg_in}',\n        f'EPSG:{epsg_out}', always_xy=True)\n    return transformer.transform(x, y)"}
