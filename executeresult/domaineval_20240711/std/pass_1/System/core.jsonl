{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "create_matcher", "method_path": "../srcdata/System/core/homeassistant/components/conversation/util.py", "method_code_mask": "from __future__ import annotations\nimport re\n\n\ndef create_matcher(utterance: str) ->re.Pattern[str]: [MASK]\n", "response": "from __future__ import annotations\nimport re\ndef create_matcher(utterance: str) ->re.Pattern[str]:\n    \"\"\"Create a regex that matches the utterance.\"\"\"\n    parts = re.split('({\\\\w+}|\\\\[[\\\\w\\\\s]+\\\\] *)', utterance)\n    group_matcher = re.compile('{(\\\\w+)}')\n    optional_matcher = re.compile('\\\\[([\\\\w ]+)\\\\] *')\n    pattern = ['^']\n    for part in parts:\n        group_match = group_matcher.match(part)\n        optional_match = optional_matcher.match(part)\n        if group_match is None and optional_match is None:\n            pattern.append(part)\n            continue\n        if group_match is not None:\n            pattern.append(f'(?P<{group_match.groups()[0]}>[\\\\w ]+?)\\\\s*')\n        elif optional_match is not None:\n            pattern.append(f'(?:{optional_match.groups()[0]} *)?')\n    pattern.append('$')\n    return re.compile(''.join(pattern), re.IGNORECASE)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "as_number", "method_path": "../srcdata/System/core/homeassistant/components/ista_ecotrend/util.py", "method_code_mask": "from __future__ import annotations\nimport datetime\nfrom typing import Any\n\n\ndef as_number(value: (str | float | None)) ->(float | int | None): [MASK]\n", "response": "from __future__ import annotations\nimport datetime\nfrom typing import Any\ndef as_number(value: (str | float | None)) ->(float | int | None):\n    \"\"\"Convert readings to float or int.\n\n    Readings in the json response are returned as strings,\n    float values have comma as decimal separator\n    \"\"\"\n    if isinstance(value, str):\n        return int(value) if value.isdigit() else float(value.replace(',', '.')\n            )\n    return value"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "is_ip_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "is_ipv6_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv6_address(address: str) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv6_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv6 address.\"\"\"\n    try:\n        IPv6Address(address)\n    except ValueError:\n        return False\n    return True"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "is_host_valid", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\n\n\ndef is_host_valid(host: str) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\ndef is_host_valid(host: str) ->bool:\n    \"\"\"Check if a given string is an IP address or valid hostname.\"\"\"\n    if is_ip_address(host):\n        return True\n    if len(host) > 255:\n        return False\n    if re.match('^[0-9\\\\.]+$', host):\n        return False\n    if host.endswith('.'):\n        host = host[:-1]\n    allowed = re.compile('(?!-)[A-Z\\\\d\\\\-]{1,63}(?<!-)$', re.IGNORECASE)\n    return all(allowed.match(x) for x in host.split('.'))"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "is_ipv4_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv4_address(address: str) ->bool: [MASK]\n", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv4_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv4 address.\"\"\"\n    try:\n        IPv4Address(address)\n    except ValueError:\n        return False\n    return True"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "normalize_url", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef normalize_url(address: str) ->str: [MASK]\n", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef normalize_url(address: str) ->str:\n    \"\"\"Normalize a given URL.\"\"\"\n    url = yarl.URL(address.rstrip('/'))\n    if url.is_absolute() and url.is_default_port():\n        return str(url.with_port(None))\n    return str(url)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "chunked_or_all", "method_path": "../srcdata/System/core/homeassistant/util/collection.py", "method_code_mask": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\n\n\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\n\n\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\n\n\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]: [MASK]\n", "response": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]:\n    \"\"\"Break *collection* into iterables of length *n*.\n    Returns the collection if its length is less than *n*.\n    Unlike chunked, this function requires a collection so it can\n    determine the length of the collection and return the collection\n    if it is less than *n*.\n    \"\"\"\n    if len(iterable) <= chunked_num:\n        return iterable,\n    return chunked(iterable, chunked_num)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "density_to_air_quality", "method_path": "../srcdata/System/core/homeassistant/components/homekit/util.py", "method_code_mask": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\n\n\ndef density_to_air_quality(density: float) ->int: [MASK]\n", "response": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\ndef density_to_air_quality(density: float) ->int:\n    \"\"\"Map PM2.5 \u00b5g/m3 density to HomeKit AirQuality level.\"\"\"\n    if density <= 9:\n        return 1\n    if density <= 35.4:\n        return 2\n    if density <= 55.4:\n        return 3\n    if density <= 125.4:\n        return 4\n    return 5"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "parse_time_expression", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]: [MASK]\n", "response": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]:\n    \"\"\"Parse the time expression part and return a list of times to match.\"\"\"\n    if parameter is None or parameter == '*':\n        res = list(range(min_value, max_value + 1))\n    elif isinstance(parameter, str):\n        if parameter.startswith('/'):\n            parameter = int(parameter[1:])\n            res = [x for x in range(min_value, max_value + 1) if x %\n                parameter == 0]\n        else:\n            res = [int(parameter)]\n    elif not hasattr(parameter, '__iter__'):\n        res = [int(parameter)]\n    else:\n        res = sorted(int(x) for x in parameter)\n    for val in res:\n        if val < min_value or val > max_value:\n            raise ValueError(\n                f\"Time expression '{parameter}': parameter {val} out of range ({min_value} to {max_value})\"\n                )\n    return res"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "TurboJPEGSingleton.instance", "method_path": "../srcdata/System/core/homeassistant/components/camera/img_util.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\n\n\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None): [MASK]\n\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False\n", "response": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None):\n        \"\"\"Singleton for TurboJPEG.\"\"\"\n        if TurboJPEGSingleton.__instance is None:\n            TurboJPEGSingleton()\n        return TurboJPEGSingleton.__instance\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "chunk_samples", "method_path": "../srcdata/System/core/homeassistant/components/assist_pipeline/vad.py", "method_code_mask": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\n\n\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\n\n\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]: [MASK]\n", "response": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]:\n    \"\"\"Yield fixed-sized chunks from samples, keeping leftover bytes from previous call(s).\"\"\"\n    if len(leftover_chunk_buffer) + len(samples) < bytes_per_chunk:\n        leftover_chunk_buffer.append(samples)\n        return\n    next_chunk_idx = 0\n    if leftover_chunk_buffer:\n        bytes_to_copy = bytes_per_chunk - len(leftover_chunk_buffer)\n        leftover_chunk_buffer.append(samples[:bytes_to_copy])\n        next_chunk_idx = bytes_to_copy\n        yield leftover_chunk_buffer.bytes()\n        leftover_chunk_buffer.clear()\n    while next_chunk_idx < len(samples) - bytes_per_chunk + 1:\n        yield samples[next_chunk_idx:next_chunk_idx + bytes_per_chunk]\n        next_chunk_idx += bytes_per_chunk\n    if (rest_samples := samples[next_chunk_idx:]):\n        leftover_chunk_buffer.append(rest_samples)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "_get_community_post_import_url", "method_path": "../srcdata/System/core/homeassistant/components/blueprint/importer.py", "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\n\n\ndef _get_community_post_import_url(url: str) ->str: [MASK]\n", "response": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\ndef _get_community_post_import_url(url: str) ->str:\n    \"\"\"Convert a forum post url to an import url.\n    Async friendly.\n    \"\"\"\n    if (match := COMMUNITY_TOPIC_PATTERN.match(url)) is None:\n        raise UnsupportedUrl('Not a topic url')\n    _topic, post = match.groups()\n    json_url = url\n    if post is not None:\n        json_url = json_url[:-len(post) - 1]\n    json_url += '.json'\n    return json_url"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_rgb_to_rgbw", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]: [M\n    ASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbw representation.\"\"\"\n    w = min(r, g, b)\n    rgbw = r - w, g - w, b - w, w\n    return match_max_scale((r, g, b), rgbw)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "rgb_hex_to_rgb_list", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]:\n    \"\"\"Return an RGB color value list from a hex color string.\"\"\"\n    return [int(hex_string[i:i + len(hex_string) // 3], 16) for i in range(\n        0, len(hex_string), len(hex_string) // 3)]"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_hsv_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]: [\n    MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]:\n    \"\"\"Convert an hsv color into its rgb representation.\n\n    Hue is scaled 0-360\n    Sat is scaled 0-100\n    Val is scaled 0-100\n    \"\"\"\n    fRGB = colorsys.hsv_to_rgb(iH / 360, iS / 100, iV / 100)\n    return int(fRGB[0] * 255), int(fRGB[1] * 255), int(fRGB[2] * 255)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_hsb_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]: [\n    MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]:\n    \"\"\"Convert a hsb into its rgb representation.\"\"\"\n    if fS == 0.0:\n        fV = int(fB * 255)\n        return fV, fV, fV\n    r = g = b = 0\n    h = fH / 60\n    f = h - float(math.floor(h))\n    p = fB * (1 - fS)\n    q = fB * (1 - fS * f)\n    t = fB * (1 - fS * (1 - f))\n    if int(h) == 0:\n        r = int(fB * 255)\n        g = int(t * 255)\n        b = int(p * 255)\n    elif int(h) == 1:\n        r = int(q * 255)\n        g = int(fB * 255)\n        b = int(p * 255)\n    elif int(h) == 2:\n        r = int(p * 255)\n        g = int(fB * 255)\n        b = int(t * 255)\n    elif int(h) == 3:\n        r = int(p * 255)\n        g = int(q * 255)\n        b = int(fB * 255)\n    elif int(h) == 4:\n        r = int(t * 255)\n        g = int(p * 255)\n        b = int(fB * 255)\n    elif int(h) == 5:\n        r = int(fB * 255)\n        g = int(p * 255)\n        b = int(q * 255)\n    return r, g, b"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_rgbw_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]: [\n    MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbw color to an rgb representation.\"\"\"\n    rgb = r + w, g + w, b + w\n    return match_max_scale((r, g, b, w), rgb)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_xy_to_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_xy_to_temperature(x: float, y: float) ->int: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_xy_to_temperature(x: float, y: float) ->int:\n    \"\"\"Convert an xy color to a color temperature in Kelvin.\n\n    Uses McCamy's approximation (https://doi.org/10.1002/col.5080170211),\n    close enough for uses between 2000 K and 10000 K.\n    \"\"\"\n    n = (x - 0.332) / (0.1858 - y)\n    CCT = 437 * n ** 3 + 3601 * n ** 2 + 6861 * n + 5517\n    return int(CCT)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "get_time_zone", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None): [MASK]\n", "response": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None):\n    \"\"\"Get time zone from string. Return None if unable to determine.\n\n    Must be run in the executor if the ZoneInfo is not already\n    in the cache. If you are not sure, use async_get_time_zone.\n    \"\"\"\n    try:\n        return zoneinfo.ZoneInfo(time_zone_str)\n    except zoneinfo.ZoneInfoNotFoundError:\n        return None"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_rgb_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbww representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    mired_midpoint = min_mireds + mired_range / 2\n    color_temp_kelvin = color_temperature_mired_to_kelvin(mired_midpoint)\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = min(r / w_r if w_r else 0, g / w_g if w_g else 0, b / w_b if\n        w_b else 0)\n    rgb = r - w_r * white_level, g - w_g * white_level, b - w_b * white_level\n    rgbww = *rgb, round(white_level * 255), round(white_level * 255)\n    return match_max_scale((r, g, b), rgbww)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_rgbww_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbww color to an rgb representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    try:\n        ct_ratio = ww / (cw + ww)\n    except ZeroDivisionError:\n        ct_ratio = 0.5\n    color_temp_mired = min_mireds + ct_ratio * mired_range\n    if color_temp_mired:\n        color_temp_kelvin = color_temperature_mired_to_kelvin(color_temp_mired)\n    else:\n        color_temp_kelvin = 0\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = max(cw, ww) / 255\n    rgb = r + w_r * white_level, g + w_g * white_level, b + w_b * white_level\n    return match_max_scale((r, g, b, cw, ww), rgb)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_temperature_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert color temperature in kelvin to rgbcw.\n    Returns a (r, g, b, cw, ww) tuple.\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    temperature = color_temperature_kelvin_to_mired(temperature)\n    mired_range = max_mireds - min_mireds\n    cold = (max_mireds - temperature) / mired_range * brightness\n    warm = brightness - cold\n    return 0, 0, 0, round(cold), round(warm)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "generate_filter", "method_path": "../srcdata/System/core/homeassistant/helpers/entityfilter.py", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\n\n\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\n\n\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or \n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\n\n\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]: [MASK]\n", "response": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or\n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]:\n    \"\"\"Return a function that will filter entities based on the args.\"\"\"\n    return _generate_filter_from_sets_and_pattern_lists(set(include_domains\n        ), set(include_entities), set(exclude_domains), set(\n        exclude_entities), _convert_globs_to_pattern(include_entity_globs),\n        _convert_globs_to_pattern(exclude_entity_globs))"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "rgbww_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\n\n\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert rgbcw to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    _, _, _, cold, warm = rgbww\n    return _white_levels_to_color_temperature(cold, warm, min_kelvin,\n        max_kelvin)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "_white_levels_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "recursive_flatten", "method_path": "../srcdata/System/core/homeassistant/helpers/translation.py", "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\n\n\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]: [MASK]\n", "response": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]:\n    \"\"\"Return a flattened representation of dict data.\"\"\"\n    output: dict[str, str] = {}\n    for key, value in data.items():\n        if isinstance(value, dict):\n            output.update(recursive_flatten(f'{prefix}{key}.', value))\n        else:\n            output[f'{prefix}{key}'] = value\n    return output"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "icon_for_signal_level", "method_path": "../srcdata/System/core/homeassistant/helpers/icon.py", "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\n\n\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str: [MASK]\n", "response": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str:\n    \"\"\"Return a signal icon valid identifier.\"\"\"\n    if signal_level is None or signal_level == 0:\n        return 'mdi:signal-cellular-outline'\n    if signal_level > 70:\n        return 'mdi:signal-cellular-3'\n    if signal_level > 30:\n        return 'mdi:signal-cellular-2'\n    return 'mdi:signal-cellular-1'"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "_parse_url", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult: [MASK]\n", "response": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "vincenty", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None): [MASK]\n", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "_parse_client_id", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\n\n\ndef _parse_client_id(client_id: str) ->ParseResult: [MASK]\n", "response": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\ndef _parse_client_id(client_id: str) ->ParseResult:\n    \"\"\"Test if client id is a valid URL according to IndieAuth section 3.2.\n    https://indieauth.spec.indieweb.org/#client-identifier\n    \"\"\"\n    parts = _parse_url(client_id)\n    if parts.scheme not in ('http', 'https'):\n        raise ValueError\n    if any(segment in ('.', '..') for segment in parts.path.split('/')):\n        raise ValueError(\n            'Client ID cannot contain single-dot or double-dot path segments')\n    if parts.fragment != '':\n        raise ValueError('Client ID cannot contain a fragment')\n    if parts.username is not None:\n        raise ValueError('Client ID cannot contain username')\n    if parts.password is not None:\n        raise ValueError('Client ID cannot contain password')\n    try:\n        _ = parts.port\n    except ValueError as ex:\n        raise ValueError('Client ID contains invalid port') from ex\n    address = None\n    try:\n        netloc = parts.netloc\n        if netloc[0] == '[' and netloc[-1] == ']':\n            netloc = netloc[1:-1]\n        address = ip_address(netloc)\n    except ValueError:\n        pass\n    if address is None or is_local(address):\n        return parts\n    raise ValueError('Hostname should be a domain name or local IP address')"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "color_temperature_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]: [MASK]\n", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "serialize_response", "method_path": "../srcdata/System/core/homeassistant/util/aiohttp.py", "method_code_mask": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\n\n\ndef serialize_response(response: web.Response) ->dict[str, Any]: [MASK]\n", "response": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\ndef serialize_response(response: web.Response) ->dict[str, Any]:\n    \"\"\"Serialize an aiohttp response to a dictionary.\"\"\"\n    if (body := response.body) is None:\n        body_decoded = None\n    elif isinstance(body, payload.StringPayload):\n        body_decoded = body._value.decode(body.encoding)\n    elif isinstance(body, bytes):\n        body_decoded = body.decode(response.charset or 'utf-8')\n    else:\n        raise TypeError('Unknown payload encoding')\n    return {'status': response.status, 'body': body_decoded, 'headers':\n        dict(response.headers)}"}
{"result": "passed", "model_name": "std", "repository": "core", "full_method_name": "gps_accuracy", "method_path": "../srcdata/System/core/homeassistant/components/aprs/device_tracker.py", "method_code_mask": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\n\n\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int: [MASK]\n", "response": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int:\n    \"\"\"Calculate the GPS accuracy based on APRS posambiguity.\"\"\"\n    pos_a_map = {(0): 0, (1): 1 / 600, (2): 1 / 60, (3): 1 / 6, (4): 1}\n    if posambiguity in pos_a_map:\n        degrees = pos_a_map[posambiguity]\n        gps2 = gps[0], gps[1] + degrees\n        dist_m: float = geopy.distance.distance(gps, gps2).m\n        accuracy = round(dist_m)\n    else:\n        message = f\"APRS position ambiguity must be 0-4, not '{posambiguity}'.\"\n        raise ValueError(message)\n    return accuracy"}
