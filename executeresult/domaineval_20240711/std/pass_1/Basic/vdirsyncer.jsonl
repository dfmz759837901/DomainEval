{"result": "passed", "model_name": "std", "repository": "vdirsyncer", "full_method_name": "repair_item", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/repair.py", "method_code_mask": "from __future__ import annotations\nimport logging\nfrom os.path import basename\nimport aiostream\n\n\ndef repair_item(href, item, seen_uids, repair_unsafe_uid): [MASK]\n", "response": "from __future__ import annotations\nimport logging\nfrom os.path import basename\nimport aiostream\ndef repair_item(href, item, seen_uids, repair_unsafe_uid):\n    if item.parsed is None:\n        raise IrreparableItem\n    new_item = item\n    if not item.uid:\n        logger.warning('No UID, assigning random UID.')\n        new_item = item.with_uid(generate_href())\n    elif item.uid in seen_uids:\n        logger.warning('Duplicate UID, assigning random UID.')\n        new_item = item.with_uid(generate_href())\n    elif not href_safe(item.uid) or not href_safe(basename(href)):\n        if not repair_unsafe_uid:\n            logger.warning(\n                'UID may cause problems, add --repair-unsafe-uid to repair.')\n        else:\n            logger.warning('UID or href is unsafe, assigning random UID.')\n            new_item = item.with_uid(generate_href())\n    if not new_item.uid:\n        raise IrreparableItem\n    return new_item"}
{"result": "passed", "model_name": "std", "repository": "vdirsyncer", "full_method_name": "_merge_xml", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/storage/dav.py", "method_code_mask": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\n\n\ndef _merge_xml(items): [MASK]\n", "response": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\ndef _merge_xml(items):\n    if not items:\n        return None\n    rv = items[0]\n    for item in items[1:]:\n        rv.extend(item.iter())\n    return rv"}
{"result": "passed", "model_name": "std", "repository": "vdirsyncer", "full_method_name": "_parse_xml", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/storage/dav.py", "method_code_mask": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\n\n\ndef _parse_xml(content): [MASK]\n", "response": "from __future__ import annotations\nimport datetime\nimport logging\nimport urllib.parse as urlparse\nimport xml.etree.ElementTree as etree\nfrom abc import abstractmethod\nfrom inspect import getfullargspec\nfrom inspect import signature\nimport aiohttp\nimport aiostream\nfrom vdirsyncer.exceptions import Error\nfrom vdirsyncer.vobject import Item\ndef _parse_xml(content):\n    try:\n        return etree.XML(_clean_body(content))\n    except etree.ParseError as e:\n        raise InvalidXMLResponse(\n            f\"\"\"Invalid XML encountered: {e}\nDouble-check the URLs in your config.\"\"\"\n            )"}
{"result": "passed", "model_name": "std", "repository": "vdirsyncer", "full_method_name": "expand_fetch_params", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/cli/fetchparams.py", "method_code_mask": "from __future__ import annotations\nimport logging\nimport click\nimport subprocess\n\n\ndef expand_fetch_params(config): [MASK]\n", "response": "from __future__ import annotations\nimport logging\nimport click\nimport subprocess\ndef expand_fetch_params(config):\n    config = dict(config)\n    for key in list(config):\n        if not key.endswith(SUFFIX):\n            continue\n        newkey = key[:-len(SUFFIX)]\n        if newkey in config:\n            raise ValueError(f\"Can't set {key} and {newkey}.\")\n        config[newkey] = _fetch_value(config[key], key)\n        del config[key]\n    return config"}
{"result": "passed", "model_name": "std", "repository": "vdirsyncer", "full_method_name": "_Component.parse", "method_path": "../srcdata/Basic/vdirsyncer/vdirsyncer/vobject.py", "method_code_mask": "from __future__ import annotations\nimport hashlib\nfrom itertools import chain\nfrom itertools import tee\n\n\nclass _Component:\n    \"\"\"\n    Raw outline of the components.\n\n    Vdirsyncer's operations on iCalendar and VCard objects are limited to\n    retrieving the UID and splitting larger files into items. Consequently this\n    parser is very lazy, with the downside that manipulation of item properties\n    are extremely costly.\n\n    Other features:\n\n    - Preserve the original property order and wrapping.\n    - Don't choke on irrelevant details like invalid datetime formats.\n\n    Original version from https://github.com/collective/icalendar/, but apart\n    from the similar API, very few parts have been reused.\n    \"\"\"\n\n    def __init__(self, name, lines, subcomponents):\n        \"\"\"\n        :param name: The component name.\n        :param lines: The component's own properties, as list of lines\n            (strings).\n        :param subcomponents: List of components.\n        \"\"\"\n        self.name = name\n        self.props = lines\n        self.subcomponents = subcomponents\n\n    @classmethod\n    def parse(cls, lines, multiple=False): [MASK]\n\n    def dump_lines(self):\n        yield f'BEGIN:{self.name}'\n        yield from self.props\n        for c in self.subcomponents:\n            yield from c.dump_lines()\n        yield f'END:{self.name}'\n\n    def __delitem__(self, key):\n        prefix = f'{key}:', f'{key};'\n        new_lines = []\n        lineiter = iter(self.props)\n        while True:\n            for line in lineiter:\n                if line.startswith(prefix):\n                    break\n                else:\n                    new_lines.append(line)\n            else:\n                break\n            for line in lineiter:\n                if not line.startswith((' ', '\\t')):\n                    new_lines.append(line)\n                    break\n        self.props = new_lines\n\n    def __setitem__(self, key, val):\n        assert isinstance(val, str)\n        assert '\\n' not in val\n        del self[key]\n        line = f'{key}:{val}'\n        self.props.append(line)\n\n    def __contains__(self, obj):\n        if isinstance(obj, type(self)):\n            return obj not in self.subcomponents and not any(obj in x for x in\n                self.subcomponents)\n        elif isinstance(obj, str):\n            return self.get(obj, None) is not None\n        else:\n            raise ValueError(obj)\n\n    def __getitem__(self, key):\n        prefix_without_params = f'{key}:'\n        prefix_with_params = f'{key};'\n        iterlines = iter(self.props)\n        for line in iterlines:\n            if line.startswith(prefix_without_params):\n                rv = line[len(prefix_without_params):]\n                break\n            elif line.startswith(prefix_with_params):\n                rv = line[len(prefix_with_params):].split(':', 1)[-1]\n                break\n        else:\n            raise KeyError\n        for line in iterlines:\n            if line.startswith((' ', '\\t')):\n                rv += line[1:]\n            else:\n                break\n        return rv\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __eq__(self, other):\n        return (isinstance(other, type(self)) and self.name == other.name and\n            self.props == other.props and self.subcomponents == other.\n            subcomponents)\n", "response": "from __future__ import annotations\nimport hashlib\nfrom itertools import chain\nfrom itertools import tee\nclass _Component:\n    \"\"\"\n    Raw outline of the components.\n\n    Vdirsyncer's operations on iCalendar and VCard objects are limited to\n    retrieving the UID and splitting larger files into items. Consequently this\n    parser is very lazy, with the downside that manipulation of item properties\n    are extremely costly.\n\n    Other features:\n\n    - Preserve the original property order and wrapping.\n    - Don't choke on irrelevant details like invalid datetime formats.\n\n    Original version from https://github.com/collective/icalendar/, but apart\n    from the similar API, very few parts have been reused.\n    \"\"\"\n\n    def __init__(self, name, lines, subcomponents):\n        \"\"\"\n        :param name: The component name.\n        :param lines: The component's own properties, as list of lines\n            (strings).\n        :param subcomponents: List of components.\n        \"\"\"\n        self.name = name\n        self.props = lines\n        self.subcomponents = subcomponents\n\n    @classmethod\n    def parse(cls, lines, multiple=False):\n        if isinstance(lines, bytes):\n            lines = lines.decode('utf-8')\n        if isinstance(lines, str):\n            lines = lines.splitlines()\n        stack = []\n        rv = []\n        try:\n            for _i, line in enumerate(lines):\n                if line.startswith('BEGIN:'):\n                    c_name = line[len('BEGIN:'):].strip().upper()\n                    stack.append(cls(c_name, [], []))\n                elif line.startswith('END:'):\n                    component = stack.pop()\n                    c_name = line[len('END:'):].strip().upper()\n                    if c_name != component.name:\n                        raise ValueError(\n                            f'Got END:{c_name}, expected END:{component.name}'\n                             + f' at line {_i + 1}')\n                    if stack:\n                        stack[-1].subcomponents.append(component)\n                    else:\n                        rv.append(component)\n                elif line.strip():\n                    stack[-1].props.append(line)\n        except IndexError:\n            raise ValueError(f'Parsing error at line {_i + 1}')\n        if len(stack) > 0:\n            raise ValueError(\n                f\"Missing END for component(s): {', '.join(c.name for c in stack)}\"\n                )\n        if multiple:\n            return rv\n        elif len(rv) != 1:\n            raise ValueError(f'Found {len(rv)} components, expected one.')\n        else:\n            return rv[0]\n\n    def dump_lines(self):\n        yield f'BEGIN:{self.name}'\n        yield from self.props\n        for c in self.subcomponents:\n            yield from c.dump_lines()\n        yield f'END:{self.name}'\n\n    def __delitem__(self, key):\n        prefix = f'{key}:', f'{key};'\n        new_lines = []\n        lineiter = iter(self.props)\n        while True:\n            for line in lineiter:\n                if line.startswith(prefix):\n                    break\n                else:\n                    new_lines.append(line)\n            else:\n                break\n            for line in lineiter:\n                if not line.startswith((' ', '\\t')):\n                    new_lines.append(line)\n                    break\n        self.props = new_lines\n\n    def __setitem__(self, key, val):\n        assert isinstance(val, str)\n        assert '\\n' not in val\n        del self[key]\n        line = f'{key}:{val}'\n        self.props.append(line)\n\n    def __contains__(self, obj):\n        if isinstance(obj, type(self)):\n            return obj not in self.subcomponents and not any(obj in x for x in\n                self.subcomponents)\n        elif isinstance(obj, str):\n            return self.get(obj, None) is not None\n        else:\n            raise ValueError(obj)\n\n    def __getitem__(self, key):\n        prefix_without_params = f'{key}:'\n        prefix_with_params = f'{key};'\n        iterlines = iter(self.props)\n        for line in iterlines:\n            if line.startswith(prefix_without_params):\n                rv = line[len(prefix_without_params):]\n                break\n            elif line.startswith(prefix_with_params):\n                rv = line[len(prefix_with_params):].split(':', 1)[-1]\n                break\n        else:\n            raise KeyError\n        for line in iterlines:\n            if line.startswith((' ', '\\t')):\n                rv += line[1:]\n            else:\n                break\n        return rv\n\n    def get(self, key, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __eq__(self, other):\n        return (isinstance(other, type(self)) and self.name == other.name and\n            self.props == other.props and self.subcomponents == other.\n            subcomponents)"}
