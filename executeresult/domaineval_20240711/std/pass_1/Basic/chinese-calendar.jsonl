{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef get_holidays(start, end, include_weekends=True):\n    \"\"\"\n    get holidays between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :param include_weekends: False for excluding Saturdays and Sundays\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = _validate_date(start, end)\n    if include_weekends:\n        return list(filter(is_holiday, get_dates(start, end)))\n    return list(filter(lambda x: x in holidays, get_dates(start, end)))"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef get_holiday_detail(date):\n    \"\"\"\n    check if one date is holiday in China,\n    and return the holiday name (None if it's a normal day)\n\n    :type date: datetime.date | datetime.datetime\n    :return: holiday bool indicator, and holiday name if it's holiday related day\n    :rtype: (bool, str | None)\n    \"\"\"\n    date = _validate_date(date)\n    if date in workdays.keys():\n        return False, workdays[date]\n    elif date in holidays.keys():\n        return True, holidays[date]\n    else:\n        return date.weekday() > 4, None"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    find the workday after {delta_days} days.\n    :type delta_days: int\n    :param delta_days: 0 means next workday (includes today), -1 means previous workday.\n    :type date: datetime.date | datetime.datetime\n    :param: the start point\n    :rtype: datetime.date\n    \"\"\"\n    date = _wrap_date(date or datetime.date.today())\n    if delta_days >= 0:\n        delta_days += 1\n    sign = 1 if delta_days >= 0 else -1\n    for i in range(abs(delta_days)):\n        if delta_days < 0 or i:\n            date += datetime.timedelta(days=sign)\n        while not is_workday(date):\n            date += datetime.timedelta(days=sign)\n    return date"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef get_solar_terms(start, end):\n    \"\"\"\n    \u751f\u6210 24 \u8282\u6c14\n    \u901a\u7528\u5bff\u661f\u516c\u5f0f\uff1a https://www.jianshu.com/p/1f814c6bb475\n\n    \u901a\u5f0f\u5bff\u661f\u516c\u5f0f\uff1a[Y\u00d7D+C]-L\n    []\u91cc\u9762\u53d6\u6574\u6570\uff1b Y=\u5e74\u6570\u7684\u540e2\u4f4d\u6570\uff1b D=0.2422\uff1b L=Y/4\uff0c\u5c0f\u5bd2\u3001\u5927\u5bd2\u3001\u7acb\u6625\u3001\u96e8\u6c34\u7684 L=(Y-1)/4\n\n    :type start: datetime.date\n    :param start: \u5f00\u59cb\u65e5\u671f\n    :type end: datetime.date\n    :param end: \u7ed3\u675f\u65e5\u671f\n    :rtype: list[(datetime.date, str)]\n    \"\"\"\n    if not 1900 <= start.year <= 2100 or not 1900 <= end.year <= 2100:\n        raise NotImplementedError('only year between [1900, 2100] supported')\n    D = 0.2422\n    result = []\n    year, month = start.year, start.month\n    while year < end.year or year == end.year and month <= end.month:\n        for solar_term in SOLAR_TERMS_MONTH[month]:\n            nums = SOLAR_TERMS_C_NUMS[solar_term]\n            C = nums[0] if year < 2000 else nums[1]\n            if year == 2000 and solar_term in [SolarTerms.lesser_cold,\n                SolarTerms.greater_cold, SolarTerms.the_beginning_of_spring,\n                SolarTerms.rain_water]:\n                C = nums[0]\n            Y = year % 100\n            L = int(Y / 4)\n            if solar_term in [SolarTerms.lesser_cold, SolarTerms.\n                greater_cold, SolarTerms.the_beginning_of_spring,\n                SolarTerms.rain_water]:\n                L = int((Y - 1) / 4)\n            day = int(Y * D + C) - L\n            delta = SOLAR_TERMS_DELTA.get((year, solar_term))\n            if delta:\n                day += delta\n            _date = datetime.date(year, month, day)\n            if _date < start or _date > end:\n                continue\n            result.append((_date, solar_term.value[1]))\n        if month == 12:\n            year, month = year + 1, 1\n        else:\n            month += 1\n    return result"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    get workdays between start date and end date. (includes start date and end date)\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :param include_weekends: False for excluding Saturdays and Sundays\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = _validate_date(start, end)\n    if include_weekends:\n        return list(filter(is_workday, get_dates(start, end)))\n    return list(filter(lambda x: is_workday(x) and x.weekday() < 5,\n        get_dates(start, end)))"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\ndef get_holiday_detail(date):\n    \"\"\"\n    check if one date is holiday in China,\n    and return the holiday name (None if it's a normal day)\n    :type date: datetime.date | datetime.datetime\n    :return: holiday bool indicator, and holiday name if it's holiday related day\n    :rtype: (bool, str | None)\n    \"\"\"\n    date = _validate_date(date)\n    if date in workdays.keys():\n        return False, workdays[date]\n    elif date in holidays.keys():\n        return True, holidays[date]\n    else:\n        return date.weekday() > 4, None"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\ndef is_in_lieu(date):\n    \"\"\"\n    check if one date is in lieu in China.\n    in other words, Chinese people get rest at that day because of legal holiday.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "passed", "model_name": "std", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "../srcdata/Basic/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())"}
