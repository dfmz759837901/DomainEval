{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "summarize_attrs", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting_html.py", "method_code_mask": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\n\n\ndef summarize_attrs(attrs) ->str: [MASK]\n", "response": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\ndef summarize_attrs(attrs) ->str:\n    attrs_dl = ''.join(\n        f'<dt><span>{escape(str(k))} :</span></dt><dd>{escape(str(v))}</dd>'\n         for k, v in attrs.items())\n    return f\"<dl class='xr-attrs'>{attrs_dl}</dl>\""}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "format_dims", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting_html.py", "method_code_mask": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\n\n\ndef format_dims(dim_sizes, dims_with_index) ->str: [MASK]\n", "response": "from __future__ import annotations\nimport uuid\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nfrom functools import lru_cache\nfrom functools import partial\nfrom html import escape\nfrom importlib.resources import files\nfrom typing import TYPE_CHECKING\nfrom xarray.core.formatting import inline_index_repr\nfrom xarray.core.formatting import inline_variable_array_repr\nfrom xarray.core.formatting import short_data_repr\nfrom xarray.core.options import _get_boolean_with_default\ndef format_dims(dim_sizes, dims_with_index) ->str:\n    if not dim_sizes:\n        return ''\n    dim_css_map = {dim: (\" class='xr-has-index'\" if dim in dims_with_index else\n        '') for dim in dim_sizes}\n    dims_li = ''.join(\n        f'<li><span{dim_css_map[dim]}>{escape(str(dim))}</span>: {size}</li>'\n         for dim, size in dim_sizes.items())\n    return f\"<ul class='xr-dim-list'>{dims_li}</ul>\""}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_asarray_tuplesafe", "method_path": "../srcdata/Basic/xarray/xarray/core/indexes.py", "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\n\n\ndef _asarray_tuplesafe(values): [MASK]\n", "response": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\ndef _asarray_tuplesafe(values):\n    \"\"\"\n    Convert values into a numpy array of at most 1-dimension, while preserving\n    tuples.\n\n    Adapted from pandas.core.common._asarray_tuplesafe\n    \"\"\"\n    if isinstance(values, tuple):\n        result = utils.to_0d_object_array(values)\n    else:\n        result = np.asarray(values)\n        if result.ndim == 2:\n            result = np.empty(len(values), dtype=object)\n            result[:] = values\n    return result"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "date_range_like", "method_path": "../srcdata/Basic/xarray/xarray/coding/cftime_offsets.py", "method_code_mask": "from __future__ import annotations\nimport re\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.cftimeindex import _parse_iso8601_with_reso\nfrom xarray.coding.times import _is_standard_calendar\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import convert_time_or_go_back\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.pdcompat import NoDefault\nfrom xarray.core.pdcompat import count_not_none\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pdcompat import no_default\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.types import InclusiveOptions\nfrom xarray.core.types import Self\nfrom xarray.core.types import SideOptions\nfrom xarray.coding.frequencies import infer_freq\nfrom xarray.core.dataarray import DataArray\n\n\ndef date_range_like(source, calendar, use_cftime=None): [MASK]\n", "response": "from __future__ import annotations\nimport re\nfrom collections.abc import Mapping\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import TYPE_CHECKING\nfrom typing import ClassVar\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.coding.cftimeindex import _parse_iso8601_with_reso\nfrom xarray.coding.times import _is_standard_calendar\nfrom xarray.coding.times import _should_cftime_be_used\nfrom xarray.coding.times import convert_time_or_go_back\nfrom xarray.coding.times import format_cftime_datetime\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.pdcompat import NoDefault\nfrom xarray.core.pdcompat import count_not_none\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.pdcompat import no_default\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.types import InclusiveOptions\nfrom xarray.core.types import Self\nfrom xarray.core.types import SideOptions\nfrom xarray.coding.frequencies import infer_freq\nfrom xarray.core.dataarray import DataArray\ndef date_range_like(source, calendar, use_cftime=None):\n    \"\"\"Generate a datetime array with the same frequency, start and end as\n    another one, but in a different calendar.\n\n    Parameters\n    ----------\n    source : DataArray, CFTimeIndex, or pd.DatetimeIndex\n        1D datetime array\n    calendar : str\n        New calendar name.\n    use_cftime : bool, optional\n        If True, the output uses :py:class:`cftime.datetime` objects.\n        If None (default), :py:class:`numpy.datetime64` values are used if possible.\n        If False, :py:class:`numpy.datetime64` values are used or an error is raised.\n\n    Returns\n    -------\n    DataArray\n        1D datetime coordinate with the same start, end and frequency as the\n        source, but in the new calendar. The start date is assumed to exist in\n        the target calendar. If the end date doesn't exist, the code tries 1\n        and 2 calendar days before. There is a special case when the source time\n        series is daily or coarser and the end of the input range is on the\n        last day of the month. Then the output range will also end on the last\n        day of the month in the new calendar.\n    \"\"\"\n    from xarray.coding.frequencies import infer_freq\n    from xarray.core.dataarray import DataArray\n    if not isinstance(source, (pd.DatetimeIndex, CFTimeIndex)) and (\n        isinstance(source, DataArray) and source.ndim != 1 or not\n        _contains_datetime_like_objects(source.variable)):\n        raise ValueError(\n            \"'source' must be a 1D array of datetime objects for inferring its range.\"\n            )\n    freq = infer_freq(source)\n    if freq is None:\n        raise ValueError(\n            '`date_range_like` was unable to generate a range as the source frequency was not inferable.'\n            )\n    freq = _legacy_to_new_freq(freq)\n    use_cftime = _should_cftime_be_used(source, calendar, use_cftime)\n    source_start = source.values.min()\n    source_end = source.values.max()\n    freq_as_offset = to_offset(freq)\n    if freq_as_offset.n < 0:\n        source_start, source_end = source_end, source_start\n    if is_np_datetime_like(source.dtype):\n        source_calendar = 'standard'\n        source_start = nanosecond_precision_timestamp(source_start)\n        source_end = nanosecond_precision_timestamp(source_end)\n    elif isinstance(source, CFTimeIndex):\n        source_calendar = source.calendar\n    else:\n        source_calendar = source.dt.calendar\n    if calendar == source_calendar and is_np_datetime_like(source.dtype\n        ) ^ use_cftime:\n        return source\n    date_type = get_date_type(calendar, use_cftime)\n    start = convert_time_or_go_back(source_start, date_type)\n    end = convert_time_or_go_back(source_end, date_type)\n    if source_end.day == source_end.daysinmonth and isinstance(freq_as_offset,\n        (YearEnd, QuarterEnd, MonthEnd, Day)):\n        end = end.replace(day=end.daysinmonth)\n    return date_range(start=start.isoformat(), end=end.isoformat(), freq=\n        freq, calendar=calendar)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "equivalent", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef equivalent(first: T, second: T) ->bool: [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef equivalent(first: T, second: T) ->bool:\n    \"\"\"Compare two objects for equivalence (identity or equality), using\n    array_equiv if either object is an ndarray. If both objects are lists,\n    equivalent is sequentially called on all the elements.\n    \"\"\"\n    from xarray.core import duck_array_ops\n    if first is second:\n        return True\n    if isinstance(first, np.ndarray) or isinstance(second, np.ndarray):\n        return duck_array_ops.array_equiv(first, second)\n    if isinstance(first, list) or isinstance(second, list):\n        return list_equiv(first, second)\n    return first == second or pd.isnull(first) and pd.isnull(second)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "decode_cf_timedelta", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef decode_cf_timedelta(num_timedeltas, units: str) ->np.ndarray: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef decode_cf_timedelta(num_timedeltas, units: str) ->np.ndarray:\n    \"\"\"Given an array of numeric timedeltas in netCDF format, convert it into a\n    numpy timedelta64[ns] array.\n    \"\"\"\n    num_timedeltas = np.asarray(num_timedeltas)\n    units = _netcdf_to_numpy_timeunit(units)\n    result = to_timedelta_unboxed(ravel(num_timedeltas), unit=units)\n    return reshape(result, num_timedeltas.shape)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "hashable", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef hashable(v: Any) ->TypeGuard[Hashable]: [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef hashable(v: Any) ->TypeGuard[Hashable]:\n    \"\"\"Determine whether `v` can be hashed.\"\"\"\n    try:\n        hash(v)\n    except TypeError:\n        return False\n    return True"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "maybe_coerce_to_str", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef maybe_coerce_to_str(index, original_coords): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef maybe_coerce_to_str(index, original_coords):\n    \"\"\"maybe coerce a pandas Index back to a nunpy array of type str\n\n    pd.Index uses object-dtype to store str - try to avoid this for coords\n    \"\"\"\n    from xarray.core import dtypes\n    try:\n        result_type = dtypes.result_type(*original_coords)\n    except TypeError:\n        pass\n    else:\n        if result_type.kind in 'SU':\n            index = np.asarray(index, dtype=result_type.type)\n    return index"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_update_bounds_attributes", "method_path": "../srcdata/Basic/xarray/xarray/conventions.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\n\n\ndef _update_bounds_attributes(variables: T_Variables) ->None: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\ndef _update_bounds_attributes(variables: T_Variables) ->None:\n    \"\"\"Adds time attributes to time bounds variables.\n\n    Variables handling time bounds (\"Cell boundaries\" in the CF\n    conventions) do not necessarily carry the necessary attributes to be\n    decoded. This copies the attributes from the time variable to the\n    associated boundaries.\n\n    See Also:\n\n    http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/\n         cf-conventions.html#cell-boundaries\n\n    https://github.com/pydata/xarray/issues/2565\n    \"\"\"\n    for v in variables.values():\n        attrs = v.attrs\n        units = attrs.get('units')\n        has_date_units = isinstance(units, str) and 'since' in units\n        if has_date_units and 'bounds' in attrs:\n            if attrs['bounds'] in variables:\n                bounds_attrs = variables[attrs['bounds']].attrs\n                bounds_attrs.setdefault('units', attrs['units'])\n                if 'calendar' in attrs:\n                    bounds_attrs.setdefault('calendar', attrs['calendar'])"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "encode_cf_datetime", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef encode_cf_datetime(dates: T_DuckArray, units: (str | None)=None,\n    calendar: (str | None)=None, dtype: (np.dtype | None)=None) ->tuple[\n    T_DuckArray, str, str]: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef encode_cf_datetime(dates: T_DuckArray, units: (str | None)=None,\n    calendar: (str | None)=None, dtype: (np.dtype | None)=None) ->tuple[\n    T_DuckArray, str, str]:\n    \"\"\"Given an array of datetime objects, returns the tuple `(num, units,\n    calendar)` suitable for a CF compliant time variable.\n\n    Unlike `date2num`, this function can handle datetime64 arrays.\n\n    See Also\n    --------\n    cftime.date2num\n    \"\"\"\n    dates = asarray(dates)\n    if is_chunked_array(dates):\n        return _lazily_encode_cf_datetime(dates, units, calendar, dtype)\n    else:\n        return _eagerly_encode_cf_datetime(dates, units, calendar, dtype)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_is_contiguous", "method_path": "../srcdata/Basic/xarray/xarray/core/nputils.py", "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom typing import Callable\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy import RankWarning\nfrom xarray.core.options import OPTIONS\nimport bottleneck as bn\n\n\ndef _is_contiguous(positions): [MASK]\n", "response": "from __future__ import annotations\nimport warnings\nfrom typing import Callable\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nfrom numpy import RankWarning\nfrom xarray.core.options import OPTIONS\nimport bottleneck as bn\ndef _is_contiguous(positions):\n    \"\"\"Given a non-empty list, does it consist of contiguous integers?\"\"\"\n    previous = positions[0]\n    for current in positions[1:]:\n        if current != previous + 1:\n            return False\n        previous = current\n    return True"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "safe_cast_to_index", "method_path": "../srcdata/Basic/xarray/xarray/core/indexes.py", "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\n\n\ndef safe_cast_to_index(array: Any) ->pd.Index: [MASK]\n", "response": "from __future__ import annotations\nimport collections.abc\nimport copy\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Generic\nfrom typing import TypeVar\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import formatting\nfrom xarray.core import nputils\nfrom xarray.core import utils\nfrom xarray.core.indexing import IndexSelResult\nfrom xarray.core.indexing import PandasIndexingAdapter\nfrom xarray.core.indexing import PandasMultiIndexingAdapter\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.types import ErrorOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.coding.cftimeindex import CFTimeIndex\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import calculate_dimensions\ndef safe_cast_to_index(array: Any) ->pd.Index:\n    \"\"\"Given an array, safely cast it to a pandas.Index.\n\n    If it is already a pandas.Index, return it unchanged.\n\n    Unlike pandas.Index, if the array has dtype=object or dtype=timedelta64,\n    this function will not attempt to do automatic type conversion but will\n    always return an index with dtype=object.\n    \"\"\"\n    from xarray.core.dataarray import DataArray\n    from xarray.core.variable import Variable\n    if isinstance(array, pd.Index):\n        index = array\n    elif isinstance(array, (DataArray, Variable)):\n        index = array._to_index()\n    elif isinstance(array, Index):\n        index = array.to_pandas_index()\n    elif isinstance(array, PandasIndexingAdapter):\n        index = array.array\n    else:\n        kwargs: dict[str, Any] = {}\n        if hasattr(array, 'dtype'):\n            if array.dtype.kind == 'O':\n                kwargs['dtype'] = 'object'\n            elif array.dtype == 'float16':\n                emit_user_level_warning(\n                    '`pandas.Index` does not support the `float16` dtype. Casting to `float64` for you, but in the future please manually cast to either `float32` and `float64`.'\n                    , category=DeprecationWarning)\n                kwargs['dtype'] = 'float64'\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "encode_zarr_attr_value", "method_path": "../srcdata/Basic/xarray/xarray/backends/zarr.py", "method_code_mask": "from __future__ import annotations\nimport json\nimport os\nimport warnings\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import AbstractWritableDataStore\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import _encode_variable_name\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import HiddenKeyDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\n\n\ndef encode_zarr_attr_value(value): [MASK]\n", "response": "from __future__ import annotations\nimport json\nimport os\nimport warnings\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nimport pandas as pd\nfrom xarray import coding\nfrom xarray import conventions\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import AbstractWritableDataStore\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import _encode_variable_name\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import HiddenKeyDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\ndef encode_zarr_attr_value(value):\n    \"\"\"\n    Encode a attribute value as something that can be serialized as json\n\n    Many xarray datasets / variables have numpy arrays and values. This\n    function handles encoding / decoding of such items.\n\n    ndarray -> list\n    scalar array -> scalar\n    other -> other (no change)\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        encoded = value.tolist()\n    elif isinstance(value, np.generic):\n        encoded = value.item()\n    else:\n        encoded = value\n    return encoded"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "where", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef where(condition, x, y): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef where(condition, x, y):\n    \"\"\"Three argument where() with better dtype promotion rules.\"\"\"\n    xp = get_array_namespace(condition)\n    return xp.where(condition, *as_shared_dtype([x, y], xp=xp))"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "get_example_data", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_interp.py", "method_code_mask": "from __future__ import annotations\nfrom itertools import combinations\nfrom itertools import permutations\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import _parse_array_of_cftime_strings\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_scipy\nfrom xarray.tests.test_dataset import create_test_data\nimport scipy\n\n\ndef get_example_data(case: int) ->xr.DataArray: [MASK]\n", "response": "from __future__ import annotations\nfrom itertools import combinations\nfrom itertools import permutations\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.coding.cftimeindex import _parse_array_of_cftime_strings\nfrom xarray.core.types import InterpOptions\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_identical\nfrom xarray.tests import has_dask\nfrom xarray.tests import has_scipy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_scipy\nfrom xarray.tests.test_dataset import create_test_data\nimport scipy\ndef get_example_data(case: int) ->xr.DataArray:\n    if case == 0:\n        x = np.linspace(0, 1, 100)\n        y = np.linspace(0, 0.1, 30)\n        return xr.DataArray(np.sin(x[:, np.newaxis]) * np.cos(y), dims=['x',\n            'y'], coords={'x': x, 'y': y, 'x2': ('x', x ** 2)})\n    elif case == 1:\n        return get_example_data(0).chunk({'y': 3})\n    elif case == 2:\n        return get_example_data(0).chunk({'x': 25, 'y': 3})\n    elif case == 3:\n        x = np.linspace(0, 1, 100)\n        y = np.linspace(0, 0.1, 30)\n        z = np.linspace(0.1, 0.2, 10)\n        return xr.DataArray(np.sin(x[:, np.newaxis, np.newaxis]) * np.cos(y\n            [:, np.newaxis]) * z, dims=['x', 'y', 'z'], coords={'x': x, 'y':\n            y, 'x2': ('x', x ** 2), 'z': z})\n    elif case == 4:\n        return get_example_data(3).chunk({'z': 5})\n    else:\n        raise ValueError('case must be 1-4')"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_extract_nc4_variable_encoding", "method_path": "../srcdata/Basic/xarray/xarray/backends/netCDF4_.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport operator\nimport os\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom xarray import coding\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.common import find_root_and_group\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.file_manager import CachingFileManager\nfrom xarray.backends.file_manager import DummyFileManager\nfrom xarray.backends.locks import HDF5_LOCK\nfrom xarray.backends.locks import NETCDFC_LOCK\nfrom xarray.backends.locks import combine_locks\nfrom xarray.backends.locks import ensure_lock\nfrom xarray.backends.locks import get_write_lock\nfrom xarray.backends.netcdf3 import encode_nc3_attr_value\nfrom xarray.backends.netcdf3 import encode_nc3_variable\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.utils import is_remote_uri\nfrom xarray.core.utils import try_read_magic_number_from_path\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\n\n\ndef _extract_nc4_variable_encoding(variable: Variable, raise_on_invalid=\n    False, lsd_okay=True, h5py_okay=False, backend='netCDF4',\n    unlimited_dims=None) ->dict[str, Any]: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport operator\nimport os\nfrom collections.abc import Callable\nfrom collections.abc import Iterable\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nimport numpy as np\nfrom xarray import coding\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendArray\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.backends.common import WritableCFDataStore\nfrom xarray.backends.common import _normalize_path\nfrom xarray.backends.common import find_root_and_group\nfrom xarray.backends.common import robust_getitem\nfrom xarray.backends.file_manager import CachingFileManager\nfrom xarray.backends.file_manager import DummyFileManager\nfrom xarray.backends.locks import HDF5_LOCK\nfrom xarray.backends.locks import NETCDFC_LOCK\nfrom xarray.backends.locks import combine_locks\nfrom xarray.backends.locks import ensure_lock\nfrom xarray.backends.locks import get_write_lock\nfrom xarray.backends.netcdf3 import encode_nc3_attr_value\nfrom xarray.backends.netcdf3 import encode_nc3_variable\nfrom xarray.backends.store import StoreBackendEntrypoint\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.utils import FrozenDict\nfrom xarray.core.utils import close_on_error\nfrom xarray.core.utils import is_remote_uri\nfrom xarray.core.utils import try_read_magic_number_from_path\nfrom xarray.core.variable import Variable\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\nfrom xarray.backends.api import open_dataset\ndef _extract_nc4_variable_encoding(variable: Variable, raise_on_invalid=\n    False, lsd_okay=True, h5py_okay=False, backend='netCDF4',\n    unlimited_dims=None) ->dict[str, Any]:\n    if unlimited_dims is None:\n        unlimited_dims = ()\n    encoding = variable.encoding.copy()\n    safe_to_drop = {'source', 'original_shape'}\n    valid_encodings = {'zlib', 'complevel', 'fletcher32', 'contiguous',\n        'chunksizes', 'shuffle', '_FillValue', 'dtype', 'compression',\n        'significant_digits', 'quantize_mode', 'blosc_shuffle',\n        'szip_coding', 'szip_pixels_per_block', 'endian'}\n    if lsd_okay:\n        valid_encodings.add('least_significant_digit')\n    if h5py_okay:\n        valid_encodings.add('compression_opts')\n    if not raise_on_invalid and encoding.get('chunksizes') is not None:\n        chunksizes = encoding['chunksizes']\n        chunks_too_big = any(c > d and dim not in unlimited_dims for c, d,\n            dim in zip(chunksizes, variable.shape, variable.dims))\n        has_original_shape = 'original_shape' in encoding\n        changed_shape = has_original_shape and encoding.get('original_shape'\n            ) != variable.shape\n        if chunks_too_big or changed_shape:\n            del encoding['chunksizes']\n    var_has_unlim_dim = any(dim in unlimited_dims for dim in variable.dims)\n    if (not raise_on_invalid and var_has_unlim_dim and 'contiguous' in\n        encoding.keys()):\n        del encoding['contiguous']\n    for k in safe_to_drop:\n        if k in encoding:\n            del encoding[k]\n    if raise_on_invalid:\n        invalid = [k for k in encoding if k not in valid_encodings]\n        if invalid:\n            raise ValueError(\n                f'unexpected encoding parameters for {backend!r} backend: {invalid!r}. Valid encodings are: {valid_encodings!r}'\n                )\n    else:\n        for k in list(encoding):\n            if k not in valid_encodings:\n                del encoding[k]\n    return encoding"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "result_name", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef result_name(objects: Iterable[Any]) ->Any: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef result_name(objects: Iterable[Any]) ->Any:\n    names = {getattr(obj, 'name', _DEFAULT_NAME) for obj in objects}\n    names.discard(_DEFAULT_NAME)\n    if len(names) == 1:\n        name, = names\n    else:\n        name = None\n    return name"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "decode_cf_variable", "method_path": "../srcdata/Basic/xarray/xarray/conventions.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\n\n\ndef decode_cf_variable(name: Hashable, var: Variable, concat_characters:\n    bool=True, mask_and_scale: bool=True, decode_times: bool=True,\n    decode_endianness: bool=True, stack_char_dim: bool=True, use_cftime: (\n    bool | None)=None, decode_timedelta: (bool | None)=None) ->Variable: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom xarray.coding import strings\nfrom xarray.coding import times\nfrom xarray.coding import variables\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import pop_to\nfrom xarray.core import indexing\nfrom xarray.core.common import _contains_datetime_like_objects\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.backends.common import AbstractDataStore\nfrom xarray.core.dataset import Dataset\ndef decode_cf_variable(name: Hashable, var: Variable, concat_characters:\n    bool=True, mask_and_scale: bool=True, decode_times: bool=True,\n    decode_endianness: bool=True, stack_char_dim: bool=True, use_cftime: (\n    bool | None)=None, decode_timedelta: (bool | None)=None) ->Variable:\n    \"\"\"\n    Decodes a variable which may hold CF encoded information.\n\n    This includes variables that have been masked and scaled, which\n    hold CF style time variables (this is almost always the case if\n    the dataset has been serialized) and which have strings encoded\n    as character arrays.\n\n    Parameters\n    ----------\n    name : str\n        Name of the variable. Used for better error messages.\n    var : Variable\n        A variable holding potentially CF encoded information.\n    concat_characters : bool\n        Should character arrays be concatenated to strings, for\n        example: [\"h\", \"e\", \"l\", \"l\", \"o\"] -> \"hello\"\n    mask_and_scale : bool\n        Lazily scale (using scale_factor and add_offset) and mask\n        (using _FillValue). If the _Unsigned attribute is present\n        treat integer arrays as unsigned.\n    decode_times : bool\n        Decode cf times (\"hours since 2000-01-01\") to np.datetime64.\n    decode_endianness : bool\n        Decode arrays from non-native to native endianness.\n    stack_char_dim : bool\n        Whether to stack characters into bytes along the last dimension of this\n        array. Passed as an argument because we need to look at the full\n        dataset to figure out if this is appropriate.\n    use_cftime : bool, optional\n        Only relevant if encoded dates come from a standard calendar\n        (e.g. \"gregorian\", \"proleptic_gregorian\", \"standard\", or not\n        specified).  If None (default), attempt to decode times to\n        ``np.datetime64[ns]`` objects; if this is not possible, decode times to\n        ``cftime.datetime`` objects. If True, always decode times to\n        ``cftime.datetime`` objects, regardless of whether or not they can be\n        represented using ``np.datetime64[ns]`` objects.  If False, always\n        decode times to ``np.datetime64[ns]`` objects; if this is not possible\n        raise an error.\n\n    Returns\n    -------\n    out : Variable\n        A variable holding the decoded equivalent of var.\n    \"\"\"\n    if _contains_datetime_like_objects(var):\n        return var\n    original_dtype = var.dtype\n    if decode_timedelta is None:\n        decode_timedelta = decode_times\n    if concat_characters:\n        if stack_char_dim:\n            var = strings.CharacterArrayCoder().decode(var, name=name)\n        var = strings.EncodedStringCoder().decode(var)\n    if original_dtype == object:\n        var = variables.ObjectVLenStringCoder().decode(var)\n        original_dtype = var.dtype\n    if mask_and_scale:\n        for coder in [variables.UnsignedIntegerCoder(), variables.\n            CFMaskCoder(), variables.CFScaleOffsetCoder()]:\n            var = coder.decode(var, name=name)\n    if decode_timedelta:\n        var = times.CFTimedeltaCoder().decode(var, name=name)\n    if decode_times:\n        var = times.CFDatetimeCoder(use_cftime=use_cftime).decode(var, name\n            =name)\n    if decode_endianness and not var.dtype.isnative:\n        var = variables.EndianCoder().decode(var)\n        original_dtype = var.dtype\n    var = variables.BooleanCoder().decode(var)\n    dimensions, data, attributes, encoding = variables.unpack_for_decoding(var)\n    encoding.setdefault('dtype', original_dtype)\n    if not is_duck_dask_array(data):\n        data = indexing.LazilyIndexedArray(data)\n    return Variable(dimensions, data, attributes, encoding=encoding,\n        fastpath=True)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "group_indexers_by_index", "method_path": "../srcdata/Basic/xarray/xarray/core/indexing.py", "method_code_mask": "from __future__ import annotations\nimport enum\nimport functools\nimport operator\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom datetime import timedelta\nfrom html import escape\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import duck_array_ops\nfrom xarray.core.nputils import NumpyVIndexAdapter\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import NDArrayMixin\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import to_0d_array\nfrom numpy.typing import DTypeLike\nfrom xarray.core.indexes import Index\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.formatting import short_array_repr\n\n\ndef group_indexers_by_index(obj: T_Xarray, indexers: Mapping[Any, Any],\n    options: Mapping[str, Any]) ->list[tuple[Index, dict[Any, Any]]]: [MASK]\n", "response": "from __future__ import annotations\nimport enum\nimport functools\nimport operator\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom datetime import timedelta\nfrom html import escape\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core import duck_array_ops\nfrom xarray.core.nputils import NumpyVIndexAdapter\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import NDArrayMixin\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import get_valid_numpy_dtype\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import to_0d_array\nfrom numpy.typing import DTypeLike\nfrom xarray.core.indexes import Index\nfrom xarray.core.types import Self\nfrom xarray.core.variable import Variable\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.indexes import safe_cast_to_index\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.formatting import short_array_repr\ndef group_indexers_by_index(obj: T_Xarray, indexers: Mapping[Any, Any],\n    options: Mapping[str, Any]) ->list[tuple[Index, dict[Any, Any]]]:\n    \"\"\"Returns a list of unique indexes and their corresponding indexers.\"\"\"\n    unique_indexes = {}\n    grouped_indexers: Mapping[int | None, dict] = defaultdict(dict)\n    for key, label in indexers.items():\n        index: Index = obj.xindexes.get(key, None)\n        if index is not None:\n            index_id = id(index)\n            unique_indexes[index_id] = index\n            grouped_indexers[index_id][key] = label\n        elif key in obj.coords:\n            raise KeyError(f'no index found for coordinate {key!r}')\n        elif key not in obj.dims:\n            raise KeyError(\n                f'{key!r} is not a valid dimension or coordinate for {obj.__class__.__name__} with dimensions {obj.dims!r}'\n                )\n        elif len(options):\n            raise ValueError(\n                f'cannot supply selection options {options!r} for dimension {key!r}that has no associated coordinate or index'\n                )\n        else:\n            unique_indexes[None] = None\n            grouped_indexers[None][key] = label\n    return [(unique_indexes[k], grouped_indexers[k]) for k in unique_indexes]"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "check_vlen_dtype", "method_path": "../srcdata/Basic/xarray/xarray/coding/strings.py", "method_code_mask": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\n\n\ndef check_vlen_dtype(dtype): [MASK]\n", "response": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\ndef check_vlen_dtype(dtype):\n    if dtype.kind != 'O' or dtype.metadata is None:\n        return None\n    else:\n        return dtype.metadata.get('element_type', dtype.metadata.get('vlen'))"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "decode_cf_datetime", "method_path": "../srcdata/Basic/xarray/xarray/coding/times.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\n\n\ndef decode_cf_datetime(num_dates, units: str, calendar: (str | None)=None,\n    use_cftime: (bool | None)=None) ->np.ndarray: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport warnings\nfrom collections.abc import Hashable\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom functools import partial\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import Union\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom pandas.errors import OutOfBoundsTimedelta\nfrom xarray.coding.variables import SerializationWarning\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.common import contains_cftime_datetimes\nfrom xarray.core.common import is_np_datetime_like\nfrom xarray.core.duck_array_ops import asarray\nfrom xarray.core.duck_array_ops import reshape\nfrom xarray.core.formatting import first_n_items\nfrom xarray.core.formatting import format_timestamp\nfrom xarray.core.formatting import last_item\nfrom xarray.core.pdcompat import nanosecond_precision_timestamp\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.variable import Variable\nfrom xarray.core.types import CFCalendar\ndef decode_cf_datetime(num_dates, units: str, calendar: (str | None)=None,\n    use_cftime: (bool | None)=None) ->np.ndarray:\n    \"\"\"Given an array of numeric dates in netCDF format, convert it into a\n    numpy array of date time objects.\n\n    For standard (Gregorian) calendars, this function uses vectorized\n    operations, which makes it much faster than cftime.num2date. In such a\n    case, the returned array will be of type np.datetime64.\n\n    Note that time unit in `units` must not be smaller than microseconds and\n    not larger than days.\n\n    See Also\n    --------\n    cftime.num2date\n    \"\"\"\n    num_dates = np.asarray(num_dates)\n    flat_num_dates = ravel(num_dates)\n    if calendar is None:\n        calendar = 'standard'\n    if use_cftime is None:\n        try:\n            dates = _decode_datetime_with_pandas(flat_num_dates, units,\n                calendar)\n        except (KeyError, OutOfBoundsDatetime, OutOfBoundsTimedelta,\n            OverflowError):\n            dates = _decode_datetime_with_cftime(flat_num_dates.astype(\n                float), units, calendar)\n            if dates[np.nanargmin(num_dates)].year < 1678 or dates[np.\n                nanargmax(num_dates)].year >= 2262:\n                if _is_standard_calendar(calendar):\n                    warnings.warn(\n                        'Unable to decode time axis into full numpy.datetime64 objects, continuing using cftime.datetime objects instead, reason: dates out of range'\n                        , SerializationWarning, stacklevel=3)\n            elif _is_standard_calendar(calendar):\n                dates = cftime_to_nptime(dates)\n    elif use_cftime:\n        dates = _decode_datetime_with_cftime(flat_num_dates, units, calendar)\n    else:\n        dates = _decode_datetime_with_pandas(flat_num_dates, units, calendar)\n    return reshape(dates, num_dates.shape)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "ordered_set_intersection", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef ordered_set_intersection(all_keys: list[Iterable]) ->Iterable: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef ordered_set_intersection(all_keys: list[Iterable]) ->Iterable:\n    intersection = set(all_keys[0])\n    for keys in all_keys[1:]:\n        intersection.intersection_update(keys)\n    return [key for key in all_keys[0] if key in intersection]"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "join_dict_keys", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef join_dict_keys(objects: Iterable[Mapping | Any], how: str='inner'\n    ) ->Iterable: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef join_dict_keys(objects: Iterable[Mapping | Any], how: str='inner'\n    ) ->Iterable:\n    joiner = _JOINERS[how]\n    all_keys = [obj.keys() for obj in objects if hasattr(obj, 'keys')]\n    return joiner(all_keys)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "collect_dict_values", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef collect_dict_values(objects: Iterable[Mapping | Any], keys: Iterable,\n    fill_value: object=None) ->list[list]: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef collect_dict_values(objects: Iterable[Mapping | Any], keys: Iterable,\n    fill_value: object=None) ->list[list]:\n    return [[(obj.get(key, fill_value) if is_dict_like(obj) else obj) for\n        obj in objects] for key in keys]"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "broadcast_dimension_size", "method_path": "../srcdata/Basic/xarray/xarray/core/merge.py", "method_code_mask": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Union\nimport pandas as pd\nfrom xarray.core import dtypes\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.duck_array_ops import lazy_array_equiv\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.indexes import indexes_equal\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import compat_dict_union\nfrom xarray.core.utils import dict_equiv\nfrom xarray.core.utils import equivalent\nfrom xarray.core.variable import Variable\nfrom xarray.core.variable import as_variable\nfrom xarray.core.variable import calculate_dimensions\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import CompatOptions\nfrom xarray.core.types import JoinOptions\n\n\ndef broadcast_dimension_size(variables: list[Variable]) ->dict[Hashable, int\n    ]: [MASK]\n", "response": "from __future__ import annotations\nfrom collections import defaultdict\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Union\nimport pandas as pd\nfrom xarray.core import dtypes\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.duck_array_ops import lazy_array_equiv\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.indexes import indexes_equal\nfrom xarray.core.utils import Frozen\nfrom xarray.core.utils import compat_dict_union\nfrom xarray.core.utils import dict_equiv\nfrom xarray.core.utils import equivalent\nfrom xarray.core.variable import Variable\nfrom xarray.core.variable import as_variable\nfrom xarray.core.variable import calculate_dimensions\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import CompatOptions\nfrom xarray.core.types import JoinOptions\ndef broadcast_dimension_size(variables: list[Variable]) ->dict[Hashable, int]:\n    \"\"\"Extract dimension sizes from a dictionary of variables.\n\n    Raises ValueError if any dimensions have different sizes.\n    \"\"\"\n    dims: dict[Hashable, int] = {}\n    for var in variables:\n        for dim, size in zip(var.dims, var.shape):\n            if dim in dims and size != dims[dim]:\n                raise ValueError(f'index {dim!r} not aligned')\n            dims[dim] = size\n    return dims"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "list_engines", "method_path": "../srcdata/Basic/xarray/xarray/backends/plugins.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport inspect\nimport itertools\nimport sys\nimport warnings\nfrom importlib.metadata import entry_points\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.core.utils import module_available\nimport os\nfrom importlib.metadata import EntryPoint\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\n\n\n@functools.lru_cache(maxsize=1)\ndef list_engines() ->dict[str, BackendEntrypoint]: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport inspect\nimport itertools\nimport sys\nimport warnings\nfrom importlib.metadata import entry_points\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom xarray.backends.common import BACKEND_ENTRYPOINTS\nfrom xarray.backends.common import BackendEntrypoint\nfrom xarray.core.utils import module_available\nimport os\nfrom importlib.metadata import EntryPoint\nfrom io import BufferedIOBase\nfrom xarray.backends.common import AbstractDataStore\n@functools.lru_cache(maxsize=1)\ndef list_engines() ->dict[str, BackendEntrypoint]:\n    \"\"\"\n    Return a dictionary of available engines and their BackendEntrypoint objects.\n\n    Returns\n    -------\n    dictionary\n\n    Notes\n    -----\n    This function lives in the backends namespace (``engs=xr.backends.list_engines()``).\n    If available, more information is available about each backend via ``engs[\"eng_name\"]``.\n\n    # New selection mechanism introduced with Python 3.10. See GH6514.\n    \"\"\"\n    if sys.version_info >= (3, 10):\n        entrypoints = entry_points(group='xarray.backends')\n    else:\n        entrypoints = entry_points().get('xarray.backends', [])\n    return build_engines(entrypoints)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "unified_dim_sizes", "method_path": "../srcdata/Basic/xarray/xarray/core/computation.py", "method_code_mask": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\n\n\ndef unified_dim_sizes(variables: Iterable[Variable], exclude_dims: Set=\n    frozenset()) ->dict[Hashable, int]: [MASK]\n", "response": "from __future__ import annotations\nimport functools\nimport itertools\nimport operator\nimport warnings\nfrom collections import Counter\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom collections.abc import Set\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import Union\nfrom typing import cast\nfrom typing import overload\nimport numpy as np\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import utils\nfrom xarray.core.alignment import align\nfrom xarray.core.alignment import deep_align\nfrom xarray.core.common import zeros_like\nfrom xarray.core.duck_array_ops import datetime_to_numeric\nfrom xarray.core.formatting import limit_lines\nfrom xarray.core.indexes import Index\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.merge import merge_attrs\nfrom xarray.core.merge import merge_coordinates_without_align\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.utils import is_dict_like\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import parse_dims\nfrom xarray.core.variable import Variable\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import CombineAttrsOptions\nfrom xarray.core.types import JoinOptions\nfrom xarray.core.groupby import _dummy_copy\nfrom xarray.core.groupby import GroupBy\nfrom xarray.core.groupby import peek_at\nfrom xarray.core.formatting import short_array_repr\nfrom xarray.core.variable import as_compatible_data\ndef unified_dim_sizes(variables: Iterable[Variable], exclude_dims: Set=\n    frozenset()) ->dict[Hashable, int]:\n    dim_sizes: dict[Hashable, int] = {}\n    for var in variables:\n        if len(set(var.dims)) < len(var.dims):\n            raise ValueError(\n                f'broadcasting cannot handle duplicate dimensions on a variable: {list(var.dims)}'\n                )\n        for dim, size in zip(var.dims, var.shape):\n            if dim not in exclude_dims:\n                if dim not in dim_sizes:\n                    dim_sizes[dim] = size\n                elif dim_sizes[dim] != size:\n                    raise ValueError(\n                        f'operands cannot be broadcast together with mismatched lengths for dimension {dim}: {dim_sizes[dim]} vs {size}'\n                        )\n    return dim_sizes"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "scatter_example_dataset", "method_path": "../srcdata/Basic/xarray/xarray/tutorial.py", "method_code_mask": "from __future__ import annotations\nimport os\nimport pathlib\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom xarray.backends.api import open_dataset as _open_dataset\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nimport pooch\nimport scipy\n\n\ndef scatter_example_dataset(*, seed: (None | int)=None) ->Dataset: [MASK]\n", "response": "from __future__ import annotations\nimport os\nimport pathlib\nfrom typing import TYPE_CHECKING\nimport numpy as np\nfrom xarray.backends.api import open_dataset as _open_dataset\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nimport pooch\nimport scipy\ndef scatter_example_dataset(*, seed: (None | int)=None) ->Dataset:\n    \"\"\"\n    Create an example dataset.\n\n    Parameters\n    ----------\n    seed : int, optional\n        Seed for the random number generation.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    A = DataArray(np.zeros([3, 11, 4, 4]), dims=['x', 'y', 'z', 'w'],\n        coords={'x': np.arange(3), 'y': np.linspace(0, 1, 11), 'z': np.\n        arange(4), 'w': 0.1 * rng.standard_normal(4)})\n    B = 0.1 * A.x ** 2 + A.y ** 2.5 + 0.1 * A.z * A.w\n    A = -0.1 * A.x + A.y / (5 + A.z) + A.w\n    ds = Dataset({'A': A, 'B': B})\n    ds['w'] = ['one', 'two', 'three', 'five']\n    ds.x.attrs['units'] = 'xunits'\n    ds.y.attrs['units'] = 'yunits'\n    ds.z.attrs['units'] = 'zunits'\n    ds.w.attrs['units'] = 'wunits'\n    ds.A.attrs['units'] = 'Aunits'\n    ds.B.attrs['units'] = 'Bunits'\n    return ds"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_color_palette", "method_path": "../srcdata/Basic/xarray/xarray/plot/utils.py", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport textwrap\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom datetime import date\nfrom datetime import datetime\nfrom inspect import getfullargspec\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import module_available\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import FuncFormatter\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import AspectOptions\nfrom xarray.core.types import ScaleOptions\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\nfrom seaborn import color_palette\nimport matplotlib.dates as mdates\n\n\ndef _color_palette(cmap, n_colors): [MASK]\n", "response": "from __future__ import annotations\nimport itertools\nimport textwrap\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import Sequence\nfrom datetime import date\nfrom datetime import datetime\nfrom inspect import getfullargspec\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import module_available\nfrom matplotlib.axes import Axes\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import FuncFormatter\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.types import AspectOptions\nfrom xarray.core.types import ScaleOptions\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\nfrom seaborn import color_palette\nimport matplotlib.dates as mdates\ndef _color_palette(cmap, n_colors):\n    import matplotlib.pyplot as plt\n    from matplotlib.colors import ListedColormap\n    colors_i = np.linspace(0, 1.0, n_colors)\n    if isinstance(cmap, (list, tuple)):\n        cmap = ListedColormap(cmap, N=n_colors)\n        pal = cmap(colors_i)\n    elif isinstance(cmap, str):\n        try:\n            cmap = plt.get_cmap(cmap)\n            pal = cmap(colors_i)\n        except ValueError:\n            try:\n                from seaborn import color_palette\n                pal = color_palette(cmap, n_colors=n_colors)\n            except (ValueError, ImportError):\n                cmap = ListedColormap([cmap], N=n_colors)\n                pal = cmap(colors_i)\n    else:\n        pal = cmap(colors_i)\n    return pal"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "create_vlen_dtype", "method_path": "../srcdata/Basic/xarray/xarray/coding/strings.py", "method_code_mask": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\n\n\ndef create_vlen_dtype(element_type): [MASK]\n", "response": "from __future__ import annotations\nfrom functools import partial\nimport numpy as np\nfrom xarray.coding.variables import VariableCoder\nfrom xarray.coding.variables import lazy_elemwise_func\nfrom xarray.coding.variables import pop_to\nfrom xarray.coding.variables import safe_setitem\nfrom xarray.coding.variables import unpack_for_decoding\nfrom xarray.coding.variables import unpack_for_encoding\nfrom xarray.core import indexing\nfrom xarray.core.utils import module_available\nfrom xarray.core.variable import Variable\ndef create_vlen_dtype(element_type):\n    if element_type not in (str, bytes):\n        raise TypeError(f'unsupported type for vlen_dtype: {element_type!r}')\n    return np.dtype('O', metadata={'element_type': element_type})"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "py_timedelta_to_float", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef py_timedelta_to_float(array, datetime_unit): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef py_timedelta_to_float(array, datetime_unit):\n    \"\"\"Convert a timedelta object to a float, possibly at a loss of resolution.\"\"\"\n    array = asarray(array)\n    if is_duck_dask_array(array):\n        array = array.map_blocks(_timedelta_to_seconds, meta=np.array([],\n            dtype=np.float64))\n    else:\n        array = _timedelta_to_seconds(array)\n    conversion_factor = np.timedelta64(1, 'us') / np.timedelta64(1,\n        datetime_unit)\n    return conversion_factor * array"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "concatenate", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef concatenate(arrays, axis=0): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef concatenate(arrays, axis=0):\n    \"\"\"concatenate() with better dtype promotion rules.\"\"\"\n    if hasattr(arrays[0], '__array_namespace__') and not isinstance(arrays[\n        0], np.ndarray):\n        xp = get_array_namespace(arrays[0])\n        return xp.concat(as_shared_dtype(arrays, xp=xp), axis=axis)\n    return _concatenate(as_shared_dtype(arrays), axis=axis)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "stack", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef stack(arrays, axis=0): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef stack(arrays, axis=0):\n    \"\"\"stack() with better dtype promotion rules.\"\"\"\n    xp = get_array_namespace(arrays[0])\n    return xp.stack(as_shared_dtype(arrays, xp=xp), axis=axis)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "mean", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef mean(array, axis=None, skipna=None, **kwargs): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef mean(array, axis=None, skipna=None, **kwargs):\n    \"\"\"inhouse mean that can handle np.datetime64 or cftime.datetime\n    dtypes\"\"\"\n    from xarray.core.common import _contains_cftime_datetimes\n    array = asarray(array)\n    if dtypes.is_datetime_like(array.dtype):\n        offset = _datetime_nanmin(array)\n        dtype = 'timedelta64[ns]'\n        return _mean(datetime_to_numeric(array, offset), axis=axis, skipna=\n            skipna, **kwargs).astype(dtype) + offset\n    elif _contains_cftime_datetimes(array):\n        offset = min(array)\n        timedeltas = datetime_to_numeric(array, offset, datetime_unit='us')\n        mean_timedeltas = _mean(timedeltas, axis=axis, skipna=skipna, **kwargs)\n        return _to_pytimedelta(mean_timedeltas, unit='us') + offset\n    else:\n        return _mean(array, axis=axis, skipna=skipna, **kwargs)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "push", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef push(array, n, axis): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef push(array, n, axis):\n    if not OPTIONS['use_bottleneck'] and not OPTIONS['use_numbagg']:\n        raise RuntimeError(\n            'ffill & bfill requires bottleneck or numbagg to be enabled. Call `xr.set_options(use_bottleneck=True)` or `xr.set_options(use_numbagg=True)` to enable one.'\n            )\n    if is_duck_dask_array(array):\n        return dask_array_ops.push(array, n, axis)\n    else:\n        return _push(array, n, axis)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "set_numpy_options", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\n@contextlib.contextmanager\ndef set_numpy_options(*args, **kwargs): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n@contextlib.contextmanager\ndef set_numpy_options(*args, **kwargs):\n    original = np.get_printoptions()\n    np.set_printoptions(*args, **kwargs)\n    try:\n        yield\n    finally:\n        np.set_printoptions(**original)"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "_consolidate_slices", "method_path": "../srcdata/Basic/xarray/xarray/core/groupby.py", "method_code_mask": "from __future__ import annotations\nimport copy\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import nputils\nfrom xarray.core import ops\nfrom xarray.core._aggregations import DataArrayGroupByAggregations\nfrom xarray.core._aggregations import DatasetGroupByAggregations\nfrom xarray.core.alignment import align\nfrom xarray.core.arithmetic import DataArrayGroupbyArithmetic\nfrom xarray.core.arithmetic import DatasetGroupbyArithmetic\nfrom xarray.core.common import ImplementsArrayReduce\nfrom xarray.core.common import ImplementsDatasetReduce\nfrom xarray.core.concat import concat\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import QuantileMethods\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.types import T_DataWithCoords\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import hashable\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import maybe_wrap_array\nfrom xarray.core.utils import module_available\nfrom xarray.core.utils import peek_at\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.util.deprecation_helpers import _deprecate_positional_args\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.utils import Frozen\n\n\ndef _consolidate_slices(slices: list[slice]) ->list[slice]: [MASK]\n", "response": "from __future__ import annotations\nimport copy\nimport warnings\nfrom collections.abc import Hashable\nfrom collections.abc import Iterator\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom dataclasses import field\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import Union\nimport numpy as np\nimport pandas as pd\nfrom packaging.version import Version\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core import nputils\nfrom xarray.core import ops\nfrom xarray.core._aggregations import DataArrayGroupByAggregations\nfrom xarray.core._aggregations import DatasetGroupByAggregations\nfrom xarray.core.alignment import align\nfrom xarray.core.arithmetic import DataArrayGroupbyArithmetic\nfrom xarray.core.arithmetic import DatasetGroupbyArithmetic\nfrom xarray.core.common import ImplementsArrayReduce\nfrom xarray.core.common import ImplementsDatasetReduce\nfrom xarray.core.concat import concat\nfrom xarray.core.coordinates import Coordinates\nfrom xarray.core.formatting import format_array_flat\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import create_default_index_implicit\nfrom xarray.core.indexes import filter_indexes_from_coords\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_keep_attrs\nfrom xarray.core.types import Dims\nfrom xarray.core.types import QuantileMethods\nfrom xarray.core.types import T_DataArray\nfrom xarray.core.types import T_DataWithCoords\nfrom xarray.core.types import T_Xarray\nfrom xarray.core.utils import either_dict_or_kwargs\nfrom xarray.core.utils import emit_user_level_warning\nfrom xarray.core.utils import hashable\nfrom xarray.core.utils import is_scalar\nfrom xarray.core.utils import maybe_wrap_array\nfrom xarray.core.utils import module_available\nfrom xarray.core.utils import peek_at\nfrom xarray.core.variable import IndexVariable\nfrom xarray.core.variable import Variable\nfrom xarray.util.deprecation_helpers import _deprecate_positional_args\nfrom numpy.typing import ArrayLike\nfrom xarray.core.dataarray import DataArray\nfrom xarray.core.dataset import Dataset\nfrom xarray.core.utils import Frozen\ndef _consolidate_slices(slices: list[slice]) ->list[slice]:\n    \"\"\"Consolidate adjacent slices in a list of slices.\"\"\"\n    result: list[slice] = []\n    last_slice = slice(None)\n    for slice_ in slices:\n        if not isinstance(slice_, slice):\n            raise ValueError(f'list element is not a slice: {slice_!r}')\n        if result and last_slice.stop == slice_.start and _is_one_or_none(\n            last_slice.step) and _is_one_or_none(slice_.step):\n            last_slice = slice(last_slice.start, slice_.stop, slice_.step)\n            result[-1] = last_slice\n        else:\n            result.append(slice_)\n            last_slice = slice_\n    return result"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "inline_variable_array_repr", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef inline_variable_array_repr(var, max_width): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef inline_variable_array_repr(var, max_width):\n    \"\"\"Build a one-line summary of a variable's data.\"\"\"\n    if hasattr(var._data, '_repr_inline_'):\n        return var._data._repr_inline_(max_width)\n    if var._in_memory:\n        return format_array_flat(var, max_width)\n    dask_array_type = array_type('dask')\n    if isinstance(var._data, dask_array_type):\n        return inline_dask_repr(var.data)\n    sparse_array_type = array_type('sparse')\n    if isinstance(var._data, sparse_array_type):\n        return inline_sparse_repr(var.data)\n    if hasattr(var._data, '__array_function__'):\n        return maybe_truncate(repr(var._data).replace('\\n', ' '), max_width)\n    return '...'"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "maybe_truncate", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef maybe_truncate(obj, maxlen=500): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef maybe_truncate(obj, maxlen=500):\n    s = str(obj)\n    if len(s) > maxlen:\n        s = s[:maxlen - 3] + '...'\n    return s"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "first_n_items", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef first_n_items(array, n_desired): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef first_n_items(array, n_desired):\n    \"\"\"Returns the first n_desired items of an array\"\"\"\n    from xarray.core.variable import Variable\n    if n_desired < 1:\n        raise ValueError('must request at least one item')\n    if array.size == 0:\n        return []\n    if n_desired < array.size:\n        indexer = _get_indexer_at_least_n_items(array.shape, n_desired,\n            from_end=False)\n        array = array[indexer]\n    if isinstance(array, Variable):\n        array = array._data\n    return np.ravel(to_duck_array(array))[:n_desired]"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "format_timestamp", "method_path": "../srcdata/Basic/xarray/xarray/core/formatting.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\n\n\ndef format_timestamp(t): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport math\nfrom collections import defaultdict\nfrom collections.abc import Collection\nfrom collections.abc import Hashable\nfrom collections.abc import Sequence\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom itertools import chain\nfrom itertools import zip_longest\nfrom reprlib import recursive_repr\nfrom textwrap import dedent\nfrom typing import TYPE_CHECKING\nimport numpy as np\nimport pandas as pd\nfrom pandas.errors import OutOfBoundsDatetime\nfrom xarray.core.duck_array_ops import array_equiv\nfrom xarray.core.duck_array_ops import astype\nfrom xarray.core.indexing import MemoryCachedArray\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.options import _get_boolean_with_default\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.variable import Variable\nfrom xarray.core.indexes import PandasIndex\nfrom xarray.core.indexes import PandasMultiIndex\nfrom xarray.core.common import AbstractArray\ndef format_timestamp(t):\n    \"\"\"Cast given object to a Timestamp and return a nicely formatted string\"\"\"\n    try:\n        timestamp = pd.Timestamp(t)\n        datetime_str = timestamp.isoformat(sep=' ')\n    except OutOfBoundsDatetime:\n        datetime_str = str(t)\n    try:\n        date_str, time_str = datetime_str.split()\n    except ValueError:\n        return datetime_str\n    else:\n        if time_str == '00:00:00':\n            return date_str\n        else:\n            return f'{date_str}T{time_str}'"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "make_interpolate_example_data", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n\n\ndef make_interpolate_example_data(shape, frac_nan, seed=12345, non_uniform=\n    False): [MASK]\n", "response": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\ndef make_interpolate_example_data(shape, frac_nan, seed=12345, non_uniform=\n    False):\n    rs = np.random.RandomState(seed)\n    vals = rs.normal(size=shape)\n    if frac_nan == 1:\n        vals[:] = np.nan\n    elif frac_nan == 0:\n        pass\n    else:\n        n_missing = int(vals.size * frac_nan)\n        ys = np.arange(shape[0])\n        xs = np.arange(shape[1])\n        if n_missing:\n            np.random.shuffle(ys)\n            ys = ys[:n_missing]\n            np.random.shuffle(xs)\n            xs = xs[:n_missing]\n            vals[ys, xs] = np.nan\n    if non_uniform:\n        deltas = pd.to_timedelta(rs.normal(size=shape[0], scale=10), unit='D')\n        coords = {'time': (pd.Timestamp('2000-01-01') + deltas).sort_values()}\n    else:\n        coords = {'time': pd.date_range('2000-01-01', freq='D', periods=\n            shape[0])}\n    da = xr.DataArray(vals, dims=('time', 'x'), coords=coords)\n    df = da.to_pandas()\n    return da, df"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "array_notnull_equiv", "method_path": "../srcdata/Basic/xarray/xarray/core/duck_array_ops.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\n\n\ndef array_notnull_equiv(arr1, arr2): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport datetime\nimport inspect\nimport warnings\nfrom functools import partial\nfrom importlib import import_module\nimport numpy as np\nimport pandas as pd\nfrom numpy import all as array_all\nfrom numpy import any as array_any\nfrom numpy import around\nfrom numpy import full_like\nfrom numpy import gradient\nfrom numpy import isclose\nfrom numpy import isin\nfrom numpy import isnat\nfrom numpy import take\nfrom numpy import tensordot\nfrom numpy import transpose\nfrom numpy import unravel_index\nfrom numpy import concatenate as _concatenate\nfrom numpy.lib.stride_tricks import sliding_window_view\nfrom packaging.version import Version\nfrom pandas.api.types import is_extension_array_dtype\nfrom xarray.core import dask_array_ops\nfrom xarray.core import dtypes\nfrom xarray.core import nputils\nfrom xarray.core.options import OPTIONS\nfrom xarray.core.utils import is_duck_array\nfrom xarray.core.utils import module_available\nfrom numpy.core.multiarray import normalize_axis_index\nimport opt_einsum\nfrom dask.base import tokenize\nfrom xarray.core import nanops\nimport datetime as dt\nfrom xarray.core.common import _contains_cftime_datetimes\nimport bottleneck as bn\ndef array_notnull_equiv(arr1, arr2):\n    \"\"\"Like np.array_equal, but also allows values to be NaN in either or both\n    arrays\n    \"\"\"\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    lazy_equiv = lazy_array_equiv(arr1, arr2)\n    if lazy_equiv is None:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', \"In the future, 'NAT == x'\")\n            flag_array = (arr1 == arr2) | isnull(arr1) | isnull(arr2)\n            return bool(flag_array.all())\n    else:\n        return lazy_equiv"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "is_uniform_spaced", "method_path": "../srcdata/Basic/xarray/xarray/core/utils.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\n\n\ndef is_uniform_spaced(arr, **kwargs) ->bool: [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport functools\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Collection\nfrom collections.abc import Container\nfrom collections.abc import Hashable\nfrom collections.abc import ItemsView\nfrom collections.abc import Iterable\nfrom collections.abc import Iterator\nfrom collections.abc import KeysView\nfrom collections.abc import Mapping\nfrom collections.abc import MutableMapping\nfrom collections.abc import MutableSet\nfrom collections.abc import Sequence\nfrom collections.abc import ValuesView\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Literal\nfrom typing import TypeVar\nfrom typing import overload\nimport numpy as np\nimport pandas as pd\nfrom xarray.core.types import Dims\nfrom xarray.core.types import ErrorOptionsWithWarn\nfrom xarray.core import dtypes\nfrom xarray.core import duck_array_ops\nfrom xarray.core.variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\nfrom typing_extensions import TypeGuard\nfrom xarray.core.dataarray import DataArray\nimport xarray as xr\ndef is_uniform_spaced(arr, **kwargs) ->bool:\n    \"\"\"Return True if values of an array are uniformly spaced and sorted.\n\n    >>> is_uniform_spaced(range(5))\n    True\n    >>> is_uniform_spaced([-4, 0, 100])\n    False\n\n    kwargs are additional arguments to ``np.isclose``\n    \"\"\"\n    arr = np.array(arr, dtype=float)\n    diffs = np.diff(arr)\n    return bool(np.isclose(diffs.min(), diffs.max(), **kwargs))"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "figure_context", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n\n\n@contextlib.contextmanager\ndef figure_context(*args, **kwargs): [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n@contextlib.contextmanager\ndef figure_context(*args, **kwargs):\n    \"\"\"context manager which autocloses a figure (even if the test failed)\"\"\"\n    try:\n        yield None\n    finally:\n        plt.close('all')"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "da.interpolate_na", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_missing.py", "method_code_mask": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n\n\n@pytest.fixture\ndef da(): [MASK]\n", "response": "from __future__ import annotations\nimport itertools\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nfrom xarray.core.missing import NumpyInterpolator\nfrom xarray.core.missing import ScipyInterpolator\nfrom xarray.core.missing import SplineInterpolator\nfrom xarray.core.missing import _get_nan_block_lengths\nfrom xarray.core.missing import get_clean_interp_index\nfrom xarray.tests import _CFTIME_CALENDARS\nfrom xarray.tests import assert_allclose\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import raise_if_dask_computes\nfrom xarray.tests import requires_bottleneck\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_dask\nfrom xarray.tests import requires_numbagg\nfrom xarray.tests import requires_scipy\n@pytest.fixture\ndef da():\n    return xr.DataArray([0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7],\n        dims='time')"}
{"result": "passed", "model_name": "std", "repository": "xarray", "full_method_name": "easy_array", "method_path": "../srcdata/Basic/xarray/xarray/tests/test_plot.py", "method_code_mask": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\n\n\ndef easy_array(shape: tuple[int, ...], start: float=0, stop: float=1\n    ) ->np.ndarray: [MASK]\n", "response": "from __future__ import annotations\nimport contextlib\nimport inspect\nimport math\nfrom collections.abc import Generator\nfrom collections.abc import Hashable\nfrom copy import copy\nfrom datetime import date\nfrom datetime import timedelta\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Literal\nfrom typing import cast\nimport numpy as np\nimport pandas as pd\nimport pytest\nimport xarray as xr\nimport xarray.plot as xplt\nfrom xarray import DataArray\nfrom xarray import Dataset\nfrom xarray.plot.dataarray_plot import _infer_interval_breaks\nfrom xarray.plot.dataset_plot import _infer_meta_data\nfrom xarray.plot.utils import _assert_valid_xy\nfrom xarray.plot.utils import _build_discrete_cmap\nfrom xarray.plot.utils import _color_palette\nfrom xarray.plot.utils import _determine_cmap_params\nfrom xarray.plot.utils import _maybe_gca\nfrom xarray.plot.utils import get_axis\nfrom xarray.plot.utils import label_from_attrs\nfrom xarray.tests import assert_array_equal\nfrom xarray.tests import assert_equal\nfrom xarray.tests import assert_no_warnings\nfrom xarray.tests import requires_cartopy\nfrom xarray.tests import requires_cftime\nfrom xarray.tests import requires_matplotlib\nfrom xarray.tests import requires_seaborn\nimport matplotlib as mpl\nimport matplotlib.dates\nimport matplotlib.pyplot as plt\nimport mpl_toolkits\nfrom xarray.plot.accessor import DataArrayPlotAccessor\nimport matplotlib.dates as mdates\nfrom xarray.plot.accessor import DatasetPlotAccessor\nfrom xarray.plot.dataset_plot import _temp_dataarray\ndef easy_array(shape: tuple[int, ...], start: float=0, stop: float=1\n    ) ->np.ndarray:\n    \"\"\"\n    Make an array with desired shape using np.linspace\n\n    shape is a tuple like (2, 3)\n    \"\"\"\n    a = np.linspace(start, stop, num=math.prod(shape))\n    return a.reshape(shape)"}
