{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "get_by_shortcut", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/user_agents.py", "method_code_mask": "UASTRINGS = [('android', 'a',\n    'Mozilla/5.0 (Linux; U; Android 4.1.1; en-gb; Nexus 7 Build/JRO03D) AFL/01.04.02'\n    ), ('blackberry', 'l',\n    'Mozilla/5.0 (BlackBerry; U; BlackBerry 9900; en) AppleWebKit/534.11+ (KHTML, like Gecko) Version/7.1.0.346 Mobile Safari/534.11+'\n    ), ('bingbot', 'b',\n    'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)'\n    ), ('chrome', 'c',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1'\n    ), ('firefox', 'f',\n    'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:14.0) Gecko/20120405 Firefox/14.0a1'\n    ), ('googlebot', 'g',\n    'Googlebot/2.1 (+http://www.googlebot.com/bot.html)'), ('ie9', 'i',\n    'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)'), ('ipad',\n    'p',\n    'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'\n    ), ('iphone', 'h',\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 4_2_1 like Mac OS X) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148a Safari/6533.18.5'\n    ), ('safari', 's',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10'\n    )]\n\n\ndef get_by_shortcut(s): [MASK]\n", "response": "UASTRINGS = [('android', 'a',\n    'Mozilla/5.0 (Linux; U; Android 4.1.1; en-gb; Nexus 7 Build/JRO03D) AFL/01.04.02'\n    ), ('blackberry', 'l',\n    'Mozilla/5.0 (BlackBerry; U; BlackBerry 9900; en) AppleWebKit/534.11+ (KHTML, like Gecko) Version/7.1.0.346 Mobile Safari/534.11+'\n    ), ('bingbot', 'b',\n    'Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)'\n    ), ('chrome', 'c',\n    'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1'\n    ), ('firefox', 'f',\n    'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:14.0) Gecko/20120405 Firefox/14.0a1'\n    ), ('googlebot', 'g',\n    'Googlebot/2.1 (+http://www.googlebot.com/bot.html)'), ('ie9', 'i',\n    'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US)'), ('ipad',\n    'p',\n    'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'\n    ), ('iphone', 'h',\n    'Mozilla/5.0 (iPhone; CPU iPhone OS 4_2_1 like Mac OS X) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148a Safari/6533.18.5'\n    ), ('safari', 's',\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.3 Safari/534.53.10'\n    )]\ndef get_by_shortcut(s):\n    \"\"\"\n    Retrieve a user agent entry by shortcut.\n    \"\"\"\n    for i in UASTRINGS:\n        if s == i[1]:\n            return i"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "is_valid_host", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/check.py", "method_code_mask": "import ipaddress\nimport re\nfrom typing import AnyStr\n_label_valid = re.compile(b'[A-Z\\\\d\\\\-_]{1,63}$', re.IGNORECASE)\n\n\ndef is_valid_host(host: AnyStr) ->bool: [MASK]\n", "response": "import ipaddress\nimport re\nfrom typing import AnyStr\n_label_valid = re.compile(b'[A-Z\\\\d\\\\-_]{1,63}$', re.IGNORECASE)\ndef is_valid_host(host: AnyStr) ->bool:\n    \"\"\"\n    Checks if the passed bytes are a valid DNS hostname or an IPv4/IPv6 address.\n    \"\"\"\n    if isinstance(host, str):\n        try:\n            host_bytes = host.encode('idna')\n        except UnicodeError:\n            return False\n    else:\n        host_bytes = host\n    try:\n        host_bytes.decode('idna')\n    except ValueError:\n        return False\n    if len(host_bytes) > 255:\n        return False\n    if host_bytes and host_bytes.endswith(b'.'):\n        host_bytes = host_bytes[:-1]\n    if all(_label_valid.match(x) for x in host_bytes.split(b'.')):\n        return True\n    try:\n        ipaddress.ip_address(host_bytes.decode('idna'))\n        return True\n    except ValueError:\n        return False"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "unparse", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\n\n\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)\n\n\ndef unparse(scheme: str, host: str, port: int, path: str='') ->str: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)\ndef unparse(scheme: str, host: str, port: int, path: str='') ->str:\n    \"\"\"\n    Returns a URL string, constructed from the specified components.\n    Args:\n        All args must be str.\n    \"\"\"\n    if path == '*':\n        path = ''\n    authority = hostport(scheme, host, port)\n    return f'{scheme}://{authority}{path}'"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "decode", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef decode(s): [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef decode(s):\n    \"\"\"\n    Takes a urlencoded string and returns a list of surrogate-escaped (key, value) tuples.\n    \"\"\"\n    return urllib.parse.parse_qsl(s, keep_blank_values=True, errors=\n        'surrogateescape')"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "hostport", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/url.py", "method_code_mask": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\n\n\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\n\n\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr: [MASK]\n", "response": "from __future__ import annotations\nimport re\nimport urllib.parse\nfrom collections.abc import Sequence\nfrom typing import AnyStr\ndef default_port(scheme: AnyStr) ->(int | None):\n    return {'http': 80, b'http': 80, 'https': 443, b'https': 443}.get(scheme,\n        None)\ndef hostport(scheme: AnyStr, host: AnyStr, port: int) ->AnyStr:\n    \"\"\"\n    Returns the host component, with a port specification if needed.\n    \"\"\"\n    if default_port(scheme) == port:\n        return host\n    elif isinstance(host, bytes):\n        return b'%s:%d' % (host, port)\n    else:\n        return '%s:%d' % (host, port)"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "format_timestamp_with_milli", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef format_timestamp_with_milli(s): [MASK]\n", "response": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef format_timestamp_with_milli(s):\n    d = datetime.datetime.fromtimestamp(s)\n    return d.strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "shorten_message", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/tools/console/statusbar.py", "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom functools import lru_cache\n\n\n@lru_cache\ndef shorten_message(msg: (tuple[str, str] | str), max_width: int) ->list[tuple\n    [str, str]]: [MASK]\n", "response": "from __future__ import annotations\nfrom collections.abc import Callable\nfrom functools import lru_cache\n@lru_cache\ndef shorten_message(msg: (tuple[str, str] | str), max_width: int) ->list[tuple\n    [str, str]]:\n    \"\"\"\n    Shorten message so that it fits into a single line in the statusbar.\n    \"\"\"\n    if isinstance(msg, tuple):\n        disp_attr, msg_text = msg\n    elif isinstance(msg, str):\n        msg_text = msg\n        disp_attr = ''\n    else:\n        raise AssertionError(f'Unexpected message type: {type(msg)}')\n    msg_end = '\u2026'\n    prompt = '(more in eventlog)'\n    msg_lines = msg_text.split('\\n')\n    first_line = msg_lines[0]\n    if len(msg_lines) > 1:\n        line_length = len(first_line) + len(prompt)\n    else:\n        line_length = len(first_line)\n    if line_length > max_width:\n        shortening_index = max(0, max_width - len(prompt) - len(msg_end))\n        first_line = first_line[:shortening_index] + msg_end\n    elif len(msg_lines) == 1:\n        prompt = ''\n    return [(disp_attr, first_line), ('warn', prompt)]"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "format_timestamp", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef format_timestamp(s): [MASK]\n", "response": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef format_timestamp(s):\n    s = time.localtime(s)\n    d = datetime.datetime.fromtimestamp(time.mktime(s))\n    return d.strftime('%Y-%m-%d %H:%M:%S')"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "pretty_size", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/human.py", "method_code_mask": "import datetime\nimport functools\nimport ipaddress\nimport time\n\n\ndef pretty_size(size: int) ->str: [MASK]\n", "response": "import datetime\nimport functools\nimport ipaddress\nimport time\ndef pretty_size(size: int) ->str:\n    \"\"\"Convert a number of bytes into a human-readable string.\n\n    len(return value) <= 5 always holds true.\n    \"\"\"\n    s: float = size\n    if s < 1024:\n        return f'{s}b'\n    for suffix in ['k', 'm', 'g', 't']:\n        s /= 1024\n        if s < 99.95:\n            return f'{s:.1f}{suffix}'\n        if s < 1024 or suffix == 't':\n            return f'{s:.0f}{suffix}'\n    raise AssertionError"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "pack", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/dns/domain_names.py", "method_code_mask": "import struct\nfrom typing import Optional\n_LABEL_SIZE = struct.Struct('!B')\n\n\ndef pack(name: str) ->bytes: [MASK]\n", "response": "import struct\nfrom typing import Optional\n_LABEL_SIZE = struct.Struct('!B')\ndef pack(name: str) ->bytes:\n    \"\"\"Converts a domain name into RDATA without pointer compression.\"\"\"\n    buffer = bytearray()\n    if len(name) > 0:\n        for part in name.split('.'):\n            label = part.encode('idna')\n            size = len(label)\n            if size == 0:\n                raise ValueError(f\"domain name '{name}' contains empty labels\")\n            if size >= 64:\n                raise ValueError(\n                    f\"encoded label '{part}' of domain name '{name}' is too long ({size} bytes)\"\n                    )\n            buffer.extend(_LABEL_SIZE.pack(size))\n            buffer.extend(label)\n    buffer.extend(_LABEL_SIZE.pack(0))\n    return bytes(buffer)"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "_read_response_line", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/http1/read.py", "method_code_mask": "import re\nimport time\nfrom collections.abc import Iterable\n\n\ndef raise_if_http_version_unknown(http_version: bytes) ->None:\n    if not re.match(b'^HTTP/\\\\d\\\\.\\\\d$', http_version):\n        raise ValueError(f'Unknown HTTP version: {http_version!r}')\n\n\ndef _read_response_line(line: bytes) ->tuple[bytes, int, bytes]: [MASK]\n", "response": "import re\nimport time\nfrom collections.abc import Iterable\ndef raise_if_http_version_unknown(http_version: bytes) ->None:\n    if not re.match(b'^HTTP/\\\\d\\\\.\\\\d$', http_version):\n        raise ValueError(f'Unknown HTTP version: {http_version!r}')\ndef _read_response_line(line: bytes) ->tuple[bytes, int, bytes]:\n    try:\n        parts = line.split(None, 2)\n        if len(parts) == 2:\n            parts.append(b'')\n        http_version, status_code_str, reason = parts\n        status_code = int(status_code_str)\n        raise_if_http_version_unknown(http_version)\n    except ValueError as e:\n        raise ValueError(f'Bad HTTP response line: {line!r}') from e\n    return http_version, status_code, reason"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "unpack", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/dns/domain_names.py", "method_code_mask": "import struct\nfrom typing import Optional\n\n\ndef _unpack_label_into(labels: list[str], buffer: bytes, offset: int) ->int:\n    size, = _LABEL_SIZE.unpack_from(buffer, offset)\n    if size >= 64:\n        raise struct.error(f'unpack encountered a label of length {size}')\n    elif size == 0:\n        return _LABEL_SIZE.size\n    else:\n        offset += _LABEL_SIZE.size\n        end_label = offset + size\n        if len(buffer) < end_label:\n            raise struct.error(\n                f'unpack requires a label buffer of {size} bytes')\n        try:\n            labels.append(buffer[offset:end_label].decode('idna'))\n        except UnicodeDecodeError:\n            raise struct.error(\n                f'unpack encountered an illegal characters at offset {offset}')\n        return _LABEL_SIZE.size + size\n\n\n_POINTER_INDICATOR = 192\n_LABEL_SIZE = struct.Struct('!B')\n\n\ndef unpack_from(buffer: bytes, offset: int) ->tuple[str, int]:\n    \"\"\"Converts RDATA into a domain name without pointer compression from a given offset and also returns the binary size.\"\"\"\n    labels: list[str] = []\n    while True:\n        size, = _LABEL_SIZE.unpack_from(buffer, offset)\n        if size & _POINTER_INDICATOR == _POINTER_INDICATOR:\n            raise struct.error(\n                f'unpack encountered a pointer which is not supported in RDATA'\n                )\n        else:\n            offset += _unpack_label_into(labels, buffer, offset)\n            if size == 0:\n                break\n    return '.'.join(labels), offset\n\n\ndef unpack(buffer: bytes) ->str: [MASK]\n", "response": "import struct\nfrom typing import Optional\ndef _unpack_label_into(labels: list[str], buffer: bytes, offset: int) ->int:\n    size, = _LABEL_SIZE.unpack_from(buffer, offset)\n    if size >= 64:\n        raise struct.error(f'unpack encountered a label of length {size}')\n    elif size == 0:\n        return _LABEL_SIZE.size\n    else:\n        offset += _LABEL_SIZE.size\n        end_label = offset + size\n        if len(buffer) < end_label:\n            raise struct.error(\n                f'unpack requires a label buffer of {size} bytes')\n        try:\n            labels.append(buffer[offset:end_label].decode('idna'))\n        except UnicodeDecodeError:\n            raise struct.error(\n                f'unpack encountered an illegal characters at offset {offset}')\n        return _LABEL_SIZE.size + size\n_POINTER_INDICATOR = 192\n_LABEL_SIZE = struct.Struct('!B')\ndef unpack_from(buffer: bytes, offset: int) ->tuple[str, int]:\n    \"\"\"Converts RDATA into a domain name without pointer compression from a given offset and also returns the binary size.\"\"\"\n    labels: list[str] = []\n    while True:\n        size, = _LABEL_SIZE.unpack_from(buffer, offset)\n        if size & _POINTER_INDICATOR == _POINTER_INDICATOR:\n            raise struct.error(\n                f'unpack encountered a pointer which is not supported in RDATA'\n                )\n        else:\n            offset += _unpack_label_into(labels, buffer, offset)\n            if size == 0:\n                break\n    return '.'.join(labels), offset\ndef unpack(buffer: bytes) ->str:\n    \"\"\"Converts RDATA into a domain name without pointer compression.\"\"\"\n    name, length = unpack_from(buffer, 0)\n    if length != len(buffer):\n        raise struct.error(f'unpack requires a buffer of {length} bytes')\n    return name"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "typespec_to_str", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/typecheck.py", "method_code_mask": "import typing\nfrom collections import abc\n\n\ndef typespec_to_str(typespec: typing.Any) ->str: [MASK]\n", "response": "import typing\nfrom collections import abc\ndef typespec_to_str(typespec: typing.Any) ->str:\n    if typespec in (str, int, float, bool):\n        t = typespec.__name__\n    elif typespec == typing.Optional[str]:\n        t = 'optional str'\n    elif typespec in (typing.Sequence[str], abc.Sequence[str]):\n        t = 'sequence of str'\n    elif typespec == typing.Optional[int]:\n        t = 'optional int'\n    else:\n        raise NotImplementedError\n    return t"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "_read_quoted_string", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/cookies.py", "method_code_mask": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\n\n\ndef _read_quoted_string(s, start): [MASK]\n", "response": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "_read_cookie_pairs", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/net/http/cookies.py", "method_code_mask": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\n\n\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1\n\n\ndef _read_value(s, start, delims):\n    \"\"\"\n    Reads a value - the RHS of a token/value pair in a cookie.\n    \"\"\"\n    if start >= len(s):\n        return '', start\n    elif s[start] == '\"':\n        return _read_quoted_string(s, start)\n    else:\n        return _read_until(s, start, delims)\n\n\ndef _read_until(s, start, term):\n    \"\"\"\n    Read until one of the characters in term is reached.\n    \"\"\"\n    if start == len(s):\n        return '', start + 1\n    for i in range(start, len(s)):\n        if s[i] in term:\n            return s[start:i], i\n    return s[start:i + 1], i + 1\n\n\ndef _read_key(s, start, delims=';='):\n    \"\"\"\n    Read a key - the LHS of a token/value pair in a cookie.\n    \"\"\"\n    return _read_until(s, start, delims)\n\n\ndef _read_cookie_pairs(s, off=0): [MASK]\n", "response": "import email.utils\nimport re\nimport time\nfrom collections.abc import Iterable\ndef _read_quoted_string(s, start):\n    \"\"\"\n    start: offset to the first quote of the string to be read\n\n    A sort of loose super-set of the various quoted string specifications.\n\n    RFC6265 disallows backslashes or double quotes within quoted strings.\n    Prior RFCs use backslashes to escape. This leaves us free to apply\n    backslash escaping by default and be compatible with everything.\n    \"\"\"\n    escaping = False\n    ret = []\n    i = start\n    for i in range(start + 1, len(s)):\n        if escaping:\n            ret.append(s[i])\n            escaping = False\n        elif s[i] == '\"':\n            break\n        elif s[i] == '\\\\':\n            escaping = True\n        else:\n            ret.append(s[i])\n    return ''.join(ret), i + 1\ndef _read_value(s, start, delims):\n    \"\"\"\n    Reads a value - the RHS of a token/value pair in a cookie.\n    \"\"\"\n    if start >= len(s):\n        return '', start\n    elif s[start] == '\"':\n        return _read_quoted_string(s, start)\n    else:\n        return _read_until(s, start, delims)\ndef _read_until(s, start, term):\n    \"\"\"\n    Read until one of the characters in term is reached.\n    \"\"\"\n    if start == len(s):\n        return '', start + 1\n    for i in range(start, len(s)):\n        if s[i] in term:\n            return s[start:i], i\n    return s[start:i + 1], i + 1\ndef _read_key(s, start, delims=';='):\n    \"\"\"\n    Read a key - the LHS of a token/value pair in a cookie.\n    \"\"\"\n    return _read_until(s, start, delims)\ndef _read_cookie_pairs(s, off=0):\n    \"\"\"\n    Read pairs of lhs=rhs values from Cookie headers.\n    off: start offset\n    \"\"\"\n    pairs = []\n    while True:\n        lhs, off = _read_key(s, off)\n        lhs = lhs.lstrip()\n        rhs = ''\n        if off < len(s) and s[off] == '=':\n            rhs, off = _read_value(s, off + 1, ';')\n        if rhs or lhs:\n            pairs.append([lhs, rhs])\n        off += 1\n        if not off < len(s):\n            break\n    return pairs, off"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "_name_to_keyval", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/certs.py", "method_code_mask": "import contextlib\nimport datetime\nimport ipaddress\nimport os\nimport sys\nimport warnings\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import cast\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Union\nimport OpenSSL\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs12\nfrom cryptography.x509 import ExtendedKeyUsageOID\nfrom cryptography.x509 import NameOID\n\n\ndef _name_to_keyval(name: x509.Name) ->list[tuple[str, str]]: [MASK]\n", "response": "import contextlib\nimport datetime\nimport ipaddress\nimport os\nimport sys\nimport warnings\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import cast\nfrom typing import NewType\nfrom typing import Optional\nfrom typing import Union\nimport OpenSSL\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs12\nfrom cryptography.x509 import ExtendedKeyUsageOID\nfrom cryptography.x509 import NameOID\ndef _name_to_keyval(name: x509.Name) ->list[tuple[str, str]]:\n    parts = []\n    for attr in name:\n        k = attr.rfc4514_string().partition('=')[0]\n        v = cast(str, attr.value)\n        parts.append((k, v))\n    return parts"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "escaped_str_to_bytes", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef escaped_str_to_bytes(data: str) ->bytes: [MASK]\n", "response": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef escaped_str_to_bytes(data: str) ->bytes:\n    \"\"\"\n    Take an escaped string and return the unescaped bytes equivalent.\n\n    Raises:\n        ValueError, if the escape sequence is invalid.\n    \"\"\"\n    if not isinstance(data, str):\n        raise ValueError(f'data must be str, but is {data.__class__.__name__}')\n    return codecs.escape_decode(data)[0]"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "format_graphql", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/contentviews/graphql.py", "method_code_mask": "import json\nfrom typing import Any\n\n\ndef format_graphql(data): [MASK]\n", "response": "import json\nfrom typing import Any\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "format_query_list", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/contentviews/graphql.py", "method_code_mask": "import json\nfrom typing import Any\n\n\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)\n\n\ndef format_query_list(data: list[Any]): [MASK]\n", "response": "import json\nfrom typing import Any\ndef format_graphql(data):\n    query = data['query']\n    header_data = data.copy()\n    header_data['query'] = '...'\n    return '{header}\\n---\\n{query}\\n'.format(header=json.dumps(header_data,\n        indent=2), query=query)\ndef format_query_list(data: list[Any]):\n    num_queries = len(data) - 1\n    result = ''\n    for i, op in enumerate(data):\n        result += f'--- {i}/{num_queries}\\n'\n        result += format_graphql(op)\n    return result"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "bytes_to_escaped_str", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef bytes_to_escaped_str(data: bytes, keep_spacing: bool=False,\n    escape_single_quotes: bool=False) ->str: [MASK]\n", "response": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef bytes_to_escaped_str(data: bytes, keep_spacing: bool=False,\n    escape_single_quotes: bool=False) ->str:\n    \"\"\"\n    Take bytes and return a safe string that can be displayed to the user.\n\n    Single quotes are always escaped, double quotes are never escaped:\n        \"'\" + bytes_to_escaped_str(...) + \"'\"\n    gives a valid Python string.\n\n    Args:\n        keep_spacing: If True, tabs and newlines will not be escaped.\n    \"\"\"\n    if not isinstance(data, bytes):\n        raise ValueError(\n            f'data must be bytes, but is {data.__class__.__name__}')\n    ret = repr(b'\"' + data).lstrip('b')[2:-1]\n    if not escape_single_quotes:\n        ret = re.sub(\"(?<!\\\\\\\\)(\\\\\\\\\\\\\\\\)*\\\\\\\\'\", lambda m: (m.group(1) or\n            '') + \"'\", ret)\n    if keep_spacing:\n        ret = re.sub('(?<!\\\\\\\\)(\\\\\\\\\\\\\\\\)*\\\\\\\\([nrt])', lambda m: (m.group(\n            1) or '') + dict(n='\\n', r='\\r', t='\\t')[m.group(2)], ret)\n    return ret"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "is_mostly_bin", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef is_mostly_bin(s: bytes) ->bool: [MASK]\n", "response": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef is_mostly_bin(s: bytes) ->bool:\n    if not s or len(s) == 0:\n        return False\n    return sum(i < 9 or 13 < i < 32 or 126 < i for i in s[:100]) / len(s[:100]\n        ) > 0.3"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "is_xml", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef is_xml(s: bytes) ->bool: [MASK]\n", "response": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef is_xml(s: bytes) ->bool:\n    for char in s:\n        if char in (9, 10, 32):\n            continue\n        return char == 60\n    return False"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "clean_hanging_newline", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/utils/strutils.py", "method_code_mask": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\n\n\ndef clean_hanging_newline(t): [MASK]\n", "response": "import codecs\nimport io\nimport re\nfrom collections.abc import Iterable\nfrom typing import overload\ndef clean_hanging_newline(t):\n    \"\"\"\n    Many editors will silently add a newline to the final line of a\n    document (I'm looking at you, Vim). This function fixes this common\n    problem at the risk of removing a hanging newline in the rare cases\n    where the user actually intends it.\n    \"\"\"\n    if t and t[-1] == '\\n':\n        return t[:-1]\n    return t"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "domain_match", "method_path": "../srcdata/Network/mitmproxy/mitmproxy/addons/stickycookie.py", "method_code_mask": "import collections\nfrom http import cookiejar\nfrom typing import Optional\n\n\ndef domain_match(a: str, b: str) ->bool: [MASK]\n", "response": "import collections\nfrom http import cookiejar\nfrom typing import Optional\ndef domain_match(a: str, b: str) ->bool:\n    if cookiejar.domain_match(a, b):\n        return True\n    elif cookiejar.domain_match(a, b.strip('.')):\n        return True\n    return False"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "SetEncoder.default", "method_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/urlindex.py", "method_code_mask": "import abc\nimport datetime\nimport json\nimport logging\nfrom pathlib import Path\n\n\nclass SetEncoder(json.JSONEncoder):\n\n    def default(self, obj): [MASK]\n", "response": "import abc\nimport datetime\nimport json\nimport logging\nfrom pathlib import Path\nclass SetEncoder(json.JSONEncoder):\n\n    def default(self, obj):\n        if isinstance(obj, set):\n            return list(obj)\n        return json.JSONEncoder.default(self, obj)"}
{"result": "passed", "model_name": "std", "repository": "mitmproxy", "full_method_name": "randomString", "method_path": "../srcdata/Network/mitmproxy/examples/contrib/webscanner_helper/proxyauth_selenium.py", "method_code_mask": "import abc\nimport logging\nimport random\nimport string\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom selenium import webdriver\n\n\ndef randomString(string_length=10): [MASK]\n", "response": "import abc\nimport logging\nimport random\nimport string\nimport time\nfrom typing import Any\nfrom typing import cast\nfrom selenium import webdriver\ndef randomString(string_length=10):\n    \"\"\"Generate a random string of fixed length\"\"\"\n    letters = string.ascii_lowercase\n    return ''.join(random.choice(letters) for i in range(string_length))"}
