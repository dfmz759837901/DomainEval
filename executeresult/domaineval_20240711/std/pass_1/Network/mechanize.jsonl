{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "choose_boundary", "method_path": "../srcdata/Network/mechanize/mechanize/_form_controls.py", "method_code_mask": "from __future__ import absolute_import\nimport random\nimport re\nimport sys\nimport warnings\nfrom io import BytesIO\nfrom mimetypes import guess_type\n\n\ndef choose_boundary(): [MASK]\n", "response": "from __future__ import absolute_import\nimport random\nimport re\nimport sys\nimport warnings\nfrom io import BytesIO\nfrom mimetypes import guess_type\ndef choose_boundary():\n    \"\"\"Return a string usable as a multipart boundary.\"\"\"\n    limit = (1 << 31) - 1\n    nonce = ''.join(str(random.randint(0, limit)) for i in (0, 1, 2))\n    return '-' * 27 + nonce"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "attribute_names", "method_path": "../srcdata/Network/mechanize/test/test_cookies.py", "method_code_mask": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\n\n\ndef attribute_names(obj): [MASK]\n", "response": "import errno\nimport inspect\nimport os\nimport re\nimport sys\nimport tempfile\nimport time\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize import Request\nfrom mechanize._util import hide_experimental_warnings\nfrom mechanize._util import reset_experimental_warnings\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import codepoint_to_chr\nfrom mechanize import CookieJar\nfrom mechanize._clientcookie import request_is_unverifiable\nfrom mechanize import MozillaCookieJar\nfrom mechanize import lwp_cookie_str\nfrom mechanize import DefaultCookiePolicy\nfrom mechanize._clientcookie import DEFAULT_HTTP_PORT\nfrom mechanize._util import time2netscape\nfrom mechanize._clientcookie import escape_path\nfrom mechanize._clientcookie import request_path\nfrom mechanize._clientcookie import request_port\nfrom mechanize._clientcookie import request_host_lc\nfrom mechanize import effective_request_host\nfrom mechanize._clientcookie import is_HDN\nfrom mechanize._clientcookie import reach\nfrom mechanize._clientcookie import domain_match\nfrom mechanize._clientcookie import user_domain_match\nfrom mechanize._headersutil import parse_ns_headers\nfrom mechanize import LoadError\nfrom mechanize import LWPCookieJar\nfrom mechanize.polyglot import is_py2\ndef attribute_names(obj):\n    return set([spec[0] for spec in inspect.getmembers(obj) if not spec[0].\n        startswith('__')])"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "time2netscape", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef time2netscape(t=None): [MASK]\n", "response": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef time2netscape(t=None):\n    \"\"\"Return a string representing time in seconds since epoch, t.\n\n    If the function is called without an argument, it will use the current\n    time.\n\n    The format of the returned string is like this:\n\n    Wed, DD-Mon-YYYY HH:MM:SS GMT\n\n    \"\"\"\n    if t is None:\n        t = time.time()\n    year, mon, mday, hour, min, sec, wday = time.gmtime(t)[:7]\n    return '%s %02d-%s-%04d %02d:%02d:%02d GMT' % (days[wday], mday, months\n        [mon - 1], year, hour, min, sec)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "parse_http_list", "method_path": "../srcdata/Network/mechanize/mechanize/_urllib2_fork.py", "method_code_mask": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\n\n\ndef parse_http_list(s): [MASK]\n", "response": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\ndef parse_http_list(s):\n    \"\"\"Parse lists as described by RFC 2068 Section 2.\n\n    In particular, parse comma-separated lists where the elements of\n    the list may include quoted-strings.  A quoted-string could\n    contain a comma.  A non-quoted string could have quotes in the\n    middle.  Neither commas nor quotes count if they are escaped.\n    Only double-quotes count, not single-quotes.\n    \"\"\"\n    res = []\n    part = ''\n    escape = quote = False\n    for cur in s:\n        if escape:\n            part += cur\n            escape = False\n            continue\n        if quote:\n            if cur == '\\\\':\n                escape = True\n                continue\n            elif cur == '\"':\n                quote = False\n            part += cur\n            continue\n        if cur == ',':\n            res.append(part)\n            part = ''\n            continue\n        if cur == '\"':\n            quote = True\n        part += cur\n    if part:\n        res.append(part)\n    return list(filter(None, (part_.strip() for part_ in res)))"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "normalize_url", "method_path": "../srcdata/Network/mechanize/mechanize/_urllib2_fork.py", "method_code_mask": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\n\n\ndef normalize_url(url): [MASK]\n", "response": "from __future__ import absolute_import\nimport base64\nimport bisect\nimport copy\nimport hashlib\nimport logging\nimport os\nimport platform\nimport posixpath\nimport re\nimport socket\nimport sys\nimport time\nfrom collections import OrderedDict\nfrom functools import partial\nfrom io import BufferedReader\nfrom io import BytesIO\nimport ssl\nimport email.utils as emailutils\nimport mimetypes\nimport ftplib\ndef normalize_url(url):\n    parsed = urlparse(url)\n    netloc = parsed.netloc\n    if not isinstance(netloc, bytes) and netloc:\n\n        def safe_encode(label):\n            try:\n                return label.encode('idna').decode('ascii')\n            except ValueError:\n                return label.encode('ascii', 'replace').decode('ascii')\n        netloc = u'.'.join(map(safe_encode, netloc.split(u'.')))\n    return urlunparse(parsed._replace(path=\n        fix_invalid_bytes_in_url_component(parsed.path), netloc=netloc,\n        query=fix_invalid_bytes_in_url_component(parsed.query, QUERY_CHARS),\n        fragment=fix_invalid_bytes_in_url_component(parsed.fragment,\n        FRAGMENT_CHARS)))"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "request_is_unverifiable", "method_path": "../srcdata/Network/mechanize/mechanize/_clientcookie.py", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\n\n\ndef request_is_unverifiable(request): [MASK]\n", "response": "from __future__ import absolute_import\nimport re\nimport time\ndef request_is_unverifiable(request):\n    try:\n        return request.is_unverifiable()\n    except AttributeError:\n        if hasattr(request, 'unverifiable'):\n            return request.unverifiable\n        else:\n            raise"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "make_headers", "method_path": "../srcdata/Network/mechanize/mechanize/_response.py", "method_code_mask": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\n\n\ndef make_headers(headers): [MASK]\n", "response": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "content_parser", "method_path": "../srcdata/Network/mechanize/mechanize/_html.py", "method_code_mask": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\nDEFAULT_ENCODING = 'utf-8'\n\n\ndef content_parser(data, url=None, response_info=None, transport_encoding=\n    None, default_encoding=DEFAULT_ENCODING, is_html=True): [MASK]\n", "response": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\nDEFAULT_ENCODING = 'utf-8'\ndef content_parser(data, url=None, response_info=None, transport_encoding=\n    None, default_encoding=DEFAULT_ENCODING, is_html=True):\n    \"\"\"\n    Parse data (a bytes object) into an etree representation such as\n    :py:mod:`xml.etree.ElementTree` or `lxml.etree`\n    :param bytes data: The data to parse\n    :param url: The URL of the document being parsed or None\n    :param response_info: Information about the document\n        (contains all HTTP headers as :class:`HTTPMessage`)\n    :param transport_encoding: The character encoding for the document being\n        parsed as specified in the HTTP headers or None.\n    :param default_encoding: The character encoding to use if no encoding\n        could be detected and no transport_encoding is specified\n    :param is_html: If the document is to be parsed as HTML.\n    \"\"\"\n    if not is_html:\n        return\n    try:\n        from html5_parser import parse\n    except Exception:\n        from html5lib import parse\n        kw = {'namespaceHTMLElements': False}\n        if transport_encoding and isinstance(data, bytes):\n            kw['transport_encoding'] = transport_encoding\n        return parse(data, **kw)\n    else:\n        return parse(data, transport_encoding=transport_encoding)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "make_response", "method_path": "../srcdata/Network/mechanize/mechanize/_response.py", "method_code_mask": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\n\n\nclass closeable_response:\n    \"\"\"Avoids unnecessarily clobbering urllib.addinfourl methods on .close().\n\n    Only supports responses returned by mechanize.HTTPHandler.\n\n    After .close(), the following methods are supported:\n\n    .read()\n    .readline()\n    .info()\n    .geturl()\n    .__iter__()\n    .next()\n    .close()\n\n    and the following attributes are supported:\n\n    .code\n    .msg\n    .http_version\n\n    Also supports pickling (but the stdlib currently does something to prevent\n    it: http://python.org/sf/1144636).\n\n    \"\"\"\n    closeable_response = None\n\n    def __init__(self, fp, headers, url, code=200, msg='OK', http_version=None\n        ):\n        self._set_fp(fp)\n        self._headers = headers\n        self._url = url\n        self.code = code\n        self.msg = msg\n        self.http_version = http_version\n\n    def _set_fp(self, fp):\n        self.fp = fp\n        self.read = self.fp.read\n        self.readline = self.fp.readline\n        if hasattr(self.fp, 'readlines'):\n            self.readlines = self.fp.readlines\n        if hasattr(self.fp, 'fileno'):\n            self.fileno = self.fp.fileno\n        else:\n            self.fileno = lambda : None\n        self.__iter__ = self.fp.__iter__\n        self.next = partial(next, self.fp)\n\n    def __repr__(self):\n        return '<%s at %s whose fp = %r>' % (self.__class__.__name__, hex(\n            abs(id(self))), self.fp)\n\n    def info(self):\n        return self._headers\n\n    @property\n    def headers(self):\n        return self._headers\n\n    def getcode(self):\n        return self.code\n\n    def get_header_values(self, name):\n        return self._headers.get_all(name)\n\n    def get_all_header_names(self, normalize=True):\n        ans = self._headers.keys()\n        if normalize:\n            ans = list(map(normalize_header_name, ans))\n        return ans\n\n    def __getitem__(self, name):\n        return self._headers[name]\n\n    def get(self, name, default):\n        return self._headers.get(name)\n\n    def geturl(self):\n        return self._url\n\n    def close(self):\n        wrapped = self.fp\n        wrapped.close()\n        new_wrapped = eofresponse(self._url, self._headers, self.code, self.msg\n            )\n        self._set_fp(new_wrapped)\n\n\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))\n\n\ndef make_response(data, headers, url=None, code=200, msg='OK'): [MASK]\n", "response": "from __future__ import absolute_import\nfrom functools import partial\nimport copy\nfrom io import BytesIO\nclass closeable_response:\n    \"\"\"Avoids unnecessarily clobbering urllib.addinfourl methods on .close().\n\n    Only supports responses returned by mechanize.HTTPHandler.\n\n    After .close(), the following methods are supported:\n\n    .read()\n    .readline()\n    .info()\n    .geturl()\n    .__iter__()\n    .next()\n    .close()\n\n    and the following attributes are supported:\n\n    .code\n    .msg\n    .http_version\n\n    Also supports pickling (but the stdlib currently does something to prevent\n    it: http://python.org/sf/1144636).\n\n    \"\"\"\n    closeable_response = None\n\n    def __init__(self, fp, headers, url, code=200, msg='OK', http_version=None\n        ):\n        self._set_fp(fp)\n        self._headers = headers\n        self._url = url\n        self.code = code\n        self.msg = msg\n        self.http_version = http_version\n\n    def _set_fp(self, fp):\n        self.fp = fp\n        self.read = self.fp.read\n        self.readline = self.fp.readline\n        if hasattr(self.fp, 'readlines'):\n            self.readlines = self.fp.readlines\n        if hasattr(self.fp, 'fileno'):\n            self.fileno = self.fp.fileno\n        else:\n            self.fileno = lambda : None\n        self.__iter__ = self.fp.__iter__\n        self.next = partial(next, self.fp)\n\n    def __repr__(self):\n        return '<%s at %s whose fp = %r>' % (self.__class__.__name__, hex(\n            abs(id(self))), self.fp)\n\n    def info(self):\n        return self._headers\n\n    @property\n    def headers(self):\n        return self._headers\n\n    def getcode(self):\n        return self.code\n\n    def get_header_values(self, name):\n        return self._headers.get_all(name)\n\n    def get_all_header_names(self, normalize=True):\n        ans = self._headers.keys()\n        if normalize:\n            ans = list(map(normalize_header_name, ans))\n        return ans\n\n    def __getitem__(self, name):\n        return self._headers[name]\n\n    def get(self, name, default):\n        return self._headers.get(name)\n\n    def geturl(self):\n        return self._url\n\n    def close(self):\n        wrapped = self.fp\n        wrapped.close()\n        new_wrapped = eofresponse(self._url, self._headers, self.code, self.msg\n            )\n        self._set_fp(new_wrapped)\ndef make_headers(headers):\n    \"\"\"\n    headers: sequence of (name, value) pairs\n    \"\"\"\n    hdr_text = []\n    for name_value in headers:\n        hdr_text.append('%s: %s' % name_value)\n    ans = '\\n'.join(hdr_text)\n    if not isinstance(ans, bytes):\n        ans = ans.encode('iso-8859-1')\n    return create_response_info(BytesIO(ans))\ndef make_response(data, headers, url=None, code=200, msg='OK'):\n    \"\"\"Convenient factory for objects implementing response interface.\n    data: string containing response body data\n    headers: sequence of (name, value) pairs\n    url: URL of response\n    code: integer response code (e.g. 200)\n    msg: string response code message (e.g. \"OK\")\n    \"\"\"\n    mime_headers = make_headers(headers)\n    if not isinstance(data, bytes):\n        data = data.encode('utf-8')\n    r = closeable_response(BytesIO(data), mime_headers, url, code, msg)\n    return response_seek_wrapper(r)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "time2isoz", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef time2isoz(t=None): [MASK]\n", "response": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef time2isoz(t=None):\n    \"\"\"Return a string representing time in seconds since epoch, t.\n\n    If the function is called without an argument, it will use the current\n    time.\n\n    The format of the returned string is like \"YYYY-MM-DD hh:mm:ssZ\",\n    representing Universal Time (UTC, aka GMT).  An example of this format is:\n\n    1994-11-24 08:49:37Z\n\n    \"\"\"\n    if t is None:\n        t = time.time()\n    year, mon, mday, hour, min, sec = time.gmtime(t)[:6]\n    return '%04d-%02d-%02d %02d:%02d:%02dZ' % (year, mon, mday, hour, min, sec)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "raise_deprecations", "method_path": "../srcdata/Network/mechanize/test/test_form.py", "method_code_mask": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\n\ndef raise_deprecations(): [MASK]\n", "response": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef raise_deprecations():\n    try:\n        registry = _form.__warningregistry__\n    except AttributeError:\n        pass\n    else:\n        registry.clear()\n    warnings.filterwarnings('error', category=DeprecationWarning)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "http2time", "method_path": "../srcdata/Network/mechanize/mechanize/_util.py", "method_code_mask": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\n\n\ndef http2time(text): [MASK]\n", "response": "from __future__ import absolute_import\nimport re\nimport time\nimport warnings\nfrom calendar import timegm\ndef http2time(text):\n    \"\"\"Returns time in seconds since epoch of time represented by a string.\n\n    Return value is an integer.\n\n    None is returned if the format of str is unrecognized, the time is outside\n    the representable range, or the timezone string is not recognized.  If the\n    string contains no timezone, UTC is assumed.\n\n    The timezone in the string may be numerical (like \"-0800\" or \"+0100\") or a\n    string timezone (like \"UTC\", \"GMT\", \"BST\" or \"EST\").  Currently, only the\n    timezone strings equivalent to UTC (zero offset) are known to the function.\n\n    The function loosely parses the following formats:\n\n    Wed, 09 Feb 1994 22:23:32 GMT       -- HTTP format\n    Tuesday, 08-Feb-94 14:15:29 GMT     -- old rfc850 HTTP format\n    Tuesday, 08-Feb-1994 14:15:29 GMT   -- broken rfc850 HTTP format\n    09 Feb 1994 22:23:32 GMT            -- HTTP format (no weekday)\n    08-Feb-94 14:15:29 GMT              -- rfc850 format (no weekday)\n    08-Feb-1994 14:15:29 GMT            -- broken rfc850 format (no weekday)\n\n    The parser ignores leading and trailing whitespace.  The time may be\n    absent.\n\n    If the year is given with only 2 digits, the function will select the\n    century that makes the year closest to the current date.\n\n    \"\"\"\n    m = strict_re.search(text)\n    if m:\n        g = m.groups()\n        mon = months_lower.index(g[1].lower()) + 1\n        tt = int(g[2]), mon, int(g[0]), int(g[3]), int(g[4]), float(g[5])\n        return my_timegm(tt)\n    text = text.lstrip()\n    text = wkday_re.sub('', text, 1)\n    day, mon, yr, hr, min, sec, tz = [None] * 7\n    m = loose_http_re.search(text)\n    if m is not None:\n        day, mon, yr, hr, min, sec, tz = m.groups()\n    else:\n        return None\n    return _str2time(day, mon, yr, hr, min, sec, tz)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "get_title", "method_path": "../srcdata/Network/mechanize/mechanize/_html.py", "method_code_mask": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\n\n\ndef get_title(root): [MASK]\n", "response": "from __future__ import absolute_import\nimport codecs\nimport copy\nimport re\nfrom html5lib import parse\ndef get_title(root):\n    for title in root.iter('title'):\n        text = compress_whitespace(title.text)\n        if text:\n            return text"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "http_message", "method_path": "../srcdata/Network/mechanize/test/test_urllib2.py", "method_code_mask": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\n\n\ndef http_message(mapping): [MASK]\n", "response": "import os\nimport sys\nimport unittest\nfrom io import BytesIO\nimport mechanize\nfrom mechanize._response import test_response\nfrom mechanize import HTTPRedirectHandler\nfrom mechanize import HTTPEquivProcessor\nfrom mechanize import HTTPRefreshProcessor\nfrom mechanize import HTTPCookieProcessor\nfrom mechanize import HTTPRefererProcessor\nfrom mechanize import HTTPErrorProcessor\nfrom mechanize import HTTPHandler\nfrom mechanize import OpenerDirector\nfrom mechanize import build_opener\nfrom mechanize import Request\nfrom mechanize._urllib2_fork import AbstractHTTPHandler\nfrom mechanize._urllib2_fork import normalize_url\nfrom mechanize._urllib2_fork import AbstractBasicAuthHandler\nfrom mechanize._util import write_file\nimport mechanize._response\nimport mechanize._sockettimeout as _sockettimeout\nimport mechanize._testcase\nimport mechanize._urllib2_fork\nfrom mechanize._mechanize import sanepathname2url\nfrom mechanize.polyglot import create_response_info\nfrom mechanize.polyglot import iteritems\nimport copy\nimport socket\nfrom mechanize import URLError\nfrom mechanize import _response\nimport ftplib\nfrom email.utils import formatdate\nfrom mechanize import HTTPRobotRulesProcessor\nfrom mechanize import HTTPDefaultErrorHandler\nfrom mechanize._response import test_html_response\nfrom mechanize import CookieJar\nimport base64\nfrom mechanize import HTTPEquivParser\nimport doctest\ndef http_message(mapping):\n    \"\"\"\n    >>> http_message({\"Content-Type\": \"text/html\"}).items()\n    [('content-type', 'text/html')]\n\n    \"\"\"\n    f = []\n    for kv in iteritems(mapping):\n        f.append('%s: %s' % kv)\n    f.append('')\n    msg = '\\r\\n'.join(f)\n    if not isinstance(msg, bytes):\n        msg = msg.encode('iso-8859-1')\n    msg = create_response_info(BytesIO(msg))\n    return msg"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "join_header_words", "method_path": "../srcdata/Network/mechanize/mechanize/_headersutil.py", "method_code_mask": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\n\n\ndef join_header_words(lists): [MASK]\n", "response": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\ndef join_header_words(lists):\n    \"\"\"Do the inverse of the conversion done by split_header_words.\n\n    Takes a list of lists of (key, value) pairs and produces a single header\n    value.  Attribute values are quoted if needed.\n\n    >>> join_header_words([[(\"text/plain\", None), (\"charset\", \"iso-8859/1\")]])\n    'text/plain; charset=\"iso-8859/1\"'\n    >>> join_header_words([[(            \"text/plain\", None)], [(\"charset\", \"iso-8859/1\")]])\n    'text/plain, charset=\"iso-8859/1\"'\n\n    \"\"\"\n    headers = []\n    for pairs in lists:\n        attr = []\n        for k, v in pairs:\n            if v is not None:\n                if not re.search('^\\\\w+$', v):\n                    v = join_escape_re.sub('\\\\\\\\\\\\1', v)\n                    v = '\"%s\"' % v\n                if k is None:\n                    k = v\n                else:\n                    k = '%s=%s' % (k, v)\n            attr.append(k)\n        if attr:\n            headers.append('; '.join(attr))\n    return ', '.join(headers)"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "parse_ns_headers", "method_path": "../srcdata/Network/mechanize/mechanize/_headersutil.py", "method_code_mask": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\n\n\ndef parse_ns_headers(ns_headers): [MASK]\n", "response": "from __future__ import absolute_import\nimport os\nimport re\nimport doctest\ndef parse_ns_headers(ns_headers):\n    \"\"\"Ad-hoc parser for Netscape protocol cookie-attributes.\n\n    The old Netscape cookie format for Set-Cookie can for instance contain\n    an unquoted \",\" in the expires field, so we have to use this ad-hoc\n    parser instead of split_header_words.\n\n    XXX This may not make the best possible effort to parse all the crap\n    that Netscape Cookie headers contain.  Ronald Tschalar's HTTPClient\n    parser is probably better, so could do worse than following that if\n    this ever gives any trouble.\n\n    Currently, this is also used for parsing RFC 2109 cookies.\n\n    \"\"\"\n    known_attrs = ('expires', 'domain', 'path', 'secure', 'version', 'port',\n        'max-age')\n    result = []\n    for ns_header in ns_headers:\n        pairs = []\n        version_set = False\n        params = re.split(';\\\\s*', ns_header)\n        for ii in range(len(params)):\n            param = params[ii]\n            param = param.rstrip()\n            if param == '':\n                continue\n            if '=' not in param:\n                k, v = param, None\n            else:\n                k, v = re.split('\\\\s*=\\\\s*', param, 1)\n                k = k.lstrip()\n            if ii != 0:\n                lc = k.lower()\n                if lc in known_attrs:\n                    k = lc\n                if k == 'version':\n                    v = strip_quotes(v)\n                    version_set = True\n                if k == 'expires':\n                    v = http2time(strip_quotes(v))\n            pairs.append((k, v))\n        if pairs:\n            if not version_set:\n                pairs.append(('version', '0'))\n            result.append(pairs)\n    return result"}
{"result": "passed", "model_name": "std", "repository": "mechanize", "full_method_name": "BytesIO", "method_path": "../srcdata/Network/mechanize/test/test_form.py", "method_code_mask": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\n\n\ndef parse_file_ex(file, base_uri, select_default=False, request_class=\n    mechanize.Request, encoding=None, backwards_compat=False, add_global=True):\n    raw = file.read()\n    root = content_parser(raw, transport_encoding=encoding)\n    form_encoding = find_declared_encoding(raw) or encoding\n    forms, global_form = _form.parse_forms(root, base_uri, select_default=\n        select_default, request_class=request_class, encoding=form_encoding)\n    if not add_global:\n        return list(forms)\n    return [global_form] + list(forms)\n\n\nparse_file = partial(parse_file_ex, add_global=False)\n\n\nclass UploadTests(_testcase.TestCase):\n\n    def setUp(self):\n        _testcase.TestCase.setUp(self)\n        import mechanize._form_controls as fc\n\n        def mock_choose_boundary():\n            self.boundary_count += 1\n            return str(self.boundary_count)\n        self.choose_boundary = fc.choose_boundary\n        fc.choose_boundary = mock_choose_boundary\n        self.boundary_count = 0\n\n    def tearDown(self):\n        import mechanize._form_controls as fc\n        fc.choose_boundary = self.choose_boundary\n        _testcase.TestCase.tearDown(self)\n\n    def test_choose_boundary(self):\n        bndy = _form_controls.choose_boundary()\n        ii = bndy.find('.')\n        self.assertTrue(ii < 0)\n\n    def make_form(self):\n        html = \"\"\"<form action=\"/cgi-bin/upload.cgi\" method=\"POST\" enctype=\"multipart/form-data\">\n<input type=\"file\" name=\"data\">\n<input type=\"text\" name=\"user\" value=\"nobody\">\n<br>\n<input type=\"submit\">\n</form>\n\"\"\"\n        return parse_file(BytesIO(html),\n            'http://localhost/cgi-bin/upload.cgi', backwards_compat=False)[0]\n\n    def test_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data))\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req)\n\n    def test_file_request_with_filename(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='afilename')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req, filename='afilename')\n\n    def test_multipart_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='filenamea')\n        more_data = 'rhubarb\\nrhubarb\\n'\n        data_control.add_file(BytesIO(more_data))\n        yet_more_data = 'rheum\\nrhaponicum\\n'\n        data_control.add_file(BytesIO(yet_more_data), filename='filenamec')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        self.assertMultiLineEqual(req.get_data().decode('ascii'),\n            '--1\\r\\nContent-Disposition: form-data; name=\"data\"\\r\\nContent-Type: multipart/mixed;\\r\\n    boundary=2\\r\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamea\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nblah\\nbaz\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrhubarb\\nrhubarb\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamec\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrheum\\nrhaponicum\\n\\r\\n--2--\\r\\n\\r\\n--1\\r\\nContent-Disposition: form-data; name=\"user\"\\r\\n\\r\\njohn\\r\\n--1--\\r\\n'\n            )\n\n    def test_upload_data(self):\n        form = self.make_form()\n        data = form.click().get_data()\n        self.assertTrue(data.startswith(b'--'))\n\n    def test_empty_upload(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"./weird.html\" enctype=\"multipart/form-data\">\n<input type=\"submit\" name=\"submit\"></input>\n</form></html>\"\"\"\n            ), '.', backwards_compat=False)\n        form = forms[0]\n        data = form.click().get_data()\n        lines = data.split(b'\\r\\n')\n        self.assertTrue(lines[0].startswith(b'--'))\n        self.assertEqual(lines[1],\n            b'Content-Disposition: form-data; name=\"submit\"')\n        self.assertEqual(lines[2], b'')\n        self.assertEqual(lines[3], b'')\n        self.assertTrue(lines[4].startswith(b'--'))\n\n    def test_no_files(self):\n        self.monkey_patch(_form_controls, 'choose_boundary', lambda : '123')\n        forms = parse_file_ex(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"spam\" enctype=\"multipart/form-data\">\n<INPUT type=\"file\" name=\"spam\" />\n</form></html>\"\"\"\n            ), '.')\n        form = forms[1]\n        data = form.click().get_data()\n        self.assertEqual(data,\n            b'--123\\r\\nContent-Disposition: form-data; name=\"spam\"; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\\r\\n--123--\\r\\n'\n            )\n\n\ndef BytesIO(x=b''): [MASK]\n", "response": "import os\nimport unittest\nimport warnings\nimport io\nfrom functools import partial\nimport mechanize\nimport mechanize._form as _form\nimport mechanize._form_controls as _form_controls\nimport mechanize._testcase as _testcase\nfrom mechanize import AmbiguityError\nfrom mechanize import ControlNotFoundError\nfrom mechanize import ItemCountError\nfrom mechanize import ItemNotFoundError\nfrom mechanize._html import content_parser\nfrom mechanize._html import find_declared_encoding\nfrom mechanize._util import get1\nfrom mechanize.polyglot import codepoint_to_chr\nimport mechanize._form_controls as fc\ndef parse_file_ex(file, base_uri, select_default=False, request_class=\n    mechanize.Request, encoding=None, backwards_compat=False, add_global=True):\n    raw = file.read()\n    root = content_parser(raw, transport_encoding=encoding)\n    form_encoding = find_declared_encoding(raw) or encoding\n    forms, global_form = _form.parse_forms(root, base_uri, select_default=\n        select_default, request_class=request_class, encoding=form_encoding)\n    if not add_global:\n        return list(forms)\n    return [global_form] + list(forms)\nparse_file = partial(parse_file_ex, add_global=False)\nclass UploadTests(_testcase.TestCase):\n    def setUp(self):\n        _testcase.TestCase.setUp(self)\n        import mechanize._form_controls as fc\n        def mock_choose_boundary():\n            self.boundary_count += 1\n            return str(self.boundary_count)\n        self.choose_boundary = fc.choose_boundary\n        fc.choose_boundary = mock_choose_boundary\n        self.boundary_count = 0\n    def tearDown(self):\n        import mechanize._form_controls as fc\n        fc.choose_boundary = self.choose_boundary\n        _testcase.TestCase.tearDown(self)\n    def test_choose_boundary(self):\n        bndy = _form_controls.choose_boundary()\n        ii = bndy.find('.')\n        self.assertTrue(ii < 0)\n    def make_form(self):\n        html = \"\"\"<form action=\"/cgi-bin/upload.cgi\" method=\"POST\" enctype=\"multipart/form-data\">\n<input type=\"file\" name=\"data\">\n<input type=\"text\" name=\"user\" value=\"nobody\">\n<br>\n<input type=\"submit\">\n</form>\n\"\"\"\n        return parse_file(BytesIO(html),\n            'http://localhost/cgi-bin/upload.cgi', backwards_compat=False)[0]\n    def test_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data))\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req)\n    def test_file_request_with_filename(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='afilename')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        compare_multipart(self, req, filename='afilename')\n    def test_multipart_file_request(self):\n        form = self.make_form()\n        form['user'] = 'john'\n        data_control = form.find_control('data')\n        data = 'blah\\nbaz\\n'\n        data_control.add_file(BytesIO(data), filename='filenamea')\n        more_data = 'rhubarb\\nrhubarb\\n'\n        data_control.add_file(BytesIO(more_data))\n        yet_more_data = 'rheum\\nrhaponicum\\n'\n        data_control.add_file(BytesIO(yet_more_data), filename='filenamec')\n        req = form.click()\n        self.assertTrue(get_header(req, 'Content-type').startswith(\n            'multipart/form-data; boundary='))\n        self.assertMultiLineEqual(req.get_data().decode('ascii'),\n            '--1\\r\\nContent-Disposition: form-data; name=\"data\"\\r\\nContent-Type: multipart/mixed;\\r\\n    boundary=2\\r\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamea\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nblah\\nbaz\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrhubarb\\nrhubarb\\n\\r\\n--2\\r\\nContent-Disposition: file; filename=\"filenamec\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nrheum\\nrhaponicum\\n\\r\\n--2--\\r\\n\\r\\n--1\\r\\nContent-Disposition: form-data; name=\"user\"\\r\\n\\r\\njohn\\r\\n--1--\\r\\n'\n            )\n    def test_upload_data(self):\n        form = self.make_form()\n        data = form.click().get_data()\n        self.assertTrue(data.startswith(b'--'))\n    def test_empty_upload(self):\n        forms = parse_file(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"./weird.html\" enctype=\"multipart/form-data\">\n<input type=\"submit\" name=\"submit\"></input>\n</form></html>\"\"\"\n            ), '.', backwards_compat=False)\n        form = forms[0]\n        data = form.click().get_data()\n        lines = data.split(b'\\r\\n')\n        self.assertTrue(lines[0].startswith(b'--'))\n        self.assertEqual(lines[1],\n            b'Content-Disposition: form-data; name=\"submit\"')\n        self.assertEqual(lines[2], b'')\n        self.assertEqual(lines[3], b'')\n        self.assertTrue(lines[4].startswith(b'--'))\n    def test_no_files(self):\n        self.monkey_patch(_form_controls, 'choose_boundary', lambda : '123')\n        forms = parse_file_ex(BytesIO(\n            \"\"\"<html>\n<form method=\"POST\" action=\"spam\" enctype=\"multipart/form-data\">\n<INPUT type=\"file\" name=\"spam\" />\n</form></html>\"\"\"\n            ), '.')\n        form = forms[1]\n        data = form.click().get_data()\n        self.assertEqual(data,\n            b'--123\\r\\nContent-Disposition: form-data; name=\"spam\"; filename=\"\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\\r\\n--123--\\r\\n'\n            )\ndef BytesIO(x=b''):\n    if not isinstance(x, bytes):\n        x = x.encode('utf-8')\n    return io.BytesIO(x)"}
