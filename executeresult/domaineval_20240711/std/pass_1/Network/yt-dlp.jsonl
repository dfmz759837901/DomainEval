{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "timeconvert", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef timeconvert(timestr): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef timeconvert(timestr):\n    \"\"\"Convert RFC 2822 defined time string into system timestamp\"\"\"\n    timestamp = None\n    timetuple = email.utils.parsedate_tz(timestr)\n    if timetuple is not None:\n        timestamp = email.utils.mktime_tz(timetuple)\n    return timestamp"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "sanitize_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef sanitize_url(url, *, scheme='http'): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef sanitize_url(url, *, scheme='http'):\n    if url is None:\n        return\n    elif url.startswith('//'):\n        return f'{scheme}:{url}'\n    COMMON_TYPOS = ('^httpss://', 'https://'), ('^rmtp([es]?)://', 'rtmp\\\\1://'\n        )\n    for mistake, fixup in COMMON_TYPOS:\n        if re.match(mistake, url):\n            return re.sub(mistake, fixup, url)\n    return url"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "date_from_str", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\n\n\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\n\n\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)\n\n\ndef date_from_str(date_str, format='%Y%m%d', strict=False): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)\ndef date_from_str(date_str, format='%Y%m%d', strict=False):\n    \"\"\"\n    Return a date object from a string using datetime_from_str\n    @param strict  Restrict allowed patterns to \"YYYYMMDD\" and\n                   (now|today|yesterday)(-\\\\d+(day|week|month|year)s?)?\n    \"\"\"\n    if strict and not re.fullmatch(\n        '\\\\d{8}|(now|today|yesterday)(-\\\\d+(day|week|month|year)s?)?', date_str\n        ):\n        raise ValueError(f'Invalid date format \"{date_str}\"')\n    return datetime_from_str(date_str, precision='microsecond', format=format\n        ).date()"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "sanitize_filename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass NO_DEFAULT:\n    pass\n\n\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass NO_DEFAULT:\n    pass\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    @param restricted   Use a stricter subset of allowed characters\n    @param is_id        Whether this is an ID that should be kept unchanged if possible.\n                        If unset, yt-dlp's new sanitization rules are in effect\n    \"\"\"\n    if s == '':\n        return ''\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        elif not restricted and char == '\\n':\n            return '\\x00 '\n        elif is_id is NO_DEFAULT and not restricted and char in '\"*:<>?|/\\\\':\n            return {'/': '\u29f8', '\\\\': '\u29f9'}.get(char, chr(ord(char) + 65248))\n        elif char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else \"'\"\n        elif char == ':':\n            return '\\x00_\\x00-' if restricted else '\\x00 \\x00-'\n        elif char in '\\\\/|*<>':\n            return '\\x00_'\n        if restricted and (char in \"!&'()[]{}$;`^,#\" or char.isspace() or\n            ord(char) > 127):\n            return '' if unicodedata.category(char)[0] in 'CM' else '\\x00_'\n        return char\n    if restricted and (is_id is NO_DEFAULT or not is_id):\n        s = unicodedata.normalize('NFKC', s)\n    s = re.sub('[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if is_id is NO_DEFAULT:\n        result = re.sub('(\\\\0.)(?:(?=\\\\1)..)+', '\\\\1', result)\n        STRIP_RE = '(?:\\\\0.|[ _-])*'\n        result = re.sub(f'^\\x00.{STRIP_RE}|{STRIP_RE}\\x00.$', '', result)\n    result = result.replace('\\x00', '') or '_'\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "remove_quotes", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef remove_quotes(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef remove_quotes(s):\n    if s is None or len(s) < 2:\n        return s\n    for quote in ('\"', \"'\"):\n        if s[0] == quote and s[-1] == quote:\n            return s[1:-1]\n    return s"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "str_to_int", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\n\n\ndef str_to_int(int_str): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "orderedSet", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef orderedSet(iterable, *, lazy=False): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef orderedSet(iterable, *, lazy=False):\n    \"\"\"Remove all duplicates from the input iterable\"\"\"\n\n    def _iter():\n        seen = []\n        for x in iterable:\n            if x not in seen:\n                seen.append(x)\n                yield x\n    return _iter() if lazy else list(_iter())"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "unsmuggle_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\n\n\ndef unsmuggle_url(smug_url, default=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "datetime_from_str", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\n\n\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\n\n\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef datetime_add_months(dt_, months):\n    \"\"\"Increment/Decrement a datetime object by months.\"\"\"\n    month = dt_.month + months - 1\n    year = dt_.year + month // 12\n    month = month % 12 + 1\n    day = min(dt_.day, calendar.monthrange(year, month)[1])\n    return dt_.replace(year, month, day)\ndef datetime_round(dt_, precision='day'):\n    \"\"\"\n    Round a datetime object's time to a specific precision\n    \"\"\"\n    if precision == 'microsecond':\n        return dt_\n    unit_seconds = {'day': 86400, 'hour': 3600, 'minute': 60, 'second': 1}\n    roundto = lambda x, n: (x + n / 2) // n * n\n    timestamp = roundto(calendar.timegm(dt_.timetuple()), unit_seconds[\n        precision])\n    return dt.datetime.fromtimestamp(timestamp, dt.timezone.utc)\ndef datetime_from_str(date_str, precision='auto', format='%Y%m%d'):\n    \"\"\"\n    Return a datetime object from a string.\n    Supported format:\n        (now|today|yesterday|DATE)([+-]\\\\d+(microsecond|second|minute|hour|day|week|month|year)s?)?\n    @param format       strftime format of DATE\n    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day\n                        auto: round to the unit provided in date_str (if applicable).\n    \"\"\"\n    auto_precision = False\n    if precision == 'auto':\n        auto_precision = True\n        precision = 'microsecond'\n    today = datetime_round(dt.datetime.now(dt.timezone.utc), precision)\n    if date_str in ('now', 'today'):\n        return today\n    if date_str == 'yesterday':\n        return today - dt.timedelta(days=1)\n    match = re.match(\n        '(?P<start>.+)(?P<sign>[+-])(?P<time>\\\\d+)(?P<unit>microsecond|second|minute|hour|day|week|month|year)s?'\n        , date_str)\n    if match is not None:\n        start_time = datetime_from_str(match.group('start'), precision, format)\n        time = int(match.group('time')) * (-1 if match.group('sign') == '-'\n             else 1)\n        unit = match.group('unit')\n        if unit == 'month' or unit == 'year':\n            new_date = datetime_add_months(start_time, time * 12 if unit ==\n                'year' else time)\n            unit = 'day'\n        else:\n            if unit == 'week':\n                unit = 'day'\n                time *= 7\n            delta = dt.timedelta(**{(unit + 's'): time})\n            new_date = start_time + delta\n        if auto_precision:\n            return datetime_round(new_date, unit)\n        return new_date\n    return datetime_round(dt.datetime.strptime(date_str, format), precision)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "float_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef float_or_none(v, scale=1, invscale=1, default=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef float_or_none(v, scale=1, invscale=1, default=None):\n    if v is None:\n        return default\n    try:\n        return float(v) * invscale / scale\n    except (ValueError, TypeError):\n        return default"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "url_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef url_or_none(url): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef url_or_none(url):\n    if not url or not isinstance(url, str):\n        return None\n    url = url.strip()\n    return url if re.match(\n        '^(?:(?:https?|rt(?:m(?:pt?[es]?|fp)|sp[su]?)|mms|ftps?):)?//', url\n        ) else None"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "int_or_none", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "smuggle_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\n\n\ndef smuggle_url(url, data): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef unsmuggle_url(smug_url, default=None):\n    if '#__youtubedl_smuggle' not in smug_url:\n        return smug_url, default\n    url, _, sdata = smug_url.rpartition('#')\n    jsond = urllib.parse.parse_qs(sdata)['__youtubedl_smuggle'][0]\n    data = json.loads(jsond)\n    return url, data\ndef smuggle_url(url, data):\n    \"\"\" Pass additional data in a URL for internal use. \"\"\"\n    url, idata = unsmuggle_url(url, {})\n    data.update(idata)\n    sdata = urllib.parse.urlencode({'__youtubedl_smuggle': json.dumps(data)})\n    return url + '#' + sdata"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "url_basename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef url_basename(url): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef url_basename(url):\n    path = urllib.parse.urlparse(url).path\n    return path.strip('/').split('/')[-1]"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "urljoin", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef urljoin(base, path): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef urljoin(base, path):\n    if isinstance(path, bytes):\n        path = path.decode()\n    if not isinstance(path, str) or not path:\n        return None\n    if re.match('^(?:[a-zA-Z][a-zA-Z0-9+-.]*:)?//', path):\n        return path\n    if isinstance(base, bytes):\n        base = base.decode()\n    if not isinstance(base, str) or not re.match('^(?:https?:)?//', base):\n        return None\n    return urllib.parse.urljoin(base, path)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_age_limit", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nTV_PARENTAL_GUIDELINES = {'TV-Y': 0, 'TV-Y7': 7, 'TV-G': 0, 'TV-PG': 0,\n    'TV-14': 14, 'TV-MA': 17}\nUS_RATINGS = {'G': 0, 'PG': 10, 'PG-13': 13, 'R': 16, 'NC': 18}\n\n\ndef parse_age_limit(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nTV_PARENTAL_GUIDELINES = {'TV-Y': 0, 'TV-Y7': 7, 'TV-G': 0, 'TV-PG': 0,\n    'TV-14': 14, 'TV-MA': 17}\nUS_RATINGS = {'G': 0, 'PG': 10, 'PG-13': 13, 'R': 16, 'NC': 18}\ndef parse_age_limit(s):\n    if type(s) is int:\n        return s if 0 <= s <= 21 else None\n    elif not isinstance(s, str):\n        return None\n    m = re.match('^(?P<age>\\\\d{1,2})\\\\+?$', s)\n    if m:\n        return int(m.group('age'))\n    s = s.upper()\n    if s in US_RATINGS:\n        return US_RATINGS[s]\n    m = re.match('^TV[_-]?({})$'.format('|'.join(k[3:] for k in\n        TV_PARENTAL_GUIDELINES)), s)\n    if m:\n        return TV_PARENTAL_GUIDELINES['TV-' + m.group(1)]\n    return None"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "sanitize_filename", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nACCENT_CHARS = dict(zip(\n    '\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n    itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'],\n    'UUUUUY', ['TH', 'ss'], 'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'],\n    'uuuuuy', ['th'], 'y')))\n\n\nclass NO_DEFAULT:\n    pass\n\n\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nACCENT_CHARS = dict(zip(\n    '\u00c2\u00c3\u00c4\u00c0\u00c1\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u0150\u00d8\u0152\u00d9\u00da\u00db\u00dc\u0170\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u0151\u00f8\u0153\u00f9\u00fa\u00fb\u00fc\u0171\u00fd\u00fe\u00ff',\n    itertools.chain('AAAAAA', ['AE'], 'CEEEEIIIIDNOOOOOOO', ['OE'],\n    'UUUUUY', ['TH', 'ss'], 'aaaaaa', ['ae'], 'ceeeeiiiionooooooo', ['oe'],\n    'uuuuuy', ['th'], 'y')))\nclass NO_DEFAULT:\n    pass\ndef sanitize_filename(s, restricted=False, is_id=NO_DEFAULT):\n    \"\"\"Sanitizes a string so it could be used as part of a filename.\n    @param restricted   Use a stricter subset of allowed characters\n    @param is_id        Whether this is an ID that should be kept unchanged if possible.\n                        If unset, yt-dlp's new sanitization rules are in effect\n    \"\"\"\n    if s == '':\n        return ''\n    def replace_insane(char):\n        if restricted and char in ACCENT_CHARS:\n            return ACCENT_CHARS[char]\n        elif not restricted and char == '\\n':\n            return '\\x00 '\n        elif is_id is NO_DEFAULT and not restricted and char in '\"*:<>?|/\\\\':\n            return {'/': '\u29f8', '\\\\': '\u29f9'}.get(char, chr(ord(char) + 65248))\n        elif char == '?' or ord(char) < 32 or ord(char) == 127:\n            return ''\n        elif char == '\"':\n            return '' if restricted else \"'\"\n        elif char == ':':\n            return '\\x00_\\x00-' if restricted else '\\x00 \\x00-'\n        elif char in '\\\\/|*<>':\n            return '\\x00_'\n        if restricted and (char in \"!&'()[]{}$;`^,#\" or char.isspace() or\n            ord(char) > 127):\n            return '' if unicodedata.category(char)[0] in 'CM' else '\\x00_'\n        return char\n    if restricted and (is_id is NO_DEFAULT or not is_id):\n        s = unicodedata.normalize('NFKC', s)\n    s = re.sub('[0-9]+(?::[0-9]+)+', lambda m: m.group(0).replace(':', '_'), s)\n    result = ''.join(map(replace_insane, s))\n    if is_id is NO_DEFAULT:\n        result = re.sub('(\\\\0.)(?:(?=\\\\1)..)+', '\\\\1', result)\n        STRIP_RE = '(?:\\\\0.|[ _-])*'\n        result = re.sub(f'^\\x00.{STRIP_RE}|{STRIP_RE}\\x00.$', '', result)\n    result = result.replace('\\x00', '') or '_'\n    if not is_id:\n        while '__' in result:\n            result = result.replace('__', '_')\n        result = result.strip('_')\n        if restricted and result.startswith('-_'):\n            result = result[2:]\n        if result.startswith('-'):\n            result = '_' + result[len('-'):]\n        result = result.lstrip('.')\n        if not result:\n            result = '_'\n    return result"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "fix_xml_ampersands", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef fix_xml_ampersands(xml_str): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef fix_xml_ampersands(xml_str):\n    \"\"\"Replace all the '&' by '&amp;' in XML\"\"\"\n    return re.sub(\n        '&(?!amp;|lt;|gt;|apos;|quot;|#x[0-9a-fA-F]{,4};|#[0-9]{,4};)',\n        '&amp;', xml_str)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_duration", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_duration(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_duration(s):\n    if not isinstance(s, str):\n        return None\n    s = s.strip()\n    if not s:\n        return None\n    days, hours, mins, secs, ms = [None] * 5\n    m = re.match(\n        \"\"\"(?x)\n            (?P<before_secs>\n                (?:(?:(?P<days>[0-9]+):)?(?P<hours>[0-9]+):)?(?P<mins>[0-9]+):)?\n            (?P<secs>(?(before_secs)[0-9]{1,2}|[0-9]+))\n            (?P<ms>[.:][0-9]+)?Z?$\n        \"\"\"\n        , s)\n    if m:\n        days, hours, mins, secs, ms = m.group('days', 'hours', 'mins',\n            'secs', 'ms')\n    else:\n        m = re.match(\n            \"\"\"(?ix)(?:P?\n                (?:\n                    [0-9]+\\\\s*y(?:ears?)?,?\\\\s*\n                )?\n                (?:\n                    [0-9]+\\\\s*m(?:onths?)?,?\\\\s*\n                )?\n                (?:\n                    [0-9]+\\\\s*w(?:eeks?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<days>[0-9]+)\\\\s*d(?:ays?)?,?\\\\s*\n                )?\n                T)?\n                (?:\n                    (?P<hours>[0-9]+)\\\\s*h(?:(?:ou)?rs?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<mins>[0-9]+)\\\\s*m(?:in(?:ute)?s?)?,?\\\\s*\n                )?\n                (?:\n                    (?P<secs>[0-9]+)(?P<ms>\\\\.[0-9]+)?\\\\s*s(?:ec(?:ond)?s?)?\\\\s*\n                )?Z?$\"\"\"\n            , s)\n        if m:\n            days, hours, mins, secs, ms = m.groups()\n        else:\n            m = re.match(\n                '(?i)(?:(?P<hours>[0-9.]+)\\\\s*(?:hours?)|(?P<mins>[0-9.]+)\\\\s*(?:mins?\\\\.?|minutes?)\\\\s*)Z?$'\n                , s)\n            if m:\n                hours, mins = m.groups()\n            else:\n                return None\n    if ms:\n        ms = ms.replace(':', '.')\n    return sum(float(part or 0) * mult for part, mult in ((days, 86400), (\n        hours, 3600), (mins, 60), (secs, 1), (ms, 1)))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "remove_dot_segments", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/networking.py", "method_code_mask": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\n\n\ndef remove_dot_segments(path): [MASK]\n", "response": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "merge_dicts", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef merge_dicts(*dicts): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef merge_dicts(*dicts):\n    merged = {}\n    for a_dict in dicts:\n        for k, v in a_dict.items():\n            if v is not None and k not in merged or isinstance(v, str\n                ) and merged[k] == '':\n                merged[k] = v\n    return merged"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "read_batch_urls", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef read_batch_urls(batch_fd): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef read_batch_urls(batch_fd):\n\n    def fixup(url):\n        if not isinstance(url, str):\n            url = url.decode('utf-8', 'replace')\n        BOM_UTF8 = '\u00ef\u00bb\u00bf', '\\ufeff'\n        for bom in BOM_UTF8:\n            if url.startswith(bom):\n                url = url[len(bom):]\n        url = url.lstrip()\n        if not url or url.startswith(('#', ';', ']')):\n            return False\n        return re.split('\\\\s#', url, maxsplit=1)[0].rstrip()\n    with contextlib.closing(batch_fd) as fd:\n        return [url for url in map(fixup, fd) if url]"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "normalize_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/networking.py", "method_code_mask": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\n\n\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)\n\n\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    return urllib.parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\n\n\ndef normalize_url(url): [MASK]\n", "response": "import collections\nimport random\nimport urllib.parse\nimport urllib.request\ndef remove_dot_segments(path):\n    output = []\n    segments = path.split('/')\n    for s in segments:\n        if s == '.':\n            continue\n        elif s == '..':\n            if output:\n                output.pop()\n        else:\n            output.append(s)\n    if not segments[0] and (not output or output[0]):\n        output.insert(0, '')\n    if segments[-1] in ('.', '..'):\n        output.append('')\n    return '/'.join(output)\ndef escape_rfc3986(s):\n    \"\"\"Escape non-ASCII characters as suggested by RFC 3986\"\"\"\n    return urllib.parse.quote(s, b\"%/;:@&=+$,!~*'()?#[]\")\ndef normalize_url(url):\n    \"\"\"Normalize URL as suggested by RFC 3986\"\"\"\n    url_parsed = urllib.parse.urlparse(url)\n    return url_parsed._replace(netloc=url_parsed.netloc.encode('idna').\n        decode('ascii'), path=escape_rfc3986(remove_dot_segments(url_parsed\n        .path)), params=escape_rfc3986(url_parsed.params), query=\n        escape_rfc3986(url_parsed.query), fragment=escape_rfc3986(\n        url_parsed.fragment)).geturl()"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "strip_jsonp", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef strip_jsonp(code): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef strip_jsonp(code):\n    return re.sub(\n        \"\"\"(?sx)^\n            (?:window\\\\.)?(?P<func_name>[a-zA-Z0-9_.$]*)\n            (?:\\\\s*&&\\\\s*(?P=func_name))?\n            \\\\s*\\\\(\\\\s*(?P<callback_data>.*)\\\\);?\n            \\\\s*?(?://[^\\\\n]*)*$\"\"\"\n        , '\\\\g<callback_data>', code)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "uppercase_escape", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef uppercase_escape(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef uppercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub('\\\\\\\\U[0-9a-fA-F]{8}', lambda m: unicode_escape(m.group(0\n        ))[0], s)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "multipart_encode", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef _multipart_encode_impl(data, boundary):\n    content_type = f'multipart/form-data; boundary={boundary}'\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, str):\n            k = k.encode()\n        if isinstance(v, str):\n            v = v.encode()\n        content = (b'Content-Disposition: form-data; name=\"' + k +\n            b'\"\\r\\n\\r\\n' + v + b'\\r\\n')\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n    return out, content_type\n\n\ndef multipart_encode(data, boundary=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef _multipart_encode_impl(data, boundary):\n    content_type = f'multipart/form-data; boundary={boundary}'\n    out = b''\n    for k, v in data.items():\n        out += b'--' + boundary.encode('ascii') + b'\\r\\n'\n        if isinstance(k, str):\n            k = k.encode()\n        if isinstance(v, str):\n            v = v.encode()\n        content = (b'Content-Disposition: form-data; name=\"' + k +\n            b'\"\\r\\n\\r\\n' + v + b'\\r\\n')\n        if boundary.encode('ascii') in content:\n            raise ValueError('Boundary overlaps with data')\n        out += content\n    out += b'--' + boundary.encode('ascii') + b'--\\r\\n'\n    return out, content_type\ndef multipart_encode(data, boundary=None):\n    \"\"\"\n    Encode a dict to RFC 7578-compliant form-data\n    data:\n        A dict where keys and values can be either Unicode or bytes-like\n        objects.\n    boundary:\n        If specified a Unicode object, it's used as the boundary. Otherwise\n        a random boundary is generated.\n    Reference: https://tools.ietf.org/html/rfc7578\n    \"\"\"\n    has_specified_boundary = boundary is not None\n    while True:\n        if boundary is None:\n            boundary = '---------------' + str(random.randrange(268435455,\n                4294967295))\n        try:\n            out, content_type = _multipart_encode_impl(data, boundary)\n            break\n        except ValueError:\n            if has_specified_boundary:\n                raise\n            boundary = None\n    return out, content_type"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_iso8601", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass NO_DEFAULT:\n    pass\n\n\nTIMEZONE_NAMES = {'UT': 0, 'UTC': 0, 'GMT': 0, 'Z': 0, 'AST': -4, 'ADT': -3,\n    'EST': -5, 'EDT': -4, 'CST': -6, 'CDT': -5, 'MST': -7, 'MDT': -6, 'PST':\n    -8, 'PDT': -7}\n\n\ndef extract_timezone(date_str, default=None):\n    m = re.search(\n        \"\"\"(?x)\n            ^.{8,}?                                              # >=8 char non-TZ prefix, if present\n            (?P<tz>Z|                                            # just the UTC Z, or\n                (?:(?<=.\\\\b\\\\d{4}|\\\\b\\\\d{2}:\\\\d\\\\d)|                   # preceded by 4 digits or hh:mm or\n                   (?<!.\\\\b[a-zA-Z]{3}|[a-zA-Z]{4}|..\\\\b\\\\d\\\\d))     # not preceded by 3 alpha word or >= 4 alpha or 2 digits\n                   [ ]?                                          # optional space\n                (?P<sign>\\\\+|-)                                   # +/-\n                (?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})       # hh[:]mm\n            $)\n        \"\"\"\n        , date_str)\n    timezone = None\n    if not m:\n        m = re.search('\\\\d{1,2}:\\\\d{1,2}(?:\\\\.\\\\d+)?(?P<tz>\\\\s*[A-Z]+)$',\n            date_str)\n        timezone = TIMEZONE_NAMES.get(m and m.group('tz').strip())\n        if timezone is not None:\n            date_str = date_str[:-len(m.group('tz'))]\n            timezone = dt.timedelta(hours=timezone)\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if m.group('sign'):\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = dt.timedelta(hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    if timezone is None and default is not NO_DEFAULT:\n        timezone = default or dt.timedelta()\n    return timezone, date_str\n\n\ndef parse_iso8601(date_str, delimiter='T', timezone=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass NO_DEFAULT:\n    pass\nTIMEZONE_NAMES = {'UT': 0, 'UTC': 0, 'GMT': 0, 'Z': 0, 'AST': -4, 'ADT': -3,\n    'EST': -5, 'EDT': -4, 'CST': -6, 'CDT': -5, 'MST': -7, 'MDT': -6, 'PST':\n    -8, 'PDT': -7}\ndef extract_timezone(date_str, default=None):\n    m = re.search(\n        \"\"\"(?x)\n            ^.{8,}?                                              # >=8 char non-TZ prefix, if present\n            (?P<tz>Z|                                            # just the UTC Z, or\n                (?:(?<=.\\\\b\\\\d{4}|\\\\b\\\\d{2}:\\\\d\\\\d)|                   # preceded by 4 digits or hh:mm or\n                   (?<!.\\\\b[a-zA-Z]{3}|[a-zA-Z]{4}|..\\\\b\\\\d\\\\d))     # not preceded by 3 alpha word or >= 4 alpha or 2 digits\n                   [ ]?                                          # optional space\n                (?P<sign>\\\\+|-)                                   # +/-\n                (?P<hours>[0-9]{2}):?(?P<minutes>[0-9]{2})       # hh[:]mm\n            $)\n        \"\"\"\n        , date_str)\n    timezone = None\n    if not m:\n        m = re.search('\\\\d{1,2}:\\\\d{1,2}(?:\\\\.\\\\d+)?(?P<tz>\\\\s*[A-Z]+)$',\n            date_str)\n        timezone = TIMEZONE_NAMES.get(m and m.group('tz').strip())\n        if timezone is not None:\n            date_str = date_str[:-len(m.group('tz'))]\n            timezone = dt.timedelta(hours=timezone)\n    else:\n        date_str = date_str[:-len(m.group('tz'))]\n        if m.group('sign'):\n            sign = 1 if m.group('sign') == '+' else -1\n            timezone = dt.timedelta(hours=sign * int(m.group('hours')),\n                minutes=sign * int(m.group('minutes')))\n    if timezone is None and default is not NO_DEFAULT:\n        timezone = default or dt.timedelta()\n    return timezone, date_str\ndef parse_iso8601(date_str, delimiter='T', timezone=None):\n    \"\"\" Return a UNIX timestamp from the given date \"\"\"\n    if date_str is None:\n        return None\n    date_str = re.sub('\\\\.[0-9]+', '', date_str)\n    timezone, date_str = extract_timezone(date_str, timezone)\n    with contextlib.suppress(ValueError, TypeError):\n        date_format = f'%Y-%m-%d{delimiter}%H:%M:%S'\n        dt_ = dt.datetime.strptime(date_str, date_format) - timezone\n        return calendar.timegm(dt_.timetuple())"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "limit_length", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef limit_length(s, length): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef limit_length(s, length):\n    \"\"\" Add ellipses to overly long strings \"\"\"\n    if s is None:\n        return None\n    ELLIPSES = '...'\n    if len(s) > length:\n        return s[:length - len(ELLIPSES)] + ELLIPSES\n    return s"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "month_by_name", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nENGLISH_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May',\n    'June', 'July', 'August', 'September', 'October', 'November', 'December']\nMONTH_NAMES = {'en': ENGLISH_MONTH_NAMES, 'fr': ['janvier', 'f\u00e9vrier',\n    'mars', 'avril', 'mai', 'juin', 'juillet', 'ao\u00fbt', 'septembre',\n    'octobre', 'novembre', 'd\u00e9cembre'], 'pl': ['stycznia', 'lutego',\n    'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'wrze\u015bnia',\n    'pa\u017adziernika', 'listopada', 'grudnia']}\n\n\ndef month_by_name(name, lang='en'): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nENGLISH_MONTH_NAMES = ['January', 'February', 'March', 'April', 'May',\n    'June', 'July', 'August', 'September', 'October', 'November', 'December']\nMONTH_NAMES = {'en': ENGLISH_MONTH_NAMES, 'fr': ['janvier', 'f\u00e9vrier',\n    'mars', 'avril', 'mai', 'juin', 'juillet', 'ao\u00fbt', 'septembre',\n    'octobre', 'novembre', 'd\u00e9cembre'], 'pl': ['stycznia', 'lutego',\n    'marca', 'kwietnia', 'maja', 'czerwca', 'lipca', 'sierpnia', 'wrze\u015bnia',\n    'pa\u017adziernika', 'listopada', 'grudnia']}\ndef month_by_name(name, lang='en'):\n    \"\"\" Return the number of a month by (locale-independently) English name \"\"\"\n    month_names = MONTH_NAMES.get(lang, MONTH_NAMES['en'])\n    try:\n        return month_names.index(name) + 1\n    except ValueError:\n        return None"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "lowercase_escape", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef lowercase_escape(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef lowercase_escape(s):\n    unicode_escape = codecs.getdecoder('unicode_escape')\n    return re.sub('\\\\\\\\u[0-9a-fA-F]{4}', lambda m: unicode_escape(m.group(0\n        ))[0], s)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "clean_html", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert isinstance(s, str)\n    return re.sub('&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\n\n\ndef clean_html(html): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef unescapeHTML(s):\n    if s is None:\n        return None\n    assert isinstance(s, str)\n    return re.sub('&([^&;]+;)', lambda m: _htmlentity_transform(m.group(1)), s)\ndef clean_html(html):\n    \"\"\"Clean an HTML snippet into a readable string\"\"\"\n    if html is None:\n        return html\n    html = re.sub('\\\\s+', ' ', html)\n    html = re.sub('(?u)\\\\s?<\\\\s?br\\\\s?/?\\\\s?>\\\\s?', '\\n', html)\n    html = re.sub('(?u)<\\\\s?/\\\\s?p\\\\s?>\\\\s?<\\\\s?p[^>]*>', '\\n', html)\n    html = re.sub('<.*?>', '', html)\n    html = unescapeHTML(html)\n    return html.strip()"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "intlist_to_bytes", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef intlist_to_bytes(xs): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef intlist_to_bytes(xs):\n    if not xs:\n        return b''\n    return struct.pack('%dB' % len(xs), *xs)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_bitrate", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_bitrate(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_bitrate(s):\n    if not isinstance(s, str):\n        return\n    mobj = re.search('\\\\b(\\\\d+)\\\\s*kbps', s)\n    if mobj:\n        return int(mobj.group(1))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_count", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\n\n\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)\n\n\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\n\n\ndef parse_count(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef int_or_none(v, scale=1, default=None, get_attr=None, invscale=1):\n    if get_attr and v is not None:\n        v = getattr(v, get_attr, None)\n    try:\n        return int(v) * invscale // scale\n    except (ValueError, TypeError, OverflowError):\n        return default\ndef str_to_int(int_str):\n    \"\"\" A more relaxed version of int_or_none \"\"\"\n    if isinstance(int_str, int):\n        return int_str\n    elif isinstance(int_str, str):\n        int_str = re.sub('[,\\\\.\\\\+]', '', int_str)\n        return int_or_none(int_str)\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\ndef parse_count(s):\n    if s is None:\n        return None\n    s = re.sub('^[^\\\\d]+\\\\s', '', s).strip()\n    if re.match('^[\\\\d,.]+$', s):\n        return str_to_int(s)\n    _UNIT_TABLE = {'k': 1000, 'K': 1000, 'm': 1000 ** 2, 'M': 1000 ** 2,\n        'kk': 1000 ** 2, 'KK': 1000 ** 2, 'b': 1000 ** 3, 'B': 1000 ** 3}\n    ret = lookup_unit_table(_UNIT_TABLE, s)\n    if ret is not None:\n        return ret\n    mobj = re.match('([\\\\d,.]+)(?:$|\\\\s)', s)\n    if mobj:\n        return str_to_int(mobj.group(1))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_filesize", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\n\n\ndef parse_filesize(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef lookup_unit_table(unit_table, s, strict=False):\n    num_re = NUMBER_RE if strict else NUMBER_RE.replace('\\\\.', '[,.]')\n    units_re = '|'.join(re.escape(u) for u in unit_table)\n    m = (re.fullmatch if strict else re.match)(\n        f'(?P<num>{num_re})\\\\s*(?P<unit>{units_re})\\\\b', s)\n    if not m:\n        return None\n    num = float(m.group('num').replace(',', '.'))\n    mult = unit_table[m.group('unit')]\n    return round(num * mult)\ndef parse_filesize(s):\n    if s is None:\n        return None\n    _UNIT_TABLE = {'B': 1, 'b': 1, 'bytes': 1, 'KiB': 1024, 'KB': 1000,\n        'kB': 1024, 'Kb': 1000, 'kb': 1000, 'kilobytes': 1000, 'kibibytes':\n        1024, 'MiB': 1024 ** 2, 'MB': 1000 ** 2, 'mB': 1024 ** 2, 'Mb':\n        1000 ** 2, 'mb': 1000 ** 2, 'megabytes': 1000 ** 2, 'mebibytes':\n        1024 ** 2, 'GiB': 1024 ** 3, 'GB': 1000 ** 3, 'gB': 1024 ** 3, 'Gb':\n        1000 ** 3, 'gb': 1000 ** 3, 'gigabytes': 1000 ** 3, 'gibibytes':\n        1024 ** 3, 'TiB': 1024 ** 4, 'TB': 1000 ** 4, 'tB': 1024 ** 4, 'Tb':\n        1000 ** 4, 'tb': 1000 ** 4, 'terabytes': 1000 ** 4, 'tebibytes':\n        1024 ** 4, 'PiB': 1024 ** 5, 'PB': 1000 ** 5, 'pB': 1024 ** 5, 'Pb':\n        1000 ** 5, 'pb': 1000 ** 5, 'petabytes': 1000 ** 5, 'pebibytes':\n        1024 ** 5, 'EiB': 1024 ** 6, 'EB': 1000 ** 6, 'eB': 1024 ** 6, 'Eb':\n        1000 ** 6, 'eb': 1000 ** 6, 'exabytes': 1000 ** 6, 'exbibytes':\n        1024 ** 6, 'ZiB': 1024 ** 7, 'ZB': 1000 ** 7, 'zB': 1024 ** 7, 'Zb':\n        1000 ** 7, 'zb': 1000 ** 7, 'zettabytes': 1000 ** 7, 'zebibytes':\n        1024 ** 7, 'YiB': 1024 ** 8, 'YB': 1000 ** 8, 'yB': 1024 ** 8, 'Yb':\n        1000 ** 8, 'yb': 1000 ** 8, 'yottabytes': 1000 ** 8, 'yobibytes':\n        1024 ** 8}\n    return lookup_unit_table(_UNIT_TABLE, s)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_resolution", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef parse_resolution(s, *, lenient=False): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef parse_resolution(s, *, lenient=False):\n    if s is None:\n        return {}\n    if lenient:\n        mobj = re.search('(?P<w>\\\\d+)\\\\s*[xX\u00d7,]\\\\s*(?P<h>\\\\d+)', s)\n    else:\n        mobj = re.search(\n            '(?<![a-zA-Z0-9])(?P<w>\\\\d+)\\\\s*[xX\u00d7,]\\\\s*(?P<h>\\\\d+)(?![a-zA-Z0-9])'\n            , s)\n    if mobj:\n        return {'width': int(mobj.group('w')), 'height': int(mobj.group('h'))}\n    mobj = re.search('(?<![a-zA-Z0-9])(\\\\d+)[pPiI](?![a-zA-Z0-9])', s)\n    if mobj:\n        return {'height': int(mobj.group(1))}\n    mobj = re.search('\\\\b([48])[kK]\\\\b', s)\n    if mobj:\n        return {'height': int(mobj.group(1)) * 540}\n    return {}"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "pkcs1pad", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef pkcs1pad(data, length): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef pkcs1pad(data, length):\n    \"\"\"\n    Padding input data with PKCS#1 scheme\n\n    @param {int[]} data        input data\n    @param {int}   length      target length\n    @returns {int[]}           padded data\n    \"\"\"\n    if len(data) > length - 11:\n        raise ValueError('Input data too long for PKCS#1 padding')\n    pseudo_random = [random.randint(0, 254) for _ in range(length - len(\n        data) - 3)]\n    return [0, 2, *pseudo_random, 0, *data]"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "cli_option", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef cli_option(params, command_option, param, separator=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef cli_option(params, command_option, param, separator=None):\n    param = params.get(param)\n    return [] if param is None else [command_option, str(param)\n        ] if separator is None else [f'{command_option}{separator}{param}']"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "is_html", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\n\n\ndef is_html(first_bytes): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\ndef is_html(first_bytes):\n    \"\"\" Detect whether a file contains HTML by examining its first bytes. \"\"\"\n    encoding = 'utf-8'\n    for bom, enc in BOMS:\n        while first_bytes.startswith(bom):\n            encoding, first_bytes = enc, first_bytes[len(bom):]\n    return re.match('^\\\\s*<', first_bytes.decode(encoding, 'replace'))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "age_restricted", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef age_restricted(content_limit, age_limit): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef age_restricted(content_limit, age_limit):\n    \"\"\" Returns True iff the content should be blocked \"\"\"\n    if age_limit is None:\n        return False\n    if content_limit is None:\n        return False\n    return age_limit < content_limit"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "parse_dfxp_time_expr", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\n\n\ndef parse_dfxp_time_expr(time_expr): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nNUMBER_RE = '\\\\d+(?:\\\\.\\\\d+)?'\ndef parse_dfxp_time_expr(time_expr):\n    if not time_expr:\n        return\n    mobj = re.match(f'^(?P<time_offset>{NUMBER_RE})s?$', time_expr)\n    if mobj:\n        return float(mobj.group('time_offset'))\n    mobj = re.match('^(\\\\d+):(\\\\d\\\\d):(\\\\d\\\\d(?:(?:\\\\.|:)\\\\d+)?)$', time_expr)\n    if mobj:\n        return 3600 * int(mobj.group(1)) + 60 * int(mobj.group(2)) + float(mobj\n            .group(3).replace(':', '.'))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "ohdave_rsa_encrypt", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef ohdave_rsa_encrypt(data, exponent, modulus): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef ohdave_rsa_encrypt(data, exponent, modulus):\n    \"\"\"\n    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/\n\n    Input:\n        data: data to encrypt, bytes-like object\n        exponent, modulus: parameter e and N of RSA algorithm, both integer\n    Output: hex string of encrypted data\n\n    Limitation: supports one block encryption only\n    \"\"\"\n    payload = int(binascii.hexlify(data[::-1]), 16)\n    encrypted = pow(payload, exponent, modulus)\n    return f'{encrypted:x}'"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "encode_base_n", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef _base_n_table(n, table):\n    if not table and not n:\n        raise ValueError('Either table or n must be specified')\n    table = (table or\n        '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')[:n]\n    if n and n != len(table):\n        raise ValueError(f'base {n} exceeds table length {len(table)}')\n    return table\n\n\ndef encode_base_n(num, n=None, table=None): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef _base_n_table(n, table):\n    if not table and not n:\n        raise ValueError('Either table or n must be specified')\n    table = (table or\n        '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')[:n]\n    if n and n != len(table):\n        raise ValueError(f'base {n} exceeds table length {len(table)}')\n    return table\ndef encode_base_n(num, n=None, table=None):\n    \"\"\"Convert given int to a base-n string\"\"\"\n    table = _base_n_table(n, table)\n    if not num:\n        return table[0]\n    result, base = '', len(table)\n    while num:\n        result = table[num % base] + result\n        num = num // base\n    return result"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "caesar", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef caesar(s, alphabet, shift): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "rot47", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)\n\n\ndef rot47(s): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef caesar(s, alphabet, shift):\n    if shift == 0:\n        return s\n    l = len(alphabet)\n    return ''.join(alphabet[(alphabet.index(c) + shift) % l] if c in\n        alphabet else c for c in s)\ndef rot47(s):\n    return caesar(s,\n        '!\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'\n        , 47)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "iri_to_uri", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef iri_to_uri(iri): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef iri_to_uri(iri):\n    \"\"\"\n    Converts an IRI (Internationalized Resource Identifier, allowing Unicode characters) to a URI (Uniform Resource Identifier, ASCII-only).\n\n    The function doesn't add an additional layer of escaping; e.g., it doesn't escape `%3C` as `%253C`. Instead, it percent-escapes characters with an underlying UTF-8 encoding *besides* those already escaped, leaving the URI intact.\n    \"\"\"\n    iri_parts = urllib.parse.urlparse(iri)\n    if '[' in iri_parts.netloc:\n        raise ValueError('IPv6 URIs are not, yet, supported.')\n    net_location = ''\n    if iri_parts.username:\n        net_location += urllib.parse.quote(iri_parts.username, safe=\n            \"!$%&'()*+,~\")\n        if iri_parts.password is not None:\n            net_location += ':' + urllib.parse.quote(iri_parts.password,\n                safe=\"!$%&'()*+,~\")\n        net_location += '@'\n    net_location += iri_parts.hostname.encode('idna').decode()\n    if iri_parts.port is not None and iri_parts.port != 80:\n        net_location += ':' + str(iri_parts.port)\n    return urllib.parse.urlunparse((iri_parts.scheme, net_location, urllib.\n        parse.quote_plus(iri_parts.path, safe=\"!$%&'()*+,/:;=@|~\"), urllib.\n        parse.quote_plus(iri_parts.params, safe=\"!$%&'()*+,/:;=@|~\"),\n        urllib.parse.quote_plus(iri_parts.query, safe=\n        \"!$%&'()*+,/:;=?@{|}~\"), urllib.parse.quote_plus(iri_parts.fragment,\n        safe=\"!#$%&'()*+,/:;=?@{|}~\")))"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "clean_podcast_url", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef clean_podcast_url(url): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef clean_podcast_url(url):\n    url = re.sub(\n        \"\"\"(?x)\n        (?:\n            (?:\n                chtbl\\\\.com/track|\n                media\\\\.blubrry\\\\.com| # https://create.blubrry.com/resources/podcast-media-download-statistics/getting-started/\n                play\\\\.podtrac\\\\.com|\n                chrt\\\\.fm/track|\n                mgln\\\\.ai/e\n            )(?:/[^/.]+)?|\n            (?:dts|www)\\\\.podtrac\\\\.com/(?:pts/)?redirect\\\\.[0-9a-z]{3,4}| # http://analytics.podtrac.com/how-to-measure\n            flex\\\\.acast\\\\.com|\n            pd(?:\n                cn\\\\.co| # https://podcorn.com/analytics-prefix/\n                st\\\\.fm # https://podsights.com/docs/\n            )/e|\n            [0-9]\\\\.gum\\\\.fm|\n            pscrb\\\\.fm/rss/p\n        )/\"\"\"\n        , '', url)\n    return re.sub('^\\\\w+://(\\\\w+://)', '\\\\1', url)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "Config.hide_login_info", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\nclass Config:\n    own_args = None\n    parsed_args = None\n    filename = None\n    __initialized = False\n\n    def __init__(self, parser, label=None):\n        self.parser, self.label = parser, label\n        self._loaded_paths, self.configs = set(), []\n\n    def init(self, args=None, filename=None):\n        assert not self.__initialized\n        self.own_args, self.filename = args, filename\n        return self.load_configs()\n\n    def load_configs(self):\n        directory = ''\n        if self.filename:\n            location = os.path.realpath(self.filename)\n            directory = os.path.dirname(location)\n            if location in self._loaded_paths:\n                return False\n            self._loaded_paths.add(location)\n        self.__initialized = True\n        opts, _ = self.parser.parse_known_args(self.own_args)\n        self.parsed_args = self.own_args\n        for location in (opts.config_locations or []):\n            if location == '-':\n                if location in self._loaded_paths:\n                    continue\n                self._loaded_paths.add(location)\n                self.append_config(shlex.split(read_stdin('options'),\n                    comments=True), label='stdin')\n                continue\n            location = os.path.join(directory, expand_path(location))\n            if os.path.isdir(location):\n                location = os.path.join(location, 'yt-dlp.conf')\n            if not os.path.exists(location):\n                self.parser.error(f'config location {location} does not exist')\n            self.append_config(self.read_file(location), location)\n        return True\n\n    def __str__(self):\n        label = join_nonempty(self.label, 'config', f'\"{self.filename}\"' if\n            self.filename else '', delim=' ')\n        return join_nonempty(self.own_args is not None and\n            f'{label[0].upper()}{label[1:]}: {self.hide_login_info(self.own_args)}'\n            , *(f'\\n{c}'.replace('\\n', '\\n| ')[1:] for c in self.configs),\n            delim='\\n')\n\n    @staticmethod\n    def read_file(filename, default=[]):\n        try:\n            optionf = open(filename, 'rb')\n        except OSError:\n            return default\n        try:\n            enc, skip = determine_file_encoding(optionf.read(512))\n            optionf.seek(skip, io.SEEK_SET)\n        except OSError:\n            enc = None\n        try:\n            contents = optionf.read().decode(enc or preferredencoding())\n            res = shlex.split(contents, comments=True)\n        except Exception as err:\n            raise ValueError(f'Unable to parse \"{filename}\": {err}')\n        finally:\n            optionf.close()\n        return res\n\n    @staticmethod\n    def hide_login_info(opts): [MASK]\n\n    def append_config(self, *args, label=None):\n        config = type(self)(self.parser, label)\n        config._loaded_paths = self._loaded_paths\n        if config.init(*args):\n            self.configs.append(config)\n\n    @property\n    def all_args(self):\n        for config in reversed(self.configs):\n            yield from config.all_args\n        yield from (self.parsed_args or [])\n\n    def parse_known_args(self, **kwargs):\n        return self.parser.parse_known_args(self.all_args, **kwargs)\n\n    def parse_args(self):\n        return self.parser.parse_args(self.all_args)\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nclass Config:\n    own_args = None\n    parsed_args = None\n    filename = None\n    __initialized = False\n\n    def __init__(self, parser, label=None):\n        self.parser, self.label = parser, label\n        self._loaded_paths, self.configs = set(), []\n\n    def init(self, args=None, filename=None):\n        assert not self.__initialized\n        self.own_args, self.filename = args, filename\n        return self.load_configs()\n\n    def load_configs(self):\n        directory = ''\n        if self.filename:\n            location = os.path.realpath(self.filename)\n            directory = os.path.dirname(location)\n            if location in self._loaded_paths:\n                return False\n            self._loaded_paths.add(location)\n        self.__initialized = True\n        opts, _ = self.parser.parse_known_args(self.own_args)\n        self.parsed_args = self.own_args\n        for location in (opts.config_locations or []):\n            if location == '-':\n                if location in self._loaded_paths:\n                    continue\n                self._loaded_paths.add(location)\n                self.append_config(shlex.split(read_stdin('options'),\n                    comments=True), label='stdin')\n                continue\n            location = os.path.join(directory, expand_path(location))\n            if os.path.isdir(location):\n                location = os.path.join(location, 'yt-dlp.conf')\n            if not os.path.exists(location):\n                self.parser.error(f'config location {location} does not exist')\n            self.append_config(self.read_file(location), location)\n        return True\n\n    def __str__(self):\n        label = join_nonempty(self.label, 'config', f'\"{self.filename}\"' if\n            self.filename else '', delim=' ')\n        return join_nonempty(self.own_args is not None and\n            f'{label[0].upper()}{label[1:]}: {self.hide_login_info(self.own_args)}'\n            , *(f'\\n{c}'.replace('\\n', '\\n| ')[1:] for c in self.configs),\n            delim='\\n')\n\n    @staticmethod\n    def read_file(filename, default=[]):\n        try:\n            optionf = open(filename, 'rb')\n        except OSError:\n            return default\n        try:\n            enc, skip = determine_file_encoding(optionf.read(512))\n            optionf.seek(skip, io.SEEK_SET)\n        except OSError:\n            enc = None\n        try:\n            contents = optionf.read().decode(enc or preferredencoding())\n            res = shlex.split(contents, comments=True)\n        except Exception as err:\n            raise ValueError(f'Unable to parse \"{filename}\": {err}')\n        finally:\n            optionf.close()\n        return res\n\n    @staticmethod\n    def hide_login_info(opts):\n        PRIVATE_OPTS = {'-p', '--password', '-u', '--username',\n            '--video-password', '--ap-password', '--ap-username'}\n        eqre = re.compile('^(?P<key>' + '|'.join(re.escape(po) for po in\n            PRIVATE_OPTS) + ')=.+$')\n\n        def _scrub_eq(o):\n            m = eqre.match(o)\n            if m:\n                return m.group('key') + '=PRIVATE'\n            else:\n                return o\n        opts = list(map(_scrub_eq, opts))\n        for idx, opt in enumerate(opts):\n            if opt in PRIVATE_OPTS and idx + 1 < len(opts):\n                opts[idx + 1] = 'PRIVATE'\n        return opts\n\n    def append_config(self, *args, label=None):\n        config = type(self)(self.parser, label)\n        config._loaded_paths = self._loaded_paths\n        if config.init(*args):\n            self.configs.append(config)\n\n    @property\n    def all_args(self):\n        for config in reversed(self.configs):\n            yield from config.all_args\n        yield from (self.parsed_args or [])\n\n    def parse_known_args(self, **kwargs):\n        return self.parser.parse_known_args(self.all_args, **kwargs)\n\n    def parse_args(self):\n        return self.parser.parse_args(self.all_args)"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "extract_basic_auth", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef extract_basic_auth(url): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef extract_basic_auth(url):\n    parts = urllib.parse.urlsplit(url)\n    if parts.username is None:\n        return url, None\n    url = urllib.parse.urlunsplit(parts._replace(netloc=parts.hostname if \n        parts.port is None else f'{parts.hostname}:{parts.port}'))\n    auth_payload = base64.b64encode('{}:{}'.format(parts.username, parts.\n        password or '').encode())\n    return url, f'Basic {auth_payload.decode()}'"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "determine_file_encoding", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\n\n\ndef determine_file_encoding(data): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\nBOMS = [(b'\\xef\\xbb\\xbf', 'utf-8'), (b'\\x00\\x00\\xfe\\xff', 'utf-32-be'), (\n    b'\\xff\\xfe\\x00\\x00', 'utf-32-le'), (b'\\xff\\xfe', 'utf-16-le'), (\n    b'\\xfe\\xff', 'utf-16-be')]\ndef determine_file_encoding(data):\n    \"\"\"\n    Detect the text encoding used\n    @returns (encoding, bytes to skip)\n    \"\"\"\n    for bom, enc in BOMS:\n        if data.startswith(bom):\n            return enc, len(bom)\n    data = data.replace(b'\\x00', b'')\n    mobj = re.match(b'(?m)^#\\\\s*coding\\\\s*:\\\\s*(\\\\S+)\\\\s*$', data)\n    return mobj.group(1).decode() if mobj else None, 0"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "_get_linux_desktop_environment", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/cookies.py", "method_code_mask": "import base64\nimport collections\nimport contextlib\nimport datetime as dt\nimport functools\nimport glob\nimport hashlib\nimport http.cookiejar\nimport http.cookies\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport urllib.request\nfrom enum import Enum\nfrom enum import auto\nimport ctypes\nimport ctypes.wintypes\n\n\nclass _LinuxDesktopEnvironment(Enum):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.h\n    DesktopEnvironment\n    \"\"\"\n    OTHER = auto()\n    CINNAMON = auto()\n    DEEPIN = auto()\n    GNOME = auto()\n    KDE3 = auto()\n    KDE4 = auto()\n    KDE5 = auto()\n    KDE6 = auto()\n    PANTHEON = auto()\n    UKUI = auto()\n    UNITY = auto()\n    XFCE = auto()\n    LXQT = auto()\n\n\ndef _get_linux_desktop_environment(env, logger): [MASK]\n", "response": "import base64\nimport collections\nimport contextlib\nimport datetime as dt\nimport functools\nimport glob\nimport hashlib\nimport http.cookiejar\nimport http.cookies\nimport io\nimport json\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport urllib.request\nfrom enum import Enum\nfrom enum import auto\nimport ctypes\nimport ctypes.wintypes\nclass _LinuxDesktopEnvironment(Enum):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.h\n    DesktopEnvironment\n    \"\"\"\n    OTHER = auto()\n    CINNAMON = auto()\n    DEEPIN = auto()\n    GNOME = auto()\n    KDE3 = auto()\n    KDE4 = auto()\n    KDE5 = auto()\n    KDE6 = auto()\n    PANTHEON = auto()\n    UKUI = auto()\n    UNITY = auto()\n    XFCE = auto()\n    LXQT = auto()\ndef _get_linux_desktop_environment(env, logger):\n    \"\"\"\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.cc\n    GetDesktopEnvironment\n    \"\"\"\n    xdg_current_desktop = env.get('XDG_CURRENT_DESKTOP', None)\n    desktop_session = env.get('DESKTOP_SESSION', None)\n    if xdg_current_desktop is not None:\n        for part in map(str.strip, xdg_current_desktop.split(':')):\n            if part == 'Unity':\n                if (desktop_session is not None and 'gnome-fallback' in\n                    desktop_session):\n                    return _LinuxDesktopEnvironment.GNOME\n                else:\n                    return _LinuxDesktopEnvironment.UNITY\n            elif part == 'Deepin':\n                return _LinuxDesktopEnvironment.DEEPIN\n            elif part == 'GNOME':\n                return _LinuxDesktopEnvironment.GNOME\n            elif part == 'X-Cinnamon':\n                return _LinuxDesktopEnvironment.CINNAMON\n            elif part == 'KDE':\n                kde_version = env.get('KDE_SESSION_VERSION', None)\n                if kde_version == '5':\n                    return _LinuxDesktopEnvironment.KDE5\n                elif kde_version == '6':\n                    return _LinuxDesktopEnvironment.KDE6\n                elif kde_version == '4':\n                    return _LinuxDesktopEnvironment.KDE4\n                else:\n                    logger.info(\n                        f'unknown KDE version: \"{kde_version}\". Assuming KDE4')\n                    return _LinuxDesktopEnvironment.KDE4\n            elif part == 'Pantheon':\n                return _LinuxDesktopEnvironment.PANTHEON\n            elif part == 'XFCE':\n                return _LinuxDesktopEnvironment.XFCE\n            elif part == 'UKUI':\n                return _LinuxDesktopEnvironment.UKUI\n            elif part == 'LXQt':\n                return _LinuxDesktopEnvironment.LXQT\n        logger.info(\n            f'XDG_CURRENT_DESKTOP is set to an unknown value: \"{xdg_current_desktop}\"'\n            )\n    elif desktop_session is not None:\n        if desktop_session == 'deepin':\n            return _LinuxDesktopEnvironment.DEEPIN\n        elif desktop_session in ('mate', 'gnome'):\n            return _LinuxDesktopEnvironment.GNOME\n        elif desktop_session in ('kde4', 'kde-plasma'):\n            return _LinuxDesktopEnvironment.KDE4\n        elif desktop_session == 'kde':\n            if 'KDE_SESSION_VERSION' in env:\n                return _LinuxDesktopEnvironment.KDE4\n            else:\n                return _LinuxDesktopEnvironment.KDE3\n        elif 'xfce' in desktop_session or desktop_session == 'xubuntu':\n            return _LinuxDesktopEnvironment.XFCE\n        elif desktop_session == 'ukui':\n            return _LinuxDesktopEnvironment.UKUI\n        else:\n            logger.info(\n                f'DESKTOP_SESSION is set to an unknown value: \"{desktop_session}\"'\n                )\n    elif 'GNOME_DESKTOP_SESSION_ID' in env:\n        return _LinuxDesktopEnvironment.GNOME\n    elif 'KDE_FULL_SESSION' in env:\n        if 'KDE_SESSION_VERSION' in env:\n            return _LinuxDesktopEnvironment.KDE4\n        else:\n            return _LinuxDesktopEnvironment.KDE3\n    return _LinuxDesktopEnvironment.OTHER"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "pad_block", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/aes.py", "method_code_mask": "import base64\nfrom math import ceil\nBLOCK_SIZE_BYTES = 16\n\n\ndef pad_block(block, padding_mode): [MASK]\n", "response": "import base64\nfrom math import ceil\nBLOCK_SIZE_BYTES = 16\ndef pad_block(block, padding_mode):\n    \"\"\"\n    Pad a block with the given padding mode\n    @param {int[]} block        block to pad\n    @param padding_mode         padding mode\n    \"\"\"\n    padding_size = BLOCK_SIZE_BYTES - len(block)\n    PADDING_BYTE = {'pkcs7': padding_size, 'iso7816': 0, 'whitespace': 32,\n        'zero': 0}\n    if padding_size < 0:\n        raise ValueError('Block size exceeded')\n    elif padding_mode not in PADDING_BYTE:\n        raise NotImplementedError(\n            f'Padding mode {padding_mode} is not implemented')\n    if padding_mode == 'iso7816' and padding_size:\n        block = [*block, 128]\n        padding_size -= 1\n    return block + [PADDING_BYTE[padding_mode]] * padding_size"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "try_call", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef try_call(*funcs, expected_type=None, args=[], kwargs={}): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef try_call(*funcs, expected_type=None, args=[], kwargs={}):\n    for f in funcs:\n        try:\n            val = f(*args, **kwargs)\n        except (AttributeError, KeyError, TypeError, IndexError, ValueError,\n            ZeroDivisionError):\n            pass\n        else:\n            if expected_type is None or isinstance(val, expected_type):\n                return val"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "_make_result", "method_path": "../srcdata/Network/yt-dlp/test/test_YoutubeDL.py", "method_code_mask": "import os\nimport sys\nimport unittest\nfrom unittest.mock import patch\nimport contextlib\nimport copy\nimport json\nfrom http.cookiejar import Cookie\n\n\ndef _make_result(formats, **kwargs): [MASK]\n", "response": "import os\nimport sys\nimport unittest\nfrom unittest.mock import patch\nimport contextlib\nimport copy\nimport json\nfrom http.cookiejar import Cookie\ndef _make_result(formats, **kwargs):\n    res = {'formats': formats, 'id': 'testid', 'title': 'testttitle',\n        'extractor': 'testex', 'extractor_key': 'TestEx', 'webpage_url':\n        'http://example.com/watch?v=shenanigans'}\n    res.update(**kwargs)\n    return res"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "expect_warnings", "method_path": "../srcdata/Network/yt-dlp/test/helper.py", "method_code_mask": "import errno\nimport hashlib\nimport json\nimport os.path\nimport re\nimport ssl\nimport sys\nimport types\nimport pytest\n\n\ndef expect_warnings(ydl, warnings_re): [MASK]\n", "response": "import errno\nimport hashlib\nimport json\nimport os.path\nimport re\nimport ssl\nimport sys\nimport types\nimport pytest\ndef expect_warnings(ydl, warnings_re):\n    real_warning = ydl.report_warning\n\n    def _report_warning(w, *args, **kwargs):\n        if not any(re.search(w_re, w) for w_re in warnings_re):\n            real_warning(w, *args, **kwargs)\n    ydl.report_warning = _report_warning"}
{"result": "passed", "model_name": "std", "repository": "yt-dlp", "full_method_name": "js_to_json", "method_path": "../srcdata/Network/yt-dlp/yt_dlp/utils/_utils.py", "method_code_mask": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\n\n\ndef js_to_json(code, vars={}, *, strict=False): [MASK]\n", "response": "import base64\nimport binascii\nimport calendar\nimport codecs\nimport collections\nimport collections.abc\nimport contextlib\nimport datetime as dt\nimport email.header\nimport email.utils\nimport errno\nimport hashlib\nimport hmac\nimport html.entities\nimport html.parser\nimport inspect\nimport io\nimport itertools\nimport json\nimport locale\nimport math\nimport mimetypes\nimport netrc\nimport operator\nimport os\nimport platform\nimport random\nimport re\nimport shlex\nimport socket\nimport ssl\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport traceback\nimport types\nimport unicodedata\nimport urllib.error\nimport urllib.parse\nimport urllib.request\nimport xml.etree.ElementTree\nimport warnings\nimport ctypes\nimport ctypes.wintypes\nimport fcntl\ndef js_to_json(code, vars={}, *, strict=False):\n    STRING_QUOTES = '\\'\"`'\n    STRING_RE = '|'.join(f'{q}(?:\\\\\\\\.|[^\\\\\\\\{q}])*{q}' for q in STRING_QUOTES)\n    COMMENT_RE = '/\\\\*(?:(?!\\\\*/).)*?\\\\*/|//[^\\\\n]*\\\\n'\n    SKIP_RE = f'\\\\s*(?:{COMMENT_RE})?\\\\s*'\n    INTEGER_TABLE = (f'(?s)^(0[xX][0-9a-fA-F]+){SKIP_RE}:?$', 16), (\n        f'(?s)^(0+[0-7]+){SKIP_RE}:?$', 8)\n\n    def process_escape(match):\n        JSON_PASSTHROUGH_ESCAPES = '\"\\\\bfnrtu'\n        escape = match.group(1) or match.group(2)\n        return (f'\\\\{escape}' if escape in JSON_PASSTHROUGH_ESCAPES else \n            '\\\\u00' if escape == 'x' else '' if escape == '\\n' else escape)\n\n    def template_substitute(match):\n        evaluated = js_to_json(match.group(1), vars, strict=strict)\n        if evaluated[0] == '\"':\n            return json.loads(evaluated)\n        return evaluated\n\n    def fix_kv(m):\n        v = m.group(0)\n        if v in ('true', 'false', 'null'):\n            return v\n        elif v in ('undefined', 'void 0'):\n            return 'null'\n        elif v.startswith(('/*', '//', '!')) or v == ',':\n            return ''\n        if v[0] in STRING_QUOTES:\n            v = re.sub('(?s)\\\\${([^}]+)}', template_substitute, v[1:-1]) if v[0\n                ] == '`' else v[1:-1]\n            escaped = re.sub('(?s)(\")|\\\\\\\\(.)', process_escape, v)\n            return f'\"{escaped}\"'\n        for regex, base in INTEGER_TABLE:\n            im = re.match(regex, v)\n            if im:\n                i = int(im.group(1), base)\n                return f'\"{i}\":' if v.endswith(':') else str(i)\n        if v in vars:\n            try:\n                if not strict:\n                    json.loads(vars[v])\n            except json.JSONDecodeError:\n                return json.dumps(vars[v])\n            else:\n                return vars[v]\n        if not strict:\n            return f'\"{v}\"'\n        raise ValueError(f'Unknown value: {v}')\n\n    def create_map(mobj):\n        return json.dumps(dict(json.loads(js_to_json(mobj.group(1) or '[]',\n            vars=vars))))\n    code = re.sub('(?:new\\\\s+)?Array\\\\((.*?)\\\\)', '[\\\\g<1>]', code)\n    code = re.sub('new Map\\\\((\\\\[.*?\\\\])?\\\\)', create_map, code)\n    if not strict:\n        code = re.sub(f'new Date\\\\(({STRING_RE})\\\\)', '\\\\g<1>', code)\n        code = re.sub('new \\\\w+\\\\((.*?)\\\\)', lambda m: json.dumps(m.group(0\n            )), code)\n        code = re.sub('parseInt\\\\([^\\\\d]+(\\\\d+)[^\\\\d]+\\\\)', '\\\\1', code)\n        code = re.sub(\n            '\\\\(function\\\\([^)]*\\\\)\\\\s*\\\\{[^}]*\\\\}\\\\s*\\\\)\\\\s*\\\\(\\\\s*([\"\\\\\\'][^)]*[\"\\\\\\'])\\\\s*\\\\)'\n            , '\\\\1', code)\n    return re.sub(\n        f\"\"\"(?sx)\n        {STRING_RE}|\n        {COMMENT_RE}|,(?={SKIP_RE}[\\\\]}}])|\n        void\\\\s0|(?:(?<![0-9])[eE]|[a-df-zA-DF-Z_$])[.a-zA-Z_$0-9]*|\n        \\\\b(?:0[xX][0-9a-fA-F]+|0+[0-7]+)(?:{SKIP_RE}:)?|\n        [0-9]+(?={SKIP_RE}:)|\n        !+\n        \"\"\"\n        , fix_kv, code)"}
