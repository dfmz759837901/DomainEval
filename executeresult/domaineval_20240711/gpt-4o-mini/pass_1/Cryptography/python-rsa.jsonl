{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/pem.py", "method_code_mask": "import base64\nimport typing\nFlexiText = typing.Union[str, bytes]\n\n\ndef _markers(pem_marker: FlexiText) ->typing.Tuple[bytes, bytes]: [MASK]\n", "response": "import base64\nimport typing\nFlexiText = typing.Union[str, bytes]\n\n\ndef _markers(pem_marker: FlexiText) -> typing.Tuple[bytes, bytes]:\n    if isinstance(pem_marker, str):\n        pem_marker = pem_marker.encode('ascii')\n    \n    start_marker = b'-----BEGIN ' + pem_marker + b'-----\\n'\n    end_marker = b'-----END ' + pem_marker + b'-----\\n'\n    \n    return start_marker, end_marker"}
{"result": "failed: Invalid hash function: SHA-1", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "mgf1", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/pkcs1_v2.py", "method_code_mask": "from rsa import common\nfrom rsa import pkcs1\nfrom rsa import transform\nimport doctest\n\n\ndef mgf1(seed: bytes, length: int, hasher: str='SHA-1') ->bytes: [MASK]\n", "response": "from rsa import common\nfrom rsa import pkcs1\nfrom rsa import transform\nimport doctest\nimport hashlib\n\ndef mgf1(seed: bytes, length: int, hasher: str='SHA-1') -> bytes:\n    # Determine the hash function\n    if hasher not in hashlib.algorithms_available:\n        raise ValueError(f\"Invalid hash function: {hasher}\")\n    \n    hash_func = hashlib.new(hasher)\n    hash_len = hash_func.digest_size\n    \n    # Check if the length is too large\n    if length > (2**32) * hash_len:\n        raise OverflowError(\"Length is too large for the specified hash function.\")\n    \n    # Generate the mask\n    mask = b''\n    counter = 0\n    \n    while len(mask) < length:\n        # Create a new hash input\n        hash_func = hashlib.new(hasher)\n        hash_func.update(seed)\n        hash_func.update(counter.to_bytes(4, byteorder='big'))\n        mask += hash_func.digest()\n        counter += 1\n    \n    return mask[:length]"}
{"result": "failed: e (136407) and phi_n (3267400632) are not relatively prime (divider=3)", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "gen_keys", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/key.py", "method_code_mask": "import abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\nfrom pyasn1.codec.der import decoder\nfrom rsa.asn1 import AsnPubKey\nfrom pyasn1.codec.der import encoder\nfrom rsa.asn1 import OpenSSLPubKey\nfrom pyasn1.type import univ\nfrom pyasn1.type import namedtype\nfrom rsa import parallel\nimport doctest\n\n\ndef calculate_keys_custom_exponent(p: int, q: int, exponent: int, rs:\n    typing.Optional[typing.List[int]]=None) ->typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n    phi_n = math.prod([(x - 1) for x in [p, q] + ([] if rs is None else rs)])\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(exponent, phi_n, ex.d, msg=\n            'e (%d) and phi_n (%d) are not relatively prime (divider=%i)' %\n            (exponent, phi_n, ex.d)) from ex\n    if exponent * d % phi_n != 1:\n        raise ValueError(\n            'e (%d) and d (%d) are not mult. inv. modulo phi_n (%d)' % (\n            exponent, d, phi_n))\n    return exponent, d\n\n\ndef find_p_q(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True) ->typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n        *Introduced in Python-RSA 3.1*\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n    When not in accurate mode, the number of bits can be slightly less\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n    \"\"\"\n    total_bits = nbits * 2\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n\n    def is_acceptable(p: int, q: int) ->bool:\n        \"\"\"Returns True iff p and q are acceptable:\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n        if p == q:\n            return False\n        if not accurate:\n            return True\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n    change_p = False\n    while not is_acceptable(p, q):\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n        change_p = not change_p\n    return max(p, q), min(p, q)\n\n\ndef find_primes(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True, nprimes: int=2) ->typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1] * rem + [quo] * (nprimes - rem)\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n    return list(reversed(sorted(primes)))\n\n\nDEFAULT_EXPONENT = 65537\n\n\ndef gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],\n    accurate: bool=True, exponent: int=DEFAULT_EXPONENT, nprimes: int=2\n    ) ->typing.Tuple: [MASK]\n", "response": "import abc\nimport math\nimport threading\nimport typing\nimport warnings\nimport itertools\nimport rsa.prime\nimport rsa.pem\nimport rsa.common\nimport rsa.randnum\nimport rsa.core\nfrom pyasn1.codec.der import decoder\nfrom rsa.asn1 import AsnPubKey\nfrom pyasn1.codec.der import encoder\nfrom rsa.asn1 import OpenSSLPubKey\nfrom pyasn1.type import univ\nfrom pyasn1.type import namedtype\nfrom rsa import parallel\nimport doctest\n\n\ndef calculate_keys_custom_exponent(p: int, q: int, exponent: int, rs:\n    typing.Optional[typing.List[int]]=None) ->typing.Tuple[int, int]:\n    \"\"\"Calculates an encryption and a decryption key given p, q and an exponent,\n    and returns them as a tuple (e, d)\n\n    :param p: the first large prime\n    :param q: the second large prime\n    :param exponent: the exponent for the key; only change this if you know\n        what you're doing, as the exponent influences how difficult your\n        private key can be cracked. A very common choice for e is 65537.\n    :type exponent: int\n    :param rs: the list of other large primes\n\n    \"\"\"\n    phi_n = math.prod([(x - 1) for x in [p, q] + ([] if rs is None else rs)])\n    try:\n        d = rsa.common.inverse(exponent, phi_n)\n    except rsa.common.NotRelativePrimeError as ex:\n        raise rsa.common.NotRelativePrimeError(exponent, phi_n, ex.d, msg=\n            'e (%d) and phi_n (%d) are not relatively prime (divider=%i)' %\n            (exponent, phi_n, ex.d)) from ex\n    if exponent * d % phi_n != 1:\n        raise ValueError(\n            'e (%d) and d (%d) are not mult. inv. modulo phi_n (%d)' % (\n            exponent, d, phi_n))\n    return exponent, d\n\n\ndef find_p_q(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True) ->typing.Tuple[int, int]:\n    \"\"\"Returns a tuple of two different primes of nbits bits each.\n    The resulting p * q has exactly 2 * nbits bits, and the returned p and q\n    will not be equal.\n    :param nbits: the number of bits in each of p and q.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n        *Introduced in Python-RSA 3.1*\n    :param accurate: whether to enable accurate mode or not.\n    :returns: (p, q), where p > q\n    >>> (p, q) = find_p_q(128)\n    >>> from rsa import common\n    >>> common.bit_size(p * q)\n    256\n    When not in accurate mode, the number of bits can be slightly less\n    >>> (p, q) = find_p_q(128, accurate=False)\n    >>> from rsa import common\n    >>> common.bit_size(p * q) <= 256\n    True\n    >>> common.bit_size(p * q) > 240\n    True\n    \"\"\"\n    total_bits = nbits * 2\n    shift = nbits // 16\n    pbits = nbits + shift\n    qbits = nbits - shift\n    p = getprime_func(pbits)\n    q = getprime_func(qbits)\n\n    def is_acceptable(p: int, q: int) ->bool:\n        \"\"\"Returns True iff p and q are acceptable:\n        - p and q differ\n        - (p * q) has the right nr of bits (when accurate=True)\n        \"\"\"\n        if p == q:\n            return False\n        if not accurate:\n            return True\n        found_size = rsa.common.bit_size(p * q)\n        return total_bits == found_size\n    change_p = False\n    while not is_acceptable(p, q):\n        if change_p:\n            p = getprime_func(pbits)\n        else:\n            q = getprime_func(qbits)\n        change_p = not change_p\n    return max(p, q), min(p, q)\n\n\ndef find_primes(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.\n    prime.getprime, accurate: bool=True, nprimes: int=2) ->typing.List[int]:\n    \"\"\"Returns a list of different primes with nbits divided evenly among them.\n    :param nbits: the number of bits for the primes to sum to.\n    :param getprime_func: the getprime function, defaults to\n        :py:func:`rsa.prime.getprime`.\n    :param accurate: whether to enable accurate mode or not.\n    :returns: list of primes in descending order.\n    \"\"\"\n    if nprimes == 2:\n        return list(find_p_q(nbits // 2, getprime_func, accurate))\n    quo, rem = divmod(nbits, nprimes)\n    factor_lengths = [quo + 1] * rem + [quo] * (nprimes - rem)\n    while True:\n        primes = [getprime_func(length) for length in factor_lengths]\n        if len(set(primes)) == len(primes):\n            break\n    return list(reversed(sorted(primes)))\n\n\nDEFAULT_EXPONENT = 65537\n\n\ndef gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],\n    accurate: bool=True, exponent: int=DEFAULT_EXPONENT, nprimes: int=2\n    ) ->typing.Tuple:\n    \"\"\"Generates RSA keys of nbits bits. Returns (p, q, e, d) or (p, q, e, d, rs)\n    depending on the number of prime factors specified.\n\n    :param nbits: int - the total number of bits in \"p\" and \"q\".\n    :param getprime_func: Callable[[int], int] - a function to generate prime numbers with a specified number of bits.\n    :param accurate: bool=True - whether to enable accurate mode or not.\n    :param exponent: int=65537 - the exponent value for the key.\n    :param nprimes: int=2 - the number of prime factors comprising the modulus.\n    :returns: Tuple containing the prime numbers \"p\" and \"q\", the encryption key \"e\", and the decryption key \"d\".\n    \"\"\"\n    primes = find_primes(nbits, getprime_func, accurate, nprimes)\n    p, q = primes[0], primes[1]\n    rs = primes[2:] if nprimes > 2 else None\n    e, d = calculate_keys_custom_exponent(p, q, exponent, rs)\n    \n    if rs is not None:\n        return (p, q, e, d) + tuple(rs)\n    return (p, q, e, d)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "inverse", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef inverse(x: int, n: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\nfrom math import gcd\n\nclass NotRelativePrimeError(Exception):\n    pass\n\ndef inverse(x: int, n: int) -> int:\n    if gcd(x, n) != 1:\n        raise NotRelativePrimeError(\"x and n are not relatively prime; inverse does not exist.\")\n    \n    # Extended Euclidean Algorithm to find the multiplicative inverse\n    def extended_gcd(a: int, b: int):\n        if a == 0:\n            return b, 0, 1\n        gcd_val, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd_val, x, y\n\n    _, inv, _ = extended_gcd(x, n)\n    return inv % n"}
{"result": "failed: list index out of range", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "cli_args", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef cli_args(*new_argv): [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef cli_args(*new_argv):\n    original_argv = sys.argv[:]  # Save the original sys.argv\n    sys.argv = list(map(str, new_argv))  # Set sys.argv to the new arguments\n    try:\n        yield  # Allow the code within the context to run\n    finally:\n        sys.argv = original_argv  # Restore the original sys.argv"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "byte_size", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef byte_size(number: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\n\ndef ceil_div(a: int, b: int) -> int:\n    return -(-a // b)  # This is a way to perform ceiling division\n\ndef byte_size(number: int) -> int:\n    if number == 0:\n        return 1  # Zero requires 1 byte\n    bit_size = number.bit_length()  # Get the number of bits required to represent the number\n    return ceil_div(bit_size, 8)  # Divide by 8 and round up\n\n# Example test cases\nif __name__ == \"__main__\":\n    doctest.testmod()"}
{"result": "failed: '_io.StringIO' object has no attribute 'buffer'", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "captured_output", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef captured_output() ->typing.Generator: [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\n@contextmanager\ndef captured_output() -> typing.Generator:\n    new_out = io.StringIO()\n    new_err = io.StringIO()\n    with redirect_stdout(new_out), redirect_stderr(new_err):\n        yield new_out, new_err"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "cleanup_files", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/tests/test_cli.py", "method_code_mask": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\ndef remove_if_exists(fname):\n    \"\"\"Removes a file if it exists.\"\"\"\n    if os.path.exists(fname):\n        os.unlink(fname)\n\n\ndef cleanup_files(*filenames): [MASK]\n", "response": "import functools\nimport io\nimport os\nimport sys\nimport typing\nimport unittest\nfrom contextlib import contextmanager\nfrom contextlib import redirect_stdout\nfrom contextlib import redirect_stderr\nimport rsa\nimport rsa.cli\nimport rsa.util\n\n\ndef remove_if_exists(fname):\n    \"\"\"Removes a file if it exists.\"\"\"\n    if os.path.exists(fname):\n        os.unlink(fname)\n\n\ndef cleanup_files(*filenames):\n    \"\"\"Decorator to clean up specified files before and after a test function.\"\"\"\n    def decorator(test_func):\n        @functools.wraps(test_func)\n        def wrapper(*args, **kwargs):\n            # Remove files before the test function runs\n            for fname in filenames:\n                remove_if_exists(fname)\n            try:\n                # Run the test function\n                return test_func(*args, **kwargs)\n            finally:\n                # Remove files after the test function runs\n                for fname in filenames:\n                    remove_if_exists(fname)\n        return wrapper\n    return decorator"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "int2bytes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/transform.py", "method_code_mask": "import math\nimport doctest\n\n\ndef int2bytes(number: int, fill_size: int=0) ->bytes: [MASK]\n", "response": "import math\nimport doctest\n\n\ndef int2bytes(number: int, fill_size: int=0) -> bytes:\n    if number < 0:\n        raise ValueError(\"Number must be a non-negative integer.\")\n    \n    # Convert the integer to bytes in big-endian format\n    byte_array = number.to_bytes((number.bit_length() + 7) // 8 or 1, byteorder='big')\n    \n    # Check if fill_size is specified and handle padding\n    if fill_size > 0:\n        if fill_size < len(byte_array):\n            raise OverflowError(\"The number requires more bytes than fill_size allows.\")\n        byte_array = byte_array.rjust(fill_size, b'\\x00')\n    \n    return byte_array"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "bit_size", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/common.py", "method_code_mask": "import typing\nimport doctest\n\n\ndef bit_size(num: int) ->int: [MASK]\n", "response": "import typing\nimport doctest\n\n\ndef bit_size(num: int) -> int:\n    if num == 0:\n        return 0\n    return num.bit_length()"}
{"result": "failed: negative shift count", "model_name": "gpt-4o-mini", "repository": "python-rsa", "full_method_name": "is_prime", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-rsa/rsa/prime.py", "method_code_mask": "import rsa.common\nimport rsa.randnum\nimport doctest\n\n\ndef miller_rabin_primality_testing(n: int, k: int) ->bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n    if n < 2:\n        return False\n    d = n - 1\n    r = 0\n    while not d & 1:\n        r += 1\n        d >>= 1\n    for _ in range(k):\n        a = rsa.randnum.randint(n - 3) + 1\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n\ndef get_primality_testing_rounds(number: int) ->int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n    bitsize = rsa.common.bit_size(number)\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    return 10\n\n\ndef is_prime(number: int) ->bool: [MASK]\n", "response": "import rsa.common\nimport rsa.randnum\nimport doctest\n\n\ndef miller_rabin_primality_testing(n: int, k: int) -> bool:\n    \"\"\"Calculates whether n is composite (which is always correct) or prime\n    (which theoretically is incorrect with error probability 4**-k), by\n    applying Miller-Rabin primality testing.\n\n    For reference and implementation example, see:\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n\n    :param n: Integer to be tested for primality.\n    :type n: int\n    :param k: Number of rounds (witnesses) of Miller-Rabin testing.\n    :type k: int\n    :return: False if the number is composite, True if it's probably prime.\n    :rtype: bool\n    \"\"\"\n    if n < 2:\n        return False\n    d = n - 1\n    r = 0\n    while not d & 1:\n        r += 1\n        d >>= 1\n    for _ in range(k):\n        a = rsa.randnum.randint(n - 3) + 1\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = pow(x, 2, n)\n            if x == 1:\n                return False\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n\ndef get_primality_testing_rounds(number: int) -> int:\n    \"\"\"Returns minimum number of rounds for Miller-Rabing primality testing,\n    based on number bitsize.\n    According to NIST FIPS 186-4, Appendix C, Table C.3, minimum number of\n    rounds of M-R testing, using an error probability of 2 ** (-100), for\n    different p, q bitsizes are:\n      * p, q bitsize: 512; rounds: 7\n      * p, q bitsize: 1024; rounds: 4\n      * p, q bitsize: 1536; rounds: 3\n    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n    \"\"\"\n    bitsize = rsa.common.bit_size(number)\n    if bitsize >= 1536:\n        return 3\n    if bitsize >= 1024:\n        return 4\n    if bitsize >= 512:\n        return 7\n    return 10\n\n\ndef is_prime(number: int) -> bool:\n    \"\"\"Determines whether a given integer is prime or composite.\n\n    :param number: An integer to test for primality.\n    :type number: int\n    :return: True if the number is prime, False if it is composite.\n    :rtype: bool\n    \"\"\"\n    if number < 2:\n        return False\n    rounds = get_primality_testing_rounds(number)\n    return miller_rabin_primality_testing(number, rounds)"}
