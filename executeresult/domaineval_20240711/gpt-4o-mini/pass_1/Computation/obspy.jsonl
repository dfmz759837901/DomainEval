{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "resample_preview", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/preview.py", "method_code_mask": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef resample_preview(trace, samples, method='accurate'): [MASK]\n", "response": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef resample_preview(trace, samples, method='accurate'):\n    original_samples = len(trace.data)\n    \n    if method == 'fast':\n        # Calculate the downsampling factor\n        factor = original_samples // samples\n        # Downsample the data\n        trace.data = trace.data[::factor]\n        # Update the number of samples in the Trace object\n        trace.stats.npts = len(trace.data)\n        # Return the number of samples omitted\n        return original_samples - trace.stats.npts\n    \n    elif method == 'accurate':\n        # Create a new time array for the resampled data\n        new_times = np.linspace(trace.stats.starttime.timestamp, trace.stats.endtime.timestamp, samples)\n        # Interpolate the data to the new time array\n        new_data = np.interp(new_times, \n                              np.arange(original_samples), \n                              trace.data)\n        # Update the Trace object with the new data and statistics\n        trace.data = new_data\n        trace.stats.npts = samples\n        trace.stats.sampling_rate = samples / (trace.stats.endtime - trace.stats.starttime).seconds\n        # Return the number of samples recalculated\n        return samples\n    \n    else:\n        raise ValueError(\"Method must be either 'fast' or 'accurate'.\")"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "map_example_filename", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/decorator.py", "method_code_mask": "import functools\nimport inspect\nfrom pathlib import Path\nimport re\nimport socket\nimport tarfile\nimport warnings\nimport zipfile\nimport numpy as np\nfrom decorator import decorator\nfrom obspy.core.util import get_example_file\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nimport pytest\nimport bz2\nimport gzip\nimport doctest\n\n\ndef map_example_filename(arg_kwarg_name): [MASK]\n", "response": "import functools\nimport inspect\nfrom pathlib import Path\nimport re\nimport socket\nimport tarfile\nimport warnings\nimport zipfile\nimport numpy as np\nfrom decorator import decorator\nfrom obspy.core.util import get_example_file\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nimport pytest\nimport bz2\nimport gzip\nimport doctest\n\n\ndef map_example_filename(arg_kwarg_name):\n    def _map_example_filename(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Determine the argument index or keyword argument\n            if arg_kwarg_name in kwargs:\n                # Modify the keyword argument\n                original_value = kwargs[arg_kwarg_name]\n                modified_value = re.sub(r'/path/to/filename', get_example_file(r'/path/to/filename'), original_value)\n                kwargs[arg_kwarg_name] = modified_value\n            else:\n                # Check positional arguments\n                sig = inspect.signature(func)\n                params = list(sig.parameters.keys())\n                if arg_kwarg_name in params:\n                    index = params.index(arg_kwarg_name)\n                    if index < len(args):\n                        original_value = args[index]\n                        modified_value = re.sub(r'/path/to/filename', get_example_file(r'/path/to/filename'), original_value)\n                        args = list(args)\n                        args[index] = modified_value\n            \n            return func(*args, **kwargs)\n        return wrapper\n    return _map_example_filename"}
{"result": "failed: 'str' object has no attribute 'module_name'", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_get_default_eps", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/tests/test_waveform_plugins.py", "method_code_mask": "import io\nimport os\nimport threading\nimport time\nimport warnings\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom unittest import mock\nimport numpy as np\nimport pytest\nfrom obspy import Trace\nfrom obspy import read\nfrom obspy.io.mseed.core import _write_mseed\nfrom obspy.core.utcdatetime import UTCDateTime\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.core.util.base import _get_entry_points\nfrom obspy.core.util.base import DEFAULT_MODULES\nfrom obspy.core.util.base import WAVEFORM_ACCEPT_BYTEORDER\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.util.misc import _ENTRY_POINT_CACHE\n\n\ndef _get_default_eps(group, subgroup=None): [MASK]\n", "response": "import io\nimport os\nimport threading\nimport time\nimport warnings\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom unittest import mock\nimport numpy as np\nimport pytest\nfrom obspy import Trace\nfrom obspy import read\nfrom obspy.io.mseed.core import _write_mseed\nfrom obspy.core.utcdatetime import UTCDateTime\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.core.util.base import _get_entry_points\nfrom obspy.core.util.base import DEFAULT_MODULES\nfrom obspy.core.util.base import WAVEFORM_ACCEPT_BYTEORDER\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.util.misc import _ENTRY_POINT_CACHE\n\n\ndef _get_default_eps(group, subgroup=None):\n    eps = {}\n    entry_points = _get_entry_points(group, subgroup)\n    \n    for ep in entry_points:\n        if ep.module_name in DEFAULT_MODULES:\n            eps[ep] = ep.load()\n    \n    return eps"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "get_dependency_version", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/base.py", "method_code_mask": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef get_dependency_version(package_name, raw_string=False): [MASK]\n", "response": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef get_dependency_version(package_name, raw_string=False):\n    try:\n        package = importlib.import_module(package_name)\n        version = package.__version__\n    except ImportError:\n        return None if raw_string else []\n\n    if raw_string:\n        return version\n\n    version_parts = version.split('.')\n    version_numbers = []\n\n    for part in version_parts:\n        try:\n            version_numbers.append(int(part))\n        except ValueError:\n            version_numbers.append(0)\n\n    # Ensure the version list has exactly three elements\n    while len(version_numbers) < 3:\n        version_numbers.append(0)\n\n    return version_numbers[:3]"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "create_from_vlayer", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/taup/slowness_layer.py", "method_code_mask": "import math\nimport numpy as np\n\n\ndef create_from_vlayer(v_layer, is_p_wave, radius_of_planet, is_spherical=True\n    ): [MASK]\n", "response": "import math\nimport numpy as np\n\n\ndef create_from_vlayer(v_layer, is_p_wave, radius_of_planet, is_spherical=True):\n    if not is_spherical:\n        raise NotImplementedError(\"Non-spherical models are currently unsupported.\")\n    \n    # Calculate slowness from velocity\n    slowness_layer = np.zeros_like(v_layer, dtype=np.float64)\n    \n    if is_p_wave:\n        slowness_layer = 1.0 / v_layer  # Slowness for P-waves\n    else:\n        slowness_layer = 1.0 / v_layer  # Slowness for S-waves\n\n    # Create a structured array to hold the slowness layer attributes\n    slowness_layer_structured = np.zeros(v_layer.shape, dtype=[('top_depth', 'f8'), \n                                                               ('bot_depth', 'f8'), \n                                                               ('top_p', 'f8'), \n                                                               ('bot_p', 'f8')])\n    \n    # Assuming the depths are calculated based on the radius of the planet\n    depths = np.linspace(0, radius_of_planet, num=v_layer.shape[0])\n    \n    slowness_layer_structured['top_depth'] = depths[:-1]\n    slowness_layer_structured['bot_depth'] = depths[1:]\n    slowness_layer_structured['top_p'] = slowness_layer[:-1]\n    slowness_layer_structured['bot_p'] = slowness_layer[1:]\n\n    return slowness_layer_structured"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "create_preview", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/preview.py", "method_code_mask": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef create_preview(trace, delta=60): [MASK]\n", "response": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef create_preview(trace, delta=60):\n    # Ensure delta is a multiple of the sampling rate\n    if delta % trace.stats.sampling_rate != 0:\n        raise ValueError(\"Delta must be a multiple of the sampling rate.\")\n\n    # Calculate the number of samples in each segment\n    segment_length = int(delta * trace.stats.sampling_rate)\n    num_segments = len(trace) // segment_length\n\n    # Create an array to hold the preview data\n    preview_data = np.zeros(num_segments)\n\n    for i in range(num_segments):\n        start_sample = i * segment_length\n        end_sample = start_sample + segment_length\n        segment = trace.data[start_sample:end_sample]\n        preview_data[i] = np.max(segment) - np.min(segment)\n\n    # Create a new Trace object for the preview\n    preview_trace = copy(trace)\n    preview_trace.data = preview_data\n    preview_trace.stats.sampling_rate = 1 / delta  # New sampling rate\n    preview_trace.stats.npts = num_segments\n    preview_trace.stats.starttime = trace.stats.starttime  # Keep the same start time\n\n    return preview_trace"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "merge_previews", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/preview.py", "method_code_mask": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef merge_previews(stream): [MASK]\n", "response": "from copy import copy\nimport numpy as np\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.utcdatetime import UTCDateTime\n\n\ndef merge_previews(stream):\n    # Filter traces that have 'preview' set to True\n    preview_traces = [trace for trace in stream if trace.stats.preview]\n    \n    if not preview_traces:\n        return Stream()  # Return an empty Stream if no preview traces are found\n\n    # Sort traces by start time\n    preview_traces.sort(key=lambda x: x.stats.starttime)\n\n    merged_traces = []\n    current_trace = copy(preview_traces[0])  # Start with the first trace\n\n    for next_trace in preview_traces[1:]:\n        # Check if the current trace overlaps with the next trace\n        if current_trace.stats.endtime >= next_trace.stats.starttime:\n            # Merge the data\n            current_trace.data = np.concatenate((current_trace.data, next_trace.data))\n            current_trace.stats.endtime = next_trace.stats.endtime  # Update endtime\n        else:\n            # No overlap, add the current trace to merged_traces and move to the next\n            merged_traces.append(current_trace)\n            current_trace = copy(next_trace)  # Start a new current trace\n\n    # Don't forget to add the last trace\n    merged_traces.append(current_trace)\n\n    # Create a new Stream object with the merged traces\n    merged_stream = Stream(traces=merged_traces)\n    \n    return merged_stream"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "leg_puller", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/taup/seismic_phase.py", "method_code_mask": "from itertools import count\nimport math\nimport re\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom obspy.core.util.obspy_types import Enum\n\n\ndef leg_puller(name): [MASK]\n", "response": "from itertools import count\nimport math\nimport re\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom obspy.core.util.obspy_types import Enum\n\n\ndef leg_puller(name):\n    # Check for invalid names\n    if name == 'PIP':\n        return []\n\n    # Use regex to find all tokens\n    tokens = re.findall(r'[A-Za-z]+|[0-9]+|[^\\w\\s]', name)\n    \n    # Append \"END\" to the list of tokens\n    tokens.append(\"END\")\n    \n    return tokens"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "get_example_file", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/base.py", "method_code_mask": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef get_example_file(filename): [MASK]\n", "response": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef get_example_file(filename):\n    # Get the list of all installed packages\n    installed_packages = pkg_resources.working_set\n    # Iterate through each package\n    for package in installed_packages:\n        # Get the package's location\n        package_path = Path(package.location) / package.project_name\n        # Define possible data directories\n        data_dirs = [package_path / \"tests\" / \"data\", package_path / \"data\"]\n        # Check each data directory\n        for data_dir in data_dirs:\n            # Construct the full path to the file\n            file_path = data_dir / filename\n            # If the file exists, return its absolute path\n            if file_path.is_file():\n                return str(file_path.resolve())\n    # If the file was not found, raise an OSError\n    raise OSError(f\"File '{filename}' could not be found in any ObsPy module data directories.\")"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "bullen_depth_for", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/taup/slowness_layer.py", "method_code_mask": "import math\nimport numpy as np\n\n\ndef bullen_depth_for(layer, ray_param, radius_of_planet, check=True): [MASK]\n", "response": "import math\nimport numpy as np\n\n\ndef bullen_depth_for(layer, ray_param, radius_of_planet, check=True):\n    if check:\n        if not isinstance(layer, np.ndarray) or layer.shape != (1,):\n            raise ValueError(\"Layer must be a numpy.ndarray with shape (1,)\")\n        if not isinstance(ray_param, (float, np.float64)):\n            raise ValueError(\"Ray parameter must be a float\")\n        if not isinstance(radius_of_planet, (float, np.float64)):\n            raise ValueError(\"Radius of planet must be a float\")\n\n    # Extracting the layer properties\n    slowness = layer[0].slowness\n    depth = layer[0].depth\n\n    # Handle special case for ray_param\n    if ray_param == 0:\n        return depth  # At the surface, depth is the same as the layer depth\n\n    # Calculate the depth using the Bullen interpolant\n    try:\n        depth_value = (radius_of_planet * slowness) / ray_param\n    except ZeroDivisionError:\n        depth_value = depth  # Fallback to layer depth if division by zero occurs\n\n    # Ensure the depth is within the bounds of the layer\n    if depth_value < 0:\n        return 0.0  # Depth cannot be negative\n    elif depth_value > depth:\n        return depth  # Return the maximum depth of the layer\n\n    return depth_value"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "sanitize_filename", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/base.py", "method_code_mask": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef sanitize_filename(filename): [MASK]\n", "response": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef sanitize_filename(filename):\n    # Normalize the filename to ASCII\n    filename = unicodedata.normalize('NFKD', filename)\n    \n    # Remove any characters that are not alphanumeric, periods, or hyphens\n    filename = re.sub(r'[^a-zA-Z0-9.\\- ]+', '', filename)\n    \n    # Replace consecutive whitespace or hyphens with a single hyphen\n    filename = re.sub(r'[-\\s]+', '-', filename)\n    \n    # Strip leading and trailing hyphens\n    filename = filename.strip('-')\n    \n    return filename"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "create_empty_data_chunk", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/base.py", "method_code_mask": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef create_empty_data_chunk(delta, dtype, fill_value=None): [MASK]\n", "response": "import glob\nimport importlib\nimport inspect\nimport io\nimport os\nfrom contextlib import contextmanager\nfrom io import IOBase\nfrom io import TextIOBase\nfrom io import TextIOWrapper\nfrom pathlib import Path\nimport re\nimport sys\nimport tempfile\nimport unicodedata\nimport warnings\nfrom collections import OrderedDict\nfrom pathlib import PurePath\nimport numpy as np\nimport pkg_resources\nfrom pkg_resources import get_entry_info\nfrom pkg_resources import iter_entry_points\nfrom obspy.core.util.misc import to_int_or_zero\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom argparse import Action\nimport requests\nimport doctest\n\n\ndef create_empty_data_chunk(delta, dtype, fill_value=None):\n    if fill_value is None:\n        return np.ma.empty(delta, dtype=dtype)  # Return a masked array if no fill value is provided\n    elif isinstance(fill_value, (list, tuple)) and len(fill_value) == 2:\n        # Perform linear interpolation between the two values\n        return np.linspace(fill_value[0], fill_value[1], delta, dtype=dtype)\n    else:\n        # Fill the array with the provided fill value\n        return np.full(delta, fill_value, dtype=dtype)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_pitick2latex", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/inventory/response.py", "method_code_mask": "import copy\nimport ctypes as C\nimport collections.abc\nfrom collections import defaultdict\nfrom copy import deepcopy\nimport itertools\nfrom math import pi\nimport warnings\nimport numpy as np\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.util.obspy_types import ObsPyException\nfrom obspy.core.util.obspy_types import ZeroSamplingRate\nimport scipy.interpolate\nimport obspy.signal.evrespwrapper as ew\nfrom obspy.signal.headers import clibevresp\nimport matplotlib.pyplot as plt\nfrom matplotlib.transforms import blended_transform_factory\nimport doctest\n\n\ndef _pitick2latex(x): [MASK]\n", "response": "import copy\nimport ctypes as C\nimport collections.abc\nfrom collections import defaultdict\nfrom copy import deepcopy\nimport itertools\nfrom math import pi\nimport warnings\nimport numpy as np\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.util.obspy_types import ObsPyException\nfrom obspy.core.util.obspy_types import ZeroSamplingRate\nimport scipy.interpolate\nimport obspy.signal.evrespwrapper as ew\nfrom obspy.signal.headers import clibevresp\nimport matplotlib.pyplot as plt\nfrom matplotlib.transforms import blended_transform_factory\nimport doctest\n\n\ndef _pitick2latex(x):\n    if x % (pi / 2) == 0:\n        multiple = int(x / (pi / 2))\n        if multiple == 1:\n            return r'$\\frac{\\pi}{2}$'\n        elif multiple == -1:\n            return r'$-\\frac{\\pi}{2}$'\n        else:\n            return r'${0} \\cdot \\frac{\\pi}{2}$'.format(multiple)\n    else:\n        return \"{:.3f}\".format(x)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "farfield", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/event/source.py", "method_code_mask": "import numpy as np\nfrom obspy.core.event.base import _event_type_class_factory\nfrom obspy.core.event.base import CreationInfo\nfrom obspy.core.event import ResourceIdentifier\nfrom obspy.core.event.header import EvaluationMode\nfrom obspy.core.event.header import EvaluationStatus\nfrom obspy.core.event.header import MomentTensorCategory\nfrom obspy.core.event.header import MTInversionType\nfrom obspy.core.event.header import SourceTimeFunctionType\nfrom obspy.core.event.header import ATTRIBUTE_HAS_ERRORS\nimport doctest\n\n\ndef farfield(mt, points, type): [MASK]\n", "response": "import numpy as np\nfrom obspy.core.event.base import _event_type_class_factory\nfrom obspy.core.event.base import CreationInfo\nfrom obspy.core.event import ResourceIdentifier\nfrom obspy.core.event.header import EvaluationMode\nfrom obspy.core.event.header import EvaluationStatus\nfrom obspy.core.event.header import MomentTensorCategory\nfrom obspy.core.event.header import MTInversionType\nfrom obspy.core.event.header import SourceTimeFunctionType\nfrom obspy.core.event.header import ATTRIBUTE_HAS_ERRORS\nimport doctest\n\n\ndef farfield(mt, points, type):\n    \"\"\"\n    Calculate the P or S wave farfield radiation pattern based on Aki's equation 4.29 for a given moment tensor and set of points in space.\n\n    Parameters:\n    mt : np.ndarray\n        A 2D array representing the focal mechanism with dimensions NM x 6.\n    points : np.ndarray\n        A 3D vector array with shape either [3, npts] representing (x, y, z) coordinates or [2, npts] representing (theta, phi) angles.\n    type : str\n        A string parameter that can either be 'P' or 'S'.\n\n    Returns:\n    np.ndarray\n        A 3D vector array with shape [3, npts] that contains the displacement vector for each grid point.\n    \"\"\"\n    # Normalize the points if they are in Cartesian coordinates\n    if points.shape[0] == 3:\n        x, y, z = points\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.arccos(z / r)  # polar angle\n        phi = np.arctan2(y, x)    # azimuthal angle\n    elif points.shape[0] == 2:\n        theta, phi = points\n        r = 1  # Assume unit radius for spherical coordinates\n        x = r * np.sin(theta) * np.cos(phi)\n        y = r * np.sin(theta) * np.sin(phi)\n        z = r * np.cos(theta)\n    else:\n        raise ValueError(\"Invalid shape for points array. Must be [3, npts] or [2, npts].\")\n\n    # Initialize displacement array\n    npts = points.shape[1]\n    displacement = np.zeros((3, npts))\n\n    # Calculate the farfield displacement based on the type\n    for i in range(npts):\n        if type == 'P':\n            # P-wave displacement calculation\n            displacement[:, i] = (mt[:, 0] * (1 - 2 * np.cos(theta[i])**2) +\n                                  mt[:, 1] * np.sin(theta[i])**2 * np.cos(2 * phi[i]) +\n                                  mt[:, 2] * np.sin(theta[i])**2 * np.sin(2 * phi[i]) +\n                                  mt[:, 3] * np.sin(2 * theta[i]) * np.cos(phi[i]) +\n                                  mt[:, 4] * np.sin(2 * theta[i]) * np.sin(phi[i]) +\n                                  mt[:, 5] * np.sin(theta[i]) * np.cos(theta[i]))\n        elif type == 'S':\n            # S-wave displacement calculation\n            displacement[:, i] = (mt[:, 0] * np.sin(theta[i]) * np.cos(phi[i]) +\n                                  mt[:, 1] * np.sin(theta[i]) * np.sin(phi[i]) +\n                                  mt[:, 2] * np.cos(theta[i]) +\n                                  mt[:, 3] * np.cos(theta[i]) * np.cos(phi[i]) +\n                                  mt[:, 4] * np.cos(theta[i]) * np.sin(phi[i]) +\n                                  mt[:, 5] * np.sin(theta[i]))\n\n    return displacement"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_yield_obj_parent_attr", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/misc.py", "method_code_mask": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef _yield_obj_parent_attr(obj, cls=None, is_attr=None, has_attr=None): [MASK]\n", "response": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef _yield_obj_parent_attr(obj, cls=None, is_attr=None, has_attr=None):\n    if cls is not None and not isinstance(obj, cls):\n        return\n\n    if has_attr is not None and not hasattr(obj, has_attr):\n        return\n\n    if is_attr is not None:\n        if not hasattr(obj, is_attr):\n            return\n        obj = getattr(obj, is_attr)\n\n    yield obj, None, None  # Yield the root object with no parent\n\n    for attr_name in dir(obj):\n        if attr_name.startswith('_'):\n            continue  # Skip private attributes\n\n        attr_value = getattr(obj, attr_name)\n\n        if cls is not None and not isinstance(attr_value, cls):\n            continue\n\n        if has_attr is not None and not hasattr(attr_value, has_attr):\n            continue\n\n        if is_attr is not None and not hasattr(attr_value, is_attr):\n            continue\n\n        yield attr_value, obj, attr_name\n\n        # Recursively yield from sub-attributes\n        if isinstance(attr_value, (list, tuple, set)):\n            for item in attr_value:\n                if isinstance(item, object):\n                    yield from _yield_obj_parent_attr(item, cls, is_attr, has_attr)\n        elif isinstance(attr_value, dict):\n            for key, value in attr_value.items():\n                if isinstance(value, object):\n                    yield from _yield_obj_parent_attr(value, cls, is_attr, has_attr)\n        elif isinstance(attr_value, object):\n            yield from _yield_obj_parent_attr(attr_value, cls, is_attr, has_attr)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "build_url", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/clients/fdsn/client.py", "method_code_mask": "import collections.abc\nimport copy\nimport gzip\nimport io\nimport os\nimport re\nfrom socket import timeout as socket_timeout\nimport textwrap\nimport threading\nimport warnings\nfrom collections import OrderedDict\nfrom http.client import HTTPException\nfrom http.client import IncompleteRead\nfrom urllib.parse import urlparse\nfrom lxml import etree\nimport obspy\nfrom obspy import UTCDateTime\nfrom obspy import read_inventory\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom urllib.parse import urlencode\nimport urllib.request as urllib_request\nimport queue\nimport doctest\n\n\ndef build_url(base_url, service, major_version, resource_type, parameters=\n    None, service_mappings=None, subpath='fdsnws'): [MASK]\n", "response": "import collections.abc\nimport copy\nimport gzip\nimport io\nimport os\nimport re\nfrom socket import timeout as socket_timeout\nimport textwrap\nimport threading\nimport warnings\nfrom collections import OrderedDict\nfrom http.client import HTTPException\nfrom http.client import IncompleteRead\nfrom urllib.parse import urlparse\nfrom lxml import etree\nimport obspy\nfrom obspy import UTCDateTime\nfrom obspy import read_inventory\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom urllib.parse import urlencode\nimport urllib.request as urllib_request\nimport queue\nimport doctest\n\n\ndef build_url(base_url, service, major_version, resource_type, parameters=None, service_mappings=None, subpath='fdsnws'):\n    # Construct the service path\n    if service_mappings and service in service_mappings:\n        service_path = service_mappings[service]\n    else:\n        service_path = service\n\n    # Build the URL\n    url = f\"{base_url}/{subpath}/{service_path}/{major_version}/{resource_type}\"\n\n    # Append parameters if provided\n    if parameters:\n        url += '?' + urlencode(parameters)\n\n    return url"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "download_stationxml", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/clients/fdsn/mass_downloader/utils.py", "method_code_mask": "import collections\nimport fnmatch\nimport itertools\nimport os\nfrom http.client import HTTPException\nfrom socket import timeout as socket_timeout\nfrom urllib.error import HTTPError\nfrom urllib.error import URLError\nimport numpy as np\nfrom lxml import etree\nfrom scipy.spatial import cKDTree\nimport obspy\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.clients.fdsn.client import FDSNException\nfrom obspy.io.mseed.util import get_record_information\n\n\ndef download_stationxml(client, client_name, bulk, filename, logger): [MASK]\n", "response": "import collections\nimport fnmatch\nimport itertools\nimport os\nfrom http.client import HTTPException\nfrom socket import timeout as socket_timeout\nfrom urllib.error import HTTPError\nfrom urllib.error import URLError\nimport numpy as np\nfrom lxml import etree\nfrom scipy.spatial import cKDTree\nimport obspy\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.clients.fdsn.client import FDSNException\nfrom obspy.io.mseed.util import get_record_information\n\n\ndef download_stationxml(client, client_name, bulk, filename, logger):\n    try:\n        # Create a StationXML root element\n        root = etree.Element(\"StationXML\")\n        \n        for network, station, location, channel, start_time, end_time in bulk:\n            logger.info(f\"{client_name}: Downloading metadata for {network}.{station} {location} {channel} from {start_time} to {end_time}\")\n            try:\n                # Fetch the station metadata\n                response = client.get_station(network=network, station=station, location=location, channel=channel, starttime=start_time, endtime=end_time, format='stationxml')\n                # Parse the response and append to the root element\n                root.append(etree.fromstring(response))\n            except (HTTPError, URLError, FDSNException) as e:\n                logger.error(f\"{client_name}: Failed to download {network}.{station} {location} {channel}: {e}\")\n                return None\n        \n        # Write the StationXML to the specified file\n        with open(filename, 'wb') as f:\n            f.write(etree.tostring(root, pretty_print=True, xml_declaration=True, encoding='UTF-8'))\n        \n        logger.info(f\"{client_name}: Successfully downloaded metadata to {filename}\")\n        return (bulk[0][0], bulk[0][1]), filename  # Return the network and station codes, and the filename\n\n    except Exception as e:\n        logger.error(f\"{client_name}: An error occurred during the download process: {e}\")\n        return None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "parse_simple_xml", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/clients/fdsn/client.py", "method_code_mask": "import collections.abc\nimport copy\nimport gzip\nimport io\nimport os\nimport re\nfrom socket import timeout as socket_timeout\nimport textwrap\nimport threading\nimport warnings\nfrom collections import OrderedDict\nfrom http.client import HTTPException\nfrom http.client import IncompleteRead\nfrom urllib.parse import urlparse\nfrom lxml import etree\nimport obspy\nfrom obspy import UTCDateTime\nfrom obspy import read_inventory\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom urllib.parse import urlencode\nimport urllib.request as urllib_request\nimport queue\nimport doctest\n\n\ndef parse_simple_xml(xml_string): [MASK]\n", "response": "import collections.abc\nimport copy\nimport gzip\nimport io\nimport os\nimport re\nfrom socket import timeout as socket_timeout\nimport textwrap\nimport threading\nimport warnings\nfrom collections import OrderedDict\nfrom http.client import HTTPException\nfrom http.client import IncompleteRead\nfrom urllib.parse import urlparse\nfrom lxml import etree\nimport obspy\nfrom obspy import UTCDateTime\nfrom obspy import read_inventory\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom urllib.parse import urlencode\nimport urllib.request as urllib_request\nimport queue\nimport doctest\n\n\ndef parse_simple_xml(xml_string):\n    \"\"\"\n    Parses a simple XML structure and returns a dictionary.\n\n    The XML is expected to have a root element that ends with 's' and contains:\n    - A 'total' element\n    - Multiple 'B' elements with text content\n\n    Args:\n        xml_string (str): The XML string to parse.\n\n    Returns:\n        dict: A dictionary with the root element's tag (in lowercase) as the key\n              and a set of text content from 'B' elements as the value.\n\n    Raises:\n        ValueError: If the root tag does not end with 's'.\n    \"\"\"\n    root = etree.fromstring(xml_string)\n\n    if not root.tag.endswith('s'):\n        raise ValueError('Could not parse the XML.')\n\n    b_elements = root.findall('B')\n    b_texts = {b.text for b in b_elements if b.text is not None}\n\n    return {root.tag.lower(): b_texts}"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "locations2degrees", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/geodetics/base.py", "method_code_mask": "import math\nimport warnings\nimport numpy as np\nfrom obspy.core.util.misc import to_int_or_zero\nimport geographiclib\nfrom geographiclib.geodesic import Geodesic\nfrom scipy.stats import circmean\nimport doctest\n\n\ndef locations2degrees(lat1, long1, lat2, long2): [MASK]\n", "response": "import math\nimport warnings\nimport numpy as np\nfrom obspy.core.util.misc import to_int_or_zero\nimport geographiclib\nfrom geographiclib.geodesic import Geodesic\nfrom scipy.stats import circmean\nimport doctest\n\n\ndef locations2degrees(lat1, long1, lat2, long2):\n    \"\"\"\n    Calculate the great circle distance between two points on the Earth's surface\n    using the Vincenty formula in the special case of a spherical Earth.\n\n    Parameters:\n    lat1 : float or numpy.ndarray\n        Latitude(s) of the first point in degrees.\n    long1 : float or numpy.ndarray\n        Longitude(s) of the first point in degrees.\n    lat2 : float or numpy.ndarray\n        Latitude(s) of the second point in degrees.\n    long2 : float or numpy.ndarray\n        Longitude(s) of the second point in degrees.\n\n    Returns:\n    float or numpy.ndarray\n        Distance in degrees between the two points on the Earth's surface.\n    \n    Examples:\n    >>> locations2degrees(0, 0, 0, 90)\n    90.0\n    >>> locations2degrees(np.array([0, 0]), np.array([0, 90]), np.array([0, 0]), np.array([90, 90]))\n    array([90., 90.])\n    \"\"\"\n    \n    # Convert degrees to radians\n    lat1_rad = np.radians(lat1)\n    long1_rad = np.radians(long1)\n    lat2_rad = np.radians(lat2)\n    long2_rad = np.radians(long2)\n\n    # Haversine formula\n    dlat = lat2_rad - lat1_rad\n    dlong = long2_rad - long1_rad\n\n    a = np.sin(dlat / 2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(dlong / 2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n\n    # Radius of the Earth in degrees\n    R = 180 / math.pi  # Convert radians to degrees\n    distance = R * c\n\n    return distance"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_unified_content_strings", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/inventory/util.py", "method_code_mask": "import copy\nimport re\nimport warnings\nfrom textwrap import TextWrapper\nfrom obspy import UTCDateTime\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.decorator import deprecated_keywords\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesFixedUnit\nimport doctest\n\n\ndef _unified_content_strings(contents): [MASK]\n", "response": "import copy\nimport re\nimport warnings\nfrom textwrap import TextWrapper\nfrom obspy import UTCDateTime\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.decorator import deprecated_keywords\nfrom obspy.core.util.deprecation_helpers import ObsPyDeprecationWarning\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesFixedUnit\nimport doctest\n\n\ndef _unified_content_strings(contents):\n    unique_contents = list(set(contents))  # Remove duplicates\n    unique_contents.sort()  # Sort the unique elements\n    output = []\n\n    for item in unique_contents:\n        count = contents.count(item)  # Count occurrences in the original list\n        if count == 1:\n            output.append(item)  # Add as is if it appears once\n        else:\n            output.append(f\"{item} (count{count})\")  # Add with count if it appears more than once\n\n    return output"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "strike_dip", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/beachball.py", "method_code_mask": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef strike_dip(n, e, u): [MASK]\n", "response": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef strike_dip(n, e, u):\n    # Ensure the normal vector points upwards\n    if u < 0:\n        n, e, u = -n, -e, -u\n\n    # Calculate the strike angle\n    strike = np.arctan2(e, n) * (180 / np.pi)\n    if strike < 0:\n        strike += 360\n\n    # Calculate the dip angle\n    dip = np.arctan2(np.sqrt(n**2 + e**2), u) * (180 / np.pi)\n\n    return strike, dip"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "filter_channel_priority", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/clients/fdsn/mass_downloader/utils.py", "method_code_mask": "import collections\nimport fnmatch\nimport itertools\nimport os\nfrom http.client import HTTPException\nfrom socket import timeout as socket_timeout\nfrom urllib.error import HTTPError\nfrom urllib.error import URLError\nimport numpy as np\nfrom lxml import etree\nfrom scipy.spatial import cKDTree\nimport obspy\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.clients.fdsn.client import FDSNException\nfrom obspy.io.mseed.util import get_record_information\n\n\ndef filter_channel_priority(channels, key, priorities=None): [MASK]\n", "response": "import collections\nimport fnmatch\nimport itertools\nimport os\nfrom http.client import HTTPException\nfrom socket import timeout as socket_timeout\nfrom urllib.error import HTTPError\nfrom urllib.error import URLError\nimport numpy as np\nfrom lxml import etree\nfrom scipy.spatial import cKDTree\nimport obspy\nfrom obspy.core.util.base import NamedTemporaryFile\nfrom obspy.clients.fdsn.client import FDSNException\nfrom obspy.io.mseed.util import get_record_information\n\n\ndef filter_channel_priority(channels, key, priorities=None):\n    if priorities is None:\n        return channels\n    \n    filtered_channels = []\n    \n    for pattern in priorities:\n        for channel in channels:\n            if fnmatch.fnmatch(getattr(channel, key), pattern):\n                filtered_channels.append(channel)\n        if filtered_channels:  # Stop if we found matches for the current pattern\n            break\n    \n    return filtered_channels"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "tdl", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/beachball.py", "method_code_mask": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef tdl(an, bn): [MASK]\n", "response": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef tdl(an, bn):\n    \"\"\"\n    Calculate the fault trend, fault dip, and fault length trend given two points in 3D space.\n\n    Parameters:\n    an (list or array): A list or array containing three floats or integers representing the x, y, and z coordinates of the first point in 3D space.\n    bn (list or array): A list or array containing three floats or integers representing the x, y, and z coordinates of the second point in 3D space.\n\n    Returns:\n    tuple: A tuple containing:\n        - ft (float): The fault trend in degrees.\n        - fd (float): The fault dip in degrees.\n        - fl (float): The fault length trend in degrees.\n    \n    Example:\n    >>> tdl([1, 2, 3], [4, 5, 6])\n    (45.0, 45.0, 45.0)\n    \"\"\"\n    # Calculate the differences in coordinates\n    dx = bn[0] - an[0]\n    dy = bn[1] - an[1]\n    dz = bn[2] - an[2]\n\n    # Calculate the fault trend (ft)\n    ft = np.arctan2(dy, dx) * (180 / np.pi)  # Convert from radians to degrees\n\n    # Calculate the fault dip (fd)\n    horizontal_distance = np.sqrt(dx**2 + dy**2)\n    fd = np.arctan2(dz, horizontal_distance) * (180 / np.pi)  # Convert from radians to degrees\n\n    # Calculate the fault length trend (fl)\n    fl = ft  # In this context, fl is the same as ft\n\n    return ft, fd, fl"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "mt2plane", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/beachball.py", "method_code_mask": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef mt2plane(mt): [MASK]\n", "response": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\nclass MomentTensor:\n    def __init__(self, tensor):\n        self.tensor = tensor\n\nclass NodalPlane:\n    def __init__(self, strike, dip, rake):\n        self.strike = strike\n        self.dip = dip\n        self.rake = rake\n\ndef mt2plane(mt):\n    # Perform eigenvalue decomposition of the moment tensor\n    eigenvalues, eigenvectors = np.linalg.eig(mt.tensor)\n\n    # Sort eigenvalues and corresponding eigenvectors\n    idx = eigenvalues.argsort()[::-1]  # Sort in descending order\n    eigenvalues = eigenvalues[idx]\n    eigenvectors = eigenvectors[:, idx]\n\n    # The first two eigenvalues correspond to the nodal planes\n    strike1, dip1, rake1 = calculate_nodal_plane(eigenvectors[:, 0])\n    strike2, dip2, rake2 = calculate_nodal_plane(eigenvectors[:, 1])\n\n    # Return the nodal planes as NodalPlane objects\n    return NodalPlane(strike1, dip1, rake1), NodalPlane(strike2, dip2, rake2)\n\ndef calculate_nodal_plane(eigenvector):\n    # Placeholder for actual calculation of strike, dip, and rake from eigenvector\n    # This is a simplified example and should be replaced with actual calculations\n    strike = np.arctan2(eigenvector[1], eigenvector[0]) * (180 / np.pi)\n    dip = np.arcsin(eigenvector[2]) * (180 / np.pi)\n    rake = 0  # Placeholder for rake calculation\n    return strike, dip, rake"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "mt2axes", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/beachball.py", "method_code_mask": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef mt2axes(mt): [MASK]\n", "response": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\nclass PrincipalAxis:\n    def __init__(self, eigenvalue, azimuth, plunge):\n        self.eigenvalue = eigenvalue\n        self.azimuth = azimuth\n        self.plunge = plunge\n\ndef mt2axes(mt):\n    # Calculate eigenvalues and eigenvectors\n    eigenvalues, eigenvectors = np.linalg.eig(mt)\n\n    # Sort eigenvalues and corresponding eigenvectors\n    idx = eigenvalues.argsort()[::-1]  # Sort in descending order\n    eigenvalues = eigenvalues[idx]\n    eigenvectors = eigenvectors[:, idx]\n\n    # Calculate azimuth and plunge for each principal axis\n    principal_axes = []\n    for i in range(3):\n        eigenvalue = eigenvalues[i]\n        vector = eigenvectors[:, i]\n        \n        # Calculate azimuth\n        azimuth = np.arctan2(vector[1], vector[0]) * (180 / np.pi)\n        if azimuth < 0:\n            azimuth += 360\n        \n        # Calculate plunge\n        plunge = np.arcsin(vector[2]) * (180 / np.pi)\n        \n        # Create PrincipalAxis object\n        principal_axes.append(PrincipalAxis(eigenvalue, azimuth, plunge))\n\n    return tuple(principal_axes)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "get_ray_paths", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/taup/ray_paths.py", "method_code_mask": "import warnings\nimport numpy as np\nimport obspy.geodetics.base as geodetics\nfrom obspy.taup import TauPyModel\n\n\ndef get_ray_paths(inventory, catalog, phase_list=['P'], coordinate_system=\n    'XYZ', taup_model='iasp91'): [MASK]\n", "response": "import warnings\nimport numpy as np\nimport obspy.geodetics.base as geodetics\nfrom obspy.taup import TauPyModel\n\n\ndef get_ray_paths(inventory, catalog, phase_list=['P'], coordinate_system='XYZ', taup_model='iasp91'):\n    if isinstance(taup_model, str):\n        taup_model = TauPyModel(taup_model)\n\n    ray_paths = []\n\n    for event in catalog:\n        event_timestamp = event.origins[0].time.timestamp()\n        event_magnitude = event.magnitudes[0].mag if event.magnitudes else None\n        event_id = event.resource_id.id\n        origin_id = event.origins[0].resource_id.id\n\n        for station in inventory:\n            station_label = f\"{station.code}.{station.network}\"\n            lat, lon, depth = station.latitude, station.longitude, station.elevation\n\n            for phase in phase_list:\n                try:\n                    # Compute the ray path\n                    gcircle = taup_model.get_ray_paths(source=event.origins[0], \n                                                        distance=geodetics.gps2dist_azimuth(lat, lon, event.origins[0].latitude, event.origins[0].longitude)[0],\n                                                        phase_list=[phase],\n                                                        include_all=True,\n                                                        coordinate_system=coordinate_system)\n\n                    # Extract the coordinates\n                    if coordinate_system == 'XYZ':\n                        coordinates = np.array([gcircle[0].x, gcircle[0].y, gcircle[0].z])\n                    elif coordinate_system == 'RTP':\n                        coordinates = np.array([gcircle[0].r, gcircle[0].theta, gcircle[0].phi])\n                    else:\n                        raise ValueError(\"Invalid coordinate system. Use 'XYZ' or 'RTP'.\")\n\n                    ray_paths.append((coordinates, phase, station_label, event_timestamp, event_magnitude, event_id, origin_id))\n                except Exception as e:\n                    warnings.warn(f\"Could not compute ray path for {station_label} and phase {phase}: {e}\")\n\n    return ray_paths"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "calculate_lanczos_kernel", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/interpolation.py", "method_code_mask": "import numpy as np\nimport scipy.interpolate\nfrom obspy.signal.headers import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef calculate_lanczos_kernel(x, a, window): [MASK]\n", "response": "import numpy as np\nimport scipy.interpolate\nfrom obspy.signal.headers import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef calculate_lanczos_kernel(x, a, window):\n    # Calculate the sinc function\n    sinc_function = np.sinc(x / np.pi)  # np.sinc is normalized, so we divide by pi\n\n    # Calculate the taper function based on the specified window\n    if window == \"lanczos\":\n        taper_function = np.sinc(x / np.pi) * np.cos(np.pi * x / a) / (1 + (x / a) ** 2)\n    elif window == \"hanning\":\n        taper_function = 0.5 * (1 + np.cos(np.pi * x / a))\n    elif window == \"blackman\":\n        taper_function = 0.42 - 0.5 * np.cos(2 * np.pi * x / a) + 0.08 * np.cos(4 * np.pi * x / a)\n    else:\n        raise ValueError(\"Window type not recognized. Use 'lanczos', 'hanning', or 'blackman'.\")\n\n    # Calculate the full kernel\n    full_kernel = sinc_function * taper_function\n\n    return {\n        'full_kernel': full_kernel,\n        'only_sinc': sinc_function,\n        'only_taper': taper_function\n    }"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "aux_plane", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/beachball.py", "method_code_mask": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef aux_plane(s1, d1, r1): [MASK]\n", "response": "import io\nimport warnings\nimport numpy as np\nfrom decorator import decorator\nfrom matplotlib import collections\nfrom matplotlib import transforms\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib import path as mplpath\nimport doctest\n\n\ndef aux_plane(s1, d1, r1):\n    \"\"\"\n    Calculate the strike, dip, and rake of a second plane given the strike and dip of a primary plane\n    and the rake angle between the two planes.\n\n    Parameters:\n    s1 (float): The strike angle of the primary plane in degrees.\n    d1 (float): The dip angle of the primary plane in degrees.\n    r1 (float): The rake angle between the primary plane and the second plane in degrees.\n\n    Returns:\n    tuple: A tuple containing the strike (float), dip (float), and rake (float) of the second plane.\n    \"\"\"\n    # Convert angles from degrees to radians\n    s1_rad = np.radians(s1)\n    d1_rad = np.radians(d1)\n    r1_rad = np.radians(r1)\n\n    # Calculate the strike of the second plane\n    strike = np.degrees(s1_rad + np.arctan(np.sin(r1_rad) * np.cos(d1_rad) / \n                                             (np.cos(r1_rad) * np.sin(d1_rad) - \n                                              np.sin(s1_rad) * np.sin(r1_rad) * np.cos(d1_rad))))\n\n    # Calculate the dip of the second plane\n    dip = np.degrees(np.arcsin(np.sin(d1_rad) * np.cos(r1_rad)))\n\n    # Calculate the rake of the second plane\n    rake = r1  # Rake remains the same as the input rake angle\n\n    return strike, dip, rake"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "konno_ohmachi_smoothing_window", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/konnoohmachismoothing.py", "method_code_mask": "import warnings\nimport numpy as np\n\n\ndef konno_ohmachi_smoothing_window(frequencies, center_frequency, bandwidth\n    =40.0, normalize=False): [MASK]\n", "response": "import warnings\nimport numpy as np\n\n\ndef konno_ohmachi_smoothing_window(frequencies, center_frequency, bandwidth=40.0, normalize=False):\n    # Check if the input frequencies are of the correct dtype\n    if frequencies.dtype not in [np.float32, np.float64]:\n        raise ValueError(\"Frequencies array must be of type float32 or float64.\")\n    \n    # Check if center_frequency and bandwidth are valid\n    if center_frequency < 0:\n        raise ValueError(\"Center frequency must be greater than or equal to 0.\")\n    if bandwidth <= 0:\n        raise ValueError(\"Bandwidth must be greater than 0.\")\n    \n    # Calculate the smoothing window\n    f = frequencies\n    f_c = center_frequency\n    b = bandwidth\n    \n    # Calculate the logarithmic term\n    log_term = np.log10(f / f_c)\n    \n    # Avoid division by zero and undefined values\n    with np.errstate(divide='ignore', invalid='ignore'):\n        window = (np.sin(b * log_term) / (b * log_term)) ** 4\n    \n    # Handle the case where f == f_c\n    window[np.isnan(window)] = 1.0  # Set the value to 1 where f == f_c\n    \n    # Normalize if required\n    if normalize:\n        window /= np.max(window)\n    \n    return window"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "apply_smoothing_matrix", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/konnoohmachismoothing.py", "method_code_mask": "import warnings\nimport numpy as np\n\n\ndef apply_smoothing_matrix(spectra, smoothing_matrix, count=1): [MASK]\n", "response": "import warnings\nimport numpy as np\n\n\ndef apply_smoothing_matrix(spectra, smoothing_matrix, count=1):\n    if not isinstance(spectra, np.ndarray) or not isinstance(smoothing_matrix, np.ndarray):\n        raise ValueError(\"Both spectra and smoothing_matrix must be numpy arrays.\")\n    \n    if spectra.ndim != 2 or smoothing_matrix.ndim != 2:\n        raise ValueError(\"Both spectra and smoothing_matrix must be 2D arrays.\")\n    \n    if spectra.shape[1] != smoothing_matrix.shape[0]:\n        raise ValueError(\"The number of columns in spectra must match the number of rows in smoothing_matrix.\")\n    \n    new_spec = spectra.copy()\n    \n    for _ in range(count):\n        new_spec = np.dot(new_spec, smoothing_matrix)\n    \n    return new_spec"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "konno_ohmachi_smoothing", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/konnoohmachismoothing.py", "method_code_mask": "import warnings\nimport numpy as np\n\n\ndef konno_ohmachi_smoothing(spectra, frequencies, bandwidth=40, count=1,\n    enforce_no_matrix=False, max_memory_usage=512, normalize=False): [MASK]\n", "response": "import warnings\nimport numpy as np\n\n\ndef konno_ohmachi_smoothing(spectra, frequencies, bandwidth=40, count=1,\n    enforce_no_matrix=False, max_memory_usage=512, normalize=False):\n    \n    if not isinstance(spectra, np.ndarray) or not isinstance(frequencies, np.ndarray):\n        raise ValueError(\"spectra and frequencies must be numpy ndarrays.\")\n    \n    if spectra.ndim != 2:\n        raise ValueError(\"spectra must be a 2D array.\")\n    \n    if frequencies.ndim != 1:\n        raise ValueError(\"frequencies must be a 1D array.\")\n    \n    if bandwidth <= 0:\n        raise ValueError(\"bandwidth must be greater than 0.\")\n    \n    if count < 1:\n        raise ValueError(\"count must be at least 1.\")\n    \n    n_spectra, n_frequencies = spectra.shape\n    if len(frequencies) != n_frequencies:\n        raise ValueError(\"The length of frequencies must match the number of columns in spectra.\")\n    \n    # Calculate the Konno-Ohmachi smoothing window\n    def konno_ohmachi_window(frequencies, bandwidth, normalize):\n        f = np.asarray(frequencies)\n        window = np.zeros_like(f)\n        for i in range(len(f)):\n            window[i] = np.sum(np.exp(-0.5 * ((f - f[i]) / bandwidth) ** 2))\n        if normalize:\n            window /= np.sum(window)\n        return window\n\n    smoothed_spectra = np.copy(spectra)\n    \n    for _ in range(count):\n        window = konno_ohmachi_window(frequencies, bandwidth, normalize)\n        for i in range(n_spectra):\n            smoothed_spectra[i] = np.convolve(spectra[i], window, mode='same')\n    \n    return smoothed_spectra"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_load_cdll", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/libnames.py", "method_code_mask": "import ctypes\nimport importlib.machinery\nfrom pathlib import Path\nimport re\nimport doctest\n\n\ndef _load_cdll(name): [MASK]\n", "response": "import ctypes\nimport importlib.machinery\nfrom pathlib import Path\nimport re\nimport doctest\n\n\ndef _load_cdll(name):\n    # Construct the path to the shared library\n    lib_path = Path(__file__).parent / 'lib' / f'lib{name}.so'\n    \n    # Attempt to load the shared library\n    try:\n        return ctypes.CDLL(str(lib_path))\n    except OSError as e:\n        raise ImportError(f\"Could not load library '{name}': {e}. \"\n                          f\"Checked path: {lib_path}\")"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "lanczos_interpolation", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/interpolation.py", "method_code_mask": "import numpy as np\nimport scipy.interpolate\nfrom obspy.signal.headers import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef lanczos_interpolation(data, old_start, old_dt, new_start, new_dt,\n    new_npts, a, window='lanczos', *args, **kwargs): [MASK]\n", "response": "import numpy as np\nimport scipy.interpolate\nfrom obspy.signal.headers import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef lanczos_interpolation(data, old_start, old_dt, new_start, new_dt,\n    new_npts, a, window='lanczos', *args, **kwargs):\n    \n    # Create the old time axis\n    old_times = np.arange(old_start, old_start + len(data) * old_dt, old_dt)\n    \n    # Create the new time axis\n    new_times = np.arange(new_start, new_start + new_npts * new_dt, new_dt)\n    \n    # Define the sinc function\n    def sinc(x):\n        return np.sinc(x / np.pi)\n\n    # Define the Lanczos kernel\n    def lanczos_kernel(x):\n        if np.abs(x) < a:\n            return sinc(x) * sinc(x / a)\n        else:\n            return 0\n\n    # Create the interpolation function\n    def interpolate(t):\n        # Calculate the weights\n        weights = np.array([lanczos_kernel(t - old_time) for old_time in old_times])\n        # Apply the window function\n        if window == 'hanning':\n            weights *= np.hanning(len(weights))\n        elif window == 'blackman':\n            weights *= np.blackman(len(weights))\n        elif window == 'lanczos':\n            pass  # No additional windowing for Lanczos\n        else:\n            raise ValueError(\"Invalid window type. Choose 'lanczos', 'hanning', or 'blackman'.\")\n        \n        # Normalize the weights\n        weights /= np.sum(weights)\n        \n        # Perform the interpolation\n        return np.dot(weights, data)\n\n    # Interpolate for each new time point\n    interpolated_data = np.array([interpolate(new_time) for new_time in new_times])\n    \n    return interpolated_data.astype(np.float64)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "calc_dist", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/taup/taup_geo.py", "method_code_mask": "import warnings\nimport numpy as np\nimport obspy.geodetics.base as geodetics\nfrom geographiclib.geodesic import Geodesic\n\n\ndef calc_dist(source_latitude_in_deg, source_longitude_in_deg,\n    receiver_latitude_in_deg, receiver_longitude_in_deg,\n    radius_of_planet_in_km, flattening_of_planet): [MASK]\n", "response": "import warnings\nimport numpy as np\nimport obspy.geodetics.base as geodetics\nfrom geographiclib.geodesic import Geodesic\n\n\ndef calc_dist(source_latitude_in_deg, source_longitude_in_deg,\n    receiver_latitude_in_deg, receiver_longitude_in_deg,\n    radius_of_planet_in_km, flattening_of_planet):\n    \n    # Create a Geodesic object with the specified radius and flattening\n    geod = Geodesic.WGS84  # Using WGS84 as a reference ellipsoid\n    \n    # Calculate the distance using the Geodesic library\n    distance = geod.Inverse(source_latitude_in_deg, source_longitude_in_deg,\n                             receiver_latitude_in_deg, receiver_longitude_in_deg)\n    \n    # The distance is returned in meters, convert to kilometers\n    distance_in_km = distance['s12'] / 1000.0\n    \n    return distance_in_km"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "xcorr_3c", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef xcorr_3c(st1, st2, shift_len, components=['Z', 'N', 'E'], full_xcorr=\n    False, abs_max=True): [MASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef xcorr_3c(st1, st2, shift_len, components=['Z', 'N', 'E'], full_xcorr=False, abs_max=True):\n    \"\"\"\n    Calculate the cross-correlation between two three-component seismic streams.\n\n    Parameters:\n    st1 : Stream\n        A Stream object containing at least one trace for each of the specified components.\n    st2 : Stream\n        A Stream object similar to st1.\n    shift_len : int\n        The total length of samples to shift for the cross-correlation calculation.\n    components : list of str\n        The components to use in the cross-correlation. Defaults to ['Z', 'N', 'E'].\n    full_xcorr : bool\n        Whether to return the complete cross-correlation function. Defaults to False.\n    abs_max : bool\n        Whether to calculate the maximum or the absolute maximum value. Defaults to True.\n\n    Returns:\n    tuple\n        If full_xcorr is False, returns the index of the maximum cross-correlation value and the value itself.\n        If full_xcorr is True, returns the index of the maximum cross-correlation value, the value itself,\n        and the complete cross-correlation function as a numpy.ndarray.\n    \"\"\"\n    \n    # Initialize cross-correlation results\n    xcorr_results = []\n    \n    for comp in components:\n        # Extract traces for the specified component\n        tr1 = st1.select(component=comp)[0]\n        tr2 = st2.select(component=comp)[0]\n        \n        # Perform cross-correlation\n        xcorr = np.correlate(tr1.data, tr2.data, mode='full')\n        xcorr_results.append(xcorr)\n    \n    # Combine results by summing across components\n    combined_xcorr = np.sum(xcorr_results, axis=0)\n    \n    # Determine the index of the maximum cross-correlation value\n    if abs_max:\n        max_index = np.argmax(np.abs(combined_xcorr))\n        max_value = combined_xcorr[max_index]\n    else:\n        max_index = np.argmax(combined_xcorr)\n        max_value = combined_xcorr[max_index]\n    \n    # Calculate the shift\n    shift = max_index - (len(tr1.data) - 1)\n    \n    if full_xcorr:\n        return shift, max_value, combined_xcorr\n    else:\n        return shift, max_value"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "calculate_smoothing_matrix", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/konnoohmachismoothing.py", "method_code_mask": "import warnings\nimport numpy as np\n\n\ndef calculate_smoothing_matrix(frequencies, bandwidth=40.0, normalize=False): [\n    MASK]\n", "response": "import warnings\nimport numpy as np\n\n\ndef calculate_smoothing_matrix(frequencies, bandwidth=40.0, normalize=False):\n    if bandwidth <= 0:\n        raise ValueError(\"Bandwidth must be greater than 0.\")\n    \n    # Number of frequencies\n    n_freq = len(frequencies)\n    \n    # Initialize the smoothing matrix\n    sm_matrix = np.zeros((n_freq, n_freq), dtype=np.float64)\n    \n    # Calculate the smoothing matrix using the Konno & Ohmachi window method\n    for i in range(n_freq):\n        for j in range(n_freq):\n            # Calculate the distance in log space\n            distance = np.log(frequencies[j] / frequencies[i]) ** 2\n            # Calculate the smoothing value\n            sm_value = np.exp(-distance / (2 * (bandwidth ** 2)))\n            sm_matrix[i, j] = sm_value\n    \n    # Normalize the matrix if required\n    if normalize:\n        sm_matrix /= sm_matrix.sum(axis=1, keepdims=True)\n    \n    return sm_matrix"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_create_stream", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/imaging/tests/test_waveform.py", "method_code_mask": "import numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core.event import read_events\nfrom obspy.core.stream import read\nfrom obspy.core.util import AttribDict\nimport pytest\n\n\ndef _create_stream(starttime, endtime, sampling_rate): [MASK]\n", "response": "import numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core.event import read_events\nfrom obspy.core.stream import read\nfrom obspy.core.util import AttribDict\nimport pytest\n\n\ndef _create_stream(starttime, endtime, sampling_rate):\n    # Calculate the number of samples based on the time frame and sampling rate\n    number_of_samples = int((endtime - starttime) * sampling_rate)\n    \n    # Create a time array for the samples\n    t = np.linspace(0, (endtime - starttime), number_of_samples, endpoint=False)\n    \n    # Create a sine wave with superimposed smaller sine waves\n    main_wave = np.sin(2 * np.pi * 1 * t)  # Main sine wave with frequency of 1 Hz\n    for i in range(1, 11):  # Adding 10 smaller sine waves\n        main_wave += 0.1 * np.sin(2 * np.pi * (i + 1) * t)  # Smaller sine waves with increasing frequency\n    \n    # Create a Trace object\n    trace = Trace()\n    trace.stats.network = \"TEST\"\n    trace.stats.station = \"TEST\"\n    trace.stats.channel = \"TEST\"\n    trace.stats.starttime = starttime\n    trace.stats.sampling_rate = sampling_rate\n    trace.data = main_wave.astype(np.float32)  # Ensure data is in the correct format\n    \n    # Create a Stream object and add the Trace to it\n    stream = Stream(traces=[trace])\n    \n    return stream"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "aic_simple_python", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/tests/test_trigger.py", "method_code_mask": "import gzip\nimport re\nimport warnings\nfrom ctypes import ArgumentError\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom obspy import Stream\nfrom obspy import UTCDateTime\nfrom obspy import read\nfrom obspy.signal.trigger import ar_pick\nfrom obspy.signal.trigger import classic_sta_lta\nfrom obspy.signal.trigger import classic_sta_lta_py\nfrom obspy.signal.trigger import coincidence_trigger\nfrom obspy.signal.trigger import pk_baer\nfrom obspy.signal.trigger import recursive_sta_lta\nfrom obspy.signal.trigger import recursive_sta_lta_py\nfrom obspy.signal.trigger import trigger_onset\nfrom obspy.signal.trigger import aic_simple\nfrom obspy.signal.util import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef aic_simple_python(a): [MASK]\n", "response": "import gzip\nimport re\nimport warnings\nfrom ctypes import ArgumentError\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom obspy import Stream\nfrom obspy import UTCDateTime\nfrom obspy import read\nfrom obspy.signal.trigger import ar_pick\nfrom obspy.signal.trigger import classic_sta_lta\nfrom obspy.signal.trigger import classic_sta_lta_py\nfrom obspy.signal.trigger import coincidence_trigger\nfrom obspy.signal.trigger import pk_baer\nfrom obspy.signal.trigger import recursive_sta_lta\nfrom obspy.signal.trigger import recursive_sta_lta_py\nfrom obspy.signal.trigger import trigger_onset\nfrom obspy.signal.trigger import aic_simple\nfrom obspy.signal.util import clibsignal\nimport matplotlib.pyplot as plt\n\n\ndef aic_simple_python(a):\n    if len(a) <= 2:\n        raise ValueError(\"Input array must have a length greater than 2.\")\n    \n    n = len(a)\n    aic_values = np.zeros(n)\n    \n    for i in range(1, n - 1):\n        left = a[:i]\n        right = a[i:]\n        \n        # Calculate means and variances\n        mean_left = np.mean(left)\n        mean_right = np.mean(right)\n        var_left = np.var(left, ddof=1)\n        var_right = np.var(right, ddof=1)\n        \n        # Number of observations\n        n_left = len(left)\n        n_right = len(right)\n        \n        # Calculate AIC\n        aic_left = n_left * np.log(var_left) + 2 * 1  # 1 parameter for mean\n        aic_right = n_right * np.log(var_right) + 2 * 1  # 1 parameter for mean\n        \n        aic_values[i] = aic_left + aic_right\n    \n    return aic_values"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "traces_almost_equal", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/testing.py", "method_code_mask": "import difflib\nimport doctest\nimport inspect\nimport io\nimport os\nimport re\nimport numpy as np\nfrom lxml import etree\nimport obspy.core.event as ev\nfrom obspy import UTCDateTime\nfrom obspy import Catalog\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.trace import Stats\n\n\ndef traces_almost_equal(tr1, tr2, default_stats=True, rtol=1e-05, atol=\n    1e-08, equal_nan=True): [MASK]\n", "response": "import difflib\nimport doctest\nimport inspect\nimport io\nimport os\nimport re\nimport numpy as np\nfrom lxml import etree\nimport obspy.core.event as ev\nfrom obspy import UTCDateTime\nfrom obspy import Catalog\nfrom obspy.core.stream import Stream\nfrom obspy.core.trace import Trace\nfrom obspy.core.trace import Stats\n\n\ndef traces_almost_equal(tr1, tr2, default_stats=True, rtol=1e-05, atol=1e-08, equal_nan=True):\n    if not isinstance(tr1, Trace) or not isinstance(tr2, Trace):\n        raise ValueError(\"Both inputs must be Trace objects.\")\n\n    # Compare stats\n    if default_stats:\n        stats1 = {key: tr1.stats[key] for key in ['network', 'station', 'location', 'channel', 'starttime', 'sampling_rate']}\n        stats2 = {key: tr2.stats[key] for key in ['network', 'station', 'location', 'channel', 'starttime', 'sampling_rate']}\n    else:\n        stats1 = tr1.stats\n        stats2 = tr2.stats\n\n    if stats1 != stats2:\n        return False\n\n    # Compare data\n    return np.allclose(tr1.data, tr2.data, rtol=rtol, atol=atol, equal_nan=equal_nan)"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "energy_ratio", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/trigger.py", "method_code_mask": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef energy_ratio(a, nsta): [MASK]\n", "response": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef energy_ratio(a, nsta):\n    if nsta <= 0 or nsta > len(a) // 2:\n        raise ValueError(\"nsta must be greater than 0 and less than or equal to half the length of the data array.\")\n    \n    energy_ratios = np.zeros(len(a))\n    \n    for i in range(nsta, len(a)):\n        sum_current_window = np.sum(a[i-nsta:i]**2)\n        sum_previous_window = np.sum(a[i-2*nsta:i-nsta]**2)\n        \n        if sum_previous_window == 0:\n            energy_ratios[i] = 0\n        else:\n            energy_ratios[i] = sum_current_window / sum_previous_window\n            \n    return energy_ratios"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "trigger_onset", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/trigger.py", "method_code_mask": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef trigger_onset(charfct, thres1, thres2, max_len=9e+99, max_len_delete=False\n    ): [MASK]\n", "response": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef trigger_onset(charfct, thres1, thres2, max_len=9e+99, max_len_delete=False):\n    # Initialize variables\n    triggered = False\n    events = []\n    start_time = None\n\n    # Iterate through the characteristic function\n    for i in range(len(charfct)):\n        if charfct[i] >= thres1 and not triggered:\n            # Trigger on\n            triggered = True\n            start_time = i\n        elif charfct[i] <= thres2 and triggered:\n            # Trigger off\n            triggered = False\n            end_time = i\n            event_length = end_time - start_time\n            \n            # Check if the event length exceeds max_len\n            if event_length <= max_len:\n                events.append([start_time, end_time])\n            elif not max_len_delete:\n                events.append([start_time, end_time])  # Include even if it exceeds max_len\n\n    return np.array(events, dtype=np.int64)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "bandpass", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/filter.py", "method_code_mask": "import warnings\nimport numpy as np\nfrom scipy.fftpack import hilbert\nfrom scipy.signal import cheb2ord\nfrom scipy.signal import cheby2\nfrom scipy.signal import convolve\nfrom scipy.signal import get_window\nfrom scipy.signal import iirfilter\nfrom scipy.signal import remez\nfrom scipy.signal import sosfilt\n\n\ndef bandpass(data, freqmin, freqmax, df, corners=4, zerophase=False, rp=\n    None, rs=None, ftype='butter', axis=-1): [MASK]\n", "response": "import warnings\nimport numpy as np\nfrom scipy.fftpack import hilbert\nfrom scipy.signal import cheb2ord\nfrom scipy.signal import cheby2\nfrom scipy.signal import convolve\nfrom scipy.signal import get_window\nfrom scipy.signal import iirfilter\nfrom scipy.signal import remez\nfrom scipy.signal import sosfilt\n\n\ndef bandpass(data, freqmin, freqmax, df, corners=4, zerophase=False, rp=None, rs=None, ftype='butter', axis=-1):\n    # Calculate the Nyquist frequency\n    nyq = 0.5 * df\n    # Normalize the frequencies by the Nyquist frequency\n    low = freqmin / nyq\n    high = freqmax / nyq\n    \n    # Design the filter\n    sos = iirfilter(corners, [low, high], btype='band', ftype=ftype, output='sos', rp=rp, rs=rs)\n    \n    # Apply the filter\n    if zerophase:\n        # Apply the filter forward and backward to eliminate phase shift\n        filtered_data = sosfilt(sos, data, axis=axis)\n        filtered_data = sosfilt(sos, filtered_data[::-1], axis=axis)[::-1]\n    else:\n        filtered_data = sosfilt(sos, data, axis=axis)\n    \n    return filtered_data"}
{"result": "failed: argument of type 'float' is not iterable", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "peak_ground_motion", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/freqattributes.py", "method_code_mask": "from operator import itemgetter\nimport numpy as np\nfrom scipy import fftpack\nfrom scipy import signal\nfrom scipy import sparse\nfrom obspy.signal import util\nfrom obspy.signal.invsim import corn_freq_2_paz\nfrom obspy.signal.invsim import simulate_seismometer\n\n\ndef peak_ground_motion(data, delta, freq, damp=0.1): [MASK]\n", "response": "from operator import itemgetter\nimport numpy as np\nfrom scipy import fftpack\nfrom scipy import signal\nfrom scipy import sparse\nfrom obspy.signal import util\nfrom obspy.signal.invsim import corn_freq_2_paz\nfrom obspy.signal.invsim import simulate_seismometer\n\n\ndef peak_ground_motion(data, delta, freq, damp=0.1):\n    # Compute maximal displacement\n    max_displacement = np.max(np.abs(data))\n    \n    # Compute velocity and acceleration\n    velocity = np.gradient(data, delta)\n    acceleration = np.gradient(velocity, delta)\n    \n    # Compute maximal velocity and acceleration\n    max_velocity = np.max(np.abs(velocity))\n    max_acceleration = np.max(np.abs(acceleration))\n    \n    # Calculate Peak Ground Acceleration (PGA) using a seismometer response\n    paz = corn_freq_2_paz(freq, damp)\n    pga = simulate_seismometer(data, paz, delta)\n    pga = np.max(np.abs(pga))\n    \n    return pga, max_displacement, max_velocity, max_acceleration"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "aic_simple", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/trigger.py", "method_code_mask": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef aic_simple(a): [MASK]\n", "response": "from collections import deque\nimport ctypes as C\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import UTCDateTime\nfrom obspy.signal.cross_correlation import templates_max_similarity\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.headers import head_stalta_t\nimport matplotlib.pyplot as plt\n\n\ndef aic_simple(a):\n    if isinstance(a, list):\n        a = np.array(a)\n    \n    n = len(a)\n    aic = np.zeros(n)\n    \n    for i in range(1, n):\n        residuals = a[:i] - np.mean(a[:i])\n        variance = np.var(residuals)\n        aic[i] = 2 * (i + 1) - 2 * np.log(variance)\n    \n    aic[-1] = aic[-2]  # Duplicate the last element to match the length\n    \n    return aic"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "get_spoint", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/array_analysis.py", "method_code_mask": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef get_spoint(stream, stime, etime): [MASK]\n", "response": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef get_spoint(stream, stime, etime):\n    spoint = np.zeros(len(stream), dtype=int)\n    epoint = np.zeros(len(stream), dtype=int)\n\n    for i, trace in enumerate(stream):\n        # Calculate the start sample offset\n        spoint[i] = int((stime - trace.stats.starttime) / trace.stats.sampling_rate)\n        # Calculate the end sample offset\n        epoint[i] = int((etime - trace.stats.starttime) / trace.stats.sampling_rate)\n\n    return spoint, epoint"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "array_transff_freqslowness", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/array_analysis.py", "method_code_mask": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef array_transff_freqslowness(coords, slim, sstep, fmin, fmax, fstep,\n    coordsys='lonlat'): [MASK]\n", "response": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef array_transff_freqslowness(coords, slim, sstep, fmin, fmax, fstep,\n    coordsys='lonlat'):\n    \n    # Check if slim is a float or a tuple\n    if isinstance(slim, float):\n        sxmin, sxmax, symin, symax = -slim, slim, -slim, slim\n    elif isinstance(slim, (tuple, list)) and len(slim) == 4:\n        sxmin, sxmax, symin, symax = slim\n    else:\n        raise ValueError(\"slim must be a float or a tuple of length 4.\")\n\n    # Create slowness grid\n    sx = np.arange(sxmin, sxmax + sstep, sstep)\n    sy = np.arange(symin, symax + sstep, sstep)\n    Sx, Sy = np.meshgrid(sx, sy)\n    \n    # Create frequency grid\n    f = np.arange(fmin, fmax + fstep, fstep)\n\n    # Calculate the number of stations\n    n_stations = coords.shape[0]\n\n    # Initialize transfer function matrix\n    transff = np.zeros((len(sy), len(sx), len(f)), dtype=np.complex)\n\n    # Calculate the transfer function for each frequency and slowness\n    for i in range(len(f)):\n        for j in range(len(sx)):\n            for k in range(len(sy)):\n                # Calculate the slowness vector\n                slowness_vector = np.array([Sx[k, j], Sy[k, j]])\n                \n                # Calculate the phase shift for each station\n                for station in range(n_stations):\n                    if coordsys == 'lonlat':\n                        # Convert longitude/latitude to radians\n                        lon, lat = np.radians(coords[station, 0]), np.radians(coords[station, 1])\n                        # Calculate distance and phase shift\n                        distance = np.sqrt((lon - np.radians(coords[:, 0]))**2 + (lat - np.radians(coords[:, 1]))**2)\n                    elif coordsys == 'xy':\n                        # Use Cartesian coordinates directly\n                        distance = np.sqrt((coords[station, 0] - coords[:, 0])**2 + (coords[station, 1] - coords[:, 1])**2)\n                    else:\n                        raise ValueError(\"Invalid coordinate system. Use 'lonlat' or 'xy'.\")\n\n                    # Calculate the transfer function value\n                    transff[k, j, i] += np.exp(-1j * 2 * np.pi * f[i] * distance / np.linalg.norm(slowness_vector))\n\n    # Normalize the transfer function\n    transff /= np.max(np.abs(transff))\n\n    return transff"}
{"result": "failed: No module named 'obspy.exceptions'", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_parse_date_time", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/ndk/core.py", "method_code_mask": "import math\nimport re\nimport traceback\nimport uuid\nimport warnings\nfrom itertools import zip_longest\nfrom obspy import UTCDateTime\nfrom obspy.core.event import Axis\nfrom obspy.core.event import Catalog\nfrom obspy.core.event import Comment\nfrom obspy.core.event import CreationInfo\nfrom obspy.core.event import DataUsed\nfrom obspy.core.event import Event\nfrom obspy.core.event import EventDescription\nfrom obspy.core.event import FocalMechanism\nfrom obspy.core.event import Magnitude\nfrom obspy.core.event import MomentTensor\nfrom obspy.core.event import NodalPlane\nfrom obspy.core.event import NodalPlanes\nfrom obspy.core.event import Origin\nfrom obspy.core.event import PrincipalAxes\nfrom obspy.core.event import SourceTimeFunction\nfrom obspy.core.event import Tensor\nfrom obspy.geodetics import FlinnEngdahl\n\n\ndef _parse_date_time(date, time): [MASK]\n", "response": "import math\nimport re\nimport traceback\nimport uuid\nimport warnings\nfrom itertools import zip_longest\nfrom obspy import UTCDateTime\nfrom obspy.core.event import Axis\nfrom obspy.core.event import Catalog\nfrom obspy.core.event import Comment\nfrom obspy.core.event import CreationInfo\nfrom obspy.core.event import DataUsed\nfrom obspy.core.event import Event\nfrom obspy.core.event import EventDescription\nfrom obspy.core.event import FocalMechanism\nfrom obspy.core.event import Magnitude\nfrom obspy.core.event import MomentTensor\nfrom obspy.core.event import NodalPlane\nfrom obspy.core.event import NodalPlanes\nfrom obspy.core.event import Origin\nfrom obspy.core.event import PrincipalAxes\nfrom obspy.core.event import SourceTimeFunction\nfrom obspy.core.event import Tensor\nfrom obspy.geodetics import FlinnEngdahl\nfrom obspy.exceptions import ObsPyNDKException\n\ndef _parse_date_time(date, time):\n    # Replace 60 seconds with 00 seconds and increment the minute\n    if '60' in time:\n        time = re.sub(r'60', '00', time)\n        time_parts = time.split(':')\n        if len(time_parts) == 3:\n            time_parts[1] = str(int(time_parts[1]) + 1).zfill(2)\n        time = ':'.join(time_parts)\n\n    # Combine date and time into a single string\n    date_time_str = f\"{date} {time}\"\n\n    try:\n        # Parse the combined date and time string into a UTCDateTime object\n        utc_time = UTCDateTime(date_time_str)\n    except Exception as e:\n        raise ObsPyNDKException(f\"Could not parse date and time: {e}\")\n\n    return utc_time"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "array_transff_wavenumber", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/array_analysis.py", "method_code_mask": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef array_transff_wavenumber(coords, klim, kstep, coordsys='lonlat'): [MASK]\n", "response": "import math\nimport warnings\nfrom matplotlib.dates import datestr2num\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom obspy.core import Stream\nfrom obspy.signal.headers import clibsignal\nfrom obspy.signal.invsim import cosine_taper\nfrom obspy.signal.util import next_pow_2\nfrom obspy.signal.util import util_geo_km\n\n\ndef array_transff_wavenumber(coords, klim, kstep, coordsys='lonlat'):\n    # Check if coords is a numpy array\n    if not isinstance(coords, np.ndarray) or coords.ndim != 2 or coords.shape[1] != 3:\n        raise ValueError(\"coords must be a numpy.ndarray of shape (N, 3)\")\n\n    # Determine the wavenumber limits\n    if isinstance(klim, (int, float)):\n        kxmin = -klim\n        kxmax = klim\n        kymin = -klim\n        kymax = klim\n    elif isinstance(klim, (tuple, list)) and len(klim) == 4:\n        kxmin, kxmax, kymin, kymax = klim\n    else:\n        raise ValueError(\"klim must be a float or a tuple of (kxmin, kxmax, kymin, kymax)\")\n\n    # Create wavenumber grids\n    kx = np.arange(kxmin, kxmax + kstep, kstep)\n    ky = np.arange(kymin, kymax + kstep, kstep)\n    nkx = len(kx)\n    nky = len(ky)\n\n    # Initialize the transfer function array\n    transff = np.zeros((nkx, nky), dtype=np.complex)\n\n    # Calculate the array transfer function\n    for i in range(nkx):\n        for j in range(nky):\n            k = np.array([kx[i], ky[j]])\n            if coordsys == 'lonlat':\n                # Convert longitude/latitude to radians\n                coords_rad = np.radians(coords[:, :2])\n                # Calculate the array response\n                response = np.exp(-1j * np.dot(coords_rad, k))\n            elif coordsys == 'xy':\n                # Use the coordinates directly\n                response = np.exp(-1j * np.dot(coords, k))\n            else:\n                raise ValueError(\"coordsys must be 'lonlat' or 'xy'\")\n            \n            # Store the average response in the transfer function\n            transff[i, j] = np.mean(response)\n\n    return transff"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "lowpass_cheby_2", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/filter.py", "method_code_mask": "import warnings\nimport numpy as np\nfrom scipy.fftpack import hilbert\nfrom scipy.signal import cheb2ord\nfrom scipy.signal import cheby2\nfrom scipy.signal import convolve\nfrom scipy.signal import get_window\nfrom scipy.signal import iirfilter\nfrom scipy.signal import remez\nfrom scipy.signal import sosfilt\n\n\ndef lowpass_cheby_2(data, freq, df, maxorder=12, ba=False, freq_passband=False\n    ): [MASK]\n", "response": "import warnings\nimport numpy as np\nfrom scipy.fftpack import hilbert\nfrom scipy.signal import cheb2ord\nfrom scipy.signal import cheby2\nfrom scipy.signal import convolve\nfrom scipy.signal import get_window\nfrom scipy.signal import iirfilter\nfrom scipy.signal import remez\nfrom scipy.signal import sosfilt\n\ndef lowpass_cheby_2(data, freq, df, maxorder=12, ba=False, freq_passband=False):\n    # Calculate the Nyquist frequency\n    nyquist = 0.5 * df\n    \n    # Normalize the stop frequency\n    normalized_stop_freq = freq / nyquist\n    \n    # Determine the order and natural frequency of the filter\n    order, wn = cheb2ord(normalized_stop_freq, normalized_stop_freq + 0.1, 1, 96, fs=df)\n    order = min(order, maxorder)  # Ensure the order does not exceed maxorder\n    \n    # Design the Chebyshev Type II filter\n    b, a = cheby2(order, 96, wn, btype='low', analog=False, fs=df)\n    \n    if ba:\n        return b, a\n    \n    # Apply the filter to the data\n    filtered_data = sosfilt(np.array([b, a]), data)\n    \n    # Calculate the passband edge frequency\n    passband_edge_freq = wn * nyquist\n    \n    if freq_passband:\n        return filtered_data, passband_edge_freq\n    \n    return filtered_data"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_find_peaks", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef _find_peaks(data, height, holdon_samples, holdoff_samples): [MASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef _find_peaks(data, height, holdon_samples, holdoff_samples):\n    # Ensure data is a numpy array\n    data = np.asarray(data)\n    \n    # Find peaks using scipy's find_peaks function\n    peaks, properties = find_peaks(data, height=height)\n    \n    # Initialize a list to hold the indices of detected peaks\n    detections_index = []\n    \n    # Iterate through the detected peaks\n    for peak in peaks:\n        # Check if the peak is already accounted for by holdon_samples\n        if not detections_index or peak > detections_index[-1] + holdoff_samples:\n            detections_index.append(peak)\n            # Skip the next holdon_samples to avoid detecting multiple peaks\n            peak += holdon_samples\n            \n    return detections_index"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "from_buffer", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/compatibility.py", "method_code_mask": "import numpy as np\n\n\ndef from_buffer(data, dtype): [MASK]\n", "response": "import numpy as np\n\n\ndef from_buffer(data, dtype):\n    if isinstance(data, str):\n        data = data.encode('utf-8')\n    elif not isinstance(data, (bytes, bytearray)):\n        raise TypeError(\"Input data must be a bytes-like object or a string.\")\n\n    return np.frombuffer(memoryview(data), dtype=dtype)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_read_segy", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/segy/core.py", "method_code_mask": "import warnings\nfrom copy import deepcopy\nfrom struct import unpack\nimport numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core import AttribDict\nimport doctest\n\n\ndef _read_segy(filename, headonly=False, byteorder=None,\n    textual_header_encoding=None, unpack_trace_headers=False, **kwargs): [MASK]\n", "response": "import warnings\nfrom copy import deepcopy\nfrom struct import unpack\nimport numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core import AttribDict\nimport doctest\n\ndef _read_segy(filename, headonly=False, byteorder=None,\n    textual_header_encoding=None, unpack_trace_headers=False, **kwargs):\n    \n    # Open the SEG Y file\n    with open(filename, 'rb') as f:\n        # Read the textual header\n        textual_header = f.read(3200)\n        if textual_header_encoding is None:\n            # Attempt to autodetect encoding\n            if b'EBCDIC' in textual_header:\n                textual_header_encoding = 'EBCDIC'\n            else:\n                textual_header_encoding = 'ASCII'\n        \n        if textual_header_encoding == 'EBCDIC':\n            # Convert EBCDIC to ASCII\n            textual_header = textual_header.decode('cp500')  # EBCDIC to ASCII\n        else:\n            textual_header = textual_header.decode('ascii', errors='ignore')\n        \n        # Read the binary header\n        binary_header = f.read(400)\n        if byteorder is None:\n            # Attempt to autodetect byte order\n            if unpack('>h', binary_header[0:2])[0] == 1:\n                byteorder = '>'\n            else:\n                byteorder = '<'\n        \n        # Unpack binary header\n        bh_values = unpack(byteorder + 'hh', binary_header[0:4])  # Example unpacking\n        \n        # Initialize Stream object\n        stream = Stream()\n        \n        # Read traces\n        while True:\n            trace_header = f.read(240)  # Read trace header\n            if not trace_header:\n                break  # End of file\n            \n            # Unpack trace header\n            th_values = unpack(byteorder + 'hh', trace_header[0:4])  # Example unpacking\n            \n            if headonly:\n                continue  # Skip reading waveform data\n            \n            # Read waveform data\n            data = f.read(th_values[1])  # Example: read based on trace header\n            \n            # Create Trace object\n            trace = Trace()\n            trace.stats.network = 'ExampleNetwork'\n            trace.stats.station = 'ExampleStation'\n            trace.stats.starttime = UTCDateTime()  # Example start time\n            trace.data = np.frombuffer(data, dtype=np.float32)  # Example data type\n            \n            # Add trace to stream\n            stream.append(trace)\n        \n        return stream"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_nortoevmag", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/nordic/utils.py", "method_code_mask": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _nortoevmag(mag_type): [MASK]\n", "response": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _nortoevmag(mag_type):\n    \"\"\"\n    Convert Nordic magnitude types to ObsPy event magnitude types.\n\n    Parameters:\n    mag_type (str): The magnitude type in Nordic format.\n\n    Returns:\n    str: The equivalent magnitude type in ObsPy event format or an empty string if not convertible.\n\n    >>> _nortoevmag('ML')  # Local magnitude\n    'ML'\n    >>> _nortoevmag('mb')  # Body-wave magnitude\n    'MB'\n    >>> _nortoevmag('Ms')  # Surface-wave magnitude\n    'MS'\n    >>> _nortoevmag('Mw')  # Moment magnitude\n    'MW'\n    >>> _nortoevmag('unknown')  # Unknown type\n    ''\n    \"\"\"\n    nordic_to_obspy = {\n        'ML': 'ML',\n        'mb': 'MB',\n        'Ms': 'MS',\n        'Mw': 'MW'\n    }\n\n    if mag_type in nordic_to_obspy:\n        return nordic_to_obspy[mag_type]\n    else:\n        warnings.warn(f\"Unknown magnitude type: {mag_type}\")\n        return ''"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "correlate_stream_template", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate_stream_template(stream, template, template_time=None, **kwargs\n    ): [MASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate_stream_template(stream, template, template_time=None, **kwargs):\n    if template_time is None:\n        template_time = template[0].stats.starttime\n\n    # Prepare the output stream\n    output_stream = Stream()\n\n    for data_trace in stream:\n        # Check if the seed ID matches\n        if data_trace.stats.network == template[0].stats.network and \\\n           data_trace.stats.station == template[0].stats.station and \\\n           data_trace.stats.location == template[0].stats.location and \\\n           data_trace.stats.channel == template[0].stats.channel:\n\n            # Cross-correlate the data trace with the template\n            correlation = np.correlate(data_trace.data, template[0].data, mode='full')\n\n            # Create a new trace for the output stream\n            new_trace = Trace()\n            new_trace.data = correlation\n            new_trace.stats = copy(data_trace.stats)\n\n            # Adjust the start time based on the template time\n            new_trace.stats.starttime = data_trace.stats.starttime - (template_time - template[0].stats.starttime)\n            new_trace.stats.npts = len(correlation)\n\n            # Append the new trace to the output stream\n            output_stream.append(new_trace)\n\n    return output_stream"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "util_lon_lat", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/util.py", "method_code_mask": "import ctypes as C\nimport math\nimport numpy as np\nfrom scipy import fftpack\nfrom scipy import signal\nfrom obspy.core.util.misc import factorize_int\nfrom obspy.signal.headers import clibsignal\nfrom scipy.signal import hilbert\nfrom scipy.fftpack import next_fast_len\nimport doctest\n\n\ndef util_lon_lat(orig_lon, orig_lat, x, y): [MASK]\n", "response": "import ctypes as C\nimport math\nimport numpy as np\nfrom scipy import fftpack\nfrom scipy import signal\nfrom obspy.core.util.misc import factorize_int\nfrom obspy.signal.headers import clibsignal\nfrom scipy.signal import hilbert\nfrom scipy.fftpack import next_fast_len\nimport doctest\n\n\ndef util_lon_lat(orig_lon, orig_lat, x, y):\n    # Constants for Earth's radius in kilometers\n    R = 6371.0  # Earth's radius in kilometers\n\n    # Calculate the change in latitude and longitude\n    delta_lat = y / R * (180 / math.pi)  # Convert radians to degrees\n    delta_lon = x / (R * math.cos(math.pi * orig_lat / 180)) * (180 / math.pi)  # Convert radians to degrees\n\n    # Calculate the new latitude and longitude\n    lat = orig_lat + delta_lat\n    lon = orig_lon + delta_lon\n\n    return lon, lat"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_convert_datetime_to_mstime", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/mseed/util.py", "method_code_mask": "import collections\nimport ctypes as C\nimport os\nfrom pathlib import Path\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom struct import pack\nfrom struct import unpack\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core.compatibility import from_buffer\nfrom obspy.core.util.decorator import ObsPyDeprecationWarning\nimport doctest\n\n\ndef _convert_datetime_to_mstime(dt): [MASK]\n", "response": "import collections\nimport ctypes as C\nimport os\nfrom pathlib import Path\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom struct import pack\nfrom struct import unpack\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core.compatibility import from_buffer\nfrom obspy.core.util.decorator import ObsPyDeprecationWarning\nimport doctest\n\n\ndef _convert_datetime_to_mstime(dt):\n    \"\"\"\n    Convert an obspy.util.UTCDateTime object to milliseconds since the Unix epoch.\n\n    Parameters:\n    dt (UTCDateTime): The UTCDateTime object to convert.\n\n    Returns:\n    int: The number of milliseconds since the Unix epoch.\n    \n    Example:\n    >>> dt = UTCDateTime(2023, 10, 1, 12, 0, 0)\n    >>> _convert_datetime_to_mstime(dt)\n    1696166400000\n    \"\"\"\n    # Get the number of seconds since the Unix epoch and convert to milliseconds\n    return int(dt.timestamp * 1000 + round(dt._ns / 1_000_000))"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_evmagtonor", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/nordic/utils.py", "method_code_mask": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _evmagtonor(mag_type): [MASK]\n", "response": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _evmagtonor(mag_type):\n    \"\"\"\n    Convert earthquake magnitude types from ObsPy to Seisan format.\n\n    Parameters:\n    mag_type (str): The magnitude type as recognized by ObsPy.\n\n    Returns:\n    str: The converted magnitude type in Seisan's syntax.\n    \"\"\"\n    if mag_type in ['mB', 'mb', 'mbLg']:\n        return 'B'\n    elif mag_type in ['ML', 'ml']:\n        return 'L'\n    elif mag_type in ['Ms', 'ms']:\n        return 'S'\n    elif mag_type in ['Mw', 'M']:\n        warnings.warn(\"Converting 'M' to 'W' for moment magnitude.\")\n        return 'W'\n    elif mag_type is None:\n        warnings.warn(\"Converting None to 'W' for moment magnitude.\")\n        return 'W'\n    else:\n        warnings.warn(f\"Unknown magnitude type '{mag_type}' is not convertible.\")\n        return ' '"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_float_conv", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/nordic/utils.py", "method_code_mask": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _float_conv(string): [MASK]\n", "response": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _float_conv(string):\n    if string == \"\":\n        return None\n    try:\n        return float(string)\n    except ValueError:\n        return None"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_convert_flags_to_raw_byte", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/mseed/util.py", "method_code_mask": "import collections\nimport ctypes as C\nimport os\nfrom pathlib import Path\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom struct import pack\nfrom struct import unpack\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core.compatibility import from_buffer\nfrom obspy.core.util.decorator import ObsPyDeprecationWarning\nimport doctest\n\n\ndef _convert_flags_to_raw_byte(expected_flags, user_flags, recstart, recend): [\n    MASK]\n", "response": "import collections\nimport ctypes as C\nimport os\nfrom pathlib import Path\nimport sys\nimport warnings\nfrom datetime import datetime\nfrom struct import pack\nfrom struct import unpack\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core.compatibility import from_buffer\nfrom obspy.core.util.decorator import ObsPyDeprecationWarning\nimport doctest\n\n\ndef _convert_flags_to_raw_byte(expected_flags, user_flags, recstart, recend):\n    raw_byte = 0\n    for bit_position, flag_name in expected_flags.items():\n        if flag_name in user_flags:\n            flag_value = user_flags[flag_name]\n            if isinstance(flag_value, bool):\n                if flag_value:\n                    raw_byte |= (1 << bit_position)\n            elif isinstance(flag_value, (list, tuple)):\n                # Assuming flag_value is a sequence of tuples (start, end)\n                for start, end in flag_value:\n                    if recstart >= start and recend <= end:\n                        raw_byte |= (1 << bit_position)\n    return raw_byte"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_str_conv", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/nordic/utils.py", "method_code_mask": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _str_conv(number, rounded=False): [MASK]\n", "response": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _str_conv(number, rounded=False):\n    if number is None:\n        return \"\"\n    \n    if rounded:\n        number = round(number)\n    \n    if abs(number) < 100000:\n        return str(number)\n    else:\n        return \"{:.1e}\".format(number)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "utcdatetime_to_sac_nztimes", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/sac/util.py", "method_code_mask": "import sys\nimport warnings\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core import Stats\n\n\ndef utcdatetime_to_sac_nztimes(utcdt): [MASK]\n", "response": "import sys\nimport warnings\nimport numpy as np\nfrom obspy import UTCDateTime\nfrom obspy.core import Stats\n\n\ndef utcdatetime_to_sac_nztimes(utcdt):\n    # Convert UTCDateTime to New Zealand time\n    nzyear = utcdt.year\n    nzjday = utcdt.julday\n    nzhour = utcdt.hour\n    nzmin = utcdt.minute\n    nzsec = utcdt.second\n    nzmsec = utcdt.microsecond // 1000  # Convert microseconds to milliseconds\n    microsecond = utcdt.microsecond % 1000  # Get the remaining microseconds\n\n    nztimes = {\n        'nzyear': nzyear,\n        'nzjday': nzjday,\n        'nzhour': nzhour,\n        'nzmin': nzmin,\n        'nzsec': nzsec,\n        'nzmsec': nzmsec\n    }\n\n    return nztimes, microsecond"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_int_conv", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/nordic/utils.py", "method_code_mask": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _int_conv(string): [MASK]\n", "response": "import warnings\nfrom collections import defaultdict\nfrom obspy.io.nordic import NordicParsingError\nfrom obspy.geodetics.base import kilometers2degrees\nfrom numpy import cos\nfrom numpy import radians\nimport doctest\n\n\ndef _int_conv(string):\n    if string.strip() == \"\":\n        return None\n    try:\n        return int(string)\n    except ValueError:\n        return None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "to_tag", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/xseed/utils.py", "method_code_mask": "import warnings\nfrom obspy import UTCDateTime\n\n\ndef to_tag(name): [MASK]\n", "response": "import warnings\nfrom obspy import UTCDateTime\n\n\ndef to_tag(name):\n    # Convert the entire string to lowercase\n    name = name.lower()\n    # Replace spaces with underscores\n    name = name.replace(\" \", \"_\")\n    # Replace specific prefixes with their uppercase equivalents\n    name = name.replace(\"fir_\", \"FIR_\")\n    name = name.replace(\"a0_\", \"A0_\")\n    return name"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_determine_dtype", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/ascii/core.py", "method_code_mask": "import io\nimport numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core import Stats\nfrom obspy.core.util import AttribDict\nimport doctest\n\n\ndef _determine_dtype(custom_fmt): [MASK]\n", "response": "import io\nimport numpy as np\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy import UTCDateTime\nfrom obspy.core import Stats\nfrom obspy.core.util import AttribDict\nimport doctest\n\n\ndef _determine_dtype(custom_fmt):\n    if not custom_fmt:\n        raise ValueError(\"Input string cannot be empty.\")\n    \n    if custom_fmt[-1] in ('d', 'i'):\n        return 'INTEGER'\n    elif custom_fmt[-1] in ('e', 'f', 'g'):\n        return 'FLOAT'\n    else:\n        return 'CUSTOM'"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "ptp", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/misc.py", "method_code_mask": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef ptp(a, *args, **kwargs): [MASK]\n", "response": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef ptp(a, *args, **kwargs):\n    if isinstance(a, np.ma.MaskedArray):\n        return a.max() - a.min()\n    elif isinstance(a, np.ndarray):\n        return a.ptp(*args, **kwargs)\n    else:\n        raise TypeError(\"Input must be a numpy array or a masked numpy array.\")"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_is_rg16", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/rg16/core.py", "method_code_mask": "from collections import namedtuple\nimport numpy as np\nfrom obspy.core import Stream\nfrom obspy.core import Trace\nfrom obspy.core import Stats\nfrom obspy.core import UTCDateTime\nfrom obspy.io.rg16.util import _read\nfrom obspy.io.rg16.util import _open_file\nfrom obspy.io.rg16.util import _quick_merge\nimport doctest\n\n\n@_open_file\ndef _is_rg16(filename, **kwargs): [MASK]\n", "response": "from collections import namedtuple\nimport numpy as np\nfrom obspy.core import Stream\nfrom obspy.core import Trace\nfrom obspy.core import Stats\nfrom obspy.core import UTCDateTime\nfrom obspy.io.rg16.util import _read\nfrom obspy.io.rg16.util import _open_file\nfrom obspy.io.rg16.util import _quick_merge\nimport doctest\n\n\n@_open_file\ndef _is_rg16(filename, **kwargs):\n    # Read the first 4 bytes of the file\n    header = filename.read(4)\n    \n    # Check if the header matches the RG16 format signature\n    if header == b'RG16':\n        return True\n    else:\n        return False"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "rotate_ne_rt", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/rotate.py", "method_code_mask": "import warnings\nfrom math import cos\nfrom math import sin\nfrom math import radians\nimport numpy as np\nimport doctest\n\n\ndef rotate_ne_rt(n, e, ba): [MASK]\n", "response": "import warnings\nfrom math import cos\nfrom math import sin\nfrom math import radians\nimport numpy as np\nimport doctest\n\n\ndef rotate_ne_rt(n, e, ba):\n    \"\"\"\n    Rotate the North and East components of a seismogram into Radial and Transversal components\n    based on the back-azimuth from station to source.\n\n    Parameters:\n    n : numpy.ndarray\n        The North component of the seismogram.\n    e : numpy.ndarray\n        The East component of the seismogram.\n    ba : float\n        The back azimuth from station to source in degrees.\n\n    Returns:\n    r : numpy.ndarray\n        The Radial component of the seismogram after rotation.\n    t : numpy.ndarray\n        The Transversal component of the seismogram after rotation.\n\n    >>> n = np.array([1, 2, 3])\n    >>> e = np.array([4, 5, 6])\n    >>> ba = 45\n    >>> r, t = rotate_ne_rt(n, e, ba)\n    >>> np.allclose(r, [3.535898, 5.303300, 7.071068])\n    True\n    >>> np.allclose(t, [-1.414214, -1.414214, -1.414214])\n    True\n    \"\"\"\n    # Convert back azimuth from degrees to radians\n    ba_rad = radians(ba)\n\n    # Calculate the rotation matrix components\n    r = n * cos(ba_rad) + e * sin(ba_rad)\n    t = -n * sin(ba_rad) + e * cos(ba_rad)\n\n    return r, t"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_parse_list_of_complex_string", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/seiscomp/inventory.py", "method_code_mask": "import math\nimport re\nimport warnings\nfrom lxml import etree\nimport numpy as np\nfrom scipy.signal import tf2zpk\nimport obspy\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.inventory import Azimuth\nfrom obspy.core.inventory import ClockDrift\nfrom obspy.core.inventory import Dip\nfrom obspy.core.inventory import Distance\nfrom obspy.core.inventory import Frequency\nfrom obspy.core.inventory import Latitude\nfrom obspy.core.inventory import Longitude\nfrom obspy.core.inventory import SampleRate\nfrom obspy.core.inventory.response import CoefficientsTypeResponseStage\nfrom obspy.core.inventory.response import FilterCoefficient\nfrom obspy.core.inventory.response import FIRResponseStage\nfrom obspy.core.inventory.response import PolesZerosResponseStage\nfrom obspy.core.inventory.response import PolynomialResponseStage\nfrom obspy.core.inventory.response import ResponseListElement\nfrom obspy.core.inventory.response import ResponseListResponseStage\nfrom obspy.io.stationxml.core import _read_floattype\n\n\ndef _parse_list_of_complex_string(complex_string): [MASK]\n", "response": "import math\nimport re\nimport warnings\nfrom lxml import etree\nimport numpy as np\nfrom scipy.signal import tf2zpk\nimport obspy\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.inventory import Azimuth\nfrom obspy.core.inventory import ClockDrift\nfrom obspy.core.inventory import Dip\nfrom obspy.core.inventory import Distance\nfrom obspy.core.inventory import Frequency\nfrom obspy.core.inventory import Latitude\nfrom obspy.core.inventory import Longitude\nfrom obspy.core.inventory import SampleRate\nfrom obspy.core.inventory.response import CoefficientsTypeResponseStage\nfrom obspy.core.inventory.response import FilterCoefficient\nfrom obspy.core.inventory.response import FIRResponseStage\nfrom obspy.core.inventory.response import PolesZerosResponseStage\nfrom obspy.core.inventory.response import PolynomialResponseStage\nfrom obspy.core.inventory.response import ResponseListElement\nfrom obspy.core.inventory.response import ResponseListResponseStage\nfrom obspy.io.stationxml.core import _read_floattype\n\n\ndef _parse_list_of_complex_string(complex_string):\n    # Count the expected number of complex numbers\n    expected_count = complex_string.count('(')\n    \n    # Use regex to find all complex numbers in the format (real,imag)\n    complex_pattern = r'\\(([^,]+),([^,]+)\\)'\n    matches = re.findall(complex_pattern, complex_string)\n    \n    # Convert matches to a list of complex numbers (tuples)\n    complex_numbers = [(float(real), float(imag)) for real, imag in matches]\n    \n    # Check if the number of parsed complex numbers matches the expected count\n    if len(complex_numbers) != expected_count:\n        raise ValueError(f\"Expected {expected_count} complex numbers, but found {len(complex_numbers)}.\")\n    \n    return complex_numbers"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "datetime_2_string", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/xseed/utils.py", "method_code_mask": "import warnings\nfrom obspy import UTCDateTime\n\n\ndef datetime_2_string(dt, compact=False): [MASK]\n", "response": "import warnings\nfrom obspy import UTCDateTime\n\n\ndef datetime_2_string(dt, compact=False):\n    if isinstance(dt, str) and dt.strip() == \"\":\n        return \"\"\n    \n    try:\n        if isinstance(dt, str):\n            dt = UTCDateTime(dt)\n        elif not isinstance(dt, UTCDateTime):\n            raise Exception(\"Invalid datetime passed.\")\n    except Exception as e:\n        raise Exception(f\"Invalid datetime passed: {e}\")\n\n    if compact:\n        return dt.strftime(\"%Y%m%dT%H%M%S.%f\")[:-3] + \"Z\"\n    else:\n        return dt.strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\""}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "inside_geobounds", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/geodetics/base.py", "method_code_mask": "import math\nimport warnings\nimport numpy as np\nfrom obspy.core.util.misc import to_int_or_zero\nimport geographiclib\nfrom geographiclib.geodesic import Geodesic\nfrom scipy.stats import circmean\nimport doctest\n\n\ndef inside_geobounds(obj, minlatitude=None, maxlatitude=None, minlongitude=\n    None, maxlongitude=None, latitude=None, longitude=None, minradius=None,\n    maxradius=None): [MASK]\n", "response": "import math\nimport warnings\nimport numpy as np\nfrom obspy.core.util.misc import to_int_or_zero\nimport geographiclib\nfrom geographiclib.geodesic import Geodesic\nfrom scipy.stats import circmean\nimport doctest\n\n\ndef inside_geobounds(obj, minlatitude=None, maxlatitude=None, minlongitude=None, \n                     maxlongitude=None, latitude=None, longitude=None, \n                     minradius=None, maxradius=None):\n    # Check if the object has latitude and longitude attributes\n    if not hasattr(obj, 'latitude') or not hasattr(obj, 'longitude'):\n        raise ValueError(\"Object must have 'latitude' and 'longitude' attributes.\")\n\n    obj_lat = obj.latitude\n    obj_lon = obj.longitude\n\n    # Check latitude bounds\n    if minlatitude is not None and obj_lat < minlatitude:\n        return False\n    if maxlatitude is not None:\n        if maxlatitude < minlatitude:\n            maxlatitude += 360  # Adjust maxlatitude if it wraps around\n        if obj_lat > maxlatitude:\n            return False\n\n    # Check longitude bounds\n    if minlongitude is not None and obj_lon < minlongitude:\n        return False\n    if maxlongitude is not None and obj_lon > maxlongitude:\n        return False\n\n    # Check distance from reference point if provided\n    if latitude is not None and longitude is not None:\n        # Calculate distance using the Geodesic library\n        geod = Geodesic.WGS84\n        distance = geod.Inverse(obj_lat, obj_lon, latitude, longitude)['s12'] / 1000  # Convert to kilometers\n\n        if minradius is not None and distance < minradius:\n            return False\n        if maxradius is not None and distance > maxradius:\n            return False\n\n    return True"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "_count_complex", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/io/seiscomp/inventory.py", "method_code_mask": "import math\nimport re\nimport warnings\nfrom lxml import etree\nimport numpy as np\nfrom scipy.signal import tf2zpk\nimport obspy\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.inventory import Azimuth\nfrom obspy.core.inventory import ClockDrift\nfrom obspy.core.inventory import Dip\nfrom obspy.core.inventory import Distance\nfrom obspy.core.inventory import Frequency\nfrom obspy.core.inventory import Latitude\nfrom obspy.core.inventory import Longitude\nfrom obspy.core.inventory import SampleRate\nfrom obspy.core.inventory.response import CoefficientsTypeResponseStage\nfrom obspy.core.inventory.response import FilterCoefficient\nfrom obspy.core.inventory.response import FIRResponseStage\nfrom obspy.core.inventory.response import PolesZerosResponseStage\nfrom obspy.core.inventory.response import PolynomialResponseStage\nfrom obspy.core.inventory.response import ResponseListElement\nfrom obspy.core.inventory.response import ResponseListResponseStage\nfrom obspy.io.stationxml.core import _read_floattype\n\n\ndef _count_complex(complex_string): [MASK]\n", "response": "import math\nimport re\nimport warnings\nfrom lxml import etree\nimport numpy as np\nfrom scipy.signal import tf2zpk\nimport obspy\nfrom obspy.core.util.obspy_types import ComplexWithUncertainties\nfrom obspy.core.util.obspy_types import FloatWithUncertaintiesAndUnit\nfrom obspy.core.inventory import Azimuth\nfrom obspy.core.inventory import ClockDrift\nfrom obspy.core.inventory import Dip\nfrom obspy.core.inventory import Distance\nfrom obspy.core.inventory import Frequency\nfrom obspy.core.inventory import Latitude\nfrom obspy.core.inventory import Longitude\nfrom obspy.core.inventory import SampleRate\nfrom obspy.core.inventory.response import CoefficientsTypeResponseStage\nfrom obspy.core.inventory.response import FilterCoefficient\nfrom obspy.core.inventory.response import FIRResponseStage\nfrom obspy.core.inventory.response import PolesZerosResponseStage\nfrom obspy.core.inventory.response import PolynomialResponseStage\nfrom obspy.core.inventory.response import ResponseListElement\nfrom obspy.core.inventory.response import ResponseListResponseStage\nfrom obspy.io.stationxml.core import _read_floattype\n\n\ndef _count_complex(complex_string):\n    # Check for valid format\n    if not isinstance(complex_string, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    # Remove whitespace and check for balanced parentheses\n    complex_string = complex_string.replace(\" \", \"\")\n    if complex_string.count('(') != complex_string.count(')'):\n        raise ValueError(\"Invalid format: unbalanced parentheses.\")\n    \n    # Split the string by commas, but only at the top level\n    complex_numbers = re.split(r',(?=(?:[^(]*\\([^)]*\\))*[^()]*$)', complex_string)\n    \n    # Validate each complex number\n    for number in complex_numbers:\n        if not re.match(r'^\\(-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?\\)$', number):\n            raise ValueError(f\"Invalid format for complex number: {number}\")\n    \n    return len(complex_numbers)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "get_window_times", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/util/misc.py", "method_code_mask": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef get_window_times(starttime, endtime, window_length, step, offset,\n    include_partial_windows): [MASK]\n", "response": "import contextlib\nimport inspect\nimport io\nimport itertools\nimport math\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom subprocess import STDOUT\nfrom subprocess import CalledProcessError\nfrom subprocess import check_output\nimport numpy as np\nfrom pkg_resources import load_entry_point\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.core.event import ResourceIdentifier\nimport doctest\n\n\ndef get_window_times(starttime, endtime, window_length, step, offset,\n    include_partial_windows):\n    windows = []\n    current_start = starttime + offset\n\n    while current_start < endtime:\n        current_end = current_start + window_length\n        \n        if current_end > endtime:\n            if include_partial_windows and (endtime - current_start) >= (0.999 * window_length):\n                windows.append((current_start, endtime))\n            break\n        \n        windows.append((current_start, current_end))\n        current_start += step\n\n    return windows"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "correlate", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate(a, b, shift, demean=True, normalize='naive', method='auto'): [M\n    ASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate(a, b, shift, demean=True, normalize='naive', method='auto'):\n    if isinstance(a, Trace):\n        a = a.data\n    if isinstance(b, Trace):\n        b = b.data\n\n    if demean:\n        a -= np.mean(a)\n        b -= np.mean(b)\n\n    if method == 'auto':\n        method = 'fft' if len(a) > 1000 else 'direct'\n\n    if method == 'direct':\n        cross_correlation = np.correlate(a, b, mode='full')\n    elif method == 'fft':\n        n = len(a) + len(b) - 1\n        A = np.fft.fft(a, n=n)\n        B = np.fft.fft(b, n=n)\n        cross_correlation = np.fft.ifft(A * np.conj(B)).real\n    else:\n        raise ValueError(\"Method must be 'direct', 'fft', or 'auto'.\")\n\n    if normalize == 'naive':\n        std_a = np.std(a)\n        std_b = np.std(b)\n        if std_a > 0 and std_b > 0:\n            cross_correlation /= (std_a * std_b)\n\n    return cross_correlation[len(a) - 1 - shift: len(a) - 1 + shift + 1]"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "xcorr_max", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef xcorr_max(fct, abs_max=True): [MASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef xcorr_max(fct, abs_max=True):\n    \"\"\"\n    Returns the shift and value of the maximum of a given cross-correlation function.\n\n    Parameters:\n    fct : numpy.ndarray\n        The cross-correlation function.\n    abs_max : bool, optional\n        If True, returns the largest absolute value of the correlation function,\n        irrespective of its sign. If False, returns the largest positive value only.\n\n    Returns:\n    tuple\n        A tuple containing the shift and the value of the maximum point in the\n        cross-correlation function.\n    \"\"\"\n    if abs_max:\n        # Find the index of the maximum absolute value\n        index = np.argmax(np.abs(fct))\n    else:\n        # Find the index of the maximum value\n        index = np.argmax(fct)\n\n    # Calculate the shift relative to the midpoint\n    shift = index - (len(fct) // 2)\n    value = fct[index]\n\n    return shift, value"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "correlate_template", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/signal/cross_correlation.py", "method_code_mask": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate_template(data, template, mode='valid', normalize='full',\n    demean=True, method='auto'): [MASK]\n", "response": "from bisect import bisect_left\nfrom copy import copy\nimport warnings\nimport numpy as np\nimport scipy\nfrom obspy import Stream\nfrom obspy import Trace\nfrom obspy.core.util.misc import MatplotlibBackend\nfrom obspy.signal.invsim import cosine_taper\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom obspy.imaging.util import _set_xaxis_obspy_dates\nimport doctest\n\n\ndef correlate_template(data, template, mode='valid', normalize='full',\n    demean=True, method='auto'):\n    \n    # Convert ObsPy Trace objects to numpy arrays if necessary\n    if isinstance(data, Trace):\n        data = data.data\n    if isinstance(template, Trace):\n        template = template.data\n\n    # Check if template length is valid\n    if len(template) > len(data):\n        raise ValueError(\"Template length must be less than or equal to data length.\")\n\n    # Demean the data if required\n    if demean:\n        data_mean = np.mean(data)\n        template_mean = np.mean(template)\n        data = data - data_mean\n        template = template - template_mean\n\n    # Choose the method for correlation\n    if method == 'auto':\n        method = 'fft' if len(data) > 1000 else 'direct'\n\n    # Perform correlation\n    if method == 'direct':\n        correlation = np.correlate(data, template, mode=mode)\n    elif method == 'fft':\n        correlation = np.fft.fft(data)\n        correlation_template = np.fft.fft(template, n=len(data))\n        correlation = np.fft.ifft(correlation * np.conj(correlation_template)).real\n    else:\n        raise ValueError(\"Method must be 'direct', 'fft', or 'auto'.\")\n\n    # Normalization\n    if normalize == 'full':\n        norm_factor = np.sqrt(np.sum(template**2) * np.sum(data**2))\n        if norm_factor != 0:\n            correlation /= norm_factor\n    elif normalize == 'naive':\n        correlation /= (np.std(data) * np.std(template))\n\n    return correlation"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "read_events", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/event/catalog.py", "method_code_mask": "import copy\nimport warnings\nimport numpy as np\nfrom obspy.core.utcdatetime import UTCDateTime\nfrom obspy.core.util import _read_from_plugin\nfrom obspy.core.util.base import ENTRY_POINTS\nfrom obspy.core.util.base import _generic_reader\nfrom obspy.core.util.decorator import map_example_filename\nfrom obspy.core.util.decorator import uncompress_file\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.event import ResourceIdentifier\nfrom obspy.imaging.maps import plot_map\nfrom obspy.imaging.maps import _plot_cartopy_into_axes\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.imaging.cm import obspy_sequential\nimport doctest\n\n\n@map_example_filename('pathname_or_url')\ndef read_events(pathname_or_url=None, format=None, **kwargs): [MASK]\n", "response": "import copy\nimport warnings\nimport numpy as np\nfrom obspy.core.utcdatetime import UTCDateTime\nfrom obspy.core.util import _read_from_plugin\nfrom obspy.core.util.base import ENTRY_POINTS\nfrom obspy.core.util.base import _generic_reader\nfrom obspy.core.util.decorator import map_example_filename\nfrom obspy.core.util.decorator import uncompress_file\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.event import ResourceIdentifier\nfrom obspy.imaging.maps import plot_map\nfrom obspy.imaging.maps import _plot_cartopy_into_axes\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom obspy.imaging.cm import obspy_sequential\nimport doctest\nfrom obspy import Catalog\n\n@map_example_filename('pathname_or_url')\ndef read_events(pathname_or_url=None, format=None, **kwargs):\n    \"\"\"\n    Read event files into an ObsPy Catalog object.\n\n    :param pathname_or_url: str or Path or file-like object, optional\n        A file name or URL, a Path object, or an open file-like object.\n        If omitted, an example Catalog object will be returned.\n    :param format: str\n        The format of the file to be read (e.g., \"QUAKEML\").\n    :param kwargs: additional keyword arguments for the reader.\n    :return: Catalog\n        An ObsPy Catalog object containing the events read from the file.\n\n    \"\"\"\n    if pathname_or_url is None:\n        # Return an example Catalog if no pathname_or_url is provided\n        return Catalog()\n\n    if format is None:\n        raise ValueError(\"The 'format' parameter must be specified.\")\n\n    # Read the events using the appropriate reader based on the format\n    try:\n        catalog = _read_from_plugin(format, pathname_or_url, **kwargs)\n    except Exception as e:\n        raise RuntimeError(f\"Failed to read events: {e}\")\n\n    return catalog"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "obspy", "full_method_name": "read_inventory", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/obspy/obspy/core/inventory/inventory.py", "method_code_mask": "import copy\nimport fnmatch\nimport textwrap\nimport warnings\nimport obspy\nfrom obspy.core.util.base import ENTRY_POINTS\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.base import _read_from_plugin\nfrom obspy.core.util.base import _generic_reader\nfrom obspy.core.util.decorator import map_example_filename\nfrom obspy.core.util.decorator import uncompress_file\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.util.obspy_types import ObsPyException\nfrom obspy.core.util.obspy_types import ZeroSamplingRate\nfrom obspy.imaging.maps import plot_map\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom obspy.core.inventory.response import _adjust_bode_plot_figure\nimport doctest\n\n\n@map_example_filename('path_or_file_object')\ndef read_inventory(path_or_file_object=None, format=None, level='response',\n    *args, **kwargs): [MASK]\n", "response": "import copy\nimport fnmatch\nimport textwrap\nimport warnings\nimport obspy\nfrom obspy.core.util.base import ENTRY_POINTS\nfrom obspy.core.util.base import ComparingObject\nfrom obspy.core.util.base import _read_from_plugin\nfrom obspy.core.util.base import _generic_reader\nfrom obspy.core.util.decorator import map_example_filename\nfrom obspy.core.util.decorator import uncompress_file\nfrom obspy.core.util.misc import buffered_load_entry_point\nfrom obspy.core.util.obspy_types import ObsPyException\nfrom obspy.core.util.obspy_types import ZeroSamplingRate\nfrom obspy.imaging.maps import plot_map\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom obspy.core.inventory.response import _adjust_bode_plot_figure\nimport doctest\n\n\n@map_example_filename('path_or_file_object')\ndef read_inventory(path_or_file_object=None, format=None, level='response',\n    *args, **kwargs):\n    \"\"\"\n    Read an inventory file containing metadata about seismological networks,\n    stations, and channels.\n\n    Parameters:\n    path_or_file_object : str or file-like object\n        A file name or URL, a Path object, or a file-like object. Wildcards\n        are allowed for file names. If omitted, an example Inventory object\n        is returned.\n    format : str\n        The format of the file to be read (e.g., \"STATIONXML\").\n    level : str\n        The level of detail to read from the file. It can be one of 'response',\n        'channel', 'station', or 'network'.\n    *args : additional positional arguments\n        Additional positional arguments passed to the underlying plugin methods.\n    **kwargs : additional keyword arguments\n        Additional keyword arguments passed to the underlying plugin methods.\n\n    Returns:\n    Inventory\n        An ObsPy Inventory object containing metadata about seismological\n        networks, stations, and channels.\n    \"\"\"\n    if path_or_file_object is None:\n        # Return an example Inventory object if no path is provided\n        return obspy.read_inventory()\n\n    # Handle the reading of the inventory file\n    try:\n        inventory = _read_from_plugin('inventory', path_or_file_object, format=format,\n                                       level=level, *args, **kwargs)\n    except ObsPyException as e:\n        warnings.warn(f\"Could not read inventory: {e}\")\n        return None\n\n    return inventory"}
