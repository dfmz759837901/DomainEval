{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between the specified start date and end date, inclusive.\n\n    :param start: The start date of the range (datetime.date or datetime.datetime)\n    :param end: The end date of the range (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects representing each date in the range\n    \"\"\"\n    start_date = _wrap_date(start)\n    end_date = _wrap_date(end)\n    \n    delta = datetime.timedelta(days=1)\n    current_date = start_date\n    dates_list = []\n    \n    while current_date <= end_date:\n        dates_list.append(current_date)\n        current_date += delta\n    \n    return dates_list"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between start and end, inclusive.\n\n    :param start: The start date of the range (datetime.date or datetime.datetime)\n    :param end: The end date of the range (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects\n    \"\"\"\n    start = _wrap_date(start)\n    end = _wrap_date(end)\n    \n    delta = end - start\n    return [start + datetime.timedelta(days=i) for i in range(delta.days + 1)]"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between the specified start and end dates, inclusive.\n\n    :param start: The start date of the range (datetime.date or datetime.datetime)\n    :param end: The end date of the range (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects representing each date in the range\n    \"\"\"\n    start = _wrap_date(start)\n    end = _wrap_date(end)\n    \n    delta = end - start\n    return [start + datetime.timedelta(days=i) for i in range(delta.days + 1)]"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between the specified start and end dates, inclusive.\n\n    :param start: The start date of the range (datetime.date or datetime.datetime)\n    :param end: The end date of the range (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects representing each date between start and end\n    \"\"\"\n    start = _wrap_date(start)\n    end = _wrap_date(end)\n    \n    delta = end - start\n    return [start + datetime.timedelta(days=i) for i in range(delta.days + 1)]"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are datetime.date objects\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a list to hold holiday dates\n    holiday_dates = []\n\n    # Generate a range of dates from start to end\n    current_date = start\n    while current_date <= end:\n        # Check if the current date is a holiday\n        if current_date in holidays or current_date in in_lieu_days:\n            holiday_dates.append(current_date)\n        # Check if weekends should be included\n        elif include_weekends and current_date.weekday() in (5, 6):  # Saturday or Sunday\n            holiday_dates.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holiday_dates"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between start and end dates, inclusive.\n    \n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n    \n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # If weekends are included\n            workdays_list.append(date)\n    \n    return workdays_list"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between start and end dates, inclusive.\n    \n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n    \n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # Saturday or Sunday\n            workdays_list.append(date)\n    \n    return workdays_list"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between start and end, inclusive.\n\n    :param start: The start date (datetime.date or datetime.datetime)\n    :param end: The end date (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects\n    \"\"\"\n    start = _wrap_date(start)\n    end = _wrap_date(end)\n    \n    delta = end - start\n    return [start + datetime.timedelta(days=i) for i in range(delta.days + 1)]"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between the specified start and end dates.\n\n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n\n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # Check for weekends\n            workdays_list.append(date)\n\n    return workdays_list"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are datetime.date objects\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a set to hold holidays\n    holiday_set = set(holidays)\n\n    # Add in-lieu days to the holiday set\n    holiday_set.update(in_lieu_days)\n\n    # Create a list to hold the resulting holidays\n    holidays_in_range = []\n\n    # Iterate through the date range\n    current_date = start\n    while current_date <= end:\n        # Check if the current date is a holiday\n        if current_date in holiday_set:\n            holidays_in_range.append(current_date)\n        # Check if weekends should be included\n        elif include_weekends and current_date.weekday() in (5, 6):  # Saturday or Sunday\n            holidays_in_range.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holidays_in_range"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between start and end dates, inclusive.\n    \n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n    \n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # Check for weekends\n            workdays_list.append(date)\n\n    return workdays_list"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are of type date\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a list to hold holiday dates\n    holiday_dates = []\n\n    # Generate a list of all dates in the range\n    current_date = start\n    while current_date <= end:\n        # Check if the current date is a holiday\n        if current_date in holidays or current_date in in_lieu_days:\n            holiday_dates.append(current_date)\n        elif include_weekends and current_date.weekday() in (5, 6):  # Saturday or Sunday\n            holiday_dates.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holiday_dates"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between the specified start and end dates.\n\n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n\n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # Saturday or Sunday\n            workdays_list.append(date)\n\n    return workdays_list"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are datetime.date objects\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a list to hold holiday dates\n    holiday_dates = []\n\n    # Generate a range of dates from start to end\n    current_date = start\n    while current_date <= end:\n        # Check if the current date is a holiday\n        if current_date in holidays or current_date in in_lieu_days:\n            holiday_dates.append(current_date)\n        # Check if weekends should be included\n        elif include_weekends and current_date.weekday() in (5, 6):  # Saturday or Sunday\n            holiday_dates.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holiday_dates"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are of type datetime.date\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a list to hold holiday dates\n    holiday_dates = []\n\n    # Generate a list of all dates in the range\n    current_date = start\n    while current_date <= end:\n        # Check if the current date is a holiday\n        if current_date in holidays or current_date in in_lieu_days:\n            holiday_dates.append(current_date)\n        # Check if weekends should be included\n        elif include_weekends and current_date.weekday() in (5, 6):  # Saturday or Sunday\n            holiday_dates.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holiday_dates"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n\n    :param delta_days: The number of days to look ahead or behind to find the next workday.\n    :param date: The starting date from which to calculate the next workday.\n    :return: The date of the workday found after considering the delta_days.\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _validate_date(date)\n\n    days_found = 0\n    current_date = date\n\n    while days_found < abs(delta_days):\n        current_date += datetime.timedelta(days=1 if delta_days > 0 else -1)\n        if is_workday(current_date):\n            days_found += 1\n\n    return current_date"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n\n    :param delta_days: The number of days to look ahead or behind to find the next workday.\n    :param date: The starting date from which to calculate the next workday.\n    :return: The date of the workday found after considering the delta_days from the specified date.\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _wrap_date(date)\n\n    while delta_days != 0:\n        date += datetime.timedelta(days=1 if delta_days > 0 else -1)\n        if is_workday(date):\n            delta_days -= 1 if delta_days > 0 else -1\n\n    return date"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n    \n    :param delta_days: The number of days to look ahead (positive) or behind (negative).\n    :param date: The starting date from which to calculate the next workday.\n    :return: The date of the workday found after considering the delta_days.\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _validate_date(date)\n\n    while delta_days != 0:\n        date += datetime.timedelta(days=1 if delta_days > 0 else -1)\n        if is_workday(date):\n            delta_days -= 1 if delta_days > 0 else -1\n\n    return date"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n\n    :param delta_days: The number of days to look ahead or behind to find the next workday.\n                       A positive value indicates looking ahead, while a negative value indicates looking behind.\n    :param date: The starting date from which to calculate the next workday. If not provided, the current date is used.\n    :return: The date of the workday found after considering the delta_days from the specified date.\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _validate_date(date)\n\n    days_found = 0\n    while days_found < abs(delta_days):\n        date += datetime.timedelta(days=1 if delta_days > 0 else -1)\n        if is_workday(date):\n            days_found += 1\n\n    return date"}
{"result": "failed: AssertionError", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n\n    :param delta_days: The number of days to look ahead or behind to find the next workday.\n                       A positive value indicates looking ahead, while a negative value indicates looking behind.\n    :param date: The starting date from which to calculate the next workday. If not provided, the current date is used.\n    :return: The date of the workday found after considering the delta_days from the specified date.\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _validate_date(date)\n    \n    # Adjust the date based on delta_days\n    days_to_check = abs(delta_days)\n    direction = 1 if delta_days >= 0 else -1\n    current_date = date\n\n    while days_to_check > 0:\n        current_date += datetime.timedelta(days=direction)\n        if is_workday(current_date):\n            days_to_check -= 1\n\n    return current_date"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    # Check if the date is a holiday\n    if date in holidays:\n        return True, holidays[date]\n    \n    # Check if the date is a workday\n    if date in workdays:\n        return False, None\n    \n    # Check if the date is an in-lieu day\n    if date in in_lieu_days:\n        return True, in_lieu_days[date]\n    \n    # If it's neither a holiday nor a workday, return False and None\n    return False, None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    if date in holidays:\n        return True, holidays[date]  # Return holiday name if it's a holiday\n    elif date in in_lieu_days:\n        return True, in_lieu_days[date]  # Return in-lieu holiday name if applicable\n    elif date in workdays:\n        return False, None  # It's a working day\n    else:\n        return False, None  # It's a regular weekday"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    if date in holidays:\n        return True, holidays[date]  # Return holiday status and name\n    elif date in in_lieu_days:\n        return True, in_lieu_days[date]  # Return in lieu day status and name\n    elif date in workdays:\n        return False, None  # Return working day status\n    else:\n        return False, None  # Return regular weekday status"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    if date in holidays:\n        return True, holidays[date]\n    elif date in in_lieu_days:\n        return True, in_lieu_days[date]\n    elif date in workdays:\n        return False, None\n    else:\n        return False, None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    if date in holidays:\n        return True, holidays[date]\n    elif date in in_lieu_days:\n        return True, in_lieu_days[date]\n    elif date in workdays:\n        return False, None\n    else:\n        return False, None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    date = _validate_date(date)\n    is_holiday = date in holidays\n    holiday_name = holidays.get(date, None)\n    \n    if not is_holiday:\n        if date.weekday() >= 5:  # Saturday or Sunday\n            return (False, None)\n        elif date in workdays:\n            return (False, None)\n    \n    return (is_holiday, holiday_name)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    \"\"\"\n    Check if the given date is a holiday in China and return the holiday name if applicable.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: tuple[bool, str | None]\n    \"\"\"\n    date = _validate_date(date)\n    holiday_name = holidays.get(date)\n    \n    if holiday_name:\n        return True, holiday_name\n    \n    if date.weekday() >= 5:  # Saturday or Sunday\n        return False, None\n    \n    if date in workdays:\n        return False, None\n    \n    if date in in_lieu_days:\n        return True, \"In Lieu Day\"\n    \n    return False, None"}
{"result": "failed: 0", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Year must be between 1900 and 2100.\")\n    \n    solar_terms = []\n    start_year = start.year\n    end_year = end.year\n\n    for year in range(start_year, end_year + 1):\n        for i in range(24):\n            C = SOLAR_TERMS_C_NUMS[i]\n            D = SOLAR_TERMS_DELTA[i]\n            month = SOLAR_TERMS_MONTH[i]\n            solar_term_date = datetime.date(year, month, 1) + datetime.timedelta(days=D)\n\n            if start <= solar_term_date <= end:\n                solar_terms.append((solar_term_date, SolarTerms[i]))\n\n    return solar_terms"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    \"\"\"\n    Check if the given date is a holiday in China and return the holiday details.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: tuple[bool, str | None]\n    \"\"\"\n    date = _validate_date(date)\n    \n    # Check if the date is a holiday\n    if date in holidays:\n        return True, holidays[date]\n    \n    # Check if the date is a weekend\n    if date.weekday() in (5, 6):  # Saturday or Sunday\n        return False, None\n    \n    # Check if the date is a workday designated for work\n    if date in workdays:\n        return False, None\n    \n    # If it's a regular weekday and not a holiday or weekend\n    return False, None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    date = _validate_date(date)\n    is_holiday = date in holidays\n    holiday_name = holidays.get(date, None)\n\n    if not is_holiday:\n        if date.weekday() >= 5:  # Saturday or Sunday\n            return (False, None)\n        elif date in workdays:\n            return (False, None)\n        else:\n            return (False, None)\n\n    return (True, holiday_name)"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    \"\"\"\n    Check if the given date is a holiday in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: tuple[bool, str | None]\n    \"\"\"\n    date = _validate_date(date)\n    holiday_name = holidays.get(date)\n    \n    if holiday_name:\n        return True, holiday_name\n    \n    if date.weekday() >= 5:  # Saturday or Sunday\n        return False, None\n    \n    if date in in_lieu_days:\n        return True, \"In lieu day\"\n    \n    if date in workdays:\n        return False, None\n    \n    return False, None"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days"}
{"result": "failed: 0", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Start and end dates must be between 1900 and 2100.\")\n    \n    solar_terms = []\n    \n    for i in range(24):\n        year = start.year\n        C = SOLAR_TERMS_C_NUMS[i]\n        D = SOLAR_TERMS_DELTA[i]\n        \n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            D += 1  # Adjust for leap years\n        \n        # Calculate the solar term date\n        solar_term_date = datetime.date(year, SOLAR_TERMS_MONTH[i], 1) + datetime.timedelta(days=D)\n        \n        # Check if the solar term date is within the range\n        if start <= solar_term_date <= end:\n            solar_terms.append((solar_term_date, SolarTerms[i]))\n    \n    return solar_terms"}
{"result": "failed: 0", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Year must be between 1900 and 2100.\")\n\n    solar_terms = []\n    for i in range(24):\n        year = start.year\n        D = SOLAR_TERMS_DELTA[i]\n        C = SOLAR_TERMS_C_NUMS[i]\n        \n        # Calculate the date of the solar term\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            # Leap year adjustment\n            term_date = datetime.date(year, SOLAR_TERMS_MONTH[i], D + 1)\n        else:\n            term_date = datetime.date(year, SOLAR_TERMS_MONTH[i], D)\n\n        # Adjust for the century change\n        if year == 2000 and i < 6:\n            term_date += datetime.timedelta(days=1)\n\n        # Check if the term date is within the specified range\n        if start <= term_date <= end:\n            solar_terms.append((term_date, SolarTerms[i]))\n\n    return solar_terms"}
{"result": "failed: 0", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Year must be between 1900 and 2100.\")\n\n    solar_terms = []\n    for i in range(24):\n        year = start.year\n        D = SOLAR_TERMS_DELTA[i]\n        C = SOLAR_TERMS_C_NUMS[i]\n        \n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            # Adjust for leap years\n            if i == 2 or i == 3:  # Adjust for specific solar terms\n                D += 1\n        \n        # Calculate the solar term date\n        solar_term_date = datetime.date(year, SOLAR_TERMS_MONTH[i], 1) + datetime.timedelta(days=D)\n        \n        if start <= solar_term_date <= end:\n            solar_terms.append((solar_term_date, SolarTerms[i]))\n\n    return solar_terms"}
{"result": "failed: 0", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Year must be between 1900 and 2100\")\n\n    solar_terms = []\n    for i in range(24):\n        year = start.year\n        C = SOLAR_TERMS_C_NUMS[i]\n        D = SOLAR_TERMS_DELTA[i]\n        month = SOLAR_TERMS_MONTH[i]\n        \n        if year % 4 == 0 and month > 2:\n            D += 1  # Adjust for leap years\n        \n        # Calculate the solar term date\n        solar_term_date = datetime.date(year, month, int(20 + D + (year % 100) * 0.2422))\n        \n        # Adjust for the turn of the century\n        if year == 2000 and i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]:\n            solar_term_date += datetime.timedelta(days=1)\n        \n        if start <= solar_term_date <= end:\n            solar_terms.append((solar_term_date, SolarTerms[i]))\n\n    return solar_terms"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday\n        return False\n    \n    # Check if the date is a national holiday or in lieu day\n    if date in holidays or date in in_lieu_days:\n        return False\n    \n    # If it's not a weekend and not a holiday, it is a workday\n    return True"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 is Saturday, 6 is Sunday\n        return False\n    \n    # Check if the date is a holiday\n    if date in holidays:\n        return False\n    \n    # Check if the date is a day off in lieu\n    if date in in_lieu_days:\n        return False\n    \n    # If it is not a weekend, holiday, or in lieu day, it is a workday\n    return True"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday\n        return False\n    \n    # Check if the date is a national holiday\n    if date in holidays:\n        return False\n    \n    # Check if the date is a day off in lieu of a holiday\n    if date in in_lieu_days:\n        return False\n    \n    # If none of the above conditions are met, it is a workday\n    return True"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday\n        return False\n    \n    # Check if the date is a national holiday or in lieu day\n    if date in holidays or date in in_lieu_days:\n        return False\n    \n    # If it's not a weekend or holiday, it is a workday\n    return True"}
{"result": "passed", "model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 is Saturday, 6 is Sunday\n        return False\n    \n    # Check if the date is a national holiday\n    if date in holidays:\n        return False\n    \n    # Check if the date is an in-lieu day (a day off that is compensated by working on another day)\n    if date in in_lieu_days:\n        return False\n    \n    # If none of the above conditions are met, it is a workday\n    return True"}
