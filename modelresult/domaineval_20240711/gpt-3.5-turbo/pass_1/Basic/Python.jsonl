{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "kruskal", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/minimum_spanning_tree_kruskal.py", "response": "from typing import List, Tuple\n\ndef kruskal(num_nodes: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        x_root = find(parent, x)\n        y_root = find(parent, y)\n\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n\n    edges.sort(key=lambda x: x[2])\n    result = []\n    parent = [i for i in range(num_nodes)]\n    rank = [0] * num_nodes\n    e = 0\n    i = 0\n\n    while e < num_nodes - 1:\n        a, b, w = edges[i]\n        i += 1\n        x = find(parent, a)\n        y = find(parent, b)\n\n        if x != y:\n            e += 1\n            result.append((a, b, w))\n            union(parent, rank, x, y)\n\n    return result", "test_code_list": [{"test_code": "def test_kruskal_successful_result():\n    num_nodes = 9\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    result = kruskal(num_nodes, edges)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    assert sorted(expected) == sorted(result)\n\ntest_kruskal_successful_result()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/tests/test_min_spanning_tree_kruskal.py"}], "method_code_mask": "def kruskal(num_nodes: int, edges: list[tuple[int, int, int]]) ->list[tuple\n    [int, int, int]]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "prisms_algorithm", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/minimum_spanning_tree_prims.py", "response": "def prisms_algorithm(adjacency_list):\n    heap = Heap()\n    positions = []\n    for vertex in adjacency_list.keys():\n        positions.append(vertex)\n    heap.heapify([sys.maxsize] * len(positions), positions)\n    visited = set()\n    mst = []\n    while len(visited) < len(adjacency_list):\n        vertex = heap.delete_minimum(heap.node_position)\n        visited.add(vertex)\n        for neighbor, weight in adjacency_list[vertex]:\n            if neighbor not in visited:\n                heap_val = heap.node_position[neighbor]\n                if weight < heap_val:\n                    heap.bottom_to_top(weight, neighbor, heap.node_position, positions)\n        if len(mst) > 0:\n            mst.append((vertex, heap.node_position[vertex]))\n    return mst", "test_code_list": [{"test_code": "from collections import defaultdict\ndef test_prim_successful_result():\n    num_nodes, num_edges = 9, 14\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    adjacency = defaultdict(list)\n    for node1, node2, cost in edges:\n        adjacency[node1].append([node2, cost])\n        adjacency[node2].append([node1, cost])\n    result = prisms_algorithm(adjacency)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    for answer in expected:\n        edge = tuple(answer[:2])\n        reverse = tuple(edge[::-1])\n        assert edge in result or reverse in result\n\ntest_prim_successful_result()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/tests/test_min_spanning_tree_prim.py"}], "method_code_mask": "import sys\nfrom collections import defaultdict\n\n\nclass Heap:\n\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = heap[start\n                    ], positions[start]\n                heap[start], positions[start] = temp, temp1\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(positions[smallest_child], self.\n                    get_position(positions[start]))\n                self.set_position(positions[start], temp)\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index -\n                1) / 2)\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\n\n\ndef prisms_algorithm(adjacency_list): [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "gen_gaussian_kernel", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/digital_image_processing/edge_detection/canny.py", "response": "import cv2\nimport numpy as np\n\ndef gen_gaussian_kernel(k_size, sigma):\n    kernel = cv2.getGaussianKernel(k_size, sigma)\n    g = np.outer(kernel, kernel)\n    return g", "test_code_list": [{"test_code": "import numpy as np\nfrom cv2 import COLOR_BGR2GRAY\nfrom cv2 import cvtColor\nfrom cv2 import imread\nfrom numpy import array\nfrom numpy import uint8\nfrom PIL import Image\nfrom os import getenv\ndef test_gen_gaussian_kernel():\n    resp = gen_gaussian_kernel(9, sigma=1.4)\n    assert resp.all()\n\ntest_gen_gaussian_kernel()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/digital_image_processing/test_digital_image_processing.py"}], "method_code_mask": "import cv2\nimport numpy as np\n\n\ndef gen_gaussian_kernel(k_size, sigma): [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "miller_rabin", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/ciphers/deterministic_miller_rabin.py", "response": "import random\nimport math\n\ndef miller_rabin(n: int, allow_probable: bool=False) -> bool:\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n\n    def miller_test(d, a, s, n):\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            return True\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n        return False\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n in {2, 3}:\n            return True\n        if n % 2 == 0:\n            return False\n\n        d, s = n - 1, 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n\n        if n < 2047:\n            return all(miller_test(d, a, s, n) for a in {2})\n        if n < 1373653:\n            return all(miller_test(d, a, s, n) for a in {2, 3})\n        if n < 25326001:\n            return all(miller_test(d, a, s, n) for a in {2, 3, 5})\n        if n < 3215031751:\n            return all(miller_test(d, a, s, n) for a in {2, 3, 5, 7})\n        if n < 2152302898747:\n            return all(miller_test(d, a, s, n) for a in {2, 3, 5, 7, 11})\n        if n < 3474749660383:\n            return all(miller_test(d, a, s, n) for a in {2, 3, 5, 7, 11, 13})\n        if n < 341550071728321:\n            return all(miller_test(d, a, s, n) for a in {2, 3, 5, 7, 11, 13, 17})\n\n        if allow_probable:\n            return all(miller_test(d, a, s, n) for a in random.sample(range(2, min(n - 2, math.isqrt(n) + 1)), min(n - 4, 10)))\n        else:\n            raise ValueError(\"Number exceeds deterministic test limit and probabilistic testing not allowed.\")\n\n    return is_prime(n)", "test_code_list": [{"test_code": "def test_miller_rabin() ->None:\n    \"\"\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\n    and a prime in each range.\n    \"\"\"\n    assert not miller_rabin(561)\n    assert miller_rabin(563)\n    assert not miller_rabin(838201)\n    assert miller_rabin(838207)\n    assert not miller_rabin(17316001)\n    assert miller_rabin(17316017)\n    assert not miller_rabin(3078386641)\n    assert miller_rabin(3078386653)\n    assert not miller_rabin(1713045574801)\n    assert miller_rabin(1713045574819)\n    assert not miller_rabin(2779799728307)\n    assert miller_rabin(2779799728327)\n    assert not miller_rabin(113850023909441)\n    assert miller_rabin(113850023909527)\n    assert not miller_rabin(1275041018848804351)\n    assert miller_rabin(1275041018848804391)\n    assert not miller_rabin(79666464458507787791867)\n    assert miller_rabin(79666464458507787791951)\n    assert not miller_rabin(552840677446647897660333)\n    assert miller_rabin(552840677446647897660359)\n\ntest_miller_rabin()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/ciphers/deterministic_miller_rabin.py"}], "method_code_mask": "def miller_rabin(n: int, allow_probable: bool=False) ->bool: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "is_prime", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py", "response": "import math\n\ndef is_prime(number: int) -> bool:\n    if number <= 1:\n        raise ValueError(\"Input number must be greater than 1\")\n    if number == 2:\n        return True\n    if number % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(number)) + 1, 2):\n        if number % i == 0:\n            return False\n    return True", "test_code_list": [{"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_primes(self):\n        assert is_prime(2)\n        assert is_prime(3)\n        assert is_prime(5)\n        assert is_prime(7)\n        assert is_prime(11)\n        assert is_prime(13)\n        assert is_prime(17)\n        assert is_prime(19)\n        assert is_prime(23)\n        assert is_prime(29)\n    \nTest().test_primes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py"}, {"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_not_primes(self):\n        with pytest.raises(ValueError):\n            is_prime(-19)\n        assert not is_prime(0\n            ), \"Zero doesn't have any positive factors, primes must have exactly two.\"\n        assert not is_prime(1\n            ), 'One only has 1 positive factor, primes must have exactly two.'\n        assert not is_prime(2 * 2)\n        assert not is_prime(2 * 3)\n        assert not is_prime(3 * 3)\n        assert not is_prime(3 * 5)\n        assert not is_prime(3 * 5 * 7)\n    \nTest().test_not_primes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py"}], "method_code_mask": "import math\nimport unittest\nimport pytest\n\n\ndef is_prime(number: int) ->bool: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "abs_min", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/abs.py", "response": "import doctest\n\n\ndef abs_val(num: float) ->float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) ->int:\n    \"\"\"\n    Find the element from a list of integers that has the smallest absolute value.\n    \n    If there are multiple such integers, return the one closer to zero.\n    \n    If the input list is empty, raise a ValueError.\n    \n    >>> abs_min([3, -5, 2, -2, 5])\n    2\n    >>> abs_min([-3, -5, 2, -2, 5])\n    2\n    >>> abs_min([3, -5, 2, -2, 0])\n    0\n    >>> abs_min([])\n    Traceback (most recent call last):\n    ...\n    ValueError: List is empty\n    \"\"\"\n    if not x:\n        raise ValueError(\"List is empty\")\n    \n    min_abs_val = float('inf')\n    closest_to_zero = float('inf')\n    result = None\n    \n    for num in x:\n        abs_num = abs_val(num)\n        if abs_num < min_abs_val or (abs_num == min_abs_val and num < closest_to_zero):\n            min_abs_val = abs_num\n            closest_to_zero = num\n            result = num\n    \n    return result", "test_code_list": [{"test_code": "import doctest\ndef abs_max_sort(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max_sort([0,5,1,11])\n    11\n    >>> abs_max_sort([3,-10,-2])\n    -10\n    >>> abs_max_sort([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max_sort() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max_sort() arg is an empty sequence')\n    return sorted(x, key=abs)[-1]\ndef abs_max(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    >>> abs_max([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max() arg is an empty sequence')\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j\ndef test_abs_val():\n    \"\"\"\n    >>> test_abs_val()\n    \"\"\"\n    assert abs_val(0) == 0\n    assert abs_val(34) == 34\n    assert abs_val(-100000000000) == 100000000000\n    a = [-3, -1, 2, -11]\n    assert abs_max(a) == -11\n    assert abs_max_sort(a) == -11\n    assert abs_min(a) == -1\ntest_abs_val()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/abs.py"}], "method_code_mask": "import doctest\n\n\ndef abs_val(num: float) ->float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "signum", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/signum.py", "response": "def signum(num: float) -> int:\n    if num < 0:\n        return -1\n    elif num == 0:\n        return 0\n    else:\n        return 1", "test_code_list": [{"test_code": "def test_signum() ->None:\n    \"\"\"\n    Tests the signum function\n    >>> test_signum()\n    \"\"\"\n    assert signum(5) == 1\n    assert signum(-5) == -1\n    assert signum(0) == 0\n    assert signum(10.5) == 1\n    assert signum(-10.5) == -1\n    assert signum(1e-06) == 1\n    assert signum(-1e-06) == -1\n    assert signum(123456789) == 1\n    assert signum(-123456789) == -1\n\ntest_signum()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/signum.py"}], "method_code_mask": "def signum(num: float) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "identity", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/matrix/matrix_operation.py", "response": "from __future__ import annotations\nfrom typing import Any\nimport doctest\n\n\ndef identity(n: int) -> list[list[int]]:\n    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]\n\nassert identity(3) == [[1, 0, 0], [0, 1, 0], [0, 0, 1]]", "test_code_list": [{"test_code": "import logging\nimport sys\nimport numpy as np\nimport pytest\n@pytest.mark.mat_ops()\ndef test_identity():\n    act = np.identity(5).tolist()\n    theo = identity(5)\n    assert theo == act\n\ntest_identity()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/matrix/tests/test_matrix_operation.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Any\nimport doctest\n\n\ndef identity(n: int) ->list[list[int]]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "calc_profit", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/greedy_knapsack.py", "response": "import sys\n\ndef calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    if len(profit) != len(weight):\n        return -1  # Error: profit and weight lists are not of the same length\n    \n    if max_weight <= 0:\n        return -1  # Error: max_weight should be greater than zero\n    \n    if any(p < 0 or w < 0 for p, w in zip(profit, weight)):\n        return -1  # Error: profit and weight values should be non-negative\n    \n    n = len(profit)\n    ratios = [(profit[i] / weight[i], profit[i], weight[i]) for i in range(n)]\n    ratios.sort(reverse=True)\n    \n    max_profit = 0\n    current_weight = 0\n    \n    for ratio, p, w in ratios:\n        if current_weight + w <= max_weight:\n            max_profit += p\n            current_weight += w\n        else:\n            remaining_capacity = max_weight - current_weight\n            max_profit += ratio * remaining_capacity\n            break\n    \n    return int(max_profit)\n", "test_code_list": [{"test_code": "import unittest\nimport pytest\n\nclass TestClass(unittest.TestCase):\n    def test_sorted(self):\n        \"\"\"\n            calc_profit takes the required argument (profit, weight, max_weight)\n            and returns whether the answer matches to the expected ones\n            \"\"\"\n        profit = [10, 20, 30, 40, 50, 60]\n        weight = [2, 4, 6, 8, 10, 12]\n        max_weight = 100\n        assert calc_profit(profit, weight, max_weight) == 210\n    \nTestClass().test_sorted()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_greedy_knapsack.py"}], "method_code_mask": "def calc_profit(profit: list, weight: list, max_weight: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "knapsack", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/knapsack.py", "response": "from __future__ import annotations\nimport doctest\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int:\n    if counter == 0 or capacity == 0:\n        return 0\n    if weights[counter - 1] > capacity:\n        return knapsack(capacity, weights, values, counter - 1)\n    else:\n        return max(values[counter - 1] + knapsack(capacity - weights[counter - 1], weights, values, counter - 1),\n                   knapsack(capacity, weights, values, counter - 1))\n\n# Test the knapsack function\ndoctest.testmod()", "test_code_list": [{"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_base_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 0\n        val = [0]\n        w = [0]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n        val = [60]\n        w = [10]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n    \nTest().test_base_case()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_easy_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 3\n        val = [1, 2, 3]\n        w = [3, 2, 1]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 5\n    \nTest().test_easy_case()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_knapsack(self):\n        \"\"\"\n            test for the knapsack\n            \"\"\"\n        cap = 50\n        val = [60, 100, 120]\n        w = [10, 20, 30]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 220\n    \nTest().test_knapsack()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}], "method_code_mask": "from __future__ import annotations\nimport doctest\n\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int\n    ) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "rabin_karp", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/strings/rabin_karp.py", "response": "modulus = 1000003\nalphabet_size = 256\n\ndef rabin_karp(pattern: str, text: str) -> bool:\n    pattern_len = len(pattern)\n    text_len = len(text)\n    pattern_hash = 0\n    text_hash = 0\n    h = 1\n\n    for i in range(pattern_len - 1):\n        h = (h * alphabet_size) % modulus\n\n    for i in range(pattern_len):\n        pattern_hash = (alphabet_size * pattern_hash + ord(pattern[i])) % modulus\n        text_hash = (alphabet_size * text_hash + ord(text[i])) % modulus\n\n    for i in range(text_len - pattern_len + 1):\n        if pattern_hash == text_hash:\n            match = True\n            for j in range(pattern_len):\n                if text[i + j] != pattern[j]:\n                    match = False\n                    break\n            if match:\n                return True\n        if i < text_len - pattern_len:\n            text_hash = (alphabet_size * (text_hash - ord(text[i]) * h) + ord(text[i + pattern_len])) % modulus\n            if text_hash < 0:\n                text_hash = text_hash + modulus\n    return False", "test_code_list": [{"test_code": "def test_rabin_karp() ->None:\n    \"\"\"\n    >>> test_rabin_karp()\n    Success.\n    \"\"\"\n    pattern = 'abc1abc12'\n    text1 = 'alskfjaldsabc1abc1abc12k23adsfabcabc'\n    text2 = 'alskfjaldsk23adsfabcabc'\n    assert rabin_karp(pattern, text1)\n    assert not rabin_karp(pattern, text2)\n    pattern = 'ABABX'\n    text = 'ABABZABABYABABX'\n    assert rabin_karp(pattern, text)\n    pattern = 'AAAB'\n    text = 'ABAAAAAB'\n    assert rabin_karp(pattern, text)\n    pattern = 'abcdabcy'\n    text = 'abcxabcdabxabcdabcdabcy'\n    assert rabin_karp(pattern, text)\n    pattern = 'L\u00fc'\n    text = 'L\u00fcsai'\n    assert rabin_karp(pattern, text)\n    pattern = 'Lue'\n    assert not rabin_karp(pattern, text)\n    print('Success.')\n\ntest_rabin_karp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/strings/rabin_karp.py"}], "method_code_mask": "modulus = 1000003\nalphabet_size = 256\n\n\ndef rabin_karp(pattern: str, text: str) ->bool: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "find_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "def find_set(x: Node) -> Node:\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_set(x: Node) ->Node: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "make_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "def make_set(x: Node) ->None:\n    x.rank = 0\n    x.parent = x", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef make_set(x: Node) ->None: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "find_python_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "from typing import Set\n\nclass Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\ndef find_python_set(node: Node) ->Set:\n    sets = {frozenset({1, 2, 3}), frozenset({4, 5, 6}), frozenset({7, 8, 9})}  # Predefined collection of sets\n    for s in sets:\n        if node.data in s:\n            return s\n    raise ValueError(f\"{node.data} is not in {sets}\")", "test_code_list": [{"test_code": "def find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_python_set(node: Node) ->set: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "total_time", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "def total_time(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Calculate the total time of motion of a projectile given the initial velocity and angle of launch.\n    \n    Args:\n    - init_velocity: A float or int representing the initial velocity of the projectile. Must be a positive number.\n    - angle: A float or int representing the angle of launch in degrees. The angle must be in the range of 1-90 degrees.\n    \n    Returns:\n    - A float representing the total time of the motion. The result is rounded to 2 decimal places.\n    \"\"\"\n    check_args(init_velocity, angle)\n    angle_rad = angle_to_radians(angle)\n    total_time = (2 * init_velocity * sin(angle_rad)) / g\n    return round(total_time, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef total_time(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "horizontal_distance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "def horizontal_distance(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Calculates the horizontal distance that an object will cover given its initial velocity and launch angle.\n    \n    Args:\n    init_velocity (float): Initial velocity of the object (positive number).\n    angle (float): Angle at which the object is launched (1-90 degrees).\n    \n    Returns:\n    float: Horizontal distance covered by the object (rounded to 2 decimal places).\n    \"\"\"\n    check_args(init_velocity, angle)\n    alpha = angle_to_radians(angle)\n    distance = (init_velocity ** 2 * sin(2 * alpha)) / g\n    return round(distance, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "Python", "full_method_name": "max_height", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "def max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Calculates the maximum height that an object can reach during its trajectory\n    Formula:\n            v_0^2 * sin^2(alpha)\n            ---------------------\n                   2 * g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    11.54\n    >>> max_height(100, 78)\n    67.68\n    >>> max_height(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> max_height(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round((init_velocity ** 2 * sin(radians) ** 2) / (2 * g), 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\n\n\ndef max_height(init_velocity: float, angle: float) ->float: [MASK]\n"}
