{"model_name": "gpt-3.5-turbo", "repository": "detect-secrets", "full_method_name": "get_code_snippet", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/detect-secrets/detect_secrets/util/code_snippet.py", "response": "    start_line = max(0, line_number - lines_of_context)\n    end_line = min(len(lines), line_number + lines_of_context + 1)\n    snippet = lines[start_line:end_line]\n    target_index = line_number - start_line\n    return CodeSnippet(snippet, start_line + 1, target_index)", "test_code_list": [{"test_code": "import pytest\ndef test_target_line():\n    assert get_code_snippet(list('abcde'), 3, lines_of_context=2\n        ).target_line == 'c'\n\ntest_target_line()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/detect-secrets/tests/util/code_snippet_test.py"}, {"test_code": "import pytest\ndef test_previous_line():\n    assert get_code_snippet(list('abcde'), 3, lines_of_context=2\n        ).previous_line == 'b'\n\ntest_previous_line()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/detect-secrets/tests/util/code_snippet_test.py"}], "method_code_mask": "from typing import Generator\nfrom typing import List\n\n\nclass CodeSnippet:\n\n    def __init__(self, snippet: List[str], start_line: int, target_index: int\n        ) ->None:\n        \"\"\"\n        :param snippet: lines of code extracted from file\n        :param start_line: first line number in segment\n        :param target_index: index in snippet of target line\n        \"\"\"\n        self.lines = snippet\n        self.start_line = start_line\n        self.target_index = target_index\n\n    @property\n    def target_line(self) ->str:\n        return self.lines[self.target_index]\n\n    @target_line.setter\n    def target_line(self, value: str) ->None:\n        self.lines[self.target_index] = value\n\n    @property\n    def previous_line(self) ->str:\n        if self.target_index == 0 or len(self.lines) < self.target_index:\n            return ''\n        return self.lines[self.target_index - 1]\n\n    def add_line_numbers(self) ->'CodeSnippet':\n        for index, line in enumerate(self.lines):\n            self.lines[index] = u'{}:{}'.format(self.get_line_number(self.\n                start_line + index + 1), line)\n        return self\n\n    def highlight_line(self, payload: str) ->'CodeSnippet':\n        \"\"\"\n        :param payload: string to highlight, on chosen line\n        \"\"\"\n        try:\n            index_of_payload = self.target_line.lower().index(payload.lower())\n            end_of_payload = index_of_payload + len(payload)\n            self.target_line = u'{}{}{}'.format(self.target_line[:\n                index_of_payload], self.apply_highlight(self.target_line[\n                index_of_payload:end_of_payload]), self.target_line[\n                end_of_payload:])\n            return self\n        except ValueError:\n            raise SecretNotFoundOnSpecifiedLineError(self.target_index)\n\n    def get_line_number(self, line_number: int) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(str(line_number), AnsiColor.LIGHT_GREEN)\n\n    def apply_highlight(self, payload: str) ->str:\n        \"\"\"Broken out, for custom colorization.\"\"\"\n        return colorize(payload, AnsiColor.RED_BACKGROUND)\n\n    def __str__(self) ->str:\n        return '\\n'.join(self.lines)\n\n    def __iter__(self) ->Generator[str, None, None]:\n        yield from self.lines\n\n\ndef get_code_snippet(lines: List[str], line_number: int, lines_of_context:\n    int=5) ->'CodeSnippet': [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "detect-secrets", "full_method_name": "is_sequential_string", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/detect-secrets/detect_secrets/filters/heuristic.py", "response": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\n\ndef is_sequential_string(secret: str) -> bool:\n    alphabet_uppercase = string.ascii_uppercase * 2\n    alphabet_mixed = string.ascii_uppercase + string.digits\n    digits = string.digits * 2\n    hex_digits = string.hexdigits.upper()\n    special_chars = \"!@#$%^&*()_+-=[]{}|;:,.<>?/\"\n    \n    if secret in alphabet_uppercase or secret in alphabet_mixed or secret in digits or secret in hex_digits or secret in special_chars:\n        return True\n    else:\n        return False", "test_code_list": [{"test_code": "import os\nimport pytest\n\nclass TestIsSequentialString():\n    @staticmethod\n    def test_failure():\n        assert not is_sequential_string('BEEF1234')\n    \nTestIsSequentialString().test_failure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/detect-secrets/tests/filters/heuristic_filter_test.py"}], "method_code_mask": "import os\nimport re\nimport string\nfrom functools import lru_cache\nfrom typing import Optional\nfrom typing import Pattern\n\n\ndef is_sequential_string(secret: str) ->bool: [MASK]\n"}
