{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "echelon_form", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "response": "from typing import Optional\nimport gmpy2 as gmpy\n\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) -> int:\n    m = len(a)\n    n = len(a[0])\n    rank = 0\n    if b is not None:\n        for i in range(m):\n            a[i].append(b[i])\n    for j in range(n):\n        i = rank\n        while i < m and a[i][j] == 0:\n            i += 1\n        if i == m:\n            continue\n        if i != rank:\n            a[i], a[rank] = a[rank], a[i]\n        pivot = a[rank][j]\n        for k in range(n):\n            a[rank][k] //= pivot\n        for i in range(rank+1, m):\n            factor = a[i][j]\n            for k in range(n):\n                a[i][k] -= factor * a[rank][k]\n        rank += 1\n    return rank", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass LinAlgUtilTest(absltest.TestCase):\n    def testEchelonForm(self):\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [6, 3, 4, 6], [4, 5, 8, 2]]\n        res_a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -450]]\n        rank = echelon_form(a)\n        self.assertEqual(a, res_a)\n        self.assertEqual(rank, 4)\n        a = [[7, 4, 1, 8], [6, 7, 3, 4], [3, 4, 6, 6], [5, 8, 2, 4]]\n        res_a = [[7, 4, 1, 8], [0, 25, 15, -20], [0, 0, 105, 110], [0, 0, 0, 450]]\n        rank = echelon_form(a)\n        self.assertEqual(a, res_a)\n        self.assertEqual(rank, 4)\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [6, 3, 4, 6], [4, 5, 8, 2]]\n        res_a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -450]]\n        b = [45, 30, 40, 30]\n        res_b = [45, 60, 260, -450]\n        rank = echelon_form(a, b)\n        self.assertEqual(a, res_a)\n        self.assertEqual(b, res_b)\n        self.assertEqual(rank, 4)\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [2 * 8, 2 * 7, 2 * 4, 2 * 1], [6, 3, 4,\n            6], [4, 5, 8, 2]]\n        res_a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -\n            450], [0, 0, 0, 0]]\n        b = [45, 30, 2 * 45, 40, 30]\n        res_b = [45, 60, 260, -450, 0]\n        rank = echelon_form(a, b)\n        self.assertEqual(a, res_a)\n        self.assertEqual(b, res_b)\n        self.assertEqual(rank, 4)\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [0, 0, 0, 0], [0, 0, 0, 0], [6, 3, 4, \n            6], [4, 5, 8, 2]]\n        res_a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -\n            450], [0, 0, 0, 0], [0, 0, 0, 0]]\n        b = [45, 30, 0, 0, 40, 30]\n        res_b = [45, 60, 260, -450, 0, 0]\n        rank = echelon_form(a, b)\n        self.assertEqual(a, res_a)\n        self.assertEqual(b, res_b)\n        self.assertEqual(rank, 4)\n    \nLinAlgUtilTest().testEchelonForm()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util_test.py"}], "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "upper_triangular_solve", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "response": "from typing import Optional\nimport gmpy2 as gmpy\n\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) -> Optional[list[gmpy.mpq]]:\n    n = len(a)\n    x = [gmpy.mpq(0) for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        if a[i][i] == 0:\n            return None\n        x[i] = gmpy.mpq(b[i]) / gmpy.mpq(a[i][i])\n        for j in range(i-1, -1, -1):\n            b[j] -= a[j][i] * x[i]\n    return x", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass LinAlgUtilTest(absltest.TestCase):\n    def testUpperTriangularSolve(self):\n        a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -450]]\n        b = [45, 60, 260, -450]\n        res = [5, 0, 1, 1]\n        x = upper_triangular_solve(a, b)\n        self.assertEqual(x, res)\n        a = [[0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -450], [0, 0, 0, 0]]\n        b = [60, 260, -450, 0]\n        res = None\n        x = upper_triangular_solve(a, b)\n        self.assertEqual(x, res)\n        a = [[20, 40, 20], [0, 110, 150], [0, 0, -450]]\n        b = [60, 260, -450]\n        res = [0, 1, 1]\n        x = upper_triangular_solve(a, b)\n        self.assertEqual(x, res)\n    \nLinAlgUtilTest().testUpperTriangularSolve()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util_test.py"}], "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "solve_right", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util.py", "response": "def solve_right(a: list[list[int]], b: list[int]) -> Optional[list[gmpy.mpq]]:\n    nrows, ncols = len(a), len(a[0])\n    if nrows != ncols:\n        raise ValueError('Matrix must be square.')\n    if nrows != len(b):\n        raise ValueError('Number of rows of a must be equal to the length of b.')\n    \n    rank = echelon_form(a)\n    if rank != ncols:\n        return None\n    \n    return upper_triangular_solve(a, b)", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass LinAlgUtilTest(absltest.TestCase):\n    def testSolveRight(self):\n        a = [[8, 7, 4, 1], [0, 20, 40, 20], [0, 0, 110, 150], [0, 0, 0, -450]]\n        b = [45, 60, 260, -450]\n        res = [5, 0, 1, 1]\n        x = solve_right(a, b)\n        self.assertEqual(x, res)\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [2 * 8, 2 * 7, 2 * 4, 2 * 1], [6, 3, 4,\n            6], [4, 5, 8, 2]]\n        b = [45, 30, 2 * 45, 40, 30]\n        res = [5, 0, 1, 1]\n        x = solve_right(a, b)\n        self.assertEqual(x, res)\n        a = [[8, 7, 4, 1], [4, 6, 7, 3], [0, 0, 0, 0], [0, 0, 0, 0], [6, 3, 4, \n            6], [4, 5, 8, 2]]\n        b = [45, 30, 0, 0, 40, 30]\n        res = [5, 0, 1, 1]\n        x = solve_right(a, b)\n        self.assertEqual(x, res)\n    \nLinAlgUtilTest().testSolveRight()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/linalg_util_test.py"}], "method_code_mask": "from typing import Optional\nimport gmpy2 as gmpy\n\n\ndef upper_triangular_solve(a: list[list[int]], b: list[int]) ->Optional[list\n    [gmpy.mpq]]:\n    \"\"\"Solves a matrix equation a*x = b, with a being an upper triangular matrix.\n\n  Given an integer upper triangular matrix 'a' with m rows and m columns, and an\n  integer vector b of size m, this function finds the vector of rationals\n  (gmpy.mpq) x for the equation a*x = b.\n\n  Args:\n    a: upper triangular matrix of integers with m rows and m columns.\n    b: vector of integers of size m.\n\n  Returns:\n    A solution x for a*x == b over the rationals if found. If a zero on the\n      diagonal is found it returns None.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if nrows != ncols:\n        raise ValueError('Matrix must be square.')\n    if nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    xs = [0] * ncols\n    for i in range(nrows - 1, -1, -1):\n        den = a[i][i]\n        if den == 0:\n            return None\n        num = b[i] - sum(a[i][j] * xs[j] for j in range(i + 1, ncols))\n        xs[i] = gmpy.mpq(num, den)\n    return xs\n\n\ndef echelon_form(a: list[list[int]], b: Optional[list[int]]=None) ->int:\n    \"\"\"Puts the matrix of integers a in row echelon form.\n  All the operations are over the integers. Only exact divisions are performed.\n  Thus, this function is useful when working over the integers.\n  This is an adapted implementation of the proposal of Peter R. Turner,\n  'A Simplified Fraction-Free Integer Gauss Elimination Algorithm', U. S. Naval\n  Academy, 1995. The difference is that the original algorithm doesn't perform\n  row swapping to the bottom when linear dependent rows are found, and fails\n  when encounters zero pivots.\n  It is interesting to note that the last element of the matrix in echelon form\n  through this algorithm is the determinat of the original matrix.\n  In order to work with Integers only, comparing with original gaussian\n  elimination, it requires twice multiplications and divisions are increased\n  from O(n^2) to O(n^3). The author, however, shows that working with Rationals\n  wouldn't provide any improvement, and would require additional GCD\n  computations.\n  The b parameter can be provided for the useful cases when solving a linear\n  system. I.e., it will be equivalent of performing gaussian elimination on the\n  augmented matrix a||b.\n  The changes on a and b are in place. Thus, if one wants to preserve the\n  original a and b, one should pass copies of them to this function. The return\n  value is the rank of the matrix a.\n  Args:\n    a: matrix of integers with m rows and n columns, with m >= n.\n    b: optional vector of integers of size m. Useful when solving a system.\n  Returns:\n    rank of a.\n  \"\"\"\n    nrows, ncols = len(a), len(a[0])\n    if b and nrows != len(b):\n        raise ValueError(\n            'Number of rows of a must be equal to the length of b.')\n    n = min(nrows, ncols)\n    rank = 1\n    i = 0\n    while i < n - 1:\n        pivots = i\n        while pivots < n - 1 and a[i][i] == 0:\n            if b:\n                b.insert(nrows, b.pop(i))\n            a.insert(nrows, a.pop(i))\n            pivots += 1\n        j = i + 1\n        while j < nrows:\n            if b:\n                b[j] = a[i][i] * b[j] - a[j][i] * b[i]\n            all_zeros = True\n            for k in range(i + 1, ncols):\n                a[j][k] = a[i][i] * a[j][k] - a[j][i] * a[i][k]\n                if all_zeros and a[j][k] != 0:\n                    all_zeros = False\n            a[j][i] = 0\n            if all_zeros:\n                if b:\n                    b.insert(nrows, b.pop(j))\n                a.insert(nrows, a.pop(j))\n                nrows -= 1\n            else:\n                if rank < n:\n                    rank += 1\n                j += 1\n        if i >= 1:\n            for j in range(i + 1, nrows):\n                if b:\n                    b[j] //= a[i - 1][i - 1]\n                for k in range(i + 1, ncols):\n                    a[j][k] //= a[i - 1][i - 1]\n        i += 1\n    if all([(v == 0) for v in a[nrows - 1]]):\n        rank -= 1\n    return rank\n\n\ndef solve_right(a: list[list[int]], b: list[int]) ->Optional[list[gmpy.mpq]]: [\n    MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "Inverse2exp", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "response": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Inverse2exp(n: int, k: int) -> Optional[int]:\n    if n % 2 == 0:\n        return None\n    return int(gmpy.invert(n, 2**k))", "test_code_list": [{"test_code": "import random\nfrom absl.testing import absltest\n\nclass NTheoryUtilTest(absltest.TestCase):\n    def testInverse2exp(self):\n        for i in range(1, 257):\n            x = random.getrandbits(i) | 1\n            a = Inverse2exp(x, i)\n            self.assertEqual(a * x % 2 ** i, 1)\n    \nNTheoryUtilTest().testInverse2exp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util_test.py"}], "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Inverse2exp(n: int, k: int) ->Optional[int]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "InverseSqrt2exp", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "response": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef InverseSqrt2exp(n: int, k: int) -> Optional[int]:\n    for a in itertools.count(1):\n        if gmpy.divm(1, a * a, 2**k) == n:\n            return a\n    return None", "test_code_list": [{"test_code": "import random\nfrom absl.testing import absltest\n\nclass NTheoryUtilTest(absltest.TestCase):\n    def testInverseSqrt2exp(self):\n        for i in range(1, 257):\n            x = random.getrandbits(i)\n            x -= x % 8\n            x += 1\n            a = InverseSqrt2exp(x, i)\n            self.assertEqual(a * a * x % 2 ** i, 1)\n    \nNTheoryUtilTest().testInverseSqrt2exp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util_test.py"}], "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "Sqrt2exp", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util.py", "response": "def Sqrt2exp(n: int, k: int) ->list[int]:\n    \"\"\"Computes all square roots of a given odd integer n modulo 2**k.\n    \n    Args:\n        n: an odd integer for which the square roots are computed\n        k: the exponent of the modulus 2**k, indicating the bit-size of the result.\n    \n    Returns:\n        Returns a list of all x mod 2**k such that x * x % 2**k == n % 2**k. If no square roots exist, an empty list is returned.\n    \"\"\"\n    if k < 3:\n        result = []\n        for x in range(2 ** k):\n            if x * x % (2 ** k) == n % (2 ** k):\n                result.append(x)\n        return result\n    if n % 8 != 1:\n        return []\n    a = InverseSqrt2exp(n, k)\n    if a is None:\n        return []\n    result = []\n    for x in range(2 ** k):\n        if x * x % (2 ** k) == n % (2 ** k):\n            result.append(gmpy.f_mod_2exp(a * x, k))\n    return result", "test_code_list": [{"test_code": "import random\nfrom absl.testing import absltest\n\nclass NTheoryUtilTest(absltest.TestCase):\n    def testSqrt2exp(self):\n        for i in range(1, 257):\n            x = random.getrandbits(i)\n            x -= x % 8\n            x += 1\n            roots = Sqrt2exp(x, i)\n            if i >= 3:\n                self.assertLen(set(roots), 4)\n            for r in roots:\n                self.assertEqual(x, r * r % 2 ** i)\n    \nNTheoryUtilTest().testSqrt2exp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/ntheory_util_test.py"}], "method_code_mask": "import itertools\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Inverse2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Computes the inverse of n modulo 2**k.\n\n  Args:\n    n: an odd value that is inverted\n    k: the exponent of the modulus 2**k\n\n  Returns:\n    a, such that 1 == a * n % 2**k or None if no inverse extists.\n  \"\"\"\n    if n % 2 == 0:\n        return None\n    a = n % 4\n    t = 2\n    while t < k:\n        t = min(k, 2 * t)\n        a = gmpy.f_mod_2exp(a * (2 - a * n), t)\n    return a\n\n\ndef InverseSqrt2exp(n: int, k: int) ->Optional[int]:\n    \"\"\"Returns a, such that 1 == a * a * n % 2**k or None if no solution exists.\n  Args:\n    n: the value for which the inverse square root is computed\n    k: the bit-size of the result.\n  \"\"\"\n    if k < 3:\n        for a in range(2 ** k):\n            if a * a * n % 2 ** k == 1:\n                return a\n        return None\n    if n % 8 != 1:\n        return None\n    a = 1\n    t = 3\n    while t < k:\n        t = min(k, 2 * t - 2)\n        a = gmpy.f_mod_2exp(a * (3 - a * a * n) // 2, t)\n    return a\n\n\ndef Sqrt2exp(n: int, k: int) ->list[int]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "FermatFactor", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util.py", "response": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\ndef FermatFactor(n: int, max_steps: int) -> Optional[tuple[int, int]]:\n    a = gmpy.isqrt(n)\n    b2 = gmpy.square(a) - n\n    step = 0\n    \n    while not gmpy.is_square(b2) and step < max_steps:\n        a += 1\n        b2 = gmpy.square(a) - n\n        step += 1\n        \n    if step < max_steps:\n        b = gmpy.isqrt(b2)\n        return a + b, a - b\n    else:\n        return None", "test_code_list": [{"test_code": "import random\nfrom absl.testing import absltest\nimport gmpy2 as gmpy\n\nclass RsaUtilTest(absltest.TestCase):\n    def testFermat(self):\n        p_fermat = gmpy.next_prime(random.getrandbits(1024))\n        q_fermat = gmpy.next_prime(p_fermat + 2 ** 100)\n        max_steps = 2\n        result = FermatFactor(p_fermat * q_fermat, max_steps)\n        self.assertEqual(result[0] * result[1], p_fermat * q_fermat)\n        result = FermatFactor(2 * p_fermat, max_steps)\n        self.assertEqual(result[0] * result[1], 2 * p_fermat)\n        result = FermatFactor(q_fermat * q_fermat, max_steps)\n        self.assertEqual(result[0] * result[1], q_fermat * q_fermat)\n    \nRsaUtilTest().testFermat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util_test.py"}], "method_code_mask": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef FermatFactor(n: int, max_steps: int) ->Optional[tuple[int, int]]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "Pollardpm1", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util.py", "response": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\ndef Pollardpm1(n: int, m: Optional[int]=None, gcd_bound: int=2 ** 60) -> tuple[bool, list[int]]:\n    if m is None:\n        m = 2 ** 10\n\n    a = 2\n    for j in range(2, m):\n        a = pow(a, j, n)\n        d = gmpy.gcd(a - 1, n)\n        if 1 < d < n:\n            return True, [d, n // d]\n    return False, []", "test_code_list": [{"test_code": "import random\nfrom absl.testing import absltest\nimport gmpy2 as gmpy\n\nclass RsaUtilTest(absltest.TestCase):\n    def testPollardpm1(self):\n        res, factors = Pollardpm1(23 * 47, m=2 * 3 * 5 * 7 * 11,\n            gcd_bound=1)\n        self.assertTrue(res)\n        self.assertEqual(factors[0] * factors[1], 23 * 47)\n        res, factors = Pollardpm1(23 * 47, m=2 * 3 * 5 * 7 * 11 * 23,\n            gcd_bound=1)\n        self.assertTrue(res)\n        self.assertEmpty(factors)\n        res, factors = Pollardpm1(23 * 47, m=2 * 3 * 5 * 7, gcd_bound=1)\n        self.assertFalse(res)\n        self.assertEmpty(factors)\n        res, factors = Pollardpm1(23 * 47, m=2 * 3 * 5 * 7 * 11 * 23)\n        self.assertFalse(res)\n        self.assertEmpty(factors)\n    \nRsaUtilTest().testPollardpm1()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/rsa_util_test.py"}], "method_code_mask": "import heapq\nfrom typing import Optional\nimport gmpy2 as gmpy\n\n\ndef Pollardpm1(n: int, m: Optional[int]=None, gcd_bound: int=2 ** 60) ->tuple[\n    bool, list[int]]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "ReverseBits", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def ReverseBits(seq: int, length: int) -> int:\n    byte_array = seq.to_bytes((length + 7) // 8, byteorder='big')\n    reversed_bytes = bytes([_REVERSE_BITS[b] for b in byte_array])\n    return int.from_bytes(reversed_bytes, byteorder='big')", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testReverseBits(self):\n        bit_string = '10010100010100100010100011111111011010011111010101011000000'\n        for size in range(1, len(bit_string) + 1):\n            x = int(bit_string[:size], 2)\n            x_reversed = int(bit_string[:size][::-1], 2)\n            self.assertEqual(x_reversed, ReverseBits(x, size))\n    \nUtilTest().testReverseBits()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef _ReversedBytes() ->bytes:\n    \"\"\"Returns a table to reverse bits in a byte array.\n\n  The result of this function can be used to reverse the bits in each byte by\n  using bytes.translate() or bytearray.translate().\n\n  Returns:\n    the translation table\n  \"\"\"\n    res = bytearray(256)\n    for j in range(1, 256):\n        res[j] = res[j >> 1] >> 1 ^ (j & 1) << 7\n    return bytes(res)\n\n\n_REVERSE_BITS = _ReversedBytes()\n\n\ndef ReverseBits(seq: int, length: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "Scatter", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\ndef Scatter(seq: int, m: int) -> list[int]:\n    seq_bits = bin(seq)[2:]  # Convert integer to binary string and remove '0b' prefix\n    result = []\n    \n    if len(seq_bits) < m:\n        for i in range(len(seq_bits)):\n            result.append(int(seq_bits[i]))\n    else:\n        for i in range(m):\n            result.append(int(seq_bits[i::m], 2))  # Extract bits i, i+m, i+2m, ... and convert to integer\n    \n    return result", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testScatter(self):\n        self.assertEqual([1, 1, 0, 0], Scatter(3, 4))\n        self.assertEqual([23, 0], Scatter(277, 2))\n        self.assertEqual([3, 63, 15], Scatter(77247, 3))\n        self.assertEqual([31, 15, 7, 3, 1], Scatter(1154559, 5))\n        self.assertEqual([1, 3, 7, 15, 31], Scatter(17593311, 5))\n    \nUtilTest().testScatter()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef Scatter(seq: int, m: int) ->list[int]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "UniformSumCdf", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def UniformSumCdf(n: int, x: float) -> float:\n    if x < 0:\n        return 0.0\n    elif x > n:\n        return 1.0\n    else:\n        return scipy_stats.beta.cdf(x / n, n / 2, 0.5)", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testUniformSumCdf(self):\n        self.assertAlmostEqual(0.0, UniformSumCdf(5, 0.0))\n        self.assertAlmostEqual(1.0, UniformSumCdf(5, 5.0))\n        self.assertAlmostEqual(0.765432, UniformSumCdf(1, 0.765432))\n        self.assertAlmostEqual(0.5, UniformSumCdf(20, 10.0))\n        self.assertAlmostEqual(0.079092, UniformSumCdf(24, 10.0), delta=1e-06)\n        self.assertAlmostEqual(0.046647, UniformSumCdf(30, 12.3456), delta\n            =1e-06)\n        self.assertAlmostEqual(0.725947, UniformSumCdf(33, 17.5), delta=1e-06)\n        self.assertAlmostEqual(0.094689, UniformSumCdf(40, 17.6), delta=0.001)\n        self.assertAlmostEqual(0.40159, UniformSumCdf(48, 23.5), delta=0.001)\n        self.assertAlmostEqual(0.5, UniformSumCdf(51, 25.5), delta=0.001)\n        self.assertAlmostEqual(0.242262, UniformSumCdf(55, 26), delta=0.001)\n        self.assertAlmostEqual(0.122883, UniformSumCdf(80, 37), delta=0.001)\n        self.assertAlmostEqual(0.5, UniformSumCdf(101, 50.5), delta=0.001)\n    \nUtilTest().testUniformSumCdf()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef NormalCdf(x: float, mean: float, variance: float) ->float:\n    \"\"\"Cumulative distribution function of the normal distribution.\n\n  See en.wikipedia.org/wiki/Normal_distribution\n  NIST SP 800-22a defines in Section 5.5.3 a function Cdf. This is\n  the same as NormalCdf with mean 0.0 and variance 1.0.\n\n  Args:\n    x: a value in the range -infinity .. infinity\n    mean: the mean value of the distribution\n    variance: the variance of the distribtuion\n\n  Returns:\n    a p-value\n  \"\"\"\n    return (1 + math.erf((x - mean) / math.sqrt(2 * variance))) / 2\n\n\ndef UniformSumCdf(n: int, x: float) ->float: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "CombinedPValue", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def CombinedPValue(pvalues: list[float]) -> float:\n    if len(pvalues) == 0:\n        raise ValueError(\"Input list of p-values must not be empty\")\n    \n    # Handle special case where p-values are exactly 0\n    if any(p == 0 for p in pvalues):\n        return 0.0\n    \n    # Calculate the combined p-value using Fisher's method\n    combined_pvalue = 1.0 - Igamc((len(pvalues) - 1) / 2.0, -2.0 * sum(math.log(p) for p in pvalues))\n    \n    return combined_pvalue", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testCombinedPValue(self):\n        x = 0.324523\n        self.assertAlmostEqual(x, CombinedPValue([x]))\n        self.assertAlmostEqual(0, CombinedPValue([0, x]))\n        self.assertAlmostEqual(1.0, CombinedPValue([1.0, 1.0]), delta=1e-06)\n        self.assertAlmostEqual(0.835315, CombinedPValue([0.782334, \n            0.618821]), delta=1e-06)\n        self.assertAlmostEqual(0.051865, CombinedPValue([0.125421, \n            0.123541, 0.125134]), delta=1e-06)\n        self.assertAlmostEqual(4.25785e-07, CombinedPValue([1e-06, 0.0002,\n            0.9999, 1.0]), delta=1e-06)\n        self.assertAlmostEqual(0.603512, CombinedPValue([0.1, 0.2, 0.3, \n            0.4, 0.5, 0.6, 0.7, 0.8, 0.9]), delta=1e-06)\n        self.assertAlmostEqual(0.538353, CombinedPValue([(0.001 * i) for i in\n            range(1, 1000)]), delta=1e-06)\n    \nUtilTest().testCombinedPValue()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef Igamc(a: float, x: float) ->float:\n    \"\"\"Computes the regularized upper incomplete gamma function.\n\n  NIST defines the function in section 5.5.3 of NIST SP-800 22 and calls\n  it igmac. Wikipedia denotes the function as Q(a, x).\n\n  The function is mainly used to compute p-values for statistical tests.\n  The result does not have to be very precise (e.g. 6 digits of precision are\n  more than enough). However, the implementation is expected to handle\n  floating point underflows and return 0 in such cases.\n\n  Args:\n    a: a positive floating point number\n    x: floating point number that is 0 or positive\n\n  Returns:\n    a p-value\n  \"\"\"\n    return scipy_special.gammaincc(a, x)\n\n\ndef CombinedPValue(pvalues: list[float]) ->float: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "SubSequences", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\ndef SubSequences(seq: int, length: int, m: int, wrap: bool=True) -> Iterator[int]:\n    if m <= 0:\n        raise ValueError(\"m must be a positive integer\")\n    if length < 0:\n        raise ValueError(\"length cannot be negative\")\n    if len(bin(seq)) - 2 > length:\n        raise ValueError(\"Bit-length of seq exceeds specified length\")\n    if m > length:\n        raise ValueError(\"m cannot be larger than the specified length\")\n    \n    if wrap:\n        seq = seq % (1 << length)\n    \n    for i in range(length):\n        subseq = (seq >> i) & ((1 << m) - 1)\n        yield subseq\n", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testSubSequencesWrap(self):\n        x = 1712\n        a = list(SubSequences(x, 11, 4, wrap=True))\n        self.assertCountEqual([13, 10, 5, 11, 6, 12, 8, 0, 1, 3, 6], a)\n    \nUtilTest().testSubSequencesWrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}, {"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testSubSequencesNoWrap(self):\n        x1 = 1712\n        a1 = list(SubSequences(x1, 11, 4, wrap=False))\n        self.assertCountEqual([13, 10, 5, 11, 6, 12, 8, 0], a1)\n        x2 = 46063\n        a2 = list(SubSequences(x2, 16, 8, wrap=False))\n        self.assertCountEqual([179, 103, 207, 159, 62, 125, 251, 247, 239], a2)\n    \nUtilTest().testSubSequencesNoWrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}, {"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testSubSequencesCount(self):\n        for m in range(2, 10):\n            sub_sequence = (1 << m) - 1\n            for length in range(m, 30):\n                bits = (1 << length) - 1\n                c_wrap = list(SubSequences(bits, length, m))\n                self.assertEqual([sub_sequence] * length, c_wrap)\n                c_nowrap = list(SubSequences(bits, length, m, wrap=False))\n                self.assertEqual([sub_sequence] * (length - m + 1), c_nowrap)\n    \nUtilTest().testSubSequencesCount()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef SubSequences(seq: int, length: int, m: int, wrap: bool=True) ->Iterator[int\n    ]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "SplitSequence", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def SplitSequence(seq: int, length: int, m: int) -> list[int]:\n    blocks = []\n    for i in range(0, length, m):\n        block = seq >> i & ((1 << m) - 1)\n        blocks.append(block)\n    return blocks", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testSplitSequence(self):\n        bit_string = (\n            '1111011101010010001010001111111101110111101010100101010001110010100010111111110101010101111111111001111111111111111111'\n            )\n        seq = int(bit_string, 2)\n        for size in range(3, 17):\n            n = len(bit_string) // size\n            expected = [((seq >> i * size) % 2 ** size) for i in range(n)]\n            res = SplitSequence(seq, len(bit_string), size)\n            self.assertEqual(expected, res)\n    \nUtilTest().testSplitSequence()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef SplitSequence(seq: int, length: int, m: int) ->list[int]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "Runs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def Runs(s: int, length: int) -> int:\n    binary_str = bin(s)[2:].zfill(length)\n    runs = 1\n    for i in range(1, length):\n        if binary_str[i] != binary_str[i-1]:\n            runs += 1\n    return runs", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testRuns(self):\n        self.assertEqual(1, Runs(0, 16))\n        self.assertEqual(1, Runs(65535, 16))\n        self.assertEqual(16, Runs(21845, 16))\n        self.assertEqual(16, Runs(43690, 16))\n        self.assertEqual(7, Runs(1419, 11))\n    \nUtilTest().testRuns()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\n\n\ndef Runs(s: int, length: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "LongestRunOfOnes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def LongestRunOfOnes(seq: int) -> int:\n    binary_seq = bin(seq)[2:]\n    max_count = 0\n    count = 0\n    \n    for digit in binary_seq:\n        if digit == '1':\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    \n    return max_count", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testLongestRunOfOnes(self):\n        self.assertEqual(0, LongestRunOfOnes(0))\n        self.assertEqual(1, LongestRunOfOnes(43604))\n        self.assertEqual(4, LongestRunOfOnes(20313))\n        self.assertEqual(5, LongestRunOfOnes(20319))\n        self.assertEqual(6, LongestRunOfOnes(64829))\n        self.assertEqual(17, LongestRunOfOnes(131071))\n    \nUtilTest().testLongestRunOfOnes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef LongestRunOfOnes(seq: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "OverlappingRunsOfOnes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def OverlappingRunsOfOnes(seq: int, m: int) -> int:\n    binary_seq = bin(seq)[2:]  # Convert integer to binary string\n    count = 0\n    for i in range(len(binary_seq) - m + 1):\n        if binary_seq[i:i+m] == '1' * m:\n            count += 1\n    return count", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testOverlappingRunsOfOnes(self):\n        self.assertEqual(15, OverlappingRunsOfOnes(375775, 1))\n        self.assertEqual(10, OverlappingRunsOfOnes(375775, 2))\n        self.assertEqual(6, OverlappingRunsOfOnes(375775, 3))\n        self.assertEqual(3, OverlappingRunsOfOnes(375775, 4))\n        self.assertEqual(1, OverlappingRunsOfOnes(375775, 5))\n        self.assertEqual(0, OverlappingRunsOfOnes(375775, 6))\n    \nUtilTest().testOverlappingRunsOfOnes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef BitCount(s: int) ->int:\n    \"\"\"Counts the number of bits in an integer.\n\n  Python 3.10 will allow to use s.bit_count().\n\n  Args:\n    s: a non-negative integer\n\n  Returns:\n    the number of 1 bits in s.\n  \"\"\"\n    return gmpy.popcount(s)\n\n\ndef OverlappingRunsOfOnes(seq: int, m: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "BinaryMatrixRank", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util.py", "response": "def BinaryMatrixRank(matrix: list[int]) -> int:\n    \"\"\"Computes the rank of a binary matrix.\n\n    This implementation is used for large matrices.\n\n    Args:\n        matrix: the binary matrix represented as a list of rows.\n\n    Returns:\n        the rank of the matrix\n    \"\"\"\n    if len(matrix) == 0:\n        return 0\n\n    n = len(matrix)\n    m = len(matrix[0])\n\n    rank = 0\n    for j in range(m):\n        pivot_row = -1\n        for i in range(rank, n):\n            if (matrix[i] & (1 << (m - j - 1))) != 0:\n                pivot_row = i\n                break\n\n        if pivot_row != -1:\n            matrix[rank], matrix[pivot_row] = matrix[pivot_row], matrix[rank]\n\n            for i in range(n):\n                if i != rank and (matrix[i] & (1 << (m - j - 1))) != 0:\n                    matrix[i] ^= matrix[rank]\n\n            rank += 1\n\n    return rank", "test_code_list": [{"test_code": "import collections\nimport os\nfrom absl.testing import absltest\n\nclass UtilTest(absltest.TestCase):\n    def testBinaryMatrixRank(self):\n        self.assertEqual(0, BinaryMatrixRank([0, 0, 0, 0]))\n        self.assertEqual(1, BinaryMatrixRank([0, 13, 0, 13]))\n        self.assertEqual(3, BinaryMatrixRank([3, 5, 7]))\n        self.assertEqual(4, BinaryMatrixRank([15, 23, 27, 29, 30]))\n        self.assertEqual(4, BinaryMatrixRank(list(range(16))))\n        self.assertEqual(2, BinaryMatrixRank([5461, 2730, 8191]))\n    \nUtilTest().testBinaryMatrixRank()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/util_test.py"}], "method_code_mask": "import array\nfrom collections.abc import Iterator\nimport math\nimport gmpy2 as gmpy\nimport numpy\nfrom scipy import fftpack as scipy_fft\nfrom scipy import special as scipy_special\nfrom scipy import stats as scipy_stats\n\n\ndef _BinaryMatrixRankSmall(matrix: list[int]) ->int:\n    \"\"\"Computes the rank of a binary matrix.\n\n  This implementation is used for small matrices.\n\n  Args:\n    matrix: the binary matrix represented as a list of rows.\n\n  Returns:\n    the rank of the matrix\n  \"\"\"\n    m = matrix[:]\n    rank = 0\n    for i in range(len(m)):\n        if m[i]:\n            rank += 1\n            msb = 1 << m[i].bit_length() - 1\n            for j in range(i + 1, len(m)):\n                if m[j] & msb:\n                    m[j] ^= m[i]\n    return rank\n\n\ndef BinaryMatrixRank(matrix: list[int]) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "PseudoAverage", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/lattice_suite.py", "response": "import math\nfrom typing import Optional\n\ndef PseudoAverage(a: list[int], n: int) -> int:\n    b = [(x + n) % n for x in a]\n    b.sort()\n    return sum(b) // len(b)", "test_code_list": [{"test_code": "from absl.testing import absltest\nfrom absl.testing import parameterized\n\nclass LatticeSuiteTest(parameterized.TestCase):\n    def testPseudoAverage(self):\n        self.assertEqual(9, PseudoAverage([7, 8, 9, 0, 1], 10))\n        self.assertEqual(0, PseudoAverage([8, 9, 0, 1, 2], 10))\n        self.assertEqual(5, PseudoAverage([1, 3, 5, 7, 9], 11))\n        self.assertEqual(3, PseudoAverage([3], 10))\n        self.assertEqual(9, PseudoAverage([0, 0, 9, 9, 9], 10))\n    \nLatticeSuiteTest().testPseudoAverage()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/lattice_suite_test.py"}], "method_code_mask": "import math\nfrom typing import Optional\n\n\ndef PseudoAverage(a: list[int], n: int) ->int: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "RankDistribution", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef RankDistribution(r: int, c: int, k: int, allow_approximation: bool=True) -> list[float]:\n    if allow_approximation and (r > 10 or c > 10):\n        return [0.0] * (k + 1)\n    \n    def rank_distribution(m):\n        rank = numpy.linalg.matrix_rank(m)\n        return rank\n\n    total = 2 ** (r * c)\n    probabilities = collections.Counter()\n    \n    for i in range(total):\n        binary = format(i, f'0{r * c}b')\n        matrix = numpy.array([int(x) for x in binary]).reshape(r, c)\n        probabilities[rank_distribution(matrix)] += 1\n\n    result = [probabilities[i] / total for i in range(k + 1)]\n    \n    return result", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass NistSuite(absltest.TestCase):\n    def testRankDistribution(self):\n        computed = RankDistribution(32, 32, 3, allow_approximation=False\n            )\n        approximation = RankDistribution(32, 32, 3,\n            allow_approximation=True)\n        for x, y in zip(computed, approximation):\n            self.assertAlmostEqual(x, y)\n        experiments = [(3, 3, 2, [0.3281, 0.5742, 0.0977]), (6, 8, 3, [0.7731, \n            0.2175, 0.0093, 0.0001]), (8, 8, 3, [0.2899, 0.5775, 0.1274, 0.0052])]\n        for rows, cols, k, measured in experiments:\n            computed = RankDistribution(rows, cols, k)\n            for x, y in zip(computed, measured):\n                self.assertAlmostEqual(x, y, delta=0.0001)\n    \nNistSuite().testRankDistribution()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite_test.py"}], "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef RankDistribution(r: int, c: int, k: int, allow_approximation: bool=True\n    ) ->list[float]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "OverlappingTemplateMatchingDistribution", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "response": "def OverlappingTemplateMatchingDistribution(n: int, m: int, k: int) -> list[float]:\n    \"\"\"Calculates the probability distribution for the number of overlapping runs of 1s in a random bit string.\n\n    Args:\n        n: An integer representing the size of the bit string.\n        m: An integer representing the length of the runs of 1s.\n        k: An integer representing the maximum number of occurrences of runs of 1s.\n\n    Returns:\n        A list of size k+1 representing the probability distribution.\n    \"\"\"\n    transition_matrix = OverlappingTemplateMatchingMatrix(m, k)\n    initial_state = [1] + [0] * (k * m)\n    current_state = initial_state\n    distribution = [0.0] * (k + 1)\n\n    for _ in range(n):\n        next_state = numpy.dot(current_state, transition_matrix)\n        distribution = [distribution[i] + next_state[i] for i in range(k + 1)]\n        current_state = next_state\n\n    return distribution", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass NistSuite(absltest.TestCase):\n    def testOverlappingTemplateMatchingDistribution(self):\n        experimental_results = [(2, 7, 5, [0.265605, 0.29688, 0.226569, \n            0.124999, 0.062502, 0.023444]), (2, 9, 5, [0.17381, 0.253906, \n            0.238288, 0.167985, 0.097647, 0.068365]), (2, 10, 5, [0.140639, \n            0.229499, 0.235349, 0.182621, 0.11327, 0.098622]), (3, 18, 5, [\n            0.251821, 0.23082, 0.188961, 0.134695, 0.086656, 0.107046]), (4, 35,\n            5, [0.300125, 0.212536, 0.165604, 0.118438, 0.079562, 0.123733]), (\n            5, 68, 5, [0.328983, 0.200776, 0.15322, 0.109931, 0.075357, \n            0.131734]), (6, 133, 5, [0.345821, 0.193634, 0.146409, 0.105333, \n            0.072948, 0.135856]), (7, 262, 5, [0.355497, 0.189442, 0.142646, \n            0.102771, 0.071611, 0.138031]), (8, 519, 5, [0.360977, 0.187058, \n            0.140558, 0.101353, 0.070845, 0.139207]), (9, 1032, 5, [0.364124, \n            0.185647, 0.139349, 0.10056, 0.070437, 0.139882]), (10, 2057, 5, [\n            0.365796, 0.184898, 0.138723, 0.10015, 0.070206, 0.140227]), (8, \n            391, 5, [0.465524, 0.181114, 0.124346, 0.083009, 0.054211, 0.091797])]\n        for m, block_size, k, pi_obs in experimental_results:\n            pi = OverlappingTemplateMatchingDistribution(block_size,\n                m, k)\n            self.assertSequenceAlmostEqual(pi_obs, pi, delta=0.0001)\n    \nNistSuite().testOverlappingTemplateMatchingDistribution()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite_test.py"}], "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef OverlappingTemplateMatchingMatrix(m: int, k: int) ->list[list[float]]:\n    \"\"\"Returns a transition probability matrix for the overlapping template test.\n\n  The overlapping template test counts the number of runs of 1s of size m in a\n  bit sequence. To compute the distribution of the number of runs of 1s we use\n  a Markov chain with k * m + 1 states. A bit string with i runs of 1s ending\n  with j 1s corresponds to state min(k * m, i * m + min(k - 1, j)).\n  The Markov chain described here stops counting after seeing k runs of size m.\n  I.e., state k*m is used for any case where k or more runs have occurred.\n  The matrix M returned describes the transition probability of adding a random\n  bit to a bit string. That is M[i][j] is the probability that appending a bit\n  to a bit string in state i gives a bit string in state j.\n\n  Args:\n    m: the length of the runs of 1s.\n    k: the upper bound on the number of runs of 1s of length m.\n\n  Returns:\n    the transition probability matrix.\n  \"\"\"\n    size = k * m + 1\n    mat = [([0] * size) for _ in range(size)]\n    for occurrences in range(k):\n        for run in range(m):\n            i = occurrences * m + run\n            mat[i][occurrences * m] += 0.5\n            if run < m - 1:\n                mat[i][i + 1] += 0.5\n            elif occurrences < k - 1:\n                mat[i][i + m] += 0.5\n            else:\n                mat[i][k * m] += 0.5\n    mat[k * m][k * m] = 1.0\n    return mat\n\n\ndef OverlappingTemplateMatchingDistribution(n: int, m: int, k: int) ->list[\n    float]: [MASK]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "UniversalDistribution", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\ndef UniversalDistribution(block_size: int, k: int) -> tuple[float, float]:\n    distribution_table = {\n        1: (0.732649484, 0.690),\n        2: (1.537438301, 1.338),\n        3: (2.401606817, 1.901),\n        4: (3.311224728, 2.358),\n        5: (4.253426594, 2.705),\n        6: (5.217705236, 2.954),\n        7: (6.196250725, 3.125),\n        8: (7.183665630, 3.238),\n        9: (8.176424828, 3.311),\n        10: (9.172324334, 3.356)\n    }\n    \n    if block_size not in distribution_table:\n        raise ValueError(\"Block size not supported by the distribution table\")\n    \n    expected = distribution_table[block_size][0] * k\n    std = distribution_table[block_size][1] * math.sqrt(k)\n    \n    return (expected, std)", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass NistSuite(absltest.TestCase):\n    def testUniversalDistribution(self):\n        \"\"\"Compares the computed distribution agains experimental data.\n    \n        NIST SP 800-22 and \"Handbook of applied Cryptography\" by Menezes et. al.\n        have slightly different formulas for c. The implementation follows NIST\n        SP 800-22.\n        The relative difference between the two formulas is about 0.1%.\n        Hence, it does not influence the test significantly.\n        \"\"\"\n        for block_size, k, experimental_mean, experimental_std in [(7, 128000, \n            6.19625, 0.002956), (8, 256000, 7.183661, 0.002167)]:\n            mean, std = UniversalDistribution(block_size, k)\n            self.assertAlmostEqual(experimental_mean, mean, delta=0.0001)\n            self.assertAlmostEqual(experimental_std, std, delta=0.0001)\n    \nNistSuite().testUniversalDistribution()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite_test.py"}], "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef UniversalDistribution(block_size: int, k: int) ->tuple[float, float]: [MASK\n    ]\n"}
{"model_name": "gpt-3.5-turbo", "repository": "paranoid_crypto", "full_method_name": "RandomExcursionsDistribution", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite.py", "response": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\ndef RandomExcursionsDistribution(x: int, max_cnt: int=5) -> list[float]:\n    probabilities = [0.0] * (max_cnt + 1)\n    probabilities[0] = 1.0\n    for k in range(1, max_cnt + 1):\n        probabilities[k] = 0.0\n    return probabilities", "test_code_list": [{"test_code": "from absl.testing import absltest\n\nclass NistSuite(absltest.TestCase):\n    def testRandomExcursionsDistribution(self):\n        self.assertSequenceAlmostEqual([0.5, 0.25, 0.125, 0.0625, 0.0312, \n            0.0312], RandomExcursionsDistribution(1, 5), delta=0.0001)\n        self.assertSequenceAlmostEqual([0.5, 0.25, 0.125, 0.0625, 0.0625],\n            RandomExcursionsDistribution(1, 4), delta=0.0001)\n        self.assertSequenceAlmostEqual([0.75, 0.0625, 0.0469, 0.0352, 0.0264, \n            0.0791], RandomExcursionsDistribution(2, 5), delta=0.0001)\n        self.assertSequenceAlmostEqual([0.9286, 0.0051, 0.0047, 0.0044, 0.0041,\n            0.0531], RandomExcursionsDistribution(7, 5), delta=0.0001)\n    \nNistSuite().testRandomExcursionsDistribution()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/paranoid_crypto/paranoid_crypto/lib/randomness_tests/nist_suite_test.py"}], "method_code_mask": "import collections\nimport math\nfrom typing import Optional\nimport numpy\n\n\ndef RandomExcursionsDistribution(x: int, max_cnt: int=5) ->list[float]: [MASK]\n"}
