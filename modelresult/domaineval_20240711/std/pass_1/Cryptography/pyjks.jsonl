{"model_name": "std", "repository": "pyjks", "full_method_name": "bitstring_to_bytes", "method_path": "../srcdata/Cryptography/pyjks/jks/util.py", "response": "from __future__ import print_function\nimport textwrap\nimport base64\nimport struct\ndef bitstring_to_bytes(bitstr):\n    \"\"\"\n    Converts a pyasn1 univ.BitString instance to byte sequence of type 'bytes'.\n    The bit string is interpreted big-endian and is left-padded with 0 bits to form a multiple of 8.\n    \"\"\"\n    bitlist = list(bitstr)\n    bits_missing = (8 - len(bitlist) % 8) % 8\n    bitlist = [0] * bits_missing + bitlist\n    result = bytearray()\n    for i in range(0, len(bitlist), 8):\n        byte = 0\n        for j in range(8):\n            byte = byte << 1 | bitlist[i + j]\n        result.append(byte)\n    return bytes(result)", "test_code_list": [{"test_code": "import os\nimport sys\nimport unittest\nimport hashlib\nclass AbstractTest(unittest.TestCase):\n\n    def find_private_key(self, ks, alias):\n        pk = ks.entries[alias]\n        if not isinstance(pk, jks.PrivateKeyEntry):\n            self.fail('Private key entry not found: %s' % alias)\n        if pk.is_decrypted():\n            self.assertTrue(isinstance(pk.pkey, bytes))\n            self.assertTrue(isinstance(pk.pkey_pkcs8, bytes))\n        self.assertTrue(isinstance(pk.cert_chain, list))\n        self.assertTrue(all(isinstance(c[1], bytes) for c in pk.cert_chain))\n        return pk\n\n    def find_secret_key(self, ks, alias):\n        sk = ks.entries[alias]\n        if not isinstance(sk, jks.SecretKeyEntry):\n            self.fail('Secret key entry not found: %s' % alias)\n        if sk.is_decrypted():\n            self.assertTrue(isinstance(sk.key, bytes))\n        return sk\n\n    def find_cert(self, ks, alias):\n        c = ks.entries[alias]\n        if not isinstance(c, jks.TrustedCertEntry):\n            self.fail('Certificate entry not found: %s' % alias)\n        self.assertTrue(isinstance(c.cert, bytes))\n        self.assertTrue(isinstance(c.type, py23basestring))\n        return c\n\n    def check_pkey_and_certs_equal(self, pk, algorithm_oid, pkey_pkcs8, certs):\n        self.assertEqual(pk.algorithm_oid, algorithm_oid)\n        self.assertEqual(pk.pkey_pkcs8, pkey_pkcs8)\n        self.assertEqual(len(pk.cert_chain), len(certs))\n        for i in range(len(certs)):\n            self.assertEqual(pk.cert_chain[i][1], certs[i])\n\n    def check_secret_key_equal(self, sk, algorithm_name, key_size, key_bytes):\n        self.assertEqual(sk.algorithm, algorithm_name)\n        self.assertEqual(sk.key_size, key_size)\n        self.assertEqual(sk.key, key_bytes)\n\nclass MiscTests(AbstractTest):\n    def test_bitstring_to_bytes(self):\n    \n        def bs2b(t, _str):\n            bits_tuple = tuple(map(int, _str.replace(' ', '')))\n            result = bitstring_to_bytes(bits_tuple)\n            t.assertTrue(isinstance(result, bytes))\n            return result\n        self.assertEqual(bs2b(self, ''), b'')\n        self.assertEqual(bs2b(self, '        0'), b'\\x00')\n        self.assertEqual(bs2b(self, '        1'), b'\\x01')\n        self.assertEqual(bs2b(self, '0110 1010'), b'j')\n        self.assertEqual(bs2b(self, '1111 1111'), b'\\xff')\n        self.assertEqual(bs2b(self, '   0 1111 1111'), b'\\x00\\xff')\n        self.assertEqual(bs2b(self, '   1 1111 1111'), b'\\x01\\xff')\n    \nMiscTests().test_bitstring_to_bytes()\n", "code_start": "from __future__ import print_function\n", "test_path": "../srcdata/Cryptography/pyjks/tests/test_jks.py"}], "method_code_mask": "from __future__ import print_function\nimport textwrap\nimport base64\nimport struct\n\n\ndef bitstring_to_bytes(bitstr): [MASK]\n"}
