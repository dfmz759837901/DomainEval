{"model_name": "std", "repository": "freqtrade", "full_method_name": "set_loggers", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/loggers/set_log_levels.py", "response": "import logging\ndef set_loggers(verbosity: int=0, api_verbosity: str='info') ->None:\n    \"\"\"\n    Set the logging level for third party libraries\n    :param verbosity: Verbosity level. amount of `-v` passed to the command line\n    :return: None\n    \"\"\"\n    for logger_name in ('requests', 'urllib3', 'httpcore'):\n        logging.getLogger(logger_name).setLevel(logging.INFO if verbosity <=\n            1 else logging.DEBUG)\n    logging.getLogger('ccxt.base.exchange').setLevel(logging.INFO if \n        verbosity <= 2 else logging.DEBUG)\n    logging.getLogger('telegram').setLevel(logging.INFO)\n    logging.getLogger('httpx').setLevel(logging.WARNING)\n    logging.getLogger('werkzeug').setLevel(logging.ERROR if api_verbosity ==\n        'error' else logging.INFO)", "test_code_list": [{"test_code": "import logging\nimport sys\nimport pytest\ndef test_set_loggers() ->None:\n    logging.getLogger('requests').setLevel(logging.DEBUG)\n    logging.getLogger('urllib3').setLevel(logging.DEBUG)\n    logging.getLogger('ccxt.base.exchange').setLevel(logging.DEBUG)\n    logging.getLogger('telegram').setLevel(logging.DEBUG)\n    previous_value1 = logging.getLogger('requests').level\n    previous_value2 = logging.getLogger('ccxt.base.exchange').level\n    previous_value3 = logging.getLogger('telegram').level\n    set_loggers()\n    value1 = logging.getLogger('requests').level\n    assert previous_value1 is not value1\n    assert value1 is logging.INFO\n    value2 = logging.getLogger('ccxt.base.exchange').level\n    assert previous_value2 is not value2\n    assert value2 is logging.INFO\n    value3 = logging.getLogger('telegram').level\n    assert previous_value3 is not value3\n    assert value3 is logging.INFO\n    set_loggers(verbosity=2)\n    assert logging.getLogger('requests').level is logging.DEBUG\n    assert logging.getLogger('ccxt.base.exchange').level is logging.INFO\n    assert logging.getLogger('telegram').level is logging.INFO\n    assert logging.getLogger('werkzeug').level is logging.INFO\n    set_loggers(verbosity=3, api_verbosity='error')\n    assert logging.getLogger('requests').level is logging.DEBUG\n    assert logging.getLogger('ccxt.base.exchange').level is logging.DEBUG\n    assert logging.getLogger('telegram').level is logging.INFO\n    assert logging.getLogger('werkzeug').level is logging.ERROR\n\ntest_set_loggers()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_log_setup.py"}], "method_code_mask": "import logging\n\n\ndef set_loggers(verbosity: int=0, api_verbosity: str='info') ->None: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "check_int_positive", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/cli_options.py", "response": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\ndef check_int_positive(value: str) ->int:\n    try:\n        uint = int(value)\n        if uint <= 0:\n            raise ValueError\n    except ValueError:\n        raise ArgumentTypeError(\n            f'{value} is invalid for this parameter, should be a positive integer value'\n            )\n    return uint", "test_code_list": [{"test_code": "import argparse\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_check_int_positive() ->None:\n    assert check_int_positive('3') == 3\n    assert check_int_positive('1') == 1\n    assert check_int_positive('100') == 100\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('-2')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('0')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive(0)\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('3.5')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_positive('DeadBeef')\n\ntest_check_int_positive()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_arguments.py"}], "method_code_mask": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\n\n\ndef check_int_positive(value: str) ->int: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "check_int_nonzero", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/cli_options.py", "response": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\ndef check_int_nonzero(value: str) ->int:\n    try:\n        uint = int(value)\n        if uint == 0:\n            raise ValueError\n    except ValueError:\n        raise ArgumentTypeError(\n            f'{value} is invalid for this parameter, should be a non-zero integer value'\n            )\n    return uint", "test_code_list": [{"test_code": "import argparse\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_check_int_nonzero() ->None:\n    assert check_int_nonzero('3') == 3\n    assert check_int_nonzero('1') == 1\n    assert check_int_nonzero('100') == 100\n    assert check_int_nonzero('-2') == -2\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('0')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero(0)\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('3.5')\n    with pytest.raises(argparse.ArgumentTypeError):\n        check_int_nonzero('DeadBeef')\n\ntest_check_int_nonzero()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_arguments.py"}], "method_code_mask": "from argparse import SUPPRESS\nfrom argparse import ArgumentTypeError\n\n\ndef check_int_nonzero(value: str) ->int: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "safe_value_fallback", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/misc.py", "response": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndef safe_value_fallback(obj: dict, key1: str, key2: Optional[str]=None,\n    default_value=None):\n    \"\"\"\n    Search a value in obj, return this if it's not None.\n    Then search key2 in obj - return that if it's not none - then use default_value.\n    Else falls back to None.\n    \"\"\"\n    if key1 in obj and obj[key1] is not None:\n        return obj[key1]\n    elif key2 and key2 in obj and obj[key2] is not None:\n        return obj[key2]\n    return default_value", "test_code_list": [{"test_code": "from copy import deepcopy\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pandas as pd\nimport pytest\nfrom pandas.testing import assert_frame_equal\ndef test_safe_value_fallback():\n    dict1 = {'keya': None, 'keyb': 2, 'keyc': 5, 'keyd': None}\n    assert safe_value_fallback(dict1, 'keya', 'keyb') == 2\n    assert safe_value_fallback(dict1, 'keyb', 'keya') == 2\n    assert safe_value_fallback(dict1, 'keyb', 'keyc') == 2\n    assert safe_value_fallback(dict1, 'keya', 'keyc') == 5\n    assert safe_value_fallback(dict1, 'keyc', 'keyb') == 5\n    assert safe_value_fallback(dict1, 'keya', 'keyd') is None\n    assert safe_value_fallback(dict1, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback(dict1, 'keyNo', 'keyNo', 55) == 55\n    assert safe_value_fallback(dict1, 'keyNo', default_value=55) == 55\n    assert safe_value_fallback(dict1, 'keyNo', None, default_value=55) == 55\n\ntest_safe_value_fallback()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_misc.py"}], "method_code_mask": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\n\n\ndef safe_value_fallback(obj: dict, key1: str, key2: Optional[str]=None,\n    default_value=None): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "safe_value_fallback2", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/misc.py", "response": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndictMap = Union[Dict[str, Any], Mapping[str, Any]]\ndef safe_value_fallback2(dict1: dictMap, dict2: dictMap, key1: str, key2:\n    str, default_value=None):\n    \"\"\"\n    Search a value in dict1, return this if it's not None.\n    Fall back to dict2 - return key2 from dict2 if it's not None.\n    Else falls back to None.\n    \"\"\"\n    if key1 in dict1 and dict1[key1] is not None:\n        return dict1[key1]\n    elif key2 in dict2 and dict2[key2] is not None:\n        return dict2[key2]\n    return default_value", "test_code_list": [{"test_code": "from copy import deepcopy\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pandas as pd\nimport pytest\nfrom pandas.testing import assert_frame_equal\ndef test_safe_value_fallback2():\n    dict1 = {'keya': None, 'keyb': 2, 'keyc': 5, 'keyd': None}\n    dict2 = {'keya': 20, 'keyb': None, 'keyc': 6, 'keyd': None}\n    assert safe_value_fallback2(dict1, dict2, 'keya', 'keya') == 20\n    assert safe_value_fallback2(dict2, dict1, 'keya', 'keya') == 20\n    assert safe_value_fallback2(dict1, dict2, 'keyb', 'keyb') == 2\n    assert safe_value_fallback2(dict2, dict1, 'keyb', 'keyb') == 2\n    assert safe_value_fallback2(dict1, dict2, 'keyc', 'keyc') == 5\n    assert safe_value_fallback2(dict2, dict1, 'keyc', 'keyc') == 6\n    assert safe_value_fallback2(dict1, dict2, 'keyd', 'keyd') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyd', 'keyd') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyd', 'keyd', 1234) == 1234\n    assert safe_value_fallback2(dict1, dict2, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyNo', 'keyNo') is None\n    assert safe_value_fallback2(dict2, dict1, 'keyNo', 'keyNo', 1234) == 1234\n\ntest_safe_value_fallback2()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/test_misc.py"}], "method_code_mask": "import gzip\nimport logging\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import TextIO\nfrom typing import Union\nfrom urllib.parse import urlparse\nimport pandas as pd\nimport joblib\ndictMap = Union[Dict[str, Any], Mapping[str, Any]]\n\n\ndef safe_value_fallback2(dict1: dictMap, dict2: dictMap, key1: str, key2:\n    str, default_value=None): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "round_value", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/formatters.py", "response": "def strip_trailing_zeros(value: str) ->str:\n    \"\"\"\n    Strip trailing zeros from a string\n    :param value: Value to be stripped\n    :return: Stripped value\n    \"\"\"\n    return value.rstrip('0').rstrip('.')\ndef round_value(value: float, decimals: int, keep_trailing_zeros=False) ->str:\n    \"\"\"\n    Round value to given decimals\n    :param value: Value to be rounded\n    :param decimals: Number of decimals to round to\n    :param keep_trailing_zeros: Keep trailing zeros \"222.200\" vs. \"222.2\"\n    :return: Rounded value as string\n    \"\"\"\n    val = f'{value:.{decimals}f}'\n    if not keep_trailing_zeros:\n        val = strip_trailing_zeros(val)\n    return val", "test_code_list": [{"test_code": "def test_round_value():\n    assert round_value(222.222222, 3) == '222.222'\n    assert round_value(222.2, 3) == '222.2'\n    assert round_value(222.0, 3) == '222'\n    assert round_value(222.12745, 3) == '222.127'\n    assert round_value(0.1274512123, 8) == '0.12745121'\n    assert round_value(0.1274512123, 5) == '0.12745'\n    assert round_value(222.2, 3, True) == '222.200'\n    assert round_value(222.2, 0, True) == '222'\n\ntest_round_value()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_formatters.py"}], "method_code_mask": "def strip_trailing_zeros(value: str) ->str:\n    \"\"\"\n    Strip trailing zeros from a string\n    :param value: Value to be stripped\n    :return: Stripped value\n    \"\"\"\n    return value.rstrip('0').rstrip('.')\n\n\ndef round_value(value: float, decimals: int, keep_trailing_zeros=False\n    ) ->str: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "dt_ts_def", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "response": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_ts_def(dt: Optional[datetime], default: int=0) ->int:\n    \"\"\"\n    Return dt in ms as a timestamp in UTC.\n    If dt is None, return the given default.\n    \"\"\"\n    if dt:\n        return int(dt.timestamp() * 1000)\n    return default", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_ts_def():\n    assert dt_ts_def(None) == 0\n    assert dt_ts_def(None, 123) == 123\n    assert dt_ts_def(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n    assert dt_ts_def(datetime(2023, 5, 5, tzinfo=timezone.utc), 123\n        ) == 1683244800000\n\ntest_dt_ts_def()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_ts_def(dt: Optional[datetime], default: int=0) ->int: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "dt_ts_none", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "response": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_ts_none(dt: Optional[datetime]) ->Optional[int]:\n    \"\"\"\n    Return dt in ms as a timestamp in UTC.\n    If dt is None, return the given default.\n    \"\"\"\n    if dt:\n        return int(dt.timestamp() * 1000)\n    return None", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_ts_none():\n    assert dt_ts_none(None) is None\n    assert dt_ts_none(None) is None\n    assert dt_ts_none(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n    assert dt_ts_none(datetime(2023, 5, 5, tzinfo=timezone.utc)\n        ) == 1683244800000\n\ntest_dt_ts_none()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_ts_none(dt: Optional[datetime]) ->Optional[int]: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "dt_utc", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "response": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef dt_utc(year: int, month: int, day: int, hour: int=0, minute: int=0,\n    second: int=0, microsecond: int=0) ->datetime:\n    \"\"\"Return a datetime in UTC.\"\"\"\n    return datetime(year, month, day, hour, minute, second, microsecond,\n        tzinfo=timezone.utc)", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_dt_utc():\n    assert dt_utc(2023, 5, 5) == datetime(2023, 5, 5, tzinfo=timezone.utc)\n    assert dt_utc(2023, 5, 5, 0, 0, 0, 555500) == datetime(2023, 5, 5, 0, 0,\n        0, 555500, tzinfo=timezone.utc)\n\ntest_dt_utc()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef dt_utc(year: int, month: int, day: int, hour: int=0, minute: int=0,\n    second: int=0, microsecond: int=0) ->datetime: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "shorten_date", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/util/datetime_helpers.py", "response": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\ndef shorten_date(_date: str) ->str:\n    \"\"\"\n    Trim the date so it fits on small screens\n    \"\"\"\n    new_date = re.sub('seconds?', 'sec', _date)\n    new_date = re.sub('minutes?', 'min', new_date)\n    new_date = re.sub('hours?', 'h', new_date)\n    new_date = re.sub('days?', 'd', new_date)\n    new_date = re.sub('^an?', '1', new_date)\n    return new_date", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nimport pytest\ndef test_shorten_date() ->None:\n    str_data = '1 day, 2 hours, 3 minutes, 4 seconds ago'\n    str_shorten_data = '1 d, 2 h, 3 min, 4 sec ago'\n    assert shorten_date(str_data) == str_shorten_data\n\ntest_shorten_date()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/util/test_datetime_helpers.py"}], "method_code_mask": "import re\nfrom datetime import datetime\nfrom datetime import timezone\nfrom time import time\nfrom typing import Optional\nfrom typing import Union\n\n\ndef shorten_date(_date: str) ->str: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "validate_is_float", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/build_config_commands.py", "response": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\ndef validate_is_float(val):\n    try:\n        _ = float(val)\n        return True\n    except Exception:\n        return False", "test_code_list": [{"test_code": "from pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_validate_is_float():\n    assert validate_is_float('2.0')\n    assert validate_is_float('2.1')\n    assert validate_is_float('0.1')\n    assert validate_is_float('-0.5')\n    assert not validate_is_float('-0.5e')\n\ntest_validate_is_float()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/commands/test_build_config.py"}], "method_code_mask": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\n\n\ndef validate_is_float(val): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "validate_is_int", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/commands/build_config_commands.py", "response": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\ndef validate_is_int(val):\n    try:\n        _ = int(val)\n        return True\n    except Exception:\n        return False", "test_code_list": [{"test_code": "from pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\ndef test_validate_is_int():\n    assert validate_is_int('2')\n    assert validate_is_int('6')\n    assert validate_is_int('-1')\n    assert validate_is_int('500')\n    assert not validate_is_int('2.0')\n    assert not validate_is_int('2.1')\n    assert not validate_is_int('-2.1')\n    assert not validate_is_int('-ee')\n\ntest_validate_is_int()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/commands/test_build_config.py"}], "method_code_mask": "import logging\nimport secrets\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom jinja2.exceptions import TemplateNotFound\n\n\ndef validate_is_int(val): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "stoploss_from_absolute", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/strategy/strategy_helper.py", "response": "from typing import Optional\nimport pandas as pd\ndef stoploss_from_absolute(stop_rate: float, current_rate: float, is_short:\n    bool=False, leverage: float=1.0) ->float:\n    \"\"\"\n    Given current price and desired stop price, return a stop loss value that is relative to current\n    price.\n\n    The requested stop can be positive for a stop above the open price, or negative for\n    a stop below the open price. The return value is always >= 0.\n\n    Returns 0 if the resulting stop price would be above the current price.\n\n    :param stop_rate: Stop loss price.\n    :param current_rate: Current asset price.\n    :param is_short: When true, perform the calculation for short instead of long\n    :param leverage: Leverage to use for the calculation\n    :return: Positive stop loss value relative to current price\n    \"\"\"\n    if current_rate == 0:\n        return 1\n    stoploss = 1 - stop_rate / current_rate\n    if is_short:\n        stoploss = -stoploss\n    return max(min(stoploss, 1.0), 0.0) * leverage", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\ndef test_stoploss_from_absolute():\n    assert pytest.approx(stoploss_from_absolute(90, 100)) == 1 - 90 / 100\n    assert pytest.approx(stoploss_from_absolute(90, 100)) == 0.1\n    assert pytest.approx(stoploss_from_absolute(95, 100)) == 0.05\n    assert pytest.approx(stoploss_from_absolute(100, 100)) == 0\n    assert pytest.approx(stoploss_from_absolute(110, 100)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 0)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100, False, leverage=5)\n        ) == 5\n    assert pytest.approx(stoploss_from_absolute(90, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(110, 100, True)) == -(1 - \n        110 / 100)\n    assert pytest.approx(stoploss_from_absolute(110, 100, True)) == 0.1\n    assert pytest.approx(stoploss_from_absolute(105, 100, True)) == 0.05\n    assert pytest.approx(stoploss_from_absolute(105, 100, True, 5)) == 0.05 * 5\n    assert pytest.approx(stoploss_from_absolute(100, 0, True)) == 1\n    assert pytest.approx(stoploss_from_absolute(0, 100, True)) == 0\n    assert pytest.approx(stoploss_from_absolute(100, 1, is_short=True)) == 1\n    assert pytest.approx(stoploss_from_absolute(100, 1, is_short=True,\n        leverage=5)) == 5\n\ntest_stoploss_from_absolute()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/strategy/test_strategy_helpers.py"}], "method_code_mask": "from typing import Optional\nimport pandas as pd\n\n\ndef stoploss_from_absolute(stop_rate: float, current_rate: float, is_short:\n    bool=False, leverage: float=1.0) ->float: [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "get_last_sequence_ids", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/persistence/migrations.py", "response": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\ndef get_last_sequence_ids(engine, trade_back_name: str, order_back_name: str):\n    order_id: Optional[int] = None\n    trade_id: Optional[int] = None\n    if engine.name == 'postgresql':\n        with engine.begin() as connection:\n            trade_id = connection.execute(text(\n                \"select nextval('trades_id_seq')\")).fetchone()[0]\n            order_id = connection.execute(text(\n                \"select nextval('orders_id_seq')\")).fetchone()[0]\n        with engine.begin() as connection:\n            connection.execute(text(\n                f'ALTER SEQUENCE orders_id_seq rename to {order_back_name}_id_seq_bak'\n                ))\n            connection.execute(text(\n                f'ALTER SEQUENCE trades_id_seq rename to {trade_back_name}_id_seq_bak'\n                ))\n    return order_id, trade_id", "test_code_list": [{"test_code": "import logging\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy.schema import CreateTable\ndef test_migrate_get_last_sequence_ids():\n    engine = MagicMock()\n    engine.begin = MagicMock()\n    engine.name = 'postgresql'\n    get_last_sequence_ids(engine, 'trades_bak', 'orders_bak')\n    assert engine.begin.call_count == 2\n    engine.reset_mock()\n    engine.begin.reset_mock()\n    engine.name = 'somethingelse'\n    get_last_sequence_ids(engine, 'trades_bak', 'orders_bak')\n    assert engine.begin.call_count == 0\n\ntest_migrate_get_last_sequence_ids()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/persistence/test_migrations.py"}], "method_code_mask": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\n\n\ndef get_last_sequence_ids(engine, trade_back_name: str, order_back_name: str\n    ): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "set_sequence_ids", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/persistence/migrations.py", "response": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\ndef set_sequence_ids(engine, order_id, trade_id, pairlock_id=None):\n    if engine.name == 'postgresql':\n        with engine.begin() as connection:\n            if order_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE orders_id_seq RESTART WITH {order_id}'))\n            if trade_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE trades_id_seq RESTART WITH {trade_id}'))\n            if pairlock_id:\n                connection.execute(text(\n                    f'ALTER SEQUENCE pairlocks_id_seq RESTART WITH {pairlock_id}'\n                    ))", "test_code_list": [{"test_code": "import logging\nfrom importlib import import_module\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy.schema import CreateTable\ndef test_migrate_set_sequence_ids():\n    engine = MagicMock()\n    engine.begin = MagicMock()\n    engine.name = 'postgresql'\n    set_sequence_ids(engine, 22, 55, 5)\n    assert engine.begin.call_count == 1\n    engine.reset_mock()\n    engine.begin.reset_mock()\n    engine.name = 'somethingelse'\n    set_sequence_ids(engine, 22, 55, 6)\n    assert engine.begin.call_count == 0\n\ntest_migrate_set_sequence_ids()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/persistence/test_migrations.py"}], "method_code_mask": "import logging\nfrom typing import List\nfrom typing import Optional\nfrom sqlalchemy import inspect\nfrom sqlalchemy import select\nfrom sqlalchemy import text\nfrom sqlalchemy import update\n\n\ndef set_sequence_ids(engine, order_id, trade_id, pairlock_id=None): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "hyperopt_serializer", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/optimize/hyperopt_tools.py", "response": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport numpy as np\nfrom pandas import isna\nfrom pandas import json_normalize\ndef hyperopt_serializer(x):\n    if isinstance(x, np.integer):\n        return int(x)\n    if isinstance(x, np.bool_):\n        return bool(x)\n    return str(x)", "test_code_list": [{"test_code": "import logging\nimport re\nfrom pathlib import Path\nfrom typing import Dict\nfrom typing import List\nimport numpy as np\nimport pytest\ndef test_hyperopt_serializer():\n    assert isinstance(hyperopt_serializer(np.int_(5)), int)\n    assert isinstance(hyperopt_serializer(np.bool_(True)), bool)\n    assert isinstance(hyperopt_serializer(np.bool_(False)), bool)\n\ntest_hyperopt_serializer()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/optimize/test_hyperopt_tools.py"}], "method_code_mask": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timezone\nfrom pathlib import Path\nfrom typing import Any\nfrom typing import Dict\nfrom typing import Iterator\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\nimport numpy as np\nfrom pandas import isna\nfrom pandas import json_normalize\n\n\ndef hyperopt_serializer(x): [MASK]\n"}
{"model_name": "std", "repository": "freqtrade", "full_method_name": "generate_pair_metrics", "method_path": "../srcdata/Addition-0725/freqtrade/freqtrade/optimize/optimize_reports/optimize_reports.py", "response": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Literal\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import concat\nfrom pandas import to_datetime\ndef _generate_result_line(result: DataFrame, starting_balance: int,\n    first_column: Union[str, List[str]]) ->Dict:\n    \"\"\"\n    Generate one result dict, with \"first_column\" as key.\n    \"\"\"\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': \n        result['profit_ratio'].mean() if len(result) > 0 else 0.0,\n        'profit_mean_pct': round(result['profit_ratio'].mean() * 100.0, 2) if\n        len(result) > 0 else 0.0, 'profit_sum': profit_sum,\n        'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs':\n        result['profit_abs'].sum(), 'profit_total': profit_total,\n        'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg':\n        str(timedelta(minutes=round(result['trade_duration'].mean()))) if \n        not result.empty else '0:00', 'wins': len(result[result[\n        'profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]\n        ), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(\n        result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0\n        }\ndef generate_pair_metrics(pairlist: List[str], stake_currency: str,\n    starting_balance: int, results: DataFrame, skip_nan: bool=False) ->List[\n    Dict]:\n    \"\"\"\n    Generates and returns a list  for the given backtest data and the results dataframe\n    :param pairlist: Pairlist used\n    :param stake_currency: stake-currency - used to correctly name headers\n    :param starting_balance: Starting balance\n    :param results: Dataframe containing the backtest results\n    :param skip_nan: Print \"left open\" open trades\n    :return: List of Dicts containing the metrics per pair\n    \"\"\"\n    tabular_data = []\n    for pair in pairlist:\n        result = results[results['pair'] == pair]\n        if skip_nan and result['profit_abs'].isnull().all():\n            continue\n        tabular_data.append(_generate_result_line(result, starting_balance,\n            pair))\n    tabular_data = sorted(tabular_data, key=lambda k: k['profit_total_abs'],\n        reverse=True)\n    tabular_data.append(_generate_result_line(results, starting_balance,\n        'TOTAL'))\n    return tabular_data", "test_code_list": [{"test_code": "import re\nfrom datetime import timedelta\nfrom pathlib import Path\nfrom shutil import copyfile\nimport joblib\nimport pandas as pd\nimport pytest\ndef test_generate_pair_metrics():\n    results = pd.DataFrame({'pair': ['ETH/BTC', 'ETH/BTC'], 'profit_ratio':\n        [0.1, 0.2], 'profit_abs': [0.2, 0.4], 'trade_duration': [10, 30],\n        'wins': [2, 0], 'draws': [0, 0], 'losses': [0, 0]})\n    pair_results = generate_pair_metrics(['ETH/BTC'], stake_currency='BTC',\n        starting_balance=2, results=results)\n    assert isinstance(pair_results, list)\n    assert len(pair_results) == 2\n    assert pair_results[-1]['key'] == 'TOTAL'\n    assert pytest.approx(pair_results[-1]['profit_mean_pct']) == pair_results[\n        -1]['profit_mean'] * 100\n    assert pytest.approx(pair_results[-1]['profit_sum_pct']) == pair_results[-1\n        ]['profit_sum'] * 100\n\ntest_generate_pair_metrics()\n", "code_start": "", "test_path": "../srcdata/Addition-0725/freqtrade/tests/optimize/test_optimize_reports.py"}], "method_code_mask": "import logging\nfrom copy import deepcopy\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Any\nfrom typing import Dict\nfrom typing import List\nfrom typing import Literal\nfrom typing import Tuple\nfrom typing import Union\nimport numpy as np\nfrom pandas import DataFrame\nfrom pandas import Series\nfrom pandas import concat\nfrom pandas import to_datetime\n\n\ndef _generate_result_line(result: DataFrame, starting_balance: int,\n    first_column: Union[str, List[str]]) ->Dict:\n    \"\"\"\n    Generate one result dict, with \"first_column\" as key.\n    \"\"\"\n    profit_sum = result['profit_ratio'].sum()\n    profit_total = result['profit_abs'].sum() / starting_balance\n    return {'key': first_column, 'trades': len(result), 'profit_mean': \n        result['profit_ratio'].mean() if len(result) > 0 else 0.0,\n        'profit_mean_pct': round(result['profit_ratio'].mean() * 100.0, 2) if\n        len(result) > 0 else 0.0, 'profit_sum': profit_sum,\n        'profit_sum_pct': round(profit_sum * 100.0, 2), 'profit_total_abs':\n        result['profit_abs'].sum(), 'profit_total': profit_total,\n        'profit_total_pct': round(profit_total * 100.0, 2), 'duration_avg':\n        str(timedelta(minutes=round(result['trade_duration'].mean()))) if \n        not result.empty else '0:00', 'wins': len(result[result[\n        'profit_abs'] > 0]), 'draws': len(result[result['profit_abs'] == 0]\n        ), 'losses': len(result[result['profit_abs'] < 0]), 'winrate': len(\n        result[result['profit_abs'] > 0]) / len(result) if len(result) else 0.0\n        }\n\n\ndef generate_pair_metrics(pairlist: List[str], stake_currency: str,\n    starting_balance: int, results: DataFrame, skip_nan: bool=False) ->List[\n    Dict]: [MASK]\n"}
