{"model_name": "std", "repository": "nucypher", "full_method_name": "_resolve_ipv4", "method_path": "../srcdata/Cryptography/nucypher/nucypher/utilities/networking.py", "response": "import random\nfrom http import HTTPStatus\nfrom ipaddress import AddressValueError\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom typing import Optional\nfrom typing import Union\nimport requests\nfrom flask import Request\nfrom requests.exceptions import HTTPError\nfrom requests.exceptions import RequestException\ndef _resolve_ipv4(ip: str) ->Optional[IPv4Address]:\n    \"\"\"\n    Resolve an IPv6 address to IPv4 if required and possible.\n    Returns None if there is no valid IPv4 address available.\n    \"\"\"\n    try:\n        ip = ip_address(ip.strip())\n    except (AddressValueError, ValueError):\n        raise AddressValueError(\n            f\"'{ip}' does not appear to be an IPv4 or IPv6 address\")\n    if isinstance(ip, IPv6Address):\n        return ip.ipv4_mapped\n    elif isinstance(ip, IPv4Address):\n        return ip", "test_code_list": [{"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_valid_ipv4():\n    assert _resolve_ipv4('8.8.8.8') == IPv4Address('8.8.8.8')\n\ntest_resolve_ipv4_with_valid_ipv4()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}, {"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_valid_mapped_ipv6():\n    assert _resolve_ipv4('::ffff:8.8.8.8') == IPv4Address('8.8.8.8')\n\ntest_resolve_ipv4_with_valid_mapped_ipv6()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}, {"test_code": "from ipaddress import IPv4Address\nimport pytest\nfrom flask import Request\ndef test_resolve_ipv4_with_non_mapped_ipv6():\n    assert _resolve_ipv4('2001:0db8::') is None\n\ntest_resolve_ipv4_with_non_mapped_ipv6()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/test_ping_utils.py"}], "method_code_mask": "import random\nfrom http import HTTPStatus\nfrom ipaddress import AddressValueError\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom typing import Optional\nfrom typing import Union\nimport requests\nfrom flask import Request\nfrom requests.exceptions import HTTPError\nfrom requests.exceptions import RequestException\n\n\ndef _resolve_ipv4(ip: str) ->Optional[IPv4Address]: [MASK]\n"}
{"model_name": "std", "repository": "nucypher", "full_method_name": "secure_random", "method_path": "../srcdata/Cryptography/nucypher/nucypher/crypto/utils.py", "response": "from secrets import SystemRandom\nfrom typing import Union\nSYSTEM_RAND = SystemRandom()\ndef secure_random(num_bytes: int) ->bytes:\n    \"\"\"\n    Returns an amount `num_bytes` of data from the OS's random device.\n    If a randomness source isn't found, returns a `NotImplementedError`.\n    In this case, a secure random source most likely doesn't exist and\n    randomness will have to found elsewhere.\n    :param num_bytes: Number of bytes to return.\n    :return: bytes\n    \"\"\"\n    return SYSTEM_RAND.getrandbits(num_bytes * 8).to_bytes(num_bytes,\n        byteorder='big')", "test_code_list": [{"test_code": "import unittest\n\nclass TestCrypto(unittest.TestCase):\n    def test_secure_random(self):\n        rand1 = secure_random(10)\n        rand2 = secure_random(10)\n        self.assertNotEqual(rand1, rand2)\n        self.assertEqual(bytes, type(rand1))\n        self.assertEqual(bytes, type(rand2))\n        self.assertEqual(10, len(rand1))\n        self.assertEqual(10, len(rand2))\n    \nTestCrypto().test_secure_random()\n", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/crypto/test_keccak_sanity.py"}], "method_code_mask": "from secrets import SystemRandom\nfrom typing import Union\nSYSTEM_RAND = SystemRandom()\n\n\ndef secure_random(num_bytes: int) ->bytes: [MASK]\n"}
{"model_name": "std", "repository": "nucypher", "full_method_name": "is_context_variable", "method_path": "../srcdata/Cryptography/nucypher/nucypher/policy/conditions/context.py", "response": "import re\nfrom typing import Any\nfrom typing import List\nfrom typing import Union\nCONTEXT_REGEX = re.compile(':[a-zA-Z_][a-zA-Z0-9_]*')\nCONTEXT_PREFIX = ':'\ndef is_context_variable(variable) ->bool:\n    if isinstance(variable, str) and variable.startswith(CONTEXT_PREFIX):\n        if CONTEXT_REGEX.fullmatch(variable):\n            return True\n        else:\n            raise ValueError(\n                f\"Context variable name '{variable}' is not valid.\")\n    return False", "test_code_list": [{"test_code": "import itertools\nimport re\nimport pytest\nINVALID_CONTEXT_PARAM_NAMES = [':', ':)', ':!', ':3', ':super\u00f1o\u00f1o',\n    ':::::this//is       \ud83c\udf4c \ud83c\udf4c \ud83c\udf4c ', \"\"\":123 \"$%'+-?\n  jarl!! cobarde!!\"\"\"]\nDEFINITELY_NOT_CONTEXT_PARAM_NAMES = ['1234', 'foo', '', 123]\nVALID_CONTEXT_PARAM_NAMES = [':foo', ':_bar', ':bar_', ':_bar_', ':VAR',\n    ':a1234', ':snake_case', ':camelCase', ':_']\ndef test_is_context_variable():\n    for variable in VALID_CONTEXT_PARAM_NAMES:\n        assert is_context_variable(variable)\n    for variable in DEFINITELY_NOT_CONTEXT_PARAM_NAMES:\n        assert not is_context_variable(variable)\n    for variable in INVALID_CONTEXT_PARAM_NAMES:\n        expected_message = re.escape(\n            f\"Context variable name '{variable}' is not valid.\")\n        with pytest.raises(ValueError, match=expected_message):\n            _ = is_context_variable(variable)\ntest_is_context_variable()", "code_start": "", "test_path": "../srcdata/Cryptography/nucypher/tests/unit/conditions/test_context.py"}], "method_code_mask": "import re\nfrom typing import Any\nfrom typing import List\nfrom typing import Union\nCONTEXT_REGEX = re.compile(':[a-zA-Z_][a-zA-Z0-9_]*')\nCONTEXT_PREFIX = ':'\n\n\ndef is_context_variable(variable) ->bool: [MASK]\n"}
