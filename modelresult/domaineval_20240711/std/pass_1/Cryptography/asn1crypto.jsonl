{"model_name": "std", "repository": "asn1crypto", "full_method_name": "walk_ast", "method_path": "../srcdata/Cryptography/asn1crypto/tests/test_init.py", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\ndef walk_ast(parent_node, modname, imports):\n    \"\"\"\n    Walks the AST for a module finding any imports and recording them\n    :param parent_node:\n        A node from the _ast module\n    :param modname:\n        A unicode string of the module we are walking the AST of\n    :param imports:\n        A set of unicode strings of the imports that have been found so far\n    \"\"\"\n    for node in ast.iter_child_nodes(parent_node):\n        if isinstance(node, _ast.Import):\n            if node.names[0].name.startswith(module.__name__):\n                add_mod(node.names[0].name, imports)\n        elif isinstance(node, _ast.ImportFrom):\n            if node.level > 0:\n                if modname == module.__name__:\n                    base_mod = module.__name__\n                else:\n                    base_mod = '.'.join(modname.split('.')[:-node.level])\n                if node.module:\n                    base_mod += '.' + node.module\n            else:\n                base_mod = node.module\n            if not base_mod.startswith(module.__name__):\n                continue\n            if node.level > 0 and not node.module:\n                for n in node.names:\n                    add_mod(base_mod + '.' + n.name, imports)\n            else:\n                add_mod(base_mod, imports)\n        elif isinstance(node, _ast.If):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info >= (3, 3) and isinstance(node, _ast.Try):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryFinally):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.finalbody:\n                walk_ast(subast, modname, imports)\n        elif sys.version_info < (3, 3) and isinstance(node, _ast.TryExcept):\n            for subast in node.body:\n                walk_ast(subast, modname, imports)\n            for subast in node.orelse:\n                walk_ast(subast, modname, imports)", "test_code_list": [{"test_code": "import ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\n\nclass InitTests(unittest.TestCase):\n    def test_load_order(self):\n        deps = {}\n        mod_root = os.path.abspath(os.path.dirname(module.__file__))\n        files = []\n        for root, dnames, fnames in os.walk(mod_root):\n            for f in fnames:\n                if f.endswith('.py'):\n                    full_path = os.path.join(root, f)\n                    rel_path = full_path.replace(mod_root + os.sep, '')\n                    files.append((full_path, rel_path))\n        for full_path, rel_path in sorted(files):\n            with open(full_path, 'rb') as f:\n                full_code = f.read()\n                if sys.version_info >= (3,):\n                    full_code = full_code.decode('utf-8')\n            modname = rel_path.replace('.py', '').replace(os.sep, '.')\n            if modname == '__init__':\n                modname = module.__name__\n            else:\n                modname = '%s.%s' % (module.__name__, modname)\n            if sys.version_info < (3,\n                ) and sys.platform == 'win32' and b'\\r\\n' in full_code:\n                full_code = full_code.replace(b'\\r\\n', b'\\n')\n            imports = set([])\n            module_node = ast.parse(full_code, filename=full_path)\n            walk_ast(module_node, modname, imports)\n            deps[modname] = imports\n        load_order = module.load_order()\n        prev = set([])\n        for mod in load_order:\n            self.assertEqual(True, mod in deps)\n            self.assertEqual((mod, set([])), (mod, deps[mod] - prev))\n            prev.add(mod)\n    \nInitTests().test_load_order()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_init.py"}], "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport ast\nimport _ast\nimport unittest\nimport os\nimport sys\nimport asn1crypto as module\nMOD_MAP = {}\n\n\ndef add_mod(mod_name, imports):\n    \"\"\"\n    Maps pre-defined module.function to module import names\n    :param mod_name:\n        A unicode string of a fully-qualified module name being imported\n    :param imports:\n        A set of unicode strings of the modules that are being imported\n    \"\"\"\n    imports.add(MOD_MAP.get(mod_name, mod_name))\n\n\ndef walk_ast(parent_node, modname, imports): [MASK]\n"}
{"model_name": "std", "repository": "asn1crypto", "full_method_name": "_int_to_bit_tuple", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/core.py", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\ndef _int_to_bit_tuple(value, bits):\n    \"\"\"\n    Format value as a tuple of 1s and 0s.\n\n    :param value:\n        A non-negative integer to format\n\n    :param bits:\n        Number of bits in the output\n\n    :return:\n        A tuple of 1s and 0s with bits members.\n    \"\"\"\n    if not value and not bits:\n        return ()\n    result = tuple(map(int, format(value, '0{0}b'.format(bits))))\n    if len(result) != bits:\n        raise ValueError('Result too large: {0} > {1}'.format(len(result),\n            bits))\n    return result", "test_code_list": [{"test_code": "import pickle\nimport unittest\nimport os\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom asn1crypto import core\nfrom asn1crypto import util\n\nclass CoreTests(unittest.TestCase):\n    def test_int_to_bit_tuple(self):\n        self.assertEqual((), _int_to_bit_tuple(0, 0))\n        self.assertEqual((0,), _int_to_bit_tuple(0, 1))\n        self.assertEqual((1,), _int_to_bit_tuple(1, 1))\n        self.assertEqual((0, 0), _int_to_bit_tuple(0, 2))\n        self.assertEqual((0, 1), _int_to_bit_tuple(1, 2))\n        self.assertEqual((0, 0, 1), _int_to_bit_tuple(1, 3))\n        self.assertEqual((0, 1, 0), _int_to_bit_tuple(2, 3))\n        self.assertEqual((1, 0, 1), _int_to_bit_tuple(5, 3))\n        with self.assertRaises(ValueError):\n            _int_to_bit_tuple(9, 3)\n        with self.assertRaises(ValueError):\n            _int_to_bit_tuple(-9, 5)\n    \nCoreTests().test_int_to_bit_tuple()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_core.py"}, {"test_code": "import pickle\nimport unittest\nimport os\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom asn1crypto import core\nfrom asn1crypto import util\n\nclass CoreTests(unittest.TestCase):\n    def test_indefinite_length_bit_string(self):\n        data = b'#\\x80\\x03\\x02\\x00\\x01\\x03\\x02\\x02\\x04\\x00\\x00'\n        a = core.BitString.load(data)\n        self.assertEqual((0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1), a.native)\n        self.assertEqual((0, 0), a.unused_bits)\n        prim = core.BitString.load(b'\\x03\\x07\\x04\\n;_)\\x1c\\xd0')\n        self.assertEqual((0, 0, 0, 0), prim.unused_bits)\n        indef = core.BitString.load(\n            b'#\\x80\\x03\\x03\\x00\\n;\\x03\\x05\\x04_)\\x1c\\xd0\\x00\\x00')\n        self.assertEqual(prim.native, indef.native)\n        self.assertEqual(_int_to_bit_tuple(703132242381, 44), indef.native)\n        self.assertEqual((0, 0, 0, 0), indef.unused_bits)\n        unused = core.BitString.load(\n            b'#\\x80\\x03\\x03\\x00\\n;\\x03\\x05\\x04_)\\x1c\\xdd\\x00\\x00')\n        self.assertEqual(indef.native, unused.native)\n        self.assertEqual((1, 1, 0, 1), unused.unused_bits)\n        unused.set(indef.native)\n        self.assertEqual(indef.native, unused.native)\n        self.assertEqual((0, 0, 0, 0), unused.unused_bits)\n    \nCoreTests().test_indefinite_length_bit_string()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_core.py"}], "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom fractions import Fraction\nimport binascii\nimport copy\nimport math\nimport re\nimport sys\nfrom io import BytesIO\n\n\ndef _int_to_bit_tuple(value, bits): [MASK]\n"}
{"model_name": "std", "repository": "asn1crypto", "full_method_name": "create_timezone", "method_path": "../srcdata/Cryptography/asn1crypto/asn1crypto/util.py", "response": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\ndef create_timezone(offset):\n    \"\"\"\n    Returns a new datetime.timezone object with the given offset.\n    Uses cached objects if possible.\n    :param offset:\n        A datetime.timedelta object; It needs to be in full minutes and between -23:59 and +23:59.\n    :return:\n        A datetime.timezone object\n    \"\"\"\n    try:\n        tz = _timezone_cache[offset]\n    except KeyError:\n        tz = _timezone_cache[offset] = timezone(offset)\n    return tz", "test_code_list": [{"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_properties(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        dt = util.extended_datetime(0, 11, 27, 5, 44, 31, 14889, zone)\n        self.assertEqual(dt.year, 0)\n        self.assertEqual(dt.month, 11)\n        self.assertEqual(dt.day, 27)\n        self.assertEqual(dt.hour, 5)\n        self.assertEqual(dt.minute, 44)\n        self.assertEqual(dt.second, 31)\n        self.assertEqual(dt.microsecond, 14889)\n        self.assertEqual(dt.tzinfo, zone)\n    \nUtilTests().test_extended_datetime_properties()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_replace(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 1, 1, 23, tzinfo=zone)\n        self.assertEqual(ext_dt.replace(year=2040, minute=59), datetime(2040, 1,\n            1, 23, 59, tzinfo=zone))\n        self.assertEqual(ext_dt.replace(minute=59), util.extended_datetime(0, 1,\n            1, 23, 59, tzinfo=zone))\n    \nUtilTests().test_extended_datetime_replace()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\nif sys.version_info < (3,):\n    py2 = True\n    byte_cls = str\n    num_cls = long\nelse:\n    py2 = False\n    byte_cls = bytes\n    num_cls = int\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_encodings(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 2, 29, 9, 17, 45, 14889, zone)\n        self.assertEqual(str(ext_dt), '0000-02-29 09:17:45.014889+12:45')\n        if py2:\n            self.assertEqual(unicode(ext_dt), '0000-02-29 09:17:45.014889+12:45')\n        ext_dt = util.extended_datetime(0, 2, 29, 9, 17, 45, 0, zone)\n        self.assertEqual(str(ext_dt), '0000-02-29 09:17:45+12:45')\n        if py2:\n            self.assertEqual(unicode(ext_dt), '0000-02-29 09:17:45+12:45')\nUtilTests().test_extended_datetime_encodings()", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_timestamp(self):\n        if sys.version_info >= (3, 3):\n            zone = create_timezone(timedelta(hours=12, minutes=45))\n            ext_dt = util.extended_datetime(0, 12, 31, 23, 0, 0, 14889, zone)\n            dt = datetime(1, 1, 1, 0, 0, 0, 14889, zone)\n            self.assertTrue(abs(dt.timestamp() - ext_dt.timestamp() - 3600.0) <\n                1e-07)\n    \nUtilTests().test_extended_datetime_timestamp()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\nutc = util.timezone.utc\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_compare(self):\n        self.assertTrue(util.extended_datetime(0, 1, 1) < datetime(1, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= datetime(1, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) != datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) >= datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > datetime(1, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) < util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= util.\n            extended_datetime(0, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) != util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) >= util.\n            extended_datetime(0, 1, 1))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > util.\n            extended_datetime(0, 1, 1))\n        self.assertTrue(util.extended_datetime(0, 1, 1) < util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 1) <= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 1) != util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) >= util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 1) > util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) < util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) <= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) != util.\n            extended_datetime(0, 1, 2))\n        self.assertFalse(util.extended_datetime(0, 1, 3) == util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) >= util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 1, 3) > util.\n            extended_datetime(0, 1, 2))\n        self.assertTrue(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-8))) == datetime(1, 1, 1, 5, 4, 5,\n            6, utc))\n        self.assertTrue(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-8))) == datetime(1, 1, 1, 5, 7, 5,\n            6, create_timezone(timedelta(hours=0, minutes=3))))\n        self.assertFalse(util.extended_datetime(0, 12, 31, 21, 4, 5, 6, util.\n            create_timezone(timedelta(hours=-7))) == datetime(1, 1, 1, 5, 4, 5,\n            6, utc))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == util.\n            extended_datetime(0, 1, 1, tzinfo=utc))\n        self.assertFalse(util.extended_datetime(0, 1, 1) == '0000-01-01')\n        with self.assertRaises(TypeError):\n            util.extended_datetime(0, 1, 1) < '0000-01-02'\nUtilTests().test_extended_datetime_compare()", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}, {"test_code": "import os\nimport platform\nimport sys\nimport unittest\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom asn1crypto import util\n\nclass UtilTests(unittest.TestCase):\n    def test_extended_datetime_arithmetic(self):\n        zone = create_timezone(timedelta(hours=12, minutes=45))\n        ext_dt = util.extended_datetime(0, 12, 31, 9, 17, 45, 14889, zone)\n        self.assertEqual(ext_dt + timedelta(hours=20), datetime(1, 1, 1, 5, 17,\n            45, 14889, zone))\n        self.assertEqual(ext_dt - timedelta(hours=20), util.extended_datetime(0,\n            12, 30, 13, 17, 45, 14889, zone))\n        self.assertEqual(ext_dt - ext_dt, timedelta(0))\n        zone2 = create_timezone(timedelta(hours=-8, minutes=-31))\n        ext_dt2 = util.extended_datetime(0, 11, 14, 13, 44, 20, 876543, zone2)\n        expected_diff = timedelta(days=47, hours=-4, minutes=-27, seconds=25,\n            microseconds=-861654)\n        expected_diff -= timedelta(hours=20, minutes=76)\n        self.assertEqual(ext_dt - ext_dt2, expected_diff)\n        dt = datetime(400, 12, 31, 9, 17, 45, 14889, zone)\n        self.assertEqual(dt - ext_dt, timedelta(days=util.extended_datetime.\n            DAYS_IN_400_YEARS))\n        self.assertEqual(ext_dt - dt, -timedelta(days=util.extended_datetime.\n            DAYS_IN_400_YEARS))\n        with self.assertRaises(TypeError):\n            ext_dt - 'test'\n    \nUtilTests().test_extended_datetime_arithmetic()\n", "code_start": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\n", "test_path": "../srcdata/Cryptography/asn1crypto/tests/test_util.py"}], "method_code_mask": "from __future__ import unicode_literals\nfrom __future__ import division\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport math\nimport sys\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import timedelta\nfrom datetime import tzinfo\nfrom socket import inet_ntop\nfrom socket import inet_pton\nfrom datetime import timezone\n_timezone_cache = {}\n\n\ndef create_timezone(offset): [MASK]\n"}
