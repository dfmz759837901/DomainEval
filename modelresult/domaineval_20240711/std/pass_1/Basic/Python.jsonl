{"model_name": "std", "repository": "Python", "full_method_name": "kruskal", "method_path": "../srcdata/Basic/Python/graphs/minimum_spanning_tree_kruskal.py", "response": "\ndef kruskal(num_nodes: int, edges: list[tuple[int, int, int]]) ->list[tuple\n    [int, int, int]]:\n    \"\"\"\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])\n    [(2, 3, 1), (0, 1, 3), (1, 2, 5)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])\n    [(2, 3, 1), (0, 2, 1), (0, 1, 3)]\n\n    >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),\n    ... (2, 1, 1)])\n    [(2, 3, 1), (0, 2, 1), (2, 1, 1)]\n    \"\"\"\n    edges = sorted(edges, key=lambda edge: edge[2])\n    parent = list(range(num_nodes))\n\n    def find_parent(i):\n        if i != parent[i]:\n            parent[i] = find_parent(parent[i])\n        return parent[i]\n    minimum_spanning_tree_cost = 0\n    minimum_spanning_tree = []\n    for edge in edges:\n        parent_a = find_parent(edge[0])\n        parent_b = find_parent(edge[1])\n        if parent_a != parent_b:\n            minimum_spanning_tree_cost += edge[2]\n            minimum_spanning_tree.append(edge)\n            parent[parent_a] = parent_b\n    return minimum_spanning_tree", "test_code_list": [{"test_code": "def test_kruskal_successful_result():\n    num_nodes = 9\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    result = kruskal(num_nodes, edges)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    assert sorted(expected) == sorted(result)\n\ntest_kruskal_successful_result()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/graphs/tests/test_min_spanning_tree_kruskal.py"}], "method_code_mask": "def kruskal(num_nodes: int, edges: list[tuple[int, int, int]]) ->list[tuple\n    [int, int, int]]: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "prisms_algorithm", "method_path": "../srcdata/Basic/Python/graphs/minimum_spanning_tree_prims.py", "response": "import sys\nfrom collections import defaultdict\nclass Heap:\n\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = heap[start\n                    ], positions[start]\n                heap[start], positions[start] = temp, temp1\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(positions[smallest_child], self.\n                    get_position(positions[start]))\n                self.set_position(positions[start], temp)\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index -\n                1) / 2)\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\ndef prisms_algorithm(adjacency_list):\n    \"\"\"\n    >>> adjacency_list = {0: [[1, 1], [3, 3]],\n    ...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],\n    ...                   2: [[1, 6], [4, 5], [5, 2]],\n    ...                   3: [[0, 3], [1, 5], [4, 1]],\n    ...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],\n    ...                   5: [[2, 2], [4, 4]]}\n    >>> prisms_algorithm(adjacency_list)\n    [(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]\n    \"\"\"\n    heap = Heap()\n    visited = [0] * len(adjacency_list)\n    nbr_tv = [-1] * len(adjacency_list)\n    distance_tv = []\n    positions = []\n    for vertex in range(len(adjacency_list)):\n        distance_tv.append(sys.maxsize)\n        positions.append(vertex)\n        heap.node_position.append(vertex)\n    tree_edges = []\n    visited[0] = 1\n    distance_tv[0] = sys.maxsize\n    for neighbor, distance in adjacency_list[0]:\n        nbr_tv[neighbor] = 0\n        distance_tv[neighbor] = distance\n    heap.heapify(distance_tv, positions)\n    for _ in range(1, len(adjacency_list)):\n        vertex = heap.delete_minimum(distance_tv, positions)\n        if visited[vertex] == 0:\n            tree_edges.append((nbr_tv[vertex], vertex))\n            visited[vertex] = 1\n            for neighbor, distance in adjacency_list[vertex]:\n                if visited[neighbor] == 0 and distance < distance_tv[heap.\n                    get_position(neighbor)]:\n                    distance_tv[heap.get_position(neighbor)] = distance\n                    heap.bottom_to_top(distance, heap.get_position(neighbor\n                        ), distance_tv, positions)\n                    nbr_tv[neighbor] = vertex\n    return tree_edges", "test_code_list": [{"test_code": "from collections import defaultdict\ndef test_prim_successful_result():\n    num_nodes, num_edges = 9, 14\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    adjacency = defaultdict(list)\n    for node1, node2, cost in edges:\n        adjacency[node1].append([node2, cost])\n        adjacency[node2].append([node1, cost])\n    result = prisms_algorithm(adjacency)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    for answer in expected:\n        edge = tuple(answer[:2])\n        reverse = tuple(edge[::-1])\n        assert edge in result or reverse in result\n\ntest_prim_successful_result()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/graphs/tests/test_min_spanning_tree_prim.py"}], "method_code_mask": "import sys\nfrom collections import defaultdict\n\n\nclass Heap:\n\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = heap[start\n                    ], positions[start]\n                heap[start], positions[start] = temp, temp1\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(positions[smallest_child], self.\n                    get_position(positions[start]))\n                self.set_position(positions[start], temp)\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index -\n                1) / 2)\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\n\n\ndef prisms_algorithm(adjacency_list): [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "gen_gaussian_kernel", "method_path": "../srcdata/Basic/Python/digital_image_processing/edge_detection/canny.py", "response": "import cv2\nimport numpy as np\ndef gen_gaussian_kernel(k_size, sigma):\n    center = k_size // 2\n    x, y = np.mgrid[0 - center:k_size - center, 0 - center:k_size - center]\n    g = 1 / (2 * np.pi * sigma) * np.exp(-(np.square(x) + np.square(y)) / (\n        2 * np.square(sigma)))\n    return g", "test_code_list": [{"test_code": "import numpy as np\nfrom cv2 import COLOR_BGR2GRAY\nfrom cv2 import cvtColor\nfrom cv2 import imread\nfrom numpy import array\nfrom numpy import uint8\nfrom PIL import Image\nfrom os import getenv\ndef test_gen_gaussian_kernel():\n    resp = gen_gaussian_kernel(9, sigma=1.4)\n    assert resp.all()\n\ntest_gen_gaussian_kernel()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/digital_image_processing/test_digital_image_processing.py"}], "method_code_mask": "import cv2\nimport numpy as np\n\n\ndef gen_gaussian_kernel(k_size, sigma): [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "miller_rabin", "method_path": "../srcdata/Basic/Python/ciphers/deterministic_miller_rabin.py", "response": "\ndef miller_rabin(n: int, allow_probable: bool=False) ->bool:\n    \"\"\"Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.\n\n    Uses numerical analysis results to return whether or not the passed number\n    is prime. If the passed number is above the upper limit, and\n    allow_probable is True, then a return value of True indicates that n is\n    probably prime. This test does not allow False negatives- a return value\n    of False is ALWAYS composite.\n\n    Parameters\n    ----------\n    n : int\n        The integer to be tested. Since we usually care if a number is prime,\n        n < 2 returns False instead of raising a ValueError.\n    allow_probable: bool, default False\n        Whether or not to test n above the upper bound of the deterministic test.\n\n    Raises\n    ------\n    ValueError\n\n    Reference\n    ---------\n    https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\n    \"\"\"\n    if n == 2:\n        return True\n    if not n % 2 or n < 2:\n        return False\n    if n > 5 and n % 10 not in (1, 3, 7, 9):\n        return False\n    if n > 3317044064679887385961981 and not allow_probable:\n        raise ValueError(\n            'Warning: upper bound of deterministic test is exceeded. Pass allow_probable=True to allow probabilistic test. A return value of True indicates a probable prime.'\n            )\n    bounds = [2047, 1373653, 25326001, 3215031751, 2152302898747, \n        3474749660383, 341550071728321, 1, 3825123056546413051, 1, 1, \n        318665857834031151167461, 3317044064679887385961981]\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    for idx, _p in enumerate(bounds, 1):\n        if n < _p:\n            plist = primes[:idx]\n            break\n    d, s = n - 1, 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n    for prime in plist:\n        pr = False\n        for r in range(s):\n            m = pow(prime, d * 2 ** r, n)\n            if r == 0 and m == 1 or (m + 1) % n == 0:\n                pr = True\n                break\n        if pr:\n            continue\n        return False\n    return True", "test_code_list": [{"test_code": "def test_miller_rabin() ->None:\n    \"\"\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\n    and a prime in each range.\n    \"\"\"\n    assert not miller_rabin(561)\n    assert miller_rabin(563)\n    assert not miller_rabin(838201)\n    assert miller_rabin(838207)\n    assert not miller_rabin(17316001)\n    assert miller_rabin(17316017)\n    assert not miller_rabin(3078386641)\n    assert miller_rabin(3078386653)\n    assert not miller_rabin(1713045574801)\n    assert miller_rabin(1713045574819)\n    assert not miller_rabin(2779799728307)\n    assert miller_rabin(2779799728327)\n    assert not miller_rabin(113850023909441)\n    assert miller_rabin(113850023909527)\n    assert not miller_rabin(1275041018848804351)\n    assert miller_rabin(1275041018848804391)\n    assert not miller_rabin(79666464458507787791867)\n    assert miller_rabin(79666464458507787791951)\n    assert not miller_rabin(552840677446647897660333)\n    assert miller_rabin(552840677446647897660359)\n\ntest_miller_rabin()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/ciphers/deterministic_miller_rabin.py"}], "method_code_mask": "def miller_rabin(n: int, allow_probable: bool=False) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "is_prime", "method_path": "../srcdata/Basic/Python/maths/prime_check.py", "response": "import math\nimport unittest\nimport pytest\ndef is_prime(number: int) ->bool:\n    \"\"\"Checks to see if a number is a prime in O(sqrt(n)).\n\n    A number is prime if it has exactly two factors: 1 and itself.\n\n    >>> is_prime(0)\n    False\n    >>> is_prime(1)\n    False\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(27)\n    False\n    >>> is_prime(87)\n    False\n    >>> is_prime(563)\n    True\n    >>> is_prime(2999)\n    True\n    >>> is_prime(67483)\n    False\n    >>> is_prime(16.1)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    >>> is_prime(-4)\n    Traceback (most recent call last):\n        ...\n    ValueError: is_prime() only accepts positive integers\n    \"\"\"\n    if not isinstance(number, int) or not number >= 0:\n        raise ValueError('is_prime() only accepts positive integers')\n    if 1 < number < 4:\n        return True\n    elif number < 2 or number % 2 == 0 or number % 3 == 0:\n        return False\n    for i in range(5, int(math.sqrt(number) + 1), 6):\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n    return True", "test_code_list": [{"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_primes(self):\n        assert is_prime(2)\n        assert is_prime(3)\n        assert is_prime(5)\n        assert is_prime(7)\n        assert is_prime(11)\n        assert is_prime(13)\n        assert is_prime(17)\n        assert is_prime(19)\n        assert is_prime(23)\n        assert is_prime(29)\n    \nTest().test_primes()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/maths/prime_check.py"}, {"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_not_primes(self):\n        with pytest.raises(ValueError):\n            is_prime(-19)\n        assert not is_prime(0\n            ), \"Zero doesn't have any positive factors, primes must have exactly two.\"\n        assert not is_prime(1\n            ), 'One only has 1 positive factor, primes must have exactly two.'\n        assert not is_prime(2 * 2)\n        assert not is_prime(2 * 3)\n        assert not is_prime(3 * 3)\n        assert not is_prime(3 * 5)\n        assert not is_prime(3 * 5 * 7)\n    \nTest().test_not_primes()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/maths/prime_check.py"}], "method_code_mask": "import math\nimport unittest\nimport pytest\n\n\ndef is_prime(number: int) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "abs_min", "method_path": "../srcdata/Basic/Python/maths/abs.py", "response": "import doctest\ndef abs_val(num: float) ->float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\ndef abs_min(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_min([0,5,1,11])\n    0\n    >>> abs_min([3,-10,-2])\n    -2\n    >>> abs_min([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_min() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_min() arg is an empty sequence')\n    j = x[0]\n    for i in x:\n        if abs_val(i) < abs_val(j):\n            j = i\n    return j", "test_code_list": [{"test_code": "import doctest\ndef abs_max_sort(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max_sort([0,5,1,11])\n    11\n    >>> abs_max_sort([3,-10,-2])\n    -10\n    >>> abs_max_sort([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max_sort() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max_sort() arg is an empty sequence')\n    return sorted(x, key=abs)[-1]\ndef abs_max(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    >>> abs_max([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max() arg is an empty sequence')\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j\ndef test_abs_val():\n    \"\"\"\n    >>> test_abs_val()\n    \"\"\"\n    assert abs_val(0) == 0\n    assert abs_val(34) == 34\n    assert abs_val(-100000000000) == 100000000000\n    a = [-3, -1, 2, -11]\n    assert abs_max(a) == -11\n    assert abs_max_sort(a) == -11\n    assert abs_min(a) == -1\ntest_abs_val()", "code_start": "", "test_path": "../srcdata/Basic/Python/maths/abs.py"}], "method_code_mask": "import doctest\n\n\ndef abs_val(num: float) ->float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) ->int: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "signum", "method_path": "../srcdata/Basic/Python/maths/signum.py", "response": "\ndef signum(num: float) ->int:\n    \"\"\"\n    Applies signum function on the number\n\n    Custom test cases:\n    >>> signum(-10)\n    -1\n    >>> signum(10)\n    1\n    >>> signum(0)\n    0\n    >>> signum(-20.5)\n    -1\n    >>> signum(20.5)\n    1\n    >>> signum(-1e-6)\n    -1\n    >>> signum(1e-6)\n    1\n    >>> signum(\"Hello\")\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'str' and 'int'\n    >>> signum([])\n    Traceback (most recent call last):\n        ...\n    TypeError: '<' not supported between instances of 'list' and 'int'\n    \"\"\"\n    if num < 0:\n        return -1\n    return 1 if num else 0", "test_code_list": [{"test_code": "def test_signum() ->None:\n    \"\"\"\n    Tests the signum function\n    >>> test_signum()\n    \"\"\"\n    assert signum(5) == 1\n    assert signum(-5) == -1\n    assert signum(0) == 0\n    assert signum(10.5) == 1\n    assert signum(-10.5) == -1\n    assert signum(1e-06) == 1\n    assert signum(-1e-06) == -1\n    assert signum(123456789) == 1\n    assert signum(-123456789) == -1\n\ntest_signum()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/maths/signum.py"}], "method_code_mask": "def signum(num: float) ->int: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "identity", "method_path": "../srcdata/Basic/Python/matrix/matrix_operation.py", "response": "from __future__ import annotations\nfrom typing import Any\nimport doctest\ndef identity(n: int) ->list[list[int]]:\n    \"\"\"\n    :param n: dimension for nxn matrix\n    :type n: int\n    :return: Identity matrix of shape [n, n]\n    >>> identity(3)\n    [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    n = int(n)\n    return [[int(row == column) for column in range(n)] for row in range(n)]", "test_code_list": [{"test_code": "import logging\nimport sys\nimport numpy as np\nimport pytest\n@pytest.mark.mat_ops()\ndef test_identity():\n    act = np.identity(5).tolist()\n    theo = identity(5)\n    assert theo == act\n\ntest_identity()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/matrix/tests/test_matrix_operation.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Any\nimport doctest\n\n\ndef identity(n: int) ->list[list[int]]: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "calc_profit", "method_path": "../srcdata/Basic/Python/knapsack/greedy_knapsack.py", "response": "\ndef calc_profit(profit: list, weight: list, max_weight: int) ->int:\n    \"\"\"\n    Function description is as follows-\n    :param profit: Take a list of profits\n    :param weight: Take a list of weight if bags corresponding to the profits\n    :param max_weight: Maximum weight that could be carried\n    :return: Maximum expected gain\n\n    >>> calc_profit([1, 2, 3], [3, 4, 5], 15)\n    6\n    >>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)\n    27\n    \"\"\"\n    if len(profit) != len(weight):\n        raise ValueError('The length of profit and weight must be same.')\n    if max_weight <= 0:\n        raise ValueError('max_weight must greater than zero.')\n    if any(p < 0 for p in profit):\n        raise ValueError('Profit can not be negative.')\n    if any(w < 0 for w in weight):\n        raise ValueError('Weight can not be negative.')\n    profit_by_weight = [(p / w) for p, w in zip(profit, weight)]\n    sorted_profit_by_weight = sorted(profit_by_weight)\n    length = len(sorted_profit_by_weight)\n    limit = 0\n    gain = 0\n    i = 0\n    while limit <= max_weight and i < length:\n        biggest_profit_by_weight = sorted_profit_by_weight[length - i - 1]\n        \"\"\"\n        Calculate the index of the biggest_profit_by_weight in profit_by_weight list.\n        This will give the index of the first encountered element which is same as of\n        biggest_profit_by_weight.  There may be one or more values same as that of\n        biggest_profit_by_weight but index always encounter the very first element\n        only.  To curb this alter the values in profit_by_weight once they are used\n        here it is done to -1 because neither profit nor weight can be in negative.\n        \"\"\"\n        index = profit_by_weight.index(biggest_profit_by_weight)\n        profit_by_weight[index] = -1\n        if max_weight - limit >= weight[index]:\n            limit += weight[index]\n            gain += 1 * profit[index]\n        else:\n            gain += (max_weight - limit) / weight[index] * profit[index]\n            break\n        i += 1\n    return gain", "test_code_list": [{"test_code": "import unittest\nimport pytest\n\nclass TestClass(unittest.TestCase):\n    def test_sorted(self):\n        \"\"\"\n            calc_profit takes the required argument (profit, weight, max_weight)\n            and returns whether the answer matches to the expected ones\n            \"\"\"\n        profit = [10, 20, 30, 40, 50, 60]\n        weight = [2, 4, 6, 8, 10, 12]\n        max_weight = 100\n        assert calc_profit(profit, weight, max_weight) == 210\n    \nTestClass().test_sorted()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/knapsack/tests/test_greedy_knapsack.py"}], "method_code_mask": "def calc_profit(profit: list, weight: list, max_weight: int) ->int: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "knapsack", "method_path": "../srcdata/Basic/Python/knapsack/knapsack.py", "response": "from __future__ import annotations\nimport doctest\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int\n    ) ->int:\n    \"\"\"\n    Returns the maximum value that can be put in a knapsack of a capacity cap,\n    whereby each weight w has a specific value val.\n\n    >>> cap = 50\n    >>> val = [60, 100, 120]\n    >>> w = [10, 20, 30]\n    >>> c = len(val)\n    >>> knapsack(cap, w, val, c)\n    220\n\n    The result is 220 cause the values of 100 and 120 got the weight of 50\n    which is the limit of the capacity.\n    \"\"\"\n    if counter == 0 or capacity == 0:\n        return 0\n    if weights[counter - 1] > capacity:\n        return knapsack(capacity, weights, values, counter - 1)\n    else:\n        left_capacity = capacity - weights[counter - 1]\n        new_value_included = values[counter - 1] + knapsack(left_capacity,\n            weights, values, counter - 1)\n        without_new_value = knapsack(capacity, weights, values, counter - 1)\n        return max(new_value_included, without_new_value)", "test_code_list": [{"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_base_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 0\n        val = [0]\n        w = [0]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n        val = [60]\n        w = [10]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n    \nTest().test_base_case()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_easy_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 3\n        val = [1, 2, 3]\n        w = [3, 2, 1]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 5\n    \nTest().test_easy_case()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_knapsack(self):\n        \"\"\"\n            test for the knapsack\n            \"\"\"\n        cap = 50\n        val = [60, 100, 120]\n        w = [10, 20, 30]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 220\n    \nTest().test_knapsack()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/knapsack/tests/test_knapsack.py"}], "method_code_mask": "from __future__ import annotations\nimport doctest\n\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int\n    ) ->int: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "rabin_karp", "method_path": "../srcdata/Basic/Python/strings/rabin_karp.py", "response": "modulus = 1000003\nalphabet_size = 256\ndef rabin_karp(pattern: str, text: str) ->bool:\n    \"\"\"\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\n    with complexity O(nm), most efficient when it is used with multiple patterns\n    as it is able to check if any of a set of patterns match a section of text in o(1)\n    given the precomputed hashes.\n    This will be the simple version which only assumes one pattern is being searched\n    for but it's not hard to modify\n    1) Calculate pattern hash\n    2) Step through the text one character at a time passing a window with the same\n        length as the pattern\n        calculating the hash of the text within the window compare it with the hash\n        of the pattern. Only testing equality if the hashes match\n    \"\"\"\n    p_len = len(pattern)\n    t_len = len(text)\n    if p_len > t_len:\n        return False\n    p_hash = 0\n    text_hash = 0\n    modulus_power = 1\n    for i in range(p_len):\n        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus\n        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus\n        if i == p_len - 1:\n            continue\n        modulus_power = modulus_power * alphabet_size % modulus\n    for i in range(t_len - p_len + 1):\n        if text_hash == p_hash and text[i:i + p_len] == pattern:\n            return True\n        if i == t_len - p_len:\n            continue\n        text_hash = ((text_hash - ord(text[i]) * modulus_power) *\n            alphabet_size + ord(text[i + p_len])) % modulus\n    return False", "test_code_list": [{"test_code": "def test_rabin_karp() ->None:\n    \"\"\"\n    >>> test_rabin_karp()\n    Success.\n    \"\"\"\n    pattern = 'abc1abc12'\n    text1 = 'alskfjaldsabc1abc1abc12k23adsfabcabc'\n    text2 = 'alskfjaldsk23adsfabcabc'\n    assert rabin_karp(pattern, text1)\n    assert not rabin_karp(pattern, text2)\n    pattern = 'ABABX'\n    text = 'ABABZABABYABABX'\n    assert rabin_karp(pattern, text)\n    pattern = 'AAAB'\n    text = 'ABAAAAAB'\n    assert rabin_karp(pattern, text)\n    pattern = 'abcdabcy'\n    text = 'abcxabcdabxabcdabcdabcy'\n    assert rabin_karp(pattern, text)\n    pattern = 'L\u00fc'\n    text = 'L\u00fcsai'\n    assert rabin_karp(pattern, text)\n    pattern = 'Lue'\n    assert not rabin_karp(pattern, text)\n    print('Success.')\n\ntest_rabin_karp()\n", "code_start": "", "test_path": "../srcdata/Basic/Python/strings/rabin_karp.py"}], "method_code_mask": "modulus = 1000003\nalphabet_size = 256\n\n\ndef rabin_karp(pattern: str, text: str) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "find_set", "method_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\ndef find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_set(x: Node) ->Node: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "make_set", "method_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef make_set(x: Node) ->None: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "find_python_set", "method_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\ndef find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)", "test_code_list": [{"test_code": "def find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "../srcdata/Basic/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_python_set(node: Node) ->set: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "total_time", "method_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef total_time(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "horizontal_distance", "method_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "std", "repository": "Python", "full_method_name": "max_height", "method_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "../srcdata/Basic/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\n\n\ndef max_height(init_velocity: float, angle: float) ->float: [MASK]\n"}
