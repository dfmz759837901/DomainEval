{"model_name": "std", "repository": "setuptools", "full_method_name": "makeSetup", "method_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py", "response": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\ndef makeSetup(**args):\n    \"\"\"Return distribution from 'setup(**args)', without executing commands\"\"\"\n    distutils.core._setup_stop_after = 'commandline'\n    args.setdefault('script_args', ['install'])\n    try:\n        return setuptools.setup(**args)\n    finally:\n        distutils.core._setup_stop_after = None", "test_code_list": [{"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testTestIsCommand(self):\n\t    test_cmd = makeSetup().get_command_obj('test')\n\t    assert isinstance(test_cmd, distutils.cmd.Command)\n\t\nTestCommandTests().testTestIsCommand()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testLongOptSuiteWNoDefault(self):\n\t    ts1 = makeSetup(script_args=['test', '--test-suite=foo.tests.suite'])\n\t    ts1 = ts1.get_command_obj('test')\n\t    ts1.ensure_finalized()\n\t    assert ts1.test_suite == 'foo.tests.suite'\n\t\nTestCommandTests().testLongOptSuiteWNoDefault()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testDefaultSuite(self):\n\t    ts2 = makeSetup(test_suite='bar.tests.suite').get_command_obj('test')\n\t    ts2.ensure_finalized()\n\t    assert ts2.test_suite == 'bar.tests.suite'\n\t\nTestCommandTests().testDefaultSuite()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testDefaultWModuleOnCmdLine(self):\n\t    ts3 = makeSetup(test_suite='bar.tests', script_args=['test', '-m',\n\t        'foo.tests']).get_command_obj('test')\n\t    ts3.ensure_finalized()\n\t    assert ts3.test_module == 'foo.tests'\n\t    assert ts3.test_suite == 'foo.tests.test_suite'\n\t\nTestCommandTests().testDefaultWModuleOnCmdLine()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}, {"test_code": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\nclass TestCommandTests():\n\tdef testNoSuite(self):\n\t    ts5 = makeSetup().get_command_obj('test')\n\t    ts5.ensure_finalized()\n\t    assert ts5.test_suite is None\n\t\nTestCommandTests().testNoSuite()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_setuptools.py"}], "method_code_mask": "import re\nimport sys\nimport os\nimport distutils.core\nimport distutils.cmd\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.core import Extension\nfrom zipfile import ZipFile\nimport pytest\nimport setuptools\nimport setuptools.dist\nimport setuptools.depends as dep\nfrom setuptools.depends import Require\nfrom packaging.version import Version\nfrom json import __version__\n\n\ndef makeSetup(**args): [MASK]\n"}
{"model_name": "std", "repository": "setuptools", "full_method_name": "get_abi3_suffix", "method_path": "../srcdata/Basic/setuptools/setuptools/command/build_ext.py", "response": "from __future__ import annotations\nimport os\nimport sys\nimport itertools\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom typing import Iterator\nfrom pathlib import Path\nfrom distutils.command.build_ext import build_ext as _du_build_ext\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom distutils.sysconfig import get_config_var\nfrom distutils import log\nfrom setuptools.errors import BaseError\nfrom setuptools.extension import Extension\nfrom setuptools.extension import Library\nfrom distutils.sysconfig import _config_vars as _CONFIG_VARS\nfrom distutils.util import byte_compile\ndef get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix in EXTENSION_SUFFIXES:\n        if '.abi3' in suffix:\n            return suffix\n        elif suffix == '.pyd':\n            return suffix\n    return None", "test_code_list": [{"test_code": "import os\nimport sys\nimport distutils.command.build_ext as orig\nfrom distutils.sysconfig import get_config_var\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.command.build_ext import get_abi3_suffix\nfrom setuptools.dist import Distribution\nfrom setuptools.extension import Extension\nfrom setuptools.errors import CompileError\nimport pytest\n\nclass TestBuildExt():\n\tdef test_abi3_filename(self):\n\t    \"\"\"\n\t        Filename needs to be loadable by several versions\n\t        of Python 3 if 'is_abi3' is truthy on Extension()\n\t        \"\"\"\n\t    print(get_abi3_suffix())\n\t    extension = Extension('spam.eggs', ['eggs.c'], py_limited_api=True)\n\t    dist = Distribution(dict(ext_modules=[extension]))\n\t    cmd = build_ext(dist)\n\t    cmd.finalize_options()\n\t    assert 'spam.eggs' in cmd.ext_map\n\t    res = cmd.get_ext_filename('spam.eggs')\n\t    if not get_abi3_suffix():\n\t        assert res.endswith(get_config_var('EXT_SUFFIX'))\n\t    elif sys.platform == 'win32':\n\t        assert res.endswith('eggs.pyd')\n\t    else:\n\t        assert 'abi3' in res\n\t\nTestBuildExt().test_abi3_filename()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_build_ext.py"}], "method_code_mask": "from __future__ import annotations\nimport os\nimport sys\nimport itertools\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom importlib.util import cache_from_source as _compiled_file_name\nfrom typing import Iterator\nfrom pathlib import Path\nfrom distutils.command.build_ext import build_ext as _du_build_ext\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom distutils.sysconfig import get_config_var\nfrom distutils import log\nfrom setuptools.errors import BaseError\nfrom setuptools.extension import Extension\nfrom setuptools.extension import Library\nfrom distutils.sysconfig import _config_vars as _CONFIG_VARS\nfrom distutils.util import byte_compile\n\n\ndef get_abi3_suffix(): [MASK]\n"}
{"model_name": "std", "repository": "setuptools", "full_method_name": "CommandSpec.from_param", "method_path": "../srcdata/Basic/setuptools/setuptools/command/easy_install.py", "response": "from __future__ import annotations\nfrom glob import glob\nfrom distutils.util import get_platform\nfrom distutils.util import convert_path\nfrom distutils.util import subst_vars\nfrom distutils.errors import DistutilsArgError\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsError\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils import log\nfrom distutils import dir_util\nfrom distutils.command.build_scripts import first_line_re\nfrom distutils.command import install\nimport sys\nimport os\nimport zipimport\nimport shutil\nimport tempfile\nimport zipfile\nimport re\nimport stat\nimport random\nimport textwrap\nimport warnings\nimport site\nimport struct\nimport contextlib\nimport subprocess\nimport shlex\nimport io\nimport configparser\nimport sysconfig\nfrom sysconfig import get_path\nfrom setuptools import Command\nfrom setuptools.sandbox import run_setup\nfrom setuptools.command import setopt\nfrom setuptools.archive_util import unpack_archive\nfrom setuptools.package_index import PackageIndex\nfrom setuptools.package_index import parse_requirement_arg\nfrom setuptools.package_index import URL_SCHEME\nfrom setuptools.command import bdist_egg\nfrom setuptools.command import egg_info\nfrom setuptools.warnings import SetuptoolsDeprecationWarning\nfrom setuptools.warnings import SetuptoolsWarning\nfrom setuptools.wheel import Wheel\nfrom pkg_resources import normalize_path\nfrom pkg_resources import resource_string\nfrom pkg_resources import get_distribution\nfrom pkg_resources import find_distributions\nfrom pkg_resources import Environment\nfrom pkg_resources import Requirement\nfrom pkg_resources import Distribution\nfrom pkg_resources import PathMetadata\nfrom pkg_resources import EggMetadata\nfrom pkg_resources import WorkingSet\nfrom pkg_resources import DistributionNotFound\nfrom pkg_resources import VersionConflict\nfrom pkg_resources import DEVELOP_DIST\nimport pkg_resources\nfrom distutils import file_util\nfrom distutils.spawn import spawn\nfrom distutils.util import byte_compile\nfrom os import chmod as _chmod\nclass CommandSpec(list):\n    \"\"\"\n    A command spec for a #! header, specified as a list of arguments akin to\n    those passed to Popen.\n    \"\"\"\n    options: list[str] = []\n    split_args: dict[str, bool] = dict()\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Choose the best CommandSpec class based on environmental conditions.\n        \"\"\"\n        return cls\n\n    @classmethod\n    def _sys_executable(cls):\n        _default = os.path.normpath(sys.executable)\n        return os.environ.get('__PYVENV_LAUNCHER__', _default)\n\n    @classmethod\n    def from_param(cls, param):\n        \"\"\"\n        Construct a CommandSpec from a parameter to build_scripts, which may\n        be None.\n        \"\"\"\n        if isinstance(param, cls):\n            return param\n        if isinstance(param, list):\n            return cls(param)\n        if param is None:\n            return cls.from_environment()\n        return cls.from_string(param)\n\n    @classmethod\n    def from_environment(cls):\n        return cls([cls._sys_executable()])\n\n    @classmethod\n    def from_string(cls, string):\n        \"\"\"\n        Construct a command spec from a simple string representing a command\n        line parseable by shlex.split.\n        \"\"\"\n        items = shlex.split(string, **cls.split_args)\n        return cls(items)\n\n    def install_options(self, script_text):\n        self.options = shlex.split(self._extract_options(script_text))\n        cmdline = subprocess.list2cmdline(self)\n        if not isascii(cmdline):\n            self.options[:0] = ['-x']\n\n    @staticmethod\n    def _extract_options(orig_script):\n        \"\"\"\n        Extract any options from the first line of the script.\n        \"\"\"\n        first = (orig_script + '\\n').splitlines()[0]\n        match = _first_line_re().match(first)\n        options = match.group(1) or '' if match else ''\n        return options.strip()\n\n    def as_header(self):\n        return self._render(self + list(self.options))\n\n    @staticmethod\n    def _strip_quotes(item):\n        _QUOTES = '\"\\''\n        for q in _QUOTES:\n            if item.startswith(q) and item.endswith(q):\n                return item[1:-1]\n        return item\n\n    @staticmethod\n    def _render(items):\n        cmdline = subprocess.list2cmdline(CommandSpec._strip_quotes(item.\n            strip()) for item in items)\n        return '#!' + cmdline + '\\n'", "test_code_list": [{"test_code": "import sys\nimport os\nimport tempfile\nimport site\nimport contextlib\nimport tarfile\nimport logging\nimport itertools\nimport distutils.errors\nimport io\nfrom typing import NamedTuple\nimport zipfile\nimport time\nimport re\nimport subprocess\nimport pathlib\nimport warnings\nfrom pathlib import Path\nfrom unittest import mock\nimport pytest\nfrom setuptools import sandbox\nfrom setuptools.sandbox import run_setup\nimport setuptools.command.easy_install as ei\nfrom setuptools.command.easy_install import PthDistributions\nfrom setuptools.dist import Distribution\nfrom pkg_resources import normalize_path\nfrom pkg_resources import working_set\nfrom pkg_resources import Distribution as PRDistribution\nimport pkg_resources\n\nclass TestCommandSpec():\n\tdef test_from_simple_string_uses_shlex(self):\n\t    \"\"\"\n\t        In order to support `executable = /usr/bin/env my-python`, make sure\n\t        from_param invokes shlex on that input.\n\t        \"\"\"\n\t    cmd = CommandSpec.from_param('/usr/bin/env my-python')\n\t    assert len(cmd) == 2\n\t    assert '\"' not in cmd.as_header()\n\t\nTestCommandSpec().test_from_simple_string_uses_shlex()\n", "code_start": "", "test_path": "../srcdata/Basic/setuptools/setuptools/tests/test_easy_install.py"}], "method_code_mask": "from __future__ import annotations\nfrom glob import glob\nfrom distutils.util import get_platform\nfrom distutils.util import convert_path\nfrom distutils.util import subst_vars\nfrom distutils.errors import DistutilsArgError\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.errors import DistutilsError\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils import log\nfrom distutils import dir_util\nfrom distutils.command.build_scripts import first_line_re\nfrom distutils.command import install\nimport sys\nimport os\nimport zipimport\nimport shutil\nimport tempfile\nimport zipfile\nimport re\nimport stat\nimport random\nimport textwrap\nimport warnings\nimport site\nimport struct\nimport contextlib\nimport subprocess\nimport shlex\nimport io\nimport configparser\nimport sysconfig\nfrom sysconfig import get_path\nfrom setuptools import Command\nfrom setuptools.sandbox import run_setup\nfrom setuptools.command import setopt\nfrom setuptools.archive_util import unpack_archive\nfrom setuptools.package_index import PackageIndex\nfrom setuptools.package_index import parse_requirement_arg\nfrom setuptools.package_index import URL_SCHEME\nfrom setuptools.command import bdist_egg\nfrom setuptools.command import egg_info\nfrom setuptools.warnings import SetuptoolsDeprecationWarning\nfrom setuptools.warnings import SetuptoolsWarning\nfrom setuptools.wheel import Wheel\nfrom pkg_resources import normalize_path\nfrom pkg_resources import resource_string\nfrom pkg_resources import get_distribution\nfrom pkg_resources import find_distributions\nfrom pkg_resources import Environment\nfrom pkg_resources import Requirement\nfrom pkg_resources import Distribution\nfrom pkg_resources import PathMetadata\nfrom pkg_resources import EggMetadata\nfrom pkg_resources import WorkingSet\nfrom pkg_resources import DistributionNotFound\nfrom pkg_resources import VersionConflict\nfrom pkg_resources import DEVELOP_DIST\nimport pkg_resources\nfrom distutils import file_util\nfrom distutils.spawn import spawn\nfrom distutils.util import byte_compile\nfrom os import chmod as _chmod\n\n\nclass CommandSpec(list):\n    \"\"\"\n    A command spec for a #! header, specified as a list of arguments akin to\n    those passed to Popen.\n    \"\"\"\n    options: list[str] = []\n    split_args: dict[str, bool] = dict()\n\n    @classmethod\n    def best(cls):\n        \"\"\"\n        Choose the best CommandSpec class based on environmental conditions.\n        \"\"\"\n        return cls\n\n    @classmethod\n    def _sys_executable(cls):\n        _default = os.path.normpath(sys.executable)\n        return os.environ.get('__PYVENV_LAUNCHER__', _default)\n\n    @classmethod\n    def from_param(cls, param): [MASK]\n\n    @classmethod\n    def from_environment(cls):\n        return cls([cls._sys_executable()])\n\n    @classmethod\n    def from_string(cls, string):\n        \"\"\"\n        Construct a command spec from a simple string representing a command\n        line parseable by shlex.split.\n        \"\"\"\n        items = shlex.split(string, **cls.split_args)\n        return cls(items)\n\n    def install_options(self, script_text):\n        self.options = shlex.split(self._extract_options(script_text))\n        cmdline = subprocess.list2cmdline(self)\n        if not isascii(cmdline):\n            self.options[:0] = ['-x']\n\n    @staticmethod\n    def _extract_options(orig_script):\n        \"\"\"\n        Extract any options from the first line of the script.\n        \"\"\"\n        first = (orig_script + '\\n').splitlines()[0]\n        match = _first_line_re().match(first)\n        options = match.group(1) or '' if match else ''\n        return options.strip()\n\n    def as_header(self):\n        return self._render(self + list(self.options))\n\n    @staticmethod\n    def _strip_quotes(item):\n        _QUOTES = '\"\\''\n        for q in _QUOTES:\n            if item.startswith(q) and item.endswith(q):\n                return item[1:-1]\n        return item\n\n    @staticmethod\n    def _render(items):\n        cmdline = subprocess.list2cmdline(CommandSpec._strip_quotes(item.\n            strip()) for item in items)\n        return '#!' + cmdline + '\\n'\n"}
