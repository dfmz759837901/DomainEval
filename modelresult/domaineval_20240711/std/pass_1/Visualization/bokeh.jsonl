{"model_name": "std", "repository": "bokeh", "full_method_name": "envset", "method_path": "../srcdata/Visualization/bokeh/tests/support/util/env.py", "response": "from __future__ import annotations\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import Mapping\n@contextmanager\ndef envset(value: (Mapping[str, str] | None)=None, **kw: Any) ->Iterator[None]:\n    \"\"\" Temporarily set environment variables and undo the updates on exit.\n\n    Args:\n        value (optional) :\n            A mapping of strings to strings to apply to os.environ\n\n    Any remaining keywoard args are applied to os.environ\n\n    \"\"\"\n    old = os.environ.copy()\n    if value:\n        os.environ.update(value)\n    os.environ.update(**kw)\n    yield\n    os.environ.clear()\n    os.environ.update(old)", "test_code_list": [{"test_code": "import pytest\nimport logging\nimport bokeh.settings as bs\n\nclass TestPrioritizedSetting():\n    def test_dev_default(self) ->None:\n        ps = bs.PrioritizedSetting('foo', env_var='BOKEH_FOO', default=10,\n            dev_default=25)\n        assert ps.dev_default == 25\n        with envset(BOKEH_DEV='yes'):\n            assert ps() == 25\n            assert ps(default=20) == 25\n    \nTestPrioritizedSetting().test_dev_default()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_settings.py"}, {"test_code": "import pytest\nimport logging\nimport bokeh.settings as bs\n\nclass TestPrioritizedSetting():\n    def test_env_var(self) ->None:\n        with envset(BOKEH_FOO='30'):\n            ps = bs.PrioritizedSetting('foo', env_var='BOKEH_FOO')\n            assert ps.env_var == 'BOKEH_FOO'\n            assert ps() == '30'\n            assert ps(default=20) == '30'\n    \nTestPrioritizedSetting().test_env_var()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_settings.py"}, {"test_code": "import pytest\nimport logging\nimport bokeh.settings as bs\n\nclass TestPrioritizedSetting():\n    def test_env_var_converts(self) ->None:\n        with envset(BOKEH_FOO='30'):\n            ps = bs.PrioritizedSetting('foo', convert=int, env_var='BOKEH_FOO')\n            assert ps() == 30\n    \nTestPrioritizedSetting().test_env_var_converts()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_settings.py"}, {"test_code": "import pytest\nimport logging\nimport bokeh.settings as bs\n\nclass TestPrioritizedSetting():\n    def test_precedence(self) ->None:\n    \n    \n        class FakeSettings:\n            config_override = {}\n            config_user = {}\n            config_system = {}\n        ps = bs.PrioritizedSetting('foo', env_var='BOKEH_FOO', convert=int,\n            default=0, dev_default=15)\n        ps._parent = FakeSettings\n        assert ps() == 0\n        assert ps(default=10) == 10\n        with envset(BOKEH_DEV='yes'):\n            assert ps() == 15\n        FakeSettings.config_system['foo'] = 20\n        assert ps() == 20\n        assert ps(default=10) == 20\n        FakeSettings.config_user['foo'] = 30\n        assert ps() == 30\n        assert ps(default=10) == 30\n        with envset(BOKEH_FOO='40'):\n            assert ps() == 40\n            assert ps(default=10) == 40\n            FakeSettings.config_override['foo'] = 50\n            assert ps() == 50\n            assert ps(default=10) == 50\n            ps.set_value(60)\n            assert ps() == 60\n            assert ps(default=10) == 60\n            assert ps(70) == 70\n            assert ps(70, default=10) == 70\n    \nTestPrioritizedSetting().test_precedence()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_settings.py"}, {"test_code": "import pytest\nimport datetime\nfrom math import inf\nfrom math import nan\nimport numpy as np\nimport pandas as pd\nimport pytz\nimport bokeh.util.serialization as bus\n\nclass Test_make_id():\n    def test_simple_ids_yes(self) ->None:\n        bus._simple_id = 999\n        with envset(BOKEH_SIMPLE_IDS='yes'):\n            assert bus.make_id() == 'p1000'\n            assert bus.make_id() == 'p1001'\n            assert bus.make_id() == 'p1002'\n    \nTest_make_id().test_simple_ids_yes()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/util/test_util__serialization.py"}, {"test_code": "import pytest\nimport datetime\nfrom math import inf\nfrom math import nan\nimport numpy as np\nimport pandas as pd\nimport pytz\nimport bokeh.util.serialization as bus\n\nclass Test_make_id():\n    def test_simple_ids_no(self) ->None:\n        with envset(BOKEH_SIMPLE_IDS='no'):\n            assert len(bus.make_id()) == 36\n            assert isinstance(bus.make_id(), str)\n    \nTest_make_id().test_simple_ids_no()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/util/test_util__serialization.py"}, {"test_code": "import pytest\nimport os\ndef test_envset_preserves_id() ->None:\n    env = os.environ\n    with envset(foo='10'):\n        assert os.environ is env\n    assert os.environ is env\n\ntest_envset_preserves_id()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\ndef test_envset_restores() ->None:\n    if 'foo' in os.environ:\n        old_foo = os.environ['foo']\n        os.environ['foo'] = '123'\n        with envset(foo='10'):\n            pass\n        assert os.environ['foo'] == '123'\n        os.environ['foo'] = old_foo\n    else:\n        os.environ['foo'] = '123'\n        with envset(foo='10'):\n            pass\n        assert os.environ['foo'] == '123'\n        del os.environ['foo']\n\ntest_envset_restores()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\nUNLIKELY_KEY2 = '_bk__bar__zzz123___'\nUNLIKELY_KEY1 = '_bk__foo__zzz123___'\ndef test_envset_accepts_items() ->None:\n    with envset([(UNLIKELY_KEY1, '10'), (UNLIKELY_KEY2, '20')]):\n        assert os.environ[UNLIKELY_KEY1] == '10'\n        assert os.environ[UNLIKELY_KEY2] == '20'\n    assert UNLIKELY_KEY1 not in os.environ\n    assert UNLIKELY_KEY2 not in os.environ\ntest_envset_accepts_items()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\nUNLIKELY_KEY2 = '_bk__bar__zzz123___'\nUNLIKELY_KEY1 = '_bk__foo__zzz123___'\ndef test_envset_accepts_dict() ->None:\n    with envset({UNLIKELY_KEY1: '10', UNLIKELY_KEY2: '20'}):\n        assert os.environ[UNLIKELY_KEY1] == '10'\n        assert os.environ[UNLIKELY_KEY2] == '20'\n    assert UNLIKELY_KEY1 not in os.environ\n    assert UNLIKELY_KEY2 not in os.environ\ntest_envset_accepts_dict()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\nUNLIKELY_KEY2 = '_bk__bar__zzz123___'\nUNLIKELY_KEY1 = '_bk__foo__zzz123___'\ndef test_envset_accepts_kwargs() ->None:\n    with envset(**{UNLIKELY_KEY1: '10', UNLIKELY_KEY2: '20'}):\n        assert os.environ[UNLIKELY_KEY1] == '10'\n        assert os.environ[UNLIKELY_KEY2] == '20'\n    assert UNLIKELY_KEY1 not in os.environ\n    assert UNLIKELY_KEY2 not in os.environ\ntest_envset_accepts_kwargs()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\nUNLIKELY_KEY2 = '_bk__bar__zzz123___'\nUNLIKELY_KEY1 = '_bk__foo__zzz123___'\ndef test_envset_accepts_mix() ->None:\n    with envset([(UNLIKELY_KEY1, '10')], **{UNLIKELY_KEY2: '20'}):\n        assert os.environ[UNLIKELY_KEY1] == '10'\n        assert os.environ[UNLIKELY_KEY2] == '20'\n    assert UNLIKELY_KEY1 not in os.environ\n    assert UNLIKELY_KEY2 not in os.environ\ntest_envset_accepts_mix()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}, {"test_code": "import pytest\nimport os\nUNLIKELY_KEY2 = '_bk__bar__zzz123___'\nUNLIKELY_KEY1 = '_bk__foo__zzz123___'\ndef test_envset_applies_kwargs_last() ->None:\n    with envset([(UNLIKELY_KEY1, '10')], **{UNLIKELY_KEY1: '30',\n        UNLIKELY_KEY2: '20'}):\n        assert os.environ[UNLIKELY_KEY1] == '30'\n        assert os.environ[UNLIKELY_KEY2] == '20'\n    assert UNLIKELY_KEY1 not in os.environ\n    assert UNLIKELY_KEY2 not in os.environ\ntest_envset_applies_kwargs_last()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/_testing/util/test_env.py"}], "method_code_mask": "from __future__ import annotations\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import Mapping\n\n\n@contextmanager\ndef envset(value: (Mapping[str, str] | None)=None, **kw: Any) ->Iterator[None\n    ]: [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "_collector", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py", "response": "from __future__ import annotations\nimport pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef _collector(results):\n\n    def foo(val):\n        results.append(val)\n    return foo", "test_code_list": [{"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test_bounce() ->None:\n    results = []\n    func = bd.bounce([0, 1, 5, -1])(_collector(results))\n    for i in range(8):\n        func()\n    assert results == [0, 1, 5, -1, -1, 5, 1, 0]\n\ntest_bounce()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\noffset = 2\nphi = 0.1\nA = 3\nw = 0.3\ndef test_cosine() ->None:\n    results = []\n    func = bd.cosine(w, A, phi, offset)(_collector(results))\n    for i in range(4):\n        func()\n    assert_allclose(results, [4.985012495834077, 4.763182982008655,\n        4.294526561853465, 3.6209069176044197])\ntest_cosine()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test_count() ->None:\n    results = []\n    func = bd.count()(_collector(results))\n    for i in range(8):\n        func()\n    assert results == list(range(8))\n\ntest_count()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test_force() ->None:\n    results = []\n    seq = (x for x in ['foo', 'bar', 'baz'])\n    w = bd.force(_collector(results), seq)\n    w()\n    assert results == ['foo']\n    w()\n    assert results == ['foo', 'bar']\n    w()\n    assert results == ['foo', 'bar', 'baz']\n\ntest_force()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test_linear() ->None:\n    results = []\n    func = bd.linear(m=2.5, b=3.7)(_collector(results))\n    for i in range(4):\n        func()\n    assert_allclose(results, [3.7, 6.2, 8.7, 11.2])\n\ntest_linear()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test_repeat() ->None:\n    results = []\n    func = bd.repeat([0, 1, 5, -1])(_collector(results))\n    for i in range(8):\n        func()\n    assert results == [0, 1, 5, -1, 0, 1, 5, -1]\n\ntest_repeat()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\noffset = 2\nphi = 0.1\nA = 3\nw = 0.3\ndef test_sine() ->None:\n    results = []\n    func = bd.sine(w, A, phi, offset)(_collector(results))\n    for i in range(4):\n        func()\n    assert_allclose(results, [2.2995002499404844, 3.1682550269259515,\n        3.932653061713073, 4.524412954423689])\ntest_sine()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}, {"test_code": "import pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\ndef test__advance() ->None:\n    results = []\n    testf = _collector(results)\n    s = bd._advance(testf)\n    next(s)\n    assert results == [0]\n    next(s)\n    assert results == [0, 1]\n    next(s)\n    assert results == [0, 1, 2]\n    next(s)\n    assert results == [0, 1, 2, 3]\n\ntest__advance()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/test_driving.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nfrom numpy.testing import assert_allclose\nimport bokeh.driving as bd\n\n\ndef _collector(results): [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "compute_sha256", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/core/test_templates.py", "response": "from __future__ import annotations\nimport pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\ndef compute_sha256(data):\n    sha256 = hashlib.sha256()\n    sha256.update(data)\n    return sha256.hexdigest()", "test_code_list": [{"test_code": "import pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\npinned_template_sha256 = (\n    '6019c4cb80495c17303e1b5b05c27aac64e8ef35f41b2d2b9aabcbbe5cf5d3b1')\ndef _crlf_cr_2_lf_bin(s):\n    return re.sub(b'\\r\\n|\\r|\\n', b'\\n', s)\nTOP_PATH = abspath(join(split(bct.__file__)[0]))\ndef test_autoload_template_has_changed() ->None:\n    \"\"\"This is not really a test but a reminder that if you change the\n    autoload_nb_js.js template then you should make sure that insertion of\n    plots into notebooks is working as expected. In particular, this test was\n    created as part of https://github.com/bokeh/bokeh/issues/7125.\n    \"\"\"\n    with open(join(TOP_PATH, '_templates/autoload_nb_js.js'), mode='rb') as f:\n        current_template_sha256 = compute_sha256(_crlf_cr_2_lf_bin(f.read()))\n        assert pinned_template_sha256 == current_template_sha256, \"\"\"            It seems that the template autoload_nb_js.js has changed.\n            If this is voluntary and that proper testing of plots insertion\n            in notebooks has been completed successfully, update this test\n            with the new file SHA256 signature.\"\"\"\ntest_autoload_template_has_changed()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/core/test_templates.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\n\n\ndef compute_sha256(data): [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "get_html_lines", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/core/test_templates.py", "response": "from __future__ import annotations\nimport pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\ndef get_html_lines(resource_mode: ResourcesMode) ->list[str]:\n    p = figure()\n    p.scatter(x=[], y=[])\n    html = file_html(p, resources=Resources(resource_mode))\n    return html.split('\\n')", "test_code_list": [{"test_code": "import pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\ndef test_no_white_space_in_top_of_html() ->None:\n    lines = get_html_lines('inline')\n    any_character = re.compile('\\\\S')\n    assert any_character.search(lines[0]) is not None\n\ntest_no_white_space_in_top_of_html()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/core/test_templates.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nimport hashlib\nimport re\nimport sys\nfrom os.path import abspath\nfrom os.path import join\nfrom os.path import split\nfrom bokeh.embed import file_html\nfrom bokeh.plotting import figure\nfrom bokeh.resources import Resources\nfrom bokeh.resources import ResourcesMode\nimport bokeh.core.templates as bct\n\n\ndef get_html_lines(resource_mode: ResourcesMode) ->list[str]: [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "plot", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py", "response": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef plot() ->models.Plot:\n    from bokeh.plotting import figure\n    plot = figure()\n    plot.scatter([1, 2], [2, 3])\n    return plot", "test_code_list": [{"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef table() ->models.DataTable:\n    return models.DataTable()\nclass Test__any():\n    def test_with_models(self) ->None:\n        assert beb._any({plot(), table()}, lambda x: isinstance(x, models.Plot)\n            ) is True\n        assert beb._any({plot(), table()}, lambda x: isinstance(x, models.Button)\n            ) is False\nTest__any().test_with_models()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef table() ->models.DataTable:\n    return models.DataTable()\nclass Test__use_gl():\n    def test_without_gl(self) ->None:\n        assert beb._use_gl(beb._all_objs([plot()])) is False\n        assert beb._use_gl(beb._all_objs([plot(), table()])) is False\n        assert beb._use_gl(beb._all_objs([plot(), widget()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        assert beb._use_gl(beb._all_objs([d])) is False\nTest__use_gl().test_without_gl()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\nclass Test__use_gl():\n    def test_with_gl(self) ->None:\n        assert beb._use_gl(beb._all_objs([glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), widget(), glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), widget(), table(), glplot()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_gl(beb._all_objs([d])) is True\nTest__use_gl().test_with_gl()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\nclass Test__use_tables():\n    def test_without_tables(self) ->None:\n        assert beb._use_tables(beb._all_objs([plot()])) is False\n        assert beb._use_tables(beb._all_objs([plot(), glplot()])) is False\n        assert beb._use_tables(beb._all_objs([plot(), widget()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(glplot())\n        d.add_root(widget())\n        assert beb._use_tables(beb._all_objs([d])) is False\nTest__use_tables().test_without_tables()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef table() ->models.DataTable:\n    return models.DataTable()\nclass Test__use_tables():\n    def test_with_tables(self) ->None:\n        assert beb._use_tables(beb._all_objs([table()])) is True\n        assert beb._use_tables(beb._all_objs([table(), plot()])) is True\n        assert beb._use_tables(beb._all_objs([table(), plot(), glplot()])) is True\n        assert beb._use_tables(beb._all_objs([table(), widget(), table(),\n            glplot()])) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_tables(beb._all_objs([d])) is True\nTest__use_tables().test_with_tables()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\nclass Test__use_widgets():\n    def test_without_widgets(self) ->None:\n        assert beb._use_widgets(beb._all_objs([plot()])) is False\n        assert beb._use_widgets(beb._all_objs([plot(), glplot()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(glplot())\n        assert beb._use_widgets(beb._all_objs([d])) is False\nTest__use_widgets().test_without_widgets()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef widget() ->models.Button:\n    return models.Button()\nclass Test__use_widgets():\n    def test_with_widgets(self) ->None:\n        assert beb._use_widgets(beb._all_objs([widget()])) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot()])) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot(), glplot()])\n            ) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot(), glplot(),\n            table()])) is True\n        assert beb._use_widgets(beb._all_objs([table(), table(), glplot()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_widgets(beb._all_objs([d])) is True\nTest__use_widgets().test_with_widgets()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\nclass Test__use_mathjax():\n    def test_without_mathjax(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([plot()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), table()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        assert beb._use_mathjax(beb._all_objs([d])) is False\nTest__use_mathjax().test_without_mathjax()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef plaintext() ->models.PlainText:\n    return models.PlainText('$$sin(x)$$')\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef mathtext() ->models.TeX:\n    return models.TeX()\nclass Test__use_mathjax():\n    def test_with_mathjax(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(), mathtext()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), mathtext()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), plaintext(), mathtext()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(mathtext())\n        assert beb._use_mathjax(beb._all_objs([d])) is True\nTest__use_mathjax().test_with_mathjax()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathstring_major_label_overrides_partial() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0):\n        'Sine \\\\[sin(x)\\\\] function'})\ndef mathstring_axis_label_with_parenthesis_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine \\\\(sin(x)\\\\) function')\ndef mathstring_axis_label_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine $$sin(x)$$ function')\ndef mathstring_major_label_overrides() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0): '\\\\[sin(x)\\\\]'})\ndef mathtext() ->models.TeX:\n    return models.TeX()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef mathstring_axis_label() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='$$sin(x)$$')\nclass Test__use_mathjax():\n    def test_with_mathstring(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathstring_axis_label()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(),\n            mathstring_major_label_overrides()])) is True\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label_partial()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_axis_label_with_parenthesis_partial()])) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_major_label_overrides_partial()])) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(mathstring_axis_label())\n        assert beb._use_mathjax(beb._all_objs([d])) is True\nTest__use_mathjax().test_with_mathstring()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathtext() ->models.TeX:\n    return models.TeX()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef plaintext() ->models.PlainText:\n    return models.PlainText('$$sin(x)$$')\nclass Test__use_mathjax():\n    def test_with_plaintext(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(), plaintext()])\n            ) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), plaintext()])\n            ) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext(), plaintext()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(plaintext())\n        assert beb._use_mathjax(beb._all_objs([d])) is False\nTest__use_mathjax().test_with_plaintext()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\n\n\ndef plot() ->models.Plot: [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "glplot", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py", "response": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef plot() ->models.Plot:\n    from bokeh.plotting import figure\n    plot = figure()\n    plot.scatter([1, 2], [2, 3])\n    return plot\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot", "test_code_list": [{"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\nclass Test__use_gl():\n    def test_with_gl(self) ->None:\n        assert beb._use_gl(beb._all_objs([glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), widget(), glplot()])) is True\n        assert beb._use_gl(beb._all_objs([plot(), widget(), table(), glplot()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_gl(beb._all_objs([d])) is True\nTest__use_gl().test_with_gl()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\nclass Test__use_tables():\n    def test_without_tables(self) ->None:\n        assert beb._use_tables(beb._all_objs([plot()])) is False\n        assert beb._use_tables(beb._all_objs([plot(), glplot()])) is False\n        assert beb._use_tables(beb._all_objs([plot(), widget()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(glplot())\n        d.add_root(widget())\n        assert beb._use_tables(beb._all_objs([d])) is False\nTest__use_tables().test_without_tables()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef table() ->models.DataTable:\n    return models.DataTable()\nclass Test__use_tables():\n    def test_with_tables(self) ->None:\n        assert beb._use_tables(beb._all_objs([table()])) is True\n        assert beb._use_tables(beb._all_objs([table(), plot()])) is True\n        assert beb._use_tables(beb._all_objs([table(), plot(), glplot()])) is True\n        assert beb._use_tables(beb._all_objs([table(), widget(), table(),\n            glplot()])) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_tables(beb._all_objs([d])) is True\nTest__use_tables().test_with_tables()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\n\nclass Test__use_widgets():\n    def test_without_widgets(self) ->None:\n        assert beb._use_widgets(beb._all_objs([plot()])) is False\n        assert beb._use_widgets(beb._all_objs([plot(), glplot()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(glplot())\n        assert beb._use_widgets(beb._all_objs([d])) is False\n    \nTest__use_widgets().test_without_widgets()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\nclass Test__use_widgets():\n    def test_with_widgets(self) ->None:\n        assert beb._use_widgets(beb._all_objs([widget()])) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot()])) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot(), glplot()])\n            ) is True\n        assert beb._use_widgets(beb._all_objs([widget(), plot(), glplot(),\n            table()])) is True\n        assert beb._use_widgets(beb._all_objs([table(), table(), glplot()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(glplot())\n        assert beb._use_widgets(beb._all_objs([d])) is True\nTest__use_widgets().test_with_widgets()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef widget() ->models.Button:\n    return models.Button()\ndef table() ->models.DataTable:\n    return models.DataTable()\nclass Test__use_mathjax():\n    def test_without_mathjax(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([plot()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), table()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget()])) is False\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        assert beb._use_mathjax(beb._all_objs([d])) is False\nTest__use_mathjax().test_without_mathjax()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef plaintext() ->models.PlainText:\n    return models.PlainText('$$sin(x)$$')\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef mathtext() ->models.TeX:\n    return models.TeX()\nclass Test__use_mathjax():\n    def test_with_mathjax(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(), mathtext()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), mathtext()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            mathtext()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), plaintext(), mathtext()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(mathtext())\n        assert beb._use_mathjax(beb._all_objs([d])) is True\nTest__use_mathjax().test_with_mathjax()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathstring_major_label_overrides_partial() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0):\n        'Sine \\\\[sin(x)\\\\] function'})\ndef mathstring_axis_label_with_parenthesis_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine \\\\(sin(x)\\\\) function')\ndef mathstring_axis_label_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine $$sin(x)$$ function')\ndef mathstring_major_label_overrides() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0): '\\\\[sin(x)\\\\]'})\ndef mathtext() ->models.TeX:\n    return models.TeX()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef mathstring_axis_label() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='$$sin(x)$$')\nclass Test__use_mathjax():\n    def test_with_mathstring(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathstring_axis_label()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(),\n            mathstring_major_label_overrides()])) is True\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label_partial()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_axis_label_with_parenthesis_partial()])) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_major_label_overrides_partial()])) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(mathstring_axis_label())\n        assert beb._use_mathjax(beb._all_objs([d])) is True\nTest__use_mathjax().test_with_mathstring()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}, {"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathtext() ->models.TeX:\n    return models.TeX()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef plaintext() ->models.PlainText:\n    return models.PlainText('$$sin(x)$$')\nclass Test__use_mathjax():\n    def test_with_plaintext(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(), plaintext()])\n            ) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), plaintext()])\n            ) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            plaintext()])) is False\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext(), plaintext()])\n            ) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(plaintext())\n        assert beb._use_mathjax(beb._all_objs([d])) is False\nTest__use_mathjax().test_with_plaintext()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\n\n\ndef plot() ->models.Plot:\n    from bokeh.plotting import figure\n    plot = figure()\n    plot.scatter([1, 2], [2, 3])\n    return plot\n\n\ndef glplot() ->models.Plot: [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "mathstring_major_label_overrides_partial", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py", "response": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathstring_major_label_overrides() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0): '\\\\[sin(x)\\\\]'})\ndef plot() ->models.Plot:\n    from bokeh.plotting import figure\n    plot = figure()\n    plot.scatter([1, 2], [2, 3])\n    return plot\ndef mathstring_major_label_overrides_partial() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0):\n        'Sine \\\\[sin(x)\\\\] function'})", "test_code_list": [{"test_code": "import pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\ndef mathstring_axis_label_with_parenthesis_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine \\\\(sin(x)\\\\) function')\ndef mathstring_axis_label_partial() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='Sine $$sin(x)$$ function')\ndef mathtext() ->models.TeX:\n    return models.TeX()\ndef table() ->models.DataTable:\n    return models.DataTable()\ndef widget() ->models.Button:\n    return models.Button()\ndef glplot() ->models.Plot:\n    from bokeh.plotting import figure\n    glplot = figure(output_backend='webgl')\n    glplot.scatter([1, 2], [2, 3])\n    return glplot\ndef mathstring_axis_label() ->models.LinearAxis:\n    return models.LinearAxis(axis_label='$$sin(x)$$')\nclass Test__use_mathjax():\n    def test_with_mathstring(self) ->None:\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathstring_axis_label()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), glplot(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), widget(), table(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(), mathtext(),\n            mathstring_axis_label()])) is True\n        assert beb._use_mathjax(beb._all_objs([plot(),\n            mathstring_major_label_overrides()])) is True\n        assert beb._use_mathjax(beb._all_objs([mathstring_axis_label_partial()])\n            ) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_axis_label_with_parenthesis_partial()])) is True\n        assert beb._use_mathjax(beb._all_objs([\n            mathstring_major_label_overrides_partial()])) is True\n        d = Document()\n        d.add_root(plot())\n        d.add_root(table())\n        d.add_root(widget())\n        d.add_root(mathstring_axis_label())\n        assert beb._use_mathjax(beb._all_objs([d])) is True\nTest__use_mathjax().test_with_mathstring()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/embed/test_bundle.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nfrom os.path import dirname\nfrom os.path import join\nfrom bokeh import models\nfrom bokeh.core.has_props import _default_resolver\nfrom bokeh.document import Document\nfrom bokeh.embed.bundle import URL\nfrom bokeh.embed.bundle import extension_dirs\nfrom bokeh.ext import build\nfrom bokeh.resources import CDN\nfrom bokeh.resources import INLINE\nfrom bokeh.resources import Resources\nimport bokeh.embed.bundle as beb\nfrom bokeh.plotting import figure\n\n\ndef mathstring_major_label_overrides() ->models.LinearAxis:\n    return models.LinearAxis(major_label_overrides={(0): '\\\\[sin(x)\\\\]'})\n\n\ndef plot() ->models.Plot:\n    from bokeh.plotting import figure\n    plot = figure()\n    plot.scatter([1, 2], [2, 3])\n    return plot\n\n\ndef mathstring_major_label_overrides_partial() ->models.LinearAxis: [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "_make_invocation_counter", "method_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py", "response": "from __future__ import annotations\nimport pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef _make_invocation_counter(loop, stop_after=1):\n    from types import MethodType\n    counter = {'count': 0}\n\n    def func():\n        counter['count'] += 1\n        if stop_after is not None and counter['count'] >= stop_after:\n            loop.stop()\n\n    def count(self):\n        return self.counter['count']\n    func.count = MethodType(count, func)\n    func.counter = counter\n    return func", "test_code_list": [{"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_next_tick_runs(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            assert 0 == len(ctx.group._next_tick_callback_removers)\n            ctx.group.add_next_tick_callback(callback=func, callback_id=make_id())\n            assert 1 == len(ctx.group._next_tick_callback_removers)\n        assert 1 == func.count()\n        assert 0 == len(ctx.group._next_tick_callback_removers)\nTestCallbackGroup().test_next_tick_runs()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_timeout_runs(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            assert 0 == len(ctx.group._timeout_callback_removers)\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                1, callback_id=make_id())\n            assert 1 == len(ctx.group._timeout_callback_removers)\n        assert 1 == func.count()\n        assert 0 == len(ctx.group._timeout_callback_removers)\nTestCallbackGroup().test_timeout_runs()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_periodic_runs(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=5)\n            assert 0 == len(ctx.group._periodic_callback_removers)\n            cb_id = make_id()\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                1, callback_id=cb_id)\n            assert 1 == len(ctx.group._periodic_callback_removers)\n        assert 5 == func.count()\n        assert 1 == len(ctx.group._periodic_callback_removers)\n        ctx.group.remove_periodic_callback(cb_id)\n        assert 0 == len(ctx.group._periodic_callback_removers)\nTestCallbackGroup().test_periodic_runs()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_next_tick_does_not_run_if_removed_immediately(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            cb_id = make_id()\n            ctx.group.add_next_tick_callback(callback=func, callback_id=cb_id)\n            ctx.group.remove_next_tick_callback(cb_id)\n        assert 0 == func.count()\nTestCallbackGroup().test_next_tick_does_not_run_if_removed_immediately()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_timeout_does_not_run_if_removed_immediately(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            cb_id = ctx.group.add_timeout_callback(callback=func,\n                timeout_milliseconds=1, callback_id=make_id())\n            ctx.group.remove_timeout_callback(cb_id)\n        assert 0 == func.count()\nTestCallbackGroup().test_timeout_does_not_run_if_removed_immediately()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_periodic_does_not_run_if_removed_immediately(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=5)\n            cb_id = make_id()\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                1, callback_id=cb_id)\n            ctx.group.remove_periodic_callback(cb_id)\n        assert 0 == func.count()\nTestCallbackGroup().test_periodic_does_not_run_if_removed_immediately()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_same_callback_as_all_three_types(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=5)\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                2, callback_id=make_id())\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                1, callback_id=make_id())\n            ctx.group.add_next_tick_callback(callback=func, callback_id=make_id())\n        assert 5 == func.count()\nTestCallbackGroup().test_same_callback_as_all_three_types()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_adding_next_tick_twice(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=2)\n            ctx.group.add_next_tick_callback(callback=func, callback_id=make_id())\n            ctx.group.add_next_tick_callback(callback=func, callback_id=make_id())\n        assert 2 == func.count()\nTestCallbackGroup().test_adding_next_tick_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_adding_timeout_twice(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=2)\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                1, callback_id=make_id())\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                2, callback_id=make_id())\n        assert 2 == func.count()\nTestCallbackGroup().test_adding_timeout_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_adding_periodic_twice(self) ->None:\n        with LoopAndGroup() as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=2)\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                3, callback_id=make_id())\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                2, callback_id=make_id())\n        assert 2 == func.count()\nTestCallbackGroup().test_adding_periodic_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_remove_all_callbacks(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            def remove_all():\n                ctx.group.remove_all_callbacks()\n            ctx.group.add_next_tick_callback(callback=remove_all, callback_id=\n                make_id())\n            func = _make_invocation_counter(ctx.io_loop, stop_after=5)\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                2, callback_id=make_id())\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                1, callback_id=make_id())\n            ctx.group.add_next_tick_callback(callback=func, callback_id=make_id())\n        assert 0 == func.count()\nTestCallbackGroup().test_remove_all_callbacks()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_removing_next_tick_twice(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            cb_id = make_id()\n            ctx.group.add_next_tick_callback(callback=func, callback_id=cb_id)\n            ctx.group.remove_next_tick_callback(cb_id)\n            with pytest.raises(ValueError) as exc:\n                ctx.group.remove_next_tick_callback(cb_id)\n        assert 0 == func.count()\n        assert 'twice' in repr(exc.value)\nTestCallbackGroup().test_removing_next_tick_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_removing_timeout_twice(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop)\n            cb_id = make_id()\n            ctx.group.add_timeout_callback(callback=func, timeout_milliseconds=\n                1, callback_id=cb_id)\n            ctx.group.remove_timeout_callback(cb_id)\n            with pytest.raises(ValueError) as exc:\n                ctx.group.remove_timeout_callback(cb_id)\n        assert 0 == func.count()\n        assert 'twice' in repr(exc.value)\nTestCallbackGroup().test_removing_timeout_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_removing_periodic_twice(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            func = _make_invocation_counter(ctx.io_loop, stop_after=5)\n            cb_id = make_id()\n            ctx.group.add_periodic_callback(callback=func, period_milliseconds=\n                1, callback_id=cb_id)\n            ctx.group.remove_periodic_callback(cb_id)\n            with pytest.raises(ValueError) as exc:\n                ctx.group.remove_periodic_callback(cb_id)\n        assert 0 == func.count()\n        assert 'twice' in repr(exc.value)\nTestCallbackGroup().test_removing_periodic_twice()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}, {"test_code": "import pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\ndef run(loop):\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        print('Keyboard interrupt')\nclass LoopAndGroup:\n    def __init__(self, quit_after=None) ->None:\n        self.io_loop = IOLoop()\n        self.io_loop.make_current()\n        self.group = _CallbackGroup(self.io_loop)\n        if quit_after is not None:\n            self.io_loop.call_later(quit_after / 1000.0, lambda : self.\n                io_loop.stop())\n    def __exit__(self, type, value, traceback):\n        run(self.io_loop)\n        self.io_loop.close()\n    def __enter__(self):\n        return self\nclass TestCallbackGroup():\n    def test_adding_next_tick_from_another_thread(self) ->None:\n        with LoopAndGroup(quit_after=15) as ctx:\n            n = 1000\n            func = _make_invocation_counter(ctx.io_loop, stop_after=n)\n            tpe = ThreadPoolExecutor(n)\n            def make_cb(cb):\n                return ctx.group.add_next_tick_callback(cb, callback_id=make_id())\n            list(tpe.map(make_cb, repeat(func, n)))\n        assert n == func.count()\nTestCallbackGroup().test_adding_next_tick_from_another_thread()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/unit/bokeh/server/test_callbacks__server.py"}], "method_code_mask": "from __future__ import annotations\nimport pytest\nfrom concurrent.futures import ThreadPoolExecutor\nfrom itertools import repeat\nfrom tornado.ioloop import IOLoop\nfrom bokeh.util.serialization import make_id\nfrom bokeh.util.tornado import _CallbackGroup\nfrom types import MethodType\n\n\ndef _make_invocation_counter(loop, stop_after=1): [MASK]\n"}
{"model_name": "std", "repository": "bokeh", "full_method_name": "ls_modules", "method_path": "../srcdata/Visualization/bokeh/tests/support/util/project.py", "response": "from __future__ import annotations\nimport logging\nfrom pathlib import Path\nfrom subprocess import run\nfrom typing import Sequence\ndef ls_files(*patterns: str) ->list[str]:\n    proc = run(['git', 'ls-files', '--', *patterns], capture_output=True)\n    return proc.stdout.decode('utf-8').split('\\n')\ndef ls_modules(*, skip_prefixes: Sequence[str]=[], skip_main: bool=True\n    ) ->list[str]:\n    modules: list[str] = []\n    files = ls_files('src/bokeh/**.py')\n    for file in files:\n        if not file:\n            continue\n        if file.endswith('__main__.py') and skip_main:\n            continue\n        module = file.strip('src/').replace('/', '.').replace('.py', ''\n            ).replace('.__init__', '')\n        if any(module.startswith(prefix) for prefix in skip_prefixes):\n            continue\n        modules.append(module)\n    return modules", "test_code_list": [{"test_code": "import pytest\nfrom subprocess import PIPE\nfrom subprocess import Popen\nfrom sys import executable as python\nfrom typing import Sequence\nSKIP: Sequence[str] = []\ndef test_python_execution_with_OO() ->None:\n    \"\"\" Running python with -OO will discard docstrings (__doc__ is None)\n    which can cause problems if docstrings are naively formatted.\n    This test ensures that the all modules are importable, even with -OO set.\n    If you encounter a new problem with docstrings being formatted, try\n    using format_docstring.\n    \"\"\"\n    imports = [f'import {mod}' for mod in ls_modules(skip_prefixes=SKIP)]\n    proc = Popen([python, '-OO', '-'], stdout=PIPE, stdin=PIPE)\n    proc.communicate('\\n'.join(imports).encode('utf-8'))\n    proc.wait()\n    assert proc.returncode == 0, 'Execution with -OO failed'\ntest_python_execution_with_OO()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Visualization/bokeh/tests/codebase/test_python_execution_with_OO.py"}], "method_code_mask": "from __future__ import annotations\nimport logging\nfrom pathlib import Path\nfrom subprocess import run\nfrom typing import Sequence\n\n\ndef ls_files(*patterns: str) ->list[str]:\n    proc = run(['git', 'ls-files', '--', *patterns], capture_output=True)\n    return proc.stdout.decode('utf-8').split('\\n')\n\n\ndef ls_modules(*, skip_prefixes: Sequence[str]=[], skip_main: bool=True\n    ) ->list[str]: [MASK]\n"}
