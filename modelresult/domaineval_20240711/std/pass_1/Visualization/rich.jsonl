{"model_name": "std", "repository": "rich", "full_method_name": "get_fileno", "method_path": "../srcdata/Visualization/rich/rich/_fileno.py", "response": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\ndef get_fileno(file_like: IO[str]) ->(int | None):\n    \"\"\"Get fileno() from a file, accounting for poorly implemented file-like objects.\n\n    Args:\n        file_like (IO): A file-like object.\n\n    Returns:\n        int | None: The result of fileno if available, or None if operation failed.\n    \"\"\"\n    fileno: Callable[[], int] | None = getattr(file_like, 'fileno', None)\n    if fileno is not None:\n        try:\n            return fileno()\n        except Exception:\n            return None\n    return None", "test_code_list": [{"test_code": "def test_get_fileno():\n\n\n    class FileLike:\n\n        def fileno(self) ->int:\n            return 123\n    assert get_fileno(FileLike()) == 123\n\ntest_get_fileno()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}, {"test_code": "def test_get_fileno_missing():\n\n\n    class FileLike:\n        pass\n    assert get_fileno(FileLike()) is None\n\ntest_get_fileno_missing()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}, {"test_code": "def test_get_fileno_broken():\n\n\n    class FileLike:\n\n        def fileno(self) ->int:\n            1 / 0\n            return 123\n    assert get_fileno(FileLike()) is None\n\ntest_get_fileno_broken()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_getfileno.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import IO\nfrom typing import Callable\n\n\ndef get_fileno(file_like: IO[str]) ->(int | None): [MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "loop_first", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first value.\"\"\"\n    iter_values = iter(values)\n    try:\n        value = next(iter_values)\n    except StopIteration:\n        return\n    yield True, value\n    for value in iter_values:\n        yield False, value", "test_code_list": [{"test_code": "def test_loop_first():\n    assert list(loop_first([])) == []\n    iterable = loop_first(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (True, 'apples')\n    assert next(iterable) == (False, 'oranges')\n    assert next(iterable) == (False, 'pears')\n    assert next(iterable) == (False, 'lemons')\n\ntest_loop_first()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "loop_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value", "test_code_list": [{"test_code": "def test_loop_last():\n    assert list(loop_last([])) == []\n    iterable = loop_last(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (False, 'apples')\n    assert next(iterable) == (False, 'oranges')\n    assert next(iterable) == (False, 'pears')\n    assert next(iterable) == (True, 'lemons')\n\ntest_loop_last()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_last(values: Iterable[T]) ->Iterable[Tuple[bool, T]]: [MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "loop_first_last", "method_path": "../srcdata/Visualization/rich/rich/_loop.py", "response": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first and last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    first = True\n    for value in iter_values:\n        yield first, False, previous_value\n        first = False\n        previous_value = value\n    yield first, True, previous_value", "test_code_list": [{"test_code": "def test_loop_first_last():\n    assert list(loop_first_last([])) == []\n    iterable = loop_first_last(['apples', 'oranges', 'pears', 'lemons'])\n    assert next(iterable) == (True, False, 'apples')\n    assert next(iterable) == (False, False, 'oranges')\n    assert next(iterable) == (False, False, 'pears')\n    assert next(iterable) == (False, True, 'lemons')\n\ntest_loop_first_last()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_tools.py"}], "method_code_mask": "from typing import Iterable\nfrom typing import Tuple\nfrom typing import TypeVar\nT = TypeVar('T')\n\n\ndef loop_first_last(values: Iterable[T]) ->Iterable[Tuple[bool, bool, T]]: [M\n    ASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "escape", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "response": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n    Args:\n        markup (str): Content to be inserted in to markup.\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n    def escape_backslashes(match: Match[str]) ->str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f'{backslashes}{backslashes}\\\\{text}'\n    markup = _escape(escape_backslashes, markup)\n    if markup.endswith('\\\\') and not markup.endswith('\\\\\\\\'):\n        return markup + '\\\\'\n    return markup", "test_code_list": [{"test_code": "import pytest\ndef test_escape():\n    assert escape('foo[bar]') == 'foo\\\\[bar]'\n    assert escape('foo\\\\[bar]') == 'foo\\\\\\\\\\\\[bar]'\n    assert escape('[5]') == '[5]'\n    assert escape('\\\\[5]') == '\\\\[5]'\n    assert escape('[@foo]') == '\\\\[@foo]'\n    assert escape('[@]') == '\\\\[@]'\n    assert escape('[nil, [nil]]') == '[nil, \\\\[nil]]'\n\ntest_escape()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}], "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\n_ReStringMatch = Match[str]\n_ReSubCallable = Callable[[_ReStringMatch], str]\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]\n\n\ndef escape(markup: str, _escape: _EscapeSubMethod=re.compile(\n    '(\\\\\\\\*)(\\\\[[a-z#/@][^[]*?])').sub) ->str: [MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "_parse", "method_path": "../srcdata/Visualization/rich/rich/markup.py", "response": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n    Args:\n        markup (str): A string containing console markup\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                yield start, '\\\\' * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                yield start, full_text[len(escapes):], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition('=')\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None", "test_code_list": [{"test_code": "import pytest\ndef test_parse():\n    result = list(_parse('[foo]hello[/foo][bar]world[/]\\\\[escaped]'))\n    expected = [(0, None, Tag(name='foo', parameters=None)), (10, 'hello',\n        None), (10, None, Tag(name='/foo', parameters=None)), (16, None,\n        Tag(name='bar', parameters=None)), (26, 'world', None), (26, None,\n        Tag(name='/', parameters=None)), (29, '[escaped]', None)]\n    print(repr(result))\n    assert result == expected\n\ntest_parse()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}, {"test_code": "import pytest\ndef test_parse_link():\n    result = list(_parse('[link=foo]bar[/link]'))\n    expected = [(0, None, Tag(name='link', parameters='foo')), (13, 'bar',\n        None), (13, None, Tag(name='/link', parameters=None))]\n    assert result == expected\n\ntest_parse_link()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_markup.py"}], "method_code_mask": "import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Match\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\nfrom typing import Union\nRE_TAGS = re.compile('((\\\\\\\\*)\\\\[([a-z#/@][^[]*?)])', re.VERBOSE)\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self) ->str:\n        return (self.name if self.parameters is None else\n            f'{self.name} {self.parameters}')\n\n    @property\n    def markup(self) ->str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (f'[{self.name}]' if self.parameters is None else\n            f'[{self.name}={self.parameters}]')\n\n\ndef _parse(markup: str) ->Iterable[Tuple[int, Optional[str], Optional[Tag]]]: [\n    MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "decimal", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "response": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str:\n    \"\"\"Convert a filesize in to a string (powers of 1000, SI prefixes).\n    In this convention, ``1000 B = 1 kB``.\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = \" \").\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n    Example:\n        >>> filesize.decimal(30000)\n        '30.0 kB'\n        >>> filesize.decimal(30000, precision=2, separator=\"\")\n        '30.00kB'\n    \"\"\"\n    return _to_str(size, ('kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'),\n        1000, precision=precision, separator=separator)", "test_code_list": [{"test_code": "def test_traditional():\n    assert decimal(0) == '0 bytes'\n    assert decimal(1) == '1 byte'\n    assert decimal(2) == '2 bytes'\n    assert decimal(1000) == '1.0 kB'\n    assert decimal(1.5 * 1000 * 1000) == '1.5 MB'\n    assert decimal(0, precision=2) == '0 bytes'\n    assert decimal(1111, precision=0) == '1 kB'\n    assert decimal(1111, precision=1) == '1.1 kB'\n    assert decimal(1111, precision=2) == '1.11 kB'\n    assert decimal(1111, separator='') == '1.1kB'\n\ntest_traditional()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_filesize.py"}], "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef _to_str(size: int, suffixes: Iterable[str], base: int, *, precision:\n    Optional[int]=1, separator: Optional[str]=' ') ->str:\n    if size == 1:\n        return '1 byte'\n    elif size < base:\n        return f'{size:,} bytes'\n    for i, suffix in enumerate(suffixes, 2):\n        unit = base ** i\n        if size < unit:\n            break\n    return '{:,.{precision}f}{separator}{}'.format(base * size / unit,\n        suffix, precision=precision, separator=separator)\n\n\ndef decimal(size: int, *, precision: Optional[int]=1, separator: Optional[\n    str]=' ') ->str: [MASK]\n"}
{"model_name": "std", "repository": "rich", "full_method_name": "pick_unit_and_suffix", "method_path": "../srcdata/Visualization/rich/rich/filesize.py", "response": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]:\n    \"\"\"Pick a suffix and base for the given size.\"\"\"\n    for i, suffix in enumerate(suffixes):\n        unit = base ** i\n        if size < unit * base:\n            break\n    return unit, suffix", "test_code_list": [{"test_code": "def test_pick_unit_and_suffix():\n    units = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n    assert pick_unit_and_suffix(50, units, 1024) == (1, 'bytes')\n    assert pick_unit_and_suffix(2048, units, 1024) == (1024, 'KB')\n\ntest_pick_unit_and_suffix()\n", "code_start": "", "test_path": "../srcdata/Visualization/rich/tests/test_filesize.py"}], "method_code_mask": "from typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import Tuple\n\n\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) ->Tuple[\n    int, str]: [MASK]\n"}
