{"model_name": "std", "repository": "plotly.py", "full_method_name": "get_non_empty_subplots", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py", "response": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\ndef get_non_empty_subplots(fig, selector):\n    gr = fig._validate_get_grid_ref()\n    nrows = len(gr)\n    ncols = len(gr[0])\n    sp_addresses = product(range(nrows), range(ncols))\n    ret = list(filter(lambda sp: fig._subplot_not_empty(*\n        translate_layout_keys(sp.layout_keys), selector=selector), [gr[r][c\n        ][0] for r, c in sp_addresses]))\n    return ret", "test_code_list": [{"test_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef all_combos(it):\n    return list(reduce(lambda a, b: a + b, [list(combinations(it, r)) for r in\n        range(1, len(it))], []))\ndef test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5\n        ), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert len(selectors) == len(subplot_combos)\n    for s, spc in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert sps == spc\ntest_choose_correct_non_empty_subplots()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py"}], "method_code_mask": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\n\n\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\n\n\ndef get_non_empty_subplots(fig, selector): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "all_combos", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py", "response": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef all_combos(it):\n    return list(reduce(lambda a, b: a + b, [list(combinations(it, r)) for r in\n        range(1, len(it))], []))", "test_code_list": [{"test_code": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\ndef translate_layout_keys(t):\n    xr, yr = t\n    xr = xr.replace('axis', '')\n    yr = yr.replace('axis', '')\n    return xr, yr\ndef get_non_empty_subplots(fig, selector):\n    gr = fig._validate_get_grid_ref()\n    nrows = len(gr)\n    ncols = len(gr[0])\n    sp_addresses = product(range(nrows), range(ncols))\n    ret = list(filter(lambda sp: fig._subplot_not_empty(*\n        translate_layout_keys(sp.layout_keys), selector=selector), [gr[r][c\n        ][0] for r, c in sp_addresses]))\n    return ret\ndef test_choose_correct_non_empty_subplots():\n    fig = make_subplots(2, 2)\n    fig.add_trace(go.Scatter(x=[1, 2], y=[3, 4]), row=1, col=1)\n    fig.add_shape(dict(type='rect', x0=1, x1=2, y0=3, y1=4), row=1, col=2)\n    fig.add_annotation(dict(text='A', x=1, y=2), row=2, col=1)\n    fig.add_layout_image(dict(source='test', x=1, y=2, sizex=0.5, sizey=0.5\n        ), row=2, col=2)\n    all_subplots = get_non_empty_subplots(fig, 'all')\n    selectors = all_combos(['traces', 'shapes', 'annotations', 'images'])\n    subplot_combos = all_combos(all_subplots)\n    assert len(selectors) == len(subplot_combos)\n    for s, spc in zip(selectors, subplot_combos):\n        sps = tuple(get_non_empty_subplots(fig, s))\n        assert sps == spc\ntest_choose_correct_non_empty_subplots()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_subplots/test_find_nonempty_subplots.py"}], "method_code_mask": "import pytest\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom itertools import combinations\nfrom itertools import product\nfrom functools import reduce\n\n\ndef all_combos(it): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "return_prop_descriptions", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py", "response": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\ndef return_prop_descriptions(prop_descrip_text):\n    raw_matches = re.findall(\"\"\"\n        [a-z]+|        [a-z]+\n\"\"\",\n        prop_descrip_text)\n    matches = []\n    for r in raw_matches:\n        r = r.replace(' ', '')\n        r = r.replace('\\n', '')\n        matches.append(r)\n    return matches", "test_code_list": [{"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    @pytest.mark.nodev\n    def test_deeply_nested_layout_attributes(self):\n        frames = Frame\n        frames.layout = [Layout()]\n        frames.layout[0].xaxis.showexponent = 'all'\n        prop_descrip_text = frames.layout[0].font._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        self.assertEqual(set(matches), {'color', 'family', 'size', 'weight',\n            'variant', 'style'})\n    \nFramesTest().test_deeply_nested_layout_attributes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}, {"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    def test_deeply_nested_data_attributes(self):\n        frames = Frame\n        frames.data = [Bar()]\n        frames.data[0].marker.color = 'red'\n        prop_descrip_text = frames.data[0].marker.line._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        matches = [m for m in matches if m != 'cmid']\n        self.assertEqual(set(matches), {'colorsrc', 'autocolorscale', 'cmin',\n            'colorscale', 'color', 'reversescale', 'width', 'cauto', 'widthsrc',\n            'cmax', 'coloraxis'})\n    \nFramesTest().test_deeply_nested_data_attributes()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}, {"test_code": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\nclass FramesTest(TestCase):\n    def test_frame_only_attrs(self):\n        frames = Frame\n        frames.frame = [Frame()]\n        prop_descrip_text = frames.frame[0]._prop_descriptions\n        matches = return_prop_descriptions(prop_descrip_text)\n        self.assertEqual(set(matches), {'group', 'name', 'data', 'layout',\n            'baseframe', 'traces'})\n    \nFramesTest().test_frame_only_attrs()\n", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_frames.py"}], "method_code_mask": "from unittest import TestCase\nfrom plotly.graph_objs import Bar\nfrom plotly.graph_objs import Frames\nfrom plotly.graph_objs import Frame\nfrom plotly.graph_objs import Layout\nimport pytest\nimport re\n\n\ndef return_prop_descriptions(prop_descrip_text): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "build_invalid_fig", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_validate.py", "response": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\ndef build_invalid_fig():\n    return dict(data=[{'type': 'bar', 'y': 'not_a_list', 'bogus': 23}],\n        layout_title_text='valid title', layout_colorway='not a dict')", "test_code_list": [{"test_code": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\nexpected_invalid_dict = dict(data=[{'type': 'bar', 'y': 'not_a_list',\n    'bogus': 23}], layout={'title': {'text': 'valid title'}, 'colorway':\n    'not a dict'})\ndef test_validate_false():\n    template = pio.templates.default\n    try:\n        pio.templates.default = None\n        fig = go.Figure(_validate=False, **build_invalid_fig())\n        assert json.loads(fig.to_json()) == expected_invalid_dict\n        with pytest.raises(ValueError):\n            go.Figure(_validate=True, **build_invalid_fig())\n    finally:\n        pio.templates.default = template\ntest_validate_false()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_core/test_graph_objs/test_validate.py"}], "method_code_mask": "import plotly.graph_objs as go\nimport json\nimport pytest\nimport plotly.io as pio\n\n\ndef build_invalid_fig(): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "mocked_scope", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "response": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope", "test_code_list": [{"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_kaleido_engine_to_image():\n    with mocked_scope() as scope:\n        pio.to_image(fig, engine='kaleido', validate=False)\n    scope.transform.assert_called_with(fig, format=None, width=None, height\n        =None, scale=None)\ntest_kaleido_engine_to_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n    These mocks should be passed as the `file=` argument to `write_image()`.\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path\ndef test_kaleido_engine_write_image():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, engine='kaleido', validate\n                =False)\n        scope.transform.assert_called_with(fig, format=writeable_mock.\n            expected_format, width=None, height=None, scale=None)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_kaleido_engine_to_image_kwargs():\n    with mocked_scope() as scope:\n        pio.to_image(fig, format='pdf', width=700, height=600, scale=2,\n            engine='kaleido', validate=False)\n    scope.transform.assert_called_with(fig, format='pdf', width=700, height\n        =600, scale=2)\ntest_kaleido_engine_to_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n    These mocks should be passed as the `file=` argument to `write_image()`.\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path\ndef test_kaleido_engine_write_image_kwargs():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, format='jpg', width=700,\n                height=600, scale=2, engine='kaleido', validate=False)\n        scope.transform.assert_called_with(fig, format='jpg', width=700,\n            height=600, scale=2)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}], "method_code_mask": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\n\n@contextmanager\ndef mocked_scope(): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "make_writeable_mocks", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py", "response": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\ndef make_writeable_mocks():\n    \"\"\"Produce some mocks which we will use for testing the `write_image()` function.\n\n    These mocks should be passed as the `file=` argument to `write_image()`.\n\n    The tests should verify that the method specified in the `active_write_function`\n    attribute is called once, and that scope.transform is called with the `format=`\n    argument specified by the `.expected_format` attribute.\n\n    In total we provide two mocks: one for a writable file descriptor, and other for a\n    pathlib.Path object.\n    \"\"\"\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    mock_file_descriptor.active_write_function = mock_file_descriptor.write\n    mock_file_descriptor.expected_format = None\n    mock_pathlib_path = Mock(spec=Path)\n    del mock_pathlib_path.write\n    mock_pathlib_path.active_write_function = mock_pathlib_path.write_bytes\n    mock_pathlib_path.suffix = '.png'\n    mock_pathlib_path.expected_format = 'png'\n    return mock_file_descriptor, mock_pathlib_path", "test_code_list": [{"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope\ndef test_kaleido_engine_write_image():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, engine='kaleido', validate\n                =False)\n        scope.transform.assert_called_with(fig, format=writeable_mock.\n            expected_format, width=None, height=None, scale=None)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}, {"test_code": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\n@contextmanager\ndef mocked_scope():\n    scope_mock = Mock()\n    original_scope = pio._kaleido.scope\n    pio._kaleido.scope = scope_mock\n    try:\n        yield scope_mock\n    finally:\n        pio._kaleido.scope = original_scope\ndef test_kaleido_engine_write_image_kwargs():\n    for writeable_mock in make_writeable_mocks():\n        with mocked_scope() as scope:\n            pio.write_image(fig, writeable_mock, format='jpg', width=700,\n                height=600, scale=2, engine='kaleido', validate=False)\n        scope.transform.assert_called_with(fig, format='jpg', width=700,\n            height=600, scale=2)\n        assert writeable_mock.active_write_function.call_count == 1\ntest_kaleido_engine_write_image_kwargs()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_optional/test_kaleido/test_kaleido.py"}], "method_code_mask": "import plotly.io as pio\nimport plotly.io.kaleido\nfrom contextlib import contextmanager\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\n\ndef make_writeable_mocks(): [MASK]\n"}
{"model_name": "std", "repository": "plotly.py", "full_method_name": "replace_div_id", "method_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_io/test_pathlib.py", "response": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\ndef replace_div_id(s):\n    uuid = re.search('<div id=\"([^\"]*)\"', s).groups()[0]\n    return s.replace(uuid, 'XXXX')", "test_code_list": [{"test_code": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\nfig = {'layout': {'title': {'text': 'figure title'}}}\ndef test_write_html():\n    \"\"\"Verify that various methods for producing HTML have equivalent results.\n    The results will not be identical because the div id is pseudorandom. Thus\n    we compare the results after replacing the div id.\n    We test the results of\n    - pio.to_html\n    - pio.write_html with a StringIO buffer\n    - pio.write_html with a mock pathlib Path\n    - pio.write_html with a mock file descriptor\n    \"\"\"\n    html = pio.to_html(fig)\n    sio = StringIO()\n    pio.write_html(fig, sio)\n    sio.seek(0)\n    sio_html = sio.read()\n    assert replace_div_id(html) == replace_div_id(sio_html)\n    mock_pathlib_path = Mock(spec=Path)\n    pio.write_html(fig, mock_pathlib_path)\n    mock_pathlib_path.write_text.assert_called_once()\n    pl_html = mock_pathlib_path.write_text.call_args[0][0]\n    assert replace_div_id(html) == replace_div_id(pl_html)\n    mock_file_descriptor = Mock()\n    del mock_file_descriptor.write_bytes\n    pio.write_html(fig, mock_file_descriptor)\n    mock_file_descriptor.write.assert_called_once()\n    fd_html, = mock_file_descriptor.write.call_args[0]\n    assert replace_div_id(html) == replace_div_id(fd_html)\ntest_write_html()", "code_start": "", "test_path": "../srcdata/Visualization/plotly.py/packages/python/plotly/plotly/tests/test_io/test_pathlib.py"}], "method_code_mask": "from unittest import mock\nimport plotly.io as pio\nfrom io import StringIO\nfrom pathlib import Path\nimport re\nfrom unittest.mock import Mock\n\n\ndef replace_div_id(s): [MASK]\n"}
