{"model_name": "std", "repository": "tensorboardX", "full_method_name": "_prepare_video", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/utils.py", "response": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\ndef _prepare_video(V):\n    import numpy as np\n    b, t, c, h, w = V.shape\n    if V.dtype == np.uint8:\n        V = np.float32(V) / 255.0\n\n    def is_power2(num):\n        return num != 0 and num & num - 1 == 0\n    if not is_power2(V.shape[0]):\n        len_addition = int(2 ** V.shape[0].bit_length() - V.shape[0])\n        V = np.concatenate((V, np.zeros(shape=(len_addition, t, c, h, w))),\n            axis=0)\n    n_rows = 2 ** ((b.bit_length() - 1) // 2)\n    n_cols = V.shape[0] // n_rows\n    V = np.reshape(V, newshape=(n_rows, n_cols, t, c, h, w))\n    V = np.transpose(V, axes=(2, 0, 4, 1, 5, 3))\n    V = np.reshape(V, newshape=(t, n_rows * h, n_cols * w, c))\n    return V", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport unittest\n\nclass UtilsTest(unittest.TestCase):\n    def test_prepare_video(self):\n        np.random.seed(1)\n        V_before = np.random.random((4, 10, 3, 20, 20))\n        V_after = _prepare_video(np.copy(V_before))\n        V_before = np.swapaxes(V_before, 0, 1)\n        V_before = np.reshape(V_before, newshape=(10, -1))\n        V_after = np.reshape(V_after, newshape=(10, -1))\n        np.testing.assert_array_almost_equal(np.sum(V_before, axis=1), np.sum(\n            V_after, axis=1))\n    \nUtilsTest().test_prepare_video()\n", "code_start": "", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_utils.py"}], "method_code_mask": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.backends.backend_agg as plt_backend_agg\n\n\ndef _prepare_video(V): [MASK]\n"}
{"model_name": "std", "repository": "tensorboardX", "full_method_name": "make_np", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/x2num.py", "response": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\ndef make_np(x):\n    if isinstance(x, list):\n        return check_nan(np.array(x))\n    if isinstance(x, np.ndarray):\n        return check_nan(x)\n    if isinstance(x, str):\n        return check_nan(prepare_caffe2(x))\n    if np.isscalar(x):\n        return check_nan(np.array([x]))\n    if 'torch' in str(type(x)):\n        return check_nan(prepare_pytorch(x))\n    if 'chainer' in str(type(x)):\n        return check_nan(prepare_chainer(x))\n    if 'mxnet' in str(type(x)):\n        return check_nan(prepare_mxnet(x))\n    if 'jax' in str(type(x)):\n        return check_nan(np.array(x))\n    raise NotImplementedError(\n        'Got {}, but expected numpy array or torch tensor.'.format(type(x)))", "test_code_list": [{"test_code": "import torch\nimport numpy as np\nimport unittest\n\nclass PyTorchNumpyTest(unittest.TestCase):\n    def test_pytorch_np(self):\n        tensors = [torch.rand(3, 10, 10), torch.rand(1), torch.rand(1, 2, 3, 4, 5)]\n        for tensor in tensors:\n            assert isinstance(make_np(tensor), np.ndarray)\n            if torch.cuda.device_count() > 0:\n                assert isinstance(make_np(tensor.cuda()), np.ndarray)\n            assert isinstance(make_np(torch.autograd.Variable(tensor)),\n                np.ndarray)\n            if torch.cuda.device_count() > 0:\n                assert isinstance(make_np(torch.autograd.Variable(tensor)\n                    .cuda()), np.ndarray)\n        assert isinstance(make_np(0), np.ndarray)\n        assert isinstance(make_np(0.1), np.ndarray)\n    \nPyTorchNumpyTest().test_pytorch_np()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_pytorch_np.py"}, {"test_code": "import numpy as np\nimport unittest\n\nclass NumpyTest(unittest.TestCase):\n    def test_scalar(self):\n        res = make_np(1.1)\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(1 << 64 - 1)\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(np.float16(1.00000087))\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n        if hasattr(np, 'float128'):\n            res = make_np(np.float128(1.00008 + 9))\n            assert isinstance(res, np.ndarray) and res.shape == (1,)\n        res = make_np(np.int64(100000000000))\n        assert isinstance(res, np.ndarray) and res.shape == (1,)\n    \nNumpyTest().test_scalar()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_numpy.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport numpy as np\nimport torch\n\n\ndef prepare_pytorch(x):\n    import torch\n    if isinstance(x, torch.autograd.Variable):\n        x = x.data\n    x = x.cpu().numpy()\n    return x\n\n\ndef check_nan(array):\n    tmp = np.sum(array)\n    if np.isnan(tmp) or np.isinf(tmp):\n        logger.warning('NaN or Inf found in input tensor.')\n    return array\n\n\ndef make_np(x): [MASK]\n"}
{"model_name": "std", "repository": "tensorboardX", "full_method_name": "make_valid_tf_name", "method_path": "../srcdata/Visualization/tensorboardX/tensorboardX/record_writer.py", "response": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\ndef make_valid_tf_name(name):\n    if not _VALID_OP_NAME_START.match(name):\n        name = '.' + name\n    return '_'.join(_VALID_OP_NAME_PART.findall(name))", "test_code_list": [{"test_code": "import unittest\nimport os\nimport boto3\nimport shutil\n\nclass RecordWriterTest(unittest.TestCase):\n    def test_make_valid_tf_name(self):\n        newname = make_valid_tf_name('$ave/&sound')\n        assert newname == '._ave/_sound'\n    \nRecordWriterTest().test_make_valid_tf_name()\n", "code_start": "", "test_path": "../srcdata/Visualization/tensorboardX/tests/test_record_writer.py"}], "method_code_mask": "import os\nimport copy\nimport io\nimport os.path\nimport re\nimport struct\nimport boto3\n_VALID_OP_NAME_PART = re.compile('[A-Za-z0-9_.\\\\-/]+')\n_VALID_OP_NAME_START = re.compile('^[A-Za-z0-9.]')\n\n\ndef make_valid_tf_name(name): [MASK]\n"}
