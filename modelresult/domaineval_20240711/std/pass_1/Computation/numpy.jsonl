{"model_name": "std", "repository": "numpy", "full_method_name": "get_rtol", "method_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py", "response": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\ndef get_rtol(dtype):\n    if dtype in (single, csingle):\n        return 1e-05\n    else:\n        return 1e-11", "test_code_list": [{"test_code": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\nclass TestEigvalsh():\n\tdef test_UPLO(self):\n\t    Klo = np.array([[0, 0], [1, 0]], dtype=np.double)\n\t    Kup = np.array([[0, 1], [0, 0]], dtype=np.double)\n\t    tgt = np.array([-1, 1], dtype=np.double)\n\t    rtol = get_rtol(np.double)\n\t    w = np.linalg.eigvalsh(Klo)\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Klo, UPLO='L')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Klo, UPLO='l')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Kup, UPLO='U')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w = np.linalg.eigvalsh(Kup, UPLO='u')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t\nTestEigvalsh().test_UPLO()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py"}, {"test_code": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\nclass TestEigh():\n\tdef test_UPLO(self):\n\t    Klo = np.array([[0, 0], [1, 0]], dtype=np.double)\n\t    Kup = np.array([[0, 1], [0, 0]], dtype=np.double)\n\t    tgt = np.array([-1, 1], dtype=np.double)\n\t    rtol = get_rtol(np.double)\n\t    w, v = np.linalg.eigh(Klo)\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Klo, UPLO='L')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Klo, UPLO='l')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Kup, UPLO='U')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t    w, v = np.linalg.eigh(Kup, UPLO='u')\n\t    assert_allclose(w, tgt, rtol=rtol)\n\t\nTestEigh().test_UPLO()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/linalg/tests/test_linalg.py"}], "method_code_mask": "import os\nimport sys\nimport itertools\nimport traceback\nimport textwrap\nimport subprocess\nimport pytest\nimport numpy as np\nfrom numpy import array\nfrom numpy import single\nfrom numpy import double\nfrom numpy import csingle\nfrom numpy import cdouble\nfrom numpy import dot\nfrom numpy import identity\nfrom numpy import matmul\nfrom numpy import multiply\nfrom numpy import atleast_2d\nfrom numpy import inf\nfrom numpy import asarray\nfrom numpy import linalg\nfrom numpy.linalg import matrix_power\nfrom numpy.linalg import norm\nfrom numpy.linalg import matrix_rank\nfrom numpy.linalg import multi_dot\nfrom numpy.linalg import LinAlgError\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import HAS_LAPACK64\nimport numpy.linalg.lapack_lite\nimport resource\n\n\ndef get_rtol(dtype): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "allequal", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef allequal(a, b, fill_value=True):\n    \"\"\"\n    Return True if all entries of a and b are equal, using\n    fill_value as a truth value where either or both are masked.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    fill_value : bool, optional\n        Whether masked values in a or b are considered equal (True) or not\n        (False).\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance, False otherwise. If either array contains NaN,\n        then False is returned.\n\n    See Also\n    --------\n    all, any\n    numpy.ma.allclose\n\n    Examples\n    --------\n    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n    >>> a\n    masked_array(data=[10000000000.0, 1e-07, --],\n                 mask=[False, False,  True],\n           fill_value=1e+20)\n\n    >>> b = np.array([1e10, 1e-7, -42.0])\n    >>> b\n    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n    >>> np.ma.allequal(a, b, fill_value=False)\n    False\n    >>> np.ma.allequal(a, b)\n    True\n\n    \"\"\"\n    m = mask_or(getmask(a), getmask(b))\n    if m is nomask:\n        x = getdata(a)\n        y = getdata(b)\n        d = umath.equal(x, y)\n        return d.all()\n    elif fill_value:\n        x = getdata(a)\n        y = getdata(b)\n        d = umath.equal(x, y)\n        dm = array(d, mask=m, copy=False)\n        return dm.filled(True).all(None)\n    else:\n        return False", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_raises\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import log\nfrom numpy.ma.core import add\nfrom numpy.ma.core import hypot\nfrom numpy.ma.core import divide\nfrom numpy.ma.extras import mr_\n\nclass TestMaskedMatrix():\n\tdef test_matrix_indexing(self):\n\t    x1 = np.matrix([[1, 2, 3], [4, 3, 2]])\n\t    x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])\n\t    x3 = masked_array(x1, mask=[[0, 1, 0], [1, 0, 0]])\n\t    x4 = masked_array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(type(x2[1, 0]) is type(x1[1, 0]))\n\t    assert_(x1[1, 0] == x2[1, 0])\n\t    assert_(x2[1, 1] is masked)\n\t    assert_equal(x1[0, 2], x2[0, 2])\n\t    assert_equal(x1[0, 1:], x2[0, 1:])\n\t    assert_equal(x1[:, 2], x2[:, 2])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[0, 2] = 9\n\t    x2[0, 2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[0, 1:] = 99\n\t    x2[0, 1:] = 99\n\t    assert_equal(x1, x2)\n\t    x2[0, 1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, 1:] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, :] = x1[0, :]\n\t    x2[0, 1] = masked\n\t    assert_(allequal(getmask(x2), np.array([[0, 1, 0], [0, 1, 0]])))\n\t    x3[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x3)[1], masked_array([1, 1, 0])))\n\t    assert_(allequal(getmask(x3[1]), masked_array([1, 1, 0])))\n\t    x4[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x4[1]), masked_array([1, 1, 0])))\n\t    assert_(allequal(x4[1], masked_array([1, 2, 3])))\n\t    x1 = np.matrix(np.arange(5) * 1.0)\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(masked_array([0, 0, 0, 1, 0], dtype=MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t\nTestMaskedMatrix().test_matrix_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/matrixlib/tests/test_masked_matrix.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef allequal(a, b, fill_value=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_values", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True):\n    \"\"\"\n    Mask using floating point equality.\n\n    Return a MaskedArray, masked where the data in array `x` are approximately\n    equal to `value`, determined using `isclose`. The default tolerances for\n    `masked_values` are the same as those for `isclose`.\n\n    For integer types, exact equality is used, in the same way as\n    `masked_equal`.\n\n    The fill_value is set to `value` and the mask is set to ``nomask`` if\n    possible.\n\n    Parameters\n    ----------\n    x : array_like\n        Array to mask.\n    value : float\n        Masking value.\n    rtol, atol : float, optional\n        Tolerance parameters passed on to `isclose`\n    copy : bool, optional\n        Whether to return a copy of `x`.\n    shrink : bool, optional\n        Whether to collapse a mask full of False to ``nomask``.\n\n    Returns\n    -------\n    result : MaskedArray\n        The result of masking `x` where approximately equal to `value`.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n    masked_equal : Mask where equal to a given value (integers).\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = np.array([1, 1.1, 2, 1.1, 3])\n    >>> ma.masked_values(x, 1.1)\n    masked_array(data=[1.0, --, 2.0, --, 3.0],\n                 mask=[False,  True, False,  True, False],\n           fill_value=1.1)\n\n    Note that `mask` is set to ``nomask`` if possible.\n\n    >>> ma.masked_values(x, 2.1)\n    masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n                 mask=False,\n           fill_value=2.1)\n\n    Unlike `masked_equal`, `masked_values` can perform approximate equalities.\n\n    >>> ma.masked_values(x, 2.1, atol=1e-1)\n    masked_array(data=[1.0, 1.1, --, 1.1, 3.0],\n                 mask=[False, False,  True, False, False],\n           fill_value=2.1)\n\n    \"\"\"\n    xnew = filled(x, value)\n    if np.issubdtype(xnew.dtype, np.floating):\n        mask = np.isclose(xnew, value, atol=atol, rtol=rtol)\n    else:\n        mask = umath.equal(xnew, value)\n    ret = masked_array(xnew, mask=mask, copy=copy, fill_value=value)\n    if shrink:\n        ret.shrink_mask()\n    return ret", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_raises\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import log\nfrom numpy.ma.core import add\nfrom numpy.ma.core import hypot\nfrom numpy.ma.core import divide\nfrom numpy.ma.extras import mr_\n\nclass TestMaskedMatrix():\n\tdef test_matrix_indexing(self):\n\t    x1 = np.matrix([[1, 2, 3], [4, 3, 2]])\n\t    x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])\n\t    x3 = masked_array(x1, mask=[[0, 1, 0], [1, 0, 0]])\n\t    x4 = masked_array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(type(x2[1, 0]) is type(x1[1, 0]))\n\t    assert_(x1[1, 0] == x2[1, 0])\n\t    assert_(x2[1, 1] is masked)\n\t    assert_equal(x1[0, 2], x2[0, 2])\n\t    assert_equal(x1[0, 1:], x2[0, 1:])\n\t    assert_equal(x1[:, 2], x2[:, 2])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[0, 2] = 9\n\t    x2[0, 2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[0, 1:] = 99\n\t    x2[0, 1:] = 99\n\t    assert_equal(x1, x2)\n\t    x2[0, 1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, 1:] = masked\n\t    assert_equal(x1, x2)\n\t    x2[0, :] = x1[0, :]\n\t    x2[0, 1] = masked\n\t    assert_(allequal(getmask(x2), np.array([[0, 1, 0], [0, 1, 0]])))\n\t    x3[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x3)[1], masked_array([1, 1, 0])))\n\t    assert_(allequal(getmask(x3[1]), masked_array([1, 1, 0])))\n\t    x4[1, :] = masked_array([1, 2, 3], [1, 1, 0])\n\t    assert_(allequal(getmask(x4[1]), masked_array([1, 1, 0])))\n\t    assert_(allequal(x4[1], masked_array([1, 2, 3])))\n\t    x1 = np.matrix(np.arange(5) * 1.0)\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(masked_array([0, 0, 0, 1, 0], dtype=MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t\nTestMaskedMatrix().test_matrix_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/matrixlib/tests/test_masked_matrix.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedWhereAliases():\n\tdef test_masked_values(self):\n\t    res = masked_values(np.array([-32768.0]), np.int16(-32768))\n\t    assert_equal(res.mask, [True])\n\t    res = masked_values(np.inf, np.inf)\n\t    assert_equal(res.mask, True)\n\t    res = np.ma.masked_values(np.inf, -np.inf)\n\t    assert_equal(res.mask, False)\n\t    res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=True)\n\t    assert_(res.mask is np.ma.nomask)\n\t    res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=False)\n\t    assert_equal(res.mask, [False] * 4)\n\t\nTestMaskedWhereAliases().test_masked_values()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True): [M\n    ASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "build_err_msg", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "response": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef build_err_msg(arrays, err_msg, header='Items are not equal:', verbose=\n    True, names=('ACTUAL', 'DESIRED'), precision=8):\n    msg = ['\\n' + header]\n    err_msg = str(err_msg)\n    if err_msg:\n        if err_msg.find('\\n') == -1 and len(err_msg) < 79 - len(header):\n            msg = [msg[0] + ' ' + err_msg]\n        else:\n            msg.append(err_msg)\n    if verbose:\n        for i, a in enumerate(arrays):\n            if isinstance(a, ndarray):\n                r_func = partial(array_repr, precision=precision)\n            else:\n                r_func = repr\n            try:\n                r = r_func(a)\n            except Exception as exc:\n                r = f'[repr failed for <{type(a).__name__}>: {exc}]'\n            if r.count('\\n') > 3:\n                r = '\\n'.join(r.splitlines()[:3])\n                r += '...'\n            msg.append(f' {names[i]}: {r}')\n    return '\\n'.join(msg)", "test_code_list": [{"test_code": "import warnings\nimport sys\nimport os\nimport itertools\nimport pytest\nimport weakref\nimport re\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import build_err_msg\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_approx_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import clear_and_catch_warnings\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_string_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import tempdir\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import HAS_REFCOUNT\nimport datetime\n\nclass TestBuildErrorMessage():\n\tdef test_build_err_msg_no_verbose(self):\n\t    x = np.array([1.00001, 2.00002, 3.00003])\n\t    y = np.array([1.00002, 2.00003, 3.00004])\n\t    err_msg = 'There is a mismatch'\n\t    a = build_err_msg([x, y], err_msg, verbose=False)\n\t    b = '\\nItems are not equal: There is a mismatch'\n\t    assert_equal(a, b)\n\t\nTestBuildErrorMessage().test_build_err_msg_no_verbose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/testing/tests/test_utils.py"}], "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef build_err_msg(arrays, err_msg, header='Items are not equal:', verbose=\n    True, names=('ACTUAL', 'DESIRED'), precision=8): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "mask_or", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef mask_or(m1, m2, copy=False, shrink=True):\n    \"\"\"\n    Combine two masks with the ``logical_or`` operator.\n\n    The result may be a view on `m1` or `m2` if the other is `nomask`\n    (i.e. False).\n\n    Parameters\n    ----------\n    m1, m2 : array_like\n        Input masks.\n    copy : bool, optional\n        If copy is False and one of the inputs is `nomask`, return a view\n        of the other input mask. Defaults to False.\n    shrink : bool, optional\n        Whether to shrink the output to `nomask` if all its values are\n        False. Defaults to True.\n\n    Returns\n    -------\n    mask : output mask\n        The result masks values that are masked in either `m1` or `m2`.\n\n    Raises\n    ------\n    ValueError\n        If `m1` and `m2` have different flexible dtypes.\n\n    Examples\n    --------\n    >>> m1 = np.ma.make_mask([0, 1, 1, 0])\n    >>> m2 = np.ma.make_mask([1, 0, 0, 0])\n    >>> np.ma.mask_or(m1, m2)\n    array([ True,  True,  True, False])\n\n    \"\"\"\n    if m1 is nomask or m1 is False:\n        dtype = getattr(m2, 'dtype', MaskType)\n        return make_mask(m2, copy=copy, shrink=shrink, dtype=dtype)\n    if m2 is nomask or m2 is False:\n        dtype = getattr(m1, 'dtype', MaskType)\n        return make_mask(m1, copy=copy, shrink=shrink, dtype=dtype)\n    if m1 is m2 and is_mask(m1):\n        return m1\n    dtype1, dtype2 = getattr(m1, 'dtype', None), getattr(m2, 'dtype', None)\n    if dtype1 != dtype2:\n        raise ValueError(\"Incompatible dtypes '%s'<>'%s'\" % (dtype1, dtype2))\n    if dtype1.names is not None:\n        newmask = np.empty(np.broadcast(m1, m2).shape, dtype1)\n        _recursive_mask_or(m1, m2, newmask)\n        return newmask\n    return make_mask(umath.logical_or(m1, m2), copy=copy, shrink=shrink)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_mask_or(self):\n\t    mtype = [('a', bool), ('b', bool)]\n\t    mask = np.array([(0, 0), (0, 1), (1, 0), (0, 0)], dtype=mtype)\n\t    test = mask_or(mask, nomask)\n\t    assert_equal(test, mask)\n\t    test = mask_or(nomask, mask)\n\t    assert_equal(test, mask)\n\t    test = mask_or(mask, False)\n\t    assert_equal(test, mask)\n\t    other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=mtype)\n\t    test = mask_or(mask, other)\n\t    control = np.array([(0, 1), (0, 1), (1, 1), (0, 1)], dtype=mtype)\n\t    assert_equal(test, control)\n\t    othertype = [('A', bool), ('B', bool)]\n\t    other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=othertype)\n\t    try:\n\t        test = mask_or(mask, other)\n\t    except ValueError:\n\t        pass\n\t    dtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n\t    amask = np.array([(0, (1, 0)), (0, (1, 0))], dtype=dtype)\n\t    bmask = np.array([(1, (0, 1)), (0, (0, 0))], dtype=dtype)\n\t    cntrl = np.array([(1, (1, 1)), (0, (1, 0))], dtype=dtype)\n\t    assert_equal(mask_or(amask, bmask), cntrl)\n\t\nTestMaskedArrayFunctions().test_mask_or()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef mask_or(m1, m2, copy=False, shrink=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "fromarrays", "method_path": "../srcdata/Computation/numpy/numpy/ma/mrecords.py", "response": "from numpy.ma import MAError\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.ma import masked_array\nfrom numpy.ma import getdata\nfrom numpy.ma import getmaskarray\nfrom numpy.ma import filled\nimport numpy.ma as ma\nimport warnings\nimport numpy as np\nfrom numpy import dtype\nfrom numpy import ndarray\nfrom numpy import array as narray\ndef fromarrays(arraylist, dtype=None, shape=None, formats=None, names=None,\n    titles=None, aligned=False, byteorder=None, fill_value=None):\n    \"\"\"\n    Creates a mrecarray from a (flat) list of masked arrays.\n\n    Parameters\n    ----------\n    arraylist : sequence\n        A list of (masked) arrays. Each element of the sequence is first converted\n        to a masked array if needed. If a 2D array is passed as argument, it is\n        processed line by line\n    dtype : {None, dtype}, optional\n        Data type descriptor.\n    shape : {None, integer}, optional\n        Number of records. If None, shape is defined from the shape of the\n        first array in the list.\n    formats : {None, sequence}, optional\n        Sequence of formats for each individual field. If None, the formats will\n        be autodetected by inspecting the fields and selecting the highest dtype\n        possible.\n    names : {None, sequence}, optional\n        Sequence of the names of each field.\n    fill_value : {None, sequence}, optional\n        Sequence of data to be used as filling values.\n\n    Notes\n    -----\n    Lists of tuples should be preferred over lists of lists for faster processing.\n\n    \"\"\"\n    datalist = [getdata(x) for x in arraylist]\n    masklist = [np.atleast_1d(getmaskarray(x)) for x in arraylist]\n    _array = recfromarrays(datalist, dtype=dtype, shape=shape, formats=\n        formats, names=names, titles=titles, aligned=aligned, byteorder=\n        byteorder).view(mrecarray)\n    _array._mask.flat = list(zip(*masklist))\n    if fill_value is not None:\n        _array.fill_value = fill_value\n    return _array", "test_code_list": [{"test_code": "import pickle\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.testing import temppath\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.mrecords import mrecarray\nfrom numpy.ma.mrecords import fromarrays\nfrom numpy.ma.mrecords import fromtextfile\nfrom numpy.ma.mrecords import fromrecords\nfrom numpy.ma.mrecords import addfield\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_equal_records\n\nclass TestMRecords():\n\tdef test_filled(self):\n\t    _a = ma.array([1, 2, 3], mask=[0, 0, 1], dtype=int)\n\t    _b = ma.array([1.1, 2.2, 3.3], mask=[0, 0, 1], dtype=float)\n\t    _c = ma.array(['one', 'two', 'three'], mask=[0, 0, 1], dtype='|S8')\n\t    ddtype = [('a', int), ('b', float), ('c', '|S8')]\n\t    mrec = fromarrays([_a, _b, _c], dtype=ddtype, fill_value=(99999, \n\t        99999.0, 'N/A'))\n\t    mrecfilled = mrec.filled()\n\t    assert_equal(mrecfilled['a'], np.array((1, 2, 99999), dtype=int))\n\t    assert_equal(mrecfilled['b'], np.array((1.1, 2.2, 99999.0), dtype=float))\n\t    assert_equal(mrecfilled['c'], np.array(('one', 'two', 'N/A'), dtype='|S8'))\n\t\nTestMRecords().test_filled()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_mrecords.py"}, {"test_code": "import pickle\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.testing import temppath\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.mrecords import mrecarray\nfrom numpy.ma.mrecords import fromarrays\nfrom numpy.ma.mrecords import fromtextfile\nfrom numpy.ma.mrecords import fromrecords\nfrom numpy.ma.mrecords import addfield\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_equal_records\n\nclass TestMRecords():\n\tdef test_tolist(self):\n\t    _a = ma.array([1, 2, 3], mask=[0, 0, 1], dtype=int)\n\t    _b = ma.array([1.1, 2.2, 3.3], mask=[0, 0, 1], dtype=float)\n\t    _c = ma.array(['one', 'two', 'three'], mask=[1, 0, 0], dtype='|S8')\n\t    ddtype = [('a', int), ('b', float), ('c', '|S8')]\n\t    mrec = fromarrays([_a, _b, _c], dtype=ddtype, fill_value=(99999, \n\t        99999.0, 'N/A'))\n\t    assert_equal(mrec.tolist(), [(1, 1.1, None), (2, 2.2, b'two'), (None,\n\t        None, b'three')])\n\t\nTestMRecords().test_tolist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_mrecords.py"}], "method_code_mask": "from numpy.ma import MAError\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import masked\nfrom numpy.ma import nomask\nfrom numpy.ma import masked_array\nfrom numpy.ma import getdata\nfrom numpy.ma import getmaskarray\nfrom numpy.ma import filled\nimport numpy.ma as ma\nimport warnings\nimport numpy as np\nfrom numpy import dtype\nfrom numpy import ndarray\nfrom numpy import array as narray\n\n\ndef fromarrays(arraylist, dtype=None, shape=None, formats=None, names=None,\n    titles=None, aligned=False, byteorder=None, fill_value=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_all", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef masked_all(shape, dtype=float):\n    \"\"\"\n    Empty masked array with all elements masked.\n\n    Return an empty masked array of the given shape and dtype, where all the\n    data are masked.\n\n    Parameters\n    ----------\n    shape : int or tuple of ints\n        Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``.\n    dtype : dtype, optional\n        Data type of the output.\n\n    Returns\n    -------\n    a : MaskedArray\n        A masked array with all data masked.\n\n    See Also\n    --------\n    masked_all_like : Empty masked array modelled on an existing array.\n\n    Notes\n    -----\n    Unlike other masked array creation functions (e.g. `numpy.ma.zeros`,\n    `numpy.ma.ones`, `numpy.ma.full`), `masked_all` does not initialize the\n    values of the array, and may therefore be marginally faster. However,\n    the values stored in the newly allocated array are arbitrary. For\n    reproducible behavior, be sure to set each element of the array before\n    reading.\n\n    Examples\n    --------\n    >>> np.ma.masked_all((3, 3))\n    masked_array(\n      data=[[--, --, --],\n            [--, --, --],\n            [--, --, --]],\n      mask=[[ True,  True,  True],\n            [ True,  True,  True],\n            [ True,  True,  True]],\n      fill_value=1e+20,\n      dtype=float64)\n\n    The `dtype` parameter defines the underlying data type.\n\n    >>> a = np.ma.masked_all((3, 3))\n    >>> a.dtype\n    dtype('float64')\n    >>> a = np.ma.masked_all((3, 3), dtype=np.int32)\n    >>> a.dtype\n    dtype('int32')\n\n    \"\"\"\n    a = masked_array(np.empty(shape, dtype), mask=np.ones(shape,\n        make_mask_descr(dtype)))\n    return a", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\ndef test_append_masked_array():\n    a = np.ma.masked_equal([1, 2, 3], value=2)\n    b = np.ma.masked_equal([4, 3, 2], value=2)\n    result = np.ma.append(a, b)\n    expected_data = [1, 2, 3, 4, 3, 2]\n    expected_mask = [False, True, False, False, False, True]\n    assert_array_equal(result.data, expected_data)\n    assert_array_equal(result.mask, expected_mask)\n    a = masked_all((2, 2))\n    b = np.ma.ones((3, 1))\n    result = np.ma.append(a, b)\n    expected_data = [1] * 3\n    expected_mask = [True] * 4 + [False] * 3\n    assert_array_equal(result.data[-3], expected_data)\n    assert_array_equal(result.mask, expected_mask)\n    result = np.ma.append(a, b, axis=None)\n    assert_array_equal(result.data[-3], expected_data)\n    assert_array_equal(result.mask, expected_mask)\n\ntest_append_masked_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_object_dtype(self):\n\t    a = masked_all(1, dtype='O')\n\t    assert_equal(a.filled('x')[0], 'x')\n\t\nTestMaskedArray().test_filled_with_object_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedFields():\n\tdef test_setitem(self):\n\t    ndtype = np.dtype([('a', float), ('b', int)])\n\t    ma = np.ma.MaskedArray([(1.0, 1), (2.0, 2)], dtype=ndtype)\n\t    ma['a'][1] = 3.0\n\t    assert_equal(ma['a'], np.array([1.0, 3.0]))\n\t    ma[1]['a'] = 4.0\n\t    assert_equal(ma['a'], np.array([1.0, 4.0]))\n\t    mdtype = np.dtype([('a', bool), ('b', bool)])\n\t    control = np.array([(False, True), (True, True)], dtype=mdtype)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a['a'][0] = 2\n\t    assert_equal(a.mask, control)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a[0]['a'] = 2\n\t    assert_equal(a.mask, control)\n\t    control = np.array([(True, True), (True, True)], dtype=mdtype)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a.harden_mask()\n\t    a['a'][0] = 2\n\t    assert_equal(a.mask, control)\n\t    a = masked_all((2,), dtype=ndtype)\n\t    a.harden_mask()\n\t    a[0]['a'] = 2\n\t    assert_equal(a.mask, control)\n\t\nTestMaskedFields().test_setitem()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all(self):\n\t    test = masked_all((2,), dtype=float)\n\t    control = array([1, 1], mask=[1, 1], dtype=float)\n\t    assert_equal(test, control)\n\t    dt = np.dtype({'names': ['a', 'b'], 'formats': ['f', 'f']})\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(0, 0), (0, 0)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((2, 2), dtype=dt)\n\t    control = array([[(0, 0), (0, 0)], [(0, 0), (0, 0)]], mask=[[(1, 1), (1,\n\t        1)], [(1, 1), (1, 1)]], dtype=dt)\n\t    assert_equal(test, control)\n\t    dt = np.dtype([('a', 'f'), ('b', [('ba', 'f'), ('bb', 'f')])])\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((2,), dtype=dt)\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    assert_equal(test, control)\n\t    test = masked_all((1, 1), dtype=dt)\n\t    control = array([[(1, (1, 1))]], mask=[[(1, (1, 1))]], dtype=dt)\n\t    assert_equal(test, control)\n\t\nTestGeneric().test_masked_all()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_with_object_nested(self):\n\t    my_dtype = np.dtype([('b', ([('c', object)], (1,)))])\n\t    masked_arr = masked_all((1,), my_dtype)\n\t    assert_equal(type(masked_arr['b']), np.ma.core.MaskedArray)\n\t    assert_equal(type(masked_arr['b']['c']), np.ma.core.MaskedArray)\n\t    assert_equal(len(masked_arr['b']['c']), 1)\n\t    assert_equal(masked_arr['b']['c'].shape, (1, 1))\n\t    assert_equal(masked_arr['b']['c']._fill_value.shape, ())\n\t\nTestGeneric().test_masked_all_with_object_nested()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_with_object(self):\n\t    my_dtype = np.dtype([('b', (object, (1,)))])\n\t    masked_arr = masked_all((1,), my_dtype)\n\t    assert_equal(type(masked_arr['b']), np.ma.core.MaskedArray)\n\t    assert_equal(len(masked_arr['b']), 1)\n\t    assert_equal(masked_arr['b'].shape, (1, 1))\n\t    assert_equal(masked_arr['b']._fill_value.shape, ())\n\t\nTestGeneric().test_masked_all_with_object()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef masked_all(shape, dtype=float): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "default_fill_value", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef default_fill_value(obj):\n    \"\"\"\n    Return the default fill value for the argument object.\n\n    The default filling value depends on the datatype of the input\n    array or the type of the input scalar:\n\n       ========  ========\n       datatype  default\n       ========  ========\n       bool      True\n       int       999999\n       float     1.e20\n       complex   1.e20+0j\n       object    '?'\n       string    'N/A'\n       ========  ========\n\n    For structured types, a structured scalar is returned, with each field the\n    default fill value for its type.\n\n    For subarray types, the fill value is an array of the same size containing\n    the default scalar fill value.\n\n    Parameters\n    ----------\n    obj : ndarray, dtype or scalar\n        The array data-type or scalar for which the default fill value\n        is returned.\n\n    Returns\n    -------\n    fill_value : scalar\n        The default fill value.\n\n    Examples\n    --------\n    >>> np.ma.default_fill_value(1)\n    999999\n    >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n    1e+20\n    >>> np.ma.default_fill_value(np.dtype(complex))\n    (1e+20+0j)\n\n    \"\"\"\n\n    def _scalar_fill_value(dtype):\n        if dtype.kind in 'Mm':\n            return default_filler.get(dtype.str[1:], '?')\n        else:\n            return default_filler.get(dtype.kind, '?')\n    dtype = _get_dtype_of(obj)\n    return _recursive_fill_value(dtype, _scalar_fill_value)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\ndef test_default_fill_value_complex():\n    assert_(default_fill_value(1 + 1.0j) == 1e+20 + 0.0j)\n\ntest_default_fill_value_complex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_flexible_dtype(self):\n\t    flexi = array([(1, 1, 1)], dtype=[('i', int), ('s', '|S8'), ('f', float)])\n\t    flexi[0] = masked\n\t    assert_equal(flexi.filled(), np.array([(default_fill_value(0),\n\t        default_fill_value('0'), default_fill_value(0.0))], dtype=flexi.dtype))\n\t    flexi[0] = masked\n\t    assert_equal(flexi.filled(1), np.array([(1, '1', 1.0)], dtype=flexi.dtype))\n\t\nTestMaskedArray().test_filled_with_flexible_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_filled_with_mvoid(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = mvoid((1, 2.0), mask=[(0, 1)], dtype=ndtype)\n\t    test = a.filled()\n\t    assert_equal(tuple(test), (1, default_fill_value(1.0)))\n\t    test = a.filled((-1, -1))\n\t    assert_equal(tuple(test), (1, -1))\n\t    a.fill_value = -999, -999\n\t    assert_equal(tuple(a.filled()), (1, -999))\n\t\nTestMaskedArray().test_filled_with_mvoid()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_check_on_scalar(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    fval = _check_fill_value(0, int)\n\t    assert_equal(fval, 0)\n\t    fval = _check_fill_value(None, int)\n\t    assert_equal(fval, default_fill_value(0))\n\t    fval = _check_fill_value(0, '|S3')\n\t    assert_equal(fval, b'0')\n\t    fval = _check_fill_value(None, '|S3')\n\t    assert_equal(fval, default_fill_value(b'camelot!'))\n\t    assert_raises(TypeError, _check_fill_value, 1e+20, int)\n\t    assert_raises(TypeError, _check_fill_value, 'stuff', int)\n\t\nTestFillingValues().test_check_on_scalar()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_conversion(self):\n\t    a = array([b'3', b'4', b'5'])\n\t    a._optinfo.update({'comment': 'updated!'})\n\t    b = array(a, dtype=int)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0))\n\t    b = array(a, dtype=float)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0.0))\n\t    b = a.astype(int)\n\t    assert_equal(b._data, [3, 4, 5])\n\t    assert_equal(b.fill_value, default_fill_value(0))\n\t    assert_equal(b._optinfo['comment'], 'updated!')\n\t    b = a.astype([('a', '|S3')])\n\t    assert_equal(b['a']._data, a._data)\n\t    assert_equal(b['a'].fill_value, a.fill_value)\n\t\nTestFillingValues().test_fillvalue_conversion()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value(self):\n\t    f1 = default_fill_value(1.0)\n\t    f2 = default_fill_value(np.array(1.0))\n\t    f3 = default_fill_value(np.array(1.0).dtype)\n\t    assert_equal(f1, f2)\n\t    assert_equal(f1, f3)\n\t\nTestFillingValues().test_default_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value_structured(self):\n\t    fields = array([(1, 1, 1)], dtype=[('i', int), ('s', '|S8'), ('f', float)])\n\t    f1 = default_fill_value(fields)\n\t    f2 = default_fill_value(fields.dtype)\n\t    expected = np.array((default_fill_value(0), default_fill_value('0'),\n\t        default_fill_value(0.0)), dtype=fields.dtype)\n\t    assert_equal(f1, expected)\n\t    assert_equal(f2, expected)\n\t\nTestFillingValues().test_default_fill_value_structured()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_default_fill_value_void(self):\n\t    dt = np.dtype([('v', 'V7')])\n\t    f = default_fill_value(dt)\n\t    assert_equal(f['v'], np.array(default_fill_value(dt['v']), dt['v']))\n\t\nTestFillingValues().test_default_fill_value_void()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_exotic_dtype(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    ndtype = [('i', int), ('s', '|S8'), ('f', float)]\n\t    control = np.array((default_fill_value(0), default_fill_value('0'),\n\t        default_fill_value(0.0)), dtype=ndtype)\n\t    assert_equal(_check_fill_value(None, ndtype), control)\n\t    ndtype = [('f0', float, (2, 2))]\n\t    control = np.array((default_fill_value(0.0),), dtype=[('f0', float)]\n\t        ).astype(ndtype)\n\t    assert_equal(_check_fill_value(None, ndtype), control)\n\t    control = np.array((0,), dtype=[('f0', float)]).astype(ndtype)\n\t    assert_equal(_check_fill_value(0, ndtype), control)\n\t    ndtype = np.dtype('int, (2,3)float, float')\n\t    control = np.array((default_fill_value(0), default_fill_value(0.0),\n\t        default_fill_value(0.0)), dtype='int, float, float').astype(ndtype)\n\t    test = _check_fill_value(None, ndtype)\n\t    assert_equal(test, control)\n\t    control = np.array((0, 0, 0), dtype='int, float, float').astype(ndtype)\n\t    assert_equal(_check_fill_value(0, ndtype), control)\n\t    M = masked_array(control)\n\t    assert_equal(M['f1'].fill_value.ndim, 0)\n\t\nTestFillingValues().test_fillvalue_exotic_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_datetime_timedelta(self):\n\t    for timecode in ('as', 'fs', 'ps', 'ns', 'us', 'ms', 's', 'm', 'h', 'D',\n\t        'W', 'M', 'Y'):\n\t        control = numpy.datetime64('NaT', timecode)\n\t        test = default_fill_value(numpy.dtype('<M8[' + timecode + ']'))\n\t        np.testing.assert_equal(test, control)\n\t        control = numpy.timedelta64('NaT', timecode)\n\t        test = default_fill_value(numpy.dtype('<m8[' + timecode + ']'))\n\t        np.testing.assert_equal(test, control)\n\t\nTestFillingValues().test_fillvalue_datetime_timedelta()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_extremum_fill_value(self):\n\t    a = array([(1, (2, 3)), (4, (5, 6))], dtype=[('A', int), ('B', [('BA',\n\t        int), ('BB', int)])])\n\t    test = a.fill_value\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test['A'], default_fill_value(a['A']))\n\t    assert_equal(test['B']['BA'], default_fill_value(a['B']['BA']))\n\t    assert_equal(test['B']['BB'], default_fill_value(a['B']['BB']))\n\t    test = minimum_fill_value(a)\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test[0], minimum_fill_value(a['A']))\n\t    assert_equal(test[1][0], minimum_fill_value(a['B']['BA']))\n\t    assert_equal(test[1][1], minimum_fill_value(a['B']['BB']))\n\t    assert_equal(test[1], minimum_fill_value(a['B']))\n\t    test = maximum_fill_value(a)\n\t    assert_equal(test.dtype, a.dtype)\n\t    assert_equal(test[0], maximum_fill_value(a['A']))\n\t    assert_equal(test[1][0], maximum_fill_value(a['B']['BA']))\n\t    assert_equal(test[1][1], maximum_fill_value(a['B']['BB']))\n\t    assert_equal(test[1], maximum_fill_value(a['B']))\n\t\nTestFillingValues().test_extremum_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_individual_fields(self):\n\t    ndtype = [('a', int), ('b', int)]\n\t    a = array(list(zip([1, 2, 3], [4, 5, 6])), fill_value=(-999, -999),\n\t        dtype=ndtype)\n\t    aa = a['a']\n\t    aa.set_fill_value(10)\n\t    assert_equal(aa._fill_value, np.array(10))\n\t    assert_equal(tuple(a.fill_value), (10, -999))\n\t    a.fill_value['b'] = -10\n\t    assert_equal(tuple(a.fill_value), (10, -10))\n\t    t = array(list(zip([1, 2, 3], [4, 5, 6])), dtype=ndtype)\n\t    tt = t['a']\n\t    tt.set_fill_value(10)\n\t    assert_equal(tt._fill_value, np.array(10))\n\t    assert_equal(tuple(t.fill_value), (10, default_fill_value(0)))\n\t\nTestFillingValues().test_fillvalue_individual_fields()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_implicit_structured_array(self):\n\t    ndtype = 'b', float\n\t    adtype = 'a', float\n\t    a = array([(1.0,), (2.0,)], mask=[(False,), (False,)], fill_value=(np.\n\t        nan,), dtype=np.dtype([adtype]))\n\t    b = empty(a.shape, dtype=[adtype, ndtype])\n\t    b['a'] = a['a']\n\t    b['a'].set_fill_value(a['a'].fill_value)\n\t    f = b._fill_value[()]\n\t    assert_(np.isnan(f[0]))\n\t    assert_equal(f[-1], default_fill_value(1.0))\n\t\nTestFillingValues().test_fillvalue_implicit_structured_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_fillvalue_bytes_or_str(self):\n\t    a = empty(shape=(3,), dtype='(2,)3S,(2,)3U')\n\t    assert_equal(a['f0'].fill_value, default_fill_value(b'spam'))\n\t    assert_equal(a['f1'].fill_value, default_fill_value('eggs'))\n\t\nTestFillingValues().test_fillvalue_bytes_or_str()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef default_fill_value(obj): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "doc_note", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef doc_note(initialdoc, note):\n    \"\"\"\n    Adds a Notes section to an existing docstring.\n\n    \"\"\"\n    if initialdoc is None:\n        return\n    if note is None:\n        return initialdoc\n    notesplit = re.split('\\\\n\\\\s*?Notes\\\\n\\\\s*?-----', inspect.cleandoc(\n        initialdoc))\n    notedoc = '\\n\\nNotes\\n-----\\n%s\\n' % inspect.cleandoc(note)\n    return ''.join(notesplit[:1] + [notedoc] + notesplit[1:])", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n@pytest.mark.skipif(sys.flags.optimize > 1, reason=\n    'no docstrings present to inspect when PYTHONOPTIMIZE/Py_OptimizeFlag > 1')\ndef test_doc_note():\n\n    def method(self):\n        \"\"\"This docstring\n\n        Has multiple lines\n\n        And notes\n\n        Notes\n        -----\n        original note\n        \"\"\"\n        pass\n    expected_doc = \"\"\"This docstring\n\nHas multiple lines\n\nAnd notes\n\nNotes\n-----\nnote\n\noriginal note\"\"\"\n    assert_equal(doc_note(method.__doc__, 'note'), expected_doc)\n\ntest_doc_note()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef doc_note(initialdoc, note): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "filled", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef filled(a, fill_value=None):\n    \"\"\"\n    Return input as an `~numpy.ndarray`, with masked values replaced by\n    `fill_value`.\n\n    If `a` is not a `MaskedArray`, `a` itself is returned.\n    If `a` is a `MaskedArray` with no masked values, then ``a.data`` is\n    returned.\n    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to\n    ``a.fill_value``.\n\n    Parameters\n    ----------\n    a : MaskedArray or array_like\n        An input object.\n    fill_value : array_like, optional.\n        Can be scalar or non-scalar. If non-scalar, the\n        resulting filled array should be broadcastable\n        over input array. Default is None.\n\n    Returns\n    -------\n    a : ndarray\n        The filled array.\n\n    See Also\n    --------\n    compressed\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n    ...                                                [1, 0, 0],\n    ...                                                [0, 0, 0]])\n    >>> x.filled()\n    array([[999999,      1,      2],\n           [999999,      4,      5],\n           [     6,      7,      8]])\n    >>> x.filled(fill_value=333)\n    array([[333,   1,   2],\n           [333,   4,   5],\n           [  6,   7,   8]])\n    >>> x.filled(fill_value=np.arange(3))\n    array([[0, 1, 2],\n           [0, 4, 5],\n           [6, 7, 8]])\n\n    \"\"\"\n    if hasattr(a, 'filled'):\n        return a.filled(fill_value)\n    elif isinstance(a, ndarray):\n        return a\n    elif isinstance(a, dict):\n        return np.array(a, 'O')\n    else:\n        return np.array(a)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_maskedelement(self):\n\t    x = arange(6)\n\t    x[1] = masked\n\t    assert_(str(masked) == '--')\n\t    assert_(x[1] is masked)\n\t    assert_equal(filled(x[1], 0), 0)\n\t\nTestMaskedArray().test_maskedelement()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayAttributes():\n\tdef test_hardmask(self):\n\t    d = arange(5)\n\t    n = [0, 0, 0, 1, 1]\n\t    m = make_mask(n)\n\t    xh = array(d, mask=m, hard_mask=True)\n\t    xs = array(d, mask=m, hard_mask=False, copy=True)\n\t    xh[[1, 4]] = [10, 40]\n\t    xs[[1, 4]] = [10, 40]\n\t    assert_equal(xh._data, [0, 10, 2, 3, 4])\n\t    assert_equal(xs._data, [0, 10, 2, 3, 40])\n\t    assert_equal(xs.mask, [0, 0, 0, 1, 0])\n\t    assert_(xh._hardmask)\n\t    assert_(not xs._hardmask)\n\t    xh[1:4] = [10, 20, 30]\n\t    xs[1:4] = [10, 20, 30]\n\t    assert_equal(xh._data, [0, 10, 20, 3, 4])\n\t    assert_equal(xs._data, [0, 10, 20, 30, 40])\n\t    assert_equal(xs.mask, nomask)\n\t    xh[0] = masked\n\t    xs[0] = masked\n\t    assert_equal(xh.mask, [1, 0, 0, 1, 1])\n\t    assert_equal(xs.mask, [1, 0, 0, 0, 0])\n\t    xh[:] = 1\n\t    xs[:] = 1\n\t    assert_equal(xh._data, [0, 1, 1, 3, 4])\n\t    assert_equal(xs._data, [1, 1, 1, 1, 1])\n\t    assert_equal(xh.mask, [1, 0, 0, 1, 1])\n\t    assert_equal(xs.mask, nomask)\n\t    xh.soften_mask()\n\t    xh[:] = arange(5)\n\t    assert_equal(xh._data, [0, 1, 2, 3, 4])\n\t    assert_equal(xh.mask, nomask)\n\t    xh.harden_mask()\n\t    xh[xh < 3] = masked\n\t    assert_equal(xh._data, [0, 1, 2, 3, 4])\n\t    assert_equal(xh._mask, [1, 1, 1, 0, 0])\n\t    xh[filled(xh > 1, False)] = 5\n\t    assert_equal(xh._data, [0, 1, 2, 5, 5])\n\t    assert_equal(xh._mask, [1, 1, 1, 0, 0])\n\t    xh = array([[1, 2], [3, 4]], mask=[[1, 0], [0, 0]], hard_mask=True)\n\t    xh[0] = 0\n\t    assert_equal(xh._data, [[1, 0], [3, 4]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t    xh[-1, -1] = 5\n\t    assert_equal(xh._data, [[1, 0], [3, 5]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t    xh[filled(xh < 5, False)] = 2\n\t    assert_equal(xh._data, [[1, 2], [2, 5]])\n\t    assert_equal(xh._mask, [[1, 0], [0, 0]])\n\t\nTestMaskedArrayAttributes().test_hardmask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef filled(a, fill_value=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "concatenate", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef concatenate(arrays, axis=0):\n    \"\"\"\n    Concatenate a sequence of arrays along the given axis.\n\n    Parameters\n    ----------\n    arrays : sequence of array_like\n        The arrays must have the same shape, except in the dimension\n        corresponding to `axis` (the first, by default).\n    axis : int, optional\n        The axis along which the arrays will be joined. Default is 0.\n\n    Returns\n    -------\n    result : MaskedArray\n        The concatenated array with any masked entries preserved.\n\n    See Also\n    --------\n    numpy.concatenate : Equivalent function in the top-level NumPy module.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = ma.arange(3)\n    >>> a[1] = ma.masked\n    >>> b = ma.arange(2, 5)\n    >>> a\n    masked_array(data=[0, --, 2],\n                 mask=[False,  True, False],\n           fill_value=999999)\n    >>> b\n    masked_array(data=[2, 3, 4],\n                 mask=False,\n           fill_value=999999)\n    >>> ma.concatenate([a, b])\n    masked_array(data=[0, --, 2, 2, 3, 4],\n                 mask=[False,  True, False, False, False, False],\n           fill_value=999999)\n\n    \"\"\"\n    d = np.concatenate([getdata(a) for a in arrays], axis)\n    rcls = get_masked_subclass(*arrays)\n    data = d.view(rcls)\n    for x in arrays:\n        if getmask(x) is not nomask:\n            break\n    else:\n        return data\n    dm = np.concatenate([getmaskarray(a) for a in arrays], axis)\n    dm = dm.reshape(d.shape)\n    data._mask = _shrink_mask(dm)\n    return data", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_concatenate_flexible(self):\n\t    data = masked_array(list(zip(np.random.rand(10), np.arange(10))), dtype\n\t        =[('a', float), ('b', int)])\n\t    test = concatenate([data[:5], data[5:]])\n\t    assert_equal_records(test, data)\n\t\nTestMaskedArray().test_concatenate_flexible()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef concatenate(arrays, axis=0): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "asarray", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef asarray(a, dtype=None, order=None):\n    \"\"\"\n    Convert the input to a masked array of the given data-type.\n\n    No copy is performed if the input is already an `ndarray`. If `a` is\n    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data, in any form that can be converted to a masked array. This\n        includes lists, lists of tuples, tuples, tuples of tuples, tuples\n        of lists, ndarrays and masked arrays.\n    dtype : dtype, optional\n        By default, the data-type is inferred from the input data.\n    order : {'C', 'F'}, optional\n        Whether to use row-major ('C') or column-major ('FORTRAN') memory\n        representation.  Default is 'C'.\n\n    Returns\n    -------\n    out : MaskedArray\n        Masked array interpretation of `a`.\n\n    See Also\n    --------\n    asanyarray : Similar to `asarray`, but conserves subclasses.\n\n    Examples\n    --------\n    >>> x = np.arange(10.).reshape(2, 5)\n    >>> x\n    array([[0., 1., 2., 3., 4.],\n           [5., 6., 7., 8., 9.]])\n    >>> np.ma.asarray(x)\n    masked_array(\n      data=[[0., 1., 2., 3., 4.],\n            [5., 6., 7., 8., 9.]],\n      mask=False,\n      fill_value=1e+20)\n    >>> type(np.ma.asarray(x))\n    <class 'numpy.ma.MaskedArray'>\n\n    \"\"\"\n    order = order or 'C'\n    return masked_array(a, dtype=dtype, copy=False, keep_mask=True, subok=\n        False, order=order)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_asarray_default_order(self):\n\t    m = np.eye(3).T\n\t    assert_(not m.flags.c_contiguous)\n\t    new_m = asarray(m)\n\t    assert_(new_m.flags.c_contiguous)\n\t\nTestMaskedArray().test_asarray_default_order()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_asarray_enforce_order(self):\n\t    m = np.eye(3).T\n\t    assert_(not m.flags.c_contiguous)\n\t    new_m = asarray(m, order='C')\n\t    assert_(new_m.flags.c_contiguous)\n\t\nTestMaskedArray().test_asarray_enforce_order()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef asarray(a, dtype=None, order=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "sort", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None,\n    *, stable=None):\n    \"\"\"\n    Return a sorted copy of the masked array.\n\n    Equivalent to creating a copy of the array\n    and applying the  MaskedArray ``sort()`` method.\n\n    Refer to ``MaskedArray.sort`` for the full documentation\n\n    See Also\n    --------\n    MaskedArray.sort : equivalent method\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)\n    >>> ma.sort(masked_x)\n    masked_array(data=[-3.973, 0.801, 11.2, --],\n                 mask=[False, False, False,  True],\n           fill_value=1e+20)\n    \"\"\"\n    a = np.array(a, copy=True, subok=True)\n    if axis is None:\n        a = a.flatten()\n        axis = 0\n    if isinstance(a, MaskedArray):\n        a.sort(axis=axis, kind=kind, order=order, endwith=endwith,\n            fill_value=fill_value, stable=stable)\n    else:\n        a.sort(axis=axis, kind=kind, order=order, stable=stable)\n    return a", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_indexing(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_equal(np.sort(x1), sort(x2, endwith=False))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_equal(x1[2], x2[2])\n\t    assert_equal(x1[2:5], x2[2:5])\n\t    assert_equal(x1[:], x2[:])\n\t    assert_equal(x1[1:], x3[1:])\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_equal(x1, x2)\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_equal(x1, x2)\n\t    x2[1] = masked\n\t    assert_equal(x1, x2)\n\t    x2[1:3] = masked\n\t    assert_equal(x1, x2)\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_equal(x1, x2)\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_equal(3.0, x2.fill_value)\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMaskedArray().test_indexing()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    sortedx = sort(x)\n\t    assert_equal(sortedx._data, [1, 2, 3, 4])\n\t    assert_equal(sortedx._mask, [0, 0, 0, 1])\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [4, 1, 2, 3])\n\t    assert_equal(sortedx._mask, [1, 0, 0, 0])\n\t    x.sort()\n\t    assert_equal(x._data, [1, 2, 3, 4])\n\t    assert_equal(x._mask, [0, 0, 0, 1])\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    x.sort(endwith=False)\n\t    assert_equal(x._data, [4, 1, 2, 3])\n\t    assert_equal(x._mask, [1, 0, 0, 0])\n\t    x = [1, 4, 2, 3]\n\t    sortedx = sort(x)\n\t    assert_(not isinstance(sorted, MaskedArray))\n\t    x = array([0, 1, -1, -2, 2], mask=nomask, dtype=np.int8)\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [-2, -1, 0, 1, 2])\n\t    x = array([0, 1, -1, -2, 2], mask=[0, 1, 0, 0, 1], dtype=np.int8)\n\t    sortedx = sort(x, endwith=False)\n\t    assert_equal(sortedx._data, [1, 2, -2, -1, 0])\n\t    assert_equal(sortedx._mask, [1, 1, 0, 0, 0])\n\t    x = array([0, -1], dtype=np.int8)\n\t    sortedx = sort(x, kind='stable')\n\t    assert_equal(sortedx, array([-1, 0], dtype=np.int8))\n\t\nTestMaskedArrayMethods().test_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort_matches_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    for kwargs in [dict(), dict(endwith=True), dict(endwith=False), dict(\n\t        fill_value=2), dict(fill_value=2, endwith=True), dict(fill_value=2,\n\t        endwith=False)]:\n\t        sortedx = sort(x, **kwargs)\n\t        argsortedx = x[argsort(x, **kwargs)]\n\t        assert_equal(sortedx._data, argsortedx._data)\n\t        assert_equal(sortedx._mask, argsortedx._mask)\n\t\nTestMaskedArrayMethods().test_argsort_matches_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_sort_flexible(self):\n\t    a = array(data=[(3, 3), (3, 2), (2, 2), (2, 1), (1, 0), (1, 1), (1, 2)],\n\t        mask=[(0, 0), (0, 1), (0, 0), (0, 0), (1, 0), (0, 0), (0, 0)],\n\t        dtype=[('A', int), ('B', int)])\n\t    mask_last = array(data=[(1, 1), (1, 2), (2, 1), (2, 2), (3, 3), (3, 2),\n\t        (1, 0)], mask=[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (1, \n\t        0)], dtype=[('A', int), ('B', int)])\n\t    mask_first = array(data=[(1, 0), (1, 1), (1, 2), (2, 1), (2, 2), (3, 2),\n\t        (3, 3)], mask=[(1, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (0, \n\t        0)], dtype=[('A', int), ('B', int)])\n\t    test = sort(a)\n\t    assert_equal(test, mask_last)\n\t    assert_equal(test.mask, mask_last.mask)\n\t    test = sort(a, endwith=False)\n\t    assert_equal(test, mask_first)\n\t    assert_equal(test.mask, mask_first.mask)\n\t    dt = np.dtype([('v', int, 2)])\n\t    a = a.view(dt)\n\t    test = sort(a)\n\t    test = sort(a, endwith=False)\n\t\nTestMaskedArrayMethods().test_sort_flexible()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None,\n    *, stable=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_where", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_where(condition, a, copy=True):\n    \"\"\"\n    Mask an array where a condition is met.\n\n    Return `a` as an array masked where `condition` is True.\n    Any masked values of `a` or `condition` are also masked in the output.\n\n    Parameters\n    ----------\n    condition : array_like\n        Masking condition.  When `condition` tests floating point values for\n        equality, consider using ``masked_values`` instead.\n    a : array_like\n        Array to mask.\n    copy : bool\n        If True (default) make a copy of `a` in the result.  If False modify\n        `a` in place and return a view.\n\n    Returns\n    -------\n    result : MaskedArray\n        The result of masking `a` where `condition` is True.\n\n    See Also\n    --------\n    masked_values : Mask using floating point equality.\n    masked_equal : Mask where equal to a given value.\n    masked_not_equal : Mask where *not* equal to a given value.\n    masked_less_equal : Mask where less than or equal to a given value.\n    masked_greater_equal : Mask where greater than or equal to a given value.\n    masked_less : Mask where less than a given value.\n    masked_greater : Mask where greater than a given value.\n    masked_inside : Mask inside a given interval.\n    masked_outside : Mask outside a given interval.\n    masked_invalid : Mask invalid values (NaNs or infs).\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_where(a <= 2, a)\n    masked_array(data=[--, --, --, 3],\n                 mask=[ True,  True,  True, False],\n           fill_value=999999)\n\n    Mask array `b` conditional on `a`.\n\n    >>> b = ['a', 'b', 'c', 'd']\n    >>> ma.masked_where(a == 2, b)\n    masked_array(data=['a', 'b', --, 'd'],\n                 mask=[False, False,  True, False],\n           fill_value='N/A',\n                dtype='<U1')\n\n    Effect of the `copy` argument.\n\n    >>> c = ma.masked_where(a <= 2, a)\n    >>> c\n    masked_array(data=[--, --, --, 3],\n                 mask=[ True,  True,  True, False],\n           fill_value=999999)\n    >>> c[0] = 99\n    >>> c\n    masked_array(data=[99, --, --, 3],\n                 mask=[False,  True,  True, False],\n           fill_value=999999)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> c = ma.masked_where(a <= 2, a, copy=False)\n    >>> c[0] = 99\n    >>> c\n    masked_array(data=[99, --, --, 3],\n                 mask=[False,  True,  True, False],\n           fill_value=999999)\n    >>> a\n    array([99,  1,  2,  3])\n\n    When `condition` or `a` contain masked values.\n\n    >>> a = np.arange(4)\n    >>> a = ma.masked_where(a == 2, a)\n    >>> a\n    masked_array(data=[0, 1, --, 3],\n                 mask=[False, False,  True, False],\n           fill_value=999999)\n    >>> b = np.arange(4)\n    >>> b = ma.masked_where(b == 0, b)\n    >>> b\n    masked_array(data=[--, 1, 2, 3],\n                 mask=[ True, False, False, False],\n           fill_value=999999)\n    >>> ma.masked_where(a == 3, b)\n    masked_array(data=[--, 1, --, --],\n                 mask=[ True, False,  True,  True],\n           fill_value=999999)\n\n    \"\"\"\n    cond = make_mask(condition, shrink=False)\n    a = np.array(a, copy=copy, subok=True)\n    cshape, ashape = cond.shape, a.shape\n    if cshape and cshape != ashape:\n        raise IndexError(\n            'Inconsistent shape between the condition and the input (got %s and %s)'\n             % (cshape, ashape))\n    if hasattr(a, '_mask'):\n        cond = mask_or(cond, a._mask)\n        cls = type(a)\n    else:\n        cls = MaskedArray\n    result = a.view(cls)\n    result.mask = _shrink_mask(cond)\n    if not copy and hasattr(a, '_mask') and getmask(a) is nomask:\n        a._mask = result._mask.view()\n    return result", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_1(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_equal(z.real, x)\n\t    assert_equal(z.imag, 10 * x)\n\t    assert_equal((z * conjugate(z)).real, 101 * x * x)\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_equal(x, z)\n\t\nTestMaskedArray().test_oddfeatures_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestUfuncs():\n\tdef test_minmax(self):\n\t    a = arange(1, 13).reshape(3, 4)\n\t    amask = masked_where(a < 5, a)\n\t    assert_equal(amask.max(), a.max())\n\t    assert_equal(amask.min(), 5)\n\t    assert_equal(amask.max(0), a.max(0))\n\t    assert_equal(amask.min(0), [5, 6, 7, 8])\n\t    assert_(amask.max(1)[0].mask)\n\t    assert_(amask.min(1)[0].mask)\n\t\nTestUfuncs().test_minmax()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_bool(self):\n\t    x = [1, 2]\n\t    y = masked_where(False, x)\n\t    assert_equal(y, [1, 2])\n\t    assert_equal(y[1], 2)\n\t\nTestMaskedArrayFunctions().test_masked_where_bool()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    x[2] = masked\n\t    assert_equal(masked_where(greater(x, 2), x), masked_greater(x, 2))\n\t    assert_equal(masked_where(greater_equal(x, 2), x), masked_greater_equal\n\t        (x, 2))\n\t    assert_equal(masked_where(less(x, 2), x), masked_less(x, 2))\n\t    assert_equal(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where(equal(x, 2), x), masked_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3,\n\t        4, 5])\n\t\nTestMaskedArrayFunctions().test_masked_where_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_oddities(self):\n\t    atest = ones((10, 10, 10), dtype=float)\n\t    btest = zeros(atest.shape, MaskType)\n\t    ctest = masked_where(btest, atest)\n\t    assert_equal(atest, ctest)\n\t\nTestMaskedArrayFunctions().test_masked_where_oddities()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_structured_masked(self):\n\t    dt = np.dtype([('a', int), ('b', int)])\n\t    x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)\n\t    ma = where([0, 1, 1], x, masked)\n\t    expected = masked_where([1, 0, 0], x)\n\t    assert_equal(ma.dtype, expected.dtype)\n\t    assert_equal(ma, expected)\n\t    assert_equal(ma.mask, expected.mask)\n\t\nTestMaskedArrayFunctions().test_where_structured_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_where(condition, a, copy=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "where", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef where(condition, x=_NoValue, y=_NoValue):\n    \"\"\"\n    Return a masked array with elements from `x` or `y`, depending on condition.\n\n    .. note::\n        When only `condition` is provided, this function is identical to\n        `nonzero`. The rest of this documentation covers only the case where\n        all three arguments are provided.\n\n    Parameters\n    ----------\n    condition : array_like, bool\n        Where True, yield `x`, otherwise yield `y`.\n    x, y : array_like, optional\n        Values from which to choose. `x`, `y` and `condition` need to be\n        broadcastable to some shape.\n\n    Returns\n    -------\n    out : MaskedArray\n        An masked array with `masked` elements where the condition is masked,\n        elements from `x` where `condition` is True, and elements from `y`\n        elsewhere.\n\n    See Also\n    --------\n    numpy.where : Equivalent function in the top-level NumPy module.\n    nonzero : The function that is called when x and y are omitted\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n    ...                                                    [1, 0, 1],\n    ...                                                    [0, 1, 0]])\n    >>> x\n    masked_array(\n      data=[[0.0, --, 2.0],\n            [--, 4.0, --],\n            [6.0, --, 8.0]],\n      mask=[[False,  True, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=1e+20)\n    >>> np.ma.where(x > 5, x, -3.1416)\n    masked_array(\n      data=[[-3.1416, --, -3.1416],\n            [--, -3.1416, --],\n            [6.0, --, 8.0]],\n      mask=[[False,  True, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=1e+20)\n\n    \"\"\"\n    missing = (x is _NoValue, y is _NoValue).count(True)\n    if missing == 1:\n        raise ValueError(\"Must provide both 'x' and 'y' or neither.\")\n    if missing == 2:\n        return nonzero(condition)\n    cf = filled(condition, False)\n    xd = getdata(x)\n    yd = getdata(y)\n    cm = getmaskarray(condition)\n    xm = getmaskarray(x)\n    ym = getmaskarray(y)\n    if x is masked and y is not masked:\n        xd = np.zeros((), dtype=yd.dtype)\n        xm = np.ones((), dtype=ym.dtype)\n    elif y is masked and x is not masked:\n        yd = np.zeros((), dtype=xd.dtype)\n        ym = np.ones((), dtype=xm.dtype)\n    data = np.where(cf, xd, yd)\n    mask = np.where(cf, xm, ym)\n    mask = np.where(cm, np.ones((), dtype=mask.dtype), mask)\n    mask = _shrink_mask(mask)\n    return masked_array(data, mask=mask)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_1(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_equal(z.real, x)\n\t    assert_equal(z.imag, 10 * x)\n\t    assert_equal((z * conjugate(z)).real, 101 * x * x)\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_equal(x, z)\n\t\nTestMaskedArray().test_oddfeatures_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_oddfeatures_2(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t\nTestMaskedArray().test_oddfeatures_2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_round(self):\n\t    a = array([1.23456, 2.34567, 3.45678, 4.56789, 5.6789], mask=[0, 1, 0, \n\t        0, 0])\n\t    assert_equal(a.round(), [1.0, 2.0, 3.0, 5.0, 6.0])\n\t    assert_equal(a.round(1), [1.2, 2.3, 3.5, 4.6, 5.7])\n\t    assert_equal(a.round(3), [1.235, 2.346, 3.457, 4.568, 5.679])\n\t    b = empty_like(a)\n\t    a.round(out=b)\n\t    assert_equal(b, [1.0, 2.0, 3.0, 5.0, 6.0])\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t\nTestMaskedArrayFunctions().test_round()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_with_masked_choice(self):\n\t    x = arange(10)\n\t    x[3] = masked\n\t    c = x >= 8\n\t    z = where(c, x, masked)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is masked)\n\t    assert_(z[7] is masked)\n\t    assert_(z[8] is not masked)\n\t    assert_(z[9] is not masked)\n\t    assert_equal(x, z)\n\t    z = where(c, masked, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t\nTestMaskedArrayFunctions().test_where_with_masked_choice()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_with_masked_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_equal(z, [1.0, 2.0, 0.0, -4.0, -5])\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    x = arange(1, 6)\n\t    x[-1] = masked\n\t    y = arange(1, 6) * 10\n\t    y[2] = masked\n\t    c = array([1, 1, 1, 0, 0], mask=[1, 0, 0, 0, 0])\n\t    cm = c.filled(1)\n\t    z = where(c, x, y)\n\t    zm = where(cm, x, y)\n\t    assert_equal(z, zm)\n\t    assert_(getmask(zm) is nomask)\n\t    assert_equal(zm, [1, 2, 3, 40, 50])\n\t    z = where(c, masked, 1)\n\t    assert_equal(z, [99, 99, 99, 1, 1])\n\t    z = where(c, 1, masked)\n\t    assert_equal(z, [99, 1, 1, 99, 99])\n\t\nTestMaskedArrayFunctions().test_where_with_masked_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_type(self):\n\t    x = np.arange(4, dtype=np.int32)\n\t    y = np.arange(4, dtype=np.float32) * 2.2\n\t    test = where(x > 1.5, y, x).dtype\n\t    control = np.result_type(np.int32, np.float32)\n\t    assert_equal(test, control)\n\t\nTestMaskedArrayFunctions().test_where_type()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_broadcast(self):\n\t    x = np.arange(9).reshape(3, 3)\n\t    y = np.zeros(3)\n\t    core = np.where([1, 0, 1], x, y)\n\t    ma = where([1, 0, 1], x, y)\n\t    assert_equal(core, ma)\n\t    assert_equal(core.dtype, ma.dtype)\n\t\nTestMaskedArrayFunctions().test_where_broadcast()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_where_structured_masked(self):\n\t    dt = np.dtype([('a', int), ('b', int)])\n\t    x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)\n\t    ma = where([0, 1, 1], x, masked)\n\t    expected = masked_where([1, 0, 0], x)\n\t    assert_equal(ma.dtype, expected.dtype)\n\t    assert_equal(ma, expected)\n\t    assert_equal(ma.mask, expected.mask)\n\t\nTestMaskedArrayFunctions().test_where_structured_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef where(condition, x=_NoValue, y=_NoValue): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "flatten_structured_array", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef flatten_structured_array(a):\n    \"\"\"\n    Flatten a structured array.\n\n    The data type of the output is chosen such that it can represent all of the\n    (nested) fields.\n\n    Parameters\n    ----------\n    a : structured array\n\n    Returns\n    -------\n    output : masked array or ndarray\n        A flattened masked array if the input is a masked array, otherwise a\n        standard ndarray.\n\n    Examples\n    --------\n    >>> ndtype = [('a', int), ('b', float)]\n    >>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n    >>> np.ma.flatten_structured_array(a)\n    array([[1., 1.],\n           [2., 2.]])\n\n    \"\"\"\n\n    def flatten_sequence(iterable):\n        \"\"\"\n        Flattens a compound of nested iterables.\n\n        \"\"\"\n        for elm in iter(iterable):\n            if hasattr(elm, '__iter__'):\n                yield from flatten_sequence(elm)\n            else:\n                yield elm\n    a = np.asanyarray(a)\n    inishape = a.shape\n    a = a.ravel()\n    if isinstance(a, MaskedArray):\n        out = np.array([tuple(flatten_sequence(d.item())) for d in a._data])\n        out = out.view(MaskedArray)\n        out._mask = np.array([tuple(flatten_sequence(d.item())) for d in\n            getmaskarray(a)])\n    else:\n        out = np.array([tuple(flatten_sequence(d.item())) for d in a])\n    if len(inishape) > 1:\n        newshape = list(out.shape)\n        newshape[0] = inishape\n        out.shape = tuple(flatten_sequence(newshape))\n    return out", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArray():\n\tdef test_flatten_structured_array(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = np.array([(1, 1), (2, 2)], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = np.array([[1.0, 1.0], [2.0, 2.0]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    a = array([(1, 1), (2, 2)], mask=[(0, 1), (1, 0)], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = array([[1.0, 1.0], [2.0, 2.0]], mask=[[0, 1], [1, 0]], dtype=\n\t        float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    assert_equal(test.mask, control.mask)\n\t    ndtype = [('a', int), ('b', [('ba', int), ('bb', float)])]\n\t    a = array([(1, (1, 1.1)), (2, (2, 2.2))], mask=[(0, (1, 0)), (1, (0, 1)\n\t        )], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = array([[1.0, 1.0, 1.1], [2.0, 2.0, 2.2]], mask=[[0, 1, 0], [1,\n\t        0, 1]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t    assert_equal(test.mask, control.mask)\n\t    ndtype = [('a', int), ('b', float)]\n\t    a = np.array([[(1, 1)], [(2, 2)]], dtype=ndtype)\n\t    test = flatten_structured_array(a)\n\t    control = np.array([[[1.0, 1.0]], [[2.0, 2.0]]], dtype=float)\n\t    assert_equal(test, control)\n\t    assert_equal(test.dtype, control.dtype)\n\t\nTestMaskedArray().test_flatten_structured_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef flatten_structured_array(a): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "getmaskarray", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef getmaskarray(arr):\n    \"\"\"\n    Return the mask of a masked array, or full boolean array of False.\n\n    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and\n    the mask is not `nomask`, else return a full boolean array of False of\n    the same shape as `arr`.\n\n    Parameters\n    ----------\n    arr : array_like\n        Input `MaskedArray` for which the mask is required.\n\n    See Also\n    --------\n    getmask : Return the mask of a masked array, or nomask.\n    getdata : Return the data of a masked array as an ndarray.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = ma.masked_equal([[1,2],[3,4]], 2)\n    >>> a\n    masked_array(\n      data=[[1, --],\n            [3, 4]],\n      mask=[[False,  True],\n            [False, False]],\n      fill_value=2)\n    >>> ma.getmaskarray(a)\n    array([[False,  True],\n           [False, False]])\n\n    Result when mask == ``nomask``\n\n    >>> b = ma.masked_array([[1,2],[3,4]])\n    >>> b\n    masked_array(\n      data=[[1, 2],\n            [3, 4]],\n      mask=False,\n      fill_value=999999)\n    >>> ma.getmaskarray(b)\n    array([[False, False],\n           [False, False]])\n\n    \"\"\"\n    mask = getmask(arr)\n    if mask is nomask:\n        mask = make_mask_none(np.shape(arr), getattr(arr, 'dtype', None))\n    return mask", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_limits_arithmetic(self):\n\t    tiny = np.finfo(float).tiny\n\t    a = array([tiny, 1.0 / tiny, 0.0])\n\t    assert_equal(getmaskarray(a / 2), [0, 0, 0])\n\t    assert_equal(getmaskarray(2 / a), [1, 0, 1])\n\t\nTestMaskedArrayArithmetic().test_limits_arithmetic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedFields():\n\tdef test_getmaskarray(self):\n\t    ndtype = [('a', int), ('b', float)]\n\t    test = empty(3, dtype=ndtype)\n\t    assert_equal(getmaskarray(test), np.array([(0, 0), (0, 0), (0, 0)],\n\t        dtype=[('a', '|b1'), ('b', '|b1')]))\n\t    test[:] = masked\n\t    assert_equal(getmaskarray(test), np.array([(1, 1), (1, 1), (1, 1)],\n\t        dtype=[('a', '|b1'), ('b', '|b1')]))\n\t\nTestMaskedFields().test_getmaskarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef getmaskarray(arr): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "outer", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef outer(a, b):\n    \"\"\"maskedarray version of the numpy function.\"\"\"\n    fa = filled(a, 0).ravel()\n    fb = filled(b, 0).ravel()\n    d = np.outer(fa, fb)\n    ma = getmask(a)\n    mb = getmask(b)\n    if ma is nomask and mb is nomask:\n        return masked_array(d)\n    ma = getmaskarray(a)\n    mb = getmaskarray(b)\n    m = make_mask(1 - np.outer(1 - ma, 1 - mb), copy=False)\n    return masked_array(d, mask=m)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef outer(a, b): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "take", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef take(a, indices, axis=None, out=None, mode='raise'):\n    \"\"\"\n    \"\"\"\n    a = masked_array(a)\n    return a.take(indices, axis=axis, out=out, mode=mode)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_take(self):\n\t    x = masked_array([10, 20, 30, 40], [0, 1, 0, 1])\n\t    assert_equal(x.take([0, 0, 3]), masked_array([10, 10, 40], [0, 0, 1]))\n\t    assert_equal(x.take([0, 0, 3]), x[[0, 0, 3]])\n\t    assert_equal(x.take([[0, 1], [0, 1]]), masked_array([[10, 20], [10, 20]\n\t        ], [[0, 1], [0, 1]]))\n\t    assert_(x[1] is np.ma.masked)\n\t    assert_(x.take(1) is np.ma.masked)\n\t    x = array([[10, 20, 30], [40, 50, 60]], mask=[[0, 0, 1], [1, 0, 0]])\n\t    assert_equal(x.take([0, 2], axis=1), array([[10, 30], [40, 60]], mask=[\n\t        [0, 1], [1, 0]]))\n\t    assert_equal(take(x, [0, 2], axis=1), array([[10, 30], [40, 60]], mask=\n\t        [[0, 1], [1, 0]]))\n\t\nTestMaskedArrayMethods().test_take()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_take_masked_indices(self):\n\t    a = np.array((40, 18, 37, 9, 22))\n\t    indices = np.arange(3)[None, :] + np.arange(5)[:, None]\n\t    mindices = array(indices, mask=indices >= len(a))\n\t    test = take(a, mindices, mode='clip')\n\t    ctrl = array([[40, 18, 37], [18, 37, 9], [37, 9, 22], [9, 22, 22], [22,\n\t        22, 22]])\n\t    assert_equal(test, ctrl)\n\t    test = take(a, mindices)\n\t    ctrl = array([[40, 18, 37], [18, 37, 9], [37, 9, 22], [9, 22, 40], [22,\n\t        40, 40]])\n\t    ctrl[3, 2] = ctrl[4, 1] = ctrl[4, 2] = masked\n\t    assert_equal(test, ctrl)\n\t    assert_equal(test.mask, ctrl.mask)\n\t    a = array((40, 18, 37, 9, 22), mask=(0, 1, 0, 0, 0))\n\t    test = take(a, mindices)\n\t    ctrl[0, 1] = ctrl[1, 0] = masked\n\t    assert_equal(test, ctrl)\n\t    assert_equal(test.mask, ctrl.mask)\n\t\nTestMaskedArrayMethods().test_take_masked_indices()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef take(a, indices, axis=None, out=None, mode='raise'): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "inner", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef inner(a, b):\n    \"\"\"\n    Returns the inner product of a and b for arrays of floating point types.\n\n    Like the generic NumPy equivalent the product sum is over the last dimension\n    of a and b. The first argument is not conjugated.\n\n    \"\"\"\n    fa = filled(a, 0)\n    fb = filled(b, 0)\n    if fa.ndim == 0:\n        fa.shape = 1,\n    if fb.ndim == 0:\n        fb.shape = 1,\n    return np.inner(fa, fb).view(MaskedArray)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayArithmetic():\n\tdef test_TakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))\n\t    assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))\n\t    assert_equal(np.inner(filled(x, 0), filled(y, 0)), inner(x, y))\n\t    assert_equal(np.outer(filled(x, 0), filled(y, 0)), outer(x, y))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMaskedArrayArithmetic().test_TakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef inner(a, b): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "asbytes", "method_path": "../srcdata/Computation/numpy/numpy/_utils/_convertions.py", "response": "\ndef asbytes(s):\n    if isinstance(s, bytes):\n        return s\n    return str(s).encode('latin1')", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestFillingValues():\n\tdef test_check_on_fields(self):\n\t    _check_fill_value = np.ma.core._check_fill_value\n\t    ndtype = [('a', int), ('b', float), ('c', '|S3')]\n\t    fval = _check_fill_value([-999, -12345678.9, '???'], ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fval = _check_fill_value(None, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [default_fill_value(0), default_fill_value(\n\t        0.0), asbytes(default_fill_value('0'))])\n\t    fill_val = np.array((-999, -12345678.9, '???'), dtype=ndtype)\n\t    fval = _check_fill_value(fill_val, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fill_val = np.array((-999, -12345678.9, '???'), dtype=[('A', int), ('B',\n\t        float), ('C', '|S3')])\n\t    fval = _check_fill_value(fill_val, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    fill_val = np.ndarray(shape=(1,), dtype=object)\n\t    fill_val[0] = -999, -12345678.9, b'???'\n\t    fval = _check_fill_value(fill_val, object)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), [-999, -12345678.9, b'???'])\n\t    ndtype = [('a', int)]\n\t    fval = _check_fill_value(-999999999, ndtype)\n\t    assert_(isinstance(fval, ndarray))\n\t    assert_equal(fval.item(), (-999999999,))\n\t\nTestFillingValues().test_check_on_fields()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestSaveTxt():\n\tdef test_array(self):\n\t    a = np.array([[1, 2], [3, 4]], float)\n\t    fmt = '%.18e'\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt=fmt)\n\t    c.seek(0)\n\t    assert_equal(c.readlines(), [asbytes((fmt + ' ' + fmt + '\\n') % (1, 2)),\n\t        asbytes((fmt + ' ' + fmt + '\\n') % (3, 4))])\n\t    a = np.array([[1, 2], [3, 4]], int)\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt='%d')\n\t    c.seek(0)\n\t    assert_equal(c.readlines(), [b'1 2\\n', b'3 4\\n'])\n\t\nTestSaveTxt().test_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestSaveTxt():\n\tdef test_header_footer(self):\n\t    c = BytesIO()\n\t    a = np.array([(1, 2), (3, 4)], dtype=int)\n\t    test_header_footer = 'Test header / footer'\n\t    np.savetxt(c, a, fmt='%1d', header=test_header_footer)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('# ' + test_header_footer + '\\n1 2\\n3 4\\n'))\n\t    c = BytesIO()\n\t    np.savetxt(c, a, fmt='%1d', footer=test_header_footer)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('1 2\\n3 4\\n# ' + test_header_footer + '\\n'))\n\t    c = BytesIO()\n\t    commentstr = '% '\n\t    np.savetxt(c, a, fmt='%1d', header=test_header_footer, comments=commentstr)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes(commentstr + test_header_footer + '\\n' +\n\t        '1 2\\n3 4\\n'))\n\t    c = BytesIO()\n\t    commentstr = '% '\n\t    np.savetxt(c, a, fmt='%1d', footer=test_header_footer, comments=commentstr)\n\t    c.seek(0)\n\t    assert_equal(c.read(), asbytes('1 2\\n3 4\\n' + commentstr +\n\t        test_header_footer + '\\n'))\n\t\nTestSaveTxt().test_header_footer()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import copy\nimport sys\nimport gc\nimport tempfile\nimport pytest\nfrom os import path\nfrom io import BytesIO\nfrom itertools import chain\nimport pickle\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import _assert_valid_refcount\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.testing._private.utils import requires_memory\nfrom math import radians\nfrom hashlib import sha256\nimport re\nimport operator as op\n\nclass TestRegression():\n\tdef test_junk_in_string_fields_of_recarray(self):\n\t    r = np.array([[b'abc']], dtype=[('var1', '|S20')])\n\t    assert_(asbytes(r['var1'][0][0]) == b'abc')\n\t\nTestRegression().test_junk_in_string_fields_of_recarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_regression.py"}], "method_code_mask": "def asbytes(s): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "allclose", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    This function is equivalent to `allclose` except that masked values\n    are treated as equal (default) or unequal, depending on the `masked_equal`\n    argument.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    masked_equal : bool, optional\n        Whether masked values in `a` and `b` are considered equal (True) or not\n        (False). They are considered equal by default.\n    rtol : float, optional\n        Relative tolerance. The relative difference is equal to ``rtol * b``.\n        Default is 1e-5.\n    atol : float, optional\n        Absolute tolerance. The absolute difference is equal to `atol`.\n        Default is 1e-8.\n\n    Returns\n    -------\n    y : bool\n        Returns True if the two arrays are equal within the given\n        tolerance, False otherwise. If either array contains NaN, then\n        False is returned.\n\n    See Also\n    --------\n    all, any\n    numpy.allclose : the non-masked `allclose`.\n\n    Notes\n    -----\n    If the following equation is element-wise True, then `allclose` returns\n    True::\n\n      absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Return True if all elements of `a` and `b` are equal subject to\n    given tolerances.\n\n    Examples\n    --------\n    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n    >>> a\n    masked_array(data=[10000000000.0, 1e-07, --],\n                 mask=[False, False,  True],\n           fill_value=1e+20)\n    >>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    False\n\n    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n    >>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    True\n    >>> np.ma.allclose(a, b, masked_equal=False)\n    False\n\n    Masked values are not compared directly.\n\n    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n    >>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n    >>> np.ma.allclose(a, b)\n    True\n    >>> np.ma.allclose(a, b, masked_equal=False)\n    False\n\n    \"\"\"\n    x = masked_array(a, copy=False)\n    y = masked_array(b, copy=False)\n    if y.dtype.kind != 'm':\n        dtype = np.result_type(y, 1.0)\n        if y.dtype != dtype:\n            y = masked_array(y, dtype=dtype, copy=False)\n    m = mask_or(getmask(x), getmask(y))\n    xinf = np.isinf(masked_array(x, copy=False, mask=m)).filled(False)\n    if not np.all(xinf == filled(np.isinf(y), False)):\n        return False\n    if not np.any(xinf):\n        d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),\n            masked_equal)\n        return np.all(d)\n    if not np.all(filled(x[xinf] == y[xinf], masked_equal)):\n        return False\n    x = x[~xinf]\n    y = y[~xinf]\n    d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),\n        masked_equal)\n    return np.all(d)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_allclose(self):\n\t    a = np.random.rand(10)\n\t    b = a + np.random.rand(10) * 1e-08\n\t    assert_(allclose(a, b))\n\t    a[0] = np.inf\n\t    assert_(not allclose(a, b))\n\t    b[0] = np.inf\n\t    assert_(allclose(a, b))\n\t    a = masked_array(a)\n\t    a[-1] = masked\n\t    assert_(allclose(a, b, masked_equal=True))\n\t    assert_(not allclose(a, b, masked_equal=False))\n\t    a *= 1e-08\n\t    a[0] = 0\n\t    assert_(allclose(a, 0, masked_equal=True))\n\t    a = masked_array([np.iinfo(np.int_).min], dtype=np.int_)\n\t    assert_(allclose(a, a))\n\t\nTestMaskedArrayMethods().test_allclose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_allclose_timedelta(self):\n\t    a = np.array([[1, 2, 3, 4]], dtype='m8[ns]')\n\t    assert allclose(a, a, atol=0)\n\t    assert allclose(a, a, atol=np.timedelta64(1, 'ns'))\n\t\nTestMaskedArrayMethods().test_allclose_timedelta()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "putmask", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef putmask(a, mask, values):\n    \"\"\"\n    Changes elements of an array based on conditional and input values.\n\n    This is the masked array version of `numpy.putmask`, for details see\n    `numpy.putmask`.\n\n    See Also\n    --------\n    numpy.putmask\n\n    Notes\n    -----\n    Using a masked array as `values` will **not** transform a `ndarray` into\n    a `MaskedArray`.\n\n    Examples\n    --------\n    >>> arr = [[1, 2], [3, 4]]\n    >>> mask = [[1, 0], [0, 0]]\n    >>> x = np.ma.array(arr, mask=mask)\n    >>> np.ma.putmask(x, x < 4, 10*x)\n    >>> x\n    masked_array(\n      data=[[--, 20],\n            [30, 4]],\n      mask=[[ True, False],\n            [False, False]],\n      fill_value=999999)\n    >>> x.data\n    array([[10, 20],\n           [30,  4]])\n\n    \"\"\"\n    if not isinstance(a, MaskedArray):\n        a = a.view(MaskedArray)\n    valdata, valmask = getdata(values), getmask(values)\n    if getmask(a) is nomask:\n        if valmask is not nomask:\n            a._sharedmask = True\n            a._mask = make_mask_none(a.shape, a.dtype)\n            np.copyto(a._mask, valmask, where=mask)\n    elif a._hardmask:\n        if valmask is not nomask:\n            m = a._mask.copy()\n            np.copyto(m, valmask, where=mask)\n            a.mask |= m\n    else:\n        if valmask is nomask:\n            valmask = getmaskarray(values)\n        np.copyto(a._mask, valmask, where=mask)\n    np.copyto(a._data, valdata, where=mask)\n    return", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_putmask(self):\n\t    x = arange(6) + 1\n\t    mx = array(x, mask=[0, 0, 0, 1, 1, 1])\n\t    mask = [0, 0, 1, 0, 0, 1]\n\t    xx = x.copy()\n\t    putmask(xx, mask, 99)\n\t    assert_equal(xx, [1, 2, 99, 4, 5, 99])\n\t    mxx = mx.copy()\n\t    putmask(mxx, mask, 99)\n\t    assert_equal(mxx._data, [1, 2, 99, 4, 5, 99])\n\t    assert_equal(mxx._mask, [0, 0, 0, 1, 1, 0])\n\t    values = array([10, 20, 30, 40, 50, 60], mask=[1, 1, 1, 0, 0, 0])\n\t    xx = x.copy()\n\t    putmask(xx, mask, values)\n\t    assert_equal(xx._data, [1, 2, 30, 4, 5, 60])\n\t    assert_equal(xx._mask, [0, 0, 1, 0, 0, 0])\n\t    mxx = mx.copy()\n\t    putmask(mxx, mask, values)\n\t    assert_equal(mxx._data, [1, 2, 30, 4, 5, 60])\n\t    assert_equal(mxx._mask, [0, 0, 1, 1, 1, 0])\n\t    mxx = mx.copy()\n\t    mxx.harden_mask()\n\t    putmask(mxx, mask, values)\n\t    assert_equal(mxx, [1, 2, 30, 4, 5, 60])\n\t\nTestMaskedArrayMethods().test_putmask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef putmask(a, mask, values): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "argsort", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True,\n    fill_value=None, *, stable=None):\n    \"\"\"Function version of the eponymous method.\"\"\"\n    a = np.asanyarray(a)\n    if axis is np._NoValue:\n        axis = _deprecate_argsort_axis(a)\n    if isinstance(a, MaskedArray):\n        return a.argsort(axis=axis, kind=kind, order=order, endwith=endwith,\n            fill_value=fill_value, stable=None)\n    else:\n        return a.argsort(axis=axis, kind=kind, order=order, stable=None)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_stable_sort(self):\n\t    x = array([1, 2, 3, 1, 2, 3], dtype=np.uint8)\n\t    expected = array([0, 3, 1, 4, 2, 5])\n\t    computed = argsort(x, kind='stable')\n\t    assert_equal(computed, expected)\n\t\nTestMaskedArrayMethods().test_stable_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort_matches_sort(self):\n\t    x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)\n\t    for kwargs in [dict(), dict(endwith=True), dict(endwith=False), dict(\n\t        fill_value=2), dict(fill_value=2, endwith=True), dict(fill_value=2,\n\t        endwith=False)]:\n\t        sortedx = sort(x, **kwargs)\n\t        argsortedx = x[argsort(x, **kwargs)]\n\t        assert_equal(sortedx._data, argsortedx._data)\n\t        assert_equal(sortedx._mask, argsortedx._mask)\n\t\nTestMaskedArrayMethods().test_argsort_matches_sort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMethods():\n\tdef test_argsort(self):\n\t    a = array([1, 5, 2, 4, 3], mask=[1, 0, 0, 1, 0])\n\t    assert_equal(np.argsort(a), argsort(a))\n\t\nTestMaskedArrayMethods().test_argsort()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True,\n    fill_value=None, *, stable=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "diag", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef diag(v, k=0):\n    \"\"\"\n    Extract a diagonal or construct a diagonal array.\n\n    This function is the equivalent of `numpy.diag` that takes masked\n    values into account, see `numpy.diag` for details.\n\n    See Also\n    --------\n    numpy.diag : Equivalent function for ndarrays.\n\n    Examples\n    --------\n\n    Create an array with negative values masked:\n\n    >>> import numpy as np\n    >>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])\n    >>> masked_x = np.ma.masked_array(x, mask=x < 0)\n    >>> masked_x\n    masked_array(\n      data=[[11.2, --, 18.0],\n            [0.801, --, 12.0],\n            [7.0, 33.0, --]],\n      mask=[[False,  True, False],\n            [False,  True, False],\n            [False, False,  True]],\n      fill_value=1e+20)\n\n    Isolate the main diagonal from the masked array:\n\n    >>> np.ma.diag(masked_x)\n    masked_array(data=[11.2, --, --],\n                 mask=[False,  True,  True],\n           fill_value=1e+20)\n\n    Isolate the first diagonal below the main diagonal:\n\n    >>> np.ma.diag(masked_x, -1)\n    masked_array(data=[0.801, 33.0],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    output = np.diag(v, k).view(MaskedArray)\n    if getmask(v) is not nomask:\n        output._mask = np.diag(v._mask, k)\n    return output", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMathMethods():\n\tdef test_diag(self):\n\t    x = arange(9).reshape((3, 3))\n\t    x[1, 1] = masked\n\t    out = np.diag(x)\n\t    assert_equal(out, [0, 4, 8])\n\t    out = diag(x)\n\t    assert_equal(out, [0, 4, 8])\n\t    assert_equal(out.mask, [0, 1, 0])\n\t    out = diag(out)\n\t    control = array([[0, 0, 0], [0, 4, 0], [0, 0, 8]], mask=[[0, 0, 0], [0,\n\t        1, 0], [0, 0, 0]])\n\t    assert_equal(out, control)\n\t\nTestMaskedArrayMathMethods().test_diag()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef diag(v, k=0): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "requires_memory", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "response": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef requires_memory(free_bytes):\n    \"\"\"Decorator to skip a test if not enough memory is available\"\"\"\n    import pytest\n\n    def decorator(func):\n\n        @wraps(func)\n        def wrapper(*a, **kw):\n            msg = check_free_memory(free_bytes)\n            if msg is not None:\n                pytest.skip(msg)\n            try:\n                return func(*a, **kw)\n            except MemoryError:\n                pytest.xfail('MemoryError raised')\n        return wrapper\n    return decorator", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayMathMethods():\n\t@requires_memory(free_bytes=2 * 10000 * 1000 * 2)\n\tdef test_mean_overflow(self):\n\t    a = masked_array(np.full((10000, 10000), 65535, dtype=np.uint16), mask=\n\t        np.zeros((10000, 10000)))\n\t    assert_equal(a.mean(), 65535.0)\n\t\nTestMaskedArrayMathMethods().test_mean_overflow()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import copy\nimport sys\nimport gc\nimport tempfile\nimport pytest\nfrom os import path\nfrom io import BytesIO\nfrom itertools import chain\nimport pickle\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import _assert_valid_refcount\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.testing._private.utils import requires_memory\nfrom math import radians\nfrom hashlib import sha256\nimport re\nimport operator as op\n\nclass TestRegression():\n\t@pytest.mark.skipif(sys.maxsize < 2 ** 31 + 1, reason='overflows 32-bit python'\n\t    )\n\t@requires_memory(free_bytes=9000000000.0)\n\tdef test_dot_big_stride(self):\n\t    int32_max = np.iinfo(np.int32).max\n\t    n = int32_max + 3\n\t    a = np.empty([n], dtype=np.float32)\n\t    b = a[::n - 1]\n\t    b[...] = 1\n\t    assert b.strides[0] > int32_max * b.dtype.itemsize\n\t    assert np.dot(b, b) == 2.0\n\t\nTestRegression().test_dot_big_stride()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_regression.py"}], "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef requires_memory(free_bytes): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_equal", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_equal(x, value, copy=True):\n    \"\"\"\n    Mask an array where equal to a given value.\n\n    Return a MaskedArray, masked where the data in array `x` are\n    equal to `value`. The fill_value of the returned MaskedArray\n    is set to `value`.\n\n    For floating point arrays, consider using ``masked_values(x, value)``.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n    masked_values : Mask using floating point equality.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> a = np.arange(4)\n    >>> a\n    array([0, 1, 2, 3])\n    >>> ma.masked_equal(a, 2)\n    masked_array(data=[0, 1, --, 3],\n                 mask=[False, False,  True, False],\n           fill_value=2)\n\n    \"\"\"\n    output = masked_where(equal(x, value), x, copy=copy)\n    output.fill_value = value\n    return output", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_equal_wlist(self):\n\t    x = [1, 2, 3]\n\t    mx = masked_equal(x, 3)\n\t    assert_equal(mx, x)\n\t    assert_equal(mx._mask, [0, 0, 1])\n\t    mx = masked_not_equal(x, 3)\n\t    assert_equal(mx, x)\n\t    assert_equal(mx._mask, [1, 1, 0])\n\t\nTestMaskedArrayFunctions().test_masked_equal_wlist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_equal_fill_value(self):\n\t    x = [1, 2, 3]\n\t    mx = masked_equal(x, 3)\n\t    assert_equal(mx._mask, [0, 0, 1])\n\t    assert_equal(mx.fill_value, 3)\n\t\nTestMaskedArrayFunctions().test_masked_equal_fill_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_condition(self):\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    x[2] = masked\n\t    assert_equal(masked_where(greater(x, 2), x), masked_greater(x, 2))\n\t    assert_equal(masked_where(greater_equal(x, 2), x), masked_greater_equal\n\t        (x, 2))\n\t    assert_equal(masked_where(less(x, 2), x), masked_less(x, 2))\n\t    assert_equal(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where(equal(x, 2), x), masked_equal(x, 2))\n\t    assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))\n\t    assert_equal(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3,\n\t        4, 5])\n\t\nTestMaskedArrayFunctions().test_masked_where_condition()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_where_shape_constraint(self):\n\t    a = arange(10)\n\t    with assert_raises(IndexError):\n\t        masked_equal(1, a)\n\t    test = masked_equal(a, 1)\n\t    assert_equal(test.mask, [0, 1, 0, 0, 0, 0, 0, 0, 0, 0])\n\t\nTestMaskedArrayFunctions().test_masked_where_shape_constraint()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_equal(x, value, copy=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_outside", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_outside(x, v1, v2, copy=True):\n    \"\"\"\n    Mask an array outside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` outside\n    the interval [v1,v2] (x < v1)|(x > v2).\n    The boundaries `v1` and `v2` can be given in either order.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The array `x` is prefilled with its filling value.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_outside(x, -0.3, 0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_outside(x, 0.3, -0.3)\n    masked_array(data=[--, --, 0.01, 0.2, --, --],\n                 mask=[ True,  True, False, False,  True,  True],\n           fill_value=1e+20)\n\n    \"\"\"\n    if v2 < v1:\n        v1, v2 = v2, v1\n    xf = filled(x)\n    condition = (xf < v1) | (xf > v2)\n    return masked_where(condition, x, copy=copy)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_outside(x, v1, v2, copy=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_inside", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef masked_inside(x, v1, v2, copy=True):\n    \"\"\"\n    Mask an array inside a given interval.\n\n    Shortcut to ``masked_where``, where `condition` is True for `x` inside\n    the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`\n    can be given in either order.\n\n    See Also\n    --------\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The array `x` is prefilled with its filling value.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n    >>> ma.masked_inside(x, -0.3, 0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)\n\n    The order of `v1` and `v2` doesn't matter.\n\n    >>> ma.masked_inside(x, 0.3, -0.3)\n    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n                 mask=[False, False,  True,  True, False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    if v2 < v1:\n        v1, v2 = v2, v1\n    xf = filled(x)\n    condition = (xf >= v1) & (xf <= v2)\n    return masked_where(condition, x, copy=copy)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_masked_otherfunctions(self):\n\t    assert_equal(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4])\n\t    assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])\n\t    assert_equal(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 1, 1, 0])\n\t    assert_equal(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]),\n\t        1, 3).mask, [1, 1, 0, 0, 1])\n\t    assert_equal(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), \n\t        2).mask, [1, 0, 1, 0, 0])\n\t    assert_equal(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, \n\t        0]), 2).mask, [1, 0, 1, 0, 1])\n\t\nTestMaskedArrayFunctions().test_masked_otherfunctions()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef masked_inside(x, v1, v2, copy=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "power", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef power(a, b, third=None):\n    \"\"\"\n    Returns element-wise base array raised to power from second array.\n\n    This is the masked array version of `numpy.power`. For details see\n    `numpy.power`.\n\n    See Also\n    --------\n    numpy.power\n\n    Notes\n    -----\n    The *out* argument to `numpy.power` is not supported, `third` has to be\n    None.\n\n    Examples\n    --------\n    >>> import numpy.ma as ma\n    >>> x = [11.2, -3.973, 0.801, -1.41]\n    >>> mask = [0, 0, 0, 1]\n    >>> masked_x = ma.masked_array(x, mask)\n    >>> masked_x\n    masked_array(data=[11.2, -3.973, 0.801, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, 2)\n    masked_array(data=[125.43999999999998, 15.784728999999999,\n                   0.6416010000000001, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> y = [-0.5, 2, 0, 17]\n    >>> masked_y = ma.masked_array(y, mask)\n    >>> masked_y\n    masked_array(data=[-0.5, 2.0, 0.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n    >>> ma.power(masked_x, masked_y)\n    masked_array(data=[0.2988071523335984, 15.784728999999999, 1.0, --],\n             mask=[False, False, False,  True],\n       fill_value=1e+20)\n\n    \"\"\"\n    if third is not None:\n        raise MaskError('3-argument power not supported.')\n    ma = getmask(a)\n    mb = getmask(b)\n    m = mask_or(ma, mb)\n    fa = getdata(a)\n    fb = getdata(b)\n    if isinstance(a, MaskedArray):\n        basetype = type(a)\n    else:\n        basetype = MaskedArray\n    with np.errstate(divide='ignore', invalid='ignore'):\n        result = np.where(m, fa, umath.power(fa, fb)).view(basetype)\n    result._update_from(a)\n    invalid = np.logical_not(np.isfinite(result.view(ndarray)))\n    if m is not nomask:\n        if not result.ndim:\n            return masked\n        result._mask = np.logical_or(m, invalid)\n    if invalid.any():\n        if not result.ndim:\n            return masked\n        elif result._mask is nomask:\n            result._mask = invalid\n        result._data[invalid] = result.fill_value\n    return result", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_power(self):\n\t    x = -1.1\n\t    assert_almost_equal(power(x, 2.0), 1.21)\n\t    assert_(power(x, masked) is masked)\n\t    x = array([-1.1, -1.1, 1.1, 1.1, 0.0])\n\t    b = array([0.5, 2.0, 0.5, 2.0, -1.0], mask=[0, 0, 0, 0, 1])\n\t    y = power(x, b)\n\t    assert_almost_equal(y, [0, 1.21, 1.04880884817, 1.21, 0.0])\n\t    assert_equal(y._mask, [1, 0, 0, 0, 1])\n\t    b.mask = nomask\n\t    y = power(x, b)\n\t    assert_equal(y._mask, [1, 0, 0, 0, 1])\n\t    z = x ** b\n\t    assert_equal(z._mask, y._mask)\n\t    assert_almost_equal(z, y)\n\t    assert_almost_equal(z._data, y._data)\n\t    x **= b\n\t    assert_equal(x._mask, y._mask)\n\t    assert_almost_equal(x, y)\n\t    assert_almost_equal(x._data, y._data)\n\t\nTestMaskedArrayFunctions().test_power()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef power(a, b, third=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "choose", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef choose(indices, choices, out=None, mode='raise'):\n    \"\"\"\n    Use an index array to construct a new array from a list of choices.\n\n    Given an array of integers and a list of n choice arrays, this method\n    will create a new array that merges each of the choice arrays.  Where a\n    value in `index` is i, the new array will have the value that choices[i]\n    contains in the same place.\n\n    Parameters\n    ----------\n    indices : ndarray of ints\n        This array must contain integers in ``[0, n-1]``, where n is the\n        number of choices.\n    choices : sequence of arrays\n        Choice arrays. The index array and all of the choices should be\n        broadcastable to the same shape.\n    out : array, optional\n        If provided, the result will be inserted into this array. It should\n        be of the appropriate shape and `dtype`.\n    mode : {'raise', 'wrap', 'clip'}, optional\n        Specifies how out-of-bounds indices will behave.\n\n        * 'raise' : raise an error\n        * 'wrap' : wrap around\n        * 'clip' : clip to the range\n\n    Returns\n    -------\n    merged_array : array\n\n    See Also\n    --------\n    choose : equivalent function\n\n    Examples\n    --------\n    >>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n    >>> a = np.array([2, 1, 0])\n    >>> np.ma.choose(a, choice)\n    masked_array(data=[3, 2, 1],\n                 mask=False,\n           fill_value=999999)\n\n    \"\"\"\n\n    def fmask(x):\n        \"\"\"Returns the filled array, or True if masked.\"\"\"\n        if x is masked:\n            return True\n        return filled(x)\n\n    def nmask(x):\n        \"\"\"Returns the mask, True if ``masked``, False if ``nomask``.\"\"\"\n        if x is masked:\n            return True\n        return getmask(x)\n    c = filled(indices, 0)\n    masks = [nmask(x) for x in choices]\n    data = [fmask(x) for x in choices]\n    outputmask = np.choose(c, masks, mode=mode)\n    outputmask = make_mask(mask_or(outputmask, getmask(indices)), copy=\n        False, shrink=True)\n    d = np.choose(c, data, mode=mode, out=out).view(MaskedArray)\n    if out is not None:\n        if isinstance(out, MaskedArray):\n            out.__setmask__(outputmask)\n        return out\n    d.__setmask__(outputmask)\n    return d", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_choose(self):\n\t    choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, \n\t        32, 33]]\n\t    chosen = choose([2, 3, 1, 0], choices)\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    chosen = choose([2, 4, 1, 0], choices, mode='clip')\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    chosen = choose([2, 4, 1, 0], choices, mode='wrap')\n\t    assert_equal(chosen, array([20, 1, 12, 3]))\n\t    indices_ = array([2, 4, 1, 0], mask=[1, 0, 0, 1])\n\t    chosen = choose(indices_, choices, mode='wrap')\n\t    assert_equal(chosen, array([99, 1, 12, 99]))\n\t    assert_equal(chosen.mask, [1, 0, 0, 1])\n\t    choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 0],\n\t        [0, 0, 0, 0]])\n\t    indices_ = [2, 3, 1, 0]\n\t    chosen = choose(indices_, choices, mode='wrap')\n\t    assert_equal(chosen, array([20, 31, 12, 3]))\n\t    assert_equal(chosen.mask, [1, 0, 0, 1])\n\t\nTestMaskedArrayFunctions().test_choose()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}, {"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_choose_with_out(self):\n\t    choices = [[0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, \n\t        32, 33]]\n\t    store = empty(4, dtype=int)\n\t    chosen = choose([2, 3, 1, 0], choices, out=store)\n\t    assert_equal(store, array([20, 31, 12, 3]))\n\t    assert_(store is chosen)\n\t    store = empty(4, dtype=int)\n\t    indices_ = array([2, 3, 1, 0], mask=[1, 0, 0, 1])\n\t    chosen = choose(indices_, choices, mode='wrap', out=store)\n\t    assert_equal(store, array([99, 31, 12, 99]))\n\t    assert_equal(store.mask, [1, 0, 0, 1])\n\t    choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 0],\n\t        [0, 0, 0, 0]])\n\t    indices_ = [2, 3, 1, 0]\n\t    store = empty(4, dtype=int).view(ndarray)\n\t    chosen = choose(indices_, choices, mode='wrap', out=store)\n\t    assert_equal(store, array([999999, 31, 12, 999999]))\n\t\nTestMaskedArrayFunctions().test_choose_with_out()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef choose(indices, choices, out=None, mode='raise'): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "flatten_mask", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef flatten_mask(mask):\n    \"\"\"\n    Returns a completely flattened version of the mask, where nested fields\n    are collapsed.\n\n    Parameters\n    ----------\n    mask : array_like\n        Input array, which will be interpreted as booleans.\n\n    Returns\n    -------\n    flattened_mask : ndarray of bools\n        The flattened input.\n\n    Examples\n    --------\n    >>> mask = np.array([0, 0, 1])\n    >>> np.ma.flatten_mask(mask)\n    array([False, False,  True])\n\n    >>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n    >>> np.ma.flatten_mask(mask)\n    array([False, False, False,  True])\n\n    >>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n    >>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)\n    >>> np.ma.flatten_mask(mask)\n    array([False, False, False, False, False,  True])\n\n    \"\"\"\n\n    def _flatmask(mask):\n        \"\"\"Flatten the mask and returns a (maybe nested) sequence of booleans.\"\"\"\n        mnames = mask.dtype.names\n        if mnames is not None:\n            return [flatten_mask(mask[name]) for name in mnames]\n        else:\n            return mask\n\n    def _flatsequence(sequence):\n        \"\"\"Generates a flattened version of the sequence.\"\"\"\n        try:\n            for element in sequence:\n                if hasattr(element, '__iter__'):\n                    yield from _flatsequence(element)\n                else:\n                    yield element\n        except TypeError:\n            yield sequence\n    mask = np.asarray(mask)\n    flattened = _flatsequence(_flatmask(mask))\n    return np.array([_ for _ in flattened], dtype=bool)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_flatten_mask(self):\n\t    mask = np.array([0, 0, 1], dtype=bool)\n\t    assert_equal(flatten_mask(mask), mask)\n\t    mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])\n\t    test = flatten_mask(mask)\n\t    control = np.array([0, 0, 0, 1], dtype=bool)\n\t    assert_equal(test, control)\n\t    mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]\n\t    data = [(0, (0, 0)), (0, (0, 1))]\n\t    mask = np.array(data, dtype=mdtype)\n\t    test = flatten_mask(mask)\n\t    control = np.array([0, 0, 0, 0, 0, 1], dtype=bool)\n\t    assert_equal(test, control)\n\t\nTestMaskedArrayFunctions().test_flatten_mask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef flatten_mask(mask): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "reshape", "method_path": "../srcdata/Computation/numpy/numpy/ma/core.py", "response": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\ndef reshape(a, new_shape, order='C'):\n    \"\"\"\n    Returns an array containing the same data with a new shape.\n\n    Refer to `MaskedArray.reshape` for full documentation.\n\n    See Also\n    --------\n    MaskedArray.reshape : equivalent function\n\n    \"\"\"\n    try:\n        return a.reshape(new_shape, order=order)\n    except AttributeError:\n        _tmp = np.asarray(a).reshape(new_shape, order=order)\n        return _tmp.view(MaskedArray)", "test_code_list": [{"test_code": "import sys\nimport warnings\nimport copy\nimport operator\nimport itertools\nimport textwrap\nimport pickle\nfrom functools import reduce\nimport pytest\nimport numpy as np\nimport numpy.ma.core\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy import ndarray\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.testutils import assert_equal_records\nfrom numpy.ma.testutils import fail_if_equal\nfrom numpy.ma.testutils import assert_not_equal\nfrom numpy.ma.testutils import assert_mask_equal\nfrom numpy.ma.core import MAError\nfrom numpy.ma.core import MaskError\nfrom numpy.ma.core import MaskType\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import abs\nfrom numpy.ma.core import absolute\nfrom numpy.ma.core import add\nfrom numpy.ma.core import all\nfrom numpy.ma.core import allclose\nfrom numpy.ma.core import allequal\nfrom numpy.ma.core import alltrue\nfrom numpy.ma.core import angle\nfrom numpy.ma.core import anom\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import arccos\nfrom numpy.ma.core import arccosh\nfrom numpy.ma.core import arctan2\nfrom numpy.ma.core import arcsin\nfrom numpy.ma.core import arctan\nfrom numpy.ma.core import argsort\nfrom numpy.ma.core import array\nfrom numpy.ma.core import asarray\nfrom numpy.ma.core import choose\nfrom numpy.ma.core import concatenate\nfrom numpy.ma.core import conjugate\nfrom numpy.ma.core import cos\nfrom numpy.ma.core import cosh\nfrom numpy.ma.core import count\nfrom numpy.ma.core import default_fill_value\nfrom numpy.ma.core import diag\nfrom numpy.ma.core import divide\nfrom numpy.ma.core import doc_note\nfrom numpy.ma.core import empty\nfrom numpy.ma.core import empty_like\nfrom numpy.ma.core import equal\nfrom numpy.ma.core import exp\nfrom numpy.ma.core import flatten_mask\nfrom numpy.ma.core import filled\nfrom numpy.ma.core import fix_invalid\nfrom numpy.ma.core import flatten_structured_array\nfrom numpy.ma.core import fromflex\nfrom numpy.ma.core import getmask\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import greater\nfrom numpy.ma.core import greater_equal\nfrom numpy.ma.core import identity\nfrom numpy.ma.core import inner\nfrom numpy.ma.core import isMaskedArray\nfrom numpy.ma.core import less\nfrom numpy.ma.core import less_equal\nfrom numpy.ma.core import log\nfrom numpy.ma.core import log10\nfrom numpy.ma.core import make_mask\nfrom numpy.ma.core import make_mask_descr\nfrom numpy.ma.core import mask_or\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import masked_equal\nfrom numpy.ma.core import masked_greater\nfrom numpy.ma.core import masked_greater_equal\nfrom numpy.ma.core import masked_inside\nfrom numpy.ma.core import masked_less\nfrom numpy.ma.core import masked_less_equal\nfrom numpy.ma.core import masked_not_equal\nfrom numpy.ma.core import masked_outside\nfrom numpy.ma.core import masked_print_option\nfrom numpy.ma.core import masked_values\nfrom numpy.ma.core import masked_where\nfrom numpy.ma.core import max\nfrom numpy.ma.core import maximum\nfrom numpy.ma.core import maximum_fill_value\nfrom numpy.ma.core import min\nfrom numpy.ma.core import minimum\nfrom numpy.ma.core import minimum_fill_value\nfrom numpy.ma.core import mod\nfrom numpy.ma.core import multiply\nfrom numpy.ma.core import mvoid\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import not_equal\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import ones_like\nfrom numpy.ma.core import outer\nfrom numpy.ma.core import power\nfrom numpy.ma.core import product\nfrom numpy.ma.core import put\nfrom numpy.ma.core import putmask\nfrom numpy.ma.core import ravel\nfrom numpy.ma.core import repeat\nfrom numpy.ma.core import reshape\nfrom numpy.ma.core import resize\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import sin\nfrom numpy.ma.core import sinh\nfrom numpy.ma.core import sometrue\nfrom numpy.ma.core import sort\nfrom numpy.ma.core import sqrt\nfrom numpy.ma.core import subtract\nfrom numpy.ma.core import sum\nfrom numpy.ma.core import take\nfrom numpy.ma.core import tan\nfrom numpy.ma.core import tanh\nfrom numpy.ma.core import transpose\nfrom numpy.ma.core import where\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import zeros_like\nimport datetime\nfrom copy import deepcopy\nfrom io import BytesIO\n\nclass TestMaskedArrayFunctions():\n\tdef test_on_ndarray(self):\n\t    a = np.array([1, 2, 3, 4])\n\t    m = array(a, mask=False)\n\t    test = anom(a)\n\t    assert_equal(test, m.anom())\n\t    test = reshape(a, (2, 2))\n\t    assert_equal(test, m.reshape(2, 2))\n\t\nTestMaskedArrayFunctions().test_on_ndarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_core.py"}], "method_code_mask": "import builtins\nimport inspect\nimport operator\nimport warnings\nimport textwrap\nimport re\nfrom functools import reduce\nfrom typing import Dict\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import amax\nfrom numpy import amin\nfrom numpy import iscomplexobj\nfrom numpy import bool_\nfrom numpy import _NoValue\nfrom numpy import angle\nfrom numpy import array as narray\nfrom numpy import expand_dims\nfrom numpy import iinfo\nfrom numpy import finfo\nfrom copy import deepcopy\n\n\ndef reshape(a, new_shape, order='C'): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "masked_all_like", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef masked_all_like(arr):\n    \"\"\"\n    Empty masked array with the properties of an existing array.\n\n    Return an empty masked array of the same shape and dtype as\n    the array `arr`, where all the data are masked.\n\n    Parameters\n    ----------\n    arr : ndarray\n        An array describing the shape and dtype of the required MaskedArray.\n\n    Returns\n    -------\n    a : MaskedArray\n        A masked array with all data masked.\n\n    Raises\n    ------\n    AttributeError\n        If `arr` doesn't have a shape attribute (i.e. not an ndarray)\n\n    See Also\n    --------\n    masked_all : Empty masked array with all elements masked.\n\n    Notes\n    -----\n    Unlike other masked array creation functions (e.g. `numpy.ma.zeros_like`,\n    `numpy.ma.ones_like`, `numpy.ma.full_like`), `masked_all_like` does not\n    initialize the values of the array, and may therefore be marginally\n    faster. However, the values stored in the newly allocated array are\n    arbitrary. For reproducible behavior, be sure to set each element of the\n    array before reading.\n\n    Examples\n    --------\n    >>> arr = np.zeros((2, 3), dtype=np.float32)\n    >>> arr\n    array([[0., 0., 0.],\n           [0., 0., 0.]], dtype=float32)\n    >>> np.ma.masked_all_like(arr)\n    masked_array(\n      data=[[--, --, --],\n            [--, --, --]],\n      mask=[[ True,  True,  True],\n            [ True,  True,  True]],\n      fill_value=np.float64(1e+20),\n      dtype=float32)\n\n    The dtype of the masked array matches the dtype of `arr`.\n\n    >>> arr.dtype\n    dtype('float32')\n    >>> np.ma.masked_all_like(arr).dtype\n    dtype('float32')\n\n    \"\"\"\n    a = np.empty_like(arr).view(MaskedArray)\n    a._mask = np.ones(a.shape, dtype=make_mask_descr(a.dtype))\n    return a", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_masked_all_like(self):\n\t    base = array([1, 2], dtype=float)\n\t    test = masked_all_like(base)\n\t    control = array([1, 1], mask=[1, 1], dtype=float)\n\t    assert_equal(test, control)\n\t    dt = np.dtype({'names': ['a', 'b'], 'formats': ['f', 'f']})\n\t    base = array([(0, 0), (0, 0)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    test = masked_all_like(base)\n\t    control = array([(10, 10), (10, 10)], mask=[(1, 1), (1, 1)], dtype=dt)\n\t    assert_equal(test, control)\n\t    dt = np.dtype([('a', 'f'), ('b', [('ba', 'f'), ('bb', 'f')])])\n\t    control = array([(1, (1, 1)), (1, (1, 1))], mask=[(1, (1, 1)), (1, (1, \n\t        1))], dtype=dt)\n\t    test = masked_all_like(control)\n\t    assert_equal(test, control)\n\t\nTestGeneric().test_masked_all_like()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef masked_all_like(arr): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "flatnotmasked_contiguous", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef flatnotmasked_contiguous(a):\n    \"\"\"\n    Find contiguous unmasked data in a masked array.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n\n    Returns\n    -------\n    slice_list : list\n        A sorted sequence of `slice` objects (start index, end index).\n\n        .. versionchanged:: 1.15.0\n            Now returns an empty list instead of None for a fully masked array\n\n    See Also\n    --------\n    flatnotmasked_edges, notmasked_contiguous, notmasked_edges\n    clump_masked, clump_unmasked\n\n    Notes\n    -----\n    Only accepts 2-D arrays at most.\n\n    Examples\n    --------\n    >>> a = np.ma.arange(10)\n    >>> np.ma.flatnotmasked_contiguous(a)\n    [slice(0, 10, None)]\n\n    >>> mask = (a < 3) | (a > 8) | (a == 5)\n    >>> a[mask] = np.ma.masked\n    >>> np.array(a[~a.mask])\n    array([3, 4, 6, 7, 8])\n\n    >>> np.ma.flatnotmasked_contiguous(a)\n    [slice(3, 5, None), slice(6, 9, None)]\n    >>> a[:] = np.ma.masked\n    >>> np.ma.flatnotmasked_contiguous(a)\n    []\n\n    \"\"\"\n    m = getmask(a)\n    if m is nomask:\n        return [slice(0, a.size)]\n    i = 0\n    result = []\n    for k, g in itertools.groupby(m.ravel()):\n        n = len(list(g))\n        if not k:\n            result.append(slice(i, i + n))\n        i += n\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestGeneric():\n\tdef test_flatnotmasked_contiguous(self):\n\t    a = arange(10)\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [slice(0, a.size)])\n\t    a.mask = np.zeros(10, dtype=bool)\n\t    assert_equal(test, [slice(0, a.size)])\n\t    a[(a < 3) | (a > 8) | (a == 5)] = masked\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [slice(3, 5), slice(6, 9)])\n\t    a[:] = masked\n\t    test = flatnotmasked_contiguous(a)\n\t    assert_equal(test, [])\n\t\nTestGeneric().test_flatnotmasked_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef flatnotmasked_contiguous(a): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "average", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef average(a, axis=None, weights=None, returned=False, *, keepdims=np._NoValue\n    ):\n    \"\"\"\n    Return the weighted average of array over the given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        Data to be averaged.\n        Masked entries are not taken into account in the computation.\n    axis : None or int or tuple of ints, optional\n        Axis or axes along which to average `a`.  The default,\n        `axis=None`, will average over all of the elements of the input array.\n        If axis is a tuple of ints, averaging is performed on all of the axes\n        specified in the tuple instead of a single axis or all the axes as\n        before.\n    weights : array_like, optional\n        An array of weights associated with the values in `a`. Each value in\n        `a` contributes to the average according to its associated weight.\n        The array of weights must be the same shape as `a` if no axis is\n        specified, otherwise the weights must have dimensions and shape\n        consistent with `a` along the specified axis.\n        If `weights=None`, then all data in `a` are assumed to have a\n        weight equal to one.\n        The calculation is::\n\n            avg = sum(a * weights) / sum(weights)\n\n        where the sum is over all included elements.\n        The only constraint on the values of `weights` is that `sum(weights)`\n        must not be 0.\n    returned : bool, optional\n        Flag indicating whether a tuple ``(result, sum of weights)``\n        should be returned as output (True), or just the result (False).\n        Default is False.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the original `a`.\n        *Note:* `keepdims` will not work with instances of `numpy.matrix`\n        or other classes whose methods do not support `keepdims`.\n\n        .. versionadded:: 1.23.0\n\n    Returns\n    -------\n    average, [sum_of_weights] : (tuple of) scalar or MaskedArray\n        The average along the specified axis. When returned is `True`,\n        return a tuple with the average as the first element and the sum\n        of the weights as the second element. The return type is `np.float64`\n        if `a` is of integer type and floats smaller than `float64`, or the\n        input data-type, otherwise. If returned, `sum_of_weights` is always\n        `float64`.\n\n    Raises\n    ------\n    ZeroDivisionError\n        When all weights along axis are zero. See `numpy.ma.average` for a\n        version robust to this type of error.\n    TypeError\n        When `weights` does not have the same shape as `a`, and `axis=None`.\n    ValueError\n        When `weights` does not have dimensions and shape consistent with `a`\n        along specified `axis`.\n\n    Examples\n    --------\n    >>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n    >>> np.ma.average(a, weights=[3, 1, 0, 0])\n    1.25\n\n    >>> x = np.ma.arange(6.).reshape(3, 2)\n    >>> x\n    masked_array(\n      data=[[0., 1.],\n            [2., 3.],\n            [4., 5.]],\n      mask=False,\n      fill_value=1e+20)\n    >>> data = np.arange(8).reshape((2, 2, 2))\n    >>> data\n    array([[[0, 1],\n            [2, 3]],\n           [[4, 5],\n            [6, 7]]])\n    >>> np.ma.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])\n    masked_array(data=[3.4, 4.4],\n             mask=[False, False],\n       fill_value=1e+20)\n    >>> np.ma.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])\n    Traceback (most recent call last):\n        ...\n    ValueError: Shape of weights must be consistent\n    with shape of a along specified axis.\n\n    >>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n    ...                                 returned=True)\n    >>> avg\n    masked_array(data=[2.6666666666666665, 3.6666666666666665],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    With ``keepdims=True``, the following result has shape (3, 1).\n\n    >>> np.ma.average(x, axis=1, keepdims=True)\n    masked_array(\n      data=[[0.5],\n            [2.5],\n            [4.5]],\n      mask=False,\n      fill_value=1e+20)\n    \"\"\"\n    a = asarray(a)\n    m = getmask(a)\n    if axis is not None:\n        axis = normalize_axis_tuple(axis, a.ndim, argname='axis')\n    if keepdims is np._NoValue:\n        keepdims_kw = {}\n    else:\n        keepdims_kw = {'keepdims': keepdims}\n    if weights is None:\n        avg = a.mean(axis, **keepdims_kw)\n        scl = avg.dtype.type(a.count(axis))\n    else:\n        wgt = asarray(weights)\n        if issubclass(a.dtype.type, (np.integer, np.bool)):\n            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')\n        else:\n            result_dtype = np.result_type(a.dtype, wgt.dtype)\n        if a.shape != wgt.shape:\n            if axis is None:\n                raise TypeError(\n                    'Axis must be specified when shapes of a and weights differ.'\n                    )\n            if wgt.shape != tuple(a.shape[ax] for ax in axis):\n                raise ValueError(\n                    'Shape of weights must be consistent with shape of a along specified axis.'\n                    )\n            wgt = wgt.transpose(np.argsort(axis))\n            wgt = wgt.reshape(tuple(s if ax in axis else 1 for ax, s in\n                enumerate(a.shape)))\n        if m is not nomask:\n            wgt = wgt * ~a.mask\n            wgt.mask |= a.mask\n        scl = wgt.sum(axis=axis, dtype=result_dtype, **keepdims_kw)\n        avg = np.multiply(a, wgt, dtype=result_dtype).sum(axis, **keepdims_kw\n            ) / scl\n    if returned:\n        if scl.shape != avg.shape:\n            scl = np.broadcast_to(scl, avg.shape).copy()\n        return avg, scl\n    else:\n        return avg", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage1(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[True, False, False, False])\n\t    assert_equal(2.0, average(ott, axis=0))\n\t    assert_equal(2.0, average(ott, weights=[1.0, 1.0, 2.0, 1.0]))\n\t    result, wts = average(ott, weights=[1.0, 1.0, 2.0, 1.0], returned=True)\n\t    assert_equal(2.0, result)\n\t    assert_(wts == 4.0)\n\t    ott[:] = masked\n\t    assert_equal(average(ott, axis=0).mask, [True])\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[True, False, False, False])\n\t    ott = ott.reshape(2, 2)\n\t    ott[:, 1] = masked\n\t    assert_equal(average(ott, axis=0), [2.0, 0.0])\n\t    assert_equal(average(ott, axis=1).mask[0], [True])\n\t    assert_equal([2.0, 0.0], average(ott, axis=0))\n\t    result, wts = average(ott, axis=0, returned=True)\n\t    assert_equal(wts, [1.0, 0.0])\n\t\nTestAverage().test_testAverage1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage2(self):\n\t    w1 = [0, 1, 1, 1, 1, 0]\n\t    w2 = [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1]]\n\t    x = arange(6, dtype=np.float64)\n\t    assert_equal(average(x, axis=0), 2.5)\n\t    assert_equal(average(x, axis=0, weights=w1), 2.5)\n\t    y = array([arange(6, dtype=np.float64), 2.0 * arange(6)])\n\t    assert_equal(average(y, None), np.add.reduce(np.arange(6)) * 3.0 / 12.0)\n\t    assert_equal(average(y, axis=0), np.arange(6) * 3.0 / 2.0)\n\t    assert_equal(average(y, axis=1), [average(x, axis=0), average(x, axis=0\n\t        ) * 2.0])\n\t    assert_equal(average(y, None, weights=w2), 20.0 / 6.0)\n\t    assert_equal(average(y, axis=0, weights=w2), [0.0, 1.0, 2.0, 3.0, 4.0, \n\t        10.0])\n\t    assert_equal(average(y, axis=1), [average(x, axis=0), average(x, axis=0\n\t        ) * 2.0])\n\t    m1 = zeros(6)\n\t    m2 = [0, 0, 1, 1, 0, 0]\n\t    m3 = [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]]\n\t    m4 = ones(6)\n\t    m5 = [0, 1, 1, 1, 1, 1]\n\t    assert_equal(average(masked_array(x, m1), axis=0), 2.5)\n\t    assert_equal(average(masked_array(x, m2), axis=0), 2.5)\n\t    assert_equal(average(masked_array(x, m4), axis=0).mask, [True])\n\t    assert_equal(average(masked_array(x, m5), axis=0), 0.0)\n\t    assert_equal(count(average(masked_array(x, m4), axis=0)), 0)\n\t    z = masked_array(y, m3)\n\t    assert_equal(average(z, None), 20.0 / 6.0)\n\t    assert_equal(average(z, axis=0), [0.0, 1.0, 99.0, 99.0, 4.0, 7.5])\n\t    assert_equal(average(z, axis=1), [2.5, 5.0])\n\t    assert_equal(average(z, axis=0, weights=w2), [0.0, 1.0, 99.0, 99.0, 4.0,\n\t        10.0])\n\t\nTestAverage().test_testAverage2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_testAverage3(self):\n\t    a = arange(6)\n\t    b = arange(6) * 3\n\t    r1, w1 = average([[a, b], [b, a]], axis=1, returned=True)\n\t    assert_equal(shape(r1), shape(w1))\n\t    assert_equal(r1.shape, w1.shape)\n\t    r2, w2 = average(ones((2, 2, 3)), axis=0, weights=[3, 1], returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), weights=ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    a2d = array([[1, 2], [0, 4]], float)\n\t    a2dm = masked_array(a2d, [[False, False], [True, False]])\n\t    a2da = average(a2d, axis=0)\n\t    assert_equal(a2da, [0.5, 3.0])\n\t    a2dma = average(a2dm, axis=0)\n\t    assert_equal(a2dma, [1.0, 3.0])\n\t    a2dma = average(a2dm, axis=None)\n\t    assert_equal(a2dma, 7.0 / 3.0)\n\t    a2dma = average(a2dm, axis=1)\n\t    assert_equal(a2dma, [1.5, 4.0])\n\t\nTestAverage().test_testAverage3()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_onintegers_with_mask(self):\n\t    a = average(array([1, 2]))\n\t    assert_equal(a, 1.5)\n\t    a = average(array([1, 2, 3, 4], mask=[False, False, True, True]))\n\t    assert_equal(a, 1.5)\n\t\nTestAverage().test_onintegers_with_mask()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestAverage():\n\tdef test_complex(self):\n\t    mask = np.array([[0, 0, 0, 1, 0], [0, 1, 0, 0, 0]], dtype=bool)\n\t    a = masked_array([[0, 1 + 2.0j, 3 + 4.0j, 5 + 6.0j, 7 + 8.0j], [9.0j, 0 +\n\t        1.0j, 2 + 3.0j, 4 + 5.0j, 7 + 7.0j]], mask=mask)\n\t    av = average(a)\n\t    expected = np.average(a.compressed())\n\t    assert_almost_equal(av.real, expected.real)\n\t    assert_almost_equal(av.imag, expected.imag)\n\t    av0 = average(a, axis=0)\n\t    expected0 = average(a.real, axis=0) + average(a.imag, axis=0) * 1.0j\n\t    assert_almost_equal(av0.real, expected0.real)\n\t    assert_almost_equal(av0.imag, expected0.imag)\n\t    av1 = average(a, axis=1)\n\t    expected1 = average(a.real, axis=1) + average(a.imag, axis=1) * 1.0j\n\t    assert_almost_equal(av1.real, expected1.real)\n\t    assert_almost_equal(av1.imag, expected1.imag)\n\t    wts = np.array([[0.5, 1.0, 2.0, 1.0, 0.5], [1.0, 1.0, 1.0, 1.0, 1.0]])\n\t    wav = average(a, weights=wts)\n\t    expected = np.average(a.compressed(), weights=wts[~mask])\n\t    assert_almost_equal(wav.real, expected.real)\n\t    assert_almost_equal(wav.imag, expected.imag)\n\t    wav0 = average(a, weights=wts, axis=0)\n\t    expected0 = average(a.real, weights=wts, axis=0) + average(a.imag,\n\t        weights=wts, axis=0) * 1.0j\n\t    assert_almost_equal(wav0.real, expected0.real)\n\t    assert_almost_equal(wav0.imag, expected0.imag)\n\t    wav1 = average(a, weights=wts, axis=1)\n\t    expected1 = average(a.real, weights=wts, axis=1) + average(a.imag,\n\t        weights=wts, axis=1) * 1.0j\n\t    assert_almost_equal(wav1.real, expected1.real)\n\t    assert_almost_equal(wav1.imag, expected1.imag)\n\t\nTestAverage().test_complex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef average(a, axis=None, weights=None, returned=False, *, keepdims=np._NoValue\n    ): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "notmasked_edges", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef notmasked_edges(a, axis=None):\n    \"\"\"\n    Find the indices of the first and last unmasked values along an axis.\n\n    If all values are masked, return None.  Otherwise, return a list\n    of two tuples, corresponding to the indices of the first and last\n    unmasked values respectively.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    axis : int, optional\n        Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array.\n\n    Returns\n    -------\n    edges : ndarray or list\n        An array of start and end indexes if there are any masked data in\n        the array. If there are no masked data in the array, `edges` is a\n        list of the first and last index.\n\n    See Also\n    --------\n    flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous\n    clump_masked, clump_unmasked\n\n    Examples\n    --------\n    >>> a = np.arange(9).reshape((3, 3))\n    >>> m = np.zeros_like(a)\n    >>> m[1:, 1:] = 1\n\n    >>> am = np.ma.array(a, mask=m)\n    >>> np.array(am[~am.mask])\n    array([0, 1, 2, 3, 6])\n\n    >>> np.ma.notmasked_edges(am)\n    array([0, 6])\n\n    \"\"\"\n    a = asarray(a)\n    if axis is None or a.ndim == 1:\n        return flatnotmasked_edges(a)\n    m = getmaskarray(a)\n    idx = array(np.indices(a.shape), mask=np.asarray([m] * a.ndim))\n    return [tuple([idx[i].min(axis).compressed() for i in range(a.ndim)]),\n        tuple([idx[i].max(axis).compressed() for i in range(a.ndim)])]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNotMasked():\n\tdef test_edges(self):\n\t    data = masked_array(np.arange(25).reshape(5, 5), mask=[[0, 0, 1, 0, 0],\n\t        [0, 0, 0, 1, 1], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 0]])\n\t    test = notmasked_edges(data, None)\n\t    assert_equal(test, [0, 24])\n\t    test = notmasked_edges(data, 0)\n\t    assert_equal(test[0], [(0, 0, 1, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(3, 3, 3, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data, 1)\n\t    assert_equal(test[0], [(0, 1, 2, 3, 4), (0, 0, 2, 0, 3)])\n\t    assert_equal(test[1], [(0, 1, 2, 3, 4), (4, 2, 4, 4, 4)])\n\t    test = notmasked_edges(data.data, None)\n\t    assert_equal(test, [0, 24])\n\t    test = notmasked_edges(data.data, 0)\n\t    assert_equal(test[0], [(0, 0, 0, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(4, 4, 4, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data.data, -1)\n\t    assert_equal(test[0], [(0, 1, 2, 3, 4), (0, 0, 0, 0, 0)])\n\t    assert_equal(test[1], [(0, 1, 2, 3, 4), (4, 4, 4, 4, 4)])\n\t    data[-2] = masked\n\t    test = notmasked_edges(data, 0)\n\t    assert_equal(test[0], [(0, 0, 1, 0, 0), (0, 1, 2, 3, 4)])\n\t    assert_equal(test[1], [(1, 1, 2, 4, 4), (0, 1, 2, 3, 4)])\n\t    test = notmasked_edges(data, -1)\n\t    assert_equal(test[0], [(0, 1, 2, 4), (0, 0, 2, 3)])\n\t    assert_equal(test[1], [(0, 1, 2, 4), (4, 2, 4, 4)])\n\t\nTestNotMasked().test_edges()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef notmasked_edges(a, axis=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "notmasked_contiguous", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef notmasked_contiguous(a, axis=None):\n    \"\"\"\n    Find contiguous unmasked data in a masked array along the given axis.\n\n    Parameters\n    ----------\n    a : array_like\n        The input array.\n    axis : int, optional\n        Axis along which to perform the operation.\n        If None (default), applies to a flattened version of the array, and this\n        is the same as `flatnotmasked_contiguous`.\n\n    Returns\n    -------\n    endpoints : list\n        A list of slices (start and end indexes) of unmasked indexes\n        in the array.\n\n        If the input is 2d and axis is specified, the result is a list of lists.\n\n    See Also\n    --------\n    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges\n    clump_masked, clump_unmasked\n\n    Notes\n    -----\n    Only accepts 2-D arrays at most.\n\n    Examples\n    --------\n    >>> a = np.arange(12).reshape((3, 4))\n    >>> mask = np.zeros_like(a)\n    >>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n    >>> ma = np.ma.array(a, mask=mask)\n    >>> ma\n    masked_array(\n      data=[[0, --, 2, 3],\n            [--, --, --, 7],\n            [8, --, --, 11]],\n      mask=[[False,  True, False, False],\n            [ True,  True,  True, False],\n            [False,  True,  True, False]],\n      fill_value=999999)\n    >>> np.array(ma[~ma.mask])\n    array([ 0,  2,  3,  7, 8, 11])\n\n    >>> np.ma.notmasked_contiguous(ma)\n    [slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n    >>> np.ma.notmasked_contiguous(ma, axis=0)\n    [[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n    >>> np.ma.notmasked_contiguous(ma, axis=1)\n    [[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]\n\n    \"\"\"\n    a = asarray(a)\n    nd = a.ndim\n    if nd > 2:\n        raise NotImplementedError('Currently limited to at most 2D array.')\n    if axis is None or nd == 1:\n        return flatnotmasked_contiguous(a)\n    result = []\n    other = (axis + 1) % 2\n    idx = [0, 0]\n    idx[axis] = slice(None, None)\n    for i in range(a.shape[other]):\n        idx[other] = i\n        result.append(flatnotmasked_contiguous(a[tuple(idx)]))\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNotMasked():\n\tdef test_contiguous(self):\n\t    a = masked_array(np.arange(24).reshape(3, 8), mask=[[0, 0, 0, 0, 1, 1, \n\t        1, 1], [1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0]])\n\t    tmp = notmasked_contiguous(a, None)\n\t    assert_equal(tmp, [slice(0, 4, None), slice(16, 22, None), slice(23, 24,\n\t        None)])\n\t    tmp = notmasked_contiguous(a, 0)\n\t    assert_equal(tmp, [[slice(0, 1, None), slice(2, 3, None)], [slice(0, 1,\n\t        None), slice(2, 3, None)], [slice(0, 1, None), slice(2, 3, None)],\n\t        [slice(0, 1, None), slice(2, 3, None)], [slice(2, 3, None)], [slice\n\t        (2, 3, None)], [], [slice(2, 3, None)]])\n\t    tmp = notmasked_contiguous(a, 1)\n\t    assert_equal(tmp, [[slice(0, 4, None)], [], [slice(0, 6, None), slice(7,\n\t        8, None)]])\n\t\nTestNotMasked().test_contiguous()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef notmasked_contiguous(a, axis=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "compress_nd", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef compress_nd(x, axis=None):\n    \"\"\"Suppress slices from multiple dimensions which contain masked values.\n\n    Parameters\n    ----------\n    x : array_like, MaskedArray\n        The array to operate on. If not a MaskedArray instance (or if no array\n        elements are masked), `x` is interpreted as a MaskedArray with `mask`\n        set to `nomask`.\n    axis : tuple of ints or int, optional\n        Which dimensions to suppress slices from can be configured with this\n        parameter.\n        - If axis is a tuple of ints, those are the axes to suppress slices from.\n        - If axis is an int, then that is the only axis to suppress slices from.\n        - If axis is None, all axis are selected.\n\n    Returns\n    -------\n    compress_array : ndarray\n        The compressed array.\n\n    Examples\n    --------\n    >>> arr = [[1, 2], [3, 4]]\n    >>> mask = [[0, 1], [0, 0]]\n    >>> x = np.ma.array(arr, mask=mask)\n    >>> np.ma.compress_nd(x, axis=0)\n    array([[3, 4]])\n    >>> np.ma.compress_nd(x, axis=1)\n    array([[1],\n           [3]])\n    >>> np.ma.compress_nd(x)\n    array([[3]])\n\n    \"\"\"\n    x = asarray(x)\n    m = getmask(x)\n    if axis is None:\n        axis = tuple(range(x.ndim))\n    else:\n        axis = normalize_axis_tuple(axis, x.ndim)\n    if m is nomask or not m.any():\n        return x._data\n    if m.all():\n        return nxarray([])\n    data = x._data\n    for ax in axis:\n        axes = tuple(list(range(ax)) + list(range(ax + 1, x.ndim)))\n        data = data[(slice(None),) * ax + (~m.any(axis=axes),)]\n    return data", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_compress_nd(self):\n\t    x = np.array(list(range(3 * 4 * 5))).reshape(3, 4, 5)\n\t    m = np.zeros((3, 4, 5)).astype(bool)\n\t    m[1, 1, 1] = True\n\t    x = array(x, mask=m)\n\t    a = compress_nd(x)\n\t    assert_equal(a, [[[0, 2, 3, 4], [10, 12, 13, 14], [15, 17, 18, 19]], [[\n\t        40, 42, 43, 44], [50, 52, 53, 54], [55, 57, 58, 59]]])\n\t    a = compress_nd(x, 0)\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14\n\t        ], [15, 16, 17, 18, 19]], [[40, 41, 42, 43, 44], [45, 46, 47, 48, \n\t        49], [50, 51, 52, 53, 54], [55, 56, 57, 58, 59]]])\n\t    a = compress_nd(x, 1)\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [10, 11, 12, 13, 14], [15, 16, 17, \n\t        18, 19]], [[20, 21, 22, 23, 24], [30, 31, 32, 33, 34], [35, 36, 37,\n\t        38, 39]], [[40, 41, 42, 43, 44], [50, 51, 52, 53, 54], [55, 56, 57,\n\t        58, 59]]])\n\t    a2 = compress_nd(x, (1,))\n\t    a3 = compress_nd(x, -2)\n\t    a4 = compress_nd(x, (-2,))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, 2)\n\t    assert_equal(a, [[[0, 2, 3, 4], [5, 7, 8, 9], [10, 12, 13, 14], [15, 17,\n\t        18, 19]], [[20, 22, 23, 24], [25, 27, 28, 29], [30, 32, 33, 34], [\n\t        35, 37, 38, 39]], [[40, 42, 43, 44], [45, 47, 48, 49], [50, 52, 53,\n\t        54], [55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (2,))\n\t    a3 = compress_nd(x, -1)\n\t    a4 = compress_nd(x, (-1,))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, (0, 1))\n\t    assert_equal(a, [[[0, 1, 2, 3, 4], [10, 11, 12, 13, 14], [15, 16, 17, \n\t        18, 19]], [[40, 41, 42, 43, 44], [50, 51, 52, 53, 54], [55, 56, 57,\n\t        58, 59]]])\n\t    a2 = compress_nd(x, (0, -2))\n\t    assert_equal(a, a2)\n\t    a = compress_nd(x, (1, 2))\n\t    assert_equal(a, [[[0, 2, 3, 4], [10, 12, 13, 14], [15, 17, 18, 19]], [[\n\t        20, 22, 23, 24], [30, 32, 33, 34], [35, 37, 38, 39]], [[40, 42, 43,\n\t        44], [50, 52, 53, 54], [55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (-2, 2))\n\t    a3 = compress_nd(x, (1, -1))\n\t    a4 = compress_nd(x, (-2, -1))\n\t    assert_equal(a, a2)\n\t    assert_equal(a, a3)\n\t    assert_equal(a, a4)\n\t    a = compress_nd(x, (0, 2))\n\t    assert_equal(a, [[[0, 2, 3, 4], [5, 7, 8, 9], [10, 12, 13, 14], [15, 17,\n\t        18, 19]], [[40, 42, 43, 44], [45, 47, 48, 49], [50, 52, 53, 54], [\n\t        55, 57, 58, 59]]])\n\t    a2 = compress_nd(x, (0, -1))\n\t    assert_equal(a, a2)\n\t\nTestCompressFunctions().test_compress_nd()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef compress_nd(x, axis=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "compress_rowcols", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef compress_rowcols(x, axis=None):\n    \"\"\"\n    Suppress the rows and/or columns of a 2-D array that contain\n    masked values.\n\n    The suppression behavior is selected with the `axis` parameter.\n\n    - If axis is None, both rows and columns are suppressed.\n    - If axis is 0, only rows are suppressed.\n    - If axis is 1 or -1, only columns are suppressed.\n\n    Parameters\n    ----------\n    x : array_like, MaskedArray\n        The array to operate on.  If not a MaskedArray instance (or if no array\n        elements are masked), `x` is interpreted as a MaskedArray with\n        `mask` set to `nomask`. Must be a 2D array.\n    axis : int, optional\n        Axis along which to perform the operation. Default is None.\n\n    Returns\n    -------\n    compressed_array : ndarray\n        The compressed array.\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n    ...                                                   [1, 0, 0],\n    ...                                                   [0, 0, 0]])\n    >>> x\n    masked_array(\n      data=[[--, 1, 2],\n            [--, 4, 5],\n            [6, 7, 8]],\n      mask=[[ True, False, False],\n            [ True, False, False],\n            [False, False, False]],\n      fill_value=999999)\n\n    >>> np.ma.compress_rowcols(x)\n    array([[7, 8]])\n    >>> np.ma.compress_rowcols(x, 0)\n    array([[6, 7, 8]])\n    >>> np.ma.compress_rowcols(x, 1)\n    array([[1, 2],\n           [4, 5],\n           [7, 8]])\n\n    \"\"\"\n    if asarray(x).ndim != 2:\n        raise NotImplementedError('compress_rowcols works for 2D arrays only.')\n    return compress_nd(x, axis=axis)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_compress_rowcols(self):\n\t    x = array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0], [0, 0, 0], [0, 0,\n\t        0]])\n\t    assert_equal(compress_rowcols(x), [[4, 5], [7, 8]])\n\t    assert_equal(compress_rowcols(x, 0), [[3, 4, 5], [6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[1, 2], [4, 5], [7, 8]])\n\t    x = array(x._data, mask=[[0, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(compress_rowcols(x), [[0, 2], [6, 8]])\n\t    assert_equal(compress_rowcols(x, 0), [[0, 1, 2], [6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[0, 2], [3, 5], [6, 8]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(compress_rowcols(x), [[8]])\n\t    assert_equal(compress_rowcols(x, 0), [[6, 7, 8]])\n\t    assert_equal(compress_rowcols(x, 1), [[2], [5], [8]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\t    assert_equal(compress_rowcols(x).size, 0)\n\t    assert_equal(compress_rowcols(x, 0).size, 0)\n\t    assert_equal(compress_rowcols(x, 1).size, 0)\n\t\nTestCompressFunctions().test_compress_rowcols()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef compress_rowcols(x, axis=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "mask_rowcols", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef mask_rowcols(a, axis=None):\n    \"\"\"\n    Mask rows and/or columns of a 2D array that contain masked values.\n\n    Mask whole rows and/or columns of a 2D array that contain\n    masked values.  The masking behavior is selected using the\n    `axis` parameter.\n\n      - If `axis` is None, rows *and* columns are masked.\n      - If `axis` is 0, only rows are masked.\n      - If `axis` is 1 or -1, only columns are masked.\n\n    Parameters\n    ----------\n    a : array_like, MaskedArray\n        The array to mask.  If not a MaskedArray instance (or if no array\n        elements are masked), the result is a MaskedArray with `mask` set\n        to `nomask` (False). Must be a 2D array.\n    axis : int, optional\n        Axis along which to perform the operation. If None, applies to a\n        flattened version of the array.\n\n    Returns\n    -------\n    a : MaskedArray\n        A modified version of the input array, masked depending on the value\n        of the `axis` parameter.\n\n    Raises\n    ------\n    NotImplementedError\n        If input array `a` is not 2D.\n\n    See Also\n    --------\n    mask_rows : Mask rows of a 2D array that contain masked values.\n    mask_cols : Mask cols of a 2D array that contain masked values.\n    masked_where : Mask where a condition is met.\n\n    Notes\n    -----\n    The input array's mask is modified by this function.\n\n    Examples\n    --------\n    >>> a = np.zeros((3, 3), dtype=int)\n    >>> a[1, 1] = 1\n    >>> a\n    array([[0, 0, 0],\n           [0, 1, 0],\n           [0, 0, 0]])\n    >>> a = np.ma.masked_equal(a, 1)\n    >>> a\n    masked_array(\n      data=[[0, 0, 0],\n            [0, --, 0],\n            [0, 0, 0]],\n      mask=[[False, False, False],\n            [False,  True, False],\n            [False, False, False]],\n      fill_value=1)\n    >>> np.ma.mask_rowcols(a)\n    masked_array(\n      data=[[0, --, 0],\n            [--, --, --],\n            [0, --, 0]],\n      mask=[[False,  True, False],\n            [ True,  True,  True],\n            [False,  True, False]],\n      fill_value=1)\n\n    \"\"\"\n    a = array(a, subok=False)\n    if a.ndim != 2:\n        raise NotImplementedError('mask_rowcols works for 2D arrays only.')\n    m = getmask(a)\n    if m is nomask or not m.any():\n        return a\n    maskedval = m.nonzero()\n    a._mask = a._mask.copy()\n    if not axis:\n        a[np.unique(maskedval[0])] = masked\n    if axis in [None, 1, -1]:\n        a[:, np.unique(maskedval[1])] = masked\n    return a", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestCompressFunctions():\n\tdef test_mask_rowcols(self):\n\t    x = array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0], [0, 0, 0], [0, 0,\n\t        0]])\n\t    assert_equal(mask_rowcols(x).mask, [[1, 1, 1], [1, 0, 0], [1, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[1, 1, 1], [0, 0, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[1, 0, 0], [1, 0, 0], [1, 0, 0]])\n\t    x = array(x._data, mask=[[0, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x).mask, [[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[0, 0, 0], [1, 1, 1], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[0, 1, 0], [0, 1, 0], [0, 1, 0]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x).mask, [[1, 1, 1], [1, 1, 1], [1, 1, 0]])\n\t    assert_equal(mask_rowcols(x, 0).mask, [[1, 1, 1], [1, 1, 1], [0, 0, 0]])\n\t    assert_equal(mask_rowcols(x, 1).mask, [[1, 1, 0], [1, 1, 0], [1, 1, 0]])\n\t    x = array(x._data, mask=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n\t    assert_(mask_rowcols(x).all() is masked)\n\t    assert_(mask_rowcols(x, 0).all() is masked)\n\t    assert_(mask_rowcols(x, 1).all() is masked)\n\t    assert_(mask_rowcols(x).mask.all())\n\t    assert_(mask_rowcols(x, 0).mask.all())\n\t    assert_(mask_rowcols(x, 1).mask.all())\n\t\nTestCompressFunctions().test_mask_rowcols()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef mask_rowcols(a, axis=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "apply_along_axis", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef apply_along_axis(func1d, axis, arr, *args, **kwargs):\n    \"\"\"\n    (This docstring should be overwritten)\n    \"\"\"\n    arr = array(arr, copy=False, subok=True)\n    nd = arr.ndim\n    axis = normalize_axis_index(axis, nd)\n    ind = [0] * (nd - 1)\n    i = np.zeros(nd, 'O')\n    indlist = list(range(nd))\n    indlist.remove(axis)\n    i[axis] = slice(None, None)\n    outshape = np.asarray(arr.shape).take(indlist)\n    i.put(indlist, ind)\n    res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n    asscalar = np.isscalar(res)\n    if not asscalar:\n        try:\n            len(res)\n        except TypeError:\n            asscalar = True\n    dtypes = []\n    if asscalar:\n        dtypes.append(np.asarray(res).dtype)\n        outarr = zeros(outshape, object)\n        outarr[tuple(ind)] = res\n        Ntot = np.prod(outshape)\n        k = 1\n        while k < Ntot:\n            ind[-1] += 1\n            n = -1\n            while ind[n] >= outshape[n] and n > 1 - nd:\n                ind[n - 1] += 1\n                ind[n] = 0\n                n -= 1\n            i.put(indlist, ind)\n            res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n            outarr[tuple(ind)] = res\n            dtypes.append(asarray(res).dtype)\n            k += 1\n    else:\n        res = array(res, copy=False, subok=True)\n        j = i.copy()\n        j[axis] = [slice(None, None)] * res.ndim\n        j.put(indlist, ind)\n        Ntot = np.prod(outshape)\n        holdshape = outshape\n        outshape = list(arr.shape)\n        outshape[axis] = res.shape\n        dtypes.append(asarray(res).dtype)\n        outshape = flatten_inplace(outshape)\n        outarr = zeros(outshape, object)\n        outarr[tuple(flatten_inplace(j.tolist()))] = res\n        k = 1\n        while k < Ntot:\n            ind[-1] += 1\n            n = -1\n            while ind[n] >= holdshape[n] and n > 1 - nd:\n                ind[n - 1] += 1\n                ind[n] = 0\n                n -= 1\n            i.put(indlist, ind)\n            j.put(indlist, ind)\n            res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\n            outarr[tuple(flatten_inplace(j.tolist()))] = res\n            dtypes.append(asarray(res).dtype)\n            k += 1\n    max_dtypes = np.dtype(np.asarray(dtypes).max())\n    if not hasattr(arr, '_mask'):\n        result = np.asarray(outarr, dtype=max_dtypes)\n    else:\n        result = asarray(outarr, dtype=max_dtypes)\n        result.fill_value = ma.default_fill_value(result)\n    return result", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyAlongAxis():\n\tdef test_3d(self):\n\t    a = arange(12.0).reshape(2, 2, 3)\n\t\n\t    def myfunc(b):\n\t        return b[1]\n\t    xa = apply_along_axis(myfunc, 2, a)\n\t    assert_equal(xa, [[1, 4], [7, 10]])\n\t\nTestApplyAlongAxis().test_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyAlongAxis():\n\tdef test_3d_kwargs(self):\n\t    a = arange(12).reshape(2, 2, 3)\n\t\n\t    def myfunc(b, offset=0):\n\t        return b[1 + offset]\n\t    xa = apply_along_axis(myfunc, 2, a, offset=1)\n\t    assert_equal(xa, [[2, 5], [8, 11]])\n\t\nTestApplyAlongAxis().test_3d_kwargs()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef apply_along_axis(func1d, axis, arr, *args, **kwargs): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "apply_over_axes", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef apply_over_axes(func, a, axes):\n    \"\"\"\n    (This docstring will be overwritten)\n    \"\"\"\n    val = asarray(a)\n    N = a.ndim\n    if array(axes).ndim == 0:\n        axes = axes,\n    for axis in axes:\n        if axis < 0:\n            axis = N + axis\n        args = val, axis\n        res = func(*args)\n        if res.ndim == val.ndim:\n            val = res\n        else:\n            res = ma.expand_dims(res, axis)\n            if res.ndim == val.ndim:\n                val = res\n            else:\n                raise ValueError(\n                    'function is not returning an array of the correct shape')\n    return val", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestApplyOverAxes():\n\tdef test_basic(self):\n\t    a = arange(24).reshape(2, 3, 4)\n\t    test = apply_over_axes(np.sum, a, [0, 2])\n\t    ctrl = np.array([[[60], [92], [124]]])\n\t    assert_equal(test, ctrl)\n\t    a[(a % 2).astype(bool)] = masked\n\t    test = apply_over_axes(np.sum, a, [0, 2])\n\t    ctrl = np.array([[[28], [44], [60]]])\n\t    assert_equal(test, ctrl)\n\t\nTestApplyOverAxes().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef apply_over_axes(func, a, axes): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "median", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef median(a, axis=None, out=None, overwrite_input=False, keepdims=False):\n    \"\"\"\n    Compute the median along the specified axis.\n\n    Returns the median of the array elements.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array or object that can be converted to an array.\n    axis : int, optional\n        Axis along which the medians are computed. The default (None) is\n        to compute the median along a flattened version of the array.\n    out : ndarray, optional\n        Alternative output array in which to place the result. It must\n        have the same shape and buffer length as the expected output\n        but the type will be cast if necessary.\n    overwrite_input : bool, optional\n        If True, then allow use of memory of input array (a) for\n        calculations. The input array will be modified by the call to\n        median. This will save memory when you do not need to preserve\n        the contents of the input array. Treat the input as undefined,\n        but it will probably be fully or partially sorted. Default is\n        False. Note that, if `overwrite_input` is True, and the input\n        is not already an `ndarray`, an error will be raised.\n    keepdims : bool, optional\n        If this is set to True, the axes which are reduced are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    median : ndarray\n        A new array holding the result is returned unless out is\n        specified, in which case a reference to out is returned.\n        Return data-type is `float64` for integers and floats smaller than\n        `float64`, or the input data-type, otherwise.\n\n    See Also\n    --------\n    mean\n\n    Notes\n    -----\n    Given a vector ``V`` with ``N`` non masked values, the median of ``V``\n    is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.\n    ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``\n    when ``N`` is even.\n\n    Examples\n    --------\n    >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n    >>> np.ma.median(x)\n    1.5\n\n    >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n    >>> np.ma.median(x)\n    2.5\n    >>> np.ma.median(x, axis=-1, overwrite_input=True)\n    masked_array(data=[2.0, 5.0],\n                 mask=[False, False],\n           fill_value=1e+20)\n\n    \"\"\"\n    if not hasattr(a, 'mask'):\n        m = np.median(getdata(a, subok=True), axis=axis, out=out,\n            overwrite_input=overwrite_input, keepdims=keepdims)\n        if isinstance(m, np.ndarray) and 1 <= m.ndim:\n            return masked_array(m, copy=False)\n        else:\n            return m\n    return _ureduce(a, func=_median, keepdims=keepdims, axis=axis, out=out,\n        overwrite_input=overwrite_input)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_pytype(self):\n\t    r = median([[np.inf, np.inf], [np.inf, np.inf]], axis=-1)\n\t    assert_equal(r, np.inf)\n\t\nTestMedian().test_pytype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_inf(self):\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ]), axis=-1)\n\t    assert_equal(r, np.inf)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ]), axis=None)\n\t    assert_equal(r, np.inf)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ], mask=True), axis=-1)\n\t    assert_equal(r.mask, True)\n\t    r = median(np.ma.masked_array([[np.inf, np.inf], [np.inf, np.inf]\n\t        ], mask=True), axis=None)\n\t    assert_equal(r.mask, True)\n\t\nTestMedian().test_inf()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_non_masked(self):\n\t    x = np.arange(9)\n\t    assert_equal(median(x), 4.0)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = range(8)\n\t    assert_equal(median(x), 3.5)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = 5\n\t    assert_equal(median(x), 5.0)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = np.arange(9 * 8).reshape(9, 8)\n\t    assert_equal(median(x, axis=0), np.median(x, axis=0))\n\t    assert_equal(median(x, axis=1), np.median(x, axis=1))\n\t    assert_(median(x, axis=1) is not MaskedArray)\n\t    x = np.arange(9 * 8.0).reshape(9, 8)\n\t    assert_equal(median(x, axis=0), np.median(x, axis=0))\n\t    assert_equal(median(x, axis=1), np.median(x, axis=1))\n\t    assert_(median(x, axis=1) is not MaskedArray)\n\t\nTestMedian().test_non_masked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_docstring_examples(self):\n\t    \"\"\"test the examples given in the docstring of ma.median\"\"\"\n\t    x = array(np.arange(8), mask=[0] * 4 + [1] * 4)\n\t    assert_equal(median(x), 1.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(10).reshape(2, 5), mask=[0] * 6 + [1] * 4)\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    ma_x = median(x, axis=-1, overwrite_input=True)\n\t    assert_equal(ma_x, [2.0, 5.0])\n\t    assert_equal(ma_x.shape, (2,), 'shape mismatch')\n\t    assert_(type(ma_x) is MaskedArray)\n\t\nTestMedian().test_docstring_examples()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_masked_0d(self):\n\t    x = array(1, mask=False)\n\t    assert_equal(median(x), 1)\n\t    x = array(1, mask=True)\n\t    assert_equal(median(x), np.ma.masked)\n\t\nTestMedian().test_masked_0d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_masked_1d(self):\n\t    x = array(np.arange(5), mask=True)\n\t    assert_equal(median(x), np.ma.masked)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is np.ma.core.MaskedConstant)\n\t    x = array(np.arange(5), mask=False)\n\t    assert_equal(median(x), 2.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 0, 0, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 1, 1, 1])\n\t    assert_equal(median(x), 0.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5), mask=[0, 1, 1, 0, 0])\n\t    assert_equal(median(x), 3.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(5.0), mask=[0, 1, 1, 0, 0])\n\t    assert_equal(median(x), 3.0)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(6), mask=[0, 1, 1, 1, 1, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    x = array(np.arange(6.0), mask=[0, 1, 1, 1, 1, 0])\n\t    assert_equal(median(x), 2.5)\n\t    assert_equal(median(x).shape, (), 'shape mismatch')\n\t    assert_(type(median(x)) is not MaskedArray)\n\t\nTestMedian().test_masked_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_1d_shape_consistency(self):\n\t    assert_equal(median(array([1, 2, 3], mask=[0, 0, 0])).shape, np.\n\t        ma.median(array([1, 2, 3], mask=[0, 1, 0])).shape)\n\t\nTestMedian().test_1d_shape_consistency()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d(self):\n\t    n, p = 101, 30\n\t    x = masked_array(np.linspace(-1.0, 1.0, n))\n\t    x[:10] = x[-10:] = masked\n\t    z = masked_array(np.empty((n, p), dtype=float))\n\t    z[:, 0] = x[:]\n\t    idx = np.arange(len(x))\n\t    for i in range(1, p):\n\t        np.random.shuffle(idx)\n\t        z[:, i] = x[idx]\n\t    assert_equal(median(z[:, 0]), 0)\n\t    assert_equal(median(z), 0)\n\t    assert_equal(median(z, axis=0), np.zeros(p))\n\t    assert_equal(median(z.T, axis=1), np.zeros(p))\n\t\nTestMedian().test_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d_waxis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x), 14.5)\n\t    assert_(type(median(x)) is not MaskedArray)\n\t    assert_equal(median(x, axis=0), [13.5, 14.5, 15.5])\n\t    assert_(type(median(x, axis=0)) is MaskedArray)\n\t    assert_equal(median(x, axis=1), [0, 0, 0, 10, 13, 16, 19, 0, 0, 0])\n\t    assert_(type(median(x, axis=1)) is MaskedArray)\n\t    assert_equal(median(x, axis=1).mask, [1, 1, 1, 0, 0, 0, 0, 1, 1, 1])\n\t\nTestMedian().test_2d_waxis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_2d_waxis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x), 14.5)\n\t    assert_(type(np.ma.median(x)) is not MaskedArray)\n\t    assert_equal(median(x, axis=0), [13.5, 14.5, 15.5])\n\t    assert_(type(np.ma.median(x, axis=0)) is MaskedArray)\n\t    assert_equal(median(x, axis=1), [0, 0, 0, 10, 13, 16, 19, 0, 0, 0])\n\t    assert_(type(np.ma.median(x, axis=1)) is MaskedArray)\n\t    assert_equal(median(x, axis=1).mask, [1, 1, 1, 0, 0, 0, 0, 1, 1, 1])\n\t\nTestMedian().test_2d_waxis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_3d(self):\n\t    x = np.ma.arange(24).reshape(3, 4, 2)\n\t    x[x % 3 == 0] = masked\n\t    assert_equal(median(x, 0), [[12, 9], [6, 15], [12, 9], [18, 15]])\n\t    x.shape = 4, 3, 2\n\t    assert_equal(median(x, 0), [[99, 10], [11, 99], [13, 14]])\n\t    x = np.ma.arange(24).reshape(4, 3, 2)\n\t    x[x % 5 == 0] = masked\n\t    assert_equal(median(x, 0), [[12, 10], [8, 9], [16, 17]])\n\t\nTestMedian().test_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_neg_axis(self):\n\t    x = masked_array(np.arange(30).reshape(10, 3))\n\t    x[:3] = x[-3:] = masked\n\t    assert_equal(median(x, axis=-1), median(x, axis=1))\n\t\nTestMedian().test_neg_axis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out_1d(self):\n\t    for v in (30, 30.0, 31, 31.0):\n\t        x = masked_array(np.arange(v))\n\t        x[:3] = x[-3:] = masked\n\t        out = masked_array(np.ones(()))\n\t        r = median(x, out=out)\n\t        if v == 30:\n\t            assert_equal(out, 14.5)\n\t        else:\n\t            assert_equal(out, 15.0)\n\t        assert_(r is out)\n\t        assert_(type(r) is MaskedArray)\n\t\nTestMedian().test_out_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out(self):\n\t    for v in (40, 40.0, 30, 30.0):\n\t        x = masked_array(np.arange(v).reshape(10, -1))\n\t        x[:3] = x[-3:] = masked\n\t        out = masked_array(np.ones(10))\n\t        r = median(x, axis=1, out=out)\n\t        if v == 30:\n\t            e = masked_array([0.0] * 3 + [10, 13, 16, 19] + [0.0] * 3, mask\n\t                =[True] * 3 + [False] * 4 + [True] * 3)\n\t        else:\n\t            e = masked_array([0.0] * 3 + [13.5, 17.5, 21.5, 25.5] + [0.0] *\n\t                3, mask=[True] * 3 + [False] * 4 + [True] * 3)\n\t        assert_equal(r, e)\n\t        assert_(r is out)\n\t        assert_(type(r) is MaskedArray)\n\t\nTestMedian().test_out()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_single_non_masked_value_on_axis(self):\n\t    data = [[1.0, 0.0], [0.0, 3.0], [0.0, 0.0]]\n\t    masked_arr = np.ma.masked_equal(data, 0)\n\t    expected = [1.0, 3.0]\n\t    assert_array_equal(median(masked_arr, axis=0), expected)\n\t\nTestMedian().test_single_non_masked_value_on_axis()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_nan(self):\n\t    for mask in (False, np.zeros(6, dtype=bool)):\n\t        dm = np.ma.array([[1, np.nan, 3], [1, 2, 3]])\n\t        dm.mask = mask\n\t        r = median(dm, axis=None)\n\t        assert_(np.isscalar(r))\n\t        assert_array_equal(r, np.nan)\n\t        r = median(dm.ravel(), axis=0)\n\t        assert_(np.isscalar(r))\n\t        assert_array_equal(r, np.nan)\n\t        r = median(dm, axis=0)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [1, np.nan, 3])\n\t        r = median(dm, axis=1)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [np.nan, 2])\n\t        r = median(dm, axis=-1)\n\t        assert_equal(type(r), MaskedArray)\n\t        assert_array_equal(r, [np.nan, 2])\n\t    dm = np.ma.array([[1, np.nan, 3], [1, 2, 3]])\n\t    dm[:, 2] = np.ma.masked\n\t    assert_array_equal(median(dm, axis=None), np.nan)\n\t    assert_array_equal(median(dm, axis=0), [1, np.nan, 3])\n\t    assert_array_equal(median(dm, axis=1), [np.nan, 1.5])\n\t\nTestMedian().test_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_out_nan(self):\n\t    o = np.ma.masked_array(np.zeros((4,)))\n\t    d = np.ma.masked_array(np.ones((3, 4)))\n\t    d[2, 1] = np.nan\n\t    d[2, 2] = np.ma.masked\n\t    assert_equal(median(d, 0, out=o), o)\n\t    o = np.ma.masked_array(np.zeros((3,)))\n\t    assert_equal(median(d, 1, out=o), o)\n\t    o = np.ma.masked_array(np.zeros(()))\n\t    assert_equal(median(d, out=o), o)\n\t\nTestMedian().test_out_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_nan_behavior(self):\n\t    a = np.ma.masked_array(np.arange(24, dtype=float))\n\t    a[::3] = np.ma.masked\n\t    a[2] = np.nan\n\t    assert_array_equal(median(a), np.nan)\n\t    assert_array_equal(median(a, axis=0), np.nan)\n\t    a = np.ma.masked_array(np.arange(24, dtype=float).reshape(2, 3, 4))\n\t    a.mask = np.arange(a.size) % 2 == 1\n\t    aorig = a.copy()\n\t    a[1, 2, 3] = np.nan\n\t    a[1, 1, 2] = np.nan\n\t    assert_array_equal(median(a), np.nan)\n\t    assert_(np.isscalar(median(a)))\n\t    b = median(aorig, axis=0)\n\t    b[2, 3] = np.nan\n\t    b[1, 2] = np.nan\n\t    assert_equal(median(a, 0), b)\n\t    b = median(aorig, axis=1)\n\t    b[1, 3] = np.nan\n\t    b[1, 2] = np.nan\n\t    assert_equal(median(a, 1), b)\n\t    b = median(aorig, axis=(0, 2))\n\t    b[1] = np.nan\n\t    b[2] = np.nan\n\t    assert_equal(median(a, (0, 2)), b)\n\t\nTestMedian().test_nan_behavior()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_ambigous_fill(self):\n\t    a = np.array([[3, 3, 255], [3, 3, 255]], dtype=np.uint8)\n\t    a = np.ma.masked_array(a, mask=a == 3)\n\t    assert_array_equal(median(a, axis=1), 255)\n\t    assert_array_equal(median(a, axis=1).mask, False)\n\t    assert_array_equal(median(a, axis=0), a[0])\n\t    assert_array_equal(median(a), 255)\n\t\nTestMedian().test_ambigous_fill()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_special(self):\n\t    for inf in [np.inf, -np.inf]:\n\t        a = np.array([[inf, np.nan], [np.nan, np.nan]])\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        assert_equal(median(a, axis=0), [inf, np.nan])\n\t        assert_equal(median(a, axis=1), [inf, np.nan])\n\t        assert_equal(median(a), inf)\n\t        a = np.array([[np.nan, np.nan, inf], [np.nan, np.nan, inf]])\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        assert_array_equal(median(a, axis=1), inf)\n\t        assert_array_equal(median(a, axis=1).mask, False)\n\t        assert_array_equal(median(a, axis=0), a[0])\n\t        assert_array_equal(median(a), inf)\n\t        a = np.array([[inf, inf], [inf, inf]])\n\t        assert_equal(median(a), inf)\n\t        assert_equal(median(a, axis=0), inf)\n\t        assert_equal(median(a, axis=1), inf)\n\t        a = np.array([[inf, 7, -inf, -9], [-10, np.nan, np.nan, 5], [4, np.\n\t            nan, np.nan, inf]], dtype=np.float32)\n\t        a = np.ma.masked_array(a, mask=np.isnan(a))\n\t        if inf > 0:\n\t            assert_equal(median(a, axis=0), [4.0, 7.0, -inf, 5.0])\n\t            assert_equal(median(a), 4.5)\n\t        else:\n\t            assert_equal(median(a, axis=0), [-10.0, 7.0, -inf, -9.0])\n\t            assert_equal(median(a), -2.5)\n\t        assert_equal(median(a, axis=1), [-1.0, -2.5, inf])\n\t        for i in range(0, 10):\n\t            for j in range(1, 10):\n\t                a = np.array([[np.nan] * i + [inf] * j] * 2)\n\t                a = np.ma.masked_array(a, mask=np.isnan(a))\n\t                assert_equal(median(a), inf)\n\t                assert_equal(median(a, axis=1), inf)\n\t                assert_equal(median(a, axis=0), [np.nan] * i + [inf] * j)\n\t\nTestMedian().test_special()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_empty(self):\n\t    a = np.ma.masked_array(np.array([], dtype=float))\n\t    with suppress_warnings() as w:\n\t        w.record(RuntimeWarning)\n\t        assert_array_equal(median(a), np.nan)\n\t        assert_(w.log[0].category is RuntimeWarning)\n\t    a = np.ma.masked_array(np.array([], dtype=float, ndmin=3))\n\t    with suppress_warnings() as w:\n\t        w.record(RuntimeWarning)\n\t        warnings.filterwarnings('always', '', RuntimeWarning)\n\t        assert_array_equal(median(a), np.nan)\n\t        assert_(w.log[0].category is RuntimeWarning)\n\t    b = np.ma.masked_array(np.array([], dtype=float, ndmin=2))\n\t    assert_equal(median(a, axis=0), b)\n\t    assert_equal(median(a, axis=1), b)\n\t    b = np.ma.masked_array(np.array(np.nan, dtype=float, ndmin=2))\n\t    with warnings.catch_warnings(record=True) as w:\n\t        warnings.filterwarnings('always', '', RuntimeWarning)\n\t        assert_equal(median(a, axis=2), b)\n\t        assert_(w[0].category is RuntimeWarning)\n\t\nTestMedian().test_empty()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestMedian():\n\tdef test_object(self):\n\t    o = np.ma.masked_array(np.arange(7.0))\n\t    assert_(type(median(o.astype(object))), float)\n\t    o[2] = np.nan\n\t    assert_(type(median(o.astype(object))), float)\n\t\nTestMedian().test_object()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef median(a, axis=None, out=None, overwrite_input=False, keepdims=False): [M\n    ASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "polyfit", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):\n    \"\"\"\n    Any masked values in x is propagated in y, and vice-versa.\n\n    \"\"\"\n    x = asarray(x)\n    y = asarray(y)\n    m = getmask(x)\n    if y.ndim == 1:\n        m = mask_or(m, getmask(y))\n    elif y.ndim == 2:\n        my = getmask(mask_rows(y))\n        if my is not nomask:\n            m = mask_or(m, my[:, 0])\n    else:\n        raise TypeError('Expected a 1D or 2D array for y!')\n    if w is not None:\n        w = asarray(w)\n        if w.ndim != 1:\n            raise TypeError('expected a 1-d array for weights')\n        if w.shape[0] != y.shape[0]:\n            raise TypeError('expected w and y to have the same length')\n        m = mask_or(m, getmask(w))\n    if m is not nomask:\n        not_m = ~m\n        if w is not None:\n            w = w[not_m]\n        return np.polyfit(x[not_m], y[not_m], deg, rcond, full, w, cov)\n    else:\n        return np.polyfit(x, y, deg, rcond, full, w, cov)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestPolynomial():\n\tdef test_polyfit(self):\n\t    x = np.random.rand(10)\n\t    y = np.random.rand(20).reshape(-1, 2)\n\t    assert_almost_equal(polyfit(x, y, 3), np.polyfit(x, y, 3))\n\t    x = x.view(MaskedArray)\n\t    x[0] = masked\n\t    y = y.view(MaskedArray)\n\t    y[0, 0] = y[-1, -1] = masked\n\t    C, R, K, S, D = polyfit(x, y[:, 0], 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:], y[1:, 0].compressed(), 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    C, R, K, S, D = polyfit(x, y[:, -1], 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, -1], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, :], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t    w = np.random.rand(10) + 1\n\t    wo = w.copy()\n\t    xs = x[1:-1]\n\t    ys = y[1:-1]\n\t    ws = w[1:-1]\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True, w=w)\n\t    c, r, k, s, d = np.polyfit(xs, ys, 3, full=True, w=ws)\n\t    assert_equal(w, wo)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t\nTestPolynomial().test_polyfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestPolynomial():\n\tdef test_polyfit_with_masked_NaNs(self):\n\t    x = np.random.rand(10)\n\t    y = np.random.rand(20).reshape(-1, 2)\n\t    x[0] = np.nan\n\t    y[-1, -1] = np.nan\n\t    x = x.view(MaskedArray)\n\t    y = y.view(MaskedArray)\n\t    x[0] = masked\n\t    y[-1, -1] = masked\n\t    C, R, K, S, D = polyfit(x, y, 3, full=True)\n\t    c, r, k, s, d = np.polyfit(x[1:-1], y[1:-1, :], 3, full=True)\n\t    for a, a_ in zip((C, R, K, S, D), (c, r, k, s, d)):\n\t        assert_almost_equal(a, a_)\n\t\nTestPolynomial().test_polyfit_with_masked_NaNs()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "unique", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef unique(ar1, return_index=False, return_inverse=False):\n    \"\"\"\n    Finds the unique elements of an array.\n\n    Masked values are considered the same element (masked). The output array\n    is always a masked array. See `numpy.unique` for more details.\n\n    See Also\n    --------\n    numpy.unique : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> a = [1, 2, 1000, 2, 3]\n    >>> mask = [0, 0, 1, 0, 0]\n    >>> masked_a = np.ma.masked_array(a, mask)\n    >>> masked_a\n    masked_array(data=[1, 2, --, 2, 3],\n                mask=[False, False,  True, False, False],\n        fill_value=999999)\n    >>> np.ma.unique(masked_a)\n    masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999)\n    >>> np.ma.unique(masked_a, return_index=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]))\n    >>> np.ma.unique(masked_a, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 3, 1, 2]))\n    >>> np.ma.unique(masked_a, return_index=True, return_inverse=True)\n    (masked_array(data=[1, 2, 3, --],\n                mask=[False, False, False,  True],\n        fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))\n    \"\"\"\n    output = np.unique(ar1, return_index=return_index, return_inverse=\n        return_inverse)\n    if isinstance(output, tuple):\n        output = list(output)\n        output[0] = output[0].view(MaskedArray)\n        output = tuple(output)\n    else:\n        output = output.view(MaskedArray)\n    return output", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_onlist(self):\n\t    data = [1, 1, 1, 2, 2, 3]\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_(isinstance(test[0], MaskedArray))\n\t    assert_equal(test[0], masked_array([1, 2, 3], mask=[0, 0, 0]))\n\t    assert_equal(test[1], [0, 3, 5])\n\t    assert_equal(test[2], [0, 0, 0, 1, 1, 2])\n\t\nTestArraySetOps().test_unique_onlist()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_onmaskedarray(self):\n\t    data = masked_array([1, 1, 1, 2, 2, 3], mask=[0, 0, 1, 0, 1, 0])\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1, 2, 3, -1], mask=[0, 0, 0, 1]))\n\t    assert_equal(test[1], [0, 3, 5, 2])\n\t    assert_equal(test[2], [0, 0, 3, 1, 3, 2])\n\t    data.fill_value = 3\n\t    data = masked_array(data=[1, 1, 1, 2, 2, 3], mask=[0, 0, 1, 0, 1, 0],\n\t        fill_value=3)\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1, 2, 3, -1], mask=[0, 0, 0, 1]))\n\t    assert_equal(test[1], [0, 3, 5, 2])\n\t    assert_equal(test[2], [0, 0, 3, 1, 3, 2])\n\t\nTestArraySetOps().test_unique_onmaskedarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_unique_allmasked(self):\n\t    data = masked_array([1, 1, 1], mask=True)\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array([1], mask=[True]))\n\t    assert_equal(test[1], [0])\n\t    assert_equal(test[2], [0, 0, 0])\n\t    data = masked\n\t    test = unique(data, return_index=True, return_inverse=True)\n\t    assert_equal(test[0], masked_array(masked))\n\t    assert_equal(test[1], [0])\n\t    assert_equal(test[2], [0])\n\t\nTestArraySetOps().test_unique_allmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef unique(ar1, return_index=False, return_inverse=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "ediff1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef ediff1d(arr, to_end=None, to_begin=None):\n    \"\"\"\n    Compute the differences between consecutive elements of an array.\n\n    This function is the equivalent of `numpy.ediff1d` that takes masked\n    values into account, see `numpy.ediff1d` for details.\n\n    See Also\n    --------\n    numpy.ediff1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> arr = np.ma.array([1, 2, 4, 7, 0])\n    >>> np.ma.ediff1d(arr)\n    masked_array(data=[ 1,  2,  3, -7],\n                 mask=False,\n           fill_value=999999)\n\n    \"\"\"\n    arr = ma.asanyarray(arr).flat\n    ed = arr[1:] - arr[:-1]\n    arrays = [ed]\n    if to_begin is not None:\n        arrays.insert(0, to_begin)\n    if to_end is not None:\n        arrays.append(to_end)\n    if len(arrays) != 1:\n        ed = hstack(arrays)\n    return ed", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    control = array([1, 1, 1, 4], mask=[1, 0, 0, 1])\n\t    test = ediff1d(x)\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_tobegin(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4], mask=[1, 1, 0, 0, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_begin=[1, 2, 3])\n\t    control = array([1, 2, 3, 1, 1, 1, 4], mask=[0, 0, 0, 1, 0, 0, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_tobegin()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_toend(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_end=masked)\n\t    control = array([1, 1, 1, 4, 0], mask=[1, 0, 0, 1, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=[1, 2, 3])\n\t    control = array([1, 1, 1, 4, 1, 2, 3], mask=[1, 0, 0, 1, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_toend()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_tobegin_toend(self):\n\t    x = masked_array(np.arange(5), mask=[1, 0, 0, 0, 1])\n\t    test = ediff1d(x, to_end=masked, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4, 0], mask=[1, 1, 0, 0, 1, 1])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=[1, 2, 3], to_begin=masked)\n\t    control = array([0, 1, 1, 1, 4, 1, 2, 3], mask=[1, 1, 0, 0, 1, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_tobegin_toend()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_ediff1d_ndarray(self):\n\t    x = np.arange(5)\n\t    test = ediff1d(x)\n\t    control = array([1, 1, 1, 1], mask=[0, 0, 0, 0])\n\t    assert_equal(test, control)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t    test = ediff1d(x, to_end=masked, to_begin=masked)\n\t    control = array([0, 1, 1, 1, 1, 0], mask=[1, 0, 0, 0, 0, 1])\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test.filled(0), control.filled(0))\n\t    assert_equal(test.mask, control.mask)\n\t\nTestArraySetOps().test_ediff1d_ndarray()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef ediff1d(arr, to_end=None, to_begin=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "intersect1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef intersect1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Returns the unique elements common to both arrays.\n\n    Masked values are considered equal one to the other.\n    The output is always a masked array.\n\n    See `numpy.intersect1d` for more details.\n\n    See Also\n    --------\n    numpy.intersect1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n    >>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n    >>> np.ma.intersect1d(x, y)\n    masked_array(data=[1, 3, --],\n                 mask=[False, False,  True],\n           fill_value=999999)\n\n    \"\"\"\n    if assume_unique:\n        aux = ma.concatenate((ar1, ar2))\n    else:\n        aux = ma.concatenate((unique(ar1), unique(ar2)))\n    aux.sort()\n    return aux[:-1][aux[1:] == aux[:-1]]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_intersect1d(self):\n\t    x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])\n\t    y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])\n\t    test = intersect1d(x, y)\n\t    control = array([1, 3, -1], mask=[0, 0, 1])\n\t    assert_equal(test, control)\n\t\nTestArraySetOps().test_intersect1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef intersect1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "setxor1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef setxor1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Set exclusive-or of 1-D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setxor1d` for more details.\n\n    See Also\n    --------\n    numpy.setxor1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> ar1 = np.ma.array([1, 2, 3, 2, 4])\n    >>> ar2 = np.ma.array([2, 3, 5, 7, 5])\n    >>> np.ma.setxor1d(ar1, ar2)\n    masked_array(data=[1, 4, 5, 7],\n                 mask=False,    \n           fill_value=999999)\n\n    \"\"\"\n    if not assume_unique:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n    aux = ma.concatenate((ar1, ar2), axis=None)\n    if aux.size == 0:\n        return aux\n    aux.sort()\n    auxf = aux.filled()\n    flag = ma.concatenate(([True], auxf[1:] != auxf[:-1], [True]))\n    flag2 = flag[1:] == flag[:-1]\n    return aux[flag2]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setxor1d(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    test = setxor1d(a, b)\n\t    assert_equal(test, array([3, 4, 7]))\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = [1, 2, 3, 4, 5]\n\t    test = setxor1d(a, b)\n\t    assert_equal(test, array([3, 4, 7, -1], mask=[0, 0, 0, 1]))\n\t    a = array([1, 2, 3])\n\t    b = array([6, 5, 4])\n\t    test = setxor1d(a, b)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test, [1, 2, 3, 4, 5, 6])\n\t    a = array([1, 8, 2, 3], mask=[0, 1, 0, 0])\n\t    b = array([6, 5, 4, 8], mask=[0, 0, 0, 1])\n\t    test = setxor1d(a, b)\n\t    assert_(isinstance(test, MaskedArray))\n\t    assert_equal(test, [1, 2, 3, 4, 5, 6])\n\t    assert_array_equal([], setxor1d([], []))\n\t\nTestArraySetOps().test_setxor1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef setxor1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "isin", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef isin(element, test_elements, assume_unique=False, invert=False):\n    \"\"\"\n    Calculates `element in test_elements`, broadcasting over\n    `element` only.\n\n    The output is always a masked array of the same shape as `element`.\n    See `numpy.isin` for more details.\n\n    See Also\n    --------\n    in1d       : Flattened version of this function.\n    numpy.isin : Equivalent function for ndarrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.13.0\n\n    Examples\n    --------\n    >>> element = np.ma.array([1, 2, 3, 4, 5, 6])\n    >>> test_elements = [0, 2]\n    >>> np.ma.isin(element, test_elements)\n    masked_array(data=[False,  True, False, False, False, False],\n                 mask=False,\n           fill_value=True)\n\n    \"\"\"\n    element = ma.asarray(element)\n    return in1d(element, test_elements, assume_unique=assume_unique, invert\n        =invert).reshape(element.shape)", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_isin(self):\n\t    a = np.arange(24).reshape([2, 3, 4])\n\t    mask = np.zeros([2, 3, 4])\n\t    mask[1, 2, 0] = 1\n\t    a = array(a, mask=mask)\n\t    b = array(data=[0, 10, 20, 30, 1, 3, 11, 22, 33], mask=[0, 1, 0, 1, 0, \n\t        1, 0, 1, 0])\n\t    ec = zeros((2, 3, 4), dtype=bool)\n\t    ec[0, 0, 0] = True\n\t    ec[0, 0, 1] = True\n\t    ec[0, 2, 3] = True\n\t    c = isin(a, b)\n\t    assert_(isinstance(c, MaskedArray))\n\t    assert_array_equal(c, ec)\n\t    d = np.isin(a, b[~b.mask]) & ~a.mask\n\t    assert_array_equal(c, d)\n\t\nTestArraySetOps().test_isin()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef isin(element, test_elements, assume_unique=False, invert=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "in1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef in1d(ar1, ar2, assume_unique=False, invert=False):\n    \"\"\"\n    Test whether each element of an array is also present in a second\n    array.\n\n    The output is always a masked array. See `numpy.in1d` for more details.\n\n    We recommend using :func:`isin` instead of `in1d` for new code.\n\n    See Also\n    --------\n    isin       : Version of this function that preserves the shape of ar1.\n    numpy.in1d : Equivalent function for ndarrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.4.0\n\n    Examples\n    --------\n    >>> ar1 = np.ma.array([0, 1, 2, 5, 0])\n    >>> ar2 = [0, 2]\n    >>> np.ma.in1d(ar1, ar2)\n    masked_array(data=[ True, False,  True, False,  True],\n                 mask=False,\n           fill_value=True)\n\n    \"\"\"\n    if not assume_unique:\n        ar1, rev_idx = unique(ar1, return_inverse=True)\n        ar2 = unique(ar2)\n    ar = ma.concatenate((ar1, ar2))\n    order = ar.argsort(kind='mergesort')\n    sar = ar[order]\n    if invert:\n        bool_ar = sar[1:] != sar[:-1]\n    else:\n        bool_ar = sar[1:] == sar[:-1]\n    flag = ma.concatenate((bool_ar, [invert]))\n    indx = order.argsort(kind='mergesort')[:len(ar1)]\n    if assume_unique:\n        return flag[indx]\n    else:\n        return flag[indx][rev_idx]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_in1d(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    test = in1d(a, b)\n\t    assert_equal(test, [True, True, True, False, True])\n\t    a = array([5, 5, 2, 1, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 5, -1], mask=[0, 0, 1])\n\t    test = in1d(a, b)\n\t    assert_equal(test, [True, True, False, True, True])\n\t    assert_array_equal([], in1d([], []))\n\t\nTestArraySetOps().test_in1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_in1d_invert(self):\n\t    a = array([1, 2, 5, 7, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 2, 3, 4, 5, -1], mask=[0, 0, 0, 0, 0, 1])\n\t    assert_equal(np.invert(in1d(a, b)), in1d(a, b, invert=True))\n\t    a = array([5, 5, 2, 1, -1], mask=[0, 0, 0, 0, 1])\n\t    b = array([1, 5, -1], mask=[0, 0, 1])\n\t    assert_equal(np.invert(in1d(a, b)), in1d(a, b, invert=True))\n\t    assert_array_equal([], in1d([], [], invert=True))\n\t\nTestArraySetOps().test_in1d_invert()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef in1d(ar1, ar2, assume_unique=False, invert=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "setdiff1d", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef setdiff1d(ar1, ar2, assume_unique=False):\n    \"\"\"\n    Set difference of 1D arrays with unique elements.\n\n    The output is always a masked array. See `numpy.setdiff1d` for more\n    details.\n\n    See Also\n    --------\n    numpy.setdiff1d : Equivalent function for ndarrays.\n\n    Examples\n    --------\n    >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])\n    >>> np.ma.setdiff1d(x, [1, 2])\n    masked_array(data=[3, --],\n                 mask=[False,  True],\n           fill_value=999999)\n\n    \"\"\"\n    if assume_unique:\n        ar1 = ma.asarray(ar1).ravel()\n    else:\n        ar1 = unique(ar1)\n        ar2 = unique(ar2)\n    return ar1[in1d(ar1, ar2, assume_unique=True, invert=True)]", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setdiff1d(self):\n\t    a = array([6, 5, 4, 7, 7, 1, 2, 1], mask=[0, 0, 0, 0, 0, 0, 0, 1])\n\t    b = array([2, 4, 3, 3, 2, 1, 5])\n\t    test = setdiff1d(a, b)\n\t    assert_equal(test, array([6, 7, -1], mask=[0, 0, 1]))\n\t    a = arange(10)\n\t    b = arange(8)\n\t    assert_equal(setdiff1d(a, b), array([8, 9]))\n\t    a = array([], np.uint32, mask=[])\n\t    assert_equal(setdiff1d(a, []).dtype, np.uint32)\n\t\nTestArraySetOps().test_setdiff1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestArraySetOps():\n\tdef test_setdiff1d_char_array(self):\n\t    a = np.array(['a', 'b', 'c'])\n\t    b = np.array(['a', 'b', 's'])\n\t    assert_array_equal(setdiff1d(a, b), np.array(['c']))\n\t\nTestArraySetOps().test_setdiff1d_char_array()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef setdiff1d(ar1, ar2, assume_unique=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "ndenumerate", "method_path": "../srcdata/Computation/numpy/numpy/ma/extras.py", "response": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\ndef ndenumerate(a, compressed=True):\n    \"\"\"\n    Multidimensional index iterator.\n\n    Return an iterator yielding pairs of array coordinates and values,\n    skipping elements that are masked. With `compressed=False`,\n    `ma.masked` is yielded as the value of masked elements. This\n    behavior differs from that of `numpy.ndenumerate`, which yields the\n    value of the underlying data array.\n\n    Notes\n    -----\n    .. versionadded:: 1.23.0\n\n    Parameters\n    ----------\n    a : array_like\n        An array with (possibly) masked elements.\n    compressed : bool, optional\n        If True (default), masked elements are skipped.\n\n    See Also\n    --------\n    numpy.ndenumerate : Equivalent function ignoring any mask.\n\n    Examples\n    --------\n    >>> a = np.ma.arange(9).reshape((3, 3))\n    >>> a[1, 0] = np.ma.masked\n    >>> a[1, 2] = np.ma.masked\n    >>> a[2, 1] = np.ma.masked\n    >>> a\n    masked_array(\n      data=[[0, 1, 2],\n            [--, 4, --],\n            [6, --, 8]],\n      mask=[[False, False, False],\n            [ True, False,  True],\n            [False,  True, False]],\n      fill_value=999999)\n    >>> for index, x in np.ma.ndenumerate(a):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 1) 4\n    (2, 0) 6\n    (2, 2) 8\n\n    >>> for index, x in np.ma.ndenumerate(a, compressed=False):\n    ...     print(index, x)\n    (0, 0) 0\n    (0, 1) 1\n    (0, 2) 2\n    (1, 0) --\n    (1, 1) 4\n    (1, 2) --\n    (2, 0) 6\n    (2, 1) --\n    (2, 2) 8\n    \"\"\"\n    for it, mask in zip(np.ndenumerate(a), getmaskarray(a).flat):\n        if not mask:\n            yield it\n        elif not compressed:\n            yield it[0], masked", "test_code_list": [{"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_nomasked(self):\n\t    ordinary = np.arange(6.0).reshape((1, 3, 2))\n\t    empty_mask = np.zeros_like(ordinary, dtype=bool)\n\t    with_mask = masked_array(ordinary, mask=empty_mask)\n\t    assert_equal(list(np.ndenumerate(ordinary)), list(ndenumerate(ordinary)))\n\t    assert_equal(list(ndenumerate(ordinary)), list(ndenumerate(with_mask)))\n\t    assert_equal(list(ndenumerate(with_mask)), list(ndenumerate(with_mask,\n\t        compressed=False)))\n\t\nTestNDEnumerate().test_ndenumerate_nomasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_allmasked(self):\n\t    a = masked_all(())\n\t    b = masked_all((100,))\n\t    c = masked_all((2, 3, 4))\n\t    assert_equal(list(ndenumerate(a)), [])\n\t    assert_equal(list(ndenumerate(b)), [])\n\t    assert_equal(list(ndenumerate(b, compressed=False)), list(zip(np.\n\t        ndindex((100,)), 100 * [masked])))\n\t    assert_equal(list(ndenumerate(c)), [])\n\t    assert_equal(list(ndenumerate(c, compressed=False)), list(zip(np.\n\t        ndindex((2, 3, 4)), 2 * 3 * 4 * [masked])))\n\t\nTestNDEnumerate().test_ndenumerate_allmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}, {"test_code": "import warnings\nimport itertools\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_warns\nfrom numpy.testing import suppress_warnings\nfrom numpy.ma.testutils import assert_\nfrom numpy.ma.testutils import assert_array_equal\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.ma.testutils import assert_almost_equal\nfrom numpy.ma.core import array\nfrom numpy.ma.core import arange\nfrom numpy.ma.core import masked\nfrom numpy.ma.core import MaskedArray\nfrom numpy.ma.core import masked_array\nfrom numpy.ma.core import getmaskarray\nfrom numpy.ma.core import shape\nfrom numpy.ma.core import nomask\nfrom numpy.ma.core import ones\nfrom numpy.ma.core import zeros\nfrom numpy.ma.core import count\nfrom numpy.ma.extras import atleast_1d\nfrom numpy.ma.extras import atleast_2d\nfrom numpy.ma.extras import atleast_3d\nfrom numpy.ma.extras import mr_\nfrom numpy.ma.extras import dot\nfrom numpy.ma.extras import polyfit\nfrom numpy.ma.extras import cov\nfrom numpy.ma.extras import corrcoef\nfrom numpy.ma.extras import median\nfrom numpy.ma.extras import average\nfrom numpy.ma.extras import unique\nfrom numpy.ma.extras import setxor1d\nfrom numpy.ma.extras import setdiff1d\nfrom numpy.ma.extras import union1d\nfrom numpy.ma.extras import intersect1d\nfrom numpy.ma.extras import in1d\nfrom numpy.ma.extras import ediff1d\nfrom numpy.ma.extras import apply_over_axes\nfrom numpy.ma.extras import apply_along_axis\nfrom numpy.ma.extras import compress_nd\nfrom numpy.ma.extras import compress_rowcols\nfrom numpy.ma.extras import mask_rowcols\nfrom numpy.ma.extras import clump_masked\nfrom numpy.ma.extras import clump_unmasked\nfrom numpy.ma.extras import flatnotmasked_contiguous\nfrom numpy.ma.extras import notmasked_contiguous\nfrom numpy.ma.extras import notmasked_edges\nfrom numpy.ma.extras import masked_all\nfrom numpy.ma.extras import masked_all_like\nfrom numpy.ma.extras import isin\nfrom numpy.ma.extras import diagflat\nfrom numpy.ma.extras import stack\nfrom numpy.ma.extras import vstack\nfrom numpy.ma.extras import _covhelper\n\nclass TestNDEnumerate():\n\tdef test_ndenumerate_mixedmasked(self):\n\t    a = masked_array(np.arange(12).reshape((3, 4)), mask=[[1, 1, 1, 1], [1,\n\t        1, 0, 1], [0, 0, 0, 0]])\n\t    items = [((1, 2), 6), ((2, 0), 8), ((2, 1), 9), ((2, 2), 10), ((2, 3), 11)]\n\t    assert_equal(list(ndenumerate(a)), items)\n\t    assert_equal(len(list(ndenumerate(a, compressed=False))), a.size)\n\t    for coordinate, value in ndenumerate(a, compressed=False):\n\t        assert_equal(a[coordinate], value)\n\t\nTestNDEnumerate().test_ndenumerate_mixedmasked()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_extras.py"}], "method_code_mask": "import itertools\nimport warnings\nimport numpy as np\nfrom numpy import ndarray\nfrom numpy import array as nxarray\n\n\ndef ndenumerate(a, compressed=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "eq", "method_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py", "response": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\ndef eq(v, w, msg=''):\n    result = allclose(v, w)\n    if not result:\n        print(f'Not eq:{msg}\\n{v}\\n----{w}')\n    return result", "test_code_list": [{"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_xtestCount(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_equal(3, count(ott))\n\t    assert_equal(1, count(1))\n\t    assert_(eq(0, array(1, mask=[1])))\n\t    ott = ott.reshape((2, 2))\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_(isinstance(count(ott, 0), np.ndarray))\n\t    assert_(count(ott).dtype.type is np.intp)\n\t    assert_(eq(3, count(ott)))\n\t    assert_(getmask(count(ott, 0)) is nomask)\n\t    assert_(eq([1, 2], count(ott, 0)))\n\t\nTestMa().test_xtestCount()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testCI(self):\n\t    x1 = np.array([1, 2, 4, 3])\n\t    x2 = array(x1, mask=[1, 0, 0, 0])\n\t    x3 = array(x1, mask=[0, 1, 0, 1])\n\t    x4 = array(x1)\n\t    str(x2)\n\t    repr(x2)\n\t    assert_(eq(np.sort(x1), sort(x2, fill_value=0)))\n\t    assert_(type(x2[1]) is type(x1[1]))\n\t    assert_(x1[1] == x2[1])\n\t    assert_(x2[0] is masked)\n\t    assert_(eq(x1[2], x2[2]))\n\t    assert_(eq(x1[2:5], x2[2:5]))\n\t    assert_(eq(x1[:], x2[:]))\n\t    assert_(eq(x1[1:], x3[1:]))\n\t    x1[2] = 9\n\t    x2[2] = 9\n\t    assert_(eq(x1, x2))\n\t    x1[1:3] = 99\n\t    x2[1:3] = 99\n\t    assert_(eq(x1, x2))\n\t    x2[1] = masked\n\t    assert_(eq(x1, x2))\n\t    x2[1:3] = masked\n\t    assert_(eq(x1, x2))\n\t    x2[:] = x1\n\t    x2[1] = masked\n\t    assert_(allequal(getmask(x2), array([0, 1, 0, 0])))\n\t    x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x3), array([0, 1, 1, 0])))\n\t    x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])\n\t    assert_(allequal(getmask(x4), array([0, 1, 1, 0])))\n\t    assert_(allequal(x4, array([1, 2, 3, 4])))\n\t    x1 = np.arange(5) * 1.0\n\t    x2 = masked_values(x1, 3.0)\n\t    assert_(eq(x1, x2))\n\t    assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))\n\t    assert_(eq(3.0, x2.fill_value))\n\t    x1 = array([1, 'hello', 2, 3], object)\n\t    x2 = np.array([1, 'hello', 2, 3], object)\n\t    s1 = x1[1]\n\t    s2 = x2[1]\n\t    assert_equal(type(s2), str)\n\t    assert_equal(type(s1), str)\n\t    assert_equal(s1, s2)\n\t    assert_(x1[1:1].shape == (0,))\n\t\nTestMa().test_testCI()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testCopySize(self):\n\t    n = [0, 0, 1, 0, 0]\n\t    m = make_mask(n)\n\t    m2 = make_mask(m)\n\t    assert_(m is m2)\n\t    m3 = make_mask(m, copy=True)\n\t    assert_(m is not m3)\n\t    x1 = np.arange(5)\n\t    y1 = array(x1, mask=m)\n\t    assert_(y1._data is not x1)\n\t    assert_(allequal(x1, y1._data))\n\t    assert_(y1._mask is m)\n\t    y1a = array(y1, copy=0)\n\t    assert_(y1a._mask.__array_interface__ == y1._mask.__array_interface__)\n\t    y2 = array(x1, mask=m3, copy=0)\n\t    assert_(y2._mask is m3)\n\t    assert_(y2[2] is masked)\n\t    y2[2] = 9\n\t    assert_(y2[2] is not masked)\n\t    assert_(y2._mask is m3)\n\t    assert_(allequal(y2.mask, 0))\n\t    y2a = array(x1, mask=m, copy=1)\n\t    assert_(y2a._mask is not m)\n\t    assert_(y2a[2] is masked)\n\t    y2a[2] = 9\n\t    assert_(y2a[2] is not masked)\n\t    assert_(y2a._mask is not m)\n\t    assert_(allequal(y2a.mask, 0))\n\t    y3 = array(x1 * 1.0, mask=m)\n\t    assert_(filled(y3).dtype is (x1 * 1.0).dtype)\n\t    x4 = arange(4)\n\t    x4[2] = masked\n\t    y4 = resize(x4, (8,))\n\t    assert_(eq(concatenate([x4, x4]), y4))\n\t    assert_(eq(getmask(y4), [0, 0, 1, 0, 0, 0, 1, 0]))\n\t    y5 = repeat(x4, (2, 2, 2, 2), axis=0)\n\t    assert_(eq(y5, [0, 0, 1, 1, 2, 2, 3, 3]))\n\t    y6 = repeat(x4, 2, axis=0)\n\t    assert_(eq(y5, y6))\n\t\nTestMa().test_testCopySize()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPut(self):\n\t    d = arange(5)\n\t    n = [0, 0, 0, 1, 1]\n\t    m = make_mask(n)\n\t    m2 = m.copy()\n\t    x = array(d, mask=m)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is masked)\n\t    x[[1, 4]] = [10, 40]\n\t    assert_(x._mask is m)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is not masked)\n\t    assert_(eq(x, [0, 10, 2, -1, 40]))\n\t    x = array(d, mask=m2, copy=True)\n\t    x.put([0, 1, 2], [-1, 100, 200])\n\t    assert_(x._mask is not m2)\n\t    assert_(x[3] is masked)\n\t    assert_(x[4] is masked)\n\t    assert_(eq(x, [-1, 100, 200, 0, 0]))\n\t\nTestMa().test_testPut()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPut2(self):\n\t    d = arange(5)\n\t    x = array(d, mask=[0, 0, 0, 0, 0])\n\t    z = array([10, 40], mask=[1, 0])\n\t    assert_(x[2] is not masked)\n\t    assert_(x[3] is not masked)\n\t    x[2:4] = z\n\t    assert_(x[2] is masked)\n\t    assert_(x[3] is not masked)\n\t    assert_(eq(x, [0, 1, 10, 40, 4]))\n\t    d = arange(5)\n\t    x = array(d, mask=[0, 0, 0, 0, 0])\n\t    y = x[2:4]\n\t    z = array([10, 40], mask=[1, 0])\n\t    assert_(x[2] is not masked)\n\t    assert_(x[3] is not masked)\n\t    y[:] = z\n\t    assert_(y[0] is masked)\n\t    assert_(y[1] is not masked)\n\t    assert_(eq(y, [10, 40]))\n\t    assert_(x[2] is masked)\n\t    assert_(x[3] is not masked)\n\t    assert_(eq(x, [0, 1, 10, 40, 4]))\n\t\nTestMa().test_testPut2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testOddFeatures(self):\n\t    x = arange(20)\n\t    x = x.reshape(4, 5)\n\t    x.flat[5] = 12\n\t    assert_(x[1, 0] == 12)\n\t    z = x + 10.0j * x\n\t    assert_(eq(z.real, x))\n\t    assert_(eq(z.imag, 10 * x))\n\t    assert_(eq((z * conjugate(z)).real, 101 * x * x))\n\t    z.imag[...] = 0.0\n\t    x = arange(10)\n\t    x[3] = masked\n\t    assert_(str(x[3]) == str(masked))\n\t    c = x >= 8\n\t    assert_(count(where(c, masked, masked)) == 0)\n\t    assert_(shape(where(c, masked, masked)) == c.shape)\n\t    z = where(c, x, masked)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is masked)\n\t    assert_(z[7] is masked)\n\t    assert_(z[8] is not masked)\n\t    assert_(z[9] is not masked)\n\t    assert_(eq(x, z))\n\t    z = where(c, masked, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    z = masked_where(c, x)\n\t    assert_(z.dtype is x.dtype)\n\t    assert_(z[3] is masked)\n\t    assert_(z[4] is not masked)\n\t    assert_(z[7] is not masked)\n\t    assert_(z[8] is masked)\n\t    assert_(z[9] is masked)\n\t    assert_(eq(x, z))\n\t    x = array([1.0, 2.0, 3.0, 4.0, 5.0])\n\t    c = array([1, 1, 1, 0, 0])\n\t    x[2] = masked\n\t    z = where(c, x, -x)\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    c[0] = masked\n\t    z = where(c, x, -x)\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    assert_(eq(masked_where(greater(x, 2), x), masked_greater(x, 2)))\n\t    assert_(eq(masked_where(greater_equal(x, 2), x), masked_greater_equal(x,\n\t        2)))\n\t    assert_(eq(masked_where(less(x, 2), x), masked_less(x, 2)))\n\t    assert_(eq(masked_where(less_equal(x, 2), x), masked_less_equal(x, 2)))\n\t    assert_(eq(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2)))\n\t    assert_(eq(masked_where(equal(x, 2), x), masked_equal(x, 2)))\n\t    assert_(eq(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2)))\n\t    assert_(eq(masked_inside(list(range(5)), 1, 3), [0, 199, 199, 199, 4]))\n\t    assert_(eq(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199]))\n\t    assert_(eq(masked_inside(array(list(range(5)), mask=[1, 0, 0, 0, 0]), 1,\n\t        3).mask, [1, 1, 1, 1, 0]))\n\t    assert_(eq(masked_outside(array(list(range(5)), mask=[0, 1, 0, 0, 0]), \n\t        1, 3).mask, [1, 1, 0, 0, 1]))\n\t    assert_(eq(masked_equal(array(list(range(5)), mask=[1, 0, 0, 0, 0]), 2)\n\t        .mask, [1, 0, 1, 0, 0]))\n\t    assert_(eq(masked_not_equal(array([2, 2, 1, 2, 1], mask=[1, 0, 0, 0, 0]\n\t        ), 2).mask, [1, 0, 1, 0, 1]))\n\t    assert_(eq(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]), [99, 99, 3, \n\t        4, 5]))\n\t    atest = ones((10, 10, 10), dtype=np.float32)\n\t    btest = zeros(atest.shape, MaskType)\n\t    ctest = masked_where(btest, atest)\n\t    assert_(eq(atest, ctest))\n\t    z = choose(c, (-x, x))\n\t    assert_(eq(z, [1.0, 2.0, 0.0, -4.0, -5]))\n\t    assert_(z[0] is masked)\n\t    assert_(z[1] is not masked)\n\t    assert_(z[2] is masked)\n\t    x = arange(6)\n\t    x[5] = masked\n\t    y = arange(6) * 10\n\t    y[2] = masked\n\t    c = array([1, 1, 1, 0, 0, 0], mask=[1, 0, 0, 0, 0, 0])\n\t    cm = c.filled(1)\n\t    z = where(c, x, y)\n\t    zm = where(cm, x, y)\n\t    assert_(eq(z, zm))\n\t    assert_(getmask(zm) is nomask)\n\t    assert_(eq(zm, [0, 1, 2, 30, 40, 50]))\n\t    z = where(c, masked, 1)\n\t    assert_(eq(z, [99, 99, 99, 1, 1, 1]))\n\t    z = where(c, 1, masked)\n\t    assert_(eq(z, [99, 1, 1, 99, 99, 99]))\n\t\nTestMa().test_testOddFeatures()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testMinMax2(self):\n\t    assert_(eq(minimum([1, 2, 3], [4, 0, 9]), [1, 0, 3]))\n\t    assert_(eq(maximum([1, 2, 3], [4, 0, 9]), [4, 2, 9]))\n\t    x = arange(5)\n\t    y = arange(5) - 2\n\t    x[3] = masked\n\t    y[0] = masked\n\t    assert_(eq(minimum(x, y), where(less(x, y), x, y)))\n\t    assert_(eq(maximum(x, y), where(greater(x, y), x, y)))\n\t    assert_(minimum.reduce(x) == 0)\n\t    assert_(maximum.reduce(x) == 4)\n\t\nTestMa().test_testMinMax2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testTakeTransposeInnerOuter(self):\n\t    x = arange(24)\n\t    y = np.arange(24)\n\t    x[5:6] = masked\n\t    x = x.reshape(2, 3, 4)\n\t    y = y.reshape(2, 3, 4)\n\t    assert_(eq(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1))))\n\t    assert_(eq(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1)))\n\t    assert_(eq(np.inner(filled(x, 0), filled(y, 0)), inner(x, y)))\n\t    assert_(eq(np.outer(filled(x, 0), filled(y, 0)), outer(x, y)))\n\t    y = array(['abc', 1, 'def', 2, 3], object)\n\t    y[2] = masked\n\t    t = take(y, [0, 3, 4])\n\t    assert_(t[0] == 'abc')\n\t    assert_(t[1] == 2)\n\t    assert_(t[2] == 3)\n\t\nTestMa().test_testTakeTransposeInnerOuter()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testInplace(self):\n\t    y = arange(10)\n\t    x = arange(10)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x += 1\n\t    assert_(eq(x, y + 1))\n\t    xm += 1\n\t    assert_(eq(x, y + 1))\n\t    x = arange(10)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x -= 1\n\t    assert_(eq(x, y - 1))\n\t    xm -= 1\n\t    assert_(eq(xm, y - 1))\n\t    x = arange(10) * 1.0\n\t    xm = arange(10) * 1.0\n\t    xm[2] = masked\n\t    x *= 2.0\n\t    assert_(eq(x, y * 2))\n\t    xm *= 2.0\n\t    assert_(eq(xm, y * 2))\n\t    x = arange(10) * 2\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x //= 2\n\t    assert_(eq(x, y))\n\t    xm //= 2\n\t    assert_(eq(x, y))\n\t    x = arange(10) * 1.0\n\t    xm = arange(10) * 1.0\n\t    xm[2] = masked\n\t    x /= 2.0\n\t    assert_(eq(x, y / 2.0))\n\t    xm /= arange(10)\n\t    assert_(eq(xm, ones((10,))))\n\t    x = arange(10).astype(np.float32)\n\t    xm = arange(10)\n\t    xm[2] = masked\n\t    x += 1.0\n\t    assert_(eq(x, y + 1.0))\n\t\nTestMa().test_testInplace()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testPickle(self):\n\t    x = arange(12)\n\t    x[4:10:2] = masked\n\t    x = x.reshape(4, 3)\n\t    for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):\n\t        s = pickle.dumps(x, protocol=proto)\n\t        y = pickle.loads(s)\n\t        assert_(eq(x, y))\n\t\nTestMa().test_testPickle()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testAverage1(self):\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    assert_(eq(2.0, average(ott, axis=0)))\n\t    assert_(eq(2.0, average(ott, weights=[1.0, 1.0, 2.0, 1.0])))\n\t    result, wts = average(ott, weights=[1.0, 1.0, 2.0, 1.0], returned=True)\n\t    assert_(eq(2.0, result))\n\t    assert_(wts == 4.0)\n\t    ott[:] = masked\n\t    assert_(average(ott, axis=0) is masked)\n\t    ott = array([0.0, 1.0, 2.0, 3.0], mask=[1, 0, 0, 0])\n\t    ott = ott.reshape(2, 2)\n\t    ott[:, 1] = masked\n\t    assert_(eq(average(ott, axis=0), [2.0, 0.0]))\n\t    assert_(average(ott, axis=1)[0] is masked)\n\t    assert_(eq([2.0, 0.0], average(ott, axis=0)))\n\t    result, wts = average(ott, axis=0, returned=True)\n\t    assert_(eq(wts, [1.0, 0.0]))\n\t\nTestMa().test_testAverage1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testAverage2(self):\n\t    w1 = [0, 1, 1, 1, 1, 0]\n\t    w2 = [[0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1]]\n\t    x = arange(6)\n\t    assert_(allclose(average(x, axis=0), 2.5))\n\t    assert_(allclose(average(x, axis=0, weights=w1), 2.5))\n\t    y = array([arange(6), 2.0 * arange(6)])\n\t    assert_(allclose(average(y, None), np.add.reduce(np.arange(6)) * 3.0 / \n\t        12.0))\n\t    assert_(allclose(average(y, axis=0), np.arange(6) * 3.0 / 2.0))\n\t    assert_(allclose(average(y, axis=1), [average(x, axis=0), average(x,\n\t        axis=0) * 2.0]))\n\t    assert_(allclose(average(y, None, weights=w2), 20.0 / 6.0))\n\t    assert_(allclose(average(y, axis=0, weights=w2), [0.0, 1.0, 2.0, 3.0, \n\t        4.0, 10.0]))\n\t    assert_(allclose(average(y, axis=1), [average(x, axis=0), average(x,\n\t        axis=0) * 2.0]))\n\t    m1 = zeros(6)\n\t    m2 = [0, 0, 1, 1, 0, 0]\n\t    m3 = [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]]\n\t    m4 = ones(6)\n\t    m5 = [0, 1, 1, 1, 1, 1]\n\t    assert_(allclose(average(masked_array(x, m1), axis=0), 2.5))\n\t    assert_(allclose(average(masked_array(x, m2), axis=0), 2.5))\n\t    assert_(average(masked_array(x, m4), axis=0) is masked)\n\t    assert_equal(average(masked_array(x, m5), axis=0), 0.0)\n\t    assert_equal(count(average(masked_array(x, m4), axis=0)), 0)\n\t    z = masked_array(y, m3)\n\t    assert_(allclose(average(z, None), 20.0 / 6.0))\n\t    assert_(allclose(average(z, axis=0), [0.0, 1.0, 99.0, 99.0, 4.0, 7.5]))\n\t    assert_(allclose(average(z, axis=1), [2.5, 5.0]))\n\t    assert_(allclose(average(z, axis=0, weights=w2), [0.0, 1.0, 99.0, 99.0,\n\t        4.0, 10.0]))\n\t    a = arange(6)\n\t    b = arange(6) * 3\n\t    r1, w1 = average([[a, b], [b, a]], axis=1, returned=True)\n\t    assert_equal(shape(r1), shape(w1))\n\t    assert_equal(r1.shape, w1.shape)\n\t    r2, w2 = average(ones((2, 2, 3)), axis=0, weights=[3, 1], returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), returned=True)\n\t    assert_equal(shape(w2), shape(r2))\n\t    r2, w2 = average(ones((2, 2, 3)), weights=ones((2, 2, 3)), returned=True)\n\t    assert_(shape(w2) == shape(r2))\n\t    a2d = array([[1, 2], [0, 4]], float)\n\t    a2dm = masked_array(a2d, [[0, 0], [1, 0]])\n\t    a2da = average(a2d, axis=0)\n\t    assert_(eq(a2da, [0.5, 3.0]))\n\t    a2dma = average(a2dm, axis=0)\n\t    assert_(eq(a2dma, [1.0, 3.0]))\n\t    a2dma = average(a2dm, axis=None)\n\t    assert_(eq(a2dma, 7.0 / 3.0))\n\t    a2dma = average(a2dm, axis=1)\n\t    assert_(eq(a2dma, [1.5, 4.0]))\n\t\nTestMa().test_testAverage2()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestMa():\n\tdef test_testArrayMethods(self):\n\t    a = array([1, 3, 2])\n\t    assert_(eq(a.any(), a._data.any()))\n\t    assert_(eq(a.all(), a._data.all()))\n\t    assert_(eq(a.argmax(), a._data.argmax()))\n\t    assert_(eq(a.argmin(), a._data.argmin()))\n\t    assert_(eq(a.choose(0, 1, 2, 3, 4), a._data.choose(0, 1, 2, 3, 4)))\n\t    assert_(eq(a.compress([1, 0, 1]), a._data.compress([1, 0, 1])))\n\t    assert_(eq(a.conj(), a._data.conj()))\n\t    assert_(eq(a.conjugate(), a._data.conjugate()))\n\t    m = array([[1, 2], [3, 4]])\n\t    assert_(eq(m.diagonal(), m._data.diagonal()))\n\t    assert_(eq(a.sum(), a._data.sum()))\n\t    assert_(eq(a.take([1, 2]), a._data.take([1, 2])))\n\t    assert_(eq(m.transpose(), m._data.transpose()))\n\t\nTestMa().test_testArrayMethods()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}, {"test_code": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\nclass TestUfuncs():\n\tdef test_nonzero(self):\n\t    for t in '?bhilqpBHILQPfdgFDGO':\n\t        x = array([1, 0, 2, 0], mask=[0, 0, 1, 1])\n\t        assert_(eq(nonzero(x), [0]))\n\t\nTestUfuncs().test_nonzero()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/ma/tests/test_old_ma.py"}], "method_code_mask": "from functools import reduce\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.ma import MaskType\nfrom numpy.ma import MaskedArray\nfrom numpy.ma import absolute\nfrom numpy.ma import add\nfrom numpy.ma import all\nfrom numpy.ma import allclose\nfrom numpy.ma import allequal\nfrom numpy.ma import alltrue\nfrom numpy.ma import arange\nfrom numpy.ma import arccos\nfrom numpy.ma import arcsin\nfrom numpy.ma import arctan\nfrom numpy.ma import arctan2\nfrom numpy.ma import array\nfrom numpy.ma import average\nfrom numpy.ma import choose\nfrom numpy.ma import concatenate\nfrom numpy.ma import conjugate\nfrom numpy.ma import cos\nfrom numpy.ma import cosh\nfrom numpy.ma import count\nfrom numpy.ma import divide\nfrom numpy.ma import equal\nfrom numpy.ma import exp\nfrom numpy.ma import filled\nfrom numpy.ma import getmask\nfrom numpy.ma import greater\nfrom numpy.ma import greater_equal\nfrom numpy.ma import inner\nfrom numpy.ma import isMaskedArray\nfrom numpy.ma import less\nfrom numpy.ma import less_equal\nfrom numpy.ma import log\nfrom numpy.ma import log10\nfrom numpy.ma import make_mask\nfrom numpy.ma import masked\nfrom numpy.ma import masked_array\nfrom numpy.ma import masked_equal\nfrom numpy.ma import masked_greater\nfrom numpy.ma import masked_greater_equal\nfrom numpy.ma import masked_inside\nfrom numpy.ma import masked_less\nfrom numpy.ma import masked_less_equal\nfrom numpy.ma import masked_not_equal\nfrom numpy.ma import masked_outside\nfrom numpy.ma import masked_print_option\nfrom numpy.ma import masked_values\nfrom numpy.ma import masked_where\nfrom numpy.ma import maximum\nfrom numpy.ma import minimum\nfrom numpy.ma import multiply\nfrom numpy.ma import nomask\nfrom numpy.ma import nonzero\nfrom numpy.ma import not_equal\nfrom numpy.ma import ones\nfrom numpy.ma import outer\nfrom numpy.ma import product\nfrom numpy.ma import put\nfrom numpy.ma import ravel\nfrom numpy.ma import repeat\nfrom numpy.ma import resize\nfrom numpy.ma import shape\nfrom numpy.ma import sin\nfrom numpy.ma import sinh\nfrom numpy.ma import sometrue\nfrom numpy.ma import sort\nfrom numpy.ma import sqrt\nfrom numpy.ma import subtract\nfrom numpy.ma import sum\nfrom numpy.ma import take\nfrom numpy.ma import tan\nfrom numpy.ma import tanh\nfrom numpy.ma import transpose\nfrom numpy.ma import where\nfrom numpy.ma import zeros\n\n\ndef eq(v, w, msg=''): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "markinnerspaces", "method_path": "../srcdata/Computation/numpy/numpy/f2py/crackfortran.py", "response": "import sys\nimport string\nimport fileinput\nimport re\nimport os\nimport copy\nimport platform\nimport codecs\nfrom pathlib import Path\nimport charset_normalizer\ndef markinnerspaces(line):\n    \"\"\"\n    The function replace all spaces in the input variable line which are \n    surrounded with quotation marks, with the triplet \"@_@\".\n\n    For instance, for the input \"a 'b c'\" the function returns \"a 'b@_@c'\"\n\n    Parameters\n    ----------\n    line : str\n\n    Returns\n    -------\n    str\n\n    \"\"\"\n    fragment = ''\n    inside = False\n    current_quote = None\n    escaped = ''\n    for c in line:\n        if escaped == '\\\\' and c in ['\\\\', \"'\", '\"']:\n            fragment += c\n            escaped = c\n            continue\n        if not inside and c in [\"'\", '\"']:\n            current_quote = c\n        if c == current_quote:\n            inside = not inside\n        elif c == ' ' and inside:\n            fragment += '@_@'\n            continue\n        fragment += c\n        escaped = c\n    return fragment", "test_code_list": [{"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_do_not_touch_normal_spaces(self):\n\t    test_list = ['a ', ' a', 'a b c', \"'abcdefghij'\"]\n\t    for i in test_list:\n\t        assert markinnerspaces(i) == i\n\t\nTestMarkinnerspaces().test_do_not_touch_normal_spaces()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}, {"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_one_relevant_space(self):\n\t    assert markinnerspaces(\"a 'b c' \\\\' \\\\'\") == \"a 'b@_@c' \\\\' \\\\'\"\n\t    assert markinnerspaces('a \"b c\" \\\\\" \\\\\"') == 'a \"b@_@c\" \\\\\" \\\\\"'\n\t\nTestMarkinnerspaces().test_one_relevant_space()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}, {"test_code": "import importlib\nimport codecs\nimport time\nimport unicodedata\nimport pytest\nimport numpy as np\nfrom numpy.f2py.crackfortran import markinnerspaces\nfrom numpy.f2py.crackfortran import nameargspattern\nfrom numpy.f2py import crackfortran\nimport textwrap\nimport contextlib\nimport io\n\nclass TestMarkinnerspaces():\n\tdef test_ignore_inner_quotes(self):\n\t    assert markinnerspaces('a \\'b c\" \" d\\' e') == 'a \\'b@_@c\"@_@\"@_@d\\' e'\n\t    assert markinnerspaces('a \"b c\\' \\' d\" e') == 'a \"b@_@c\\'@_@\\'@_@d\" e'\n\t\nTestMarkinnerspaces().test_ignore_inner_quotes()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/f2py/tests/test_crackfortran.py"}], "method_code_mask": "import sys\nimport string\nimport fileinput\nimport re\nimport os\nimport copy\nimport platform\nimport codecs\nfrom pathlib import Path\nimport charset_normalizer\n\n\ndef markinnerspaces(line): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "fft1", "method_path": "../srcdata/Computation/numpy/numpy/fft/tests/test_pocketfft.py", "response": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\ndef fft1(x):\n    L = len(x)\n    phase = -2.0j * np.pi * (np.arange(L) / L)\n    phase = np.arange(L).reshape(-1, 1) * phase\n    return np.sum(x * np.exp(phase), axis=1)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\n\nclass TestFFT1D():\n\tdef test_fft(self):\n\t    x = random(30) + 1.0j * random(30)\n\t    assert_allclose(fft1(x), np.fft.fft(x), atol=1e-06)\n\t    assert_allclose(fft1(x), np.fft.fft(x, norm='backward'), atol=1e-06)\n\t    assert_allclose(fft1(x) / np.sqrt(30), np.fft.fft(x, norm='ortho'),\n\t        atol=1e-06)\n\t    assert_allclose(fft1(x) / 30.0, np.fft.fft(x, norm='forward'), atol=1e-06)\n\t\nTestFFT1D().test_fft()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/fft/tests/test_pocketfft.py"}], "method_code_mask": "import numpy as np\nimport pytest\nfrom numpy.random import random\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nimport threading\nimport queue\n\n\ndef fft1(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermval(x, c, tensor=True):\n    \"\"\"\n    Evaluate an Hermite series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    hermval2d, hermgrid2d, hermval3d, hermgrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermval\n    >>> coef = [1,2,3]\n    >>> hermval(1, coef)\n    11.0\n    >>> hermval([[1,2],[3,4]], coef)\n    array([[ 11.,   51.],\n           [115.,  203.]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    x2 = x * 2\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (2 * (nd - 1))\n            c1 = tmp + c1 * x2\n    return c0 + c1 * x2", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_hermvander(self):\n\t    x = np.arange(3)\n\t    v = herm.hermvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = herm.hermvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermval(x, coef))\n\t\nTestVander().test_hermvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_hermfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], -1)\n\t    assert_raises(TypeError, herm.hermfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], [-1])\n\t    assert_raises(ValueError, herm.hermfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, herm.hermfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = herm.hermfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermval(x, coef3), y)\n\t    coef3 = herm.hermfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermval(x, coef3), y)\n\t    coef4 = herm.hermfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef4 = herm.hermfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef4 = herm.hermfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermval(x, coef4), y)\n\t    coef2d = herm.hermfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = herm.hermfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = herm.hermfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = herm.hermfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = herm.hermfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = herm.hermfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(herm.hermfit(x, x, 1), [0, 0.5])\n\t    assert_almost_equal(herm.hermfit(x, x, [0, 1]), [0, 0.5])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = herm.hermfit(x, y, 4)\n\t    assert_almost_equal(hermval(x, coef1), y)\n\t    coef2 = herm.hermfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(hermval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_hermfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "polyval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef polyval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a polynomial at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value\n\n    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, compatible object\n        The shape of the returned array is described above.\n\n    See Also\n    --------\n    polyval2d, polygrid2d, polyval3d, polygrid3d\n\n    Notes\n    -----\n    The evaluation uses Horner's method.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.polynomial import polyval\n    >>> polyval(1, [1,2,3])\n    6.0\n    >>> a = np.arange(4).reshape(2,2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> polyval(a, [1, 2, 3])\n    array([[ 1.,   6.],\n           [17.,  34.]])\n    >>> coef = np.arange(4).reshape(2, 2)  # multidimensional coefficients\n    >>> coef\n    array([[0, 1],\n           [2, 3]])\n    >>> polyval([1, 2], coef, tensor=True)\n    array([[2.,  4.],\n           [4.,  7.]])\n    >>> polyval([1, 2], coef, tensor=False)\n    array([2.,  7.])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c + 0.0\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    c0 = c[-1] + x * 0\n    for i in range(2, len(c) + 1):\n        c0 = c[-i] + c0 * x\n    return c0", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestEvaluation():\n\tdef test_polyval(self):\n\t    assert_equal(polyval([], [1]).size, 0)\n\t    x = np.linspace(-1, 1)\n\t    y = [(x ** i) for i in range(5)]\n\t    for i in range(5):\n\t        tgt = y[i]\n\t        res = polyval(x, [0] * i + [1])\n\t        assert_almost_equal(res, tgt)\n\t    tgt = x * (x ** 2 - 1)\n\t    res = polyval(x, [0, -1, 0, 1])\n\t    assert_almost_equal(res, tgt)\n\t    for i in range(3):\n\t        dims = [2] * i\n\t        x = np.zeros(dims)\n\t        assert_equal(polyval(x, [1]).shape, dims)\n\t        assert_equal(polyval(x, [1, 0]).shape, dims)\n\t        assert_equal(polyval(x, [1, 0, 0]).shape, dims)\n\t    mask = [False, True, False]\n\t    mx = np.ma.array([1, 2, 3], mask=mask)\n\t    res = np.polyval([7, 5, 3], mx)\n\t    assert_array_equal(res.mask, mask)\n\t\n\t\n\t    class C(np.ndarray):\n\t        pass\n\t    cx = np.array([1, 2, 3]).view(C)\n\t    assert_equal(type(np.polyval([2, 3, 4], cx)), C)\n\t\nTestEvaluation().test_polyval()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestVander():\n\tdef test_polyvander(self):\n\t    x = np.arange(3)\n\t    v = poly.polyvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], polyval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = poly.polyvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], polyval(x, coef))\n\t\nTestVander().test_polyvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], -1)\n\t    assert_raises(TypeError, poly.polyfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], [-1])\n\t    assert_raises(ValueError, poly.polyfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, poly.polyfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = poly.polyfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(polyval(x, coef3), y)\n\t    coef3 = poly.polyfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(polyval(x, coef3), y)\n\t    coef4 = poly.polyfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(polyval(x, coef4), y)\n\t    coef4 = poly.polyfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(polyval(x, coef4), y)\n\t    coef2d = poly.polyfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = poly.polyfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    yw[0::2] = 0\n\t    wcoef3 = poly.polyfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = poly.polyfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(poly.polyfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(poly.polyfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = poly.polyfit(x, y, 4)\n\t    assert_almost_equal(polyval(x, coef1), y)\n\t    coef2 = poly.polyfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(polyval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestMisc().test_polyfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermline(off, scl):\n    \"\"\"\n    Hermite series whose graph is a straight line.\n\n\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Hermite series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermline, hermval\n    >>> hermval(0,hermline(3, 2))\n    3.0\n    >>> hermval(1,hermline(3, 2))\n    5.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl / 2])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_hermline(self):\n\t    assert_equal(hermline(3, 4), [3, 2])\n\t\nTestMisc().test_hermline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermline(off, scl): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermweight(x):\n    \"\"\"\n    Weight function of the Hermite polynomials.\n\n    The weight function is :math:`\\\\exp(-x^2)` and the interval of\n    integration is :math:`[-\\\\inf, \\\\inf]`. the Hermite polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite import hermweight\n    >>> x = np.arange(-2, 2)\n    >>> hermweight(x)\n    array([0.01831564, 0.36787944, 1.        , 0.36787944])\n\n    \"\"\"\n    w = np.exp(-x ** 2)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite as herm\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-5, 5, 11)\n\t    tgt = np.exp(-x ** 2)\n\t    res = hermweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermweight(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "trimseq", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polyutils.py", "response": "import operator\nimport functools\nimport warnings\nimport numpy as np\ndef trimseq(seq):\n    \"\"\"Remove small Poly series coefficients.\n\n    Parameters\n    ----------\n    seq : sequence\n        Sequence of Poly series coefficients.\n\n    Returns\n    -------\n    series : sequence\n        Subsequence with trailing zeros removed. If the resulting sequence\n        would be empty, return the first element. The returned sequence may\n        or may not be a view.\n\n    Notes\n    -----\n    Do not lose the type info if the sequence contains unknown objects.\n\n    \"\"\"\n    if len(seq) == 0 or seq[-1] != 0:\n        return seq\n    else:\n        for i in range(len(seq) - 1, -1, -1):\n            if seq[i] != 0:\n                break\n        return seq[:i + 1]", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_trimseq(self):\n\t    tgt = [1]\n\t    for num_trailing_zeros in range(5):\n\t        res = trimseq([1] + [0] * num_trailing_zeros)\n\t        assert_equal(res, tgt)\n\t\nTestMisc().test_trimseq()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}, {"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_trimseq_empty_input(self):\n\t    for empty_seq in [[], np.array([], dtype=np.int32)]:\n\t        assert_equal(trimseq(empty_seq), empty_seq)\n\t\nTestMisc().test_trimseq_empty_input()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}], "method_code_mask": "import operator\nimport functools\nimport warnings\nimport numpy as np\n\n\ndef trimseq(seq): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "mapparms", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polyutils.py", "response": "import operator\nimport functools\nimport warnings\nimport numpy as np\ndef mapparms(old, new):\n    \"\"\"\n    Linear map parameters between domains.\n\n    Return the parameters of the linear map ``offset + scale*x`` that maps\n    `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.\n\n    Parameters\n    ----------\n    old, new : array_like\n        Domains. Each domain must (successfully) convert to a 1-d array\n        containing precisely two values.\n\n    Returns\n    -------\n    offset, scale : scalars\n        The map ``L(x) = offset + scale*x`` maps the first domain to the\n        second.\n\n    See Also\n    --------\n    getdomain, mapdomain\n\n    Notes\n    -----\n    Also works for complex numbers, and thus can be used to calculate the\n    parameters required to map any line in the complex plane to any other\n    line therein.\n\n    Examples\n    --------\n    >>> from numpy.polynomial import polyutils as pu\n    >>> pu.mapparms((-1,1),(-1,1))\n    (0.0, 1.0)\n    >>> pu.mapparms((1,-1),(-1,1))\n    (-0.0, -1.0)\n    >>> i = complex(0,1)\n    >>> pu.mapparms((-i,-1),(1,i))\n    ((1+1j), (1-0j))\n\n    \"\"\"\n    oldlen = old[1] - old[0]\n    newlen = new[1] - new[0]\n    off = (old[1] * new[0] - old[0] * new[1]) / oldlen\n    scl = newlen / oldlen\n    return off, scl", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.polynomial.polyutils as pu\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestDomain():\n\tdef test_mapparms(self):\n\t    dom1 = [0, 4]\n\t    dom2 = [1, 3]\n\t    tgt = [1, 0.5]\n\t    res = mapparms(dom1, dom2)\n\t    assert_almost_equal(res, tgt)\n\t    dom1 = [0 - 1.0j, 2 + 1.0j]\n\t    dom2 = [-2, 2]\n\t    tgt = [-1 + 1.0j, 1 - 1.0j]\n\t    res = mapparms(dom1, dom2)\n\t    assert_almost_equal(res, tgt)\n\t\nTestDomain().test_mapparms()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polyutils.py"}], "method_code_mask": "import operator\nimport functools\nimport warnings\nimport numpy as np\n\n\ndef mapparms(old, new): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "lagval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/laguerre.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef lagval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Laguerre series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    lagval2d, laggrid2d, lagval3d, laggrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.laguerre import lagval\n    >>> coef = [1, 2, 3]\n    >>> lagval(1, coef)\n    -0.5\n    >>> lagval([[1, 2],[3, 4]], coef)\n    array([[-0.5, -4. ],\n           [-4.5, -2. ]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1) / nd\n            c1 = tmp + c1 * (2 * nd - 1 - x) / nd\n    return c0 + c1 * (1 - x)", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_lagvander(self):\n\t    x = np.arange(3)\n\t    v = lag.lagvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], lagval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = lag.lagvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], lagval(x, coef))\n\t\nTestVander().test_lagvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_lagfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], -1)\n\t    assert_raises(TypeError, lag.lagfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], [-1])\n\t    assert_raises(ValueError, lag.lagfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, lag.lagfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = lag.lagfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(lagval(x, coef3), y)\n\t    coef3 = lag.lagfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(lagval(x, coef3), y)\n\t    coef4 = lag.lagfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(lagval(x, coef4), y)\n\t    coef4 = lag.lagfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(lagval(x, coef4), y)\n\t    coef2d = lag.lagfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = lag.lagfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = lag.lagfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = lag.lagfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = lag.lagfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = lag.lagfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(lag.lagfit(x, x, 1), [1, -1])\n\t    assert_almost_equal(lag.lagfit(x, x, [0, 1]), [1, -1])\n\t\nTestFitting().test_lagfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef lagval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "lagweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/laguerre.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef lagweight(x):\n    \"\"\"Weight function of the Laguerre polynomials.\n\n    The weight function is :math:`exp(-x)` and the interval of integration\n    is :math:`[0, \\\\inf]`. The Laguerre polynomials are orthogonal, but not\n    normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    Examples\n    --------\n    >>> from numpy.polynomial.laguerre import lagweight\n    >>> x = np.array([0, 1, 2])\n    >>> lagweight(x)\n    array([1.        , 0.36787944, 0.13533528])\n\n    \"\"\"\n    w = np.exp(-x)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.laguerre as lag\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(0, 10, 11)\n\t    tgt = np.exp(-x)\n\t    res = lagweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_laguerre.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef lagweight(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_cseries_to_zseries", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef _cseries_to_zseries(c):\n    \"\"\"Convert Chebyshev series to z-series.\n\n    Convert a Chebyshev series to the equivalent z-series. The result is\n    never an empty array. The dtype of the return is the same as that of\n    the input. No checks are run on the arguments as this routine is for\n    internal use.\n\n    Parameters\n    ----------\n    c : 1-D ndarray\n        Chebyshev coefficients, ordered from low to high\n\n    Returns\n    -------\n    zs : 1-D ndarray\n        Odd length symmetric z-series, ordered from  low to high.\n\n    \"\"\"\n    n = c.size\n    zs = np.zeros(2 * n - 1, dtype=c.dtype)\n    zs[n - 1:] = c / 2\n    return zs + zs[::-1]", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestPrivate():\n\tdef test__cseries_to_zseries(self):\n\t    for i in range(5):\n\t        inp = np.array([2] + [1] * i, np.double)\n\t        tgt = np.array([0.5] * i + [2] + [0.5] * i, np.double)\n\t        res = _cseries_to_zseries(inp)\n\t        assert_equal(res, tgt)\n\t\nTestPrivate().test__cseries_to_zseries()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef _cseries_to_zseries(c): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_zseries_to_cseries", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef _zseries_to_cseries(zs):\n    \"\"\"Convert z-series to a Chebyshev series.\n\n    Convert a z series to the equivalent Chebyshev series. The result is\n    never an empty array. The dtype of the return is the same as that of\n    the input. No checks are run on the arguments as this routine is for\n    internal use.\n\n    Parameters\n    ----------\n    zs : 1-D ndarray\n        Odd length symmetric z-series, ordered from  low to high.\n\n    Returns\n    -------\n    c : 1-D ndarray\n        Chebyshev coefficients, ordered from  low to high.\n\n    \"\"\"\n    n = (zs.size + 1) // 2\n    c = zs[n - 1:].copy()\n    c[1:n] *= 2\n    return c", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestPrivate():\n\tdef test__zseries_to_cseries(self):\n\t    for i in range(5):\n\t        inp = np.array([0.5] * i + [2] + [0.5] * i, np.double)\n\t        tgt = np.array([2] + [1] * i, np.double)\n\t        res = _zseries_to_cseries(inp)\n\t        assert_equal(res, tgt)\n\t\nTestPrivate().test__zseries_to_cseries()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef _zseries_to_cseries(zs): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "chebval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef chebval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Chebyshev series at points x.\n\n    If `c` is of length `n + 1`, this function returns the value:\n\n    .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    chebval2d, chebgrid2d, chebval3d, chebgrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=True)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        x2 = 2 * x\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            c0 = c[-i] - c1\n            c1 = tmp + c1 * x2\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_chebvander(self):\n\t    x = np.arange(3)\n\t    v = cheb.chebvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], chebval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = cheb.chebvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], chebval(x, coef))\n\t\nTestVander().test_chebvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_chebfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], -1)\n\t    assert_raises(TypeError, cheb.chebfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], [-1])\n\t    assert_raises(ValueError, cheb.chebfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, cheb.chebfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = cheb.chebfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(chebval(x, coef3), y)\n\t    coef3 = cheb.chebfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(chebval(x, coef3), y)\n\t    coef4 = cheb.chebfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef4 = cheb.chebfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef4 = cheb.chebfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(chebval(x, coef4), y)\n\t    coef2d = cheb.chebfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = cheb.chebfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = cheb.chebfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = cheb.chebfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = cheb.chebfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = cheb.chebfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(cheb.chebfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(cheb.chebfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = cheb.chebfit(x, y, 4)\n\t    assert_almost_equal(chebval(x, coef1), y)\n\t    coef2 = cheb.chebfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(chebval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_chebfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestInterpolate():\n\tdef test_approximation(self):\n\t\n\t    def powx(x, p):\n\t        return x ** p\n\t    x = np.linspace(-1, 1, 10)\n\t    for deg in range(0, 10):\n\t        for p in range(0, deg + 1):\n\t            c = cheb.chebinterpolate(powx, deg, (p,))\n\t            assert_almost_equal(chebval(x, c), powx(x, p), decimal=12)\n\t\nTestInterpolate().test_approximation()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "chebline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef chebline(off, scl):\n    \"\"\"\n    Chebyshev series whose graph is a straight line.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Chebyshev series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> import numpy.polynomial.chebyshev as C\n    >>> C.chebline(3,2)\n    array([3, 2])\n    >>> C.chebval(-3, C.chebline(3,2)) # should be -3\n    -3.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_chebline(self):\n\t    assert_equal(chebline(3, 4), [3, 4])\n\t\nTestMisc().test_chebline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebline(off, scl): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "chebweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef chebweight(x):\n    \"\"\"\n    The weight function of the Chebyshev polynomials.\n\n    The weight function is :math:`1/\\\\sqrt{1 - x^2}` and the interval of\n    integration is :math:`[-1, 1]`. The Chebyshev polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = 1.0 / (np.sqrt(1.0 + x) * np.sqrt(1.0 - x))\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-1, 1, 11)[1:-1]\n\t    tgt = 1.0 / (np.sqrt(1 + x) * np.sqrt(1 - x))\n\t    res = chebweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebweight(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "chebpts1", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/chebyshev.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef chebpts1(npts):\n    \"\"\"\n    Chebyshev points of the first kind.\n\n    The Chebyshev points of the first kind are the points ``cos(x)``,\n    where ``x = [pi*(k + .5)/npts for k in range(npts)]``.\n\n    Parameters\n    ----------\n    npts : int\n        Number of sample points desired.\n\n    Returns\n    -------\n    pts : ndarray\n        The Chebyshev points of the first kind.\n\n    See Also\n    --------\n    chebpts2\n\n    Notes\n    -----\n\n    .. versionadded:: 1.5.0\n\n    \"\"\"\n    _npts = int(npts)\n    if _npts != npts:\n        raise ValueError('npts must be integer')\n    if _npts < 1:\n        raise ValueError('npts must be >= 1')\n    x = 0.5 * np.pi / _npts * np.arange(-_npts + 1, _npts + 1, 2)\n    return np.sin(x)", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.chebyshev as cheb\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_chebpts1(self):\n\t    assert_raises(ValueError, chebpts1, 1.5)\n\t    assert_raises(ValueError, chebpts1, 0)\n\t    tgt = [0]\n\t    assert_almost_equal(chebpts1(1), tgt)\n\t    tgt = [-0.7071067811865475, 0.7071067811865475]\n\t    assert_almost_equal(chebpts1(2), tgt)\n\t    tgt = [-0.8660254037844387, 0, 0.8660254037844387]\n\t    assert_almost_equal(chebpts1(3), tgt)\n\t    tgt = [-0.9238795325, -0.3826834323, 0.3826834323, 0.9238795325]\n\t    assert_almost_equal(chebpts1(4), tgt)\n\t\nTestMisc().test_chebpts1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_chebyshev.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef chebpts1(npts): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "polyvalfromroots", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef polyvalfromroots(x, r, tensor=True):\n    \"\"\"\n    Evaluate a polynomial specified by its roots at points x.\n\n    If `r` is of length ``N``, this function returns the value\n\n    .. math:: p(x) = \\\\prod_{n=1}^{N} (x - r_n)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `r`.\n\n    If `r` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If `r`\n    is multidimensional, then the shape of the result depends on the value of\n    `tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;\n    that is, each polynomial is evaluated at every value of `x`. If `tensor` is\n    ``False``, the shape will be r.shape[1:]; that is, each polynomial is\n    evaluated only for the corresponding broadcast value of `x`. Note that\n    scalars have shape (,).\n\n    .. versionadded:: 1.12\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `r`.\n    r : array_like\n        Array of roots. If `r` is multidimensional the first index is the\n        root index, while the remaining indices enumerate multiple\n        polynomials. For instance, in the two dimensional case the roots\n        of each polynomial may be thought of as stored in the columns of `r`.\n    tensor : boolean, optional\n        If True, the shape of the roots array is extended with ones on the\n        right, one for each dimension of `x`. Scalars have dimension 0 for this\n        action. The result is that every column of coefficients in `r` is\n        evaluated for every element of `x`. If False, `x` is broadcast over the\n        columns of `r` for the evaluation.  This keyword is useful when `r` is\n        multidimensional. The default value is True.\n\n    Returns\n    -------\n    values : ndarray, compatible object\n        The shape of the returned array is described above.\n\n    See Also\n    --------\n    polyroots, polyfromroots, polyval\n\n    Examples\n    --------\n    >>> from numpy.polynomial.polynomial import polyvalfromroots\n    >>> polyvalfromroots(1, [1, 2, 3])\n    0.0\n    >>> a = np.arange(4).reshape(2, 2)\n    >>> a\n    array([[0, 1],\n           [2, 3]])\n    >>> polyvalfromroots(a, [-1, 0, 1])\n    array([[-0.,   0.],\n           [ 6.,  24.]])\n    >>> r = np.arange(-2, 2).reshape(2,2)  # multidimensional coefficients\n    >>> r # each column of r defines one polynomial\n    array([[-2, -1],\n           [ 0,  1]])\n    >>> b = [-2, 1]\n    >>> polyvalfromroots(b, r, tensor=True)\n    array([[-0.,  3.],\n           [ 3., 0.]])\n    >>> polyvalfromroots(b, r, tensor=False)\n    array([-0.,  0.])\n\n    \"\"\"\n    r = np.array(r, ndmin=1, copy=None)\n    if r.dtype.char in '?bBhHiIlLqQpP':\n        r = r.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray):\n        if tensor:\n            r = r.reshape(r.shape + (1,) * x.ndim)\n        elif x.ndim >= r.ndim:\n            raise ValueError('x.ndim must be < r.ndim when tensor == False')\n    return np.prod(x - r, axis=0)", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestEvaluation():\n\tdef test_polyvalfromroots(self):\n\t    assert_raises(ValueError, polyvalfromroots, [1], [1], tensor=False)\n\t    assert_equal(polyvalfromroots([], [1]).size, 0)\n\t    assert_(polyvalfromroots([], [1]).shape == (0,))\n\t    assert_equal(polyvalfromroots([], [[1] * 5]).size, 0)\n\t    assert_(polyvalfromroots([], [[1] * 5]).shape == (5, 0))\n\t    assert_equal(polyvalfromroots(1, 1), 0)\n\t    assert_(polyvalfromroots(1, np.ones((3, 3))).shape == (3,))\n\t    x = np.linspace(-1, 1)\n\t    y = [(x ** i) for i in range(5)]\n\t    for i in range(1, 5):\n\t        tgt = y[i]\n\t        res = polyvalfromroots(x, [0] * i)\n\t        assert_almost_equal(res, tgt)\n\t    tgt = x * (x - 1) * (x + 1)\n\t    res = polyvalfromroots(x, [-1, 0, 1])\n\t    assert_almost_equal(res, tgt)\n\t    for i in range(3):\n\t        dims = [2] * i\n\t        x = np.zeros(dims)\n\t        assert_equal(polyvalfromroots(x, [1]).shape, dims)\n\t        assert_equal(polyvalfromroots(x, [1, 0]).shape, dims)\n\t        assert_equal(polyvalfromroots(x, [1, 0, 0]).shape, dims)\n\t    ptest = [15, 2, -16, -2, 1]\n\t    r = poly.polyroots(ptest)\n\t    x = np.linspace(-1, 1)\n\t    assert_almost_equal(poly.polyval(x, ptest), polyvalfromroots(x, r))\n\t    rshape = 3, 5\n\t    x = np.arange(-3, 2)\n\t    r = np.random.randint(-5, 5, size=rshape)\n\t    res = polyvalfromroots(x, r, tensor=False)\n\t    tgt = np.empty(r.shape[1:])\n\t    for ii in range(tgt.size):\n\t        tgt[ii] = polyvalfromroots(x[ii], r[:, ii])\n\t    assert_equal(res, tgt)\n\t    x = np.vstack([x, 2 * x])\n\t    res = polyvalfromroots(x, r, tensor=True)\n\t    tgt = np.empty(r.shape[1:] + x.shape)\n\t    for ii in range(r.shape[1]):\n\t        for jj in range(x.shape[0]):\n\t            tgt[ii, jj, :] = polyvalfromroots(x[jj], r[:, ii])\n\t    assert_equal(res, tgt)\n\t\nTestEvaluation().test_polyvalfromroots()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyvalfromroots(x, r, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "polyline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/polynomial.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef polyline(off, scl):\n    \"\"\"\n    Returns an array representing a linear polynomial.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The \"y-intercept\" and \"slope\" of the line, respectively.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the linear polynomial ``off +\n        scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> from numpy.polynomial import polynomial as P\n    >>> P.polyline(1, -1)\n    array([ 1, -1])\n    >>> P.polyval(1, P.polyline(1, -1))  # should be 0\n    0.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyline(self):\n\t    assert_equal(polyline(3, 4), [3, 4])\n\t\nTestMisc().test_polyline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}, {"test_code": "from functools import reduce\nfrom fractions import Fraction\nimport numpy as np\nimport numpy.polynomial.polynomial as poly\nimport pickle\nfrom copy import deepcopy\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\n\nclass TestMisc():\n\tdef test_polyline_zero(self):\n\t    assert_equal(polyline(3, 0), [3])\n\t\nTestMisc().test_polyline_zero()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_polynomial.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef polyline(off, scl): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermeval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermeval(x, c, tensor=True):\n    \"\"\"\n    Evaluate an HermiteE series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        with themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    hermeval2d, hermegrid2d, hermeval3d, hermegrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite_e import hermeval\n    >>> coef = [1,2,3]\n    >>> hermeval(1, coef)\n    3.0\n    >>> hermeval([[1,2],[3,4]], coef)\n    array([[ 3., 14.],\n           [31., 54.]])\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1)\n            c1 = tmp + c1 * x\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_hermevander(self):\n\t    x = np.arange(3)\n\t    v = herme.hermevander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermeval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = herme.hermevander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], hermeval(x, coef))\n\t\nTestVander().test_hermevander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_hermefit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], -1)\n\t    assert_raises(TypeError, herme.hermefit, [[1]], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], [-1])\n\t    assert_raises(ValueError, herme.hermefit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, herme.hermefit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = herme.hermefit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermeval(x, coef3), y)\n\t    coef3 = herme.hermefit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(hermeval(x, coef3), y)\n\t    coef4 = herme.hermefit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef4 = herme.hermefit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef4 = herme.hermefit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(hermeval(x, coef4), y)\n\t    coef2d = herme.hermefit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = herme.hermefit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = herme.hermefit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = herme.hermefit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = herme.hermefit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = herme.hermefit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(herme.hermefit(x, x, 1), [0, 1])\n\t    assert_almost_equal(herme.hermefit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = herme.hermefit(x, y, 4)\n\t    assert_almost_equal(hermeval(x, coef1), y)\n\t    coef2 = herme.hermefit(x, y, [0, 2, 4])\n\t    assert_almost_equal(hermeval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_hermefit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermeline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermeline(off, scl):\n    \"\"\"\n    Hermite series whose graph is a straight line.\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Hermite series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.legendre.legline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite_e import hermeline\n    >>> from numpy.polynomial.hermite_e import hermeline, hermeval\n    >>> hermeval(0,hermeline(3, 2))\n    3.0\n    >>> hermeval(1,hermeline(3, 2))\n    5.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_hermeline(self):\n\t    assert_equal(hermeline(3, 4), [3, 4])\n\t\nTestMisc().test_hermeline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeline(off, scl): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "hermeweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/hermite_e.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef hermeweight(x):\n    \"\"\"Weight function of the Hermite_e polynomials.\n\n    The weight function is :math:`\\\\exp(-x^2/2)` and the interval of\n    integration is :math:`[-\\\\inf, \\\\inf]`. the HermiteE polynomials are\n    orthogonal, but not normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = np.exp(-0.5 * x ** 2)\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.hermite_e as herme\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-5, 5, 11)\n\t    tgt = np.exp(-0.5 * x ** 2)\n\t    res = hermeweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_hermite_e.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef hermeweight(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "legval", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef legval(x, c, tensor=True):\n    \"\"\"\n    Evaluate a Legendre series at points x.\n\n    If `c` is of length ``n + 1``, this function returns the value:\n\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n\n    The parameter `x` is converted to an array only if it is a tuple or a\n    list, otherwise it is treated as a scalar. In either case, either `x`\n    or its elements must support multiplication and addition both with\n    themselves and with the elements of `c`.\n\n    If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If\n    `c` is multidimensional, then the shape of the result depends on the\n    value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +\n    x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that\n    scalars have shape (,).\n\n    Trailing zeros in the coefficients will be used in the evaluation, so\n    they should be avoided if efficiency is a concern.\n\n    Parameters\n    ----------\n    x : array_like, compatible object\n        If `x` is a list or tuple, it is converted to an ndarray, otherwise\n        it is left unchanged and treated as a scalar. In either case, `x`\n        or its elements must support addition and multiplication with\n        themselves and with the elements of `c`.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree n are contained in c[n]. If `c` is multidimensional the\n        remaining indices enumerate multiple polynomials. In the two\n        dimensional case the coefficients may be thought of as stored in\n        the columns of `c`.\n    tensor : boolean, optional\n        If True, the shape of the coefficient array is extended with ones\n        on the right, one for each dimension of `x`. Scalars have dimension 0\n        for this action. The result is that every column of coefficients in\n        `c` is evaluated for every element of `x`. If False, `x` is broadcast\n        over the columns of `c` for the evaluation.  This keyword is useful\n        when `c` is multidimensional. The default value is True.\n\n        .. versionadded:: 1.7.0\n\n    Returns\n    -------\n    values : ndarray, algebra_like\n        The shape of the return value is described above.\n\n    See Also\n    --------\n    legval2d, leggrid2d, legval3d, leggrid3d\n\n    Notes\n    -----\n    The evaluation uses Clenshaw recursion, aka synthetic division.\n\n    \"\"\"\n    c = np.array(c, ndmin=1, copy=None)\n    if c.dtype.char in '?bBhHiIlLqQpP':\n        c = c.astype(np.double)\n    if isinstance(x, (tuple, list)):\n        x = np.asarray(x)\n    if isinstance(x, np.ndarray) and tensor:\n        c = c.reshape(c.shape + (1,) * x.ndim)\n    if len(c) == 1:\n        c0 = c[0]\n        c1 = 0\n    elif len(c) == 2:\n        c0 = c[0]\n        c1 = c[1]\n    else:\n        nd = len(c)\n        c0 = c[-2]\n        c1 = c[-1]\n        for i in range(3, len(c) + 1):\n            tmp = c0\n            nd = nd - 1\n            c0 = c[-i] - c1 * (nd - 1) / nd\n            c1 = tmp + c1 * x * (2 * nd - 1) / nd\n    return c0 + c1 * x", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestVander():\n\tdef test_legvander(self):\n\t    x = np.arange(3)\n\t    v = leg.legvander(x, 3)\n\t    assert_(v.shape == (3, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], legval(x, coef))\n\t    x = np.array([[1, 2], [3, 4], [5, 6]])\n\t    v = leg.legvander(x, 3)\n\t    assert_(v.shape == (3, 2, 4))\n\t    for i in range(4):\n\t        coef = [0] * i + [1]\n\t        assert_almost_equal(v[..., i], legval(x, coef))\n\t\nTestVander().test_legvander()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestFitting():\n\tdef test_legfit(self):\n\t\n\t    def f(x):\n\t        return x * (x - 1) * (x - 2)\n\t\n\t    def f2(x):\n\t        return x ** 4 + x ** 2 + 1\n\t    assert_raises(ValueError, leg.legfit, [1], [1], -1)\n\t    assert_raises(TypeError, leg.legfit, [[1]], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [[[1]]], 0)\n\t    assert_raises(TypeError, leg.legfit, [1, 2], [1], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [1, 2], 0)\n\t    assert_raises(TypeError, leg.legfit, [1], [1], 0, w=[[1]])\n\t    assert_raises(TypeError, leg.legfit, [1], [1], 0, w=[1, 1])\n\t    assert_raises(ValueError, leg.legfit, [1], [1], [-1])\n\t    assert_raises(ValueError, leg.legfit, [1], [1], [2, -1, 6])\n\t    assert_raises(TypeError, leg.legfit, [1], [1], [])\n\t    x = np.linspace(0, 2)\n\t    y = f(x)\n\t    coef3 = leg.legfit(x, y, 3)\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(legval(x, coef3), y)\n\t    coef3 = leg.legfit(x, y, [0, 1, 2, 3])\n\t    assert_equal(len(coef3), 4)\n\t    assert_almost_equal(legval(x, coef3), y)\n\t    coef4 = leg.legfit(x, y, 4)\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef4 = leg.legfit(x, y, [0, 1, 2, 3, 4])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef4 = leg.legfit(x, y, [2, 3, 4, 1, 0])\n\t    assert_equal(len(coef4), 5)\n\t    assert_almost_equal(legval(x, coef4), y)\n\t    coef2d = leg.legfit(x, np.array([y, y]).T, 3)\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    coef2d = leg.legfit(x, np.array([y, y]).T, [0, 1, 2, 3])\n\t    assert_almost_equal(coef2d, np.array([coef3, coef3]).T)\n\t    w = np.zeros_like(x)\n\t    yw = y.copy()\n\t    w[1::2] = 1\n\t    y[0::2] = 0\n\t    wcoef3 = leg.legfit(x, yw, 3, w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef3 = leg.legfit(x, yw, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef3, coef3)\n\t    wcoef2d = leg.legfit(x, np.array([yw, yw]).T, 3, w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    wcoef2d = leg.legfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)\n\t    assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)\n\t    x = [1, 1.0j, -1, -1.0j]\n\t    assert_almost_equal(leg.legfit(x, x, 1), [0, 1])\n\t    assert_almost_equal(leg.legfit(x, x, [0, 1]), [0, 1])\n\t    x = np.linspace(-1, 1)\n\t    y = f2(x)\n\t    coef1 = leg.legfit(x, y, 4)\n\t    assert_almost_equal(legval(x, coef1), y)\n\t    coef2 = leg.legfit(x, y, [0, 2, 4])\n\t    assert_almost_equal(legval(x, coef2), y)\n\t    assert_almost_equal(coef1, coef2)\n\t\nTestFitting().test_legfit()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legval(x, c, tensor=True): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "legline", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef legline(off, scl):\n    \"\"\"\n    Legendre series whose graph is a straight line.\n\n\n\n    Parameters\n    ----------\n    off, scl : scalars\n        The specified line is given by ``off + scl*x``.\n\n    Returns\n    -------\n    y : ndarray\n        This module's representation of the Legendre series for\n        ``off + scl*x``.\n\n    See Also\n    --------\n    numpy.polynomial.polynomial.polyline\n    numpy.polynomial.chebyshev.chebline\n    numpy.polynomial.laguerre.lagline\n    numpy.polynomial.hermite.hermline\n    numpy.polynomial.hermite_e.hermeline\n\n    Examples\n    --------\n    >>> import numpy.polynomial.legendre as L\n    >>> L.legline(3,2)\n    array([3, 2])\n    >>> L.legval(-3, L.legline(3,2)) # should be -3\n    -3.0\n\n    \"\"\"\n    if scl != 0:\n        return np.array([off, scl])\n    else:\n        return np.array([off])", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_legline(self):\n\t    assert_equal(legline(3, 4), [3, 4])\n\t\nTestMisc().test_legline()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}, {"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_legline_zeroscl(self):\n\t    assert_equal(legline(3, 0), [3])\n\t\nTestMisc().test_legline_zeroscl()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legline(off, scl): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "legweight", "method_path": "../srcdata/Computation/numpy/numpy/polynomial/legendre.py", "response": "import numpy as np\nimport numpy.linalg as la\ndef legweight(x):\n    \"\"\"\n    Weight function of the Legendre polynomials.\n\n    The weight function is :math:`1` and the interval of integration is\n    :math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not\n    normalized, with respect to this weight function.\n\n    Parameters\n    ----------\n    x : array_like\n       Values at which the weight function will be computed.\n\n    Returns\n    -------\n    w : ndarray\n       The weight function at `x`.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.7.0\n\n    \"\"\"\n    w = x * 0.0 + 1.0\n    return w", "test_code_list": [{"test_code": "from functools import reduce\nimport numpy as np\nimport numpy.polynomial.legendre as leg\nfrom numpy.polynomial.polynomial import polyval\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_\n\nclass TestMisc():\n\tdef test_weight(self):\n\t    x = np.linspace(-1, 1, 11)\n\t    tgt = 1.0\n\t    res = legweight(x)\n\t    assert_almost_equal(res, tgt)\n\t\nTestMisc().test_weight()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/polynomial/tests/test_legendre.py"}], "method_code_mask": "import numpy as np\nimport numpy.linalg as la\n\n\ndef legweight(x): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "drop_metadata", "method_path": "../srcdata/Computation/numpy/numpy/lib/_utils_impl.py", "response": "import os\nimport sys\nimport textwrap\nimport types\nimport re\nimport warnings\nimport functools\nimport platform\nimport numpy as np\nfrom pprint import pprint\nfrom threadpoolctl import threadpool_info\nimport numpy\nimport pydoc\nimport inspect\nimport ast\ndef drop_metadata(dtype, /):\n    \"\"\"\n    Returns the dtype unchanged if it contained no metadata or a copy of the\n    dtype if it (or any of its structure dtypes) contained metadata.\n\n    This utility is used by `np.save` and `np.savez` to drop metadata before\n    saving.\n\n    .. note::\n\n        Due to its limitation this function may move to a more appropriate\n        home or change in the future and is considered semi-public API only.\n\n    .. warning::\n\n        This function does not preserve more strange things like record dtypes\n        and user dtypes may simply return the wrong thing.  If you need to be\n        sure about the latter, check the result with:\n        ``np.can_cast(new_dtype, dtype, casting=\"no\")``.\n\n    \"\"\"\n    if dtype.fields is not None:\n        found_metadata = dtype.metadata is not None\n        names = []\n        formats = []\n        offsets = []\n        titles = []\n        for name, field in dtype.fields.items():\n            field_dt = drop_metadata(field[0])\n            if field_dt is not field[0]:\n                found_metadata = True\n            names.append(name)\n            formats.append(field_dt)\n            offsets.append(field[1])\n            titles.append(None if len(field) < 3 else field[2])\n        if not found_metadata:\n            return dtype\n        structure = dict(names=names, formats=formats, offsets=offsets,\n            titles=titles, itemsize=dtype.itemsize)\n        return np.dtype(structure, align=dtype.isalignedstruct)\n    elif dtype.subdtype is not None:\n        subdtype, shape = dtype.subdtype\n        new_subdtype = drop_metadata(subdtype)\n        if dtype.metadata is None and new_subdtype is subdtype:\n            return dtype\n        return np.dtype((new_subdtype, shape))\n    else:\n        if dtype.metadata is None:\n            return dtype\n        return np.dtype(dtype.str)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_raises_regex\nfrom io import StringIO\ndef test_drop_metadata():\n\n    def _compare_dtypes(dt1, dt2):\n        return np.can_cast(dt1, dt2, casting='no')\n    dt = np.dtype([('l1', [('l2', np.dtype('S8', metadata={'msg': 'toto'}))\n        ])], metadata={'msg': 'titi'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    assert dt_m['l1'].metadata is None\n    assert dt_m['l1']['l2'].metadata is None\n    dt = np.dtype([('x', '<f8'), ('y', '<i4')], align=True, metadata={'msg':\n        'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    dt = np.dtype('8f', metadata={'msg': 'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n    dt = np.dtype('uint32', metadata={'msg': 'toto'})\n    dt_m = drop_metadata(dt)\n    assert _compare_dtypes(dt, dt_m) is True\n    assert dt_m.metadata is None\n\ntest_drop_metadata()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_utils.py"}], "method_code_mask": "import os\nimport sys\nimport textwrap\nimport types\nimport re\nimport warnings\nimport functools\nimport platform\nimport numpy as np\nfrom pprint import pprint\nfrom threadpoolctl import threadpool_info\nimport numpy\nimport pydoc\nimport inspect\nimport ast\n\n\ndef drop_metadata(dtype, /): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "get_mat", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py", "response": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\ndef get_mat(n):\n    data = np.arange(n)\n    data = np.add.outer(data, data)\n    return data", "test_code_list": [{"test_code": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\nclass TestFlip():\n\tdef test_basic_lr(self):\n\t    a = get_mat(4)\n\t    b = a[:, ::-1]\n\t    assert_equal(np.flip(a, 1), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[2, 1, 0], [5, 4, 3]]\n\t    assert_equal(np.flip(a, 1), b)\n\t\nTestFlip().test_basic_lr()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py"}, {"test_code": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\nclass TestFlip():\n\tdef test_basic_ud(self):\n\t    a = get_mat(4)\n\t    b = a[::-1, :]\n\t    assert_equal(np.flip(a, 0), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[3, 4, 5], [0, 1, 2]]\n\t    assert_equal(np.flip(a, 0), b)\n\t\nTestFlip().test_basic_ud()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_function_base.py"}], "method_code_mask": "import operator\nimport warnings\nimport sys\nimport decimal\nfrom fractions import Fraction\nimport math\nimport pytest\nfrom functools import partial\nimport numpy as np\nfrom numpy import ma\nfrom numpy import angle\nfrom numpy import average\nfrom numpy import bartlett\nfrom numpy import blackman\nfrom numpy import corrcoef\nfrom numpy import cov\nfrom numpy import delete\nfrom numpy import diff\nfrom numpy import digitize\nfrom numpy import extract\nfrom numpy import flipud\nfrom numpy import gradient\nfrom numpy import hamming\nfrom numpy import hanning\nfrom numpy import i0\nfrom numpy import insert\nfrom numpy import interp\nfrom numpy import kaiser\nfrom numpy import meshgrid\nfrom numpy import piecewise\nfrom numpy import place\nfrom numpy import rot90\nfrom numpy import select\nfrom numpy import setxor1d\nfrom numpy import sinc\nfrom numpy import trim_zeros\nfrom numpy import unwrap\nfrom numpy import unique\nfrom numpy import vectorize\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.random import rand\nimport random\nimport gc\n\n\ndef get_mat(n): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "easy_dtype", "method_path": "../srcdata/Computation/numpy/numpy/lib/_iotools.py", "response": "import numpy as np\ndef easy_dtype(ndtype, names=None, defaultfmt='f%i', **validationargs):\n    \"\"\"\n    Convenience function to create a `np.dtype` object.\n\n    The function processes the input `dtype` and matches it with the given\n    names.\n\n    Parameters\n    ----------\n    ndtype : var\n        Definition of the dtype. Can be any string or dictionary recognized\n        by the `np.dtype` function, or a sequence of types.\n    names : str or sequence, optional\n        Sequence of strings to use as field names for a structured dtype.\n        For convenience, `names` can be a string of a comma-separated list\n        of names.\n    defaultfmt : str, optional\n        Format string used to define missing names, such as ``\"f%i\"``\n        (default) or ``\"fields_%02i\"``.\n    validationargs : optional\n        A series of optional arguments used to initialize a\n        `NameValidator`.\n\n    Examples\n    --------\n    >>> np.lib._iotools.easy_dtype(float)\n    dtype('float64')\n    >>> np.lib._iotools.easy_dtype(\"i4, f8\")\n    dtype([('f0', '<i4'), ('f1', '<f8')])\n    >>> np.lib._iotools.easy_dtype(\"i4, f8\", defaultfmt=\"field_%03i\")\n    dtype([('field_000', '<i4'), ('field_001', '<f8')])\n\n    >>> np.lib._iotools.easy_dtype((int, float, float), names=\"a,b,c\")\n    dtype([('a', '<i8'), ('b', '<f8'), ('c', '<f8')])\n    >>> np.lib._iotools.easy_dtype(float, names=\"a,b,c\")\n    dtype([('a', '<f8'), ('b', '<f8'), ('c', '<f8')])\n\n    \"\"\"\n    try:\n        ndtype = np.dtype(ndtype)\n    except TypeError:\n        validate = NameValidator(**validationargs)\n        nbfields = len(ndtype)\n        if names is None:\n            names = [''] * len(ndtype)\n        elif isinstance(names, str):\n            names = names.split(',')\n        names = validate(names, nbfields=nbfields, defaultfmt=defaultfmt)\n        ndtype = np.dtype(dict(formats=ndtype, names=names))\n    else:\n        if names is not None:\n            validate = NameValidator(**validationargs)\n            if isinstance(names, str):\n                names = names.split(',')\n            if ndtype.names is None:\n                formats = tuple([ndtype.type] * len(names))\n                names = validate(names, defaultfmt=defaultfmt)\n                ndtype = np.dtype(list(zip(names, formats)))\n            else:\n                ndtype.names = validate(names, nbfields=len(ndtype.names),\n                    defaultfmt=defaultfmt)\n        elif ndtype.names is not None:\n            validate = NameValidator(**validationargs)\n            numbered_names = tuple('f%i' % i for i in range(len(ndtype.names)))\n            if ndtype.names == numbered_names and defaultfmt != 'f%i':\n                ndtype.names = validate([''] * len(ndtype.names),\n                    defaultfmt=defaultfmt)\n            else:\n                ndtype.names = validate(ndtype.names, defaultfmt=defaultfmt)\n    return ndtype", "test_code_list": [{"test_code": "import time\nfrom datetime import date\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_raises\nfrom numpy.lib._iotools import LineSplitter\nfrom numpy.lib._iotools import NameValidator\nfrom numpy.lib._iotools import StringConverter\nfrom numpy.lib._iotools import has_nested_fields\nfrom numpy.lib._iotools import easy_dtype\nfrom numpy.lib._iotools import flatten_dtype\n\nclass TestMiscFunctions():\n\tdef test_easy_dtype(self):\n\t    \"\"\"Test ndtype on dtypes\"\"\"\n\t    ndtype = float\n\t    assert_equal(easy_dtype(ndtype), np.dtype(float))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('f0', 'i4'), ('f1', 'f8')]))\n\t    assert_equal(easy_dtype(ndtype, defaultfmt='field_%03i'), np.dtype([(\n\t        'field_000', 'i4'), ('field_001', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names='a, b'), np.dtype([('a', 'i4'), (\n\t        'b', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([('a', 'i4'),\n\t        ('b', 'f8')]))\n\t    ndtype = 'i4, f8'\n\t    assert_equal(easy_dtype(ndtype, names=', b'), np.dtype([('f0', 'i4'), (\n\t        'b', 'f8')]))\n\t    assert_equal(easy_dtype(ndtype, names='a', defaultfmt='f%02i'), np.\n\t        dtype([('a', 'i4'), ('f00', 'f8')]))\n\t    ndtype = [('A', int), ('B', float)]\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('A', int), ('B', float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a,b'), np.dtype([('a', int), (\n\t        'b', float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a'), np.dtype([('a', int), ('f0',\n\t        float)]))\n\t    assert_equal(easy_dtype(ndtype, names='a,b,c'), np.dtype([('a', int), (\n\t        'b', float)]))\n\t    ndtype = int, float, float\n\t    assert_equal(easy_dtype(ndtype), np.dtype([('f0', int), ('f1', float),\n\t        ('f2', float)]))\n\t    ndtype = int, float, float\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([('a', int),\n\t        ('b', float), ('c', float)]))\n\t    ndtype = np.dtype(float)\n\t    assert_equal(easy_dtype(ndtype, names='a, b, c'), np.dtype([(_, float) for\n\t        _ in ('a', 'b', 'c')]))\n\t    ndtype = np.dtype(float)\n\t    assert_equal(easy_dtype(ndtype, names=['', '', ''], defaultfmt='f%02i'),\n\t        np.dtype([(_, float) for _ in ('f00', 'f01', 'f02')]))\n\t\nTestMiscFunctions().test_easy_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test__iotools.py"}], "method_code_mask": "import numpy as np\n\n\ndef easy_dtype(ndtype, names=None, defaultfmt='f%i', **validationargs): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "flatten_dtype", "method_path": "../srcdata/Computation/numpy/numpy/lib/_iotools.py", "response": "import numpy as np\ndef flatten_dtype(ndtype, flatten_base=False):\n    \"\"\"\n    Unpack a structured data-type by collapsing nested fields and/or fields\n    with a shape.\n\n    Note that the field names are lost.\n\n    Parameters\n    ----------\n    ndtype : dtype\n        The datatype to collapse\n    flatten_base : bool, optional\n       If True, transform a field with a shape into several fields. Default is\n       False.\n\n    Examples\n    --------\n    >>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),\n    ...                ('block', int, (2, 3))])\n    >>> np.lib._iotools.flatten_dtype(dt)\n    [dtype('S4'), dtype('float64'), dtype('float64'), dtype('int64')]\n    >>> np.lib._iotools.flatten_dtype(dt, flatten_base=True)\n    [dtype('S4'),\n     dtype('float64'),\n     dtype('float64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64'),\n     dtype('int64')]\n\n    \"\"\"\n    names = ndtype.names\n    if names is None:\n        if flatten_base:\n            return [ndtype.base] * int(np.prod(ndtype.shape))\n        return [ndtype.base]\n    else:\n        types = []\n        for field in names:\n            info = ndtype.fields[field]\n            flat_dt = flatten_dtype(info[0], flatten_base)\n            types.extend(flat_dt)\n        return types", "test_code_list": [{"test_code": "import time\nfrom datetime import date\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_raises\nfrom numpy.lib._iotools import LineSplitter\nfrom numpy.lib._iotools import NameValidator\nfrom numpy.lib._iotools import StringConverter\nfrom numpy.lib._iotools import has_nested_fields\nfrom numpy.lib._iotools import easy_dtype\nfrom numpy.lib._iotools import flatten_dtype\n\nclass TestMiscFunctions():\n\tdef test_flatten_dtype(self):\n\t    \"\"\"Testing flatten_dtype\"\"\"\n\t    dt = np.dtype([('a', 'f8'), ('b', 'f8')])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, float])\n\t    dt = np.dtype([('a', [('aa', '|S1'), ('ab', '|S2')]), ('b', int)])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [np.dtype('|S1'), np.dtype('|S2'), int])\n\t    dt = np.dtype([('a', (float, 2)), ('b', (int, 3))])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, int])\n\t    dt_flat = flatten_dtype(dt, True)\n\t    assert_equal(dt_flat, [float] * 2 + [int] * 3)\n\t    dt = np.dtype([(('a', 'A'), 'f8'), (('b', 'B'), 'f8')])\n\t    dt_flat = flatten_dtype(dt)\n\t    assert_equal(dt_flat, [float, float])\n\t\nTestMiscFunctions().test_flatten_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test__iotools.py"}], "method_code_mask": "import numpy as np\n\n\ndef flatten_dtype(ndtype, flatten_base=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "get_mat", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py", "response": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\ndef get_mat(n):\n    data = arange(n)\n    data = add.outer(data, data)\n    return data", "test_code_list": [{"test_code": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\nclass TestFliplr():\n\tdef test_basic(self):\n\t    assert_raises(ValueError, fliplr, ones(4))\n\t    a = get_mat(4)\n\t    b = a[:, ::-1]\n\t    assert_equal(fliplr(a), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[2, 1, 0], [5, 4, 3]]\n\t    assert_equal(fliplr(a), b)\n\t\nTestFliplr().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py"}, {"test_code": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\nclass TestFlipud():\n\tdef test_basic(self):\n\t    a = get_mat(4)\n\t    b = a[::-1, :]\n\t    assert_equal(flipud(a), b)\n\t    a = [[0, 1, 2], [3, 4, 5]]\n\t    b = [[3, 4, 5], [0, 1, 2]]\n\t    assert_equal(flipud(a), b)\n\t\nTestFlipud().test_basic()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_twodim_base.py"}], "method_code_mask": "from numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_max_ulp\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_\nfrom numpy import arange\nfrom numpy import add\nfrom numpy import fliplr\nfrom numpy import flipud\nfrom numpy import zeros\nfrom numpy import ones\nfrom numpy import eye\nfrom numpy import array\nfrom numpy import diag\nfrom numpy import histogram2d\nfrom numpy import tri\nfrom numpy import mask_indices\nfrom numpy import triu_indices\nfrom numpy import triu_indices_from\nfrom numpy import tril_indices\nfrom numpy import tril_indices_from\nfrom numpy import vander\nimport numpy as np\nimport pytest\n\n\ndef get_mat(n): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_add_keepdims", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py", "response": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\ndef _add_keepdims(func):\n    \"\"\" hack in keepdims behavior into a function taking an axis \"\"\"\n\n    @functools.wraps(func)\n    def wrapped(a, axis, **kwargs):\n        res = func(a, axis=axis, **kwargs)\n        if axis is None:\n            axis = 0\n        return np.expand_dims(res, axis=axis)\n    return wrapped", "test_code_list": [{"test_code": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\nclass TestTakeAlongAxis():\n\tdef test_argequivalent(self):\n\t    \"\"\" Test it translates from arg<func> to <func> \"\"\"\n\t    from numpy.random import rand\n\t    a = rand(3, 4, 5)\n\t    funcs = [(np.sort, np.argsort, dict()), (_add_keepdims(np.min),\n\t        _add_keepdims(np.argmin), dict()), (_add_keepdims(np.max),\n\t        _add_keepdims(np.argmax), dict())]\n\t    for func, argfunc, kwargs in funcs:\n\t        for axis in (list(range(a.ndim)) + [None]):\n\t            a_func = func(a, axis=axis, **kwargs)\n\t            ai_func = argfunc(a, axis=axis, **kwargs)\n\t            assert_equal(a_func, take_along_axis(a, ai_func, axis=axis))\n\t\nTestTakeAlongAxis().test_argequivalent()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py"}, {"test_code": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\nclass TestPutAlongAxis():\n\tdef test_replace_max(self):\n\t    a_base = np.array([[10, 30, 20], [60, 40, 50]])\n\t    for axis in (list(range(a_base.ndim)) + [None]):\n\t        a = a_base.copy()\n\t        i_max = _add_keepdims(np.argmax)(a, axis=axis)\n\t        put_along_axis(a, i_max, -99, axis=axis)\n\t        i_min = _add_keepdims(np.argmin)(a, axis=axis)\n\t        assert_equal(i_min, i_max)\n\t\nTestPutAlongAxis().test_replace_max()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_shape_base.py"}], "method_code_mask": "import numpy as np\nimport functools\nimport sys\nimport pytest\nfrom numpy import apply_along_axis\nfrom numpy import apply_over_axes\nfrom numpy import array_split\nfrom numpy import split\nfrom numpy import hsplit\nfrom numpy import dsplit\nfrom numpy import vsplit\nfrom numpy import dstack\nfrom numpy import column_stack\nfrom numpy import kron\nfrom numpy import tile\nfrom numpy import expand_dims\nfrom numpy import take_along_axis\nfrom numpy import put_along_axis\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.random import rand\nfrom numpy.random import randint\n\n\ndef _add_keepdims(func): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "roundtrip", "method_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_format.py", "response": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\ndef roundtrip(arr):\n    f = BytesIO()\n    format.write_array(f, arr)\n    f2 = BytesIO(f.getvalue())\n    arr2 = format.read_array(f2, allow_pickle=True)\n    return arr2", "test_code_list": [{"test_code": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\ndef test_long_str():\n    long_str_arr = np.ones(1, dtype=np.dtype((str, format.BUFFER_SIZE + 1)))\n    long_str_arr2 = roundtrip(long_str_arr)\n    assert_array_equal(long_str_arr, long_str_arr2)\n\ntest_long_str()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_format.py"}], "method_code_mask": "import sys\nimport os\nimport warnings\nimport pytest\nfrom io import BytesIO\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.lib import format\nimport random\nimport subprocess as sp\n\n\ndef roundtrip(arr): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_replace_nan", "method_path": "../srcdata/Computation/numpy/numpy/lib/_nanfunctions_impl.py", "response": "import functools\nimport warnings\nimport numpy as np\ndef _replace_nan(a, val):\n    \"\"\"\n    If `a` is of inexact type, make a copy of `a`, replace NaNs with\n    the `val` value, and return the copy together with a boolean mask\n    marking the locations where NaNs were present. If `a` is not of\n    inexact type, do nothing and return `a` together with a mask of None.\n\n    Note that scalars will end up as array scalars, which is important\n    for using the result as the value of the out argument in some\n    operations.\n\n    Parameters\n    ----------\n    a : array-like\n        Input array.\n    val : float\n        NaN values are set to val before doing the operation.\n\n    Returns\n    -------\n    y : ndarray\n        If `a` is of inexact type, return a copy of `a` with the NaNs\n        replaced by the fill value, otherwise return `a`.\n    mask: {bool, None}\n        If `a` is of inexact type, return a boolean mask marking locations of\n        NaNs, otherwise return None.\n\n    \"\"\"\n    a = np.asanyarray(a)\n    if a.dtype == np.object_:\n        mask = np.not_equal(a, a, dtype=bool)\n    elif issubclass(a.dtype.type, np.inexact):\n        mask = np.isnan(a)\n    else:\n        mask = None\n    if mask is not None:\n        a = np.array(a, subok=True, copy=True)\n        np.copyto(a, val, where=mask)\n    return a, mask", "test_code_list": [{"test_code": "import warnings\nimport pytest\nimport inspect\nfrom functools import partial\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import suppress_warnings\ndef test__replace_nan():\n    \"\"\" Test that _replace_nan returns the original array if there are no\n    NaNs, not a copy.\n    \"\"\"\n    for dtype in [np.bool, np.int32, np.int64]:\n        arr = np.array([0, 1], dtype=dtype)\n        result, mask = _replace_nan(arr, 0)\n        assert mask is None\n        assert result is arr\n    for dtype in [np.float32, np.float64]:\n        arr = np.array([0, 1], dtype=dtype)\n        result, mask = _replace_nan(arr, 2)\n        assert (mask == False).all()\n        assert result is not arr\n        assert_equal(result, arr)\n        arr_nan = np.array([0, 1, np.nan], dtype=dtype)\n        result_nan, mask_nan = _replace_nan(arr_nan, 2)\n        assert_equal(mask_nan, np.array([False, False, True]))\n        assert result_nan is not arr_nan\n        assert_equal(result_nan, np.array([0, 1, 2]))\n        assert np.isnan(arr_nan[-1])\n\ntest__replace_nan()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_nanfunctions.py"}], "method_code_mask": "import functools\nimport warnings\nimport numpy as np\n\n\ndef _replace_nan(a, val): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_as_pairs", "method_path": "../srcdata/Computation/numpy/numpy/lib/_arraypad_impl.py", "response": "import numpy as np\ndef _as_pairs(x, ndim, as_index=False):\n    \"\"\"\n    Broadcast `x` to an array with the shape (`ndim`, 2).\n\n    A helper function for `pad` that prepares and validates arguments like\n    `pad_width` for iteration in pairs.\n\n    Parameters\n    ----------\n    x : {None, scalar, array-like}\n        The object to broadcast to the shape (`ndim`, 2).\n    ndim : int\n        Number of pairs the broadcasted `x` will have.\n    as_index : bool, optional\n        If `x` is not None, try to round each element of `x` to an integer\n        (dtype `np.intp`) and ensure every element is positive.\n\n    Returns\n    -------\n    pairs : nested iterables, shape (`ndim`, 2)\n        The broadcasted version of `x`.\n\n    Raises\n    ------\n    ValueError\n        If `as_index` is True and `x` contains negative elements.\n        Or if `x` is not broadcastable to the shape (`ndim`, 2).\n    \"\"\"\n    if x is None:\n        return ((None, None),) * ndim\n    x = np.array(x)\n    if as_index:\n        x = np.round(x).astype(np.intp, copy=False)\n    if x.ndim < 3:\n        if x.size == 1:\n            x = x.ravel()\n            if as_index and x < 0:\n                raise ValueError(\"index can't contain negative values\")\n            return ((x[0], x[0]),) * ndim\n        if x.size == 2 and x.shape != (2, 1):\n            x = x.ravel()\n            if as_index and (x[0] < 0 or x[1] < 0):\n                raise ValueError(\"index can't contain negative values\")\n            return ((x[0], x[1]),) * ndim\n    if as_index and x.min() < 0:\n        raise ValueError(\"index can't contain negative values\")\n    return np.broadcast_to(x, (ndim, 2)).tolist()", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_single_value(self):\n\t    \"\"\"Test casting for a single value.\"\"\"\n\t    expected = np.array([[3, 3]] * 10)\n\t    for x in (3, [3], [[3]]):\n\t        result = _as_pairs(x, 10)\n\t        assert_equal(result, expected)\n\t    obj = object()\n\t    assert_equal(_as_pairs(obj, 10), np.array([[obj, obj]] * 10))\n\t\nTestAsPairs().test_single_value()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_two_values(self):\n\t    \"\"\"Test proper casting for two different values.\"\"\"\n\t    expected = np.array([[3, 4]] * 10)\n\t    for x in ([3, 4], [[3, 4]]):\n\t        result = _as_pairs(x, 10)\n\t        assert_equal(result, expected)\n\t    obj = object()\n\t    assert_equal(_as_pairs(['a', obj], 10), np.array([['a', obj]] * 10))\n\t    assert_equal(_as_pairs([[3], [4]], 2), np.array([[3, 3], [4, 4]]))\n\t    assert_equal(_as_pairs([['a'], [obj]], 2), np.array([['a', 'a'], [obj,\n\t        obj]]))\n\t\nTestAsPairs().test_two_values()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_with_none(self):\n\t    expected = (None, None), (None, None), (None, None)\n\t    assert_equal(_as_pairs(None, 3, as_index=False), expected)\n\t    assert_equal(_as_pairs(None, 3, as_index=True), expected)\n\t\nTestAsPairs().test_with_none()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_pass_through(self):\n\t    \"\"\"Test if `x` already matching desired output are passed through.\"\"\"\n\t    expected = np.arange(12).reshape((6, 2))\n\t    assert_equal(_as_pairs(expected, 6), expected)\n\t\nTestAsPairs().test_pass_through()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_equal\nfrom fractions import Fraction\n\nclass TestAsPairs():\n\tdef test_as_index(self):\n\t    \"\"\"Test results if `as_index=True`.\"\"\"\n\t    assert_equal(_as_pairs([2.6, 3.3], 10, as_index=True), np.array([[3, 3]\n\t        ] * 10, dtype=np.intp))\n\t    assert_equal(_as_pairs([2.6, 4.49], 10, as_index=True), np.array([[3, 4\n\t        ]] * 10, dtype=np.intp))\n\t    for x in (-3, [-3], [[-3]], [-3, 4], [3, -4], [[-3, 4]], [[4, -3]], [[1,\n\t        2]] * 9 + [[1, -2]]):\n\t        with pytest.raises(ValueError, match='negative values'):\n\t            _as_pairs(x, 10, as_index=True)\n\t\nTestAsPairs().test_as_index()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_arraypad.py"}], "method_code_mask": "import numpy as np\n\n\ndef _as_pairs(x, ndim, as_index=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "get_fieldstructure", "method_path": "../srcdata/Computation/numpy/numpy/lib/recfunctions.py", "response": "import itertools\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy import ndarray\nfrom numpy.ma import MaskedArray\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.lib._iotools import _is_string_like\ndef get_fieldstructure(adtype, lastname=None, parents=None):\n    \"\"\"\n    Returns a dictionary with fields indexing lists of their parent fields.\n\n    This function is used to simplify access to fields nested in other fields.\n\n    Parameters\n    ----------\n    adtype : np.dtype\n        Input datatype\n    lastname : optional\n        Last processed field name (used internally during recursion).\n    parents : dictionary\n        Dictionary of parent fields (used interbally during recursion).\n\n    Examples\n    --------\n    >>> from numpy.lib import recfunctions as rfn\n    >>> ndtype =  np.dtype([('A', int),\n    ...                     ('B', [('BA', int),\n    ...                            ('BB', [('BBA', int), ('BBB', int)])])])\n    >>> rfn.get_fieldstructure(ndtype)\n    ... # XXX: possible regression, order of BBA and BBB is swapped\n    {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}\n\n    \"\"\"\n    if parents is None:\n        parents = {}\n    names = adtype.names\n    for name in names:\n        current = adtype[name]\n        if current.names is not None:\n            if lastname:\n                parents[name] = [lastname]\n            else:\n                parents[name] = []\n            parents.update(get_fieldstructure(current, name, parents))\n        else:\n            lastparent = [_ for _ in parents.get(lastname, []) or []]\n            if lastparent:\n                lastparent.append(lastname)\n            elif lastname:\n                lastparent = [lastname]\n            parents[name] = lastparent or []\n    return parents", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.lib.recfunctions import drop_fields\nfrom numpy.lib.recfunctions import rename_fields\nfrom numpy.lib.recfunctions import get_fieldstructure\nfrom numpy.lib.recfunctions import recursive_fill_fields\nfrom numpy.lib.recfunctions import find_duplicates\nfrom numpy.lib.recfunctions import merge_arrays\nfrom numpy.lib.recfunctions import append_fields\nfrom numpy.lib.recfunctions import stack_arrays\nfrom numpy.lib.recfunctions import join_by\nfrom numpy.lib.recfunctions import repack_fields\nfrom numpy.lib.recfunctions import unstructured_to_structured\nfrom numpy.lib.recfunctions import structured_to_unstructured\nfrom numpy.lib.recfunctions import apply_along_fields\nfrom numpy.lib.recfunctions import require_fields\nfrom numpy.lib.recfunctions import assign_fields_by_name\nfrom datetime import date\n\nclass TestRecFunctions():\n\tdef test_get_fieldstructure(self):\n\t    ndtype = np.dtype([('A', '|S3'), ('B', float)])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {'A': [], 'B': []})\n\t    ndtype = np.dtype([('A', int), ('B', [('BA', float), ('BB', '|S1')])])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B']})\n\t    ndtype = np.dtype([('A', int), ('B', [('BA', int), ('BB', [('BBA', int),\n\t        ('BBB', int)])])])\n\t    test = get_fieldstructure(ndtype)\n\t    control = {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B',\n\t        'BB'], 'BBB': ['B', 'BB']}\n\t    assert_equal(test, control)\n\t    ndtype = np.dtype([])\n\t    test = get_fieldstructure(ndtype)\n\t    assert_equal(test, {})\n\t\nTestRecFunctions().test_get_fieldstructure()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_recfunctions.py"}], "method_code_mask": "import itertools\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy import ndarray\nfrom numpy.ma import MaskedArray\nfrom numpy.ma.mrecords import MaskedRecords\nfrom numpy.lib._iotools import _is_string_like\n\n\ndef get_fieldstructure(adtype, lastname=None, parents=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "break_cycles", "method_path": "../srcdata/Computation/numpy/numpy/testing/_private/utils.py", "response": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\ndef break_cycles():\n    \"\"\"\n    Break reference cycles by calling gc.collect\n    Objects can call other objects' methods (for instance, another object's\n     __del__) inside their own __del__. On PyPy, the interpreter only runs\n    between calls to gc.collect, so multiple calls are needed to completely\n    release all cycles.\n    \"\"\"\n    gc.collect()\n    if IS_PYPY:\n        gc.collect()\n        gc.collect()\n        gc.collect()\n        gc.collect()", "test_code_list": [{"test_code": "import sys\nimport gc\nimport gzip\nimport os\nimport threading\nimport time\nimport warnings\nimport re\nimport pytest\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\nfrom io import BytesIO\nfrom io import StringIO\nfrom datetime import datetime\nimport locale\nfrom multiprocessing import Value\nfrom multiprocessing import get_context\nfrom ctypes import c_bool\nimport numpy as np\nimport numpy.ma as ma\nfrom numpy.lib._iotools import ConverterError\nfrom numpy.lib._iotools import ConversionWarning\nfrom numpy.ma.testutils import assert_equal\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import temppath\nfrom numpy.testing import tempdir\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import assert_no_gc_cycles\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing._private.utils import requires_memory\nimport bz2\nimport lzma\n\nclass TestPathUsage():\n\tdef test_save_load_memmap(self):\n\t    with temppath(suffix='.npy') as path:\n\t        path = Path(path)\n\t        a = np.array([[1, 2], [3, 4]], int)\n\t        np.save(path, a)\n\t        data = np.load(path, mmap_mode='r')\n\t        assert_array_equal(data, a)\n\t        del data\n\t        if IS_PYPY:\n\t            break_cycles()\n\t            break_cycles()\n\t\nTestPathUsage().test_save_load_memmap()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/lib/tests/test_io.py"}, {"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestCTypes():\n\tdef test_ctypes_as_parameter_holds_reference(self):\n\t    arr = np.array([None]).copy()\n\t    arr_ref = weakref.ref(arr)\n\t    ctypes_ptr = arr.ctypes._as_parameter_\n\t    del arr\n\t    break_cycles()\n\t    assert_(arr_ref() is not None,\n\t        'ctypes pointer did not hold onto a reference')\n\t    del ctypes_ptr\n\t    if IS_PYPY:\n\t        break_cycles()\n\t    assert_(arr_ref() is None,\n\t        'unknowable whether ctypes pointer holds a reference')\n\t\nTestCTypes().test_ctypes_as_parameter_holds_reference()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}, {"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestArrayFinalize():\n\tdef test_lifetime_on_error(self):\n\t\n\t\n\t    class RaisesInFinalize(np.ndarray):\n\t\n\t        def __array_finalize__(self, obj):\n\t            raise Exception(self)\n\t\n\t\n\t    class Dummy:\n\t        pass\n\t    obj_arr = np.array(Dummy())\n\t    obj_ref = weakref.ref(obj_arr[()])\n\t    with assert_raises(Exception) as e:\n\t        obj_arr.view(RaisesInFinalize)\n\t    obj_subarray = e.exception.args[0]\n\t    del e\n\t    assert_(isinstance(obj_subarray, RaisesInFinalize))\n\t    break_cycles()\n\t    assert_(obj_ref() is not None, 'object should not already be dead')\n\t    del obj_arr\n\t    break_cycles()\n\t    assert_(obj_ref() is not None, 'obj_arr should not hold the last reference'\n\t        )\n\t    del obj_subarray\n\t    break_cycles()\n\t    assert_(obj_ref() is None, 'no references should remain')\n\t\nTestArrayFinalize().test_lifetime_on_error()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}], "method_code_mask": "import os\nimport sys\nimport platform\nimport re\nimport gc\nimport operator\nimport warnings\nfrom functools import partial\nfrom functools import wraps\nimport shutil\nimport contextlib\nfrom tempfile import mkdtemp\nfrom tempfile import mkstemp\nfrom unittest.case import SkipTest\nfrom warnings import WarningMessage\nimport pprint\nimport sysconfig\nimport numpy as np\nfrom numpy import isfinite\nfrom numpy import isnan\nfrom numpy import isinf\nimport numpy.linalg._umath_linalg\nfrom io import StringIO\nimport time\nfrom numpy import iscomplexobj\nfrom numpy import real\nfrom numpy import imag\nimport traceback\nimport difflib\nimport doctest\nimport subprocess\nimport unittest\nfrom inspect import isfunction\nimport pytest\nimport psutil\n\n\ndef break_cycles(): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_new_duck_type_and_implements", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_overrides.py", "response": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\ndef _new_duck_type_and_implements():\n    \"\"\"Create a duck array type and implements functions.\"\"\"\n    HANDLED_FUNCTIONS = {}\n\n\n    class MyArray:\n\n        def __array_function__(self, func, types, args, kwargs):\n            if func not in HANDLED_FUNCTIONS:\n                return NotImplemented\n            if not all(issubclass(t, MyArray) for t in types):\n                return NotImplemented\n            return HANDLED_FUNCTIONS[func](*args, **kwargs)\n\n    def implements(numpy_function):\n        \"\"\"Register an __array_function__ implementations.\"\"\"\n\n        def decorator(func):\n            HANDLED_FUNCTIONS[numpy_function] = func\n            return func\n        return decorator\n    return MyArray, implements", "test_code_list": [{"test_code": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\n\nclass TestNumPyFunctions():\n\tdef test_override_sum(self):\n\t    MyArray, implements = _new_duck_type_and_implements()\n\t\n\t    @implements(np.sum)\n\t    def _(array):\n\t        return 'yes'\n\t    assert_equal(np.sum(MyArray()), 'yes')\n\t\nTestNumPyFunctions().test_override_sum()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_overrides.py"}], "method_code_mask": "import inspect\nimport sys\nimport os\nimport tempfile\nfrom io import StringIO\nfrom unittest import mock\nimport pickle\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_raises_regex\n\n\ndef _new_duck_type_and_implements(): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_block_dispatcher", "method_path": "../srcdata/Computation/numpy/numpy/_core/shape_base.py", "response": "import functools\nimport itertools\nimport operator\nimport warnings\ndef _block_dispatcher(arrays):\n    if type(arrays) is list:\n        for subarrays in arrays:\n            yield from _block_dispatcher(subarrays)\n    else:\n        yield arrays", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_warns\nfrom numpy.testing import IS_PYPY\nimport operator\ndef test_block_dispatcher():\n\n\n    class ArrayLike:\n        pass\n    a = ArrayLike()\n    b = ArrayLike()\n    c = ArrayLike()\n    assert_equal(list(_block_dispatcher(a)), [a])\n    assert_equal(list(_block_dispatcher([a])), [a])\n    assert_equal(list(_block_dispatcher([a, b])), [a, b])\n    assert_equal(list(_block_dispatcher([[a], [b, [c]]])), [a, b, c])\n    assert_equal(list(_block_dispatcher((a, b))), [(a, b)])\n\ntest_block_dispatcher()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_shape_base.py"}], "method_code_mask": "import functools\nimport itertools\nimport operator\nimport warnings\n\n\ndef _block_dispatcher(arrays): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "_aligned_zeros", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py", "response": "from __future__ import annotations\nimport collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\ndef _aligned_zeros(shape, dtype=float, order='C', align=None):\n    \"\"\"\n    Allocate a new ndarray with aligned memory.\n\n    The ndarray is guaranteed *not* aligned to twice the requested alignment.\n    Eg, if align=4, guarantees it is not aligned to 8. If align=None uses\n    dtype.alignment.\"\"\"\n    dtype = np.dtype(dtype)\n    if dtype == np.dtype(object):\n        if align is not None:\n            raise ValueError('object array alignment not supported')\n        return np.zeros(shape, dtype=dtype, order=order)\n    if align is None:\n        align = dtype.alignment\n    if not hasattr(shape, '__len__'):\n        shape = shape,\n    size = functools.reduce(operator.mul, shape) * dtype.itemsize\n    buf = np.empty(size + 2 * align + 1, np.uint8)\n    ptr = buf.__array_interface__['data'][0]\n    offset = ptr % align\n    if offset != 0:\n        offset = align - offset\n    if ptr % (2 * align) == 0:\n        offset += align\n    buf = buf[offset:offset + size + 1][:-1]\n    buf.fill(0)\n    data = np.ndarray(shape, dtype, buf, order=order)\n    return data", "test_code_list": [{"test_code": "import collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\nclass TestMethods():\n\tdef test_dot_out_mem_overlap(self):\n\t    np.random.seed(1)\n\t    dtypes = [np.dtype(code) for code in np.typecodes['All'] if code not in\n\t        'USVM']\n\t    for dtype in dtypes:\n\t        a = np.random.rand(3, 3).astype(dtype)\n\t        b = _aligned_zeros((3, 3), dtype=dtype)\n\t        b[...] = np.random.rand(3, 3)\n\t        y = np.dot(a, b)\n\t        x = np.dot(a, b, out=b)\n\t        assert_equal(x, y, err_msg=repr(dtype))\n\t        assert_raises(ValueError, np.dot, a, b, out=b[::2])\n\t        assert_raises(ValueError, np.dot, a, b, out=b.T)\n\t\nTestMethods().test_dot_out_mem_overlap()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_multiarray.py"}], "method_code_mask": "from __future__ import annotations\nimport collections.abc\nimport tempfile\nimport sys\nimport warnings\nimport operator\nimport io\nimport itertools\nimport functools\nimport ctypes\nimport os\nimport gc\nimport re\nimport weakref\nimport pytest\nfrom contextlib import contextmanager\nimport pickle\nimport pathlib\nimport builtins\nfrom decimal import Decimal\nimport mmap\nimport numpy as np\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises_regex\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import IS_PYPY\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import runstring\nfrom numpy.testing import temppath\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\nfrom numpy.testing import assert_array_compare\nfrom numpy.testing._private.utils import requires_memory\nfrom numpy.testing._private.utils import _no_tracing\nfrom numpy.lib.recfunctions import repack_fields\nfrom datetime import timedelta\nfrom datetime import datetime\nimport fractions\nfrom fractions import Fraction as F\nimport _testbuffer\n\n\ndef _aligned_zeros(shape, dtype=float, order='C', align=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "iter_multi_index", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "response": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_multi_index(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.multi_index)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_1d():\n    a = arange(4)\n    i = nditer(a, ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0,), (1,), (2,), (3,)])\n    i = nditer(a[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(3,), (2,), (1,), (0,)])\n\ntest_iter_best_order_multi_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0), (0, 1), (0, 2), (1, 0), (1, \n        1), (1, 2)])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['multi_index'], [['readonly']]\n        )\n    assert_equal(iter_multi_index(i), [(0, 0), (1, 0), (0, 1), (1, 1), (0, \n        2), (1, 2)])\n    i = nditer(a.reshape(2, 3)[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0), (1, 1), (1, 2), (0, 0), (0, \n        1), (0, 2)])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2), (0, 1), (0, 0), (1, 2), (1, \n        1), (1, 0)])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 2), (1, 1), (1, 0), (0, 2), (0, \n        1), (0, 0)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['multi_index'], [[\n        'readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0), (0, 0), (1, 1), (0, 1), (1, \n        2), (0, 2)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['multi_index'], [\n        ['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2), (1, 2), (0, 1), (1, 1), (0, \n        0), (1, 0)])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['multi_index'],\n        [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 2), (0, 2), (1, 1), (0, 1), (1, \n        0), (0, 0)])\n\ntest_iter_best_order_multi_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_multi_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0,\n        1, 1), (0, 2, 0), (0, 2, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1,\n        1), (1, 2, 0), (1, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['multi_index'], [[\n        'readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1,\n        1, 0), (0, 2, 0), (1, 2, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1,\n        1), (0, 2, 1), (1, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0, 0), (1, 0, 1), (1, 1, 0), (1,\n        1, 1), (1, 2, 0), (1, 2, 1), (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1,\n        1), (0, 2, 0), (0, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2, 0), (0, 2, 1), (0, 1, 0), (0,\n        1, 1), (0, 0, 0), (0, 0, 1), (1, 2, 0), (1, 2, 1), (1, 1, 0), (1, 1,\n        1), (1, 0, 0), (1, 0, 1)])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 1), (0, 0, 0), (0, 1, 1), (0,\n        1, 0), (0, 2, 1), (0, 2, 0), (1, 0, 1), (1, 0, 0), (1, 1, 1), (1, 1,\n        0), (1, 2, 1), (1, 2, 0)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['multi_index'], [\n        ['readonly']])\n    assert_equal(iter_multi_index(i), [(1, 0, 0), (0, 0, 0), (1, 1, 0), (0,\n        1, 0), (1, 2, 0), (0, 2, 0), (1, 0, 1), (0, 0, 1), (1, 1, 1), (0, 1,\n        1), (1, 2, 1), (0, 2, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['multi_index'],\n        [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 2, 0), (1, 2, 0), (0, 1, 0), (1,\n        1, 0), (0, 0, 0), (1, 0, 0), (0, 2, 1), (1, 2, 1), (0, 1, 1), (1, 1,\n        1), (0, 0, 1), (1, 0, 1)])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], [\n        'multi_index'], [['readonly']])\n    assert_equal(iter_multi_index(i), [(0, 0, 1), (1, 0, 1), (0, 1, 1), (1,\n        1, 1), (0, 2, 1), (1, 2, 1), (0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1,\n        0), (0, 2, 0), (1, 2, 0)])\n\ntest_iter_best_order_multi_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_multi_index(i): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "iter_indices", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "response": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_indices(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.index)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_1d():\n    a = arange(4)\n    i = nditer(a, ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3])\n    i = nditer(a[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 2, 1, 0])\n\ntest_iter_best_order_c_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 3, 1, 4, 2, 5])\n    i = nditer(a.reshape(2, 3)[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 4, 5, 0, 1, 2])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [2, 1, 0, 5, 4, 3])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [3, 0, 4, 1, 5, 2])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [2, 5, 1, 4, 0, 3])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [5, 2, 4, 1, 3, 0])\n\ntest_iter_best_order_c_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_c_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['c_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['c_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], ['c_index'],\n        [['readonly']])\n    assert_equal(iter_indices(i), [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])\n\ntest_iter_best_order_c_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_1d():\n    a = arange(4)\n    i = nditer(a, ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3])\n    i = nditer(a[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [3, 2, 1, 0])\n\ntest_iter_best_order_f_index_1d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_2d():\n    a = arange(6)\n    i = nditer(a.reshape(2, 3), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 2, 4, 1, 3, 5])\n    i = nditer(a.reshape(2, 3).copy(order='F'), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])\n    i = nditer(a.reshape(2, 3)[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 3, 5, 0, 2, 4])\n    i = nditer(a.reshape(2, 3)[:, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 2, 0, 5, 3, 1])\n    i = nditer(a.reshape(2, 3)[::-1, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [5, 3, 1, 4, 2, 0])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4])\n    i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1])\n    i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])\n\ntest_iter_best_order_f_index_2d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}, {"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_best_order_f_index_3d():\n    a = arange(12)\n    i = nditer(a.reshape(2, 3, 2), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    i = nditer(a.reshape(2, 3, 2)[::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])\n    i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])\n    i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['f_index'], [['readonly']])\n    assert_equal(iter_indices(i), [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1], ['f_index'], [[\n        'readonly']])\n    assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])\n    i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1], ['f_index'],\n        [['readonly']])\n    assert_equal(iter_indices(i), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])\n\ntest_iter_best_order_f_index_3d()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_indices(i): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "iter_iterindices", "method_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py", "response": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef iter_iterindices(i):\n    ret = []\n    while not i.finished:\n        ret.append(i.iterindex)\n        i.iternext()\n    return ret", "test_code_list": [{"test_code": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\ndef test_iter_iterindex():\n    buffersize = 5\n    a = arange(24).reshape(4, 3, 2)\n    for flags in ([], ['buffered']):\n        i = nditer(a, flags, buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 2\n        assert_equal(iter_iterindices(i), list(range(2, 24)))\n        i = nditer(a, flags, order='F', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 5\n        assert_equal(iter_iterindices(i), list(range(5, 24)))\n        i = nditer(a[::-1], flags, order='F', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 9\n        assert_equal(iter_iterindices(i), list(range(9, 24)))\n        i = nditer(a[::-1, ::-1], flags, order='C', buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 13\n        assert_equal(iter_iterindices(i), list(range(13, 24)))\n        i = nditer(a[::1, ::-1], flags, buffersize=buffersize)\n        assert_equal(iter_iterindices(i), list(range(24)))\n        i.iterindex = 23\n        assert_equal(iter_iterindices(i), list(range(23, 24)))\n        i.reset()\n        i.iterindex = 2\n        assert_equal(iter_iterindices(i), list(range(2, 24)))\n\ntest_iter_iterindex()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/_core/tests/test_nditer.py"}], "method_code_mask": "import sys\nimport pytest\nimport textwrap\nimport subprocess\nimport numpy as np\nfrom numpy import array\nfrom numpy import arange\nfrom numpy import nditer\nfrom numpy import all\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import HAS_REFCOUNT\nfrom numpy.testing import suppress_warnings\nfrom numpy.testing import break_cycles\n\n\ndef iter_iterindices(i): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "check_dir", "method_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py", "response": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef check_dir(module, module_name=None):\n    \"\"\"Returns a mapping of all objects with the wrong __module__ attribute.\"\"\"\n    if module_name is None:\n        module_name = module.__name__\n    results = {}\n    for name in dir(module):\n        if name == 'core':\n            continue\n        item = getattr(module, name)\n        if hasattr(item, '__module__') and hasattr(item, '__name__'\n            ) and item.__module__ != module_name:\n            results[name] = item.__module__ + '.' + item.__name__\n    return results", "test_code_list": [{"test_code": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef test_numpy_linalg():\n    bad_results = check_dir(np.linalg)\n    assert bad_results == {}\n\ntest_numpy_linalg()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py"}, {"test_code": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\ndef test_numpy_fft():\n    bad_results = check_dir(np.fft)\n    assert bad_results == {}\n\ntest_numpy_fft()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_public_api.py"}], "method_code_mask": "import sys\nimport sysconfig\nimport subprocess\nimport pkgutil\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport numpy as np\nimport numpy\nimport pytest\nimport ctypes\nimport numpy.core as core\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nfrom typing import Tuple\n\n\ndef check_dir(module, module_name=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "ndpointer", "method_path": "../srcdata/Computation/numpy/numpy/ctypeslib.py", "response": "import os\nfrom numpy import integer\nfrom numpy import ndarray\nfrom numpy import dtype as _dtype\nfrom numpy import asarray\nfrom numpy import frombuffer\nimport ctypes\nfrom numpy import intp as c_intp\nimport sys\nimport sysconfig\ndef ndpointer(dtype=None, ndim=None, shape=None, flags=None):\n    \"\"\"\n    Array-checking restype/argtypes.\n\n    An ndpointer instance is used to describe an ndarray in restypes\n    and argtypes specifications.  This approach is more flexible than\n    using, for example, ``POINTER(c_double)``, since several restrictions\n    can be specified, which are verified upon calling the ctypes function.\n    These include data type, number of dimensions, shape and flags.  If a\n    given array does not satisfy the specified restrictions,\n    a ``TypeError`` is raised.\n\n    Parameters\n    ----------\n    dtype : data-type, optional\n        Array data-type.\n    ndim : int, optional\n        Number of array dimensions.\n    shape : tuple of ints, optional\n        Array shape.\n    flags : str or tuple of str\n        Array flags; may be one or more of:\n\n        - C_CONTIGUOUS / C / CONTIGUOUS\n        - F_CONTIGUOUS / F / FORTRAN\n        - OWNDATA / O\n        - WRITEABLE / W\n        - ALIGNED / A\n        - WRITEBACKIFCOPY / X\n\n    Returns\n    -------\n    klass : ndpointer type object\n        A type object, which is an ``_ndtpr`` instance containing\n        dtype, ndim, shape and flags information.\n\n    Raises\n    ------\n    TypeError\n        If a given array does not satisfy the specified restrictions.\n\n    Examples\n    --------\n    >>> clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,\n    ...                                                  ndim=1,\n    ...                                                  flags='C_CONTIGUOUS')]\n    ... #doctest: +SKIP\n    >>> clib.somefunc(np.array([1, 2, 3], dtype=np.float64))\n    ... #doctest: +SKIP\n\n    \"\"\"\n    if dtype is not None:\n        dtype = _dtype(dtype)\n    num = None\n    if flags is not None:\n        if isinstance(flags, str):\n            flags = flags.split(',')\n        elif isinstance(flags, (int, integer)):\n            num = flags\n            flags = _flags_fromnum(num)\n        elif isinstance(flags, flagsobj):\n            num = flags.num\n            flags = _flags_fromnum(num)\n        if num is None:\n            try:\n                flags = [x.strip().upper() for x in flags]\n            except Exception as e:\n                raise TypeError('invalid flags specification') from e\n            num = _num_fromflags(flags)\n    if shape is not None:\n        try:\n            shape = tuple(shape)\n        except TypeError:\n            shape = shape,\n    cache_key = dtype, ndim, shape, num\n    try:\n        return _pointer_type_cache[cache_key]\n    except KeyError:\n        pass\n    if dtype is None:\n        name = 'any'\n    elif dtype.names is not None:\n        name = str(id(dtype))\n    else:\n        name = dtype.str\n    if ndim is not None:\n        name += '_%dd' % ndim\n    if shape is not None:\n        name += '_' + 'x'.join(str(x) for x in shape)\n    if flags is not None:\n        name += '_' + '_'.join(flags)\n    if dtype is not None and shape is not None:\n        base = _concrete_ndptr\n    else:\n        base = _ndptr\n    klass = type('ndpointer_%s' % name, (base,), {'_dtype_': dtype,\n        '_shape_': shape, '_ndim_': ndim, '_flags_': num})\n    _pointer_type_cache[cache_key] = klass\n    return klass", "test_code_list": [{"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_dtype(self):\n\t    dt = np.intc\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.array([1], dt)))\n\t    dt = '<i4'\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.array([1], dt)))\n\t    dt = np.dtype('>i4')\n\t    p = ndpointer(dtype=dt)\n\t    p.from_param(np.array([1], dt))\n\t    assert_raises(TypeError, p.from_param, np.array([1], dt.newbyteorder(\n\t        'swap')))\n\t    dtnames = ['x', 'y']\n\t    dtformats = [np.intc, np.float64]\n\t    dtdescr = {'names': dtnames, 'formats': dtformats}\n\t    dt = np.dtype(dtdescr)\n\t    p = ndpointer(dtype=dt)\n\t    assert_(p.from_param(np.zeros((10,), dt)))\n\t    samedt = np.dtype(dtdescr)\n\t    p = ndpointer(dtype=samedt)\n\t    assert_(p.from_param(np.zeros((10,), dt)))\n\t    dt2 = np.dtype(dtdescr, align=True)\n\t    if dt.itemsize != dt2.itemsize:\n\t        assert_raises(TypeError, p.from_param, np.zeros((10,), dt2))\n\t    else:\n\t        assert_(p.from_param(np.zeros((10,), dt2)))\n\t\nTestNdpointer().test_dtype()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_ndim(self):\n\t    p = ndpointer(ndim=0)\n\t    assert_(p.from_param(np.array(1)))\n\t    assert_raises(TypeError, p.from_param, np.array([1]))\n\t    p = ndpointer(ndim=1)\n\t    assert_raises(TypeError, p.from_param, np.array(1))\n\t    assert_(p.from_param(np.array([1])))\n\t    p = ndpointer(ndim=2)\n\t    assert_(p.from_param(np.array([[1]])))\n\t\nTestNdpointer().test_ndim()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_shape(self):\n\t    p = ndpointer(shape=(1, 2))\n\t    assert_(p.from_param(np.array([[1, 2]])))\n\t    assert_raises(TypeError, p.from_param, np.array([[1], [2]]))\n\t    p = ndpointer(shape=())\n\t    assert_(p.from_param(np.array(1)))\n\t\nTestNdpointer().test_shape()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_flags(self):\n\t    x = np.array([[1, 2], [3, 4]], order='F')\n\t    p = ndpointer(flags='FORTRAN')\n\t    assert_(p.from_param(x))\n\t    p = ndpointer(flags='CONTIGUOUS')\n\t    assert_raises(TypeError, p.from_param, x)\n\t    p = ndpointer(flags=x.flags.num)\n\t    assert_(p.from_param(x))\n\t    assert_raises(TypeError, p.from_param, np.array([[1, 2], [3, 4]]))\n\t\nTestNdpointer().test_flags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}, {"test_code": "import sys\nimport sysconfig\nimport weakref\nfrom pathlib import Path\nimport pytest\nimport numpy as np\nfrom numpy.ctypeslib import ndpointer\nfrom numpy.ctypeslib import load_library\nfrom numpy.ctypeslib import as_array\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_raises\nfrom numpy.testing import assert_equal\nimport ctypes\nfrom ctypes import c_int\nfrom ctypes import cast\nfrom ctypes import POINTER\nfrom ctypes import c_int16\nfrom ctypes import Structure\nfrom ctypes import pointer\n\nclass TestNdpointer():\n\tdef test_cache(self):\n\t    assert_(ndpointer(dtype=np.float64) is ndpointer(dtype=np.float64))\n\t    assert_(ndpointer(shape=2) is ndpointer(shape=(2,)))\n\t    assert_(ndpointer(shape=2) is not ndpointer(ndim=2))\n\t    assert_(ndpointer(ndim=2) is not ndpointer(shape=2))\n\t\nTestNdpointer().test_cache()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_ctypeslib.py"}], "method_code_mask": "import os\nfrom numpy import integer\nfrom numpy import ndarray\nfrom numpy import dtype as _dtype\nfrom numpy import asarray\nfrom numpy import frombuffer\nimport ctypes\nfrom numpy import intp as c_intp\nimport sys\nimport sysconfig\n\n\ndef ndpointer(dtype=None, ndim=None, shape=None, flags=None): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "ones", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "response": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef ones(shape, dtype=None, order='C'):\n    \"\"\"\n    Matrix of ones.\n\n    Return a matrix of given shape and type, filled with ones.\n\n    Parameters\n    ----------\n    shape : {sequence of ints, int}\n        Shape of the matrix\n    dtype : data-type, optional\n        The desired data-type for the matrix, default is np.float64.\n    order : {'C', 'F'}, optional\n        Whether to store matrix in C- or Fortran-contiguous order,\n        default is 'C'.\n\n    Returns\n    -------\n    out : matrix\n        Matrix of ones of given shape, dtype, and order.\n\n    See Also\n    --------\n    ones : Array of ones.\n    matlib.zeros : Zero matrix.\n\n    Notes\n    -----\n    If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,\n    `out` becomes a single row matrix of shape ``(1,N)``.\n\n    Examples\n    --------\n    >>> np.matlib.ones((2,3))\n    matrix([[1.,  1.,  1.],\n            [1.,  1.,  1.]])\n\n    >>> np.matlib.ones(2)\n    matrix([[1.,  1.]])\n\n    \"\"\"\n    a = ndarray.__new__(matrix, shape, dtype, order=order)\n    a.fill(1)\n    return a", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_ones():\n    assert_array_equal(ones((2, 3)), np.matrix([[1.0, 1.0, 1.0\n        ], [1.0, 1.0, 1.0]]))\n    assert_array_equal(ones(2), np.matrix([[1.0, 1.0]]))\n\ntest_ones()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef ones(shape, dtype=None, order='C'): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "zeros", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "response": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef zeros(shape, dtype=None, order='C'):\n    \"\"\"\n    Return a matrix of given shape and type, filled with zeros.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the matrix\n    dtype : data-type, optional\n        The desired data-type for the matrix, default is float.\n    order : {'C', 'F'}, optional\n        Whether to store the result in C- or Fortran-contiguous order,\n        default is 'C'.\n\n    Returns\n    -------\n    out : matrix\n        Zero matrix of given shape, dtype, and order.\n\n    See Also\n    --------\n    numpy.zeros : Equivalent array function.\n    matlib.ones : Return a matrix of ones.\n\n    Notes\n    -----\n    If `shape` has length one i.e. ``(N,)``, or is a scalar ``N``,\n    `out` becomes a single row matrix of shape ``(1,N)``.\n\n    Examples\n    --------\n    >>> import numpy.matlib\n    >>> np.matlib.zeros((2, 3))\n    matrix([[0.,  0.,  0.],\n            [0.,  0.,  0.]])\n\n    >>> np.matlib.zeros(2)\n    matrix([[0.,  0.]])\n\n    \"\"\"\n    a = ndarray.__new__(matrix, shape, dtype, order=order)\n    a.fill(0)\n    return a", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_zeros():\n    assert_array_equal(zeros((2, 3)), np.matrix([[0.0, 0.0, \n        0.0], [0.0, 0.0, 0.0]]))\n    assert_array_equal(zeros(2), np.matrix([[0.0, 0.0]]))\n\ntest_zeros()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef zeros(shape, dtype=None, order='C'): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "rand", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "response": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef rand(*args):\n    \"\"\"\n    Return a matrix of random values with given shape.\n\n    Create a matrix of the given shape and propagate it with\n    random samples from a uniform distribution over ``[0, 1)``.\n\n    Parameters\n    ----------\n    \\\\*args : Arguments\n        Shape of the output.\n        If given as N integers, each integer specifies the size of one\n        dimension.\n        If given as a tuple, this tuple gives the complete shape.\n\n    Returns\n    -------\n    out : ndarray\n        The matrix of random values with shape given by `\\\\*args`.\n\n    See Also\n    --------\n    randn, numpy.random.RandomState.rand\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> import numpy.matlib\n    >>> np.matlib.rand(2, 3)\n    matrix([[0.69646919, 0.28613933, 0.22685145],\n            [0.55131477, 0.71946897, 0.42310646]])\n    >>> np.matlib.rand((2, 3))\n    matrix([[0.9807642 , 0.68482974, 0.4809319 ],\n            [0.39211752, 0.34317802, 0.72904971]])\n\n    If the first argument is a tuple, other arguments are ignored:\n\n    >>> np.matlib.rand((2, 3), 4)\n    matrix([[0.43857224, 0.0596779 , 0.39804426],\n            [0.73799541, 0.18249173, 0.17545176]])\n\n    \"\"\"\n    if isinstance(args[0], tuple):\n        args = args[0]\n    return asmatrix(np.random.rand(*args))", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_rand():\n    x = rand(3)\n    assert_(x.ndim == 2)\n\ntest_rand()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef rand(*args): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "randn", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "response": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef randn(*args):\n    \"\"\"\n    Return a random matrix with data from the \"standard normal\" distribution.\n\n    `randn` generates a matrix filled with random floats sampled from a\n    univariate \"normal\" (Gaussian) distribution of mean 0 and variance 1.\n\n    Parameters\n    ----------\n    \\\\*args : Arguments\n        Shape of the output.\n        If given as N integers, each integer specifies the size of one\n        dimension. If given as a tuple, this tuple gives the complete shape.\n\n    Returns\n    -------\n    Z : matrix of floats\n        A matrix of floating-point samples drawn from the standard normal\n        distribution.\n\n    See Also\n    --------\n    rand, numpy.random.RandomState.randn\n\n    Notes\n    -----\n    For random samples from the normal distribution with mean ``mu`` and\n    standard deviation ``sigma``, use::\n\n        sigma * np.matlib.randn(...) + mu\n\n    Examples\n    --------\n    >>> np.random.seed(123)\n    >>> import numpy.matlib\n    >>> np.matlib.randn(1)\n    matrix([[-1.0856306]])\n    >>> np.matlib.randn(1, 2, 3)\n    matrix([[ 0.99734545,  0.2829785 , -1.50629471],\n            [-0.57860025,  1.65143654, -2.42667924]])\n\n    Two-by-four matrix of samples from the normal distribution with\n    mean 3 and standard deviation 2.5:\n\n    >>> 2.5 * np.matlib.randn((2, 4)) + 3\n    matrix([[1.92771843, 6.16484065, 0.83314899, 1.30278462],\n            [2.76322758, 6.72847407, 1.40274501, 1.8900451 ]])\n\n    \"\"\"\n    if isinstance(args[0], tuple):\n        args = args[0]\n    return asmatrix(np.random.randn(*args))", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_randn():\n    x = randn(3)\n    assert_(x.ndim == 2)\n\ntest_randn()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef randn(*args): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "repmat", "method_path": "../srcdata/Computation/numpy/numpy/matlib.py", "response": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\ndef repmat(a, m, n):\n    \"\"\"\n    Repeat a 0-D to 2-D array or matrix MxN times.\n\n    Parameters\n    ----------\n    a : array_like\n        The array or matrix to be repeated.\n    m, n : int\n        The number of times `a` is repeated along the first and second axes.\n\n    Returns\n    -------\n    out : ndarray\n        The result of repeating `a`.\n\n    Examples\n    --------\n    >>> import numpy.matlib\n    >>> a0 = np.array(1)\n    >>> np.matlib.repmat(a0, 2, 3)\n    array([[1, 1, 1],\n           [1, 1, 1]])\n\n    >>> a1 = np.arange(4)\n    >>> np.matlib.repmat(a1, 2, 2)\n    array([[0, 1, 2, 3, 0, 1, 2, 3],\n           [0, 1, 2, 3, 0, 1, 2, 3]])\n\n    >>> a2 = np.asmatrix(np.arange(6).reshape(2, 3))\n    >>> np.matlib.repmat(a2, 2, 3)\n    matrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],\n            [3, 4, 5, 3, 4, 5, 3, 4, 5],\n            [0, 1, 2, 0, 1, 2, 0, 1, 2],\n            [3, 4, 5, 3, 4, 5, 3, 4, 5]])\n\n    \"\"\"\n    a = asanyarray(a)\n    ndim = a.ndim\n    if ndim == 0:\n        origrows, origcols = 1, 1\n    elif ndim == 1:\n        origrows, origcols = 1, a.shape[0]\n    else:\n        origrows, origcols = a.shape\n    rows = origrows * m\n    cols = origcols * n\n    c = a.reshape(1, a.size).repeat(m, 0).reshape(rows, origcols).repeat(n, 0)\n    return c.reshape(rows, cols)", "test_code_list": [{"test_code": "import numpy as np\nimport numpy.matlib\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_\ndef test_repmat():\n    a1 = np.arange(4)\n    x = repmat(a1, 2, 2)\n    y = np.array([[0, 1, 2, 3, 0, 1, 2, 3], [0, 1, 2, 3, 0, 1, 2, 3]])\n    assert_array_equal(x, y)\n\ntest_repmat()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/tests/test_matlib.py"}], "method_code_mask": "import warnings\nimport numpy as np\nfrom numpy.matrixlib.defmatrix import matrix\nfrom numpy.matrixlib.defmatrix import asmatrix\nfrom numpy import *\n\n\ndef repmat(a, m, n): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "minrelpath", "method_path": "../srcdata/Computation/numpy/numpy/distutils/misc_util.py", "response": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\ndef minrelpath(path):\n    \"\"\"Resolve `..` and '.' from path.\n    \"\"\"\n    if not is_string(path):\n        return path\n    if '.' not in path:\n        return path\n    l = path.split(os.sep)\n    while l:\n        try:\n            i = l.index('.', 1)\n        except ValueError:\n            break\n        del l[i]\n    j = 1\n    while l:\n        try:\n            i = l.index('..', j)\n        except ValueError:\n            break\n        if l[i - 1] == '..':\n            j += 1\n        else:\n            del l[i], l[i - 1]\n            j = 1\n    if not l:\n        return ''\n    return os.sep.join(l)", "test_code_list": [{"test_code": "from os.path import join\nfrom os.path import sep\nfrom os.path import dirname\nimport pytest\nfrom numpy.distutils.misc_util import appendpath\nfrom numpy.distutils.misc_util import minrelpath\nfrom numpy.distutils.misc_util import gpaths\nfrom numpy.distutils.misc_util import get_shared_lib_extension\nfrom numpy.distutils.misc_util import get_info\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nimport sys\n\nclass TestMinrelpath():\n\tdef test_1(self):\n\t    n = lambda path: path.replace('/', sep)\n\t    assert_equal(minrelpath(n('aa/bb')), n('aa/bb'))\n\t    assert_equal(minrelpath('..'), '..')\n\t    assert_equal(minrelpath(n('aa/..')), '')\n\t    assert_equal(minrelpath(n('aa/../bb')), 'bb')\n\t    assert_equal(minrelpath(n('aa/bb/..')), 'aa')\n\t    assert_equal(minrelpath(n('aa/bb/../..')), '')\n\t    assert_equal(minrelpath(n('aa/bb/../cc/../dd')), n('aa/dd'))\n\t    assert_equal(minrelpath(n('.././..')), n('../..'))\n\t    assert_equal(minrelpath(n('aa/bb/.././../dd')), n('dd'))\n\t\nTestMinrelpath().test_1()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_misc_util.py"}], "method_code_mask": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\n\n\ndef minrelpath(path): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "get_shared_lib_extension", "method_path": "../srcdata/Computation/numpy/numpy/distutils/misc_util.py", "response": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\ndef get_shared_lib_extension(is_python_ext=False):\n    \"\"\"Return the correct file extension for shared libraries.\n\n    Parameters\n    ----------\n    is_python_ext : bool, optional\n        Whether the shared library is a Python extension.  Default is False.\n\n    Returns\n    -------\n    so_ext : str\n        The shared library extension.\n\n    Notes\n    -----\n    For Python shared libs, `so_ext` will typically be '.so' on Linux and OS X,\n    and '.pyd' on Windows.  For Python >= 3.2 `so_ext` has a tag prepended on\n    POSIX systems according to PEP 3149.\n\n    \"\"\"\n    confvars = distutils.sysconfig.get_config_vars()\n    so_ext = confvars.get('EXT_SUFFIX', '')\n    if not is_python_ext:\n        if sys.platform.startswith('linux') or sys.platform.startswith(\n            'gnukfreebsd'):\n            so_ext = '.so'\n        elif sys.platform.startswith('darwin'):\n            so_ext = '.dylib'\n        elif sys.platform.startswith('win'):\n            so_ext = '.dll'\n        elif 'SOABI' in confvars:\n            so_ext = so_ext.replace('.' + confvars.get('SOABI'), '', 1)\n    return so_ext", "test_code_list": [{"test_code": "from os.path import join\nfrom os.path import sep\nfrom os.path import dirname\nimport pytest\nfrom numpy.distutils.misc_util import appendpath\nfrom numpy.distutils.misc_util import minrelpath\nfrom numpy.distutils.misc_util import gpaths\nfrom numpy.distutils.misc_util import get_shared_lib_extension\nfrom numpy.distutils.misc_util import get_info\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_equal\nimport sys\n\nclass TestSharedExtension():\n\tdef test_get_shared_lib_extension(self):\n\t    import sys\n\t    ext = get_shared_lib_extension(is_python_ext=False)\n\t    if sys.platform.startswith('linux'):\n\t        assert_equal(ext, '.so')\n\t    elif sys.platform.startswith('gnukfreebsd'):\n\t        assert_equal(ext, '.so')\n\t    elif sys.platform.startswith('darwin'):\n\t        assert_equal(ext, '.dylib')\n\t    elif sys.platform.startswith('win'):\n\t        assert_equal(ext, '.dll')\n\t    assert_(get_shared_lib_extension(is_python_ext=True))\n\t\nTestSharedExtension().test_get_shared_lib_extension()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_misc_util.py"}], "method_code_mask": "import os\nimport re\nimport sys\nimport copy\nimport glob\nimport atexit\nimport tempfile\nimport subprocess\nimport shutil\nimport multiprocessing\nimport textwrap\nimport importlib.util\nfrom threading import local as tlocal\nfrom functools import reduce\nimport distutils\nfrom distutils.errors import DistutilsError\nfrom numpy.distutils.core import get_distribution\nimport warnings\nimport curses\nfrom numpy.distutils.core import Extension\nfrom pprint import pformat\nimport distutils.core\nfrom distutils.errors import DistutilsInternalError\nimport numpy\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nimport builtins\nfrom numpy.distutils.system_info import system_info\nfrom distutils.dir_util import mkpath\nfrom distutils.msvccompiler import get_build_architecture\n\n\ndef get_shared_lib_extension(is_python_ext=False): [MASK]\n"}
{"model_name": "std", "repository": "numpy", "full_method_name": "parse_flags", "method_path": "../srcdata/Computation/numpy/numpy/distutils/npy_pkg_config.py", "response": "import sys\nimport re\nimport os\nfrom configparser import RawConfigParser\nfrom optparse import OptionParser\nimport glob\ndef parse_flags(line):\n    \"\"\"\n    Parse a line from a config file containing compile flags.\n\n    Parameters\n    ----------\n    line : str\n        A single line containing one or more compile flags.\n\n    Returns\n    -------\n    d : dict\n        Dictionary of parsed flags, split into relevant categories.\n        These categories are the keys of `d`:\n\n        * 'include_dirs'\n        * 'library_dirs'\n        * 'libraries'\n        * 'macros'\n        * 'ignored'\n\n    \"\"\"\n    d = {'include_dirs': [], 'library_dirs': [], 'libraries': [], 'macros':\n        [], 'ignored': []}\n    flags = (' ' + line).split(' -')\n    for flag in flags:\n        flag = '-' + flag\n        if len(flag) > 0:\n            if flag.startswith('-I'):\n                d['include_dirs'].append(flag[2:].strip())\n            elif flag.startswith('-L'):\n                d['library_dirs'].append(flag[2:].strip())\n            elif flag.startswith('-l'):\n                d['libraries'].append(flag[2:].strip())\n            elif flag.startswith('-D'):\n                d['macros'].append(flag[2:].strip())\n            else:\n                d['ignored'].append(flag)\n    return d", "test_code_list": [{"test_code": "import os\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_\n\nclass TestParseFlags():\n\tdef test_simple_cflags(self):\n\t    d = parse_flags('-I/usr/include')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    d = parse_flags('-I/usr/include -DFOO')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    assert_(d['macros'] == ['FOO'])\n\t    d = parse_flags('-I /usr/include -DFOO')\n\t    assert_(d['include_dirs'] == ['/usr/include'])\n\t    assert_(d['macros'] == ['FOO'])\n\t\nTestParseFlags().test_simple_cflags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_npy_pkg_config.py"}, {"test_code": "import os\nfrom numpy.distutils.npy_pkg_config import read_config\nfrom numpy.distutils.npy_pkg_config import parse_flags\nfrom numpy.testing import temppath\nfrom numpy.testing import assert_\n\nclass TestParseFlags():\n\tdef test_simple_lflags(self):\n\t    d = parse_flags('-L/usr/lib -lfoo -L/usr/lib -lbar')\n\t    assert_(d['library_dirs'] == ['/usr/lib', '/usr/lib'])\n\t    assert_(d['libraries'] == ['foo', 'bar'])\n\t    d = parse_flags('-L /usr/lib -lfoo -L/usr/lib -lbar')\n\t    assert_(d['library_dirs'] == ['/usr/lib', '/usr/lib'])\n\t    assert_(d['libraries'] == ['foo', 'bar'])\n\t\nTestParseFlags().test_simple_lflags()\n", "code_start": "", "test_path": "../srcdata/Computation/numpy/numpy/distutils/tests/test_npy_pkg_config.py"}], "method_code_mask": "import sys\nimport re\nimport os\nfrom configparser import RawConfigParser\nfrom optparse import OptionParser\nimport glob\n\n\ndef parse_flags(line): [MASK]\n"}
