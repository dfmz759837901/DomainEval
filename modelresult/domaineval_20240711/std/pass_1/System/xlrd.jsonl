{"model_name": "std", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "std", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "std", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple ``(year, month, day, hour, minute, second)`` to an\n    Excel date value.\n    For more details, refer to other xldate_from_*_tuple functions.\n    :param datetime_tuple: ``(year, month, day, hour, minute, second)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    \"\"\"\n    return xldate_from_date_tuple(datetime_tuple[:3], datemode\n        ) + xldate_from_time_tuple(datetime_tuple[3:])", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
