{"model_name": "std", "repository": "core", "full_method_name": "_parse_client_id", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "response": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\ndef _parse_client_id(client_id: str) ->ParseResult:\n    \"\"\"Test if client id is a valid URL according to IndieAuth section 3.2.\n    https://indieauth.spec.indieweb.org/#client-identifier\n    \"\"\"\n    parts = _parse_url(client_id)\n    if parts.scheme not in ('http', 'https'):\n        raise ValueError\n    if any(segment in ('.', '..') for segment in parts.path.split('/')):\n        raise ValueError(\n            'Client ID cannot contain single-dot or double-dot path segments')\n    if parts.fragment != '':\n        raise ValueError('Client ID cannot contain a fragment')\n    if parts.username is not None:\n        raise ValueError('Client ID cannot contain username')\n    if parts.password is not None:\n        raise ValueError('Client ID cannot contain password')\n    try:\n        _ = parts.port\n    except ValueError as ex:\n        raise ValueError('Client ID contains invalid port') from ex\n    address = None\n    try:\n        netloc = parts.netloc\n        if netloc[0] == '[' and netloc[-1] == ']':\n            netloc = netloc[1:-1]\n        address = ip_address(netloc)\n    except ValueError:\n        pass\n    if address is None or is_local(address):\n        return parts\n    raise ValueError('Hostname should be a domain name or local IP address')", "test_code_list": [{"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_client_id_scheme() ->None:\n    \"\"\"Test we enforce valid scheme.\"\"\"\n    assert _parse_client_id('http://ex.com/')\n    assert _parse_client_id('https://ex.com/')\n    with pytest.raises(ValueError):\n        _parse_client_id('ftp://ex.com')\n\ntest_client_id_scheme()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}, {"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_client_id_path() ->None:\n    \"\"\"Test we enforce valid path.\"\"\"\n    assert _parse_client_id('http://ex.com').path == '/'\n    assert _parse_client_id('http://ex.com/hello').path == '/hello'\n    assert _parse_client_id('http://ex.com/hello/.world'\n        ).path == '/hello/.world'\n    assert _parse_client_id('http://ex.com/hello./.world'\n        ).path == '/hello./.world'\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/.')\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/hello/./yo')\n    with pytest.raises(ValueError):\n        _parse_client_id('http://ex.com/hello/../yo')\n\ntest_client_id_path()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}], "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts\n\n\ndef _parse_client_id(client_id: str) ->ParseResult: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "_parse_url", "method_path": "../srcdata/System/core/homeassistant/components/auth/indieauth.py", "response": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\ndef _parse_url(url: str) ->ParseResult:\n    \"\"\"Parse a url in parts and canonicalize according to IndieAuth.\"\"\"\n    parts = urlparse(url)\n    parts = parts._replace(netloc=parts.netloc.lower())\n    if parts.path == '':\n        parts = parts._replace(path='/')\n    return parts", "test_code_list": [{"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_parse_url_lowercase_host() ->None:\n    \"\"\"Test we update empty paths.\"\"\"\n    assert _parse_url('http://ex.com/hello').path == '/hello'\n    assert _parse_url('http://EX.COM/hello').hostname == 'ex.com'\n    parts = _parse_url('http://EX.COM:123/HELLO')\n    assert parts.netloc == 'ex.com:123'\n    assert parts.path == '/HELLO'\n\ntest_parse_url_lowercase_host()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}, {"test_code": "import asyncio\nfrom unittest.mock import patch\nimport pytest\ndef test_parse_url_path() ->None:\n    \"\"\"Test we update empty paths.\"\"\"\n    assert _parse_url('http://ex.com').path == '/'\n\ntest_parse_url_path()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/auth/test_indieauth.py"}], "method_code_mask": "from __future__ import annotations\nfrom html.parser import HTMLParser\nfrom ipaddress import ip_address\nimport logging\nfrom urllib.parse import ParseResult\nfrom urllib.parse import urljoin\nfrom urllib.parse import urlparse\nimport aiohttp\nimport aiohttp.client_exceptions\n\n\ndef _parse_url(url: str) ->ParseResult: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "as_number", "method_path": "../srcdata/System/core/homeassistant/components/ista_ecotrend/util.py", "response": "from __future__ import annotations\nimport datetime\nfrom typing import Any\ndef as_number(value: (str | float | None)) ->(float | int | None):\n    \"\"\"Convert readings to float or int.\n\n    Readings in the json response are returned as strings,\n    float values have comma as decimal separator\n    \"\"\"\n    if isinstance(value, str):\n        return int(value) if value.isdigit() else float(value.replace(',', '.')\n            )\n    return value", "test_code_list": [{"test_code": "def test_as_number() ->None:\n    \"\"\"Test as_number formatting function.\"\"\"\n    assert as_number('10') == 10\n    assert isinstance(as_number('10'), int)\n    assert as_number('9,5') == 9.5\n    assert isinstance(as_number('9,5'), float)\n    assert as_number(None) is None\n    assert isinstance(as_number(10.0), float)\n\ntest_as_number()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/ista_ecotrend/test_util.py"}], "method_code_mask": "from __future__ import annotations\nimport datetime\nfrom typing import Any\n\n\ndef as_number(value: (str | float | None)) ->(float | int | None): [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "_get_community_post_import_url", "method_path": "../srcdata/System/core/homeassistant/components/blueprint/importer.py", "response": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\ndef _get_community_post_import_url(url: str) ->str:\n    \"\"\"Convert a forum post url to an import url.\n    Async friendly.\n    \"\"\"\n    if (match := COMMUNITY_TOPIC_PATTERN.match(url)) is None:\n        raise UnsupportedUrl('Not a topic url')\n    _topic, post = match.groups()\n    json_url = url\n    if post is not None:\n        json_url = json_url[:-len(post) - 1]\n    json_url += '.json'\n    return json_url", "test_code_list": [{"test_code": "import json\nfrom pathlib import Path\nimport pytest\ndef test_get_community_post_import_url() ->None:\n    \"\"\"Test variations of generating import forum url.\"\"\"\n    assert _get_community_post_import_url(\n        'https://community.home-assistant.io/t/test-topic/123'\n        ) == 'https://community.home-assistant.io/t/test-topic/123.json'\n    assert _get_community_post_import_url(\n        'https://community.home-assistant.io/t/test-topic/123/2'\n        ) == 'https://community.home-assistant.io/t/test-topic/123.json'\n\ntest_get_community_post_import_url()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/blueprint/test_importer.py"}], "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport html\nimport re\nimport yarl\nCOMMUNITY_TOPIC_PATTERN = re.compile(\n    '^https://community.home-assistant.io/t/[a-z0-9-]+/(?P<topic>\\\\d+)(?:/(?P<post>\\\\d+)|)$'\n    )\n\n\ndef _get_community_post_import_url(url: str) ->str: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "density_to_air_quality", "method_path": "../srcdata/System/core/homeassistant/components/homekit/util.py", "response": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\ndef density_to_air_quality(density: float) ->int:\n    \"\"\"Map PM2.5 \u00b5g/m3 density to HomeKit AirQuality level.\"\"\"\n    if density <= 9:\n        return 1\n    if density <= 35.4:\n        return 2\n    if density <= 55.4:\n        return 3\n    if density <= 125.4:\n        return 4\n    return 5", "test_code_list": [{"test_code": "from unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\ndef test_density_to_air_quality() ->None:\n    \"\"\"Test map PM2.5 density to HomeKit AirQuality level.\"\"\"\n    assert density_to_air_quality(0) == 1\n    assert density_to_air_quality(9) == 1\n    assert density_to_air_quality(9.1) == 2\n    assert density_to_air_quality(12) == 2\n    assert density_to_air_quality(35.4) == 2\n    assert density_to_air_quality(35.5) == 3\n    assert density_to_air_quality(55.4) == 3\n    assert density_to_air_quality(55.5) == 4\n    assert density_to_air_quality(125.4) == 4\n    assert density_to_air_quality(125.5) == 5\n    assert density_to_air_quality(200) == 5\n\ntest_density_to_air_quality()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/homekit/test_util.py"}], "method_code_mask": "from __future__ import annotations\nimport io\nimport ipaddress\nimport logging\nimport os\nimport re\nimport secrets\nimport socket\nfrom typing import Any\nfrom typing import cast\n\n\ndef density_to_air_quality(density: float) ->int: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "create_matcher", "method_path": "../srcdata/System/core/homeassistant/components/conversation/util.py", "response": "from __future__ import annotations\nimport re\ndef create_matcher(utterance: str) ->re.Pattern[str]:\n    \"\"\"Create a regex that matches the utterance.\"\"\"\n    parts = re.split('({\\\\w+}|\\\\[[\\\\w\\\\s]+\\\\] *)', utterance)\n    group_matcher = re.compile('{(\\\\w+)}')\n    optional_matcher = re.compile('\\\\[([\\\\w ]+)\\\\] *')\n    pattern = ['^']\n    for part in parts:\n        group_match = group_matcher.match(part)\n        optional_match = optional_matcher.match(part)\n        if group_match is None and optional_match is None:\n            pattern.append(part)\n            continue\n        if group_match is not None:\n            pattern.append(f'(?P<{group_match.groups()[0]}>[\\\\w ]+?)\\\\s*')\n        elif optional_match is not None:\n            pattern.append(f'(?:{optional_match.groups()[0]} *)?')\n    pattern.append('$')\n    return re.compile(''.join(pattern), re.IGNORECASE)", "test_code_list": [{"test_code": "def test_create_matcher() ->None:\n    \"\"\"Test the create matcher method.\"\"\"\n    pattern = create_matcher('Hello world')\n    assert pattern.match('Hello world') is not None\n    pattern = create_matcher('Hello {name}')\n    match = pattern.match('hello world')\n    assert match is not None\n    assert match.groupdict()['name'] == 'world'\n    no_match = pattern.match('Hello world, how are you?')\n    assert no_match is None\n    pattern = create_matcher('Turn on [the] {name}')\n    match = pattern.match('turn on the kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn off kitchen lights')\n    assert match is None\n    pattern = create_matcher('Turn on [the] [a] {name}')\n    match = pattern.match('turn on the kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on kitchen lights')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn on a kitchen light')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen light'\n    pattern = create_matcher('Turn {name}[s] on')\n    match = pattern.match('turn kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen light'\n    pattern = create_matcher('Turn [the great] {name} on')\n    match = pattern.match('turn the great kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n    match = pattern.match('turn kitchen lights on')\n    assert match is not None\n    assert match.groupdict()['name'] == 'kitchen lights'\n\ntest_create_matcher()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/conversation/test_util.py"}], "method_code_mask": "from __future__ import annotations\nimport re\n\n\ndef create_matcher(utterance: str) ->re.Pattern[str]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "gps_accuracy", "method_path": "../srcdata/System/core/homeassistant/components/aprs/device_tracker.py", "response": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int:\n    \"\"\"Calculate the GPS accuracy based on APRS posambiguity.\"\"\"\n    pos_a_map = {(0): 0, (1): 1 / 600, (2): 1 / 60, (3): 1 / 6, (4): 1}\n    if posambiguity in pos_a_map:\n        degrees = pos_a_map[posambiguity]\n        gps2 = gps[0], gps[1] + degrees\n        dist_m: float = geopy.distance.distance(gps, gps2).m\n        accuracy = round(dist_m)\n    else:\n        message = f\"APRS position ambiguity must be 0-4, not '{posambiguity}'.\"\n        raise ValueError(message)\n    return accuracy", "test_code_list": [{"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_0() ->None:\n    \"\"\"Test GPS accuracy level 0.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 0)\n    assert acc == 0\ntest_gps_accuracy_0()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_1() ->None:\n    \"\"\"Test GPS accuracy level 1.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 1)\n    assert acc == 186\ntest_gps_accuracy_1()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_2() ->None:\n    \"\"\"Test GPS accuracy level 2.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 2)\n    assert acc == 1855\ntest_gps_accuracy_2()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_3() ->None:\n    \"\"\"Test GPS accuracy level 3.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 3)\n    assert acc == 18553\ntest_gps_accuracy_3()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}, {"test_code": "from collections.abc import Generator\nfrom unittest.mock import MagicMock\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\nTEST_COORDS_NULL_ISLAND = 0, 0\ndef test_gps_accuracy_4() ->None:\n    \"\"\"Test GPS accuracy level 4.\"\"\"\n    acc = gps_accuracy(TEST_COORDS_NULL_ISLAND, 4)\n    assert acc == 111319\ntest_gps_accuracy_4()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/aprs/test_device_tracker.py"}], "method_code_mask": "from __future__ import annotations\nimport logging\nimport threading\nfrom typing import Any\nimport geopy.distance\n\n\ndef gps_accuracy(gps: tuple[float, float], posambiguity: int) ->int: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "TurboJPEGSingleton.instance", "method_path": "../srcdata/System/core/homeassistant/components/camera/img_util.py", "response": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None):\n        \"\"\"Singleton for TurboJPEG.\"\"\"\n        if TurboJPEGSingleton.__instance is None:\n            TurboJPEGSingleton()\n        return TurboJPEGSingleton.__instance\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False", "test_code_list": [{"test_code": "from unittest.mock import patch\nimport pytest\ndef _clear_turbojpeg_singleton():\n    TurboJPEGSingleton.__instance = None\ndef test_turbojpeg_singleton() ->None:\n    \"\"\"Verify the instance always gives back the same.\"\"\"\n    _clear_turbojpeg_singleton()\n    assert TurboJPEGSingleton.instance() == TurboJPEGSingleton.instance()\ntest_turbojpeg_singleton()", "code_start": "", "test_path": "../srcdata/System/core/tests/components/camera/test_img_util.py"}], "method_code_mask": "from __future__ import annotations\nfrom contextlib import suppress\nimport logging\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom typing import cast\n_LOGGER = logging.getLogger(__name__)\n\n\nclass TurboJPEGSingleton:\n    \"\"\"Load TurboJPEG only once.\n    Ensures we do not log load failures each snapshot\n    since camera image fetches happen every few\n    seconds.\n    \"\"\"\n    __instance: TurboJPEG | Literal[False] | None = None\n\n    @staticmethod\n    def instance() ->(TurboJPEG | Literal[False] | None): [MASK]\n\n    def __init__(self) ->None:\n        \"\"\"Try to create TurboJPEG only once.\"\"\"\n        try:\n            TurboJPEGSingleton.__instance = TurboJPEG()\n        except Exception:\n            _LOGGER.exception(\n                'Error loading libturbojpeg; Camera snapshot performance will be sub-optimal'\n                )\n            TurboJPEGSingleton.__instance = False\n"}
{"model_name": "std", "repository": "core", "full_method_name": "chunk_samples", "method_path": "../srcdata/System/core/homeassistant/components/assist_pipeline/vad.py", "response": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]:\n    \"\"\"Yield fixed-sized chunks from samples, keeping leftover bytes from previous call(s).\"\"\"\n    if len(leftover_chunk_buffer) + len(samples) < bytes_per_chunk:\n        leftover_chunk_buffer.append(samples)\n        return\n    next_chunk_idx = 0\n    if leftover_chunk_buffer:\n        bytes_to_copy = bytes_per_chunk - len(leftover_chunk_buffer)\n        leftover_chunk_buffer.append(samples[:bytes_to_copy])\n        next_chunk_idx = bytes_to_copy\n        yield leftover_chunk_buffer.bytes()\n        leftover_chunk_buffer.clear()\n    while next_chunk_idx < len(samples) - bytes_per_chunk + 1:\n        yield samples[next_chunk_idx:next_chunk_idx + bytes_per_chunk]\n        next_chunk_idx += bytes_per_chunk\n    if (rest_samples := samples[next_chunk_idx:]):\n        leftover_chunk_buffer.append(rest_samples)", "test_code_list": [{"test_code": "import itertools as it\nfrom unittest.mock import patch\ndef test_partial_chunk() ->None:\n    \"\"\"Test that chunk_samples returns when given a partial chunk.\"\"\"\n    bytes_per_chunk = 5\n    samples = bytes([1, 2, 3])\n    leftover_chunk_buffer = AudioBuffer(bytes_per_chunk)\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 0\n    assert leftover_chunk_buffer.bytes() == samples\n\ntest_partial_chunk()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/assist_pipeline/test_vad.py"}, {"test_code": "import itertools as it\nfrom unittest.mock import patch\ndef test_chunk_samples_leftover() ->None:\n    \"\"\"Test that chunk_samples property keeps left over bytes across calls.\"\"\"\n    bytes_per_chunk = 5\n    samples = bytes([1, 2, 3, 4, 5, 6])\n    leftover_chunk_buffer = AudioBuffer(bytes_per_chunk)\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 1\n    assert leftover_chunk_buffer.bytes() == bytes([6])\n    chunks = list(chunk_samples(samples, bytes_per_chunk,\n        leftover_chunk_buffer))\n    assert len(chunks) == 1\n    assert leftover_chunk_buffer.bytes() == bytes([5, 6])\n\ntest_chunk_samples_leftover()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/components/assist_pipeline/test_vad.py"}], "method_code_mask": "from __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass\nimport logging\nfrom typing import Final\nfrom typing import cast\n\n\nclass AudioBuffer:\n    \"\"\"Fixed-sized audio buffer with variable internal length.\"\"\"\n\n    def __init__(self, maxlen: int) ->None:\n        \"\"\"Initialize buffer.\"\"\"\n        self._buffer = bytearray(maxlen)\n        self._length = 0\n\n    @property\n    def length(self) ->int:\n        \"\"\"Get number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def clear(self) ->None:\n        \"\"\"Clear the buffer.\"\"\"\n        self._length = 0\n\n    def append(self, data: bytes) ->None:\n        \"\"\"Append bytes to the buffer, increasing the internal length.\"\"\"\n        data_len = len(data)\n        if self._length + data_len > len(self._buffer):\n            raise ValueError('Length cannot be greater than buffer size')\n        self._buffer[self._length:self._length + data_len] = data\n        self._length += data_len\n\n    def bytes(self) ->bytes:\n        \"\"\"Convert written portion of buffer to bytes.\"\"\"\n        return bytes(self._buffer[:self._length])\n\n    def __len__(self) ->int:\n        \"\"\"Get the number of bytes currently in the buffer.\"\"\"\n        return self._length\n\n    def __bool__(self) ->bool:\n        \"\"\"Return True if there are bytes in the buffer.\"\"\"\n        return self._length > 0\n\n\ndef chunk_samples(samples: bytes, bytes_per_chunk: int,\n    leftover_chunk_buffer: AudioBuffer) ->Iterable[bytes]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "get_time_zone", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "response": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None):\n    \"\"\"Get time zone from string. Return None if unable to determine.\n\n    Must be run in the executor if the ZoneInfo is not already\n    in the cache. If you are not sure, use async_get_time_zone.\n    \"\"\"\n    try:\n        return zoneinfo.ZoneInfo(time_zone_str)\n    except zoneinfo.ZoneInfoNotFoundError:\n        return None", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\nTEST_TIME_ZONE = 'America/Los_Angeles'\ndef test_get_time_zone_retrieves_valid_time_zone() ->None:\n    \"\"\"Test getting a time zone.\"\"\"\n    assert get_time_zone(TEST_TIME_ZONE) is not None\ntest_get_time_zone_retrieves_valid_time_zone()", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}, {"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\ndef test_get_time_zone_returns_none_for_garbage_time_zone() ->None:\n    \"\"\"Test getting a non existing time zone.\"\"\"\n    assert get_time_zone('Non existing time zone') is None\n\ntest_get_time_zone_returns_none_for_garbage_time_zone()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}], "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef get_time_zone(time_zone_str: str) ->(dt.tzinfo | None): [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "parse_time_expression", "method_path": "../srcdata/System/core/homeassistant/util/dt.py", "response": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]:\n    \"\"\"Parse the time expression part and return a list of times to match.\"\"\"\n    if parameter is None or parameter == '*':\n        res = list(range(min_value, max_value + 1))\n    elif isinstance(parameter, str):\n        if parameter.startswith('/'):\n            parameter = int(parameter[1:])\n            res = [x for x in range(min_value, max_value + 1) if x %\n                parameter == 0]\n        else:\n            res = [int(parameter)]\n    elif not hasattr(parameter, '__iter__'):\n        res = [int(parameter)]\n    else:\n        res = sorted(int(x) for x in parameter)\n    for val in res:\n        if val < min_value or val > max_value:\n            raise ValueError(\n                f\"Time expression '{parameter}': parameter {val} out of range ({min_value} to {max_value})\"\n                )\n    return res", "test_code_list": [{"test_code": "from datetime import datetime\nfrom datetime import timedelta\nimport pytest\ndef test_parse_time_expression() ->None:\n    \"\"\"Test parse_time_expression.\"\"\"\n    assert list(range(60)) == parse_time_expression('*', 0, 59)\n    assert list(range(60)) == parse_time_expression(None, 0, 59)\n    assert list(range(0, 60, 5)) == parse_time_expression('/5', 0, 59)\n    assert parse_time_expression([2, 1, 3], 0, 59) == [1, 2, 3]\n    assert list(range(24)) == parse_time_expression('*', 0, 23)\n    assert parse_time_expression(42, 0, 59) == [42]\n    assert parse_time_expression('42', 0, 59) == [42]\n    with pytest.raises(ValueError):\n        parse_time_expression(61, 0, 60)\n\ntest_parse_time_expression()\n", "code_start": "from __future__ import annotations\n", "test_path": "../srcdata/System/core/tests/util/test_dt.py"}], "method_code_mask": "from __future__ import annotations\nimport bisect\nfrom contextlib import suppress\nimport datetime as dt\nfrom functools import lru_cache\nfrom functools import partial\nimport re\nfrom typing import Any\nfrom typing import Literal\nfrom typing import overload\nimport zoneinfo\n\n\ndef parse_time_expression(parameter: Any, min_value: int, max_value: int\n    ) ->list[int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "is_ip_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ip_address() ->None:\n    \"\"\"Test if strings are IP addresses.\"\"\"\n    assert is_ip_address('192.168.0.1')\n    assert is_ip_address('8.8.8.8')\n    assert is_ip_address('::ffff:127.0.0.0')\n    assert not is_ip_address('192.168.0.999')\n    assert not is_ip_address('192.168.0.0/24')\n    assert not is_ip_address('example.com')\n\ntest_is_ip_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "is_ipv4_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv4_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv4 address.\"\"\"\n    try:\n        IPv4Address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ipv4_address() ->None:\n    \"\"\"Test if strings are IPv4 addresses.\"\"\"\n    assert is_ipv4_address('192.168.0.1') is True\n    assert is_ipv4_address('8.8.8.8') is True\n    assert is_ipv4_address('192.168.0.999') is False\n    assert is_ipv4_address('192.168.0.0/24') is False\n    assert is_ipv4_address('example.com') is False\n\ntest_is_ipv4_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv4_address(address: str) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "is_ipv6_address", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ipv6_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IPv6 address.\"\"\"\n    try:\n        IPv6Address(address)\n    except ValueError:\n        return False\n    return True", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_ipv6_address() ->None:\n    \"\"\"Test if strings are IPv6 addresses.\"\"\"\n    assert is_ipv6_address('::1') is True\n    assert is_ipv6_address('8.8.8.8') is False\n    assert is_ipv6_address('8.8.8.8') is False\n\ntest_is_ipv6_address()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ipv6_address(address: str) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "is_host_valid", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\ndef is_host_valid(host: str) ->bool:\n    \"\"\"Check if a given string is an IP address or valid hostname.\"\"\"\n    if is_ip_address(host):\n        return True\n    if len(host) > 255:\n        return False\n    if re.match('^[0-9\\\\.]+$', host):\n        return False\n    if host.endswith('.'):\n        host = host[:-1]\n    allowed = re.compile('(?!-)[A-Z\\\\d\\\\-]{1,63}(?<!-)$', re.IGNORECASE)\n    return all(allowed.match(x) for x in host.split('.'))", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_is_valid_host() ->None:\n    \"\"\"Test if strings are IPv6 addresses.\"\"\"\n    assert is_host_valid('::1')\n    assert is_host_valid('::ffff:127.0.0.0')\n    assert is_host_valid('2001:0db8:85a3:0000:0000:8a2e:0370:7334'\n        )\n    assert is_host_valid('8.8.8.8')\n    assert is_host_valid('local')\n    assert is_host_valid('host-host')\n    assert is_host_valid('example.com')\n    assert is_host_valid('example.com.')\n    assert is_host_valid('Example123.com')\n    assert not is_host_valid('')\n    assert not is_host_valid('192.168.0.1:8080')\n    assert not is_host_valid('192.168.0.999')\n    assert not is_host_valid('2001:hb8::1:0:0:1')\n    assert not is_host_valid('-host-host')\n    assert not is_host_valid('host-host-')\n    assert not is_host_valid('host_host')\n    assert not is_host_valid('example.com/path')\n    assert not is_host_valid('example.com:8080')\n    assert not is_host_valid('verylonghostname' * 4)\n    assert not is_host_valid('verydeepdomain.' * 18)\n\ntest_is_valid_host()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef is_ip_address(address: str) ->bool:\n    \"\"\"Check if a given string is an IP address.\"\"\"\n    try:\n        ip_address(address)\n    except ValueError:\n        return False\n    return True\n\n\ndef is_host_valid(host: str) ->bool: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "normalize_url", "method_path": "../srcdata/System/core/homeassistant/util/network.py", "response": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\ndef normalize_url(address: str) ->str:\n    \"\"\"Normalize a given URL.\"\"\"\n    url = yarl.URL(address.rstrip('/'))\n    if url.is_absolute() and url.is_default_port():\n        return str(url.with_port(None))\n    return str(url)", "test_code_list": [{"test_code": "from ipaddress import ip_address\ndef test_normalize_url() ->None:\n    \"\"\"Test the normalizing of URLs.\"\"\"\n    assert normalize_url('http://example.com'\n        ) == 'http://example.com'\n    assert normalize_url('https://example.com'\n        ) == 'https://example.com'\n    assert normalize_url('https://example.com/'\n        ) == 'https://example.com'\n    assert normalize_url('https://example.com:443'\n        ) == 'https://example.com'\n    assert normalize_url('http://example.com:80'\n        ) == 'http://example.com'\n    assert normalize_url('https://example.com:80'\n        ) == 'https://example.com:80'\n    assert normalize_url('http://example.com:443'\n        ) == 'http://example.com:443'\n    assert normalize_url('https://example.com:443/test/'\n        ) == 'https://example.com/test'\n    assert normalize_url('/test/') == '/test'\n\ntest_normalize_url()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_network.py"}], "method_code_mask": "from __future__ import annotations\nfrom ipaddress import IPv4Address\nfrom ipaddress import IPv6Address\nfrom ipaddress import ip_address\nfrom ipaddress import ip_network\nimport re\nimport yarl\n\n\ndef normalize_url(address: str) ->str: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "serialize_response", "method_path": "../srcdata/System/core/homeassistant/util/aiohttp.py", "response": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\ndef serialize_response(response: web.Response) ->dict[str, Any]:\n    \"\"\"Serialize an aiohttp response to a dictionary.\"\"\"\n    if (body := response.body) is None:\n        body_decoded = None\n    elif isinstance(body, payload.StringPayload):\n        body_decoded = body._value.decode(body.encoding)\n    elif isinstance(body, bytes):\n        body_decoded = body.decode(response.charset or 'utf-8')\n    else:\n        raise TypeError('Unknown payload encoding')\n    return {'status': response.status, 'body': body_decoded, 'headers':\n        dict(response.headers)}", "test_code_list": [{"test_code": "from aiohttp import web\ndef test_serialize_text() ->None:\n    \"\"\"Test serializing a text response.\"\"\"\n    response = web.Response(status=201, text='Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {'Content-Type': 'text/plain; charset=utf-8'}}\n\ntest_serialize_text()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_str() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body='Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {'Content-Type': 'text/plain; charset=utf-8'}}\n\ntest_serialize_body_str()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_None() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body=None)\n    assert serialize_response(response) == {'status': 201, 'body':\n        None, 'headers': {}}\n\ntest_serialize_body_None()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_body_bytes() ->None:\n    \"\"\"Test serializing a response with a str as body.\"\"\"\n    response = web.Response(status=201, body=b'Hello')\n    assert serialize_response(response) == {'status': 201, 'body':\n        'Hello', 'headers': {}}\n\ntest_serialize_body_bytes()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}, {"test_code": "from aiohttp import web\ndef test_serialize_json() ->None:\n    \"\"\"Test serializing a JSON response.\"\"\"\n    response = web.json_response({'how': 'what'})\n    assert serialize_response(response) == {'status': 200, 'body':\n        '{\"how\": \"what\"}', 'headers': {'Content-Type':\n        'application/json; charset=utf-8'}}\n\ntest_serialize_json()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_aiohttp.py"}], "method_code_mask": "from __future__ import annotations\nfrom http import HTTPStatus\nimport io\nfrom typing import Any\nfrom urllib.parse import parse_qsl\nfrom aiohttp import payload\nfrom aiohttp import web\nfrom aiohttp.typedefs import JSONDecoder\nfrom multidict import CIMultiDict\nfrom multidict import MultiDict\n\n\ndef serialize_response(response: web.Response) ->dict[str, Any]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "chunked_or_all", "method_path": "../srcdata/System/core/homeassistant/util/collection.py", "response": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]:\n    \"\"\"Break *collection* into iterables of length *n*.\n    Returns the collection if its length is less than *n*.\n    Unlike chunked, this function requires a collection so it can\n    determine the length of the collection and return the collection\n    if it is less than *n*.\n    \"\"\"\n    if len(iterable) <= chunked_num:\n        return iterable,\n    return chunked(iterable, chunked_num)", "test_code_list": [{"test_code": "def test_chunked_or_all() ->None:\n    \"\"\"Test chunked_or_all can iterate chunk sizes larger than the passed in collection.\"\"\"\n    all_items = []\n    incoming = 1, 2, 3, 4\n    for chunk in chunked_or_all(incoming, 2):\n        assert len(chunk) == 2\n        all_items.extend(chunk)\n    assert all_items == [1, 2, 3, 4]\n    all_items = []\n    incoming = 1, 2, 3, 4\n    for chunk in chunked_or_all(incoming, 5):\n        assert len(chunk) == 4\n        assert chunk is incoming\n        all_items.extend(chunk)\n    assert all_items == [1, 2, 3, 4]\n\ntest_chunked_or_all()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_collection.py"}], "method_code_mask": "from collections.abc import Collection\nfrom collections.abc import Iterable\nfrom functools import partial\nfrom itertools import islice\nfrom typing import Any\n\n\ndef take(take_num: int, iterable: Iterable) ->list[Any]:\n    \"\"\"Return first n items of the iterable as a list.\n\n    From itertools recipes\n    \"\"\"\n    return list(islice(iterable, take_num))\n\n\ndef chunked(iterable: Iterable, chunked_num: int) ->Iterable[Any]:\n    \"\"\"Break *iterable* into lists of length *n*.\n    From more-itertools\n    \"\"\"\n    return iter(partial(take, chunked_num, iter(iterable)), [])\n\n\ndef chunked_or_all(iterable: Collection[Any], chunked_num: int) ->Iterable[Any\n    ]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_hsv_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]:\n    \"\"\"Convert an hsv color into its rgb representation.\n\n    Hue is scaled 0-360\n    Sat is scaled 0-100\n    Val is scaled 0-100\n    \"\"\"\n    fRGB = colorsys.hsv_to_rgb(iH / 360, iS / 100, iV / 100)\n    return int(fRGB[0] * 255), int(fRGB[1] * 255), int(fRGB[2] * 255)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_hsv_to_RGB() ->None:\n    \"\"\"Test color_hsv_to_RGB.\"\"\"\n    assert color_hsv_to_RGB(0, 0, 0) == (0, 0, 0)\n    assert color_hsv_to_RGB(0, 0, 100) == (255, 255, 255)\n    assert color_hsv_to_RGB(240, 100, 100) == (0, 0, 255)\n    assert color_hsv_to_RGB(120, 100, 100) == (0, 255, 0)\n    assert color_hsv_to_RGB(0, 100, 100) == (255, 0, 0)\n\ntest_color_hsv_to_RGB()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsv_to_RGB(iH: float, iS: float, iV: float) ->tuple[int, int, int]: [\n    MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_hsb_to_RGB", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]:\n    \"\"\"Convert a hsb into its rgb representation.\"\"\"\n    if fS == 0.0:\n        fV = int(fB * 255)\n        return fV, fV, fV\n    r = g = b = 0\n    h = fH / 60\n    f = h - float(math.floor(h))\n    p = fB * (1 - fS)\n    q = fB * (1 - fS * f)\n    t = fB * (1 - fS * (1 - f))\n    if int(h) == 0:\n        r = int(fB * 255)\n        g = int(t * 255)\n        b = int(p * 255)\n    elif int(h) == 1:\n        r = int(q * 255)\n        g = int(fB * 255)\n        b = int(p * 255)\n    elif int(h) == 2:\n        r = int(p * 255)\n        g = int(fB * 255)\n        b = int(t * 255)\n    elif int(h) == 3:\n        r = int(p * 255)\n        g = int(q * 255)\n        b = int(fB * 255)\n    elif int(h) == 4:\n        r = int(t * 255)\n        g = int(p * 255)\n        b = int(fB * 255)\n    elif int(h) == 5:\n        r = int(fB * 255)\n        g = int(p * 255)\n        b = int(q * 255)\n    return r, g, b", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_hsb_to_RGB() ->None:\n    \"\"\"Test color_hsb_to_RGB.\"\"\"\n    assert color_hsb_to_RGB(0, 0, 0) == (0, 0, 0)\n    assert color_hsb_to_RGB(0, 0, 1.0) == (255, 255, 255)\n    assert color_hsb_to_RGB(240, 1.0, 1.0) == (0, 0, 255)\n    assert color_hsb_to_RGB(120, 1.0, 1.0) == (0, 255, 0)\n    assert color_hsb_to_RGB(0, 1.0, 1.0) == (255, 0, 0)\n\ntest_color_hsb_to_RGB()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_hsb_to_RGB(fH: float, fS: float, fB: float) ->tuple[int, int, int]: [\n    MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "rgb_hex_to_rgb_list", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]:\n    \"\"\"Return an RGB color value list from a hex color string.\"\"\"\n    return [int(hex_string[i:i + len(hex_string) // 3], 16) for i in range(\n        0, len(hex_string), len(hex_string) // 3)]", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_rgb_hex_to_rgb_list() ->None:\n    \"\"\"Test rgb_hex_to_rgb_list.\"\"\"\n    assert rgb_hex_to_rgb_list('ffffff') == [255, 255, 255]\n    assert rgb_hex_to_rgb_list('000000') == [0, 0, 0]\n    assert rgb_hex_to_rgb_list('ffffffff') == [255, 255, 255, 255]\n    assert rgb_hex_to_rgb_list('00000000') == [0, 0, 0, 0]\n    assert rgb_hex_to_rgb_list('3399ff') == [51, 153, 255]\n    assert rgb_hex_to_rgb_list('3399ff00') == [51, 153, 255, 0]\n\ntest_rgb_hex_to_rgb_list()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef rgb_hex_to_rgb_list(hex_string: str) ->list[int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_rgb_to_rgbw", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbw representation.\"\"\"\n    w = min(r, g, b)\n    rgbw = r - w, g - w, b - w, w\n    return match_max_scale((r, g, b), rgbw)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgb_to_rgbw() ->None:\n    \"\"\"Test color_rgb_to_rgbw.\"\"\"\n    assert color_rgb_to_rgbw(0, 0, 0) == (0, 0, 0, 0)\n    assert color_rgb_to_rgbw(255, 255, 255) == (0, 0, 0, 255)\n    assert color_rgb_to_rgbw(255, 0, 0) == (255, 0, 0, 0)\n    assert color_rgb_to_rgbw(0, 255, 0) == (0, 255, 0, 0)\n    assert color_rgb_to_rgbw(0, 0, 255) == (0, 0, 255, 0)\n    assert color_rgb_to_rgbw(255, 127, 0) == (255, 127, 0, 0)\n    assert color_rgb_to_rgbw(255, 127, 127) == (255, 0, 0, 253)\n    assert color_rgb_to_rgbw(127, 127, 127) == (0, 0, 0, 127)\n\ntest_color_rgb_to_rgbw()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgb_to_rgbw(r: int, g: int, b: int) ->tuple[int, int, int, int]: [M\n    ASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_rgbw_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbw color to an rgb representation.\"\"\"\n    rgb = r + w, g + w, b + w\n    return match_max_scale((r, g, b, w), rgb)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgbw_to_rgb() ->None:\n    \"\"\"Test color_rgbw_to_rgb.\"\"\"\n    assert color_rgbw_to_rgb(0, 0, 0, 0) == (0, 0, 0)\n    assert color_rgbw_to_rgb(0, 0, 0, 255) == (255, 255, 255)\n    assert color_rgbw_to_rgb(255, 0, 0, 0) == (255, 0, 0)\n    assert color_rgbw_to_rgb(0, 255, 0, 0) == (0, 255, 0)\n    assert color_rgbw_to_rgb(0, 0, 255, 0) == (0, 0, 255)\n    assert color_rgbw_to_rgb(255, 127, 0, 0) == (255, 127, 0)\n    assert color_rgbw_to_rgb(255, 0, 0, 253) == (255, 127, 127)\n    assert color_rgbw_to_rgb(0, 0, 0, 127) == (127, 127, 127)\n\ntest_color_rgbw_to_rgb()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef color_rgbw_to_rgb(r: int, g: int, b: int, w: int) ->tuple[int, int, int]: [\n    MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_xy_to_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_xy_to_temperature(x: float, y: float) ->int:\n    \"\"\"Convert an xy color to a color temperature in Kelvin.\n\n    Uses McCamy's approximation (https://doi.org/10.1002/col.5080170211),\n    close enough for uses between 2000 K and 10000 K.\n    \"\"\"\n    n = (x - 0.332) / (0.1858 - y)\n    CCT = 437 * n ** 3 + 3601 * n ** 2 + 6861 * n + 5517\n    return int(CCT)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_xy_to_temperature() ->None:\n    \"\"\"Test color_xy_to_temperature.\"\"\"\n    assert color_xy_to_temperature(0.5119, 0.4147) == 2136\n    assert color_xy_to_temperature(0.368, 0.3686) == 4302\n    assert color_xy_to_temperature(0.4448, 0.4066) == 2893\n    assert color_xy_to_temperature(0.1, 0.8) == 8645\n    assert color_xy_to_temperature(0.5, 0.4) == 2140\n\ntest_color_xy_to_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_xy_to_temperature(x: float, y: float) ->int: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_temperature_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_returns_same_value_for_any_two_temperatures_below_1000() ->None:\n    \"\"\"Function should return same value for 999 Kelvin and 0 Kelvin.\"\"\"\n    rgb_1 = color_temperature_to_rgb(999)\n    rgb_2 = color_temperature_to_rgb(0)\n    assert rgb_1 == rgb_2\n\ntest_returns_same_value_for_any_two_temperatures_below_1000()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_returns_same_value_for_any_two_temperatures_above_40000() ->None:\n    \"\"\"Function should return same value for 40001K and 999999K.\"\"\"\n    rgb_1 = color_temperature_to_rgb(40001)\n    rgb_2 = color_temperature_to_rgb(999999)\n    assert rgb_1 == rgb_2\n\ntest_returns_same_value_for_any_two_temperatures_above_40000()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_should_return_pure_white_at_6600() ->None:\n    \"\"\"Function should return red=255, blue=255, green=255 when given 6600K.\n\n    6600K is considered \"pure white\" light.\n    This is just a rough estimate because the formula itself is a \"best\n    guess\" approach.\n    \"\"\"\n    rgb = color_temperature_to_rgb(6600)\n    assert rgb == (255, 255, 255)\n\ntest_should_return_pure_white_at_6600()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_color_above_6600_should_have_more_blue_than_red_or_green() ->None:\n    \"\"\"Function should return a higher blue value for blue-ish light.\"\"\"\n    rgb = color_temperature_to_rgb(6700)\n    assert rgb[2] > rgb[1]\n    assert rgb[2] > rgb[0]\n\ntest_color_above_6600_should_have_more_blue_than_red_or_green()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}, {"test_code": "import math\nimport pytest\ndef test_color_below_6600_should_have_more_red_than_blue_or_green() ->None:\n    \"\"\"Function should return a higher red value for red-ish light.\"\"\"\n    rgb = color_temperature_to_rgb(6500)\n    assert rgb[0] > rgb[1]\n    assert rgb[0] > rgb[2]\n\ntest_color_below_6600_should_have_more_red_than_blue_or_green()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_rgb_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert an rgb color to an rgbww representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    mired_midpoint = min_mireds + mired_range / 2\n    color_temp_kelvin = color_temperature_mired_to_kelvin(mired_midpoint)\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = min(r / w_r if w_r else 0, g / w_g if w_g else 0, b / w_b if\n        w_b else 0)\n    rgb = r - w_r * white_level, g - w_g * white_level, b - w_b * white_level\n    rgbww = *rgb, round(white_level * 255), round(white_level * 255)\n    return match_max_scale((r, g, b), rgbww)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgb_to_rgbww() ->None:\n    \"\"\"Test color_rgb_to_rgbww conversions.\"\"\"\n    assert color_rgb_to_rgbww(255, 255, 255, 2702, 6493) == (0, \n        54, 98, 255, 255)\n    assert color_rgb_to_rgbww(255, 255, 255, 1000, 10000) == (\n        255, 255, 255, 0, 0)\n    assert color_rgb_to_rgbww(255, 255, 255, 1000, 1000000) == (\n        0, 118, 241, 255, 255)\n    assert color_rgb_to_rgbww(128, 128, 128, 2702, 6493) == (0, \n        27, 49, 128, 128)\n    assert color_rgb_to_rgbww(64, 64, 64, 2702, 6493) == (0, 14,\n        25, 64, 64)\n    assert color_rgb_to_rgbww(32, 64, 16, 2702, 6493) == (9, 64,\n        0, 38, 38)\n    assert color_rgb_to_rgbww(0, 0, 0, 2702, 6493) == (0, 0, 0, 0, 0\n        )\n    assert color_rgb_to_rgbww(0, 0, 0, 10000, 1000000) == (0, 0,\n        0, 0, 0)\n    assert color_rgb_to_rgbww(255, 255, 255, 200000, 1000000) == (\n        103, 69, 0, 255, 255)\n\ntest_color_rgb_to_rgbww()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgb_to_rgbww(r: int, g: int, b: int, min_kelvin: int, max_kelvin: int\n    ) ->tuple[int, int, int, int, int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_rgbww_to_rgb", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]:\n    \"\"\"Convert an rgbww color to an rgb representation.\"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    mired_range = max_mireds - min_mireds\n    try:\n        ct_ratio = ww / (cw + ww)\n    except ZeroDivisionError:\n        ct_ratio = 0.5\n    color_temp_mired = min_mireds + ct_ratio * mired_range\n    if color_temp_mired:\n        color_temp_kelvin = color_temperature_mired_to_kelvin(color_temp_mired)\n    else:\n        color_temp_kelvin = 0\n    w_r, w_g, w_b = color_temperature_to_rgb(color_temp_kelvin)\n    white_level = max(cw, ww) / 255\n    rgb = r + w_r * white_level, g + w_g * white_level, b + w_b * white_level\n    return match_max_scale((r, g, b, cw, ww), rgb)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_rgbww_to_rgb() ->None:\n    \"\"\"Test color_rgbww_to_rgb conversions.\"\"\"\n    assert color_rgbww_to_rgb(0, 54, 98, 255, 255, 2702, 6493) == (\n        255, 255, 255)\n    assert color_rgbww_to_rgb(255, 255, 255, 0, 0, 2702, 6493) == (\n        255, 255, 255)\n    assert color_rgbww_to_rgb(0, 118, 241, 255, 255, 2702, 6493\n        ) == (163, 204, 255)\n    assert color_rgbww_to_rgb(0, 27, 49, 128, 128, 2702, 6493) == (\n        128, 128, 128)\n    assert color_rgbww_to_rgb(0, 14, 25, 64, 64, 2702, 6493) == (\n        64, 64, 64)\n    assert color_rgbww_to_rgb(9, 64, 0, 38, 38, 2702, 6493) == (\n        32, 64, 16)\n    assert color_rgbww_to_rgb(0, 0, 0, 0, 0, 2702, 6493) == (0, 0, 0\n        )\n    assert color_rgbww_to_rgb(103, 69, 0, 255, 255, 2702, 6535) == (\n        255, 193, 112)\n\ntest_color_rgbww_to_rgb()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef match_max_scale(input_colors: tuple[int, ...], output_colors: tuple[\n    float, ...]) ->tuple[int, ...]:\n    \"\"\"Match the maximum value of the output to the input.\"\"\"\n    max_in = max(input_colors)\n    max_out = max(output_colors)\n    if max_out == 0:\n        factor = 0.0\n    else:\n        factor = max_in / max_out\n    return tuple(int(round(i * factor)) for i in output_colors)\n\n\ndef _get_blue(temperature: float) ->float:\n    \"\"\"Get the blue component of the given color temperature in RGB space.\"\"\"\n    if temperature >= 66:\n        return 255\n    if temperature <= 19:\n        return 0\n    blue = 138.5177312231 * math.log(temperature - 10) - 305.0447927307\n    return _clamp(blue)\n\n\ndef _clamp(color_component: float, minimum: float=0, maximum: float=255\n    ) ->float:\n    \"\"\"Clamp the given color component value between the given min and max values.\n    The range defined by the minimum and maximum values is inclusive, i.e. given a\n    color_component of 0 and a minimum of 10, the returned value is 10.\n    \"\"\"\n    color_component_out = max(color_component, minimum)\n    return min(color_component_out, maximum)\n\n\ndef _get_green(temperature: float) ->float:\n    \"\"\"Get the green component of the given color temp in RGB space.\"\"\"\n    if temperature <= 66:\n        green = 99.4708025861 * math.log(temperature) - 161.1195681661\n    else:\n        green = 288.1221695283 * math.pow(temperature - 60, -0.0755148492)\n    return _clamp(green)\n\n\ndef _get_red(temperature: float) ->float:\n    \"\"\"Get the red component of the temperature in RGB space.\"\"\"\n    if temperature <= 66:\n        return 255\n    tmp_red = 329.698727446 * math.pow(temperature - 60, -0.1332047592)\n    return _clamp(tmp_red)\n\n\ndef color_temperature_to_rgb(color_temperature_kelvin: float) ->tuple[float,\n    float, float]:\n    \"\"\"Return an RGB color from a color temperature in Kelvin.\n    This is a rough approximation based on the formula provided by T. Helland\n    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\n    \"\"\"\n    if color_temperature_kelvin < 1000:\n        color_temperature_kelvin = 1000\n    elif color_temperature_kelvin > 40000:\n        color_temperature_kelvin = 40000\n    tmp_internal = color_temperature_kelvin / 100.0\n    red = _get_red(tmp_internal)\n    green = _get_green(tmp_internal)\n    blue = _get_blue(tmp_internal)\n    return red, green, blue\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_rgbww_to_rgb(r: int, g: int, b: int, cw: int, ww: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int, int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "color_temperature_to_rgbww", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]:\n    \"\"\"Convert color temperature in kelvin to rgbcw.\n    Returns a (r, g, b, cw, ww) tuple.\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    temperature = color_temperature_kelvin_to_mired(temperature)\n    mired_range = max_mireds - min_mireds\n    cold = (max_mireds - temperature) / mired_range * brightness\n    warm = brightness - cold\n    return 0, 0, 0, round(cold), round(warm)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_color_temperature_to_rgbww() ->None:\n    \"\"\"Test color temp to warm, cold conversion.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert color_temperature_to_rgbww(6535, 255, 2000, 6535) == (\n        0, 0, 0, 255, 0)\n    assert color_temperature_to_rgbww(6535, 128, 2000, 6535) == (\n        0, 0, 0, 128, 0)\n    assert color_temperature_to_rgbww(2000, 255, 2000, 6535) == (\n        0, 0, 0, 0, 255)\n    assert color_temperature_to_rgbww(2000, 128, 2000, 6535) == (\n        0, 0, 0, 0, 128)\n    assert color_temperature_to_rgbww(2881, 255, 2000, 6535) == (\n        0, 0, 0, 112, 143)\n    assert color_temperature_to_rgbww(2881, 128, 2000, 6535) == (\n        0, 0, 0, 56, 72)\n\ntest_color_temperature_to_rgbww()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef color_temperature_to_rgbww(temperature: int, brightness: int,\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int, int, int, int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "rgbww_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert rgbcw to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    _, _, _, cold, warm = rgbww\n    return _white_levels_to_color_temperature(cold, warm, min_kelvin,\n        max_kelvin)", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_rgbww_to_color_temperature() ->None:\n    \"\"\"Test rgbww conversion to color temp.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert rgbww_to_color_temperature((0, 0, 0, 255, 0), 2000, 6535\n        ) == (6535, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 128, 0), 2000, 6535\n        ) == (6535, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 255), 2000, 6535\n        ) == (2000, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 128), 2000, 6535\n        ) == (2000, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 112, 143), 2000,\n        6535) == (2876, 255)\n    assert rgbww_to_color_temperature((0, 0, 0, 56, 72), 2000, 6535\n        ) == (2872, 128)\n    assert rgbww_to_color_temperature((0, 0, 0, 0, 0), 2000, 6535\n        ) == (2000, 0)\n\ntest_rgbww_to_color_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))\n\n\ndef rgbww_to_color_temperature(rgbww: tuple[int, int, int, int, int],\n    min_kelvin: int, max_kelvin: int) ->tuple[int, int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "_white_levels_to_color_temperature", "method_path": "../srcdata/System/core/homeassistant/util/color.py", "response": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]:\n    \"\"\"Convert whites to color temperature in kelvin.\n    Returns a tuple (color_temperature, brightness).\n    \"\"\"\n    max_mireds = color_temperature_kelvin_to_mired(min_kelvin)\n    min_mireds = color_temperature_kelvin_to_mired(max_kelvin)\n    brightness = warm / 255 + cold / 255\n    if brightness == 0:\n        return min_kelvin, 0\n    return round(color_temperature_mired_to_kelvin(cold / 255 / brightness *\n        (min_mireds - max_mireds) + max_mireds)), min(255, round(brightness *\n        255))", "test_code_list": [{"test_code": "import math\nimport pytest\ndef test_white_levels_to_color_temperature() ->None:\n    \"\"\"Test warm, cold conversion to color temp.\n\n    Temperature values must be in mireds\n    Home Assistant uses rgbcw for rgbww\n    \"\"\"\n    assert _white_levels_to_color_temperature(255, 0, 2000, 6535\n        ) == (6535, 255)\n    assert _white_levels_to_color_temperature(128, 0, 2000, 6535\n        ) == (6535, 128)\n    assert _white_levels_to_color_temperature(0, 255, 2000, 6535\n        ) == (2000, 255)\n    assert _white_levels_to_color_temperature(0, 128, 2000, 6535\n        ) == (2000, 128)\n    assert _white_levels_to_color_temperature(112, 143, 2000, 6535\n        ) == (2876, 255)\n    assert _white_levels_to_color_temperature(56, 72, 2000, 6535\n        ) == (2872, 128)\n    assert _white_levels_to_color_temperature(0, 0, 2000, 6535) == (\n        2000, 0)\n\ntest_white_levels_to_color_temperature()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_color.py"}], "method_code_mask": "from __future__ import annotations\nimport colorsys\nimport math\nfrom typing import NamedTuple\nimport attr\n\n\ndef color_temperature_mired_to_kelvin(mired_temperature: float) ->int:\n    \"\"\"Convert absolute mired shift to degrees kelvin.\"\"\"\n    return math.floor(1000000 / mired_temperature)\n\n\ndef color_temperature_kelvin_to_mired(kelvin_temperature: float) ->int:\n    \"\"\"Convert degrees kelvin to mired shift.\"\"\"\n    return math.floor(1000000 / kelvin_temperature)\n\n\ndef _white_levels_to_color_temperature(cold: int, warm: int, min_kelvin:\n    int, max_kelvin: int) ->tuple[int, int]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_distance_to_same_place() ->None:\n    \"\"\"Test getting the distance.\"\"\"\n    meters = distance(COORDINATES_PARIS[0], COORDINATES_PARIS\n        [1], COORDINATES_PARIS[0], COORDINATES_PARIS[1])\n    assert meters == 0\ntest_get_distance_to_same_place()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "distance", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None):\n    \"\"\"Calculate the distance in meters between two points.\n    Async friendly.\n    \"\"\"\n    if lat1 is None or lon1 is None:\n        return None\n    result = vincenty((lat1, lon1), (lat2, lon2))\n    if result is None:\n        return None\n    return result * 1000", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nDISTANCE_KM = 5846.39\nCOORDINATES_NEW_YORK = 40.73061, -73.935242\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_distance() ->None:\n    \"\"\"Test getting the distance.\"\"\"\n    meters = distance(COORDINATES_PARIS[0], COORDINATES_PARIS\n        [1], COORDINATES_NEW_YORK[0], COORDINATES_NEW_YORK[1])\n    assert meters / 1000 - DISTANCE_KM < 0.01\ntest_get_distance()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 - \n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)\n\n\n@lru_cache\ndef distance(lat1: (float | None), lon1: (float | None), lat2: float, lon2:\n    float) ->(float | None): [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "vincenty", "method_path": "../srcdata/System/core/homeassistant/util/location.py", "response": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None):\n    \"\"\"Vincenty formula (inverse method) to calculate the distance.\n    Result in kilometers or miles between two points on the surface of a\n    spheroid.\n    Async friendly.\n    \"\"\"\n    if point1[0] == point2[0] and point1[1] == point2[1]:\n        return 0.0\n    U1 = math.atan((1 - FLATTENING) * math.tan(math.radians(point1[0])))\n    U2 = math.atan((1 - FLATTENING) * math.tan(math.radians(point2[0])))\n    L = math.radians(point2[1] - point1[1])\n    Lambda = L\n    sinU1 = math.sin(U1)\n    cosU1 = math.cos(U1)\n    sinU2 = math.sin(U2)\n    cosU2 = math.cos(U2)\n    for _ in range(MAX_ITERATIONS):\n        sinLambda = math.sin(Lambda)\n        cosLambda = math.cos(Lambda)\n        sinSigma = math.sqrt((cosU2 * sinLambda) ** 2 + (cosU1 * sinU2 -\n            sinU1 * cosU2 * cosLambda) ** 2)\n        if sinSigma == 0.0:\n            return 0.0\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n        sigma = math.atan2(sinSigma, cosSigma)\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n        cosSqAlpha = 1 - sinAlpha ** 2\n        try:\n            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha\n        except ZeroDivisionError:\n            cos2SigmaM = 0\n        C = FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 *\n            cosSqAlpha))\n        LambdaPrev = Lambda\n        Lambda = L + (1 - C) * FLATTENING * sinAlpha * (sigma + C *\n            sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM ** 2))\n            )\n        if abs(Lambda - LambdaPrev) < CONVERGENCE_THRESHOLD:\n            break\n    else:\n        return None\n    uSq = cosSqAlpha * (AXIS_A ** 2 - AXIS_B ** 2) / AXIS_B ** 2\n    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))\n    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))\n    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 *\n        cos2SigmaM ** 2) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma ** 2) *\n        (-3 + 4 * cos2SigmaM ** 2)))\n    s = AXIS_B * A * (sigma - deltaSigma)\n    s /= 1000\n    if miles:\n        s *= MILES_PER_KILOMETER\n    return round(s, 6)", "test_code_list": [{"test_code": "from unittest.mock import Mock\nfrom unittest.mock import patch\nimport aiohttp\nimport pytest\nDISTANCE_KM = 5846.39\nCOORDINATES_NEW_YORK = 40.73061, -73.935242\nCOORDINATES_PARIS = 48.864716, 2.349014\ndef test_get_kilometers() ->None:\n    \"\"\"Test getting the distance between given coordinates in km.\"\"\"\n    kilometers = vincenty(COORDINATES_PARIS, COORDINATES_NEW_YORK\n        )\n    assert round(kilometers, 2) == DISTANCE_KM\ntest_get_kilometers()", "code_start": "", "test_path": "../srcdata/System/core/tests/util/test_location.py"}], "method_code_mask": "from __future__ import annotations\nfrom functools import lru_cache\nimport math\nfrom typing import Any\nfrom typing import NamedTuple\nimport aiohttp\nAXIS_B = 6356752.314245\nAXIS_A = 6378137\nCONVERGENCE_THRESHOLD = 1e-12\nMAX_ITERATIONS = 200\nFLATTENING = 1 / 298.257223563\n\n\ndef vincenty(point1: tuple[float, float], point2: tuple[float, float],\n    miles: bool=False) ->(float | None): [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "recursive_flatten", "method_path": "../srcdata/System/core/homeassistant/helpers/translation.py", "response": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]:\n    \"\"\"Return a flattened representation of dict data.\"\"\"\n    output: dict[str, str] = {}\n    for key, value in data.items():\n        if isinstance(value, dict):\n            output.update(recursive_flatten(f'{prefix}{key}.', value))\n        else:\n            output[f'{prefix}{key}'] = value\n    return output", "test_code_list": [{"test_code": "import asyncio\nimport pathlib\nfrom typing import Any\nfrom unittest.mock import Mock\nfrom unittest.mock import call\nfrom unittest.mock import patch\nimport pytest\ndef test_recursive_flatten() ->None:\n    \"\"\"Test the flatten function.\"\"\"\n    data = {'parent1': {'child1': 'data1', 'child2': 'data2'}, 'parent2':\n        'data3'}\n    flattened = recursive_flatten('prefix.', data)\n    assert flattened == {'prefix.parent1.child1': 'data1',\n        'prefix.parent1.child2': 'data2', 'prefix.parent2': 'data3'}\n\ntest_recursive_flatten()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_translation.py"}], "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom collections.abc import Mapping\nfrom contextlib import suppress\nfrom dataclasses import dataclass\nimport logging\nimport pathlib\nimport string\nfrom typing import Any\n\n\ndef recursive_flatten(prefix: str, data: dict[str, dict[str, Any] | str]\n    ) ->dict[str, str]: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "icon_for_signal_level", "method_path": "../srcdata/System/core/homeassistant/helpers/icon.py", "response": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str:\n    \"\"\"Return a signal icon valid identifier.\"\"\"\n    if signal_level is None or signal_level == 0:\n        return 'mdi:signal-cellular-outline'\n    if signal_level > 70:\n        return 'mdi:signal-cellular-3'\n    if signal_level > 30:\n        return 'mdi:signal-cellular-2'\n    return 'mdi:signal-cellular-1'", "test_code_list": [{"test_code": "import pathlib\nfrom unittest.mock import Mock\nfrom unittest.mock import patch\nimport pytest\ndef test_signal_icon() ->None:\n    \"\"\"Test icon generator for signal sensor.\"\"\"\n    assert icon_for_signal_level(None) == 'mdi:signal-cellular-outline'\n    assert icon_for_signal_level(0) == 'mdi:signal-cellular-outline'\n    assert icon_for_signal_level(5) == 'mdi:signal-cellular-1'\n    assert icon_for_signal_level(40) == 'mdi:signal-cellular-2'\n    assert icon_for_signal_level(80) == 'mdi:signal-cellular-3'\n    assert icon_for_signal_level(100) == 'mdi:signal-cellular-3'\n\ntest_signal_icon()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_icon.py"}], "method_code_mask": "from __future__ import annotations\nimport asyncio\nfrom collections.abc import Iterable\nfrom functools import lru_cache\nimport logging\nimport pathlib\nfrom typing import Any\n\n\ndef icon_for_signal_level(signal_level: (int | None)=None) ->str: [MASK]\n"}
{"model_name": "std", "repository": "core", "full_method_name": "generate_filter", "method_path": "../srcdata/System/core/homeassistant/helpers/entityfilter.py", "response": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or\n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]:\n    \"\"\"Return a function that will filter entities based on the args.\"\"\"\n    return _generate_filter_from_sets_and_pattern_lists(set(include_domains\n        ), set(include_entities), set(exclude_domains), set(\n        exclude_entities), _convert_globs_to_pattern(include_entity_globs),\n        _convert_globs_to_pattern(exclude_entity_globs))", "test_code_list": [{"test_code": "def test_no_filters_case_1() ->None:\n    \"\"\"If include and exclude not included, pass everything.\"\"\"\n    incl_dom = {}\n    incl_ent = {}\n    excl_dom = {}\n    excl_ent = {}\n    testfilter = generate_filter(incl_dom, incl_ent, excl_dom, excl_ent)\n    for value in ('sensor.test', 'sun.sun', 'light.test'):\n        assert testfilter(value)\n\ntest_no_filters_case_1()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_entityfilter.py"}, {"test_code": "def test_no_domain_case6() ->None:\n    \"\"\"Test case 6 - include and exclude specified, with no domains.\"\"\"\n    incl_dom = {}\n    incl_ent = {'binary_sensor.working'}\n    excl_dom = {}\n    excl_ent = {'light.ignoreme', 'sensor.notworking'}\n    testfilter = generate_filter(incl_dom, incl_ent, excl_dom, excl_ent)\n    assert testfilter('sensor.test') is False\n    assert testfilter('sensor.notworking') is False\n    assert testfilter('light.test') is False\n    assert testfilter('light.ignoreme') is False\n    assert testfilter('binary_sensor.working')\n    assert testfilter('binary_sensor.another') is False\n    assert testfilter('sun.sun') is False\n\ntest_no_domain_case6()\n", "code_start": "", "test_path": "../srcdata/System/core/tests/helpers/test_entityfilter.py"}], "method_code_mask": "from __future__ import annotations\nfrom collections.abc import Callable\nimport fnmatch\nfrom functools import lru_cache\nimport re\n\n\ndef _convert_globs_to_pattern(globs: (list[str] | None)) ->(re.Pattern[str] |\n    None):\n    \"\"\"Convert a list of globs to a re pattern list.\"\"\"\n    if globs is None:\n        return None\n    translated_patterns: list[str] = [pattern for glob in set(globs) if (\n        pattern := fnmatch.translate(glob))]\n    if not translated_patterns:\n        return None\n    inner = '|'.join(translated_patterns)\n    combined = f'(?:{inner})'\n    return re.compile(combined)\n\n\ndef _generate_filter_from_sets_and_pattern_lists(include_d: set[str],\n    include_e: set[str], exclude_d: set[str], exclude_e: set[str],\n    include_eg: (re.Pattern[str] | None), exclude_eg: (re.Pattern[str] | None)\n    ) ->Callable[[str], bool]:\n    \"\"\"Generate a filter from pre-comuted sets and pattern lists.\"\"\"\n    have_exclude = bool(exclude_e or exclude_d or exclude_eg)\n    have_include = bool(include_e or include_d or include_eg)\n    if not have_include and not have_exclude:\n        return lambda entity_id: True\n    if have_include and not have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_included(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches inclusion filters.\"\"\"\n            return entity_id in include_e or split_entity_id(entity_id)[0\n                ] in include_d or bool(include_eg and include_eg.match(\n                entity_id))\n        return entity_included\n    if not have_include and have_exclude:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_not_excluded(entity_id: str) ->bool:\n            \"\"\"Return true if entity matches exclusion filters.\"\"\"\n            return not (entity_id in exclude_e or split_entity_id(entity_id\n                )[0] in exclude_d or exclude_eg and exclude_eg.match(entity_id)\n                )\n        return entity_not_excluded\n    if include_d or include_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4a(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4a.\"\"\"\n            return entity_id in include_e or entity_id not in exclude_e and (\n                bool(include_eg and include_eg.match(entity_id)) or \n                split_entity_id(entity_id)[0] in include_d and not (\n                exclude_eg and exclude_eg.match(entity_id)))\n        return entity_filter_4a\n    if exclude_d or exclude_eg:\n\n        @lru_cache(maxsize=MAX_EXPECTED_ENTITY_IDS)\n        def entity_filter_4b(entity_id: str) ->bool:\n            \"\"\"Return filter function for case 4b.\"\"\"\n            domain = split_entity_id(entity_id)[0]\n            if domain in exclude_d or bool(exclude_eg and exclude_eg.match(\n                entity_id)):\n                return entity_id in include_e\n            return entity_id not in exclude_e\n        return entity_filter_4b\n    return lambda entity_id: entity_id in include_e\n\n\ndef generate_filter(include_domains: list[str], include_entities: list[str],\n    exclude_domains: list[str], exclude_entities: list[str],\n    include_entity_globs: (list[str] | None)=None, exclude_entity_globs: (\n    list[str] | None)=None) ->Callable[[str], bool]: [MASK]\n"}
