{"model_name": "std", "repository": "billiard", "full_method_name": "reset_signals", "method_path": "../srcdata/System/billiard/billiard/common.py", "response": "import os\nimport signal\nimport sys\nimport pickle\nfrom time import monotonic\nfrom io import BytesIO\ndef _shutdown_cleanup(signum, frame):\n    if _should_have_exited[0]:\n        os._exit(EX_SOFTWARE)\n    maybe_setsignal(signum, signal.SIG_DFL)\n    _should_have_exited[0] = True\n    sys.exit(-(256 - signum))\ndef reset_signals(handler=_shutdown_cleanup, full=False):\n    for sig in (TERMSIGS_FULL if full else TERMSIGS_DEFAULT):\n        num = signum(sig)\n        if num:\n            if _should_override_term_signal(sig, signal.getsignal(num)):\n                maybe_setsignal(num, handler)\n    for sig in TERMSIGS_IGNORE:\n        num = signum(sig)\n        if num:\n            maybe_setsignal(num, signal.SIG_IGN)", "test_code_list": [{"test_code": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\nclass test_reset_signals():\n    @contextmanager\n    def assert_context(self):\n        with termsigs(default, full):\n            with patch('signal.getsignal') as GET:\n                with patch('signal.signal') as SET:\n                    GET.return_value = get_returns\n                    SET.side_effect = set_effect\n                    reset_signals()\n                    GET.assert_has_calls([call(signo(sig)) for sig in default])\n                    yield GET, SET\n    \ntest_reset_signals().assert_context()\n", "code_start": "", "test_path": "../srcdata/System/billiard/t/unit/test_common.py"}], "method_code_mask": "import os\nimport signal\nimport sys\nimport pickle\nfrom time import monotonic\nfrom io import BytesIO\n\n\ndef _shutdown_cleanup(signum, frame):\n    if _should_have_exited[0]:\n        os._exit(EX_SOFTWARE)\n    maybe_setsignal(signum, signal.SIG_DFL)\n    _should_have_exited[0] = True\n    sys.exit(-(256 - signum))\n\n\ndef reset_signals(handler=_shutdown_cleanup, full=False): [MASK]\n"}
{"model_name": "std", "repository": "billiard", "full_method_name": "termsigs", "method_path": "../srcdata/System/billiard/t/unit/test_common.py", "response": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n@contextmanager\ndef termsigs(default, full):\n    from billiard import common\n    prev_def, common.TERMSIGS_DEFAULT = common.TERMSIGS_DEFAULT, default\n    prev_full, common.TERMSIGS_FULL = common.TERMSIGS_FULL, full\n    try:\n        yield\n    finally:\n        common.TERMSIGS_DEFAULT, common.TERMSIGS_FULL = prev_def, prev_full", "test_code_list": [{"test_code": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\nclass test_reset_signals():\n    @contextmanager\n    def assert_context(self):\n        with termsigs(default, full):\n            with patch('signal.getsignal') as GET:\n                with patch('signal.signal') as SET:\n                    GET.return_value = get_returns\n                    SET.side_effect = set_effect\n                    reset_signals()\n                    GET.assert_has_calls([call(signo(sig)) for sig in default])\n                    yield GET, SET\n    \ntest_reset_signals().assert_context()\n", "code_start": "", "test_path": "../srcdata/System/billiard/t/unit/test_common.py"}], "method_code_mask": "import os\nimport pytest\nimport signal\nfrom contextlib import contextmanager\nfrom time import time\nfrom unittest.mock import patch\nfrom unittest.mock import Mock\nfrom unittest.mock import call\n\n\n@contextmanager\ndef termsigs(default, full): [MASK]\n"}
