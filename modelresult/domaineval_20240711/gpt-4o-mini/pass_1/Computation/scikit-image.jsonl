{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "expected_warnings", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/_warnings.py", "response": "from contextlib import contextmanager\nimport sys\nimport warnings\nimport re\nimport functools\nimport os\nimport inspect\n\n@contextmanager\ndef expected_warnings(matching):\n    if matching is None:\n        yield\n        return\n\n    # Determine the strictness of warning checking\n    strict = os.getenv('SKIMAGE_TEST_STRICT_WARNINGS', 'False').lower() == 'true'\n    \n    # Prepare to collect warnings\n    collected_warnings = []\n\n    # Define a custom warning handler\n    def warning_handler(message, category, filename, lineno, file=None, line=None):\n        collected_warnings.append(str(message))\n\n    # Install the custom warning handler\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")  # Always trigger warnings\n        try:\n            yield\n        finally:\n            # Restore the default warning behavior\n            warnings.simplefilter(\"default\")\n\n            # Check collected warnings against expected patterns\n            remaining_patterns = [pattern for pattern in matching if not re.search(r'\\A\\Z', pattern)]\n            optional_patterns = [pattern for pattern in matching if re.search(r'\\A\\Z', pattern)]\n\n            # Check for unexpected warnings\n            if strict and len(w) > 0:\n                raise ValueError(f\"Unexpected warnings raised: {w}\")\n\n            # Check if all expected warnings are raised\n            for pattern in remaining_patterns:\n                if not any(re.search(pattern, str(warn.message)) for warn in w):\n                    raise ValueError(f\"Expected warning matching '{pattern}' not found.\")\n\n            # If strict, ensure no unexpected warnings\n            if strict and len(w) > len(remaining_patterns):\n                raise ValueError(\"Unexpected warnings raised.\")\n\n            # If optional patterns exist, check them\n            for pattern in optional_patterns:\n                if not any(re.search(pattern, str(warn.message)) for warn in w):\n                    collected_warnings.append(f\"Optional warning matching '{pattern}' not found.\")\n\n            if collected_warnings:\n                raise ValueError(\"Warnings did not match expected patterns: \" + \", \".join(collected_warnings))", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.draw import random_shapes\ndef test_returns_empty_labels_and_white_image_when_cannot_fit_shape():\n    with expected_warnings(['Could not fit']):\n        image, labels = random_shapes((10000, 10000), max_shapes=1,\n            min_size=10000, shape='circle')\n    assert len(labels) == 0\n    assert (image == 255).all()\n\ntest_returns_empty_labels_and_white_image_when_cannot_fit_shape()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/draw/tests/test_random_shapes.py"}, {"test_code": "import numpy as np\nimport itertools\nfrom skimage import img_as_float\nfrom skimage import img_as_float32\nfrom skimage import img_as_float64\nfrom skimage import img_as_int\nfrom skimage import img_as_uint\nfrom skimage import img_as_ubyte\nfrom skimage.util.dtype import _convert\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import parametrize\nfrom skimage.util.dtype import convert\ndef test_downcast():\n    x = np.arange(10).astype(np.uint64)\n    with expected_warnings(['Downcasting']):\n        y = img_as_int(x)\n    assert np.allclose(y, x.astype(np.int16))\n    assert y.dtype == np.int16, y.dtype\n\ntest_downcast()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_dtype.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_empty_image():\n    image = np.zeros((6, 6), dtype=bool)\n    with expected_warnings(['entirely zero']):\n        assert_array_equal(convex_hull_image(image), image)\n\ntest_empty_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=int)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image_holes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=np.uint8)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image_holes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom skimage import data\nfrom skimage import draw\nfrom skimage import img_as_float\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.feature import corner_fast\nfrom skimage.feature import corner_foerstner\nfrom skimage.feature import corner_harris\nfrom skimage.feature import corner_kitchen_rosenfeld\nfrom skimage.feature import corner_moravec\nfrom skimage.feature import corner_orientations\nfrom skimage.feature import corner_peaks\nfrom skimage.feature import corner_shi_tomasi\nfrom skimage.feature import corner_subpix\nfrom skimage.feature import hessian_matrix\nfrom skimage.feature import hessian_matrix_det\nfrom skimage.feature import hessian_matrix_eigvals\nfrom skimage.feature import peak_local_max\nfrom skimage.feature import shape_index\nfrom skimage.feature import structure_tensor\nfrom skimage.feature import structure_tensor_eigenvalues\nfrom skimage.morphology import cube\nfrom skimage.morphology import octagon\ndef test_shape_index():\n    square = np.zeros((5, 5))\n    square[2, 2] = 4\n    with expected_warnings(['divide by zero|\\\\A\\\\Z', 'invalid value|\\\\A\\\\Z']):\n        s = shape_index(square, sigma=0.1)\n    assert_almost_equal(s, np.array([[np.nan, np.nan, -0.5, np.nan, np.nan],\n        [np.nan, 0, np.nan, 0, np.nan], [-0.5, np.nan, -1, np.nan, -0.5], [\n        np.nan, 0, np.nan, 0, np.nan], [np.nan, np.nan, -0.5, np.nan, np.nan]])\n        )\n\ntest_shape_index()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_corner.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.feature import peak\n\nclass TestPeakLocalMax():\n\tdef test_threshold_rel_default(self):\n\t    image = np.ones((5, 5))\n\t    image[2, 2] = 1\n\t    assert len(peak.peak_local_max(image)) == 0\n\t    image[2, 2] = 2\n\t    assert_array_equal(peak.peak_local_max(image), [[2, 2]])\n\t    image[2, 2] = 0\n\t    with expected_warnings(['When min_distance < 1']):\n\t        assert len(peak.peak_local_max(image, min_distance=0)\n\t            ) == image.size - 1\n\t\nTestPeakLocalMax().test_threshold_rel_default()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_peak.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert 109 < threshold_otsu(img) < 111\n\ntest_otsu_astro_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert_almost_equal(threshold_multiotsu(img), [58, 149])\n\ntest_multiotsu_astro_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float(self):\n\t    image_uint = img_as_ubyte(data.camera()[:50, :50])\n\t    image_float = img_as_float(image_uint)\n\t    methods = ['autolevel', 'equalize', 'gradient', 'threshold',\n\t        'subtract_mean', 'enhance_contrast', 'pop']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_uint, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(image_float, disk(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float_3d(self):\n\t    np.random.seed(0)\n\t    volume_uint = np.random.randint(0, high=256, size=(10, 20, 30), dtype=\n\t        np.uint8)\n\t    volume_float = img_as_float(volume_uint)\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_uint, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(volume_float, ball(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed(self):\n\t    image = img_as_ubyte(data.camera())[::2, ::2]\n\t    image[image > 127] = 0\n\t    image_s = image.astype(np.int8)\n\t    image_u = img_as_ubyte(image_s)\n\t    assert_equal(image_u, img_as_ubyte(image_s))\n\t    methods = ['autolevel', 'equalize', 'gradient', 'maximum', 'mean',\n\t        'geometric_mean', 'subtract_mean', 'median', 'minimum', 'modal',\n\t        'enhance_contrast', 'pop', 'threshold']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_u, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(image_s, disk(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed_3d(self):\n\t    np.random.seed(0)\n\t    volume_s = np.random.randint(0, high=127, size=(10, 20, 30), dtype=np.int8)\n\t    volume_u = img_as_ubyte(volume_s)\n\t    assert_equal(volume_u, img_as_ubyte(volume_s))\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_u, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(volume_s, ball(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_entropy(self):\n\t    footprint = np.ones((16, 16), dtype=np.uint8)\n\t    data = np.tile(np.asarray([0, 1]), (100, 100)).astype(np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 1\n\t    data = np.tile(np.asarray([[0, 1], [2, 3]]), (10, 10)).astype(np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 2\n\t    data = np.tile(np.asarray([[0, 1, 2, 3], [4, 5, 6, 7]]), (10, 10)).astype(\n\t        np.uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 3\n\t    data = np.tile(np.reshape(np.arange(16), (4, 4)), (10, 10)).astype(np.uint8\n\t        )\n\t    assert np.max(rank.entropy(data, footprint)) == 4\n\t    data = np.tile(np.reshape(np.arange(64), (8, 8)), (10, 10)).astype(np.uint8\n\t        )\n\t    assert np.max(rank.entropy(data, footprint)) == 6\n\t    data = np.tile(np.reshape(np.arange(256), (16, 16)), (10, 10)).astype(np\n\t        .uint8)\n\t    assert np.max(rank.entropy(data, footprint)) == 8\n\t    footprint = np.ones((64, 64), dtype=np.uint8)\n\t    data = np.zeros((65, 65), dtype=np.uint16)\n\t    data[:64, :64] = np.reshape(np.arange(4096), (64, 64))\n\t    with expected_warnings(['Bad rank filter performance']):\n\t        assert np.max(rank.entropy(data, footprint)) == 12\n\t    with expected_warnings(['Bad rank filter performance']):\n\t        out = rank.entropy(data, np.ones((16, 16), dtype=np.uint8))\n\t    assert out.dtype == np.float64\n\t\nTestRank().test_entropy()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_16bit(self):\n\t    image = np.zeros((21, 21), dtype=np.uint16)\n\t    footprint = np.ones((3, 3), dtype=np.uint8)\n\t    for bitdepth in range(17):\n\t        value = 2 ** bitdepth - 1\n\t        image[10, 10] = value\n\t        if bitdepth >= 11:\n\t            expected = ['Bad rank filter performance']\n\t        else:\n\t            expected = []\n\t        with expected_warnings(expected):\n\t            assert rank.minimum(image, footprint)[10, 10] == 0\n\t            assert rank.maximum(image, footprint)[10, 10] == value\n\t            mean_val = rank.mean(image, footprint)[10, 10]\n\t            assert mean_val == int(value / footprint.size)\n\t\nTestRank().test_16bit()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_trivial_cases():\n    img = np.ones((10, 10))\n    labels = np.ones((10, 10))\n    with expected_warnings(['Returning provided labels']):\n        pass_through = random_walker(img, labels)\n    np.testing.assert_array_equal(pass_through, labels)\n    labels[:, :5] = 3\n    expected = np.concatenate(((labels == 1)[..., np.newaxis], (labels == 3\n        )[..., np.newaxis]), axis=2)\n    with expected_warnings(['Returning provided labels']):\n        test = random_walker(img, labels, return_full_prob=True)\n    np.testing.assert_array_equal(test, expected)\n    img = np.full((10, 10), False)\n    object_A = np.array([(6, 7), (6, 8), (7, 7), (7, 8)])\n    object_B = np.array([(3, 1), (4, 1), (2, 2), (3, 2), (4, 2), (2, 3), (3,\n        3)])\n    for x, y in np.vstack((object_A, object_B)):\n        img[y][x] = True\n    markers = np.zeros((10, 10), dtype=np.int8)\n    for x, y in object_B:\n        markers[y][x] = 1\n    markers[img == 0] = -1\n    with expected_warnings(['All unlabeled pixels are isolated']):\n        output_labels = random_walker(img, markers)\n    assert np.all(output_labels[markers == 1] == 1)\n    assert np.all(output_labels[markers == 0] == -1)\n    with expected_warnings(['All unlabeled pixels are isolated']):\n        test = random_walker(img, markers, return_full_prob=True)\n\ntest_trivial_cases()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_isolated_seeds():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 1\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask)\n    assert res[1, 1] == 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n\ntest_isolated_seeds()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_isolated_area():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 0\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask)\n    assert res[1, 1] == 0\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    assert res[0, 1, 1] == 0\n    assert res[1, 1, 1] == 0\n\ntest_isolated_area()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_prob_tol():\n    np.random.seed(0)\n    a = np.random.random((7, 7))\n    mask = -np.ones(a.shape)\n    mask[1, 1] = 1\n    mask[3:, 3:] = 0\n    mask[4, 4] = 2\n    mask[6, 6] = 1\n    with expected_warnings([\n        'The probability range is outside|scipy.sparse.linalg.cg']):\n        res = random_walker(a, mask, return_full_prob=True)\n    res = random_walker(a, mask, return_full_prob=True, beta=10)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n    res = random_walker(a, mask, return_full_prob=True, prob_tol=0.1)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n    res = random_walker(a, mask, return_full_prob=True, tol=1e-09)\n    assert res[0, 1, 1] == 1\n    assert res[1, 1, 1] == 0\n\ntest_prob_tol()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import arch32\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_array_less\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import xfail\nfrom skimage.measure import CircleModel\nfrom skimage.measure import EllipseModel\nfrom skimage.measure import LineModelND\nfrom skimage.measure import ransac\nfrom skimage.measure.fit import _dynamic_max_trials\nfrom skimage.transform import AffineTransform\ndef test_ransac_sample_duplicates():\n\n\n    class DummyModel:\n        \"\"\"Dummy model to check for duplicates.\"\"\"\n\n        def estimate(self, data):\n            assert_equal(np.unique(data).size, data.size)\n            return True\n\n        def residuals(self, data):\n            return np.ones(len(data), dtype=np.float64)\n    data = np.arange(4)\n    with expected_warnings(['No inliers found']):\n        ransac(data, DummyModel, min_samples=3, residual_threshold=0.0,\n            max_trials=10)\n\ntest_ransac_sample_duplicates()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_fit.py"}, {"test_code": "import numpy as np\nfrom skimage.restoration import unwrap_phase\nimport sys\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_almost_equal_nulp\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import skipif\nfrom skimage._shared._warnings import expected_warnings\ndef test_mask():\n    length = 100\n    ramps = [np.linspace(0, 4 * np.pi, length), np.linspace(0, 8 * np.pi,\n        length), np.linspace(0, 6 * np.pi, length)]\n    image = np.vstack(ramps)\n    mask_1d = np.ones((length,), dtype=bool)\n    mask_1d[0] = mask_1d[-1] = False\n    for i in range(len(ramps)):\n        mask = np.zeros(image.shape, dtype=bool)\n        mask |= mask_1d.reshape(1, -1)\n        mask[i, :] = False\n        image_wrapped = np.ma.array(np.angle(np.exp(1.0j * image)), mask=mask)\n        image_unwrapped = unwrap_phase(image_wrapped)\n        image_unwrapped -= image_unwrapped[0, 0]\n        assert_array_almost_equal_nulp(image_unwrapped[:, -1], image[i, -1])\n        assert_(np.ma.isMaskedArray(image_unwrapped))\n        with expected_warnings(['length 1 dimension']):\n            shape = (1,) + image_wrapped.shape\n            image_wrapped_3d = image_wrapped.reshape(shape)\n            image_unwrapped_3d = unwrap_phase(image_wrapped_3d)\n            image_unwrapped_3d -= image_unwrapped_3d[0, 0, 0]\n        assert_array_almost_equal_nulp(image_unwrapped_3d[:, :, -1], image[\n            i, -1])\n\ntest_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/restoration/tests/test_unwrap.py"}], "method_code_mask": "from contextlib import contextmanager\nimport sys\nimport warnings\nimport re\nimport functools\nimport os\nimport inspect\n\n\n@contextmanager\ndef expected_warnings(matching): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "regular_grid", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/_regular_grid.py", "response": "import numpy as np\n\n\ndef regular_grid(ar_shape, n_points):\n    # Calculate the number of dimensions\n    n_dims = len(ar_shape)\n    \n    # Calculate the number of points per dimension\n    points_per_dim = [min(ar_shape[dim], n_points) for dim in range(n_dims)]\n    \n    # Calculate the step size for each dimension\n    steps = [ar_shape[dim] // points_per_dim[dim] for dim in range(n_dims)]\n    \n    # Create slices for each dimension\n    slices = tuple(slice(0, ar_shape[dim], steps[dim]) for dim in range(n_dims))\n    \n    return slices", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_full():\n    ar = np.zeros((2, 2))\n    g = regular_grid(ar, 25)\n    assert_equal(g, [slice(None, None, None), slice(None, None, None)])\n    ar[g] = 1\n    assert_equal(ar.size, ar.sum())\n\ntest_regular_grid_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_2d_8():\n    ar = np.zeros((20, 40))\n    g = regular_grid(ar.shape, 8)\n    assert_equal(g, [slice(5.0, None, 10.0), slice(5.0, None, 10.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 8)\n\ntest_regular_grid_2d_8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_2d_32():\n    ar = np.zeros((20, 40))\n    g = regular_grid(ar.shape, 32)\n    assert_equal(g, [slice(2.0, None, 5.0), slice(2.0, None, 5.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 32)\n\ntest_regular_grid_2d_32()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}, {"test_code": "import numpy as np\nfrom skimage.util import regular_grid\nfrom skimage._shared.testing import assert_equal\ndef test_regular_grid_3d_8():\n    ar = np.zeros((3, 20, 40))\n    g = regular_grid(ar.shape, 8)\n    assert_equal(g, [slice(1.0, None, 3.0), slice(5.0, None, 10.0), slice(\n        5.0, None, 10.0)])\n    ar[g] = 1\n    assert_equal(ar.sum(), 8)\n\ntest_regular_grid_3d_8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_regular_grid.py"}], "method_code_mask": "import numpy as np\n\n\ndef regular_grid(ar_shape, n_points): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "invert", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/_invert.py", "response": "import numpy as np\n\n\ndef invert(image, signed_float=False):\n    if np.issubdtype(image.dtype, np.unsignedinteger):\n        # For unsigned integers, subtract from the maximum value of the dtype\n        max_value = np.iinfo(image.dtype).max\n        inverted = max_value - image\n    elif np.issubdtype(image.dtype, np.signedinteger):\n        # For signed integers, subtract from -1\n        inverted = -1 - image\n    elif np.issubdtype(image.dtype, np.floating):\n        if signed_float:\n            # For signed floats, subtract from 0\n            inverted = 0 - image\n        else:\n            # For unsigned floats, subtract from 1\n            inverted = 1 - image\n    else:\n        raise TypeError(\"Unsupported image data type.\")\n    \n    return inverted", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_bool():\n    dtype = 'bool'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_bool()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_uint8():\n    dtype = 'uint8'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_uint8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_int8():\n    dtype = 'int8'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    expected[0, :] = -1\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_int8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_signed():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image, signed_float=True)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_signed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_unsigned():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=True)\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[0, :] = upper_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_unsigned()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_roundtrip():\n    for t, limits in dtype_range.items():\n        image = np.array(limits, dtype=t)\n        expected = invert(invert(image))\n        assert_array_equal(image, expected)\n\ntest_invert_roundtrip()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_null_matrix():\n    a_black = np.zeros((3, 3)).astype(np.uint8)\n    a_white = invert(a_black)\n    zeros = np.zeros((3, 3))\n    ones = np.ones((3, 3))\n    assert_equal(meijering(a_black, black_ridges=True), zeros)\n    assert_equal(meijering(a_white, black_ridges=False), zeros)\n    assert_equal(sato(a_black, black_ridges=True, mode='reflect'), zeros)\n    assert_equal(sato(a_white, black_ridges=False, mode='reflect'), zeros)\n    assert_allclose(frangi(a_black, black_ridges=True), zeros, atol=0.001)\n    assert_allclose(frangi(a_white, black_ridges=False), zeros, atol=0.001)\n    assert_equal(hessian(a_black, black_ridges=False, mode='reflect'), ones)\n    assert_equal(hessian(a_white, black_ridges=True, mode='reflect'), ones)\n\ntest_2d_null_matrix()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_null_matrix():\n    a_black = np.zeros((3, 3, 5)).astype(np.uint8)\n    a_white = invert(a_black)\n    zeros = np.zeros((3, 3, 5))\n    ones = np.ones((3, 3, 5))\n    assert_allclose(meijering(a_black, black_ridges=True), zeros, atol=0.1)\n    assert_allclose(meijering(a_white, black_ridges=False), zeros, atol=0.1)\n    assert_equal(sato(a_black, black_ridges=True, mode='reflect'), zeros)\n    assert_equal(sato(a_white, black_ridges=False, mode='reflect'), zeros)\n    assert_allclose(frangi(a_black, black_ridges=True), zeros, atol=0.001)\n    assert_allclose(frangi(a_white, black_ridges=False), zeros, atol=0.001)\n    assert_equal(hessian(a_black, black_ridges=False, mode='reflect'), ones)\n    assert_equal(hessian(a_white, black_ridges=True, mode='reflect'), ones)\n\ntest_3d_null_matrix()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_energy_decrease():\n    a_black = np.zeros((5, 5)).astype(np.uint8)\n    a_black[2, 2] = 255\n    a_white = invert(a_black)\n    assert_array_less(meijering(a_black, black_ridges=True).std(), a_black.\n        std())\n    assert_array_less(meijering(a_white, black_ridges=False).std(), a_white\n        .std())\n    assert_array_less(sato(a_black, black_ridges=True, mode='reflect').std(\n        ), a_black.std())\n    assert_array_less(sato(a_white, black_ridges=False, mode='reflect').std\n        (), a_white.std())\n    assert_array_less(frangi(a_black, black_ridges=True).std(), a_black.std())\n    assert_array_less(frangi(a_white, black_ridges=False).std(), a_white.std())\n    assert_array_less(hessian(a_black, black_ridges=True, mode='reflect').\n        std(), a_black.std())\n    assert_array_less(hessian(a_white, black_ridges=False, mode='reflect').\n        std(), a_white.std())\n\ntest_2d_energy_decrease()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_energy_decrease():\n    a_black = np.zeros((5, 5, 5)).astype(np.uint8)\n    a_black[2, 2, 2] = 255\n    a_white = invert(a_black)\n    assert_array_less(meijering(a_black, black_ridges=True).std(), a_black.\n        std())\n    assert_array_less(meijering(a_white, black_ridges=False).std(), a_white\n        .std())\n    assert_array_less(sato(a_black, black_ridges=True, mode='reflect').std(\n        ), a_black.std())\n    assert_array_less(sato(a_white, black_ridges=False, mode='reflect').std\n        (), a_white.std())\n    assert_array_less(frangi(a_black, black_ridges=True).std(), a_black.std())\n    assert_array_less(frangi(a_white, black_ridges=False).std(), a_white.std())\n    assert_array_less(hessian(a_black, black_ridges=True, mode='reflect').\n        std(), a_black.std())\n    assert_array_less(hessian(a_white, black_ridges=False, mode='reflect').\n        std(), a_white.std())\n\ntest_3d_energy_decrease()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_linearity():\n    a_black = np.ones((3, 3)).astype(np.uint8)\n    a_white = invert(a_black)\n    assert_allclose(meijering(1 * a_black, black_ridges=True), meijering(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(meijering(1 * a_white, black_ridges=False), meijering(\n        10 * a_white, black_ridges=False), atol=0.001)\n    assert_allclose(sato(1 * a_black, black_ridges=True, mode='reflect'),\n        sato(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(sato(1 * a_white, black_ridges=False, mode='reflect'),\n        sato(10 * a_white, black_ridges=False, mode='reflect'), atol=0.001)\n    assert_allclose(frangi(1 * a_black, black_ridges=True), frangi(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(frangi(1 * a_white, black_ridges=False), frangi(10 *\n        a_white, black_ridges=False), atol=0.001)\n    assert_allclose(hessian(1 * a_black, black_ridges=True, mode='reflect'),\n        hessian(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(hessian(1 * a_white, black_ridges=False, mode='reflect'\n        ), hessian(10 * a_white, black_ridges=False, mode='reflect'), atol=\n        0.001)\n\ntest_2d_linearity()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_linearity():\n    a_black = np.ones((3, 3, 5)).astype(np.uint8)\n    a_white = invert(a_black)\n    assert_allclose(meijering(1 * a_black, black_ridges=True), meijering(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(meijering(1 * a_white, black_ridges=False), meijering(\n        10 * a_white, black_ridges=False), atol=0.001)\n    assert_allclose(sato(1 * a_black, black_ridges=True, mode='reflect'),\n        sato(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(sato(1 * a_white, black_ridges=False, mode='reflect'),\n        sato(10 * a_white, black_ridges=False, mode='reflect'), atol=0.001)\n    assert_allclose(frangi(1 * a_black, black_ridges=True), frangi(10 *\n        a_black, black_ridges=True), atol=0.001)\n    assert_allclose(frangi(1 * a_white, black_ridges=False), frangi(10 *\n        a_white, black_ridges=False), atol=0.001)\n    assert_allclose(hessian(1 * a_black, black_ridges=True, mode='reflect'),\n        hessian(10 * a_black, black_ridges=True, mode='reflect'), atol=0.001)\n    assert_allclose(hessian(1 * a_white, black_ridges=False, mode='reflect'\n        ), hessian(10 * a_white, black_ridges=False, mode='reflect'), atol=\n        0.001)\n\ntest_3d_linearity()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_white = invert(a_black)\n    np.zeros((100, 100))\n    ones = np.ones((100, 100))\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_2d_cropped_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_black = np.stack([a_black] * 5, axis=-1)\n    a_white = invert(a_black)\n    np.zeros(a_black.shape)\n    ones = np.ones(a_black.shape)\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_3d_cropped_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}], "method_code_mask": "import numpy as np\n\n\ndef invert(image, signed_float=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "dtype_limits", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/dtype.py", "response": "import warnings\nfrom warnings import warn\nimport numpy as np\n\n\ndef dtype_limits(image, clip_negative=False):\n    if not isinstance(image, np.ndarray):\n        raise ValueError(\"Input must be a numpy ndarray.\")\n    \n    dtype = image.dtype\n    \n    # Get the minimum and maximum values for the dtype\n    imin = np.iinfo(dtype).min if np.issubdtype(dtype, np.integer) else np.finfo(dtype).min\n    imax = np.iinfo(dtype).max if np.issubdtype(dtype, np.integer) else np.finfo(dtype).max\n    \n    # If clip_negative is True and the dtype allows negative values, set imin to 0\n    if clip_negative and imin < 0:\n        imin = 0\n    \n    return imin, imax", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_bool():\n    dtype = 'bool'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_bool()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_uint8():\n    dtype = 'uint8'\n    image = np.zeros((3, 3), dtype=dtype)\n    upper_dtype_limit = dtype_limits(image, clip_negative=False)[1]\n    image[1, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype) + upper_dtype_limit\n    expected[1, :] = 0\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_uint8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_int8():\n    dtype = 'int8'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    expected[0, :] = -1\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_int8()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_signed():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=False)\n    image[1, :] = lower_dtype_limit\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[2, :] = lower_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image, signed_float=True)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_signed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}, {"test_code": "import numpy as np\nfrom skimage import dtype_limits\nfrom skimage.util.dtype import dtype_range\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\ndef test_invert_float64_unsigned():\n    dtype = 'float64'\n    image = np.zeros((3, 3), dtype=dtype)\n    lower_dtype_limit, upper_dtype_limit = dtype_limits(image,\n        clip_negative=True)\n    image[2, :] = upper_dtype_limit\n    expected = np.zeros((3, 3), dtype=dtype)\n    expected[0, :] = upper_dtype_limit\n    expected[1, :] = upper_dtype_limit\n    result = invert(image)\n    assert_array_equal(expected, result)\n\ntest_invert_float64_unsigned()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_invert.py"}], "method_code_mask": "import warnings\nfrom warnings import warn\nimport numpy as np\n\n\ndef dtype_limits(image, clip_negative=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "slice_along_axes", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/_slice_along_axes.py", "response": "import numpy as np\n\ndef slice_along_axes(image, slices, axes=None, copy=False):\n    if axes is None:\n        axes = range(len(slices))\n    elif isinstance(axes, int):\n        axes = [axes]\n\n    # Create a list of slice objects for each axis\n    slice_objects = [slice(None)] * image.ndim\n    for ax, (start, end) in zip(axes, slices):\n        slice_objects[ax] = slice(start, end)\n\n    # Use the slice objects to slice the image\n    out = image[tuple(slice_objects)]\n\n    # Return a copy if requested\n    if copy:\n        return out.copy()\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\ndef test_copy():\n    data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    out_without_copy = slice_along_axes(data, [(0, 3)], axes=[1], copy=False)\n    out_copy = slice_along_axes(data, [(0, 3)], axes=[0], copy=True)\n    assert out_without_copy.base is data\n    assert out_copy.base is not data\n\ntest_copy()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_slice_along_axes.py"}], "method_code_mask": "def slice_along_axes(image, slices, axes=None, copy=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "apply_parallel", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/apply_parallel.py", "response": "import numpy\nfrom math import ceil\nimport dask.array as da\nfrom multiprocessing import cpu_count\n\n\ndef apply_parallel(function, array, chunks=None, depth=0, mode=None,\n    extra_arguments=(), extra_keywords=None, *, dtype=None, compute=None,\n    channel_axis=None):\n    \n    if extra_keywords is None:\n        extra_keywords = {}\n\n    # Determine the number of CPUs available\n    if chunks is None:\n        chunks = (cpu_count(),)  # Default to number of CPUs\n\n    # If the input is a Dask array, we need to handle it accordingly\n    if isinstance(array, da.Array):\n        # Split the array into chunks\n        array = array.rechunk(chunks)\n\n        # Apply the function in parallel\n        result = array.map_blocks(function, *extra_arguments, **extra_keywords, dtype=dtype)\n\n    else:\n        # For a NumPy array, we can split it manually\n        n = len(array)\n        chunk_size = ceil(n / chunks[0])\n        chunks = [array[i:i + chunk_size] for i in range(0, n, chunk_size)]\n\n        # Apply the function to each chunk\n        results = [function(chunk, *extra_arguments, **extra_keywords) for chunk in chunks]\n\n        # Combine the results back into a single array\n        result = numpy.concatenate(results)\n\n    # Handle the compute argument\n    if compute is None:\n        compute = isinstance(array, da.Array)\n\n    if compute:\n        return result.compute() if isinstance(result, da.Array) else result\n    else:\n        return result", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel():\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected1 = threshold_local(a, 3)\n    result1 = apply_parallel(threshold_local, a, chunks=(6, 6), depth=5,\n        extra_arguments=(3,), extra_keywords={'mode': 'reflect'})\n    assert_array_almost_equal(result1, expected1)\n\n    def wrapped_gauss(arr):\n        return gaussian(arr, sigma=1, mode='reflect')\n    expected2 = gaussian(a, sigma=1, mode='reflect')\n    result2 = apply_parallel(wrapped_gauss, a, chunks=(6, 6), depth=5)\n    assert_array_almost_equal(result2, expected2)\n    expected3 = gaussian(a, sigma=1, mode='reflect')\n    result3 = apply_parallel(wrapped_gauss, da.from_array(a, chunks=(6, 6)),\n        depth=5, compute=True)\n    assert isinstance(result3, np.ndarray)\n    assert_array_almost_equal(result3, expected3)\n\ntest_apply_parallel()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_lazy():\n    a = np.arange(144).reshape(12, 12).astype(float)\n    d = da.from_array(a, chunks=(6, 6))\n    expected1 = threshold_local(a, 3)\n    result1 = apply_parallel(threshold_local, a, chunks=(6, 6), depth=5,\n        extra_arguments=(3,), extra_keywords={'mode': 'reflect'}, compute=False\n        )\n    result2 = apply_parallel(threshold_local, d, depth=5, extra_arguments=(\n        3,), extra_keywords={'mode': 'reflect'})\n    assert isinstance(result1, da.Array)\n    assert_array_almost_equal(result1.compute(), expected1)\n    assert isinstance(result2, da.Array)\n    assert_array_almost_equal(result2.compute(), expected1)\n\ntest_apply_parallel_lazy()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_no_chunks():\n    a = np.ones(1 * 4 * 8 * 9).reshape(1, 4, 8, 9)\n\n    def add_42(arr):\n        return arr + 42\n    expected = add_42(a)\n    result = apply_parallel(add_42, a)\n    assert_array_almost_equal(result, expected)\n\ntest_no_chunks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_wrap():\n\n    def wrapped(arr):\n        return gaussian(arr, sigma=1, mode='wrap')\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected = gaussian(a, sigma=1, mode='wrap')\n    result = apply_parallel(wrapped, a, chunks=(6, 6), depth=5, mode='wrap')\n    assert_array_almost_equal(result, expected)\n\ntest_apply_parallel_wrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.filters import threshold_local\nfrom skimage.filters import gaussian\nfrom skimage.util.apply_parallel import apply_parallel\nimport pytest\ndef test_apply_parallel_nearest():\n\n    def wrapped(arr):\n        return gaussian(arr, sigma=1, mode='nearest')\n    a = np.arange(144).reshape(12, 12).astype(float)\n    expected = gaussian(a, sigma=1, mode='nearest')\n    result = apply_parallel(wrapped, a, chunks=(6, 6), depth={(0): 5, (1): \n        5}, mode='nearest')\n    assert_array_almost_equal(result, expected)\n\ntest_apply_parallel_nearest()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_apply_parallel.py"}], "method_code_mask": "import numpy\nfrom math import ceil\nimport dask.array as da\nfrom multiprocessing import cpu_count\n\n\ndef apply_parallel(function, array, chunks=None, depth=0, mode=None,\n    extra_arguments=(), extra_keywords=None, *, dtype=None, compute=None,\n    channel_axis=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "crop", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/arraycrop.py", "response": "import numpy as np\nfrom numbers import Integral\n\n\ndef crop(ar, crop_width, copy=False, order='K'):\n    # Convert input to numpy array if it's not already\n    ar = np.asarray(ar)\n\n    # Determine the number of dimensions in the array\n    ndim = ar.ndim\n\n    # Handle crop_width input\n    if isinstance(crop_width, Integral):\n        crop_width = [(crop_width, crop_width)] * ndim  # Same width for all dimensions\n    elif len(crop_width) == 1:\n        crop_width = [(crop_width[0], crop_width[0])] * ndim  # Single pair for all dimensions\n    elif len(crop_width) == ndim:\n        crop_width = [tuple(crop) if isinstance(crop, (list, tuple)) else (crop, crop) for crop in crop_width]\n    else:\n        raise ValueError(\"crop_width must be an integer, a single pair, or a sequence matching the number of dimensions.\")\n\n    # Create slices for cropping\n    slices = tuple(slice(crop[0], -crop[1] if crop[1] != 0 else None) for crop in crop_width)\n\n    # Crop the array\n    cropped = ar[slices]\n\n    # Return a copy if requested\n    if copy:\n        return np.array(cropped, order=order)\n    \n    return cropped", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_multi_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, ((1, 2), (2, 1)))\n    assert_array_equal(out[0], [7, 8])\n    assert_array_equal(out[-1], [32, 33])\n    assert_equal(out.shape, (6, 2))\n\ntest_multi_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_pair_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, (1, 2))\n    assert_array_equal(out[0], [6, 7])\n    assert_array_equal(out[-1], [31, 32])\n    assert_equal(out.shape, (6, 2))\n\ntest_pair_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_pair_tuple_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, ((1, 2),))\n    assert_array_equal(out[0], [6, 7])\n    assert_array_equal(out[-1], [31, 32])\n    assert_equal(out.shape, (6, 2))\n\ntest_pair_tuple_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_int_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, 1)\n    assert_array_equal(out[0], [6, 7, 8])\n    assert_array_equal(out[-1], [36, 37, 38])\n    assert_equal(out.shape, (7, 3))\n\ntest_int_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_int_tuple_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, (1,))\n    assert_array_equal(out[0], [6, 7, 8])\n    assert_array_equal(out[-1], [36, 37, 38])\n    assert_equal(out.shape, (7, 3))\n\ntest_int_tuple_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_copy_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out0 = crop(arr, 1, copy=True)\n    assert out0.flags.c_contiguous\n    out0[0, 0] = 100\n    assert not np.any(arr == 100)\n    assert not np.may_share_memory(arr, out0)\n    out1 = crop(arr, 1)\n    out1[0, 0] = 100\n    assert arr[1, 1] == 100\n    assert np.may_share_memory(arr, out1)\n\ntest_copy_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nfrom skimage.util import crop\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\ndef test_zero_crop():\n    arr = np.arange(45).reshape(9, 5)\n    out = crop(arr, 0)\n    assert out.shape == (9, 5)\n\ntest_zero_crop()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_arraycrop.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_2d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_white = invert(a_black)\n    np.zeros((100, 100))\n    ones = np.ones((100, 100))\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_2d_cropped_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom skimage import img_as_float\nfrom skimage.color import rgb2gray\nfrom skimage.data import camera\nfrom skimage.data import retina\nfrom skimage.filters import frangi\nfrom skimage.filters import hessian\nfrom skimage.filters import meijering\nfrom skimage.filters import sato\nfrom skimage.util import crop\nfrom skimage.util import invert\ndef test_3d_cropped_camera_image():\n    a_black = crop(camera(), ((200, 212), (100, 312)))\n    a_black = np.stack([a_black] * 5, axis=-1)\n    a_white = invert(a_black)\n    np.zeros(a_black.shape)\n    ones = np.ones(a_black.shape)\n    assert_allclose(meijering(a_black, black_ridges=True), meijering(\n        a_white, black_ridges=False))\n    assert_allclose(sato(a_black, black_ridges=True, mode='reflect'), sato(\n        a_white, black_ridges=False, mode='reflect'))\n    assert_allclose(frangi(a_black, black_ridges=True), frangi(a_white,\n        black_ridges=False))\n    assert_allclose(hessian(a_black, black_ridges=True, mode='reflect'),\n        ones, atol=1 - 1e-07)\n    assert_allclose(hessian(a_white, black_ridges=False, mode='reflect'),\n        ones, atol=1 - 1e-07)\n\ntest_3d_cropped_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_ridges.py"}], "method_code_mask": "import numpy as np\nfrom numbers import Integral\n\n\ndef crop(ar, crop_width, copy=False, order='K'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "view_as_blocks", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/shape.py", "response": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_blocks(arr_in, block_shape):\n    if not isinstance(arr_in, np.ndarray):\n        raise ValueError(\"Input must be a numpy array.\")\n    if not isinstance(block_shape, tuple) or len(block_shape) != arr_in.ndim:\n        raise ValueError(\"Block shape must be a tuple of the same length as the number of dimensions of the input array.\")\n    \n    # Check if the block shape divides the input array shape evenly\n    if any(arr_in.shape[i] % block_shape[i] != 0 for i in range(arr_in.ndim)):\n        raise ValueError(\"Each dimension of the block shape must divide the corresponding dimension of the input array.\")\n\n    # Calculate the new shape\n    new_shape = tuple(arr_in.shape[i] // block_shape[i] for i in range(arr_in.ndim)) + block_shape\n    \n    # Calculate the new strides\n    new_strides = arr_in.strides * 2\n    \n    # Create the block view\n    arr_out = as_strided(arr_in, shape=new_shape, strides=new_strides)\n    \n    return arr_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_1D_array():\n    A = np.arange(10)\n    B = view_as_blocks(A, (5,))\n    assert_equal(B, np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]))\n\ntest_view_as_blocks_1D_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_2D_array():\n    A = np.arange(4 * 4).reshape(4, 4)\n    B = view_as_blocks(A, (2, 2))\n    assert_equal(B[0, 1], np.array([[2, 3], [6, 7]]))\n    assert_equal(B[1, 0, 1, 1], 13)\n\ntest_view_as_blocks_2D_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_blocks_3D_array():\n    A = np.arange(4 * 4 * 6).reshape(4, 4, 6)\n    B = view_as_blocks(A, (1, 2, 2))\n    assert_equal(B.shape, (4, 2, 3, 1, 2, 2))\n    assert_equal(B[2:, 0, 2], np.array([[[[52, 53], [58, 59]]], [[[76, 77],\n        [82, 83]]]]))\n\ntest_view_as_blocks_3D_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_views_non_contiguous():\n    A = np.arange(16).reshape((4, 4))\n    A = A[::2, :]\n    res_b = view_as_blocks(A, (2, 2))\n    res_w = view_as_windows(A, (2, 2))\n    print(res_b)\n    print(res_w)\n    expected_b = [[[[0, 1], [8, 9]], [[2, 3], [10, 11]]]]\n    expected_w = [[[[0, 1], [8, 9]], [[1, 2], [9, 10]], [[2, 3], [10, 11]]]]\n    assert_equal(res_b, expected_b)\n    assert_equal(res_w, expected_w)\n\ntest_views_non_contiguous()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}], "method_code_mask": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_blocks(arr_in, block_shape): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "view_as_windows", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/shape.py", "response": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_windows(arr_in, window_shape, step=1):\n    # Ensure arr_in is a numpy array\n    arr_in = np.asarray(arr_in)\n    \n    # Determine the number of dimensions in the input array\n    if isinstance(window_shape, numbers.Integral):\n        window_shape = (window_shape,) * arr_in.ndim\n    if isinstance(step, numbers.Integral):\n        step = (step,) * arr_in.ndim\n\n    # Calculate the shape of the output array\n    shape = []\n    for dim, win, st in zip(arr_in.shape, window_shape, step):\n        if dim < win:\n            raise ValueError(\"Window shape must be less than or equal to input array shape.\")\n        shape.append((dim - win) // st + 1)\n\n    # Calculate the new shape and strides for the output array\n    new_shape = tuple(shape) + window_shape\n    new_strides = arr_in.strides + arr_in.strides\n\n    # Create the rolling window view using as_strided\n    arr_out = as_strided(arr_in, shape=new_shape, strides=new_strides)\n\n    return arr_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_1D():\n    A = np.arange(10)\n    window_shape = 3,\n    B = view_as_windows(A, window_shape)\n    assert_equal(B, np.array([[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [\n        4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]))\n\ntest_view_as_windows_1D()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_2D():\n    A = np.arange(5 * 4).reshape(5, 4)\n    window_shape = 4, 3\n    B = view_as_windows(A, window_shape)\n    assert_equal(B.shape, (2, 2, 4, 3))\n    assert_equal(B, np.array([[[[0, 1, 2], [4, 5, 6], [8, 9, 10], [12, 13, \n        14]], [[1, 2, 3], [5, 6, 7], [9, 10, 11], [13, 14, 15]]], [[[4, 5, \n        6], [8, 9, 10], [12, 13, 14], [16, 17, 18]], [[5, 6, 7], [9, 10, 11\n        ], [13, 14, 15], [17, 18, 19]]]]))\n\ntest_view_as_windows_2D()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_with_skip():\n    A = np.arange(20).reshape((5, 4))\n    B = view_as_windows(A, 2, step=2)\n    assert_equal(B, [[[[0, 1], [4, 5]], [[2, 3], [6, 7]]], [[[8, 9], [12, \n        13]], [[10, 11], [14, 15]]]])\n    C = view_as_windows(A, 2, step=4)\n    assert_equal(C.shape, (1, 1, 2, 2))\n\ntest_view_as_windows_with_skip()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_views_non_contiguous():\n    A = np.arange(16).reshape((4, 4))\n    A = A[::2, :]\n    res_b = view_as_blocks(A, (2, 2))\n    res_w = view_as_windows(A, (2, 2))\n    print(res_b)\n    print(res_w)\n    expected_b = [[[[0, 1], [8, 9]], [[2, 3], [10, 11]]]]\n    expected_w = [[[[0, 1], [8, 9]], [[1, 2], [9, 10]], [[2, 3], [10, 11]]]]\n    assert_equal(res_b, expected_b)\n    assert_equal(res_w, expected_w)\n\ntest_views_non_contiguous()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage.util.shape import view_as_blocks\nfrom skimage.util.shape import view_as_windows\ndef test_view_as_windows_step_tuple():\n    A = np.arange(24).reshape((6, 4))\n    B = view_as_windows(A, (3, 2), step=3)\n    assert B.shape == (2, 1, 3, 2)\n    assert B.size != A.size\n    C = view_as_windows(A, (3, 2), step=(3, 2))\n    assert C.shape == (2, 2, 3, 2)\n    assert C.size == A.size\n    assert_equal(C, [[[[0, 1], [4, 5], [8, 9]], [[2, 3], [6, 7], [10, 11]]],\n        [[[12, 13], [16, 17], [20, 21]], [[14, 15], [18, 19], [22, 23]]]])\n\ntest_view_as_windows_step_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_shape.py"}], "method_code_mask": "import numbers\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\n\ndef view_as_windows(arr_in, window_shape, step=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "unique_rows", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/unique.py", "response": "import numpy as np\n\n\ndef unique_rows(ar):\n    if ar.ndim != 2:\n        raise ValueError(\"Input array must be two-dimensional.\")\n    \n    # Create a view of the array where each row is treated as a single object\n    # Use np.unique to find unique rows\n    ar_out = np.unique(ar, axis=0)\n    \n    return ar_out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_discontiguous_array():\n    ar = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]], np.uint8)\n    ar = ar[::2]\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[1, 0, 1]], np.uint8)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_discontiguous_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}, {"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_uint8_array():\n    ar = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]], np.uint8)\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[0, 1, 0], [1, 0, 1]], np.uint8)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_uint8_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}, {"test_code": "import numpy as np\nfrom skimage.util import unique_rows\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_float_array():\n    ar = np.array([[1.1, 0.0, 1.1], [0.0, 1.1, 0.0], [1.1, 0.0, 1.1]], float)\n    ar_out = unique_rows(ar)\n    desired_ar_out = np.array([[0.0, 1.1, 0.0], [1.1, 0.0, 1.1]], float)\n    assert_equal(ar_out, desired_ar_out)\n\ntest_float_array()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_unique_rows.py"}], "method_code_mask": "import numpy as np\n\n\ndef unique_rows(ar): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "label_points", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/_label.py", "response": "import numpy as np\n\n\ndef label_points(coords, output_shape):\n    # Check if the dimensionality of coords matches the output_shape\n    if coords.shape[1] != len(output_shape):\n        raise ValueError(\"The dimensionality of the points does not match the output shape.\")\n    \n    # Check for negative coordinates\n    if np.any(coords < 0):\n        raise ValueError(\"Coordinates must be non-negative.\")\n    \n    # Check for out of range coordinates\n    if np.any(coords >= np.array(output_shape)):\n        raise IndexError(\"Coordinates are out of range of the mask.\")\n    \n    # Create an output mask filled with zeros\n    labels = np.zeros(output_shape, dtype=int)\n    \n    # Assign unique labels starting from 1\n    for i, coord in enumerate(coords):\n        labels[tuple(coord)] = i + 1\n    \n    return labels", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_label_points_two_dimensional_output():\n    coords, output_shape = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n        ), (5, 5)\n    mask = label_points(coords, output_shape)\n    assert_equal(mask, np.array([[1, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 3,\n        0, 0], [0, 0, 0, 4, 0], [0, 0, 0, 0, 5]]))\n\ntest_label_points_two_dimensional_output()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_labels.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\ndef test_label_points_multi_dimensional_output():\n    coords, output_shape = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3,\n        0], [4, 4, 1]]), (5, 5, 3)\n    mask = label_points(coords, output_shape)\n    result = np.array([[[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, \n        0]], [[0, 0, 0], [0, 2, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, \n        0, 0], [0, 0, 0], [0, 0, 3], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0,\n        0, 0], [0, 0, 0], [4, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0,\n        0, 0], [0, 0, 0], [0, 5, 0]]])\n    assert_equal(mask, result)\n\ntest_label_points_multi_dimensional_output()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/util/tests/test_labels.py"}], "method_code_mask": "import numpy as np\n\n\ndef label_points(coords, output_shape): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "label2rgb", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/colorlabel.py", "response": "import itertools\nimport numpy as np\nfrom skimage.color import rgb2gray, gray2rgb\n\ndef label2rgb(label, image=None, colors=None, alpha=0.3, bg_label=0,\n    bg_color=(0, 0, 0), image_alpha=1, kind='overlay', *, saturation=0,\n    channel_axis=-1):\n    \n    # Ensure label is an integer array\n    label = np.asarray(label, dtype=np.int)\n    \n    # Create a color map if colors are not provided\n    if colors is None:\n        colors = plt.cm.get_cmap('hsv', np.max(label) + 1)\n        colors = colors(np.arange(np.max(label) + 1))[:, :3]  # Take RGB only\n\n    # Create an RGB image from the labels\n    label_rgb = np.zeros((*label.shape, 3), dtype=np.float32)\n    for i in range(1, np.max(label) + 1):\n        if i == bg_label:\n            continue\n        label_rgb[label == i] = colors[i]\n\n    # Set background color\n    label_rgb[label == bg_label] = bg_color\n\n    # If an image is provided, blend it with the label colors\n    if image is not None:\n        image = np.asarray(image, dtype=np.float32)\n        if image.ndim == 2:  # Grayscale image\n            image = gray2rgb(image)\n        elif image.shape[channel_axis] == 1:  # Single channel\n            image = np.concatenate([image] * 3, axis=channel_axis)\n\n        # Adjust saturation\n        if saturation > 0:\n            image = (1 - saturation) * rgb2gray(image)[:, :, np.newaxis] + saturation * image\n\n        # Blend the images\n        result = (1 - alpha) * image * image_alpha + alpha * label_rgb\n    else:\n        result = label_rgb\n\n    return result", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_rgb():\n    image = np.ones((1, 3))\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=colors, alpha=1, image_alpha\n        =1, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_rgb()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_alpha():\n    image = np.random.uniform(size=(3, 3))\n    label = np.random.randint(0, 9, size=(3, 3))\n    rgb = label2rgb(label, image=image, alpha=0, image_alpha=1, bg_label=-1)\n    assert_array_almost_equal(rgb[..., 0], image)\n    assert_array_almost_equal(rgb[..., 1], image)\n    assert_array_almost_equal(rgb[..., 2], image)\n\ntest_alpha()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_no_input_image():\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, colors=colors, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_no_input_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_image_alpha():\n    image = np.random.uniform(size=(1, 3))\n    label = np.arange(3).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=colors, alpha=1, image_alpha\n        =0, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_image_alpha()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_color_names():\n    image = np.ones((1, 3))\n    label = np.arange(3).reshape(1, -1)\n    cnames = ['red', 'lime', 'blue']\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n    rgb = label2rgb(label, image=image, colors=cnames, alpha=1, image_alpha\n        =1, bg_label=-1)\n    assert_array_almost_equal(rgb, [colors])\n\ntest_color_names()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_bg_and_color_cycle():\n    image = np.zeros((1, 10))\n    label = np.arange(10).reshape(1, -1)\n    colors = [(1, 0, 0), (0, 0, 1)]\n    bg_color = 0, 0, 0\n    rgb = label2rgb(label, image=image, bg_label=0, bg_color=bg_color,\n        colors=colors, alpha=1)\n    assert_array_almost_equal(rgb[0, 0], bg_color)\n    for pixel, color in zip(rgb[0, 1:], itertools.cycle(colors)):\n        assert_array_almost_equal(pixel, color)\n\ntest_bg_and_color_cycle()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_negative_labels():\n    labels = np.array([0, -1, -2, 0])\n    rout = np.array([(0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (\n        0.0, 0.0, 0.0)])\n    assert_array_almost_equal(rout, label2rgb(labels, bg_label=0, alpha=1,\n        image_alpha=1))\n\ntest_negative_labels()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_nonconsecutive():\n    labels = np.array([0, 2, 4, 0])\n    colors = [(1, 0, 0), (0, 0, 1)]\n    rout = np.array([(1.0, 0.0, 0.0), (0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (\n        1.0, 0.0, 0.0)])\n    assert_array_almost_equal(rout, label2rgb(labels, colors=colors, alpha=\n        1, image_alpha=1, bg_label=-1))\n\ntest_nonconsecutive()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_label_consistency():\n    \"\"\"Assert that the same labels map to the same colors.\"\"\"\n    label_1 = np.arange(5).reshape(1, -1)\n    label_2 = np.array([0, 1])\n    colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 0), (1, 0, 1)]\n    rgb_1 = label2rgb(label_1, colors=colors, bg_label=-1)\n    rgb_2 = label2rgb(label_2, colors=colors, bg_label=-1)\n    for label_id in label_2.flat:\n        assert_array_almost_equal(rgb_1[label_1 == label_id], rgb_2[label_2 ==\n            label_id])\n\ntest_label_consistency()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_leave_labels_alone():\n    labels = np.array([-1, 0, 1])\n    labels_saved = labels.copy()\n    label2rgb(labels, bg_label=-1)\n    label2rgb(labels, bg_label=1)\n    assert_array_equal(labels, labels_saved)\n\ntest_leave_labels_alone()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}, {"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import hsv2rgb\nfrom skimage.color.colorconv import rgb2hsv\nfrom skimage.color.colorlabel import label2rgb\ndef test_bg_color_rgb_string():\n    img = np.random.randint(0, 255, (10, 10), dtype=np.uint8)\n    labels = np.zeros((10, 10), dtype=np.int64)\n    labels[1:3, 1:3] = 1\n    labels[6:9, 6:9] = 2\n    output = label2rgb(labels, image=img, alpha=0.9, bg_label=0, bg_color='red'\n        )\n    assert output[0, 0, 0] > 0.9\n\ntest_bg_color_rgb_string()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_colorlabel.py"}], "method_code_mask": "import itertools\nimport numpy as np\n\n\ndef label2rgb(label, image=None, colors=None, alpha=0.3, bg_label=0,\n    bg_color=(0, 0, 0), image_alpha=1, kind='overlay', *, saturation=0,\n    channel_axis=-1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "fetch", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/testing.py", "response": "import os\nimport platform\nimport re\nimport struct\nimport sys\nimport functools\nimport inspect\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nfrom numpy import testing\nfrom numpy.testing import TestCase\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_less\nimport pytest\nimport threading\n\n\ndef fetch(data_filename):\n    try:\n        # Attempt to fetch the data file from a predefined location\n        data_path = os.path.join('data', data_filename)\n        with open(data_path, 'r') as file:\n            data = file.read()\n        return data\n    except FileNotFoundError:\n        pytest.skip(f\"Data file '{data_filename}' not found. Skipping tests that require this data.\")\n    except ConnectionError:\n        pytest.skip(\"Connection error occurred. Skipping tests that require this data.\")\n    except ModuleNotFoundError:\n        pytest.skip(\"Required module not found. Skipping tests that require this data.\")", "test_code_list": [{"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_cells3d():\n    \"\"\"Needs internet connection.\"\"\"\n    path = fetch('data/cells3d.tif')\n    image = io.imread(path)\n    assert image.shape == (60, 2, 256, 256)\n\ntest_cells3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_brain_3d():\n    \"\"\"Needs internet connection.\"\"\"\n    path = fetch('data/brain.tiff')\n    image = io.imread(path)\n    assert image.shape == (10, 256, 256)\n\ntest_brain_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\n@pytest.mark.xfail(Version(np.__version__) >= Version('2.0.0.dev0'), reason\n    ='tifffile uses deprecated attribute `ndarray.newbyteorder`')\ndef test_kidney_3d_multichannel():\n    \"\"\"Test that 3D multichannel image of kidney tissue can be loaded.\n\n    Needs internet connection.\n    \"\"\"\n    fetch('data/kidney.tif')\n    kidney = data.kidney()\n    assert kidney.shape == (16, 512, 512, 3)\n\ntest_kidney_3d_multichannel()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\n@pytest.mark.xfail(Version(np.__version__) >= Version('2.0.0.dev0'), reason\n    ='tifffile uses deprecated attribute `ndarray.newbyteorder`')\ndef test_lily_multichannel():\n    \"\"\"Test that microscopy image of lily of the valley can be loaded.\n\n    Needs internet connection.\n    \"\"\"\n    fetch('data/lily.tif')\n    lily = data.lily()\n    assert lily.shape == (922, 922, 4)\n\ntest_lily_multichannel()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from packaging.version import Version\nimport numpy as np\nimport skimage.data as data\nfrom skimage import io\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import fetch\nimport os\nimport pytest\ndef test_vortex():\n    fetch('data/pivchallenge-B-B001_1.tif')\n    fetch('data/pivchallenge-B-B001_2.tif')\n    image0, image1 = data.vortex()\n    for image in [image0, image1]:\n        assert image.shape == (512, 512)\n\ntest_vortex()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/data/tests/test_data.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage import io\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import use_plugin\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import TestCase\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imread_as_gray():\n    img = imread(fetch('data/color.png'), as_gray=True)\n    assert img.ndim == 2\n    assert img.dtype == np.float64\n    img = imread(fetch('data/camera.png'), as_gray=True)\n    assert np.dtype(img.dtype).char in np.typecodes['AllInteger']\n\ntest_imread_as_gray()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_imread.py"}, {"test_code": "import pathlib\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import reset_plugins\nfrom skimage.io import use_plugin\ndef test_imread_multipage_rgb_tif():\n    img = imread(fetch('data/multipage_rgb.tif'))\n    assert img.shape == (2, 10, 10, 3), img.shape\n\ntest_imread_multipage_rgb_tif()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_tifffile.py"}, {"test_code": "import pathlib\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import reset_plugins\nfrom skimage.io import use_plugin\ndef test_tifffile_kwarg_passthrough():\n    img = imread(fetch('data/multipage.tif'), key=[1], is_ome=True)\n    assert img.shape == (15, 10), img.shape\n\ntest_tifffile_kwarg_passthrough()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_tifffile.py"}, {"test_code": "import os\nimport itertools\nimport numpy as np\nimport imageio.v3 as iio3\nfrom skimage import data_dir\nfrom skimage.io.collection import ImageCollection\nfrom skimage.io.collection import MultiImage\nfrom skimage.io.collection import alphanumeric_key\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imagecollection_input():\n    \"\"\"Test function for ImageCollection. The new behavior (implemented\n    in 0.16) allows the `pattern` argument to accept a list of strings\n    as the input.\n\n    Notes\n    -----\n        If correct, `images` will receive three images.\n    \"\"\"\n    pics = [fetch('data/coffee.png'), fetch('data/chessboard_GRAY.png'),\n        fetch('data/rocket.jpg')]\n    pattern = [os.path.join(data_dir, pic) for pic in pics]\n    images = ImageCollection(pattern)\n    assert len(images) == 3\n\ntest_imagecollection_input()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_collection.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import plugin_order\nfrom skimage._shared import testing\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_imageio_as_gray():\n    img = imread(fetch('data/color.png'), as_gray=True)\n    assert img.ndim == 2\n    assert img.dtype == np.float64\n    img = imread(fetch('data/camera.png'), as_gray=True)\n    assert np.dtype(img.dtype).char in np.typecodes['AllInteger']\n\ntest_imageio_as_gray()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_imageio.py"}, {"test_code": "from tempfile import NamedTemporaryFile\nimport numpy as np\nfrom skimage.io import imread\nfrom skimage.io import imsave\nfrom skimage.io import plugin_order\nfrom skimage._shared import testing\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_return_class():\n    testing.assert_equal(type(imread(fetch('data/color.png'))), np.ndarray)\n\ntest_return_class()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_imageio.py"}, {"test_code": "import os\nimport pathlib\nimport tempfile\nimport numpy as np\nimport pytest\nfrom skimage import io\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.data import data_dir\ndef test_imread_file_url():\n    data_path = str(fetch('data/camera.png'))\n    data_path = data_path.replace(os.path.sep, '/')\n    image_url = f'file:///{data_path}'\n    image = io.imread(image_url)\n    assert image.shape == (512, 512)\n\ntest_imread_file_url()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_io.py"}, {"test_code": "import os\nimport pathlib\nimport tempfile\nimport numpy as np\nimport pytest\nfrom skimage import io\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.data import data_dir\ndef test_imread_pathlib_tiff():\n    \"\"\"Tests reading from Path object (issue gh-5545).\"\"\"\n    fname = fetch('data/multipage.tif')\n    expected = io.imread(fname)\n    path = pathlib.Path(fname)\n    img = io.imread(path)\n    assert img.shape == (2, 15, 10)\n    assert_array_equal(expected, img)\n\ntest_imread_pathlib_tiff()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_io.py"}], "method_code_mask": "import os\nimport platform\nimport re\nimport struct\nimport sys\nimport functools\nimport inspect\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nfrom numpy import testing\nfrom numpy.testing import TestCase\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_warns\nfrom numpy.testing import assert_no_warnings\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_almost_equal_nulp\nfrom numpy.testing import assert_array_less\nimport pytest\nimport threading\n\n\ndef fetch(data_filename): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "deltaE_cmc", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/delta_e.py", "response": "import numpy as np\n\n\ndef deltaE_cmc(lab1, lab2, kL=1, kC=1, *, channel_axis=-1):\n    # Ensure the input arrays are numpy arrays\n    lab1 = np.asarray(lab1)\n    lab2 = np.asarray(lab2)\n\n    # Calculate the differences in the Lab color space\n    delta_L = lab1[..., 0] - lab2[..., 0]\n    delta_a = lab1[..., 1] - lab2[..., 1]\n    delta_b = lab1[..., 2] - lab2[..., 2]\n\n    # Calculate the chroma for both colors\n    C1 = np.sqrt(lab1[..., 1]**2 + lab1[..., 2]**2)\n    C2 = np.sqrt(lab2[..., 1]**2 + lab2[..., 2]**2)\n\n    # Calculate the mean chroma\n    C_mean = (C1 + C2) / 2\n\n    # Calculate the lightness and chroma differences\n    dL = delta_L\n    dC = delta_a**2 + delta_b**2 - (C1 - C2)**2\n\n    # Calculate the hue difference\n    dH = np.sqrt(delta_a**2 + delta_b**2)\n\n    # Calculate the CMC color difference\n    dE = np.sqrt((dL / kL)**2 + (dC / kC)**2 + (dH / (kC * C_mean))**2)\n\n    return dE", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.color.delta_e import deltaE_cie76\nfrom skimage.color.delta_e import deltaE_ciede94\nfrom skimage.color.delta_e import deltaE_ciede2000\nfrom skimage.color.delta_e import deltaE_cmc\ndef test_cmc_single_item():\n    lab1 = lab2 = np.array([0.0, 1.59607713, 0.87755709])\n    assert_equal(deltaE_cmc(lab1, lab2), 0)\n    lab2[0] += np.finfo(float).eps\n    assert_equal(deltaE_cmc(lab1, lab2), 0)\n\ntest_cmc_single_item()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/color/tests/test_delta_e.py"}], "method_code_mask": "import numpy as np\n\n\ndef deltaE_cmc(lab1, lab2, kL=1, kC=1, *, channel_axis=-1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "h_maxima", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "response": "import numpy as np\n\n\ndef h_maxima(image, h, footprint=None):\n    if footprint is None:\n        footprint = np.ones((3, 3), dtype=bool)  # Default footprint (ball of radius 1)\n\n    # Create a mask for the local maxima\n    local_max = (image == ndimage.maximum_filter(image, footprint=footprint))\n\n    # Create a mask for the pixels that are greater than or equal to h\n    height_mask = (image >= h)\n\n    # Combine the masks to find the local maxima that are also above the height threshold\n    h_max = local_max & height_mask\n\n    # Label the connected components in the h_max image\n    labeled, num_features = ndimage.label(h_max)\n\n    # Create an output image for the final maxima\n    output = np.zeros_like(image, dtype=np.uint8)\n\n    # Iterate through each labeled component\n    for i in range(1, num_features + 1):\n        # Get the coordinates of the current component\n        component = (labeled == i)\n        \n        # Check if the minimum value in the component is greater than or equal to h\n        if np.min(image[component]) >= h:\n            output[component] = 1  # Mark the maxima in the output image\n\n    return output", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestExtrema():\n\tdef test_h_maxima_large_h(self):\n\t    \"\"\"test that h-maxima works correctly for large h\"\"\"\n\t    data = np.array([[10, 10, 10, 10, 10], [10, 13, 13, 13, 10], [10, 13, \n\t        14, 13, 10], [10, 13, 13, 13, 10], [10, 10, 10, 10, 10]], dtype=np.\n\t        uint8)\n\t    maxima = h_maxima(data, 5)\n\t    assert np.sum(maxima) == 0\n\t    data = np.array([[10, 10, 10, 10, 10], [10, 13, 13, 13, 10], [10, 13, \n\t        14, 13, 10], [10, 13, 13, 13, 10], [10, 10, 10, 10, 10]], dtype=np.\n\t        float32)\n\t    maxima = h_maxima(data, 5.0)\n\t    assert np.sum(maxima) == 0\n\t\nTestExtrema().test_h_maxima_large_h()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "method_code_mask": "import numpy as np\n\n\ndef h_maxima(image, h, footprint=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "h_minima", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "response": "import numpy as np\nfrom scipy.ndimage import minimum_filter, label\n\ndef h_minima(image, h, footprint=None):\n    if footprint is None:\n        footprint = np.ones((3, 3), dtype=bool)  # Default ball-shaped footprint with radius 1\n\n    # Step 1: Compute the local minima using a minimum filter\n    local_min = minimum_filter(image, footprint=footprint)  # Local minima\n\n    # Step 2: Identify the depth of the minima\n    depth = local_min - image  # Depth of the minima\n\n    # Step 3: Create a binary mask for minima with depth >= h\n    h_min = (depth >= h) & (local_min < image)  # Mark local minima with sufficient depth\n\n    # Step 4: Label the connected components of the minima\n    labeled_minima, num_features = label(h_min)\n\n    # Step 5: Create the output binary array\n    output = np.zeros_like(image, dtype=bool)\n    output[labeled_minima > 0] = 1  # Mark the detected minima\n\n    return output", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestExtrema():\n\tdef test_h_minima_large_h(self):\n\t    \"\"\"test that h-minima works correctly for large h\"\"\"\n\t    data = np.array([[14, 14, 14, 14, 14], [14, 11, 11, 11, 14], [14, 11, \n\t        10, 11, 14], [14, 11, 11, 11, 14], [14, 14, 14, 14, 14]], dtype=np.\n\t        uint8)\n\t    maxima = h_minima(data, 5)\n\t    assert np.sum(maxima) == 0\n\t    data = np.array([[14, 14, 14, 14, 14], [14, 11, 11, 11, 14], [14, 11, \n\t        10, 11, 14], [14, 11, 11, 11, 14], [14, 14, 14, 14, 14]], dtype=np.\n\t        float32)\n\t    maxima = h_minima(data, 5.0)\n\t    assert np.sum(maxima) == 0\n\t\nTestExtrema().test_h_minima_large_h()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "method_code_mask": "import numpy as np\n\n\ndef h_minima(image, h, footprint=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "local_maxima", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/extrema.py", "response": "import numpy as np\n\n\ndef local_maxima(image, footprint=None, connectivity=None, indices=False,\n    allow_borders=True):\n    from scipy.ndimage import maximum_filter, label\n\n    # Create a maximum filter of the image\n    if footprint is not None:\n        filtered = maximum_filter(image, footprint=footprint, mode='constant', cval=-np.inf)\n    else:\n        filtered = maximum_filter(image, size=connectivity, mode='constant', cval=-np.inf)\n\n    # Identify local maxima\n    maxima = (image == filtered)\n\n    # Remove border maxima if not allowed\n    if not allow_borders:\n        maxima[0, :] = False\n        maxima[-1, :] = False\n        maxima[:, 0] = False\n        maxima[:, -1] = False\n\n    # Label connected components\n    labeled, num_features = label(maxima)\n\n    if indices:\n        # Return the coordinates of the maxima\n        return np.nonzero(maxima)\n    else:\n        # Return the boolean array of maxima\n        return maxima", "test_code_list": [{"test_code": "import math\nimport unittest\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom pytest import raises\nfrom pytest import warns\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.morphology import extrema\n\nclass TestLocalMaxima(unittest.TestCase):\n\tdef test_empty(self):\n\t    \"\"\"Test result with empty image.\"\"\"\n\t    result = local_maxima(np.array([[]]), indices=False)\n\t    assert result.size == 0\n\t    assert result.dtype == bool\n\t    assert result.shape == (1, 0)\n\t    result = local_maxima(np.array([]), indices=True)\n\t    assert isinstance(result, tuple)\n\t    assert len(result) == 1\n\t    assert result[0].size == 0\n\t    assert result[0].dtype == np.intp\n\t    result = local_maxima(np.array([[]]), indices=True)\n\t    assert isinstance(result, tuple)\n\t    assert len(result) == 2\n\t    assert result[0].size == 0\n\t    assert result[0].dtype == np.intp\n\t    assert result[1].size == 0\n\t    assert result[1].dtype == np.intp\n\t\nTestLocalMaxima().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_extrema.py"}], "method_code_mask": "import numpy as np\n\n\ndef local_maxima(image, footprint=None, connectivity=None, indices=False,\n    allow_borders=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "convex_hull_image", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/convex_hull.py", "response": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\n\ndef convex_hull_image(image, offset_coordinates=True, tolerance=1e-10,\n    include_borders=True):\n    # Convert the input image to a boolean array\n    image = image.astype(bool)\n    \n    # Get the coordinates of the True pixels\n    coords = np.argwhere(image)\n    \n    if len(coords) < 3:\n        # If there are less than 3 points, return the original image\n        return image\n    \n    # Compute the convex hull\n    hull = ConvexHull(coords)\n    \n    # Create an empty mask for the convex hull\n    hull_mask = np.zeros_like(image, dtype=bool)\n    \n    # Fill the hull mask\n    for simplex in hull.simplices:\n        # Get the coordinates of the vertices of the simplex\n        simplex_coords = coords[simplex]\n        \n        # Create a polygon from the simplex vertices\n        rr, cc = np.meshgrid(np.arange(image.shape[0]), np.arange(image.shape[1]), indexing='ij')\n        points = np.vstack((rr.ravel(), cc.ravel())).T\n        \n        # Check if points are inside the convex hull\n        if include_borders:\n            # Use the convex hull vertices to create a mask\n            from matplotlib.path import Path\n            path = Path(simplex_coords)\n            mask = path.contains_points(points).reshape(image.shape)\n        else:\n            # Exclude borders\n            path = Path(simplex_coords)\n            mask = path.contains_points(points) & ~np.isin(points, simplex_coords).any(axis=1).reshape(image.shape)\n        \n        # Update the hull mask\n        hull_mask |= mask\n    \n    return hull_mask", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_basic():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0,\n        0], [0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1,\n        0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0,\n        0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0], [0,\n        1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_basic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_empty_image():\n    image = np.zeros((6, 6), dtype=bool)\n    with expected_warnings(['entirely zero']):\n        assert_array_equal(convex_hull_image(image), image)\n\ntest_empty_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_qhull_offset_example():\n    nonzeros = [1367, 1368, 1368, 1368, 1369, 1369, 1369, 1369, 1369, 1370,\n        1370, 1370, 1370, 1370, 1370, 1370, 1371, 1371, 1371, 1371, 1371, \n        1371, 1371, 1371, 1371, 1372, 1372, 1372, 1372, 1372, 1372, 1372, \n        1372, 1372, 1373, 1373, 1373, 1373, 1373, 1373, 1373, 1373, 1373, \n        1374, 1374, 1374, 1374, 1374, 1374, 1374, 1375, 1375, 1375, 1375, \n        1375, 1376, 1376, 1376, 1377, 1372], [151, 150, 151, 152, 149, 150,\n        151, 152, 153, 148, 149, 150, 151, 152, 153, 154, 147, 148, 149, \n        150, 151, 152, 153, 154, 155, 146, 147, 148, 149, 150, 151, 152, \n        153, 154, 146, 147, 148, 149, 150, 151, 152, 153, 154, 147, 148, \n        149, 150, 151, 152, 153, 148, 149, 150, 151, 152, 149, 150, 151, \n        150, 155]\n    image = np.zeros((1392, 1040), dtype=bool)\n    image[nonzeros] = True\n    expected = image.copy()\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_qhull_offset_example()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_pathological_qhull_example():\n    image = np.array([[0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1], [1, 1, \n        1, 0, 0, 0, 0]], dtype=bool)\n    expected = np.array([[0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1], [1, \n        1, 1, 1, 1, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_image(image), expected)\n\ntest_pathological_qhull_example()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_non_c_contiguous():\n    image = np.ones((2, 2), order='F', dtype=bool)\n    assert_array_equal(convex_hull_image(image), image)\n    image = np.ones((2, 2, 2), order='F', dtype=bool)\n    assert_array_equal(convex_hull_image(image), image)\n    image = np.transpose(np.ones((2, 2, 2), dtype=bool), [0, 2, 1])\n    assert_array_equal(convex_hull_image(image), image)\n\ntest_non_c_contiguous()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}], "method_code_mask": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\n\ndef convex_hull_image(image, offset_coordinates=True, tolerance=1e-10,\n    include_borders=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "convex_hull_object", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/convex_hull.py", "response": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\ndef convex_hull_object(image, *, connectivity=2):\n    # Ensure the connectivity is valid\n    if connectivity not in [1, 2]:\n        raise ValueError(\"Connectivity must be either 1 or 2.\")\n    \n    # Get the coordinates of the white pixels (objects)\n    coords = np.argwhere(image)\n    \n    # If there are no white pixels, return an empty array\n    if coords.size == 0:\n        return np.zeros_like(image, dtype=bool)\n    \n    # Create a convex hull for the coordinates\n    hull = ConvexHull(coords)\n    \n    # Create a boolean array for the convex hull\n    hull_image = np.zeros_like(image, dtype=bool)\n    \n    # Fill the convex hull area in the boolean array\n    for simplex in hull.simplices:\n        # Get the vertices of the simplex\n        pts = coords[simplex]\n        # Create a polygon from the vertices\n        rr, cc = np.meshgrid(np.arange(image.shape[0]), np.arange(image.shape[1]), indexing='ij')\n        points = np.vstack((rr.ravel(), cc.ravel())).T\n        # Check if points are inside the convex hull\n        inside = np.array([hull.find_simplex(point) >= 0 for point in points])\n        hull_image[inside.reshape(image.shape)] = True\n    \n    return hull_image", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import convex_hull_image\nfrom skimage.morphology import convex_hull_object\nfrom skimage.morphology._convex_hull import possible_hull\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_object():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0,\n        0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1,\n        1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, \n        0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n        0]], dtype=bool)\n    expected_conn_1 = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0,\n        0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, \n        0], [1, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1,\n        0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, \n        0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_object(image, connectivity=1),\n        expected_conn_1)\n    expected_conn_2 = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0,\n        0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, \n        0], [1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1,\n        0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, \n        0, 0, 0, 0]], dtype=bool)\n    assert_array_equal(convex_hull_object(image, connectivity=2),\n        expected_conn_2)\n    with testing.raises(ValueError):\n        convex_hull_object(image, connectivity=3)\n    out = convex_hull_object(image, connectivity=1)\n    assert_array_equal(out, expected_conn_1)\n\ntest_object()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_convex_hull.py"}], "method_code_mask": "from itertools import product\nimport numpy as np\nfrom scipy.spatial import ConvexHull\n\n\ndef convex_hull_object(image, *, connectivity=2): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "rectangle", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "response": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef rectangle(nrows, ncols, dtype=np.uint8, *, decomposition=None):\n    if not isinstance(nrows, Integral) or not isinstance(ncols, Integral):\n        raise ValueError(\"nrows and ncols must be integers.\")\n    if nrows <= 0 or ncols <= 0:\n        raise ValueError(\"nrows and ncols must be positive integers.\")\n    \n    footprint = np.ones((nrows, ncols), dtype=dtype)\n    \n    if decomposition == 'separable':\n        return (np.ones((nrows, 1), dtype=dtype), np.ones((1, ncols), dtype=dtype))\n    elif decomposition == 'sequence':\n        return (np.ones((nrows, 1), dtype=dtype),) * ncols\n    elif decomposition is None:\n        return footprint\n    else:\n        raise ValueError(\"decomposition must be 'separable', 'sequence', or None.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\n\nclass TestFootprints():\n\tdef test_rectangle_footprint(self):\n\t    \"\"\"Test rectangle footprints\"\"\"\n\t    for i in range(0, 5):\n\t        for j in range(0, 5):\n\t            actual_mask = rectangle(i, j)\n\t            expected_mask = np.ones((i, j), dtype='uint8')\n\t            assert_equal(expected_mask, actual_mask)\n\t\nTestFootprints().test_rectangle_footprint()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_footprints.py"}], "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef rectangle(nrows, ncols, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "diamond", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "response": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef diamond(radius, dtype=np.uint8, *, decomposition=None):\n    if not isinstance(radius, Integral) or radius < 1:\n        raise ValueError(\"Radius must be a positive integer.\")\n    \n    # Create a diamond-shaped footprint\n    footprint = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=dtype)\n    for i in range(footprint.shape[0]):\n        for j in range(footprint.shape[1]):\n            if abs(radius - i) + abs(radius - j) <= radius:\n                footprint[i, j] = 1\n\n    if decomposition == 'sequence':\n        return [(footprint, 1)]  # Returning a sequence with one iteration\n    else:\n        return footprint", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.morphology import diamond\nfrom skimage.feature import match_template\nfrom skimage.feature import peak_local_max\nfrom skimage._shared import testing\ndef test_pad_input():\n    \"\"\"Test `match_template` when `pad_input=True`.\n\n    This test places two full templates (one with values lower than the image\n    mean, the other higher) and two half templates, which are on the edges of\n    the image. The two full templates should score the top (positive and\n    negative) matches and the centers of the half templates should score 2nd.\n    \"\"\"\n    template = 0.5 * diamond(2)\n    image = 0.5 * np.ones((9, 19))\n    mid = slice(2, 7)\n    image[mid, :3] -= template[:, -3:]\n    image[mid, 4:9] += template\n    image[mid, -9:-4] -= template\n    image[mid, -3:] += template[:, :3]\n    result = match_template(image, template, pad_input=True,\n        constant_values=image.mean())\n    sorted_result = np.argsort(result.flat)\n    i, j = np.unravel_index(sorted_result[:2], result.shape)\n    assert_equal(j, (12, 0))\n    i, j = np.unravel_index(sorted_result[-2:], result.shape)\n    assert_equal(j, (18, 6))\n\ntest_pad_input()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_template.py"}, {"test_code": "import numpy as np\nfrom skimage._shared.testing import assert_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage import data\nfrom skimage import img_as_float\nfrom skimage.morphology import diamond\nfrom skimage.feature import match_template\nfrom skimage.feature import peak_local_max\nfrom skimage._shared import testing\ndef test_padding_reflect():\n    template = diamond(2)\n    image = np.zeros((10, 10))\n    image[2:7, :3] = template[:, -3:]\n    result = match_template(image, template, pad_input=True, mode='reflect')\n    assert_equal(np.unravel_index(result.argmax(), result.shape), (4, 0))\n\ntest_padding_reflect()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_template.py"}], "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef diamond(radius, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "cube", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "response": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef cube(width, dtype=np.uint8, *, decomposition=None):\n    radius = width // 2\n    footprint = np.zeros((width, width, width), dtype=dtype)\n\n    # Create the cube footprint\n    for x in range(width):\n        for y in range(width):\n            for z in range(width):\n                if max(abs(x - radius), abs(y - radius), abs(z - radius)) <= radius:\n                    footprint[x, y, z] = 1\n\n    if decomposition is None:\n        return footprint\n    elif decomposition == 'separable':\n        return (footprint[:, :, radius], footprint[:, radius, :], footprint[radius, :, :])\n    elif decomposition == 'sequence':\n        return ((footprint[:, :, radius], 1), (footprint[:, radius, :], 1), (footprint[radius, :, :], 1))\n    else:\n        raise ValueError(\"decomposition must be None, 'separable', or 'sequence'\")", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_equal\nfrom skimage._shared.testing import fetch\n\nclass TestFootprints():\n\tdef test_cube_footprint(self):\n\t    \"\"\"Test cube footprints\"\"\"\n\t    for k in range(0, 5):\n\t        actual_mask = cube(k)\n\t        expected_mask = np.ones((k, k, k), dtype='uint8')\n\t        assert_equal(expected_mask, actual_mask)\n\t\nTestFootprints().test_cube_footprint()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_footprints.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom skimage import data\nfrom skimage import draw\nfrom skimage import img_as_float\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.feature import corner_fast\nfrom skimage.feature import corner_foerstner\nfrom skimage.feature import corner_harris\nfrom skimage.feature import corner_kitchen_rosenfeld\nfrom skimage.feature import corner_moravec\nfrom skimage.feature import corner_orientations\nfrom skimage.feature import corner_peaks\nfrom skimage.feature import corner_shi_tomasi\nfrom skimage.feature import corner_subpix\nfrom skimage.feature import hessian_matrix\nfrom skimage.feature import hessian_matrix_det\nfrom skimage.feature import hessian_matrix_eigvals\nfrom skimage.feature import peak_local_max\nfrom skimage.feature import shape_index\nfrom skimage.feature import structure_tensor\nfrom skimage.feature import structure_tensor_eigenvalues\nfrom skimage.morphology import cube\nfrom skimage.morphology import octagon\ndef test_structure_tensor_eigenvalues_3d():\n    image = np.pad(cube(9, dtype=np.int64), 5, mode='constant') * 1000\n    boundary = (np.pad(cube(9), 5, mode='constant') - np.pad(cube(7), 6,\n        mode='constant')).astype(bool)\n    A_elems = structure_tensor(image, sigma=0.1)\n    e0, e1, e2 = structure_tensor_eigenvalues(A_elems)\n    assert np.all(e0[boundary] != 0)\n\ntest_structure_tensor_eigenvalues_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_corner.py"}], "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef cube(width, dtype=np.uint8, *, decomposition=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "remove_small_objects", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/misc.py", "response": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_objects(ar, min_size=64, connectivity=1, *, out=None):\n    # Validate input types\n    if not isinstance(ar, (np.ndarray, np.generic)):\n        raise TypeError(\"Input 'ar' must be a numpy array.\")\n    if not isinstance(min_size, int) or min_size < 0:\n        raise ValueError(\"Input 'min_size' must be a non-negative integer.\")\n    if not isinstance(connectivity, int) or connectivity < 1 or connectivity > ar.ndim:\n        raise ValueError(\"Input 'connectivity' must be an integer between 1 and the number of dimensions of 'ar'.\")\n\n    # If the input array is boolean, label it\n    if ar.dtype == np.bool_:\n        labeled_array, num_features = ndi.label(ar, structure=ndi.generate_binary_structure(ar.ndim, connectivity))\n    else:\n        labeled_array = ar\n\n    # Count the size of each labeled object\n    sizes = np.bincount(labeled_array.ravel())\n    \n    # Create a mask for small objects\n    mask = sizes >= min_size\n    \n    # Create the output array\n    if out is None:\n        out = np.zeros_like(labeled_array)\n    else:\n        if out.shape != labeled_array.shape:\n            raise ValueError(\"Output array 'out' must have the same shape as 'ar'.\")\n\n    # Remove small objects\n    for label in range(1, len(sizes)):\n        if mask[label]:\n            out[labeled_array == label] = label\n\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image():\n    labeled_image = np.array([[2, 2, 2, 0, 1], [2, 2, 2, 0, 1], [2, 0, 0, 0,\n        0], [0, 0, 3, 3, 3]], dtype=int)\n    expected = np.array([[2, 2, 2, 0, 0], [2, 2, 2, 0, 0], [2, 0, 0, 0, 0],\n        [0, 0, 3, 3, 3]], dtype=int)\n    observed = remove_small_objects(labeled_image, min_size=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image():\n    labeled_image = np.array([[2, 2, 2, 0, 1], [2, 2, 2, 0, 1], [2, 0, 0, 0,\n        0], [0, 0, 3, 3, 3]], dtype=np.uint8)\n    expected = np.array([[2, 2, 2, 0, 0], [2, 2, 2, 0, 0], [2, 0, 0, 0, 0],\n        [0, 0, 3, 3, 3]], dtype=np.uint8)\n    observed = remove_small_objects(labeled_image, min_size=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}], "method_code_mask": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_objects(ar, min_size=64, connectivity=1, *, out=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "remove_small_holes", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/misc.py", "response": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_holes(ar, area_threshold=64, connectivity=1, *, out=None):\n    # Validate input types\n    if not isinstance(ar, (np.ndarray, np.generic)):\n        raise TypeError(\"Input must be an ndarray.\")\n    if ar.dtype.kind not in {'b', 'i'}:\n        raise TypeError(\"Input array must be of type int or bool.\")\n    if np.any(ar < 0):\n        raise ValueError(\"Input array must not contain negative values.\")\n    \n    # Ensure the output array is created if not provided\n    if out is None:\n        out = np.zeros_like(ar, dtype=bool)\n    \n    # Label the connected components\n    labeled_array, num_features = ndi.label(ar, structure=ndi.generate_binary_structure(ar.ndim, connectivity))\n    \n    # Get the sizes of each labeled component\n    sizes = np.bincount(labeled_array.ravel())\n    \n    # Create a mask for components that are smaller than the area threshold\n    small_holes_mask = sizes < area_threshold\n    \n    # Fill small holes\n    for label in np.unique(labeled_array):\n        if small_holes_mask[label]:\n            out[labeled_array == label] = True\n    \n    # Return the output array\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_labeled_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=int)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_labeled_image_holes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy as sp\nfrom skimage.morphology import remove_small_objects\nfrom skimage.morphology import remove_small_holes\nfrom skimage.morphology import local_maxima\nfrom skimage.morphology import label\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared._warnings import expected_warnings\ndef test_uint_image_holes():\n    labeled_holes_image = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, \n        1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, \n        1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, \n        0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, \n        0, 0, 2, 2, 2]], dtype=np.uint8)\n    expected = np.array([[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1,\n        0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, \n        0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, \n        1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, \n        1]], dtype=bool)\n    with expected_warnings(['returned as a boolean array']):\n        observed = remove_small_holes(labeled_holes_image, area_threshold=3)\n    assert_array_equal(observed, expected)\n\ntest_uint_image_holes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_misc.py"}], "method_code_mask": "import numpy as np\nimport functools\nfrom scipy import ndimage as ndi\nfrom scipy.spatial import cKDTree\n\n\ndef remove_small_holes(ar, area_threshold=64, connectivity=1, *, out=None): [M\n    ASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "skeletonize", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef skeletonize(image, *, method=None):\n    if method is None:\n        raise ValueError(\"Method must be specified. Use 'zhang' or 'lee'.\")\n\n    if method == 'zhang':\n        # Zhang's thinning algorithm\n        # Create a copy of the image to store the skeleton\n        skeleton = np.zeros_like(image, dtype=bool)\n        # Define the structuring element for 2D images\n        se = np.array([[0, 1, 0],\n                       [1, 1, 1],\n                       [0, 1, 0]], dtype=bool)\n\n        # Thinning process\n        while True:\n            # Erosion\n            eroded = ndi.binary_erosion(image, structure=se)\n            # Skeleton update\n            skeleton |= eroded\n            # Subtract the eroded image from the original\n            temp = image.copy()\n            temp[eroded] = 0\n            # Thinning step\n            temp = ndi.binary_erosion(temp, structure=se)\n            # Check if the image has changed\n            if np.array_equal(temp, eroded):\n                break\n            image = temp\n\n    elif method == 'lee':\n        # Lee's thinning algorithm\n        # Create a copy of the image to store the skeleton\n        skeleton = np.zeros_like(image, dtype=bool)\n        # Define the structuring element for 3D images\n        se = np.array([[0, 1, 0],\n                       [1, 1, 1],\n                       [0, 1, 0]], dtype=bool)\n\n        # Thinning process\n        while True:\n            # Erosion\n            eroded = ndi.binary_erosion(image, structure=se)\n            # Skeleton update\n            skeleton |= eroded\n            # Subtract the eroded image from the original\n            temp = image.copy()\n            temp[eroded] = 0\n            # Thinning step\n            temp = ndi.binary_erosion(temp, structure=se)\n            # Check if the image has changed\n            if np.array_equal(temp, eroded):\n                break\n            image = temp\n\n    else:\n        raise ValueError(\"Invalid method specified. Use 'zhang' or 'lee'.\")\n\n    return skeleton", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nimport scipy.ndimage as ndi\nfrom skimage import io\nfrom skimage import draw\nfrom skimage.data import binary_blobs\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import skeletonize_3d\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import parametrize\nfrom skimage._shared.testing import fetch\ndef test_skeletonize_1D_old_api():\n    im = np.ones((5, 1), dtype=bool)\n    res = skeletonize(im)\n    assert_equal(res, im)\n\ntest_skeletonize_1D_old_api()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize_3d.py"}, {"test_code": "import numpy as np\nimport pytest\nimport scipy.ndimage as ndi\nfrom skimage import io\nfrom skimage import draw\nfrom skimage.data import binary_blobs\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import skeletonize_3d\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_\nfrom skimage._shared.testing import parametrize\nfrom skimage._shared.testing import fetch\ndef test_skeletonize_no_foreground():\n    im = np.zeros((5, 5), dtype=bool)\n    result = skeletonize(im, method='lee')\n    assert_equal(result, im)\n\ntest_skeletonize_no_foreground()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize_3d.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_no_foreground(self):\n\t    im = np.zeros((5, 5))\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, np.zeros((5, 5)))\n\t\nTestSkeletonize().test_skeletonize_no_foreground()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_single_point(self):\n\t    im = np.zeros((5, 5), dtype=bool)\n\t    im[3, 3] = 1\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, im)\n\t\nTestSkeletonize().test_skeletonize_single_point()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_already_thinned(self):\n\t    im = np.zeros((5, 5), dtype=bool)\n\t    im[3, 1:-1] = 1\n\t    im[2, -1] = 1\n\t    im[4, 0] = 1\n\t    result = skeletonize(im)\n\t    assert_array_equal(result, im)\n\t\nTestSkeletonize().test_skeletonize_already_thinned()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_skeletonize_output(self):\n\t    im = imread(fetch('data/bw_text.png'), as_gray=True)\n\t    im = im == 0\n\t    result = skeletonize(im)\n\t    expected = np.load(fetch('data/bw_text_skeleton.npy'))\n\t    assert_array_equal(result, expected)\n\t\nTestSkeletonize().test_skeletonize_output()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestSkeletonize():\n\tdef test_lut_fix(self):\n\t    im = np.zeros((6, 6), dtype=bool)\n\t    im[1, 2] = 1\n\t    im[2, 2] = 1\n\t    im[2, 3] = 1\n\t    im[3, 3] = 1\n\t    im[3, 4] = 1\n\t    im[4, 4] = 1\n\t    im[4, 5] = 1\n\t    result = skeletonize(im)\n\t    expected = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, \n\t        1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0\n\t        ]], dtype=bool)\n\t    assert np.all(result == expected)\n\t\nTestSkeletonize().test_lut_fix()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef skeletonize(image, *, method=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "max_tree_local_maxima", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/max_tree.py", "response": "import numpy as np\n\n\ndef max_tree_local_maxima(image, connectivity=1, parent=None,\n    tree_traverser=None):\n    if parent is None or tree_traverser is None:\n        # Compute the max-tree representation of the image\n        # This part is assumed to be implemented elsewhere\n        parent, tree_traverser = compute_max_tree(image, connectivity)\n\n    # Initialize the local maxima label array\n    local_max = np.zeros(image.shape, dtype=np.uint64)\n    label = 1  # Start labeling from 1\n\n    # Create a visited array to keep track of processed pixels\n    visited = np.zeros(image.shape, dtype=bool)\n\n    # Iterate through the tree traverser to find local maxima\n    for index in tree_traverser:\n        x, y = np.unravel_index(index, image.shape)\n        if visited[x, y]:\n            continue  # Skip if already visited\n\n        # Check if the current pixel is a local maximum\n        is_local_max = True\n        current_value = image[x, y]\n\n        # Check neighbors based on connectivity\n        if connectivity == 1:  # 4-connectivity\n            neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        elif connectivity == 2:  # 8-connectivity\n            neighbors = [(x-1, y-1), (x-1, y), (x-1, y+1),\n                         (x, y-1), (x, y+1),\n                         (x+1, y-1), (x+1, y), (x+1, y+1)]\n        else:\n            raise ValueError(\"Invalid connectivity value. Use 1 for 4-connectivity or 2 for 8-connectivity.\")\n\n        for nx, ny in neighbors:\n            if 0 <= nx < image.shape[0] and 0 <= ny < image.shape[1]:\n                if image[nx, ny] >= current_value:\n                    is_local_max = False\n                    break\n\n        if is_local_max:\n            # Label the local maximum and mark all connected pixels\n            local_max[x, y] = label\n            label += 1\n\n            # Use a stack to label all connected pixels with the same value\n            stack = [(x, y)]\n            while stack:\n                cx, cy = stack.pop()\n                visited[cx, cy] = True\n\n                for nx, ny in neighbors:\n                    if (0 <= nx < image.shape[0] and 0 <= ny < image.shape[1] and\n                        not visited[nx, ny] and image[nx, ny] == current_value):\n                        local_max[nx, ny] = label - 1\n                        stack.append((nx, ny))\n\n    return local_max", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_local_maxima(self):\n\t    \"\"\"local maxima for various data types\"\"\"\n\t    data = np.array([[10, 11, 13, 14, 14, 15, 14, 14, 13, 11], [11, 13, 15,\n\t        16, 16, 16, 16, 16, 15, 13], [13, 15, 40, 40, 18, 18, 18, 60, 60, \n\t        15], [14, 16, 40, 40, 19, 19, 19, 60, 60, 16], [14, 16, 18, 19, 19,\n\t        19, 19, 19, 18, 16], [15, 16, 18, 19, 19, 20, 19, 19, 18, 16], [14,\n\t        16, 18, 19, 19, 19, 19, 19, 18, 16], [14, 16, 80, 80, 19, 19, 19, \n\t        100, 100, 16], [13, 15, 80, 80, 18, 18, 18, 100, 100, 15], [11, 13,\n\t        15, 16, 16, 16, 16, 16, 15, 13]], dtype=np.uint8)\n\t    expected_result = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, \n\t        0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, \n\t        0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, \n\t        1, 1, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n\t        0, 0]], dtype=np.uint64)\n\t    for dtype in [np.uint8, np.uint64, np.int8, np.int64]:\n\t        test_data = data.astype(dtype)\n\t        out = max_tree_local_maxima(test_data, connectivity=1)\n\t        out_bin = out > 0\n\t        assert_array_equal(expected_result, out_bin)\n\t        assert out.dtype == expected_result.dtype\n\t        assert np.max(out) == 5\n\t        P, S = max_tree(test_data)\n\t        out = max_tree_local_maxima(test_data, parent=P, tree_traverser=S)\n\t        assert_array_equal(expected_result, out_bin)\n\t        assert out.dtype == expected_result.dtype\n\t        assert np.max(out) == 5\n\t\nTestMaxtree().test_local_maxima()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_extrema_float(self):\n\t    \"\"\"specific tests for float type\"\"\"\n\t    data = np.array([[0.1, 0.11, 0.13, 0.14, 0.14, 0.15, 0.14, 0.14, 0.13, \n\t        0.11], [0.11, 0.13, 0.15, 0.16, 0.16, 0.16, 0.16, 0.16, 0.15, 0.13],\n\t        [0.13, 0.15, 0.4, 0.4, 0.18, 0.18, 0.18, 0.6, 0.6, 0.15], [0.14, \n\t        0.16, 0.4, 0.4, 0.19, 0.19, 0.19, 0.6, 0.6, 0.16], [0.14, 0.16, \n\t        0.18, 0.19, 0.19, 0.19, 0.19, 0.19, 0.18, 0.16], [0.15, 0.182, 0.18,\n\t        0.19, 0.204, 0.2, 0.19, 0.19, 0.18, 0.16], [0.14, 0.16, 0.18, 0.19,\n\t        0.19, 0.19, 0.19, 0.19, 0.18, 0.16], [0.14, 0.16, 0.8, 0.8, 0.19, \n\t        0.19, 0.19, 4.0, 1.0, 0.16], [0.13, 0.15, 0.8, 0.8, 0.18, 0.18, \n\t        0.18, 1.0, 1.0, 0.15], [0.11, 0.13, 0.15, 0.16, 0.16, 0.16, 0.16, \n\t        0.16, 0.15, 0.13]], dtype=np.float32)\n\t    expected_result = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, \n\t        0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, \n\t        0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, \n\t        1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, \n\t        0, 0]], dtype=np.uint8)\n\t    out = max_tree_local_maxima(data, connectivity=1)\n\t    out_bin = out > 0\n\t    assert_array_equal(expected_result, out_bin)\n\t    assert np.max(out) == 6\n\t\nTestMaxtree().test_extrema_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}, {"test_code": "import numpy as np\nfrom skimage.morphology import max_tree\nfrom skimage.morphology import area_closing\nfrom skimage.morphology import area_opening\nfrom skimage.morphology import max_tree_local_maxima\nfrom skimage.morphology import diameter_opening\nfrom skimage.morphology import diameter_closing\nfrom skimage.util import invert\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import TestCase\n\nclass TestMaxtree(TestCase):\n\tdef test_3d(self):\n\t    \"\"\"tests the detection of maxima in 3D.\"\"\"\n\t    img = np.zeros((8, 8, 8), dtype=np.uint8)\n\t    local_maxima = np.zeros((8, 8, 8), dtype=np.uint64)\n\t    img[1, 1:3, 1:3] = 100\n\t    img[2, 2, 2] = 200\n\t    img[3, 1:3, 1:3] = 100\n\t    local_maxima[2, 2, 2] = 1\n\t    img[5:8, 1, 1] = 200\n\t    local_maxima[5:8, 1, 1] = 1\n\t    img[0, 5:8, 5:8] = 200\n\t    img[1, 6, 6] = 100\n\t    img[2, 5:7, 5:7] = 200\n\t    img[0:3, 5:8, 5:8] += 50\n\t    local_maxima[0, 5:8, 5:8] = 1\n\t    local_maxima[2, 5:7, 5:7] = 1\n\t    img[6:8, 6:8, 6:8] = 200\n\t    img[7, 7, 7] = 255\n\t    local_maxima[7, 7, 7] = 1\n\t    out = max_tree_local_maxima(img)\n\t    out_bin = out > 0\n\t    assert_array_equal(local_maxima, out_bin)\n\t    assert np.max(out) == 5\n\t\nTestMaxtree().test_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_max_tree.py"}], "method_code_mask": "import numpy as np\n\n\ndef max_tree_local_maxima(image, connectivity=1, parent=None,\n    tree_traverser=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "disk", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "response": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef disk(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None):\n    if not isinstance(radius, Integral) or radius < 0:\n        raise ValueError(\"Radius must be a non-negative integer.\")\n    \n    if not strict_radius:\n        radius = radius + 0.5\n\n    # Create a grid of (x, y) coordinates\n    y, x = np.ogrid[-radius:radius+1, -radius:radius+1]\n    # Create a mask for the disk\n    mask = x**2 + y**2 <= radius**2\n\n    footprint = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=dtype)\n    footprint[mask] = 1\n\n    if decomposition is None:\n        return footprint\n    elif decomposition == 'sequence':\n        # Generate smaller footprints\n        footprints = []\n        for r in range(1, radius + 1):\n            small_footprint = disk(r, dtype=dtype)\n            footprints.append(small_footprint)\n        return footprints, len(footprints)\n    elif decomposition == 'crosses':\n        # Generate cross-shaped footprints\n        crosses = []\n        for r in range(1, radius + 1):\n            cross = np.zeros((2 * r + 1, 2 * r + 1), dtype=dtype)\n            cross[r, :] = 1\n            cross[:, r] = 1\n            crosses.append(cross)\n        return crosses, len(crosses)\n    else:\n        raise ValueError(\"Invalid decomposition method. Use None, 'sequence', or 'crosses'.\")", "test_code_list": [{"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float(self):\n\t    image_uint = img_as_ubyte(data.camera()[:50, :50])\n\t    image_float = img_as_float(image_uint)\n\t    methods = ['autolevel', 'equalize', 'gradient', 'threshold',\n\t        'subtract_mean', 'enhance_contrast', 'pop']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_uint, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(image_float, disk(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed(self):\n\t    image = img_as_ubyte(data.camera())[::2, ::2]\n\t    image[image > 127] = 0\n\t    image_s = image.astype(np.int8)\n\t    image_u = img_as_ubyte(image_s)\n\t    assert_equal(image_u, img_as_ubyte(image_s))\n\t    methods = ['autolevel', 'equalize', 'gradient', 'maximum', 'mean',\n\t        'geometric_mean', 'subtract_mean', 'median', 'minimum', 'modal',\n\t        'enhance_contrast', 'pop', 'threshold']\n\t    for method in methods:\n\t        func = getattr(rank, method)\n\t        out_u = func(image_u, disk(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(image_s, disk(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_median_default_value(self):\n\t    a = np.zeros((3, 3), dtype=np.uint8)\n\t    a[1] = 1\n\t    full_footprint = np.ones((3, 3), dtype=np.uint8)\n\t    assert_equal(rank.median(a), rank.median(a, full_footprint))\n\t    assert rank.median(a)[1, 1] == 0\n\t    assert rank.median(a, disk(1))[1, 1] == 1\n\t\nTestRank().test_median_default_value()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}], "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef disk(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None): [M\n    ASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "isotropic_erosion", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/isotropic.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef isotropic_erosion(image, radius, out=None, spacing=None):\n    # Compute the distance transform of the input image\n    distance = ndi.distance_transform_edt(image, sampling=spacing)\n    \n    # Create a binary mask where the distance is less than or equal to the specified radius\n    mask = distance <= radius\n    \n    # Perform the erosion by applying the mask to the input image\n    if out is None:\n        out = np.empty_like(image, dtype=bool)\n    \n    out[:] = mask & image\n    \n    return out", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom skimage import color\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage.morphology import binary\nfrom skimage.util import img_as_bool\ndef test_footprint_overflow():\n    img = np.zeros((20, 20), dtype=bool)\n    img[2:19, 2:19] = True\n    isotropic_res = isotropic_erosion(img, 9)\n    binary_res = img_as_bool(binary.binary_erosion(img, morphology.disk(9)))\n    assert_array_equal(isotropic_res, binary_res)\n\ntest_footprint_overflow()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_isotropic.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef isotropic_erosion(image, radius, out=None, spacing=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "thin", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef thin(image, max_num_iter=None):\n    # Ensure the input image is a boolean array\n    image = image.astype(bool)\n    out = image.copy()\n    \n    # Define the 8-connected neighborhood\n    struct_elem = np.array([[1, 1, 1],\n                            [1, 0, 1],\n                            [1, 1, 1]], dtype=bool)\n\n    # Define the thinning subiteration masks\n    subiteration_masks = [\n        np.array([[0, 1, 0],\n                  [1, 1, 1],\n                  [0, 1, 0]], dtype=bool),\n        np.array([[1, 0, 0],\n                  [1, 1, 1],\n                  [0, 1, 0]], dtype=bool),\n        np.array([[0, 1, 1],\n                  [0, 1, 0],\n                  [0, 1, 0]], dtype=bool),\n        np.array([[0, 0, 1],\n                  [1, 1, 1],\n                  [0, 0, 1]], dtype=bool)\n    ]\n\n    for _ in range(max_num_iter if max_num_iter is not None else np.inf):\n        prev_out = out.copy()\n        \n        for mask in subiteration_masks:\n            # Identify pixels to remove\n            to_remove = ndi.binary_erosion(out, structure=mask)\n            to_remove = to_remove & ndi.binary_dilation(out, structure=struct_elem)\n            out = out & ~to_remove\n        \n        # Stop if no changes occurred\n        if np.array_equal(out, prev_out):\n            break\n\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestThin():\n\tdef test_zeros(self):\n\t    image = np.zeros((10, 10), dtype=bool)\n\t    assert np.all(thin(image) == False)\n\t\nTestThin().test_zeros()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef thin(image, max_num_iter=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_generate_thin_luts", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _generate_thin_luts():\n    g123_lut = np.zeros(256, dtype=bool)\n    g123p_lut = np.zeros(256, dtype=bool)\n\n    # Define the conditions for g123_lut\n    for i in range(256):\n        # Convert the index to a binary representation of 8 bits\n        binary = [(i >> j) & 1 for j in range(8)]\n        # Count the number of 1s (foreground pixels)\n        num_ones = sum(binary)\n\n        # Check the conditions for g123_lut\n        if num_ones >= 2 and num_ones <= 6:\n            # Check specific patterns for thinning\n            if (binary[0] + binary[1] + binary[2] >= 1 and\n                binary[2] + binary[3] + binary[4] >= 1 and\n                binary[4] + binary[5] + binary[6] >= 1 and\n                binary[6] + binary[7] + binary[0] >= 1):\n                g123_lut[i] = True\n\n    # Define the conditions for g123p_lut\n    for i in range(256):\n        binary = [(i >> j) & 1 for j in range(8)]\n        num_ones = sum(binary)\n\n        # Check the conditions for g123p_lut\n        if num_ones >= 2 and num_ones <= 6:\n            if (binary[1] + binary[2] + binary[3] >= 1 and\n                binary[3] + binary[4] + binary[5] >= 1 and\n                binary[5] + binary[6] + binary[7] >= 1 and\n                binary[7] + binary[0] + binary[1] >= 1):\n                g123p_lut[i] = True\n\n    return g123_lut, g123p_lut", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestThin():\n\tdef test_lut_generation(self):\n\t    g123, g123p = _generate_thin_luts()\n\t    assert_array_equal(g123, G123_LUT)\n\t    assert_array_equal(g123p, G123P_LUT)\n\t\nTestThin().test_lut_generation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _generate_thin_luts(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "medial_axis", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_skeletonize.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef medial_axis(image, mask=None, return_distance=False, *, rng=None):\n    if mask is not None:\n        image = image * mask\n\n    # Compute the distance transform\n    dist = ndi.distance_transform_edt(image)\n\n    # Compute the medial axis (skeleton)\n    skeleton = ndi.binary_erosion(image)\n    skeleton = ndi.binary_dilation(skeleton)\n\n    # Create the medial axis by subtracting the skeleton from the original image\n    medial_axis = image - skeleton\n\n    # If a random number generator is provided, use it for tiebreaking\n    if rng is not None:\n        rng = np.random.default_rng(rng)\n        # Randomize the order of processing pixels\n        order = rng.permutation(np.flatnonzero(medial_axis))\n        medial_axis = np.zeros_like(image, dtype=bool)\n        for idx in order:\n            medial_axis.flat[idx] = True\n\n    if return_distance:\n        return medial_axis, dist\n    return medial_axis", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_00_00_zeros(self):\n\t    \"\"\"Test skeletonize on an array of all zeros\"\"\"\n\t    result = medial_axis(np.zeros((10, 10), bool))\n\t    assert np.all(result == False)\n\t\nTestMedialAxis().test_00_00_zeros()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_00_01_zeros_masked(self):\n\t    \"\"\"Test skeletonize on an array that is completely masked\"\"\"\n\t    result = medial_axis(np.zeros((10, 10), bool), np.zeros((10, 10), bool))\n\t    assert np.all(result == False)\n\t\nTestMedialAxis().test_00_01_zeros_masked()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_01_01_rectangle(self):\n\t    \"\"\"Test skeletonize on a rectangle\"\"\"\n\t    image = np.zeros((9, 15), bool)\n\t    image[1:-1, 1:-1] = True\n\t    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0,\n\t        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0,\n\t        0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n\t        [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0,\n\t        0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,\n\t        0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, \n\t        0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n\t    result = medial_axis(image)\n\t    assert np.all(result == expected)\n\t    result, distance = medial_axis(image, return_distance=True)\n\t    assert distance.max() == 4\n\t\nTestMedialAxis().test_01_01_rectangle()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_01_02_hole(self):\n\t    \"\"\"Test skeletonize on a rectangle with a hole in the middle\"\"\"\n\t    image = np.zeros((9, 15), bool)\n\t    image[1:-1, 1:-1] = True\n\t    image[4, 4:-4] = False\n\t    expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0,\n\t        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1,\n\t        1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n\t        [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0,\n\t        0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n\t        0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, \n\t        0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=bool)\n\t    result = medial_axis(image)\n\t    assert np.all(result == expected)\n\t\nTestMedialAxis().test_01_02_hole()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import correlate\nfrom skimage import draw\nfrom skimage._shared.testing import fetch\nfrom skimage.io import imread\nfrom skimage.morphology import medial_axis\nfrom skimage.morphology import skeletonize\nfrom skimage.morphology import thin\nfrom skimage.morphology._skeletonize import G123_LUT\nfrom skimage.morphology._skeletonize import G123P_LUT\nfrom skimage.morphology._skeletonize import _generate_thin_luts\n\nclass TestMedialAxis():\n\tdef test_narrow_image(self):\n\t    \"\"\"Test skeletonize on a 1-pixel thin strip\"\"\"\n\t    image = np.zeros((1, 5), bool)\n\t    image[:, 1:-1] = True\n\t    result = medial_axis(image)\n\t    assert np.all(result == image)\n\t\nTestMedialAxis().test_narrow_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_skeletonize.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef medial_axis(image, mask=None, return_distance=False, *, rng=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "flood_fill", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_flood_fill.py", "response": "import numpy as np\n\n\ndef flood_fill(image, seed_point, new_value, *, footprint=None,\n    connectivity=None, tolerance=None, in_place=False):\n    \n    if not in_place:\n        image = image.copy()\n    \n    # Get the shape of the image\n    shape = image.shape\n    \n    # Initialize a mask to keep track of filled areas\n    filled = np.zeros(shape, dtype=bool)\n    \n    # Get the seed value\n    seed_value = image[seed_point]\n    \n    # Define a function to check if a point is within the tolerance\n    def within_tolerance(value):\n        return abs(value - seed_value) <= tolerance if tolerance is not None else True\n    \n    # Define a stack for the flood fill algorithm\n    stack = [seed_point]\n    \n    while stack:\n        point = stack.pop()\n        \n        # Check if the point is within the image bounds\n        if any(p < 0 or p >= s for p, s in zip(point, shape)):\n            continue\n        \n        # Check if the point has already been filled\n        if filled[point]:\n            continue\n        \n        # Check if the point matches the seed value or is within tolerance\n        if within_tolerance(image[point]):\n            # Fill the point with the new value\n            image[point] = new_value\n            filled[point] = True\n            \n            # Add neighboring points to the stack\n            if footprint is not None:\n                # Use the footprint to determine neighbors\n                for dx in range(-footprint.shape[0]//2, footprint.shape[0]//2 + 1):\n                    for dy in range(-footprint.shape[1]//2, footprint.shape[1]//2 + 1):\n                        if footprint[dx + footprint.shape[0]//2, dy + footprint.shape[1]//2]:\n                            neighbor = (point[0] + dx, point[1] + dy)\n                            stack.append(neighbor)\n            else:\n                # Use connectivity to determine neighbors\n                for dx in range(-1, 2):\n                    for dy in range(-1, 2):\n                        if connectivity is None or (dx**2 + dy**2 <= connectivity):\n                            neighbor = (point[0] + dx, point[1] + dy)\n                            stack.append(neighbor)\n    \n    return image", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_empty_input():\n    output = flood_fill(np.empty(0), (), 2)\n    assert output.size == 0\n    assert flood(np.empty(0), ()).dtype == bool\n    assert flood(np.empty((20, 0, 4)), ()).shape == (20, 0, 4)\n\ntest_empty_input()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_overrange_tolerance_float():\n    max_value = np.finfo(np.float32).max\n    image = np.random.uniform(size=(64, 64), low=-1.0, high=1.0).astype(np.\n        float32)\n    image *= max_value\n    expected = np.ones_like(image)\n    output = flood_fill(image, (0, 1), 1.0, tolerance=max_value.item() * 10)\n    np.testing.assert_equal(output, expected)\n\ntest_overrange_tolerance_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_int():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]])\n    flood_fill(image, (0, 0), 5, in_place=True)\n    expected = np.array([[5, 5, 5, 5, 5, 5, 5], [5, 1, 1, 5, 2, 2, 5], [5, \n        1, 1, 5, 2, 2, 5], [1, 5, 5, 5, 5, 5, 3], [5, 1, 1, 1, 3, 3, 4]])\n    np.testing.assert_array_equal(image, expected)\n\ntest_inplace_int()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_float():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]],\n        dtype=np.float32)\n    flood_fill(image, (0, 0), 5, in_place=True)\n    expected = np.array([[5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [5.0, 1.0, \n        1.0, 5.0, 2.0, 2.0, 5.0], [5.0, 1.0, 1.0, 5.0, 2.0, 2.0, 5.0], [1.0,\n        5.0, 5.0, 5.0, 5.0, 5.0, 3.0], [5.0, 1.0, 1.0, 1.0, 3.0, 3.0, 4.0]],\n        dtype=np.float32)\n    np.testing.assert_allclose(image, expected)\n\ntest_inplace_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_inplace_noncontiguous():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]])\n    image2 = image[::2, ::2]\n    flood_fill(image2, (0, 0), 5, in_place=True)\n    expected2 = np.array([[5, 5, 5, 5], [5, 1, 2, 5], [5, 1, 3, 4]])\n    np.testing.assert_allclose(image2, expected2)\n    expected = np.array([[5, 0, 5, 0, 5, 0, 5], [0, 1, 1, 0, 2, 2, 0], [5, \n        1, 1, 0, 2, 2, 5], [1, 0, 0, 0, 0, 0, 3], [5, 1, 1, 1, 3, 3, 4]])\n    np.testing.assert_allclose(image, expected)\n\ntest_inplace_noncontiguous()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_1d():\n    image = np.arange(11)\n    expected = np.array([0, 1, -20, -20, -20, -20, -20, -20, -20, 9, 10])\n    output = flood_fill(image, 5, -20, tolerance=3)\n    output2 = flood_fill(image, (5,), -20, tolerance=3)\n    np.testing.assert_equal(output, expected)\n    np.testing.assert_equal(output, output2)\n\ntest_1d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_wraparound():\n    test = np.zeros((5, 7), dtype=np.float64)\n    test[:, 3] = 100\n    expected = np.array([[-1.0, -1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -\n        1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -1.0, -1.0, 100.0, 0.0, \n        0.0, 0.0], [-1.0, -1.0, -1.0, 100.0, 0.0, 0.0, 0.0], [-1.0, -1.0, -\n        1.0, 100.0, 0.0, 0.0, 0.0]])\n    np.testing.assert_equal(flood_fill(test, (0, 0), -1), expected)\n\ntest_wraparound()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_neighbors():\n    test = np.zeros((5, 7), dtype=np.float64)\n    test[:, 3] = 100\n    expected = np.array([[0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0, 0, 0],\n        [0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0, 0, 0], [0, 0, 0, 255, 0,\n        0, 0]])\n    output = flood_fill(test, (0, 3), 255)\n    np.testing.assert_equal(output, expected)\n    test[2] = 100\n    expected[2] = 255\n    output2 = flood_fill(test, (2, 3), 255)\n    np.testing.assert_equal(output2, expected)\n\ntest_neighbors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_basic_nd():\n    for dimension in (3, 4, 5):\n        shape = (5,) * dimension\n        hypercube = np.zeros(shape)\n        slice_mid = tuple(slice(1, -1, None) for dim in range(dimension))\n        hypercube[slice_mid] = 1\n        filled = flood_fill(hypercube, (2,) * dimension, 2)\n        assert filled.sum() == 3 ** dimension * 2\n        np.testing.assert_equal(filled, np.pad(np.ones((3,) * dimension) * \n            2, 1, 'constant'))\n\ntest_basic_nd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_negative_indexing_seed_point():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0], [0, 1, \n        1, 0, 2, 2, 0], [1, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 3, 3, 4]],\n        dtype=np.float32)\n    expected = np.array([[5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], [5.0, 1.0, \n        1.0, 5.0, 2.0, 2.0, 5.0], [5.0, 1.0, 1.0, 5.0, 2.0, 2.0, 5.0], [1.0,\n        5.0, 5.0, 5.0, 5.0, 5.0, 3.0], [5.0, 1.0, 1.0, 1.0, 3.0, 3.0, 4.0]],\n        dtype=np.float32)\n    image = flood_fill(image, (0, -1), 5)\n    np.testing.assert_allclose(image, expected)\n\ntest_negative_indexing_seed_point()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}], "method_code_mask": "import numpy as np\n\n\ndef flood_fill(image, seed_point, new_value, *, footprint=None,\n    connectivity=None, tolerance=None, in_place=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "flood", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/_flood_fill.py", "response": "import numpy as np\n\n\ndef flood(image, seed_point, *, footprint=None, connectivity=None,\n    tolerance=None):\n    # Ensure the image is a numpy array\n    image = np.asarray(image)\n    \n    # Get the shape of the image\n    shape = image.shape\n    \n    # Initialize the mask with False\n    mask = np.zeros(shape, dtype=bool)\n    \n    # Get the initial value at the seed point\n    initial_value = image[seed_point]\n    \n    # Define a function to check if a value is within tolerance\n    def within_tolerance(value):\n        if tolerance is None:\n            return value == initial_value\n        return abs(value - initial_value) <= tolerance\n    \n    # Create a queue for the flood fill algorithm\n    queue = [seed_point]\n    mask[seed_point] = True\n    \n    while queue:\n        current = queue.pop(0)\n        \n        # Get the neighbors based on footprint or connectivity\n        if footprint is not None:\n            # Use footprint to determine neighbors\n            for i in range(footprint.shape[0]):\n                for j in range(footprint.shape[1]):\n                    if footprint[i, j]:\n                        neighbor = tuple(np.array(current) + np.array([i - footprint.shape[0] // 2, j - footprint.shape[1] // 2]))\n                        if (0 <= neighbor[0] < shape[0]) and (0 <= neighbor[1] < shape[1]) and not mask[neighbor]:\n                            if within_tolerance(image[neighbor]):\n                                mask[neighbor] = True\n                                queue.append(neighbor)\n        elif connectivity is not None:\n            # Use connectivity to determine neighbors\n            for dx in range(-connectivity, connectivity + 1):\n                for dy in range(-connectivity, connectivity + 1):\n                    if abs(dx) + abs(dy) <= connectivity:\n                        neighbor = (current[0] + dx, current[1] + dy)\n                        if (0 <= neighbor[0] < shape[0]) and (0 <= neighbor[1] < shape[1]) and not mask[neighbor]:\n                            if within_tolerance(image[neighbor]):\n                                mask[neighbor] = True\n                                queue.append(neighbor)\n    \n    return mask", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.morphology import flood\nfrom skimage.morphology import flood_fill\ndef test_empty_input():\n    output = flood_fill(np.empty(0), (), 2)\n    assert output.size == 0\n    assert flood(np.empty(0), ()).dtype == bool\n    assert flood(np.empty((20, 0, 4)), ()).shape == (20, 0, 4)\n\ntest_empty_input()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/tests/test_flood_fill.py"}], "method_code_mask": "import numpy as np\n\n\ndef flood(image, seed_point, *, footprint=None, connectivity=None,\n    tolerance=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "learn_gmm", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/_fisher_vector.py", "response": "import numpy as np\nfrom sklearn.mixture import GaussianMixture\n\n\ndef learn_gmm(descriptors, *, n_modes=32, gm_args=None):\n    if gm_args is None:\n        gm_args = {}\n    \n    # Check if descriptors is a list of arrays and concatenate if necessary\n    if isinstance(descriptors, list):\n        descriptors = np.vstack(descriptors)\n    \n    # Create the GaussianMixture model with the specified number of modes and covariance type\n    gmm = GaussianMixture(n_components=n_modes, covariance_type='diag', **gm_args)\n    \n    # Fit the model to the descriptors\n    gmm.fit(descriptors)\n    \n    return gmm", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom sklearn.mixture import GaussianMixture\ndef test_gmm_correct_covariance_type():\n    \"\"\"Test that GMM estimation is successful when the correct covariance type\n    is passed in as a keyword argument.\n    \"\"\"\n    gmm = learn_gmm(np.random.random((10, 10)), n_modes=2, gm_args={\n        'covariance_type': 'diag'})\n    assert gmm.means_ is not None\n    assert gmm.covariances_ is not None\n    assert gmm.weights_ is not None\n\ntest_gmm_correct_covariance_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_fisher_vector.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom sklearn.mixture import GaussianMixture\ndef test_gmm_e2e():\n    \"\"\"\n    Test the GMM estimation. Since this is essentially a wrapper for the\n    scikit-learn GaussianMixture class, the testing of the actual inner\n    workings of the GMM estimation is left to scikit-learn and its\n    dependencies.\n\n    We instead simply assert that the estimation was successful based on the\n    fact that the GMM object will have associated mixture weights, means, and\n    variances after estimation is successful/complete.\n    \"\"\"\n    gmm = learn_gmm(np.random.random((100, 64)), n_modes=5)\n    assert gmm.means_ is not None\n    assert gmm.covariances_ is not None\n    assert gmm.weights_ is not None\n\ntest_gmm_e2e()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_fisher_vector.py"}], "method_code_mask": "import numpy as np\nfrom sklearn.mixture import GaussianMixture\n\n\ndef learn_gmm(descriptors, *, n_modes=32, gm_args=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "ellipsoid", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/draw/draw3d.py", "response": "import numpy as np\nfrom scipy.special import ellipkinc as ellip_F\nfrom scipy.special import ellipeinc as ellip_E\n\n\ndef ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False):\n    # Create a grid of points\n    x = np.arange(-a, a + spacing[0], spacing[0])\n    y = np.arange(-b, b + spacing[1], spacing[1])\n    z = np.arange(-c, c + spacing[2], spacing[2])\n    \n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    \n    # Calculate the level set function for the ellipsoid\n    ellipsoid_eq = (X**2 / a**2) + (Y**2 / b**2) + (Z**2 / c**2) - 1\n    \n    if levelset:\n        return ellipsoid_eq.astype(np.float64)\n    else:\n        return (ellipsoid_eq <= 0).astype(bool)", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_3d():\n    r = 6\n    pad = 10\n    im3 = ellipsoid(r, r, r)\n    im3 = np.pad(im3, pad, mode='constant')\n    blobs = blob_log(im3, min_sigma=3, max_sigma=10)\n    b = blobs[0]\n    assert b.shape == (4,)\n    assert b[0] == r + pad + 1\n    assert b[1] == r + pad + 1\n    assert b[2] == r + pad + 1\n    assert abs(math.sqrt(3) * b[3] - r) < 1\n\ntest_blob_log_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_3d_anisotropic():\n    r = 6\n    pad = 10\n    im3 = ellipsoid(r / 2, r, r)\n    im3 = np.pad(im3, pad, mode='constant')\n    blobs = blob_log(im3, min_sigma=[1, 2, 2], max_sigma=[5, 10, 10])\n    b = blobs[0]\n    assert b.shape == (6,)\n    assert b[0] == r / 2 + pad + 1\n    assert b[1] == r + pad + 1\n    assert b[2] == r + pad + 1\n    assert abs(math.sqrt(3) * b[3] - r / 2) < 1\n    assert abs(math.sqrt(3) * b[4] - r) < 1\n    assert abs(math.sqrt(3) * b[5] - r) < 1\n\ntest_blob_log_3d_anisotropic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=2, max_sigma=10, overlap=0.1)\n    assert len(blobs) == 1\n\ntest_blob_log_overlap_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d_anisotropic():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=[2, 2.01, 2.005], max_sigma=10, overlap=0.1\n        )\n    assert len(blobs) == 1\n    overlap = _blob_overlap(np.array([0, 0, 10 / math.sqrt(2)]), np.array([\n        0, 10, 10 / math.sqrt(2)]))\n    assert_almost_equal(overlap, 1.0 / math.pi * (2 * math.acos(1.0 / 2) - \n        math.sqrt(3) / 2.0))\n\ntest_blob_log_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}], "method_code_mask": "import numpy as np\nfrom scipy.special import ellipkinc as ellip_F\nfrom scipy.special import ellipeinc as ellip_E\n\n\ndef ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_blob_overlap", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/blob.py", "response": "import math\nimport numpy as np\nimport scipy.ndimage as ndi\nfrom scipy import spatial\n\n\ndef _blob_overlap(blob1, blob2, *, sigma_dim=1):\n    # Determine the dimensionality of the blobs\n    dim1 = len(blob1) - 1  # Last element is sigma\n    dim2 = len(blob2) - 1  # Last element is sigma\n\n    if dim1 != dim2 or dim1 not in [2, 3]:\n        return 0.0  # Return 0.0 for invalid dimensions\n\n    # Extract coordinates and sigma\n    coords1 = np.array(blob1[:-1])\n    coords2 = np.array(blob2[:-1])\n    sigma1 = blob1[-1]\n    sigma2 = blob2[-1]\n\n    # Create a grid for the Gaussian blobs\n    if dim1 == 2:\n        grid_size = 100  # Define a grid size for 2D\n        x = np.linspace(-3 * sigma1, 3 * sigma1, grid_size)\n        y = np.linspace(-3 * sigma1, 3 * sigma1, grid_size)\n        X, Y = np.meshgrid(x, y)\n        blob1_gaussian = np.exp(-((X - coords1[0])**2 + (Y - coords1[1])**2) / (2 * sigma1**2))\n        \n        x = np.linspace(-3 * sigma2, 3 * sigma2, grid_size)\n        y = np.linspace(-3 * sigma2, 3 * sigma2, grid_size)\n        X, Y = np.meshgrid(x, y)\n        blob2_gaussian = np.exp(-((X - coords2[0])**2 + (Y - coords2[1])**2) / (2 * sigma2**2))\n\n    elif dim1 == 3:\n        grid_size = 20  # Define a grid size for 3D\n        x = np.linspace(-3 * sigma1, 3 * sigma1, grid_size)\n        y = np.linspace(-3 * sigma1, 3 * sigma1, grid_size)\n        z = np.linspace(-3 * sigma1, 3 * sigma1, grid_size)\n        X, Y, Z = np.meshgrid(x, y, z)\n        blob1_gaussian = np.exp(-((X - coords1[0])**2 + (Y - coords1[1])**2 + (Z - coords1[2])**2) / (2 * sigma1**2))\n        \n        x = np.linspace(-3 * sigma2, 3 * sigma2, grid_size)\n        y = np.linspace(-3 * sigma2, 3 * sigma2, grid_size)\n        z = np.linspace(-3 * sigma2, 3 * sigma2, grid_size)\n        X, Y, Z = np.meshgrid(x, y, z)\n        blob2_gaussian = np.exp(-((X - coords2[0])**2 + (Y - coords2[1])**2 + (Z - coords2[2])**2) / (2 * sigma2**2))\n\n    # Calculate the overlapping area/volume\n    overlap = np.sum(np.minimum(blob1_gaussian, blob2_gaussian))\n    total_area1 = np.sum(blob1_gaussian)\n    total_area2 = np.sum(blob2_gaussian)\n\n    # Calculate the fraction of overlap\n    f = overlap / min(total_area1, total_area2) if min(total_area1, total_area2) > 0 else 0.0\n\n    return f", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_overlap_3d_anisotropic():\n    s3 = math.sqrt(3)\n    overlap = _blob_overlap(np.array([0, 0, 0, 2 / s3, 10 / s3, 10 / s3]),\n        np.array([0, 0, 10, 0.2 / s3, 1 / s3, 1 / s3]), sigma_dim=3)\n    assert_almost_equal(overlap, 0.48125)\n    overlap = _blob_overlap(np.array([0, 0, 0, 2 / s3, 10 / s3, 10 / s3]),\n        np.array([2, 0, 0, 0.2 / s3, 1 / s3, 1 / s3]), sigma_dim=3)\n    assert_almost_equal(overlap, 0.48125)\n\ntest_blob_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom skimage import feature\nfrom skimage.draw import disk\nfrom skimage.draw.draw3d import ellipsoid\nfrom skimage.feature import blob_dog\nfrom skimage.feature import blob_doh\nfrom skimage.feature import blob_log\nfrom skimage.feature.blob import _blob_overlap\ndef test_blob_log_overlap_3d_anisotropic():\n    r1, r2 = 7, 6\n    pad1, pad2 = 11, 12\n    blob1 = ellipsoid(r1, r1, r1)\n    blob1 = np.pad(blob1, pad1, mode='constant')\n    blob2 = ellipsoid(r2, r2, r2)\n    blob2 = np.pad(blob2, [(pad2, pad2), (pad2 - 9, pad2 + 9), (pad2, pad2)\n        ], mode='constant')\n    im3 = np.logical_or(blob1, blob2)\n    blobs = blob_log(im3, min_sigma=[2, 2.01, 2.005], max_sigma=10, overlap=0.1\n        )\n    assert len(blobs) == 1\n    overlap = _blob_overlap(np.array([0, 0, 10 / math.sqrt(2)]), np.array([\n        0, 10, 10 / math.sqrt(2)]))\n    assert_almost_equal(overlap, 1.0 / math.pi * (2 * math.acos(1.0 / 2) - \n        math.sqrt(3) / 2.0))\n\ntest_blob_log_overlap_3d_anisotropic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_blob.py"}], "method_code_mask": "import math\nimport numpy as np\nimport scipy.ndimage as ndi\nfrom scipy import spatial\n\n\ndef _blob_overlap(blob1, blob2, *, sigma_dim=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_mask_border_keypoints", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/util.py", "response": "import numpy as np\n\n\ndef _mask_border_keypoints(image_shape, keypoints, distance):\n    rows, cols = image_shape\n    mask = np.zeros(len(keypoints), dtype=bool)\n    \n    for i, (row, col) in enumerate(keypoints):\n        if distance <= row < rows - distance and distance <= col < cols - distance:\n            mask[i] = True\n            \n    return mask", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.feature.util import FeatureDetector\nfrom skimage.feature.util import DescriptorExtractor\nfrom skimage.feature.util import _prepare_grayscale_input_2D\nfrom skimage.feature.util import _mask_border_keypoints\nfrom skimage.feature.util import plot_matches\nfrom matplotlib import pyplot as plt\nfrom matplotlib import use\ndef test_mask_border_keypoints():\n    keypoints = np.array([[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 0),\n        [1, 1, 1, 1, 1])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 2),\n        [0, 0, 1, 1, 1])\n    np.testing.assert_equal(_mask_border_keypoints((4, 4), keypoints, 2), [\n        0, 0, 1, 0, 0])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 5),\n        [0, 0, 0, 0, 0])\n    np.testing.assert_equal(_mask_border_keypoints((10, 10), keypoints, 4),\n        [0, 0, 0, 0, 1])\n\ntest_mask_border_keypoints()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/feature/tests/test_util.py"}], "method_code_mask": "import numpy as np\n\n\ndef _mask_border_keypoints(image_shape, keypoints, distance): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_stackcopy", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/_warps.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _stackcopy(a, b):\n    if a.ndim == 2:\n        a[:] = b  # Copy b into a if a is 2D\n    elif a.ndim == 3:\n        a[:] = np.stack([b] * a.shape[2], axis=-1)  # Copy b into each layer of a if a is 3D", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_stackcopy():\n    layers = 4\n    x = np.empty((3, 3, layers))\n    y = np.eye(3, 3)\n    _stackcopy(x, y)\n    for i in range(layers):\n        assert_array_almost_equal(x[..., i], y)\n\ntest_stackcopy()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _stackcopy(a, b): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "resize", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/_warps.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\nfrom skimage.transform import resize as skimage_resize\n\ndef resize(image, output_shape, order=None, mode='reflect', cval=0, clip=True, \n           preserve_range=False, anti_aliasing=None, anti_aliasing_sigma=None):\n    if order is None:\n        order = 0 if image.dtype == np.bool_ else 1\n\n    # Calculate the resize factors for each dimension\n    factors = [o / i for i, o in zip(image.shape, output_shape)]\n    \n    # Determine if we are downsampling or upsampling\n    if all(factor >= 1 for factor in factors):\n        # Upsampling\n        resized = skimage_resize(image, output_shape, order=order, mode=mode, \n                                  cval=cval, clip=clip, preserve_range=preserve_range, \n                                  anti_aliasing=anti_aliasing, anti_aliasing_sigma=anti_aliasing_sigma)\n    else:\n        # Downsampling\n        resized = ndi.zoom(image, factors, order=order, mode=mode, cval=cval)\n\n    if clip:\n        resized = np.clip(resized, a_min=image.min() if not preserve_range else None, \n                          a_max=image.max() if not preserve_range else None)\n\n    return resized", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize2d():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    resized = resize(x, (10, 10), order=0, anti_aliasing=False, mode='constant'\n        )\n    ref = np.zeros((10, 10))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize2d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_keep():\n    x = np.zeros((5, 5, 3), dtype=np.float64)\n    x[1, 1, :] = 1\n    resized = resize(x, (10, 10), order=0, anti_aliasing=False, mode='constant'\n        )\n    with pytest.raises(ValueError):\n        resize(x, (10,), order=0, anti_aliasing=False, mode='constant')\n    ref = np.zeros((10, 10, 3))\n    ref[2:4, 2:4, :] = 1\n    assert_array_almost_equal(resized, ref)\n    resized = resize(x, (10, 10, 3), order=0, anti_aliasing=False, mode=\n        'constant')\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_keep()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_resize():\n    x = np.zeros((5, 5, 3), dtype=np.float64)\n    x[1, 1, :] = 1\n    resized = resize(x, (10, 10, 1), order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros((10, 10, 1))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_resize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_2din_3dout():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    resized = resize(x, (10, 10, 1), order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros((10, 10, 1))\n    ref[2:4, 2:4] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_2din_3dout()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize2d_4d():\n    x = np.zeros((5, 5), dtype=np.float64)\n    x[1, 1] = 1\n    out_shape = 10, 10, 1, 1\n    resized = resize(x, out_shape, order=0, anti_aliasing=False, mode=\n        'constant')\n    ref = np.zeros(out_shape)\n    ref[2:4, 2:4, ...] = 1\n    assert_array_almost_equal(resized, ref)\n\ntest_resize2d_4d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize_nd():\n    for dim in range(1, 6):\n        shape = 2 + np.arange(dim) * 2\n        x = np.ones(shape)\n        out_shape = np.asarray(shape) * 1.5\n        resized = resize(x, out_shape, order=0, mode='reflect',\n            anti_aliasing=False)\n        expected_shape = 1.5 * shape\n        assert_array_equal(resized.shape, expected_shape)\n        assert np.all(resized == 1)\n\ntest_resize_nd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_resize3d_bilinear():\n    x = np.zeros((5, 5, 2), dtype=np.float64)\n    x[1, 1, 0] = 0\n    x[1, 1, 1] = 1\n    resized = resize(x, (10, 10, 1), order=1, mode='constant',\n        anti_aliasing=False)\n    ref = np.zeros((10, 10, 1))\n    ref[1:5, 1:5, :] = 0.03125\n    ref[1:5, 2:4, :] = 0.09375\n    ref[2:4, 1:5, :] = 0.09375\n    ref[2:4, 2:4, :] = 0.28125\n    assert_array_almost_equal(resized, ref)\n\ntest_resize3d_bilinear()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_downsize_anti_aliasing():\n    x = np.zeros((10, 10), dtype=np.float64)\n    x[2, 2] = 1\n    scaled = resize(x, (5, 5), order=1, anti_aliasing=True, mode='constant')\n    assert scaled.shape == (5, 5)\n    assert np.all(scaled[:3, :3] > 0)\n    assert scaled[3:, :].sum() == 0\n    assert scaled[:, 3:].sum() == 0\n    sigma = 0.125\n    out_size = 5, 5\n    resize(x, out_size, order=1, mode='constant', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='edge', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='symmetric', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='reflect', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    resize(x, out_size, order=1, mode='wrap', anti_aliasing=True,\n        anti_aliasing_sigma=sigma)\n    with pytest.raises(ValueError):\n        resize(x, out_size, order=1, mode='non-existent', anti_aliasing=\n            True, anti_aliasing_sigma=sigma)\n\ntest_downsize_anti_aliasing()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_bool_img_resize():\n    img = np.ones((12, 18), dtype=bool)\n    img[2:-2, 4:-4] = False\n    res = resize(img, (6, 9))\n    expected = np.ones((6, 9))\n    expected[1:-1, 2:-2] = False\n    assert_array_equal(res, expected)\n\ntest_bool_img_resize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef resize(image, output_shape, order=None, mode='reflect', cval=0, clip=\n    True, preserve_range=False, anti_aliasing=None, anti_aliasing_sigma=None\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "warp_coords", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/_warps.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef warp_coords(coord_map, shape, dtype=np.float64):\n    # Create a grid of output coordinates\n    rows, cols = shape[:2]\n    y_indices, x_indices = np.indices((rows, cols))\n    \n    # Stack the indices to create a (P, 2) array of output coordinates\n    output_coords = np.stack((x_indices.ravel(), y_indices.ravel()), axis=-1)\n    \n    # Use the coord_map to get the corresponding input coordinates\n    input_coords = coord_map(output_coords)\n    \n    # Reshape the input coordinates to the desired output shape\n    coords = input_coords.reshape(rows, cols, -1).astype(dtype)\n    \n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_warp_coords_example():\n    image = astronaut().astype(np.float32)\n    assert 3 == image.shape[2]\n    tform = SimilarityTransform(translation=(0, -10))\n    coords = warp_coords(tform, (30, 30, 3))\n    map_coordinates(image[:, :, 0], coords[:2])\n\ntest_warp_coords_example()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef warp_coords(coord_map, shape, dtype=np.float64): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_linear_polar_mapping", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/_warps.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _linear_polar_mapping(output_coords, k_angle, k_radius, center):\n    # Unpack the center coordinates\n    center_row, center_col = center\n    \n    # Initialize an array to hold the cartesian coordinates\n    coords = np.zeros_like(output_coords)\n    \n    # Calculate the cartesian coordinates for each output coordinate\n    for i, (col, row) in enumerate(output_coords):\n        # Calculate the angle and radius from the output coordinates\n        angle = row / k_angle  # Inverse scaling for angle\n        radius = col / k_radius  # Inverse scaling for radius\n        \n        # Convert polar to cartesian coordinates\n        cartesian_col = center_col + radius * np.cos(angle)\n        cartesian_row = center_row + radius * np.sin(angle)\n        \n        # Store the calculated coordinates\n        coords[i] = (cartesian_col, cartesian_row)\n    \n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_linear_polar_mapping():\n    output_coords = np.array([[0, 0], [0, 90], [0, 180], [0, 270], [99, 0],\n        [99, 180], [99, 270], [99, 45]])\n    ground_truth = np.array([[100, 100], [100, 100], [100, 100], [100, 100],\n        [199, 100], [1, 100], [100, 1], [170.00357134, 170.00357134]])\n    k_angle = 360 / (2 * np.pi)\n    k_radius = 1\n    center = 100, 100\n    coords = _linear_polar_mapping(output_coords, k_angle, k_radius, center)\n    assert np.allclose(coords, ground_truth)\n\ntest_linear_polar_mapping()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _linear_polar_mapping(output_coords, k_angle, k_radius, center): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_log_polar_mapping", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/_warps.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _log_polar_mapping(output_coords, k_angle, k_radius, center):\n    # Extract the center coordinates\n    center_row, center_col = center\n    \n    # Calculate the radius and angle for each output coordinate\n    rows, cols = output_coords[:, 0], output_coords[:, 1]\n    angles = (rows - center_row) * k_angle\n    radii = (cols - center_col) * k_radius\n    \n    # Convert polar coordinates back to Cartesian coordinates\n    x_coords = center_col + radii * np.cos(angles)\n    y_coords = center_row + radii * np.sin(angles)\n    \n    # Stack the coordinates into a single array\n    coords = np.column_stack((x_coords, y_coords))\n    \n    return coords", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom scipy.ndimage import map_coordinates\nfrom skimage._shared.testing import expected_warnings\nfrom skimage.color.colorconv import rgb2gray\nfrom skimage.data import checkerboard\nfrom skimage.data import astronaut\nfrom skimage.draw.draw import circle_perimeter_aa\nfrom skimage.feature.peak import peak_local_max\nfrom skimage.transform._warps import _stackcopy\nfrom skimage.transform._warps import _linear_polar_mapping\nfrom skimage.transform._warps import _log_polar_mapping\nfrom skimage.transform._warps import warp\nfrom skimage.transform._warps import warp_coords\nfrom skimage.transform._warps import rotate\nfrom skimage.transform._warps import resize\nfrom skimage.transform._warps import rescale\nfrom skimage.transform._warps import warp_polar\nfrom skimage.transform._warps import swirl\nfrom skimage.transform._warps import downscale_local_mean\nfrom skimage.transform._geometric import AffineTransform\nfrom skimage.transform._geometric import ProjectiveTransform\nfrom skimage.transform._geometric import SimilarityTransform\nfrom skimage.util.dtype import img_as_float\nfrom skimage.util.dtype import _convert\ndef test_log_polar_mapping():\n    output_coords = np.array([[0, 0], [0, 90], [0, 180], [0, 270], [99, 0],\n        [99, 180], [99, 270], [99, 45]])\n    ground_truth = np.array([[101, 100], [100, 101], [99, 100], [100, 99],\n        [195.4992586, 100], [4.5007414, 100], [100, 4.5007414], [\n        167.52817336, 167.52817336]])\n    k_angle = 360 / (2 * np.pi)\n    k_radius = 100 / np.log(100)\n    center = 100, 100\n    coords = _log_polar_mapping(output_coords, k_angle, k_radius, center)\n    assert np.allclose(coords, ground_truth)\n\ntest_log_polar_mapping()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_warps.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _log_polar_mapping(output_coords, k_angle, k_radius, center): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_rescale_intensity", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py", "response": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\n\n\ndef _rescale_intensity(x):\n    x_min = np.min(x)\n    x_max = np.max(x)\n    # Rescale the intensity values to the range [0, 1]\n    rescaled = (x - x_min) / (x_max - x_min)\n    return rescaled.astype(float)", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\ndef test_iradon_angles():\n    \"\"\"\n    Test with different number of projections\n    \"\"\"\n    size = 100\n    image = np.tri(size) + np.tri(size)[::-1]\n    nb_angles = 200\n    theta = np.linspace(0, 180, nb_angles, endpoint=False)\n    radon_image_200 = radon(image, theta=theta, circle=False)\n    reconstructed = iradon(radon_image_200, circle=False)\n    delta_200 = np.mean(abs(_rescale_intensity(image) - _rescale_intensity(\n        reconstructed)))\n    assert delta_200 < 0.03\n    nb_angles = 80\n    radon_image_80 = radon(image, theta=theta, circle=False)\n    s = radon_image_80.sum(axis=0)\n    assert np.allclose(s, s[0], rtol=0.01)\n    reconstructed = iradon(radon_image_80, circle=False)\n    delta_80 = np.mean(abs(image / np.max(image) - reconstructed / np.max(\n        reconstructed)))\n    assert delta_80 > delta_200\n\ntest_iradon_angles()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py"}], "method_code_mask": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\n\n\ndef _rescale_intensity(x): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "order_angles_golden_ratio", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/radon_transform.py", "response": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy.constants import golden_ratio\nfrom scipy.fft import fft\nfrom scipy.fft import ifft\nfrom scipy.fft import fftfreq\nfrom scipy.fft import fftshift\nfrom warnings import warn\nfrom functools import partial\n\n\ndef order_angles_golden_ratio(theta):\n    M = len(theta)\n    if M == 0:\n        return\n    if M != len(set(theta)):\n        raise ValueError(\"Input angles must not contain duplicates.\")\n\n    # Calculate the indices based on the golden ratio\n    indices = []\n    for i in range(M):\n        index = int(round(i * golden_ratio)) % M\n        indices.append(index)\n\n    # Yield indices in the order determined by the golden ratio\n    for index in indices:\n        yield index", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pytest\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.utils import convert_to_float\nfrom skimage.data import shepp_logan_phantom\nfrom skimage.transform import radon\nfrom skimage.transform import iradon\nfrom skimage.transform import iradon_sart\nfrom skimage.transform import rescale\nfrom matplotlib import pyplot as plt\nimport matplotlib.pyplot as plt\nfrom skimage.transform.radon_transform import _sinogram_circle_to_square\nfrom skimage.transform.radon_transform import order_angles_golden_ratio\ndef test_order_angles_golden_ratio():\n    from skimage.transform.radon_transform import order_angles_golden_ratio\n    np.random.seed(1231)\n    lengths = [1, 4, 10, 180]\n    for l in lengths:\n        theta_ordered = np.linspace(0, 180, l, endpoint=False)\n        theta_random = np.random.uniform(0, 180, l)\n        for theta in (theta_random, theta_ordered):\n            indices = [x for x in order_angles_golden_ratio(theta)]\n            assert len(indices) == len(set(indices))\n\ntest_order_angles_golden_ratio()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/transform/tests/test_radon_transform.py"}], "method_code_mask": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy.constants import golden_ratio\nfrom scipy.fft import fft\nfrom scipy.fft import ifft\nfrom scipy.fft import fftfreq\nfrom scipy.fft import fftshift\nfrom warnings import warn\nfrom functools import partial\n\n\ndef order_angles_golden_ratio(theta): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "polygon_area", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/_geometry.py", "response": "import numpy as np\nfrom matplotlib import path\nfrom matplotlib import transforms\n\n\ndef polygon_area(pr, pc):\n    n = len(pr)  # Number of vertices\n    a = 0.0  # Initialize area\n    for i in range(n):\n        j = (i + 1) % n  # Next vertex index\n        a += pr[i] * pc[j] - pc[i] * pr[j]  # Calculate the area contribution\n    return abs(a) / 2.0  # Return the absolute area divided by 2", "test_code_list": [{"test_code": "import pytest\nfrom skimage._shared._geometry import polygon_clip\nfrom skimage._shared._geometry import polygon_area\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\ndef test_polygon_area():\n    x = [0, 0, 1, 1]\n    y = [0, 1, 1, 0]\n    assert_almost_equal(polygon_area(y, x), 1)\n    x = [0, 0, 1]\n    y = [0, 1, 1]\n    assert_almost_equal(polygon_area(y, x), 0.5)\n    x = [0, 0, 0.5, 1, 1, 0.5]\n    y = [0, 1, 0.5, 1, 0, 0.5]\n    assert_almost_equal(polygon_area(y, x), 0.5)\n\ntest_polygon_area()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/tests/test_geometry.py"}, {"test_code": "import pytest\nfrom skimage._shared._geometry import polygon_clip\nfrom skimage._shared._geometry import polygon_area\nimport numpy as np\nfrom numpy.testing import assert_equal\nfrom numpy.testing import assert_almost_equal\ndef test_poly_clip():\n    x = [0, 1, 2, 1]\n    y = [0, -1, 0, 1]\n    yc, xc = polygon_clip(y, x, 0, 0, 1, 1)\n    assert_equal(polygon_area(yc, xc), 0.5)\n    x = [-1, 1.5, 1.5, -1]\n    y = [0.5, 0.5, 1.5, 1.5]\n    yc, xc = polygon_clip(y, x, 0, 0, 1, 1)\n    assert_equal(polygon_area(yc, xc), 0.5)\n\ntest_poly_clip()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/tests/test_geometry.py"}], "method_code_mask": "import numpy as np\nfrom matplotlib import path\nfrom matplotlib import transforms\n\n\ndef polygon_area(pr, pc): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "get_module_version", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/version_requirements.py", "response": "import sys\nfrom packaging import version as _version\nimport re\nimport functools\n\n\ndef get_module_version(module_name):\n    try:\n        module = __import__(module_name)\n        return getattr(module, '__version__', getattr(module, 'VERSION', None))\n    except ImportError:\n        return None", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_equal\nfrom skimage._shared import version_requirements as version_req\nfrom skimage._shared import testing\ndef test_get_module_version():\n    assert get_module_version('numpy')\n    assert get_module_version('scipy')\n    with testing.raises(ImportError):\n        get_module_version('fakenumpy')\n\ntest_get_module_version()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/_shared/tests/test_version_requirements.py"}], "method_code_mask": "import sys\nfrom packaging import version as _version\nimport re\nimport functools\n\n\ndef get_module_version(module_name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_masked_phase_cross_correlation", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/_masked_phase_cross_correlation.py", "response": "from functools import partial\nimport numpy as np\nimport scipy.fft as fftmodule\nfrom scipy.fft import next_fast_len\n\n\ndef _masked_phase_cross_correlation(reference_image, moving_image,\n    reference_mask, moving_mask=None, overlap_ratio=0.3):\n    \n    if moving_mask is None:\n        moving_mask = reference_mask\n\n    # Ensure masks are boolean\n    reference_mask = reference_mask.astype(bool)\n    moving_mask = moving_mask.astype(bool)\n\n    # Apply masks to the images\n    ref_image_masked = reference_image[reference_mask]\n    mov_image_masked = moving_image[moving_mask]\n\n    # Calculate the size of the FFT\n    n = next_fast_len(max(ref_image_masked.size, mov_image_masked.size))\n\n    # Compute the FFT of the masked images\n    ref_fft = fftmodule.fft(ref_image_masked, n=n)\n    mov_fft = fftmodule.fft(mov_image_masked, n=n)\n\n    # Compute the cross-power spectrum\n    cross_power_spectrum = (ref_fft * np.conj(mov_fft)) / (np.abs(ref_fft * np.conj(mov_fft)) + 1e-10)\n\n    # Compute the inverse FFT to get the correlation\n    correlation = fftmodule.ifft(cross_power_spectrum)\n\n    # Find the peak in the correlation\n    correlation_magnitude = np.abs(correlation)\n    shifts = np.unravel_index(np.argmax(correlation_magnitude), correlation.shape)\n\n    # Calculate the shift vector\n    shift_vector = np.array(shifts) - np.array(correlation.shape) // 2\n\n    # Apply overlap ratio to limit the maximum translation\n    max_translation = np.array(reference_image.shape) * (1 - overlap_ratio)\n    shift_vector = np.clip(shift_vector, -max_translation, max_translation)\n\n    return shift_vector", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_vs_phase_cross_correlation():\n    \"\"\"_masked_phase_cross_correlation should give the same results as\n    phase_cross_correlation in the case of trivial masks.\"\"\"\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    trivial_mask = np.ones_like(reference_image)\n    nonmasked_result, *_ = phase_cross_correlation(reference_image, shifted)\n    masked_result = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=trivial_mask, overlap_ratio=1 / 10)\n    assert_equal(nonmasked_result, masked_result)\n\ntest_masked_registration_vs_phase_cross_correlation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_random_masks():\n    \"\"\"_masked_phase_cross_correlation should be able to register translations\n    between images even with random masks.\"\"\"\n    np.random.seed(23)\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    ref_mask = np.random.choice([True, False], reference_image.shape, p=[3 /\n        4, 1 / 4])\n    shifted_mask = np.random.choice([True, False], shifted.shape, p=[3 / 4,\n        1 / 4])\n    measured_shift = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=ref_mask, moving_mask=shifted_mask)\n    assert_equal(measured_shift, -np.array(shift))\n\ntest_masked_registration_random_masks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_random_masks_non_equal_sizes():\n    \"\"\"_masked_phase_cross_correlation should be able to register\n    translations between images that are not the same size even\n    with random masks.\"\"\"\n    np.random.seed(23)\n    reference_image = camera()\n    shift = -7, 12\n    shifted = np.real(fft.ifft2(fourier_shift(fft.fft2(reference_image),\n        shift)))\n    shifted = shifted[64:-64, 64:-64]\n    ref_mask = np.random.choice([True, False], reference_image.shape, p=[3 /\n        4, 1 / 4])\n    shifted_mask = np.random.choice([True, False], shifted.shape, p=[3 / 4,\n        1 / 4])\n    measured_shift = _masked_phase_cross_correlation(reference_image, shifted,\n        reference_mask=np.ones_like(ref_mask), moving_mask=np.ones_like(\n        shifted_mask))\n    assert_equal(measured_shift, -np.array(shift))\n\ntest_masked_registration_random_masks_non_equal_sizes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_equal\nfrom scipy.ndimage import fourier_shift\nfrom scipy.ndimage import shift as real_shift\nimport scipy.fft as fft\nfrom skimage._shared.testing import fetch\nfrom skimage.data import camera\nfrom skimage.data import brain\nfrom skimage.io import imread\nfrom skimage.registration._masked_phase_cross_correlation import _masked_phase_cross_correlation as _masked_phase_cross_correlation\nfrom skimage.registration._masked_phase_cross_correlation import cross_correlate_masked\nfrom skimage.registration import phase_cross_correlation\ndef test_masked_registration_padfield_data():\n    \"\"\"Masked translation registration should behave like in the original\n    publication\"\"\"\n    shifts = [(75, 75), (-130, 130), (130, 130)]\n    for xi, yi in shifts:\n        fixed_image = imread(fetch(\n            f'registration/tests/data/OriginalX{xi}Y{yi}.png'))\n        moving_image = imread(fetch(\n            f'registration/tests/data/TransformedX{xi}Y{yi}.png'))\n        fixed_mask = fixed_image != 0\n        moving_mask = moving_image != 0\n        shift_y, shift_x = _masked_phase_cross_correlation(fixed_image,\n            moving_image, reference_mask=fixed_mask, moving_mask=\n            moving_mask, overlap_ratio=0.1)\n        assert_equal((shift_x, shift_y), (-xi, yi))\n\ntest_masked_registration_padfield_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_masked_phase_cross_correlation.py"}], "method_code_mask": "from functools import partial\nimport numpy as np\nimport scipy.fft as fftmodule\nfrom scipy.fft import next_fast_len\n\n\ndef _masked_phase_cross_correlation(reference_image, moving_image,\n    reference_mask, moving_mask=None, overlap_ratio=0.3): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_sin_flow_gen", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_tvl1.py", "response": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\n\n\ndef _sin_flow_gen(image0, max_motion=4.5, npics=5):\n    h, w = image0.shape[:2]\n    y, x = np.mgrid[0:h, 0:w]\n    \n    # Generate the sinusoidal flow components\n    flow_x = max_motion * np.sin(2 * np.pi * npics * x / w)\n    flow_y = max_motion * np.sin(2 * np.pi * npics * y / h)\n    \n    # Stack the flow components to create the flow field\n    flow = np.stack((flow_x, flow_y), axis=-1)\n    \n    # Create a grid for the original image\n    grid_y, grid_x = np.mgrid[0:h, 0:w]\n    \n    # Calculate the new coordinates after applying the flow\n    new_x = grid_x + flow_x\n    new_y = grid_y + flow_y\n    \n    # Warp the image using the new coordinates\n    image1 = warp(image0, (new_y, new_x), order=1, mode='edge', preserve_range=True)\n    \n    return flow, image1", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_ilk\ndef test_optical_flow_dtype():\n    rng = np.random.default_rng(0)\n    image0 = rng.normal(size=(256, 256))\n    gt_flow, image1 = _sin_flow_gen(image0)\n    flow_f64 = optical_flow_ilk(image0, image1, dtype='float64')\n    assert flow_f64.dtype == 'float64'\n    flow_f32 = optical_flow_ilk(image0, image1, dtype='float32')\n    assert flow_f32.dtype == 'float32'\n    assert abs(flow_f64 - flow_f32).mean() < 0.001\n\ntest_optical_flow_dtype()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_ilk.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\ndef test_optical_flow_dtype():\n    rng = np.random.default_rng(0)\n    image0 = rng.normal(size=(256, 256))\n    gt_flow, image1 = _sin_flow_gen(image0)\n    flow_f64 = optical_flow_tvl1(image0, image1, attachment=5, dtype=np.float64\n        )\n    assert flow_f64.dtype == np.float64\n    flow_f32 = optical_flow_tvl1(image0, image1, attachment=5, dtype=np.float32\n        )\n    assert flow_f32.dtype == np.float32\n    assert np.abs(flow_f64 - flow_f32).mean() < 0.001\n\ntest_optical_flow_dtype()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/registration/tests/test_tvl1.py"}], "method_code_mask": "import numpy as np\nimport pytest\nfrom skimage.registration import optical_flow_tvl1\nfrom skimage.transform import warp\n\n\ndef _sin_flow_gen(image0, max_motion=4.5, npics=5): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_sigma_prefactor", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/_gabor.py", "response": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _sigma_prefactor(bandwidth):\n    if bandwidth <= 0:\n        raise ValueError(\"Bandwidth must be a positive number.\")\n    prefactor = 1 / (bandwidth * math.sqrt(2 * math.pi))\n    return prefactor", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage.filters._gabor import _sigma_prefactor\nfrom skimage.filters._gabor import gabor\nfrom skimage.filters._gabor import gabor_kernel\ndef test_sigma_prefactor():\n    assert_almost_equal(_sigma_prefactor(1), 0.56, 2)\n    assert_almost_equal(_sigma_prefactor(0.5), 1.09, 2)\n\ntest_sigma_prefactor()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_gabor.py"}], "method_code_mask": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef _sigma_prefactor(bandwidth): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "gabor", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/_gabor.py", "response": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0):\n    if sigma_x is None:\n        sigma_x = 1 / (2 * math.pi * frequency)  # Default value based on frequency\n    if sigma_y is None:\n        sigma_y = sigma_x  # Default to sigma_x if not provided\n\n    # Calculate the size of the kernel\n    n_x = int(n_stds * sigma_x * 2 + 1)\n    n_y = int(n_stds * sigma_y * 2 + 1)\n    \n    # Create a grid of (x, y) coordinates\n    x = np.linspace(-n_x // 2, n_x // 2, n_x)\n    y = np.linspace(-n_y // 2, n_y // 2, n_y)\n    x, y = np.meshgrid(x, y)\n\n    # Rotate the coordinates\n    x_theta = x * np.cos(theta) + y * np.sin(theta)\n    y_theta = -x * np.sin(theta) + y * np.cos(theta)\n\n    # Create the Gabor kernel\n    gb = np.exp(-0.5 * (x_theta**2 / sigma_x**2 + y_theta**2 / sigma_y**2)) * np.cos(2 * np.pi * frequency * x_theta + offset)\n\n    # Convolve the image with the Gabor kernel\n    real = ndi.convolve(image, gb, mode=mode, cval=cval)\n    imag = ndi.convolve(image, gb * np.sin(2 * np.pi * frequency * x_theta + offset), mode=mode, cval=cval)\n\n    return real, imag", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_equal\nfrom skimage.filters._gabor import _sigma_prefactor\nfrom skimage.filters._gabor import gabor\nfrom skimage.filters._gabor import gabor_kernel\ndef test_gabor():\n    Y, X = np.mgrid[:40, :40]\n    frequencies = 0.1, 0.3\n    wave_images = [np.sin(2 * np.pi * X * f) for f in frequencies]\n\n    def match_score(image, frequency):\n        gabor_responses = gabor(image, frequency)\n        return np.mean(np.hypot(*gabor_responses))\n    responses = np.array([[match_score(image, f) for f in frequencies] for\n        image in wave_images])\n    assert responses[0, 0] > responses[0, 1]\n    assert responses[1, 1] > responses[0, 1]\n    assert responses[0, 0] > responses[1, 0]\n    assert responses[1, 1] > responses[1, 0]\n\ntest_gabor()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_gabor.py"}], "method_code_mask": "import math\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=\n    None, n_stds=3, offset=0, mode='reflect', cval=0): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_mask_filter_result", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/edges.py", "response": "import numpy as np\nfrom scipy import ndimage as ndi\nfrom scipy.ndimage import binary_erosion\nfrom scipy.ndimage import convolve\n\n\ndef _mask_filter_result(result, mask):\n    if mask is None:\n        return result\n    \n    # Erode the mask using a square footprint of the same size as the mask\n    footprint = np.ones(mask.shape, dtype=bool)\n    eroded_mask = binary_erosion(mask, structure=footprint)\n    \n    # Element-wise multiply the result with the eroded mask\n    modified_result = result * eroded_mask\n    \n    return modified_result", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_almost_equal\nfrom skimage import data\nfrom skimage import filters\nfrom skimage.filters.edges import _mask_filter_result\ndef test_roberts_diagonal2():\n    \"\"\"Roberts' filter on a diagonal edge should be a diagonal line.\"\"\"\n    image = np.rot90(np.tri(10, 10, 0), 3)\n    expected = ~np.rot90(np.tri(10, 10, -1).astype(bool) | np.tri(10, 10, -\n        2).astype(bool).transpose())\n    expected = _mask_filter_result(expected, None)\n    result = filters.roberts(image).astype(bool)\n    assert_array_almost_equal(result, expected)\n\ntest_roberts_diagonal2()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_edges.py"}], "method_code_mask": "import numpy as np\nfrom scipy import ndimage as ndi\nfrom scipy.ndimage import binary_erosion\nfrom scipy.ndimage import convolve\n\n\ndef _mask_filter_result(result, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_otsu", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_otsu(image=None, nbins=256, *, hist=None):\n    if hist is None:\n        # Compute histogram from the image\n        hist, bin_edges = np.histogram(image, bins=nbins, range=(0, 256))\n    else:\n        if isinstance(hist, tuple):\n            hist, bin_edges = hist\n        else:\n            hist = hist\n            bin_edges = np.arange(len(hist))\n\n    # Normalize the histogram\n    total = hist.sum()\n    current_max = 0\n    sum_total = np.dot(np.arange(len(hist)), hist)\n    sum_background = 0\n    weight_background = 0\n    weight_foreground = 0\n    max_variance = 0\n    threshold = 0\n\n    for i in range(len(hist)):\n        weight_background += hist[i]\n        if weight_background == 0:\n            continue\n        \n        weight_foreground = total - weight_background\n        if weight_foreground == 0:\n            break\n        \n        sum_background += i * hist[i]\n        sum_foreground = sum_total - sum_background\n        \n        mean_background = sum_background / weight_background\n        mean_foreground = sum_foreground / weight_foreground\n        \n        # Calculate the between class variance\n        variance = weight_background * weight_foreground * (mean_background - mean_foreground) ** 2\n        \n        # Update the maximum variance and threshold\n        if variance > max_variance:\n            max_variance = variance\n            threshold = i\n\n    return float(threshold)", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    assert 101 < threshold_otsu(camera) < 103\n\ntest_otsu_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    assert 101 < threshold_otsu(hist=hist) < 103\n\ntest_otsu_camera_image_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    assert 101 < threshold_otsu(hist=counts) < 103\n\ntest_otsu_camera_image_counts()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    assert 106 < threshold_otsu(coins) < 108\n\ntest_otsu_coins_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 0.41 < threshold_otsu(coins) < 0.42\n\ntest_otsu_coins_image_as_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert 109 < threshold_otsu(img) < 111\n\ntest_otsu_astro_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_one_color_image():\n    img = np.ones((10, 10), dtype=np.uint8)\n    assert threshold_otsu(img) == 1\n\ntest_otsu_one_color_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_otsu_one_color_image_3d():\n    img = np.ones((10, 10, 10), dtype=np.uint8)\n    assert threshold_otsu(img) == 1\n\ntest_otsu_one_color_image_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_bimodal_multiotsu_hist():\n    for name in ['camera', 'moon', 'coins', 'text', 'clock', 'page']:\n        img = getattr(data, name)()\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n    for name in ['chelsea', 'coffee', 'astronaut', 'rocket']:\n        img = rgb2gray(getattr(data, name)())\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n\ntest_bimodal_multiotsu_hist()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_otsu(image=None, nbins=256, *, hist=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_li", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_li(image, *, tolerance=None, initial_guess=None,\n    iter_callback=None):\n    # Flatten the image and get unique intensity values\n    pixel_values = image.flatten()\n    unique_values = np.unique(pixel_values)\n    \n    # Set default tolerance if not provided\n    if tolerance is None:\n        tolerance = np.min(np.diff(unique_values)) / 2\n    \n    # Set initial guess\n    if initial_guess is None:\n        initial_guess = np.mean(unique_values)\n    elif callable(initial_guess):\n        initial_guess = initial_guess(unique_values)\n    \n    threshold = initial_guess\n    change = float('inf')\n    \n    while change > tolerance:\n        # Calculate foreground and background probabilities\n        foreground = pixel_values[pixel_values > threshold]\n        background = pixel_values[pixel_values <= threshold]\n        \n        p1 = len(foreground) / len(pixel_values) if len(pixel_values) > 0 else 0\n        p2 = len(background) / len(pixel_values) if len(pixel_values) > 0 else 0\n        \n        # Calculate means\n        mean1 = np.mean(foreground) if len(foreground) > 0 else 0\n        mean2 = np.mean(background) if len(background) > 0 else 0\n        \n        # Update threshold using Li's method\n        new_threshold = (mean1 + mean2) / 2\n        \n        # Calculate change\n        change = abs(new_threshold - threshold)\n        threshold = new_threshold\n        \n        # Call the iteration callback if provided\n        if iter_callback is not None:\n            iter_callback(threshold)\n    \n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_camera_image():\n    image = util.img_as_ubyte(data.camera())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 78 < threshold_li(image) < 79\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 1)\n\ntest_li_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_coins_image():\n    image = util.img_as_ubyte(data.coins())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 94 < threshold_li(image) < 95\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 2)\n\ntest_li_coins_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 94 / 255 < threshold_li(coins) < 95 / 255\n\ntest_li_coins_image_as_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_astro_image():\n    image = util.img_as_ubyte(data.astronaut())\n    threshold = threshold_li(image)\n    ce_actual = _cross_entropy(image, threshold)\n    assert 64 < threshold < 65\n    assert ce_actual < _cross_entropy(image, threshold + 1)\n    assert ce_actual < _cross_entropy(image, threshold - 1)\n\ntest_li_astro_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_nan_image():\n    image = np.full((5, 5), np.nan)\n    assert np.isnan(threshold_li(image))\n\ntest_li_nan_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_inf_image():\n    image = np.array([np.inf, np.nan])\n    assert threshold_li(image) == np.inf\n\ntest_li_inf_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_inf_minus_inf():\n    image = np.array([np.inf, -np.inf])\n    assert threshold_li(image) == 0\n\ntest_li_inf_minus_inf()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_constant_image_with_nan():\n    image = np.array([8, 8, 8, 8, np.nan])\n    assert threshold_li(image) == 8\n\ntest_li_constant_image_with_nan()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_li_arbitrary_start_point():\n    cell = data.cell()\n    max_stationary_point = threshold_li(cell)\n    low_stationary_point = threshold_li(cell, initial_guess=np.percentile(\n        cell, 5))\n    optimum = threshold_li(cell, initial_guess=np.percentile(cell, 95))\n    assert 67 < max_stationary_point < 68\n    assert 48 < low_stationary_point < 49\n    assert 111 < optimum < 112\n\ntest_li_arbitrary_start_point()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_li_constant_image(self):\n\t    assert threshold_li(np.ones((10, 10))) == 1.0\n\t\nTestSimpleImage().test_li_constant_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_li(image, *, tolerance=None, initial_guess=None,\n    iter_callback=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_yen", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_yen(image=None, nbins=256, *, hist=None):\n    if hist is None:\n        # Calculate histogram if not provided\n        hist, bin_edges = np.histogram(image, bins=nbins, range=(0, 256))\n    else:\n        # If hist is provided, unpack it\n        if isinstance(hist, tuple):\n            hist, bin_edges = hist\n        else:\n            bin_edges = np.arange(len(hist) + 1)\n\n    # Normalize the histogram\n    total = hist.sum()\n    if total == 0:\n        return 0.0  # Avoid division by zero\n\n    # Calculate cumulative sums\n    cumulative_sum = np.cumsum(hist)\n    cumulative_mean = np.cumsum(hist * (bin_edges[:-1] + bin_edges[1:]) / 2)\n\n    # Initialize variables for maximum evaluation\n    max_eval = -np.inf\n    threshold = 0\n\n    # Iterate through all possible thresholds\n    for t in range(1, nbins):\n        if cumulative_sum[t] == 0 or cumulative_sum[-1] == cumulative_sum[t]:\n            continue  # Avoid division by zero\n\n        # Calculate probabilities\n        p1 = cumulative_sum[t] / total\n        p2 = cumulative_sum[-1] / total - p1\n\n        # Calculate means\n        m1 = cumulative_mean[t] / cumulative_sum[t]\n        m2 = (cumulative_mean[-1] - cumulative_mean[t]) / (cumulative_sum[-1] - cumulative_sum[t])\n\n        # Calculate the evaluation function\n        eval_func = p1 * p2 * (m1 - m2) ** 2\n\n        # Update maximum evaluation and threshold\n        if eval_func > max_eval:\n            max_eval = eval_func\n            threshold = (bin_edges[t] + bin_edges[t + 1]) / 2  # Midpoint of the bin\n\n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    assert 145 < threshold_yen(camera) < 147\n\ntest_yen_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    assert 145 < threshold_yen(hist=hist) < 147\n\ntest_yen_camera_image_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    assert 145 < threshold_yen(hist=counts) < 147\n\ntest_yen_camera_image_counts()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    assert 109 < threshold_yen(coins) < 111\n\ntest_yen_coins_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_yen_coins_image_as_float():\n    coins = util.img_as_float(data.coins())\n    assert 0.43 < threshold_yen(coins) < 0.44\n\ntest_yen_coins_image_as_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_arange(self):\n\t    image = np.arange(256)\n\t    assert threshold_yen(image) == 127\n\t\nTestSimpleImage().test_yen_arange()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_binary(self):\n\t    image = np.zeros([2, 256], dtype=np.uint8)\n\t    image[0] = 255\n\t    assert threshold_yen(image) < 1\n\t\nTestSimpleImage().test_yen_binary()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_blank_zero(self):\n\t    image = np.zeros((5, 5), dtype=np.uint8)\n\t    assert threshold_yen(image) == 0\n\t\nTestSimpleImage().test_yen_blank_zero()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_yen_blank_max(self):\n\t    image = np.empty((5, 5), dtype=np.uint8)\n\t    image.fill(255)\n\t    assert threshold_yen(image) == 255\n\t\nTestSimpleImage().test_yen_blank_max()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_yen(image=None, nbins=256, *, hist=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_isodata", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_isodata(image=None, nbins=256, return_all=False, *, hist=None):\n    if hist is None:\n        if image is None:\n            raise ValueError(\"Either 'image' or 'hist' must be provided.\")\n        hist, bin_edges = np.histogram(image, bins=nbins, range=(0, 256))\n        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2\n    else:\n        if isinstance(hist, tuple):\n            hist, bin_centers = hist\n        else:\n            bin_centers = np.arange(len(hist))\n\n    total_pixels = np.sum(hist)\n    current_threshold = np.mean(bin_centers)  # Initial guess for threshold\n    thresholds = []\n\n    while True:\n        # Split histogram into two groups based on current threshold\n        lower_group = hist[bin_centers < current_threshold]\n        upper_group = hist[bin_centers >= current_threshold]\n\n        if len(lower_group) == 0 or len(upper_group) == 0:\n            break\n\n        # Calculate means of both groups\n        mean_lower = np.sum(lower_group * bin_centers[bin_centers < current_threshold]) / np.sum(lower_group) if np.sum(lower_group) > 0 else 0\n        mean_upper = np.sum(upper_group * bin_centers[bin_centers >= current_threshold]) / np.sum(upper_group) if np.sum(upper_group) > 0 else 0\n\n        # Calculate new threshold\n        new_threshold = (mean_lower + mean_upper) / 2\n        thresholds.append(new_threshold)\n\n        # Check for convergence\n        if abs(new_threshold - current_threshold) < 1e-5:\n            break\n\n        current_threshold = new_threshold\n\n    if return_all:\n        return np.array(thresholds)\n    else:\n        return thresholds[0] if thresholds else current_threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image():\n    camera = util.img_as_ubyte(data.camera())\n    threshold = threshold_isodata(camera)\n    assert np.floor((camera[camera <= threshold].mean() + camera[camera >\n        threshold].mean()) / 2.0) == threshold\n    assert threshold == 102\n    assert (threshold_isodata(camera, return_all=True) == [102, 103]).all()\n\ntest_isodata_camera_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_isodata(hist=hist)\n    assert threshold == 102\n\ntest_isodata_camera_image_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_camera_image_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_isodata(hist=counts)\n    assert threshold == 102\n\ntest_isodata_camera_image_counts()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_coins_image():\n    coins = util.img_as_ubyte(data.coins())\n    threshold = threshold_isodata(coins)\n    assert np.floor((coins[coins <= threshold].mean() + coins[coins >\n        threshold].mean()) / 2.0) == threshold\n    assert threshold == 107\n    assert threshold_isodata(coins, return_all=True) == [107]\n\ntest_isodata_coins_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image():\n    moon = util.img_as_ubyte(data.moon())\n    threshold = threshold_isodata(moon)\n    assert np.floor((moon[moon <= threshold].mean() + moon[moon > threshold\n        ].mean()) / 2.0) == threshold\n    assert threshold == 86\n    thresholds = threshold_isodata(moon, return_all=True)\n    for threshold in thresholds:\n        assert np.floor((moon[moon <= threshold].mean() + moon[moon >\n            threshold].mean()) / 2.0) == threshold\n    assert_equal(thresholds, [86, 87, 88, 122, 123, 124, 139, 140])\n\ntest_isodata_moon_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image_negative_int():\n    moon = util.img_as_ubyte(data.moon()).astype(np.int32)\n    moon -= 100\n    threshold = threshold_isodata(moon)\n    assert np.floor((moon[moon <= threshold].mean() + moon[moon > threshold\n        ].mean()) / 2.0) == threshold\n    assert threshold == -14\n    thresholds = threshold_isodata(moon, return_all=True)\n    for threshold in thresholds:\n        assert np.floor((moon[moon <= threshold].mean() + moon[moon >\n            threshold].mean()) / 2.0) == threshold\n    assert_equal(thresholds, [-14, -13, -12, 22, 23, 24, 39, 40])\n\ntest_isodata_moon_image_negative_int()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_isodata_moon_image_negative_float():\n    moon = util.img_as_ubyte(data.moon()).astype(np.float64)\n    moon -= 100\n    assert -14 < threshold_isodata(moon) < -13\n    thresholds = threshold_isodata(moon, return_all=True)\n    assert_almost_equal(thresholds, [-13.83789062, -12.84179688, -\n        11.84570312, 22.02148438, 23.01757812, 24.01367188, 38.95507812, \n        39.95117188])\n\ntest_isodata_moon_image_negative_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_blank_zero(self):\n\t    image = np.zeros((5, 5), dtype=np.uint8)\n\t    assert threshold_isodata(image) == 0\n\t    assert threshold_isodata(image, return_all=True) == [0]\n\t\nTestSimpleImage().test_isodata_blank_zero()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_linspace(self):\n\t    image = np.linspace(-127, 0, 256)\n\t    assert -63.8 < threshold_isodata(image) < -63.6\n\t    assert_almost_equal(threshold_isodata(image, return_all=True), [-\n\t        63.74804688, -63.25195312])\n\t\nTestSimpleImage().test_isodata_linspace()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\n\nclass TestSimpleImage():\n\tdef test_isodata_16bit(self):\n\t    np.random.seed(0)\n\t    imfloat = np.random.rand(256, 256)\n\t    assert 0.49 < threshold_isodata(imfloat, nbins=1024) < 0.51\n\t    assert all(0.49 < threshold_isodata(imfloat, nbins=1024, return_all=True))\n\t\nTestSimpleImage().test_isodata_16bit()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_isodata(image=None, nbins=256, return_all=False, *, hist=None): [\n    MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_minimum", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_minimum(image=None, nbins=256, max_num_iter=10000, *, hist=None):\n    if hist is None:\n        hist, bin_edges = np.histogram(image, bins=nbins, density=True)\n        bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])\n    else:\n        if isinstance(hist, tuple):\n            hist, bin_centers = hist\n        else:\n            bin_centers = np.arange(len(hist))\n    \n    # Smooth the histogram\n    for _ in range(max_num_iter):\n        hist = ndi.gaussian_filter1d(hist, sigma=1)\n        # Find local maxima\n        maxima = (hist[1:-1] > hist[:-2]) & (hist[1:-1] > hist[2:])\n        local_maxima_indices = np.where(maxima)[0] + 1  # Adjust for the slice\n        if len(local_maxima_indices) == 2:\n            break\n    else:\n        raise RuntimeError(\"Unable to find two local maxima in the histogram.\")\n\n    # Get the values of the local maxima\n    maxima_values = hist[local_maxima_indices]\n    # Find the minimum value between the two maxima\n    threshold = np.min(maxima_values)\n    \n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum():\n    camera = util.img_as_ubyte(data.camera())\n    threshold = threshold_minimum(camera)\n    assert_equal(threshold, 85)\n    astronaut = util.img_as_ubyte(data.astronaut())\n    threshold = threshold_minimum(astronaut)\n    assert_equal(threshold, 114)\n\ntest_threshold_minimum()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_histogram():\n    camera = util.img_as_ubyte(data.camera())\n    hist = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_minimum(hist=hist)\n    assert_equal(threshold, 85)\n\ntest_threshold_minimum_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_counts():\n    camera = util.img_as_ubyte(data.camera())\n    counts, bin_centers = histogram(camera.ravel(), 256, source_range='image')\n    threshold = threshold_minimum(hist=counts)\n    assert_equal(threshold, 85)\n\ntest_threshold_minimum_counts()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_threshold_minimum_synthetic():\n    img = np.arange(25 * 25, dtype=np.uint8).reshape((25, 25))\n    img[0:9, :] = 50\n    img[14:25, :] = 250\n    threshold = threshold_minimum(img)\n    assert_equal(threshold, 95)\n\ntest_threshold_minimum_synthetic()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_minimum(image=None, nbins=256, max_num_iter=10000, *, hist=None\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_triangle", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_triangle(image, nbins=256):\n    # Calculate the histogram of the image\n    hist, bin_edges = np.histogram(image, bins=nbins, range=(0, 256))\n    \n    # Calculate the cumulative distribution function (CDF)\n    cdf = np.cumsum(hist)\n    \n    # Normalize the CDF\n    cdf_normalized = cdf / cdf[-1]\n    \n    # Calculate the triangle threshold\n    max_val = np.max(hist)\n    threshold = 0\n    max_distance = -1\n    \n    for i in range(nbins):\n        # Calculate the distance from the point to the triangle\n        distance = (i * cdf_normalized[i]) + ((nbins - 1 - i) * (1 - cdf_normalized[i])) - max_val\n        if distance > max_distance:\n            max_distance = distance\n            threshold = i\n            \n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_uint_images():\n    assert threshold_triangle(np.invert(data.text())) == 151\n    assert threshold_triangle(data.text()) == 104\n    assert threshold_triangle(data.coins()) == 80\n    assert threshold_triangle(np.invert(data.coins())) == 175\n\ntest_triangle_uint_images()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_float_images():\n    text = data.text()\n    int_bins = text.max() - text.min() + 1\n    assert round(threshold_triangle(text.astype(float), nbins=int_bins)) == 104\n    assert round(threshold_triangle(text / 255.0, nbins=int_bins) * 255) == 104\n    assert round(threshold_triangle(np.invert(text).astype(float), nbins=\n        int_bins)) == 151\n    assert round(threshold_triangle(np.invert(text) / 255.0, nbins=int_bins\n        ) * 255) == 151\n\ntest_triangle_float_images()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_triangle_flip():\n    img = data.camera()\n    inv_img = np.invert(img)\n    t = threshold_triangle(inv_img)\n    t_inv_img = inv_img > t\n    t_inv_inv_img = np.invert(t_inv_img)\n    t = threshold_triangle(img)\n    t_img = img > t\n    unequal_pos = np.where(t_img.ravel() != t_inv_inv_img.ravel())\n    assert len(unequal_pos[0]) / t_img.size < 0.01\n\ntest_triangle_flip()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_triangle(image, nbins=256): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_niblack", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_niblack(image, window_size=15, k=0.2):\n    if isinstance(window_size, Iterable):\n        if len(window_size) != image.ndim:\n            raise ValueError(\"Length of window_size must match the number of dimensions of the image.\")\n    else:\n        window_size = [window_size] * image.ndim\n\n    # Ensure window sizes are odd integers\n    window_size = [size if size % 2 == 1 else size + 1 for size in window_size]\n\n    # Calculate local mean and standard deviation\n    mean = ndi.uniform_filter(image, size=window_size, mode='reflect')\n    std = np.sqrt(ndi.uniform_filter(image**2, size=window_size, mode='reflect') - mean**2)\n\n    # Calculate Niblack threshold\n    threshold = mean + k * std\n\n    return threshold", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_niblack_sauvola_pathological_image():\n    value = 0.03082192 + 2.19178082e-09\n    src_img = np.full((4, 4), value).astype(np.float64)\n    assert not np.any(np.isnan(threshold_niblack(src_img)))\n\ntest_niblack_sauvola_pathological_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_niblack(image, window_size=15, k=0.2): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "threshold_multiotsu", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/thresholding.py", "response": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_multiotsu(image=None, classes=3, nbins=256, *, hist=None):\n    if hist is None:\n        # Compute histogram from the image\n        hist, bin_centers = np.histogram(image, bins=nbins, range=(0, 256))\n    else:\n        if isinstance(hist, tuple):\n            hist, bin_centers = hist\n        else:\n            bin_centers = np.arange(len(hist))\n\n    # Normalize the histogram\n    hist = hist.astype(np.float64)\n    hist /= hist.sum()\n\n    # Compute cumulative sums and cumulative means\n    cumulative_sum = np.cumsum(hist)\n    cumulative_mean = np.cumsum(hist * bin_centers)\n\n    # Total mean\n    total_mean = cumulative_mean[-1]\n\n    # Initialize the maximum variance\n    max_variance = -np.inf\n    thresholds = []\n\n    # Iterate over all possible combinations of thresholds\n    for thresholds_combination in itertools.combinations(range(1, nbins), classes - 1):\n        thresholds_combination = (0,) + thresholds_combination + (nbins,)\n        between_class_variance = 0\n\n        for i in range(classes):\n            start, end = thresholds_combination[i], thresholds_combination[i + 1]\n            weight = cumulative_sum[end] - cumulative_sum[start]\n            if weight > 0:\n                mean = (cumulative_mean[end] - cumulative_mean[start]) / weight\n                between_class_variance += weight * (mean - total_mean) ** 2\n\n        if between_class_variance > max_variance:\n            max_variance = between_class_variance\n            thresholds = thresholds_combination[1:-1]\n\n    return np.array(thresholds)", "test_code_list": [{"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_bimodal_multiotsu_hist():\n    for name in ['camera', 'moon', 'coins', 'text', 'clock', 'page']:\n        img = getattr(data, name)()\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n    for name in ['chelsea', 'coffee', 'astronaut', 'rocket']:\n        img = rgb2gray(getattr(data, name)())\n        assert threshold_otsu(img) == threshold_multiotsu(img, 2)\n\ntest_bimodal_multiotsu_hist()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_check_multiotsu_results():\n    image = 0.25 * np.array([[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3,\n        4], [0, 1, 2, 3, 4]])\n    for idx in range(3, 6):\n        thr_multi = threshold_multiotsu(image, classes=idx)\n        assert len(thr_multi) == idx - 1\n\ntest_check_multiotsu_results()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_output():\n    image = np.zeros((100, 100), dtype='int')\n    coords = [(25, 25), (50, 50), (75, 75)]\n    values = [64, 128, 192]\n    for coor, val in zip(coords, values):\n        rr, cc = disk(coor, 20)\n        image[rr, cc] = val\n    thresholds = [0, 64, 128]\n    assert np.array_equal(thresholds, threshold_multiotsu(image, classes=4))\n\ntest_multiotsu_output()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}, {"test_code": "import math\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom scipy import ndimage as ndi\nfrom skimage import data\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage.color import rgb2gray\nfrom skimage.draw import disk\nfrom skimage.exposure import histogram\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices\nfrom skimage.filters._multiotsu import _get_multiotsu_thresh_indices_lut\nfrom skimage.filters.thresholding import _cross_entropy\nfrom skimage.filters.thresholding import _mean_std\nfrom skimage.filters.thresholding import threshold_isodata\nfrom skimage.filters.thresholding import threshold_li\nfrom skimage.filters.thresholding import threshold_local\nfrom skimage.filters.thresholding import threshold_mean\nfrom skimage.filters.thresholding import threshold_minimum\nfrom skimage.filters.thresholding import threshold_multiotsu\nfrom skimage.filters.thresholding import threshold_niblack\nfrom skimage.filters.thresholding import threshold_otsu\nfrom skimage.filters.thresholding import threshold_sauvola\nfrom skimage.filters.thresholding import threshold_triangle\nfrom skimage.filters.thresholding import threshold_yen\nfrom skimage.filters.thresholding import try_all_threshold\nimport dask.array as da\ndef test_multiotsu_astro_image():\n    img = util.img_as_ubyte(data.astronaut())\n    with expected_warnings(['grayscale']):\n        assert_almost_equal(threshold_multiotsu(img), [58, 149])\n\ntest_multiotsu_astro_image()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/tests/test_thresholding.py"}], "method_code_mask": "import inspect\nimport itertools\nimport math\nfrom collections import OrderedDict\nfrom collections.abc import Iterable\nimport numpy as np\nfrom scipy import ndimage as ndi\nfrom matplotlib import pyplot as plt\n\n\ndef threshold_multiotsu(image=None, classes=3, nbins=256, *, hist=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "ball", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/morphology/footprints.py", "response": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef ball(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None):\n    if not isinstance(radius, Integral) or radius < 0:\n        raise ValueError(\"Radius must be a non-negative integer.\")\n    \n    if not isinstance(dtype, type):\n        raise ValueError(\"dtype must be a data type.\")\n    \n    if strict_radius:\n        r = radius\n    else:\n        r = radius + 0.5\n\n    # Create a grid of points\n    x, y, z = np.ogrid[-r:r+1, -r:r+1, -r:r+1]\n    footprint = x**2 + y**2 + z**2 <= r**2\n\n    if decomposition == 'sequence':\n        return tuple(footprint)\n    \n    return footprint.astype(dtype)", "test_code_list": [{"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_ubyte_vs_float_3d(self):\n\t    np.random.seed(0)\n\t    volume_uint = np.random.randint(0, high=256, size=(10, 20, 30), dtype=\n\t        np.uint8)\n\t    volume_float = img_as_float(volume_uint)\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_uint, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_f = func(volume_float, ball(3))\n\t        assert_equal(out_u, out_f)\n\t\nTestRank().test_compare_ubyte_vs_float_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}, {"test_code": "import inspect\nimport numpy as np\nimport pytest\nfrom skimage import data\nfrom skimage import morphology\nfrom skimage import util\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import fetch\nfrom skimage.filters import rank\nfrom skimage.filters.rank import __all__ as all_rank_filters\nfrom skimage.filters.rank import __3Dfilters as _3d_rank_filters\nfrom skimage.filters.rank import subtract_mean\nfrom skimage.morphology import ball\nfrom skimage.morphology import disk\nfrom skimage.util import img_as_float\nfrom skimage.util import img_as_ubyte\n\nclass TestRank():\n\tdef test_compare_8bit_unsigned_vs_signed_3d(self):\n\t    np.random.seed(0)\n\t    volume_s = np.random.randint(0, high=127, size=(10, 20, 30), dtype=np.int8)\n\t    volume_u = img_as_ubyte(volume_s)\n\t    assert_equal(volume_u, img_as_ubyte(volume_s))\n\t    methods_3d = ['equalize', 'otsu', 'autolevel', 'gradient', 'majority',\n\t        'maximum', 'mean', 'geometric_mean', 'subtract_mean', 'median',\n\t        'minimum', 'modal', 'enhance_contrast', 'pop', 'sum', 'threshold',\n\t        'noise_filter', 'entropy']\n\t    for method in methods_3d:\n\t        func = getattr(rank, method)\n\t        out_u = func(volume_u, ball(3))\n\t        with expected_warnings(['Possible precision loss']):\n\t            out_s = func(volume_s, ball(3))\n\t        assert_equal(out_u, out_s)\n\t\nTestRank().test_compare_8bit_unsigned_vs_signed_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/filters/rank/tests/test_rank.py"}], "method_code_mask": "import os\nfrom collections.abc import Sequence\nfrom numbers import Integral\nimport numpy as np\nfrom skimage import morphology\n\n\ndef ball(radius, dtype=np.uint8, *, strict_radius=True, decomposition=None): [M\n    ASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "morphological_geodesic_active_contour", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/morphsnakes.py", "response": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_geodesic_active_contour(gimage, num_iter, init_level_set=\n    'disk', smoothing=1, threshold='auto', balloon=0, iter_callback=lambda\n    x: None):\n    \n    # Initialize the level set\n    if isinstance(init_level_set, str):\n        if init_level_set == 'disk':\n            init_level_set = np.zeros(gimage.shape, dtype=np.float32)\n            init_level_set[tuple(np.indices(init_level_set.shape).T)] = 1\n            init_level_set = ndi.binary_dilation(init_level_set, iterations=5)\n        elif init_level_set == 'checkerboard':\n            init_level_set = np.indices(gimage.shape).sum(axis=0) % 2\n        else:\n            raise ValueError(\"init_level_set must be 'disk' or 'checkerboard'\")\n    else:\n        init_level_set = np.asarray(init_level_set, dtype=np.float32)\n    \n    # Ensure the level set is binary\n    init_level_set = (init_level_set > 0).astype(np.float32)\n\n    # Prepare the output level set\n    level_set = init_level_set.copy()\n\n    # Define the balloon force\n    balloon_force = np.zeros_like(gimage)\n    if balloon > 0:\n        balloon_force = ndi.gaussian_filter(gimage, sigma=1) * balloon\n\n    # Main iteration loop\n    for i in range(num_iter):\n        # Apply smoothing\n        for _ in range(smoothing):\n            level_set = ndi.gaussian_filter(level_set, sigma=1)\n\n        # Compute the gradient of the gimage\n        gimage_gradient = np.gradient(gimage)\n        gimage_gradient_magnitude = np.sqrt(sum(g**2 for g in gimage_gradient))\n\n        # Update the level set based on the gimage and balloon force\n        if threshold == 'auto':\n            threshold = np.mean(gimage_gradient_magnitude)\n\n        # Evolve the contour\n        level_set += (gimage_gradient_magnitude - threshold + balloon_force) * level_set\n\n        # Call the iteration callback if provided\n        iter_callback(level_set)\n\n    # Return the final level set\n    return level_set", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_init_level_sets():\n    image = np.zeros((6, 6))\n    checkerboard_ls = morphological_chan_vese(image, 0, 'checkerboard')\n    checkerboard_ref = np.array([[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0,\n        0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1,\n        1, 0]], dtype=np.int8)\n    disk_ls = morphological_geodesic_active_contour(image, 0, 'disk')\n    disk_ref = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 1, \n        1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0\n        ]], dtype=np.int8)\n    assert_array_equal(checkerboard_ls, checkerboard_ref)\n    assert_array_equal(disk_ls, disk_ref)\n\ntest_init_level_sets()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}], "method_code_mask": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_geodesic_active_contour(gimage, num_iter, init_level_set=\n    'disk', smoothing=1, threshold='auto', balloon=0, iter_callback=lambda\n    x: None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "morphological_chan_vese", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/morphsnakes.py", "response": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_chan_vese(image, num_iter, init_level_set='checkerboard',\n    smoothing=1, lambda1=1, lambda2=1, iter_callback=lambda x: None):\n    \n    # Ensure the image is a float array\n    image = np.asarray(image, dtype=np.float32)\n    \n    # Initialize the level set\n    if isinstance(init_level_set, str):\n        if init_level_set == 'checkerboard':\n            # Create a checkerboard pattern\n            rows, cols = image.shape[:2]\n            init_level_set = np.indices((rows, cols)).sum(axis=0) % 2\n        elif init_level_set == 'disk':\n            # Create a disk pattern\n            radius = min(image.shape) // 8\n            y, x = np.ogrid[-radius: radius, -radius: radius]\n            mask = x**2 + y**2 <= radius**2\n            init_level_set = np.zeros(image.shape, dtype=np.float32)\n            init_level_set[mask] = 1\n        else:\n            raise ValueError(\"init_level_set must be 'checkerboard' or 'disk'\")\n    else:\n        init_level_set = np.asarray(init_level_set, dtype=np.float32)\n    \n    # Binarize the initial level set\n    level_set = np.where(init_level_set > 0, 1, -1)\n    \n    for i in range(num_iter):\n        # Compute the average intensities inside and outside the contour\n        c1 = np.sum(image * (level_set == 1)) / np.sum(level_set == 1)\n        c2 = np.sum(image * (level_set == -1)) / np.sum(level_set == -1)\n\n        # Compute the Heaviside and Dirac functions\n        H = 0.5 * (1 + (2 / np.pi) * np.arctan((level_set - 0.5) / 1e-10))\n        delta = np.gradient(H)\n\n        # Update the level set\n        # Compute the gradient of the level set\n        gradient = np.array(np.gradient(level_set))\n        norm_gradient = np.sqrt(sum(g**2 for g in gradient))\n        norm_gradient = np.where(norm_gradient == 0, 1, norm_gradient)\n\n        # Update the level set using the Chan-Vese equation\n        level_set += smoothing * (lambda1 * (image - c1)**2 - lambda2 * (image - c2)**2) * H - \\\n                     (1 / norm_gradient) * (np.sum(delta, axis=0))\n\n        # Call the callback function if provided\n        iter_callback(level_set)\n\n    # Return the final level set\n    out = np.where(level_set > 0, 1, 0)\n    return out", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_init_level_sets():\n    image = np.zeros((6, 6))\n    checkerboard_ls = morphological_chan_vese(image, 0, 'checkerboard')\n    checkerboard_ref = np.array([[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0,\n        0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1,\n        1, 0]], dtype=np.int8)\n    disk_ls = morphological_geodesic_active_contour(image, 0, 'disk')\n    disk_ref = np.array([[0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0], [0, 1, 1, \n        1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0\n        ]], dtype=np.int8)\n    assert_array_equal(checkerboard_ls, checkerboard_ref)\n    assert_array_equal(disk_ls, disk_ref)\n\ntest_init_level_sets()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom skimage.segmentation import disk_level_set\nfrom skimage.segmentation import inverse_gaussian_gradient\nfrom skimage.segmentation import morphological_chan_vese\nfrom skimage.segmentation import morphological_geodesic_active_contour\ndef test_morphsnakes_3d():\n    image = np.zeros((7, 7, 7))\n    evolution = []\n\n    def callback(x):\n        evolution.append(x.sum())\n    ls = morphological_chan_vese(image, 5, 'disk', iter_callback=callback)\n    assert evolution[0] == 81\n    assert ls.sum() == 0\n    for v1, v2 in zip(evolution[:-1], evolution[1:]):\n        assert v1 >= v2\n\ntest_morphsnakes_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_morphsnakes.py"}], "method_code_mask": "from itertools import cycle\nimport numpy as np\nfrom scipy import ndimage as ndi\n\n\ndef morphological_chan_vese(image, num_iter, init_level_set='checkerboard',\n    smoothing=1, lambda1=1, lambda2=1, iter_callback=lambda x: None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "relabel_sequential", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/_join.py", "response": "import numpy as np\n\ndef relabel_sequential(label_field, offset=1):\n    # Ensure the input is a numpy array\n    label_field = np.asarray(label_field)\n    \n    # Get unique labels, excluding the background label (0)\n    unique_labels = np.unique(label_field)\n    unique_labels = unique_labels[unique_labels > 0]  # Exclude 0 if present\n    \n    # Create a mapping from original labels to new labels\n    forward_map = {original: new for new, original in enumerate(unique_labels, start=offset)}\n    \n    # Create the relabeled array\n    relabeled = np.zeros_like(label_field, dtype=np.int32)\n    \n    # Apply the mapping to create the relabeled array\n    for original, new in forward_map.items():\n        relabeled[label_field == original] = new\n    \n    # Create the inverse map\n    inverse_map = {new: original for original, new in forward_map.items()}\n    \n    return relabeled, forward_map, inverse_map", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_relabel_sequential_signed_overflow():\n    imax = np.iinfo(np.int32).max\n    labels = np.array([0, 1, 99, 42, 42], dtype=np.int32)\n    output, fw, inv = relabel_sequential(labels, offset=imax)\n    reference = np.array([0, imax, imax + 2, imax + 1, imax + 1], dtype=np.\n        uint32)\n    assert_array_equal(output, reference)\n    assert output.dtype == reference.dtype\n\ntest_relabel_sequential_signed_overflow()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_very_large_labels():\n    imax = np.iinfo(np.int64).max\n    labels = np.array([0, 1, imax, 42, 42], dtype=np.int64)\n    output, fw, inv = relabel_sequential(labels, offset=imax)\n    assert np.max(output) == imax + 2\n\ntest_very_large_labels()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_call():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    testing.assert_array_equal(relabeled, fw(ar))\n    testing.assert_array_equal(ar, inv(relabeled))\n\ntest_arraymap_call()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_len():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    assert len(fw) == 100\n    assert len(fw) == len(np.array(fw))\n    assert len(inv) == 6\n    assert len(inv) == len(np.array(inv))\n\ntest_arraymap_len()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import join_segmentations\nfrom skimage.segmentation import relabel_sequential\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_array_equal\nimport pytest\ndef test_arraymap_set():\n    ar = np.array([1, 1, 5, 5, 8, 99, 42, 0], dtype=np.intp)\n    relabeled, fw, inv = relabel_sequential(ar)\n    fw[72] = 6\n    assert fw[72] == 6\n\ntest_arraymap_set()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_join.py"}], "method_code_mask": "import numpy as np\n\n\ndef relabel_sequential(label_field, offset=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "clear_border", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/_clear_border.py", "response": "import numpy as np\n\n\ndef clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None):\n    if out is None:\n        out = np.empty_like(labels)\n    else:\n        out[:] = labels  # Copy input to output if out is provided\n\n    if mask is not None:\n        # If a mask is provided, use it to clear the labels\n        labels[~mask] = bgval\n\n    # Create a binary mask for the border\n    border_mask = np.zeros(labels.shape, dtype=bool)\n    border_mask[:buffer_size, :] = True\n    border_mask[-buffer_size:, :] = True\n    border_mask[:, :buffer_size] = True\n    border_mask[:, -buffer_size:] = True\n\n    # Find connected components in the labels\n    from scipy.ndimage import label\n    labeled_array, num_features = label(labels)\n\n    # Identify the labels that are connected to the border\n    border_labels = np.unique(labeled_array[border_mask])\n    border_labels = border_labels[border_labels > 0]  # Exclude background label\n\n    # Clear the border-connected labels in the output\n    for border_label in border_labels:\n        out[labeled_array == border_label] = bgval\n\n    return out", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border():\n    image = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 1,\n        0], [1, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 1,\n        1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]])\n    result = clear_border(image.copy())\n    ref = image.copy()\n    ref[1:3, 0:2] = 0\n    ref[0:2, -2] = 0\n    assert_array_equal(result, ref)\n    result = clear_border(image.copy(), 1)\n    assert_array_equal(result, np.zeros(result.shape))\n    result = clear_border(image.copy(), buffer_size=1, bgval=2)\n    assert_array_equal(result, 2 * np.ones_like(image))\n    mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, \n        1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1,\n        1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)\n    result = clear_border(image.copy(), mask=mask)\n    ref = image.copy()\n    ref[1:3, 0:2] = 0\n    assert_array_equal(result, ref)\n\ntest_clear_border()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_3d():\n    image = np.array([[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, \n        0]], [[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]], [[0,\n        0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]])\n    result = clear_border(image.copy())\n    ref = image.copy()\n    ref[0, 3, 0] = 0\n    assert_array_equal(result, ref)\n    result = clear_border(image.copy(), 1)\n    assert_array_equal(result, np.zeros(result.shape))\n    result = clear_border(image.copy(), buffer_size=1, bgval=2)\n    assert_array_equal(result, 2 * np.ones_like(image))\n\ntest_clear_border_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_non_binary():\n    image = np.array([[1, 2, 3, 1, 2], [3, 3, 5, 4, 2], [3, 4, 5, 4, 2], [3,\n        3, 2, 1, 2]])\n    result = clear_border(image)\n    expected = np.array([[0, 0, 0, 0, 0], [0, 0, 5, 4, 0], [0, 4, 5, 4, 0],\n        [0, 0, 0, 0, 0]])\n    assert_array_equal(result, expected)\n    assert_(not np.all(image == result))\n\ntest_clear_border_non_binary()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}, {"test_code": "import numpy as np\nfrom skimage.segmentation import clear_border\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_\ndef test_clear_border_non_binary_3d():\n    image3d = np.array([[[1, 2, 3, 1, 2], [3, 3, 3, 4, 2], [3, 4, 3, 4, 2],\n        [3, 3, 2, 1, 2]], [[1, 2, 3, 1, 2], [3, 3, 5, 4, 2], [3, 4, 5, 4, 2\n        ], [3, 3, 2, 1, 2]], [[1, 2, 3, 1, 2], [3, 3, 3, 4, 2], [3, 4, 3, 4,\n        2], [3, 3, 2, 1, 2]]])\n    result = clear_border(image3d)\n    expected = np.array([[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 5, 0, 0], [0, 0, 5, 0, 0\n        ], [0, 0, 0, 0, 0]], [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0,\n        0], [0, 0, 0, 0, 0]]])\n    assert_array_equal(result, expected)\n    assert_(not np.all(image3d == result))\n\ntest_clear_border_non_binary_3d()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_clear_border.py"}], "method_code_mask": "import numpy as np\n\n\ndef clear_border(labels, buffer_size=0, bgval=0, mask=None, *, out=None): [MASK\n    ]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "make_2d_syntheticdata", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py", "response": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_2d_syntheticdata(lx, ly=None):\n    if ly is None:\n        ly = lx\n\n    # Create a background with random noise\n    data = np.random.rand(ly, lx)\n\n    # Create a central disk feature\n    center_x, center_y = lx // 2, ly // 2\n    radius = min(lx, ly) // 8\n    y, x = np.ogrid[-center_y:ly-center_y, -center_x:lx-center_x]\n    mask = x**2 + y**2 <= radius**2\n    data[mask] = 1  # Set the disk feature to a high value\n\n    # Create seed points\n    seeds = np.zeros_like(data)\n    seeds[center_y, center_x] = 1  # Seed point 1\n    seeds[center_y + radius // 2, center_x + radius // 2] = 2  # Seed point 2\n\n    return data, seeds", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_reorder_labels():\n    lx = 70\n    ly = 100\n    data, labels = make_2d_syntheticdata(lx, ly)\n    labels[labels == 2] = 4\n    labels_bf = random_walker(data, labels, beta=90, mode='bf')\n    assert (labels_bf[25:45, 40:60] == 2).all()\n    assert data.shape == labels.shape\n\ntest_reorder_labels()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_2d_inactive():\n    lx = 70\n    ly = 100\n    data, labels = make_2d_syntheticdata(lx, ly)\n    labels[10:20, 10:20] = -1\n    labels[46:50, 33:38] = -2\n    labels = random_walker(data, labels, beta=90)\n    assert (labels.reshape((lx, ly))[25:45, 40:60] == 2).all()\n    assert data.shape == labels.shape\n\ntest_2d_inactive()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}], "method_code_mask": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_2d_syntheticdata(lx, ly=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "make_3d_syntheticdata", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py", "response": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_3d_syntheticdata(lx, ly=None, lz=None):\n    if ly is None:\n        ly = lx\n    if lz is None:\n        lz = lx\n\n    # Create a 3D array filled with Gaussian noise\n    data = np.random.normal(loc=0.0, scale=1.0, size=(lx, ly, lz))\n\n    # Introduce a spherical structure\n    center = (lx // 2, ly // 2, lz // 2)\n    radius = min(lx, ly, lz) // 4\n    z, y, x = np.ogrid[:lx, :ly, :lz]\n    sphere = (x - center[0])**2 + (y - center[1])**2 + (z - center[2])**2 <= radius**2\n    data[sphere] += 5  # Increase the intensity of the spherical structure\n\n    # Add a hole in the structure\n    hole_radius = radius // 2\n    hole = (x - center[0])**2 + (y - center[1])**2 + (z - center[2])**2 <= hole_radius**2\n    data[hole] -= 5  # Decrease the intensity to create a hole\n\n    # Create seed points\n    seeds = np.zeros((lx, ly, lz), dtype=int)\n    seeds[center[0], center[1], center[2]] = 1  # Seed point 1\n    seeds[center[0] + 1, center[1] + 1, center[2] + 1] = 2  # Seed point 2\n\n    return data, seeds", "test_code_list": [{"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_3d_inactive():\n    n = 30\n    lx, ly, lz = n, n, n\n    data, labels = make_3d_syntheticdata(lx, ly, lz)\n    labels[5:25, 26:29, 26:29] = -1\n    with expected_warnings(['\"cg\" mode|CObject type|scipy.sparse.linalg.cg']):\n        labels = random_walker(data, labels, mode='cg')\n    assert (labels.reshape(data.shape)[13:17, 13:17, 13:17] == 2).all()\n    assert data.shape == labels.shape\n\ntest_3d_inactive()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}, {"test_code": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\ndef test_spacing_0():\n    n = 30\n    lx, ly, lz = n, n, n\n    data, _ = make_3d_syntheticdata(lx, ly, lz)\n    data_aniso = np.zeros((n, n, n // 2))\n    for i, yz in enumerate(data):\n        data_aniso[i, :, :] = resize(yz, (n, n // 2), mode='constant',\n            anti_aliasing=False)\n    small_l = int(lx // 5)\n    labels_aniso = np.zeros_like(data_aniso)\n    labels_aniso[lx // 5, ly // 5, lz // 5] = 1\n    labels_aniso[lx // 2 + small_l // 4, ly // 2 - small_l // 4, lz // 4 - \n        small_l // 8] = 2\n    with expected_warnings(['\"cg\" mode|scipy.sparse.linalg.cg']):\n        labels_aniso = random_walker(data_aniso, labels_aniso, mode='cg',\n            spacing=(1.0, 1.0, 0.5))\n    assert (labels_aniso[13:17, 13:17, 7:9] == 2).all()\n\ntest_spacing_0()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/segmentation/tests/test_random_walker.py"}], "method_code_mask": "import numpy as np\nfrom skimage._shared import testing\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import xfail\nfrom skimage._shared.testing import arch32\nfrom skimage.segmentation import random_walker\nfrom skimage.transform import resize\nfrom skimage.segmentation import random_walker_segmentation\n\n\ndef make_3d_syntheticdata(lx, ly=None, lz=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_label_bool", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/_label.py", "response": "from scipy import ndimage\nimport numpy as np\n\ndef _label_bool(image, background=None, return_num=False, connectivity=None):\n    if background == 1:\n        image = np.logical_not(image)\n\n    if connectivity is None:\n        connectivity = image.ndim\n\n    labeled_image, num_labels = ndimage.label(image, structure=np.ones((3,) * connectivity))\n\n    if return_num:\n        return labeled_image, num_labels\n    else:\n        return labeled_image", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_no_option():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img)\n    l_cy = clabel(img)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_no_option()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_background():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img, background=0)\n    l_cy = clabel(img, background=0)\n    testing.assert_equal(l_ndi, l_cy)\n    l_ndi = _label_bool(img, background=1)\n    l_cy = clabel(img, background=1)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_background()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_return_num():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    l_ndi = _label_bool(img, return_num=True)\n    l_cy = clabel(img, return_num=True)\n    testing.assert_equal(l_ndi, l_cy)\n\ntest_return_num()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}, {"test_code": "import pytest\nimport numpy as np\nfrom skimage import data\nfrom skimage.measure._label import _label_bool\nfrom skimage.measure._label import label\nfrom skimage.measure._ccomp import label_cython as clabel\nfrom skimage._shared import testing\ndef test_connectivity():\n    img = data.binary_blobs(length=128, blob_size_fraction=0.15, n_dim=3)\n    for c in (1, 2, 3):\n        l_ndi = _label_bool(img, connectivity=c)\n        l_cy = clabel(img, connectivity=c)\n        testing.assert_equal(l_ndi, l_cy)\n    for c in (0, 4):\n        with pytest.raises(ValueError):\n            l_ndi = _label_bool(img, connectivity=c)\n        with pytest.raises(ValueError):\n            l_cy = clabel(img, connectivity=c)\n\ntest_connectivity()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_label.py"}], "method_code_mask": "from scipy import ndimage\n\n\ndef _label_bool(image, background=None, return_num=False, connectivity=None): [\n    MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_same_mesh", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py", "response": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\n\n\ndef _same_mesh(vertices1, faces1, vertices2, faces2, tol=1e-10):\n    # Check if the number of faces is the same\n    if len(faces1) != len(faces2):\n        return False\n\n    # Create a function to get sorted triangles from faces\n    def get_sorted_triangles(vertices, faces):\n        triangles = []\n        for face in faces:\n            triangle = np.sort(vertices[face], axis=0)  # Sort the vertices of the triangle\n            triangles.append(triangle)\n        return sorted(triangles)  # Sort the list of triangles\n\n    # Get sorted triangles for both meshes\n    triangles1 = get_sorted_triangles(vertices1, faces1)\n    triangles2 = get_sorted_triangles(vertices2, faces2)\n\n    # Compare the triangles using assert_allclose with the given tolerance\n    for tri1, tri2 in zip(triangles1, triangles2):\n        if not assert_allclose(tri1, tri2, atol=tol).all():\n            return False\n\n    return True", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\ndef test_both_algs_same_result_ellipse():\n    sphere_small = ellipsoid(1, 1, 1, levelset=True)\n    vertices1, faces1 = marching_cubes(sphere_small, 0, allow_degenerate=False\n        )[:2]\n    vertices2, faces2 = marching_cubes(sphere_small, 0, allow_degenerate=\n        False, method='lorensen')[:2]\n    assert _same_mesh(vertices1, faces1, vertices2, faces2)\n\ntest_both_algs_same_result_ellipse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\ndef test_both_algs_same_result_donut():\n    n = 48\n    a, b = 2.5 / n, -1.25\n    vol = np.empty((n, n, n), 'float32')\n    for iz in range(vol.shape[0]):\n        for iy in range(vol.shape[1]):\n            for ix in range(vol.shape[2]):\n                z, y, x = float(iz) * a + b, float(iy) * a + b, float(ix\n                    ) * a + b\n                vol[iz, iy, ix] = (((8 * x) ** 2 + (8 * y - 2) ** 2 + (8 *\n                    z) ** 2 + 16 - 1.85 * 1.85) * ((8 * x) ** 2 + (8 * y - \n                    2) ** 2 + (8 * z) ** 2 + 16 - 1.85 * 1.85) - 64 * ((8 *\n                    x) ** 2 + (8 * y - 2) ** 2)) * (((8 * x) ** 2 + (8 * y -\n                    2 + 4) * (8 * y - 2 + 4) + (8 * z) ** 2 + 16 - 1.85 * \n                    1.85) * ((8 * x) ** 2 + (8 * y - 2 + 4) * (8 * y - 2 + \n                    4) + (8 * z) ** 2 + 16 - 1.85 * 1.85) - 64 * ((8 * y - \n                    2 + 4) * (8 * y - 2 + 4) + (8 * z) ** 2)) + 1025\n    vertices1, faces1 = marching_cubes(vol, 0, method='lorensen')[:2]\n    vertices2, faces2 = marching_cubes(vol, 0)[:2]\n    assert not _same_mesh(vertices1, faces1, vertices2, faces2)\n\ntest_both_algs_same_result_donut()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/measure/tests/test_marching_cubes.py"}], "method_code_mask": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom skimage.draw import ellipsoid\nfrom skimage.draw import ellipsoid_stats\nfrom skimage.measure import marching_cubes\nfrom skimage.measure import mesh_surface_area\n\n\ndef _same_mesh(vertices1, faces1, vertices2, faces2, tol=1e-10): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "alphanumeric_key", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/collection.py", "response": "import os\nfrom glob import glob\nimport re\nfrom collections.abc import Sequence\nfrom copy import copy\nimport numpy as np\nfrom PIL import Image\nfrom tifffile import TiffFile\n\n\ndef alphanumeric_key(s):\n    # Use regular expression to find all sequences of digits and non-digits\n    return [int(text) if text.isdigit() else text for text in re.split('([0-9]+)', s)]", "test_code_list": [{"test_code": "import os\nimport itertools\nimport numpy as np\nimport imageio.v3 as iio3\nfrom skimage import data_dir\nfrom skimage.io.collection import ImageCollection\nfrom skimage.io.collection import MultiImage\nfrom skimage.io.collection import alphanumeric_key\nfrom skimage.io import reset_plugins\nfrom skimage._shared import testing\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import fetch\nimport pytest\ndef test_string_split():\n    test_string = 'z23a'\n    test_str_result = ['z', 23, 'a']\n    assert_equal(alphanumeric_key(test_string), test_str_result)\n\ntest_string_split()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_collection.py"}], "method_code_mask": "import os\nfrom glob import glob\nimport re\nfrom collections.abc import Sequence\nfrom copy import copy\nimport numpy as np\nfrom PIL import Image\nfrom tifffile import TiffFile\n\n\ndef alphanumeric_key(s): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "_palette_is_grayscale", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/_plugins/pil_plugin.py", "response": "import numpy as np\nfrom PIL import Image\n\n\ndef _palette_is_grayscale(pil_image):\n    if pil_image.mode != 'P':\n        raise ValueError(\"Image must be in Palette mode (P)\")\n\n    palette = pil_image.getpalette()\n    is_grayscale = True\n\n    for i in range(0, len(palette), 3):\n        r = palette[i]\n        g = palette[i + 1]\n        b = palette[i + 2]\n        \n        # Check if the color is a shade of gray\n        if not (r == g == b):\n            is_grayscale = False\n            break\n\n    return is_grayscale", "test_code_list": [{"test_code": "import os\nfrom io import BytesIO\nfrom tempfile import NamedTemporaryFile\nimport numpy as np\nimport pytest\nfrom PIL import Image\nfrom skimage._shared import testing\nfrom skimage._shared._tempfile import temporary_file\nfrom skimage._shared._warnings import expected_warnings\nfrom skimage._shared.testing import assert_allclose\nfrom skimage._shared.testing import assert_array_almost_equal\nfrom skimage._shared.testing import assert_array_equal\nfrom skimage._shared.testing import assert_equal\nfrom skimage._shared.testing import color_check\nfrom skimage._shared.testing import fetch\nfrom skimage._shared.testing import mono_check\nfrom skimage.metrics import structural_similarity\ndef test_palette_is_gray():\n    gray = Image.open(fetch('data/palette_gray.png'))\n    assert _palette_is_grayscale(gray)\n    color = Image.open(fetch('data/palette_color.png'))\n    assert not _palette_is_grayscale(color)\n\ntest_palette_is_gray()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/io/tests/test_pil.py"}], "method_code_mask": "import numpy as np\nfrom PIL import Image\n\n\ndef _palette_is_grayscale(pil_image): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "intensity_range", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/exposure/exposure.py", "response": "import numpy as np\n\n\ndef intensity_range(image, range_values='image', clip_negative=False):\n    if range_values == 'image':\n        i_min = np.min(image)\n        i_max = np.max(image)\n    elif range_values == 'dtype':\n        i_min, i_max = np.iinfo(image.dtype).min, np.iinfo(image.dtype).max\n    elif isinstance(range_values, str):\n        i_min, i_max = np.iinfo(range_values).min, np.iinfo(range_values).max\n    elif isinstance(range_values, tuple) and len(range_values) == 2:\n        i_min, i_max = range_values\n    else:\n        raise ValueError(\"Invalid range_values parameter\")\n\n    if clip_negative and i_min < 0:\n        i_min = 0\n\n    return i_min, i_max", "test_code_list": [{"test_code": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\ndef test_intensity_range_clipped_float():\n    image = np.array([0.1, 0.2], dtype=np.float64)\n    out = intensity_range(image, range_values='dtype', clip_negative=True)\n    assert_array_equal(out, (0, 1))\n\ntest_intensity_range_clipped_float()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py"}], "method_code_mask": "import numpy as np\n\n\ndef intensity_range(image, range_values='image', clip_negative=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "scikit-image", "full_method_name": "norm_brightness_err", "method_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py", "response": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\n\n\ndef norm_brightness_err(img1, img2):\n    # Convert images to grayscale if they are in RGB format\n    if img1.ndim == 3:\n        img1 = rgb2gray(img1)\n    if img2.ndim == 3:\n        img2 = rgb2gray(img2)\n\n    # Calculate the absolute mean brightness difference\n    mean_diff = np.mean(np.abs(img1 - img2))\n\n    # Normalize the difference based on the maximum value of the image's data type\n    max_value = dtype_range[img1.dtype.type][1]\n    norm_brightness_error = mean_diff / max_value\n\n    return norm_brightness_error", "test_code_list": [{"test_code": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\ndef test_adapthist_borders():\n    \"\"\"Test border processing\"\"\"\n    img = rgb2gray(util.img_as_float(data.astronaut()))\n    img /= 100.0\n    img[img.shape[0] // 2, img.shape[1] // 2] = 1.0\n    border_index = -1\n    for kernel_size in range(51, 71, 2):\n        adapted = exposure.equalize_adapthist(img, kernel_size, clip_limit=0.5)\n        assert norm_brightness_err(adapted[:, border_index], img[:,\n            border_index]) > 0.1\n        assert norm_brightness_err(adapted[border_index, :], img[\n            border_index, :]) > 0.1\n\ntest_adapthist_borders()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/srcdata/Computation/scikit-image/skimage/exposure/tests/test_exposure.py"}], "method_code_mask": "import warnings\nimport numpy as np\nimport pytest\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_almost_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_equal\nfrom packaging.version import Version\nfrom skimage import data\nfrom skimage import exposure\nfrom skimage import util\nfrom skimage.color import rgb2gray\nfrom skimage.exposure.exposure import intensity_range\nfrom skimage.util.dtype import dtype_range\nfrom skimage._shared._warnings import expected_warnings\nimport dask.array as da\n\n\ndef norm_brightness_err(img1, img2): [MASK]\n"}
