{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "kruskal", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/minimum_spanning_tree_kruskal.py", "response": "from typing import List, Tuple\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])  # Path compression\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            # Union by rank\n            if self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n            elif self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n\ndef kruskal(num_nodes: int, edges: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:\n    # Sort edges based on their weight\n    edges.sort(key=lambda x: x[2])\n    \n    disjoint_set = DisjointSet(num_nodes)\n    mst_edges = []\n    \n    for a, b, w in edges:\n        if disjoint_set.find(a) != disjoint_set.find(b):\n            disjoint_set.union(a, b)\n            mst_edges.append((a, b, w))\n    \n    return mst_edges", "test_code_list": [{"test_code": "def test_kruskal_successful_result():\n    num_nodes = 9\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    result = kruskal(num_nodes, edges)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    assert sorted(expected) == sorted(result)\n\ntest_kruskal_successful_result()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/tests/test_min_spanning_tree_kruskal.py"}], "method_code_mask": "def kruskal(num_nodes: int, edges: list[tuple[int, int, int]]) ->list[tuple\n    [int, int, int]]: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "prisms_algorithm", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/minimum_spanning_tree_prims.py", "response": "import sys\nfrom collections import defaultdict\n\n\nclass Heap:\n\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = heap[start\n                    ], positions[start]\n                heap[start], positions[start] = temp, temp1\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(positions[smallest_child], self.\n                    get_position(positions[start]))\n                self.set_position(positions[start], temp)\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index -\n                1) / 2)\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\n\n\ndef prisms_algorithm(adjacency_list):\n    mst_edges = []\n    visited = set()\n    min_heap = []\n    positions = []\n    \n    # Start from the first vertex (arbitrarily chosen)\n    start_vertex = next(iter(adjacency_list))\n    visited.add(start_vertex)\n    \n    # Add all edges from the start vertex to the heap\n    for neighbor, weight in adjacency_list[start_vertex]:\n        min_heap.append(weight)\n        positions.append(neighbor)\n    \n    heap = Heap()\n    heap.heapify(min_heap, positions)\n    \n    while len(visited) < len(adjacency_list):\n        # Get the minimum edge\n        min_edge_index = heap.delete_minimum(min_heap, positions)\n        min_edge_weight = min_heap[min_edge_index]\n        \n        # Get the vertex connected by the minimum edge\n        next_vertex = positions[min_edge_index]\n        \n        if next_vertex not in visited:\n            visited.add(next_vertex)\n            mst_edges.append((start_vertex, next_vertex))\n            \n            # Add all edges from the new vertex to the heap\n            for neighbor, weight in adjacency_list[next_vertex]:\n                if neighbor not in visited:\n                    min_heap.append(weight)\n                    positions.append(neighbor)\n                    heap.bottom_to_top(weight, len(min_heap) - 1, min_heap, positions)\n    \n    return mst_edges", "test_code_list": [{"test_code": "from collections import defaultdict\ndef test_prim_successful_result():\n    num_nodes, num_edges = 9, 14\n    edges = [[0, 1, 4], [0, 7, 8], [1, 2, 8], [7, 8, 7], [7, 6, 1], [2, 8, \n        2], [8, 6, 6], [2, 3, 7], [2, 5, 4], [6, 5, 2], [3, 5, 14], [3, 4, \n        9], [5, 4, 10], [1, 7, 11]]\n    adjacency = defaultdict(list)\n    for node1, node2, cost in edges:\n        adjacency[node1].append([node2, cost])\n        adjacency[node2].append([node1, cost])\n    result = prisms_algorithm(adjacency)\n    expected = [[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, \n        3, 7], [0, 7, 8], [3, 4, 9]]\n    for answer in expected:\n        edge = tuple(answer[:2])\n        reverse = tuple(edge[::-1])\n        assert edge in result or reverse in result\n\ntest_prim_successful_result()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/graphs/tests/test_min_spanning_tree_prim.py"}], "method_code_mask": "import sys\nfrom collections import defaultdict\n\n\nclass Heap:\n\n    def __init__(self):\n        self.node_position = []\n\n    def get_position(self, vertex):\n        return self.node_position[vertex]\n\n    def set_position(self, vertex, pos):\n        self.node_position[vertex] = pos\n\n    def top_to_bottom(self, heap, start, size, positions):\n        if start > size // 2 - 1:\n            return\n        else:\n            if 2 * start + 2 >= size:\n                smallest_child = 2 * start + 1\n            elif heap[2 * start + 1] < heap[2 * start + 2]:\n                smallest_child = 2 * start + 1\n            else:\n                smallest_child = 2 * start + 2\n            if heap[smallest_child] < heap[start]:\n                temp, temp1 = heap[smallest_child], positions[smallest_child]\n                heap[smallest_child], positions[smallest_child] = heap[start\n                    ], positions[start]\n                heap[start], positions[start] = temp, temp1\n                temp = self.get_position(positions[smallest_child])\n                self.set_position(positions[smallest_child], self.\n                    get_position(positions[start]))\n                self.set_position(positions[start], temp)\n                self.top_to_bottom(heap, smallest_child, size, positions)\n\n    def bottom_to_top(self, val, index, heap, position):\n        temp = position[index]\n        while index != 0:\n            parent = int((index - 2) / 2) if index % 2 == 0 else int((index -\n                1) / 2)\n            if val < heap[parent]:\n                heap[index] = heap[parent]\n                position[index] = position[parent]\n                self.set_position(position[parent], index)\n            else:\n                heap[index] = val\n                position[index] = temp\n                self.set_position(temp, index)\n                break\n            index = parent\n        else:\n            heap[0] = val\n            position[0] = temp\n            self.set_position(temp, 0)\n\n    def heapify(self, heap, positions):\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            self.top_to_bottom(heap, i, len(heap), positions)\n\n    def delete_minimum(self, heap, positions):\n        temp = positions[0]\n        heap[0] = sys.maxsize\n        self.top_to_bottom(heap, 0, len(heap), positions)\n        return temp\n\n\ndef prisms_algorithm(adjacency_list): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "gen_gaussian_kernel", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/digital_image_processing/edge_detection/canny.py", "response": "import cv2\nimport numpy as np\n\n\ndef gen_gaussian_kernel(k_size, sigma):\n    # Create a 2D grid of (x, y) coordinates\n    ax = np.linspace(-(k_size // 2), k_size // 2, k_size)\n    xx, yy = np.meshgrid(ax, ax)\n\n    # Calculate the Gaussian kernel using the formula\n    g = np.exp(-(xx**2 + yy**2) / (2 * sigma**2))\n\n    # Normalize the kernel to ensure the sum of weights is 1\n    g /= np.sum(g)\n\n    return g", "test_code_list": [{"test_code": "import numpy as np\nfrom cv2 import COLOR_BGR2GRAY\nfrom cv2 import cvtColor\nfrom cv2 import imread\nfrom numpy import array\nfrom numpy import uint8\nfrom PIL import Image\nfrom os import getenv\ndef test_gen_gaussian_kernel():\n    resp = gen_gaussian_kernel(9, sigma=1.4)\n    assert resp.all()\n\ntest_gen_gaussian_kernel()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/digital_image_processing/test_digital_image_processing.py"}], "method_code_mask": "import cv2\nimport numpy as np\n\n\ndef gen_gaussian_kernel(k_size, sigma): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "miller_rabin", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/ciphers/deterministic_miller_rabin.py", "response": "import random\n\ndef miller_rabin(n: int, allow_probable: bool=False) -> bool:\n    if n < 2:\n        return False\n    if n in (2, 3):\n        return True\n    if n % 2 == 0:\n        return False\n\n    # Deterministic test limit\n    if n < 3.32e24:\n        # List of bases for deterministic testing\n        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n        for a in bases:\n            if a >= n:\n                break\n            if not miller_test(n, a):\n                return False\n        return True\n    elif not allow_probable:\n        raise ValueError(\"Number exceeds deterministic test limit and allow_probable is False.\")\n\n    # Probabilistic test\n    k = 40  # Number of iterations for the probabilistic test\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        if not miller_test(n, a):\n            return False\n    return True\n\ndef miller_test(n: int, a: int) -> bool:\n    d = n - 1\n    r = 0\n    while d % 2 == 0:\n        d //= 2\n        r += 1\n    x = pow(a, d, n)\n    if x == 1 or x == n - 1:\n        return True\n    for _ in range(r - 1):\n        x = pow(x, 2, n)\n        if x == n - 1:\n            return True\n    return False", "test_code_list": [{"test_code": "def test_miller_rabin() ->None:\n    \"\"\"Testing a nontrivial (ends in 1, 3, 7, 9) composite\n    and a prime in each range.\n    \"\"\"\n    assert not miller_rabin(561)\n    assert miller_rabin(563)\n    assert not miller_rabin(838201)\n    assert miller_rabin(838207)\n    assert not miller_rabin(17316001)\n    assert miller_rabin(17316017)\n    assert not miller_rabin(3078386641)\n    assert miller_rabin(3078386653)\n    assert not miller_rabin(1713045574801)\n    assert miller_rabin(1713045574819)\n    assert not miller_rabin(2779799728307)\n    assert miller_rabin(2779799728327)\n    assert not miller_rabin(113850023909441)\n    assert miller_rabin(113850023909527)\n    assert not miller_rabin(1275041018848804351)\n    assert miller_rabin(1275041018848804391)\n    assert not miller_rabin(79666464458507787791867)\n    assert miller_rabin(79666464458507787791951)\n    assert not miller_rabin(552840677446647897660333)\n    assert miller_rabin(552840677446647897660359)\n\ntest_miller_rabin()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/ciphers/deterministic_miller_rabin.py"}], "method_code_mask": "def miller_rabin(n: int, allow_probable: bool=False) ->bool: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "is_prime", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py", "response": "import math\nimport unittest\nimport pytest\n\n\ndef is_prime(number: int) -> bool:\n    if number <= 1:\n        raise ValueError(\"Input must be a positive integer greater than 1.\")\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    i = 5\n    while i * i <= number:\n        if number % i == 0 or number % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "test_code_list": [{"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_primes(self):\n        assert is_prime(2)\n        assert is_prime(3)\n        assert is_prime(5)\n        assert is_prime(7)\n        assert is_prime(11)\n        assert is_prime(13)\n        assert is_prime(17)\n        assert is_prime(19)\n        assert is_prime(23)\n        assert is_prime(29)\n    \nTest().test_primes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py"}, {"test_code": "import math\nimport unittest\nimport pytest\n\nclass Test(unittest.TestCase):\n    def test_not_primes(self):\n        with pytest.raises(ValueError):\n            is_prime(-19)\n        assert not is_prime(0\n            ), \"Zero doesn't have any positive factors, primes must have exactly two.\"\n        assert not is_prime(1\n            ), 'One only has 1 positive factor, primes must have exactly two.'\n        assert not is_prime(2 * 2)\n        assert not is_prime(2 * 3)\n        assert not is_prime(3 * 3)\n        assert not is_prime(3 * 5)\n        assert not is_prime(3 * 5 * 7)\n    \nTest().test_not_primes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/prime_check.py"}], "method_code_mask": "import math\nimport unittest\nimport pytest\n\n\ndef is_prime(number: int) ->bool: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "abs_min", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/abs.py", "response": "import doctest\n\n\ndef abs_val(num: float) -> float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) -> int:\n    if not x:\n        raise ValueError(\"The list is empty.\")\n    \n    min_value = x[0]\n    for num in x:\n        if abs_val(num) < abs_val(min_value) or (abs_val(num) == abs_val(min_value) and num > min_value):\n            min_value = num\n            \n    return min_value", "test_code_list": [{"test_code": "import doctest\ndef abs_max_sort(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max_sort([0,5,1,11])\n    11\n    >>> abs_max_sort([3,-10,-2])\n    -10\n    >>> abs_max_sort([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max_sort() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max_sort() arg is an empty sequence')\n    return sorted(x, key=abs)[-1]\ndef abs_max(x: list[int]) ->int:\n    \"\"\"\n    >>> abs_max([0,5,1,11])\n    11\n    >>> abs_max([3,-10,-2])\n    -10\n    >>> abs_max([])\n    Traceback (most recent call last):\n        ...\n    ValueError: abs_max() arg is an empty sequence\n    \"\"\"\n    if len(x) == 0:\n        raise ValueError('abs_max() arg is an empty sequence')\n    j = x[0]\n    for i in x:\n        if abs(i) > abs(j):\n            j = i\n    return j\ndef test_abs_val():\n    \"\"\"\n    >>> test_abs_val()\n    \"\"\"\n    assert abs_val(0) == 0\n    assert abs_val(34) == 34\n    assert abs_val(-100000000000) == 100000000000\n    a = [-3, -1, 2, -11]\n    assert abs_max(a) == -11\n    assert abs_max_sort(a) == -11\n    assert abs_min(a) == -1\ntest_abs_val()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/abs.py"}], "method_code_mask": "import doctest\n\n\ndef abs_val(num: float) ->float:\n    \"\"\"\n    Find the absolute value of a number.\n\n    >>> abs_val(-5.1)\n    5.1\n    >>> abs_val(-5) == abs_val(5)\n    True\n    >>> abs_val(0)\n    0\n    \"\"\"\n    return -num if num < 0 else num\n\n\ndef abs_min(x: list[int]) ->int: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "signum", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/signum.py", "response": "def signum(num: float) -> int:\n    if num < 0:\n        return -1\n    elif num > 0:\n        return 1\n    else:\n        return 0", "test_code_list": [{"test_code": "def test_signum() ->None:\n    \"\"\"\n    Tests the signum function\n    >>> test_signum()\n    \"\"\"\n    assert signum(5) == 1\n    assert signum(-5) == -1\n    assert signum(0) == 0\n    assert signum(10.5) == 1\n    assert signum(-10.5) == -1\n    assert signum(1e-06) == 1\n    assert signum(-1e-06) == -1\n    assert signum(123456789) == 1\n    assert signum(-123456789) == -1\n\ntest_signum()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/maths/signum.py"}], "method_code_mask": "def signum(num: float) ->int: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "identity", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/matrix/matrix_operation.py", "response": "from __future__ import annotations\nfrom typing import Any\nimport doctest\n\n\ndef identity(n: int) -> list[list[int]]:\n    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]", "test_code_list": [{"test_code": "import logging\nimport sys\nimport numpy as np\nimport pytest\n@pytest.mark.mat_ops()\ndef test_identity():\n    act = np.identity(5).tolist()\n    theo = identity(5)\n    assert theo == act\n\ntest_identity()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/matrix/tests/test_matrix_operation.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Any\nimport doctest\n\n\ndef identity(n: int) ->list[list[int]]: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "calc_profit", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/greedy_knapsack.py", "response": "def calc_profit(profit: list, weight: list, max_weight: int) -> int:\n    # Validate input data\n    if len(profit) != len(weight):\n        raise ValueError(\"Profit and weight lists must have the same length.\")\n    if max_weight <= 0:\n        raise ValueError(\"Maximum weight must be greater than zero.\")\n    if any(p < 0 for p in profit) or any(w < 0 for w in weight):\n        raise ValueError(\"Profit and weight values must be non-negative.\")\n\n    # Calculate profit-to-weight ratio and create a list of tuples (ratio, profit, weight)\n    ratio_list = [(p / w if w > 0 else 0, p, w) for p, w in zip(profit, weight)]\n    \n    # Sort the list by profit-to-weight ratio in descending order\n    ratio_list.sort(reverse=True, key=lambda x: x[0])\n\n    total_profit = 0\n    current_weight = 0\n\n    # Select bags based on the highest profit-to-weight ratio\n    for ratio, p, w in ratio_list:\n        if current_weight + w <= max_weight:\n            total_profit += p\n            current_weight += w\n        else:\n            # If the next bag cannot be fully taken, take the fraction of it\n            remaining_weight = max_weight - current_weight\n            if remaining_weight > 0:\n                total_profit += (p / w) * remaining_weight\n            break\n\n    return int(total_profit)", "test_code_list": [{"test_code": "import unittest\nimport pytest\n\nclass TestClass(unittest.TestCase):\n    def test_sorted(self):\n        \"\"\"\n            calc_profit takes the required argument (profit, weight, max_weight)\n            and returns whether the answer matches to the expected ones\n            \"\"\"\n        profit = [10, 20, 30, 40, 50, 60]\n        weight = [2, 4, 6, 8, 10, 12]\n        max_weight = 100\n        assert calc_profit(profit, weight, max_weight) == 210\n    \nTestClass().test_sorted()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_greedy_knapsack.py"}], "method_code_mask": "def calc_profit(profit: list, weight: list, max_weight: int) ->int: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "knapsack", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/knapsack.py", "response": "from __future__ import annotations\nimport doctest\n\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int:\n    # Base case: no items left or capacity is 0\n    if counter < 0 or capacity <= 0:\n        return 0\n    \n    # If the weight of the current item is more than the capacity, skip it\n    if weights[counter] > capacity:\n        return knapsack(capacity, weights, values, counter - 1)\n    \n    # Return the maximum of two cases: \n    # 1. Current item included\n    # 2. Current item excluded\n    include_item = values[counter] + knapsack(capacity - weights[counter], weights, values, counter - 1)\n    exclude_item = knapsack(capacity, weights, values, counter - 1)\n    \n    return max(include_item, exclude_item)", "test_code_list": [{"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_base_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 0\n        val = [0]\n        w = [0]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n        val = [60]\n        w = [10]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 0\n    \nTest().test_base_case()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_easy_case(self):\n        \"\"\"\n            test for the base case\n            \"\"\"\n        cap = 3\n        val = [1, 2, 3]\n        w = [3, 2, 1]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 5\n    \nTest().test_easy_case()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}, {"test_code": "import unittest\n\nclass Test(unittest.TestCase):\n    def test_knapsack(self):\n        \"\"\"\n            test for the knapsack\n            \"\"\"\n        cap = 50\n        val = [60, 100, 120]\n        w = [10, 20, 30]\n        c = len(val)\n        assert knapsack(cap, w, val, c) == 220\n    \nTest().test_knapsack()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/knapsack/tests/test_knapsack.py"}], "method_code_mask": "from __future__ import annotations\nimport doctest\n\n\ndef knapsack(capacity: int, weights: list[int], values: list[int], counter: int\n    ) ->int: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "rabin_karp", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/strings/rabin_karp.py", "response": "modulus = 1000003\nalphabet_size = 256\n\n\ndef rabin_karp(pattern: str, text: str) -> bool:\n    m = len(pattern)\n    n = len(text)\n    if m > n:\n        return False\n\n    # Calculate the hash value of the pattern and the first window of text\n    pattern_hash = 0\n    text_hash = 0\n    for i in range(m):\n        pattern_hash = (pattern_hash * alphabet_size + ord(pattern[i])) % modulus\n        text_hash = (text_hash * alphabet_size + ord(text[i])) % modulus\n\n    # Precompute the value of alphabet_size^(m-1) % modulus\n    h = pow(alphabet_size, m - 1, modulus)\n\n    # Slide the pattern over text one by one\n    for i in range(n - m + 1):\n        # Check the hash values\n        if pattern_hash == text_hash:\n            # Check for characters one by one\n            if text[i:i + m] == pattern:\n                return True\n\n        # Calculate the hash value for the next window of text\n        if i < n - m:\n            text_hash = (text_hash - ord(text[i]) * h) % modulus\n            text_hash = (text_hash * alphabet_size + ord(text[i + m])) % modulus\n            text_hash = (text_hash + modulus) % modulus  # Ensure positive hash value\n\n    return False", "test_code_list": [{"test_code": "def test_rabin_karp() ->None:\n    \"\"\"\n    >>> test_rabin_karp()\n    Success.\n    \"\"\"\n    pattern = 'abc1abc12'\n    text1 = 'alskfjaldsabc1abc1abc12k23adsfabcabc'\n    text2 = 'alskfjaldsk23adsfabcabc'\n    assert rabin_karp(pattern, text1)\n    assert not rabin_karp(pattern, text2)\n    pattern = 'ABABX'\n    text = 'ABABZABABYABABX'\n    assert rabin_karp(pattern, text)\n    pattern = 'AAAB'\n    text = 'ABAAAAAB'\n    assert rabin_karp(pattern, text)\n    pattern = 'abcdabcy'\n    text = 'abcxabcdabxabcdabcdabcy'\n    assert rabin_karp(pattern, text)\n    pattern = 'L\u00fc'\n    text = 'L\u00fcsai'\n    assert rabin_karp(pattern, text)\n    pattern = 'Lue'\n    assert not rabin_karp(pattern, text)\n    print('Success.')\n\ntest_rabin_karp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/strings/rabin_karp.py"}], "method_code_mask": "modulus = 1000003\nalphabet_size = 256\n\n\ndef rabin_karp(pattern: str, text: str) ->bool: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "find_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.rank: int = 0\n        self.parent: Node = self  # Initially, a node is its own parent\n\n\ndef find_set(x: Node) -> Node:\n    if x.parent != x:  # If x is not the root\n        x.parent = find_set(x.parent)  # Path compression\n    return x.parent  # Return the root node", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_set(x: Node) ->Node: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "make_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.rank = 0  # Initialize rank to 0\n        self.parent = self  # Set parent to point to itself\n\n\ndef make_set(x: Node) -> None:\n    x.rank = 0  # Set the rank of the node to 0\n    x.parent = x  # Set the parent of the node to itself", "test_code_list": [{"test_code": "def find_python_set(node: Node) ->set:\n    \"\"\"\n    Return a Python Standard Library set that contains i.\n    \"\"\"\n    sets = {0, 1, 2}, {3, 4, 5}\n    for s in sets:\n        if node.data in s:\n            return s\n    msg = f'{node.data} is not in {sets}'\n    raise ValueError(msg)\ndef find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef make_set(x: Node) ->None: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "find_python_set", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py", "response": "class Node:\n\n    def __init__(self, data: int) -> None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_python_set(node: Node) -> set:\n    sets = {frozenset({1, 2, 3}), frozenset({4, 5, 6}), frozenset({7, 8, 9})}\n    \n    for s in sets:\n        if node.data in s:\n            return s\n    \n    raise ValueError(f\"{node.data} is not in {sets}\")", "test_code_list": [{"test_code": "def find_set(x: Node) ->Node:\n    \"\"\"\n    Return the parent of x\n    \"\"\"\n    if x != x.parent:\n        x.parent = find_set(x.parent)\n    return x.parent\ndef union_set(x: Node, y: Node) ->None:\n    \"\"\"\n    Union of two sets.\n    set with bigger rank should be parent, so that the\n    disjoint set tree will be more flat.\n    \"\"\"\n    x, y = find_set(x), find_set(y)\n    if x == y:\n        return\n    elif x.rank > y.rank:\n        y.parent = x\n    else:\n        x.parent = y\n        if x.rank == y.rank:\n            y.rank += 1\ndef make_set(x: Node) ->None:\n    \"\"\"\n    Make x as a set.\n    \"\"\"\n    x.rank = 0\n    x.parent = x\ndef test_disjoint_set() ->None:\n    \"\"\"\n    >>> test_disjoint_set()\n    \"\"\"\n    vertex = [Node(i) for i in range(6)]\n    for v in vertex:\n        make_set(v)\n    union_set(vertex[0], vertex[1])\n    union_set(vertex[1], vertex[2])\n    union_set(vertex[3], vertex[4])\n    union_set(vertex[3], vertex[5])\n    for node0 in vertex:\n        for node1 in vertex:\n            if find_python_set(node0).isdisjoint(find_python_set(node1)):\n                assert find_set(node0) != find_set(node1)\n            else:\n                assert find_set(node0) == find_set(node1)\ntest_disjoint_set()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/data_structures/disjoint_set/disjoint_set.py"}], "method_code_mask": "class Node:\n\n    def __init__(self, data: int) ->None:\n        self.data = data\n        self.rank: int\n        self.parent: Node\n\n\ndef find_python_set(node: Node) ->set: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "total_time", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef total_time(init_velocity: float, angle: float) -> float:\n    check_args(init_velocity, angle)\n    total_time = (2 * init_velocity * sin(angle_to_radians(angle))) / g\n    return round(total_time, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef total_time(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "horizontal_distance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) -> float:\n    check_args(init_velocity, angle)\n    # Convert angle to radians\n    angle_rad = angle_to_radians(angle)\n    # Calculate horizontal distance using the projectile motion formula\n    distance = (init_velocity ** 2) * sin(2 * angle_rad) / g\n    return round(distance, 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef max_height(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the maximum height that the object reach\n    Formula:\n            v_0^2 * sin^2(alpha)\n            --------------------\n                   2g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    22.94\n    >>> max_height(100, 78)\n    487.82\n    >>> max_height(\"a\", 20)\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(init_velocity ** 2 * sin(radians) ** 2 / (2 * g), 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "Python", "full_method_name": "max_height", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py", "response": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) -> None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\n\n\ndef max_height(init_velocity: float, angle: float) -> float:\n    \"\"\"\n    Calculate the maximum height of the object during its trajectory.\n    Formula:\n            (v_0^2 * sin^2(alpha))\n            ---------------------\n                   2 * g\n    v_0 - initial velocity\n    alpha - angle\n    >>> max_height(30, 45)\n    11.48\n    >>> max_height(100, 78)\n    254.83\n    >>> max_height(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> max_height(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round((init_velocity ** 2 * sin(radians) ** 2) / (2 * g), 2)", "test_code_list": [{"test_code": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ndef total_time(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns total time of the motion\n    Formula:\n            2 * v_0 * sin(alpha)\n            --------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> total_time(30, 45)\n    4.33\n    >>> total_time(100, 78)\n    19.95\n    >>> total_time(-10, 40)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> total_time(30, \"b\")\n    Traceback (most recent call last):\n        ...\n    TypeError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(angle)\n    return round(2 * init_velocity * sin(radians) / g, 2)\ndef test_motion() ->None:\n    \"\"\"\n    >>> test_motion()\n    \"\"\"\n    v0, angle = 25, 20\n    assert horizontal_distance(v0, angle) == 40.97\n    assert max_height(v0, angle) == 3.73\n    assert total_time(v0, angle) == 1.74\ntest_motion()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/General/Python/physics/horizontal_projectile_motion.py"}], "method_code_mask": "from math import radians as angle_to_radians\nfrom math import sin\nfrom doctest import testmod\ng = 9.80665\n\n\ndef check_args(init_velocity: float, angle: float) ->None:\n    \"\"\"\n    Check that the arguments are valid\n    \"\"\"\n    if not isinstance(init_velocity, (int, float)):\n        raise TypeError('Invalid velocity. Should be a positive number.')\n    if not isinstance(angle, (int, float)):\n        raise TypeError('Invalid angle. Range is 1-90 degrees.')\n    if angle > 90 or angle < 1:\n        raise ValueError('Invalid angle. Range is 1-90 degrees.')\n    if init_velocity < 0:\n        raise ValueError('Invalid velocity. Should be a positive number.')\n\n\ndef horizontal_distance(init_velocity: float, angle: float) ->float:\n    \"\"\"\n    Returns the horizontal distance that the object cover\n    Formula:\n            v_0^2 * sin(2 * alpha)\n            ---------------------\n                   g\n    v_0 - initial velocity\n    alpha - angle\n    >>> horizontal_distance(30, 45)\n    91.77\n    >>> horizontal_distance(100, 78)\n    414.76\n    >>> horizontal_distance(-1, 20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid velocity. Should be a positive number.\n    >>> horizontal_distance(30, -20)\n    Traceback (most recent call last):\n        ...\n    ValueError: Invalid angle. Range is 1-90 degrees.\n    \"\"\"\n    check_args(init_velocity, angle)\n    radians = angle_to_radians(2 * angle)\n    return round(init_velocity ** 2 * sin(radians) / g, 2)\n\n\ndef max_height(init_velocity: float, angle: float) ->float: [MASK]\n"}
