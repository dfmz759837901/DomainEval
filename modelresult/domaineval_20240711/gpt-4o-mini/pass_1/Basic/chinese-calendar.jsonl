{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_dates", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end):\n    \"\"\"\n    Generate a list of all dates between the specified start date and end date, inclusive.\n\n    :param start: The start date of the range (datetime.date or datetime.datetime)\n    :param end: The end date of the range (datetime.date or datetime.datetime)\n    :return: A list of datetime.date objects representing each date in the range\n    \"\"\"\n    start = _wrap_date(start)\n    end = _wrap_date(end)\n    \n    delta = end - start\n    return [start + datetime.timedelta(days=i) for i in range(delta.days + 1)]", "test_code_list": [{"test_code": "import datetime\nimport unittest\nimport chinese_calendar\n\nclass HelperTests(unittest.TestCase):\n    def test_get_dates(self):\n        cases = [((2018, 2, 1), (2018, 1, 1), 0), ((2018, 1, 1), (2018, 1, 1), \n            1), ((2018, 1, 1), (2018, 1, 2), 2), ((2018, 1, 1), (2018, 2, 1), \n            32), ((2019, 1, 1), (2020, 1, 1), 366), ((2020, 1, 1), (2021, 1, 1),\n            367)]\n        for start, end, duration in cases:\n            start, end = datetime.date(*start), datetime.date(*end)\n            dates = get_dates(start, end)\n            self.assertEqual(duration, len(dates))\n            if dates:\n                self.assertIn(start, dates)\n                self.assertIn(end, dates)\n    \nHelperTests().test_get_dates()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_helpers.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef get_dates(start, end): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_workdays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True):\n    \"\"\"\n    Get a list of workdays between the specified start and end dates.\n\n    :type start: datetime.date | datetime.datetime\n    :type end: datetime.date | datetime.datetime\n    :type include_weekends: bool\n    :rtype: list[datetime.date]\n    \"\"\"\n    dates = get_dates(start, end)\n    workdays_list = []\n    \n    for date in dates:\n        if is_workday(date):\n            workdays_list.append(date)\n        elif include_weekends and date.weekday() >= 5:  # Saturday or Sunday\n            workdays_list.append(date)\n\n    return workdays_list", "test_code_list": [{"test_code": "import datetime\nimport unittest\nimport chinese_calendar\n\nclass HelperTests(unittest.TestCase):\n    def test_get_workdays_holidays(self):\n        cases = [((2018, 2, 1), (2018, 1, 1), 0, 0, 0, 0), ((2018, 1, 1), (2018,\n            1, 1), 1, 1, 0, 0), ((2018, 1, 1), (2018, 1, 7), 3, 1, 4, 4), ((\n            2018, 1, 1), (2018, 2, 1), 9, 1, 23, 23), ((2018, 2, 1), (2018, 3, \n            1), 11, 7, 18, 16)]\n        for start, end, include_weekends, exclude_weekends, workdays, workdays_exclude_weekends in cases:\n            start, end = datetime.date(*start), datetime.date(*end)\n            self.assertEqual(include_weekends, len(chinese_calendar.\n                get_holidays(start, end)))\n            self.assertEqual(exclude_weekends, len(chinese_calendar.\n                get_holidays(start, end, include_weekends=False)))\n            self.assertEqual(workdays, len(get_workdays(start,\n                end)))\n            self.assertEqual(workdays_exclude_weekends, len(chinese_calendar.\n                get_workdays(start, end, include_weekends=False)))\n    \nHelperTests().test_get_workdays_holidays()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_helpers.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_dates(start, end):\n    \"\"\"\n    get dates between start date and end date. (includes start date and end date)\n\n    :type start: datetime.date | datetime.datetime\n    :type end:  datetime.date | datetime.datetime\n    :rtype: list[datetime.date]\n    \"\"\"\n    start, end = map(_wrap_date, (start, end))\n    delta_days = (end - start).days\n    return [(start + datetime.timedelta(days=delta)) for delta in range(\n        delta_days + 1)]\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_workdays(start, end, include_weekends=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holidays", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True):\n    # Ensure start and end are datetime.date objects\n    if isinstance(start, datetime.datetime):\n        start = start.date()\n    if isinstance(end, datetime.datetime):\n        end = end.date()\n\n    # Create a set to hold holidays\n    holiday_set = set(holidays)\n\n    # Generate the list of holidays in the range\n    holidays_in_range = []\n    current_date = start\n\n    while current_date <= end:\n        if current_date in holiday_set:\n            holidays_in_range.append(current_date)\n        elif include_weekends and current_date.weekday() >= 5:  # Saturday or Sunday\n            holidays_in_range.append(current_date)\n        current_date += datetime.timedelta(days=1)\n\n    return holidays_in_range", "test_code_list": [{"test_code": "import datetime\nimport unittest\nimport chinese_calendar\n\nclass HelperTests(unittest.TestCase):\n    def test_get_workdays_holidays(self):\n        cases = [((2018, 2, 1), (2018, 1, 1), 0, 0, 0, 0), ((2018, 1, 1), (2018,\n            1, 1), 1, 1, 0, 0), ((2018, 1, 1), (2018, 1, 7), 3, 1, 4, 4), ((\n            2018, 1, 1), (2018, 2, 1), 9, 1, 23, 23), ((2018, 2, 1), (2018, 3, \n            1), 11, 7, 18, 16)]\n        for start, end, include_weekends, exclude_weekends, workdays, workdays_exclude_weekends in cases:\n            start, end = datetime.date(*start), datetime.date(*end)\n            self.assertEqual(include_weekends, len(chinese_calendar.\n                get_holidays(start, end)))\n            self.assertEqual(exclude_weekends, len(chinese_calendar.\n                get_holidays(start, end, include_weekends=False)))\n            self.assertEqual(workdays, len(chinese_calendar.get_workdays(start,\n                end)))\n            self.assertEqual(workdays_exclude_weekends, len(chinese_calendar.\n                get_workdays(start, end, include_weekends=False)))\n    \nHelperTests().test_get_workdays_holidays()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_helpers.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holidays(start, end, include_weekends=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "find_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None):\n    \"\"\"\n    Find the workday after a specified number of days from a given date.\n\n    :param delta_days: The number of days to look ahead (positive) or behind (negative).\n    :param date: The starting date from which to calculate the next workday. If not provided, the current date is used.\n    :return: The date of the workday found after considering the delta_days from the specified date.\n    :rtype: datetime.date\n    \"\"\"\n    if date is None:\n        date = datetime.date.today()\n    date = _wrap_date(date)\n\n    while delta_days != 0:\n        date += datetime.timedelta(days=1 if delta_days > 0 else -1)\n        if is_workday(date):\n            delta_days += -1 if delta_days > 0 else 1\n\n    return date", "test_code_list": [{"test_code": "import datetime\nimport unittest\nimport chinese_calendar\n\nclass HelperTests(unittest.TestCase):\n    def test_find_workday(self):\n        dates = [datetime.date(2017, 12, 30), datetime.date(2017, 12, 31),\n            datetime.date(2018, 1, 1), datetime.date(2018, 1, 2)]\n        cases = [[find_workday(i, date) for i in range(-7, 7)] for\n            date in dates]\n        for i in range(len(cases) - 1):\n            self.assertListEqual(cases[i], cases[i + 1])\n    \nHelperTests().test_find_workday()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_helpers.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_workday(date):\n    \"\"\"\n    check if one date is workday in China.\n    in other words, Chinese people works at that day.\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    weekday = date.weekday()\n    return bool(date in workdays.keys() or weekday <= 4 and date not in\n        holidays.keys())\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef find_workday(delta_days=0, date=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_workday", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date):\n    # Ensure the input is a date object\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    \n    # Check if the date is a weekend (Saturday or Sunday)\n    if date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday\n        return False\n    \n    # Check if the date is a national holiday\n    if date in holidays:\n        return False\n    \n    # Check if the date is a day off in lieu of a holiday\n    if date in in_lieu_days:\n        return False\n    \n    # If none of the above conditions are met, it is a workday\n    return True", "test_code_list": [{"test_code": "import datetime\nimport unittest\nfrom chinese_calendar import Holiday\nfrom chinese_calendar import get_holiday_detail\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\n\nclass BasicTests(unittest.TestCase):\n    def test_opposite(self):\n        date = datetime.date.today()\n        self.assertEqual(not is_workday(date), is_holiday(date))\n    \nBasicTests().test_opposite()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_basics.py"}, {"test_code": "import datetime\nimport unittest\nfrom chinese_calendar import Holiday\nfrom chinese_calendar import get_holiday_detail\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\n\nclass BasicTests(unittest.TestCase):\n    def test_holidays(self):\n        dates = [datetime.date(year=2017, month=5, day=30), datetime.date(year=\n            2017, month=6, day=4), datetime.date(year=2017, month=10, day=1),\n            datetime.date(year=2018, month=5, day=1)]\n        for date in dates:\n            self.assertFalse(is_workday(date))\n            self.assertTrue(is_holiday(date))\n    \nBasicTests().test_holidays()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_basics.py"}, {"test_code": "import datetime\nimport unittest\nfrom chinese_calendar import Holiday\nfrom chinese_calendar import get_holiday_detail\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\n\nclass BasicTests(unittest.TestCase):\n    def test_workdays(self):\n        dates = [datetime.date(year=2017, month=5, day=27), datetime.date(year=\n            2017, month=6, day=5), datetime.date(year=2017, month=10, day=31),\n            datetime.date(year=2018, month=5, day=10)]\n        for date in dates:\n            self.assertFalse(is_holiday(date))\n            self.assertTrue(is_workday(date))\n    \nBasicTests().test_workdays()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_basics.py"}, {"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_english(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = calendar.get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_english()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}, {"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_chinese(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = calendar.get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_chinese()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef is_workday(date): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date):\n    if isinstance(date, datetime.datetime):\n        date = date.date()  # Convert to date if it's a datetime object\n\n    if date in holidays:\n        return True, holidays[date]\n    elif date in in_lieu_days:\n        return True, in_lieu_days[date]\n    elif date in workdays:\n        return False, None\n    else:\n        return False, None", "test_code_list": [{"test_code": "import datetime\nimport unittest\nfrom chinese_calendar import Holiday\nfrom chinese_calendar import get_holiday_detail\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\n\nclass BasicTests(unittest.TestCase):\n    def test_detail(self):\n        cases = [((2018, 2, 10), (True, None)), ((2018, 2, 11), (False, Holiday\n            .spring_festival.value)), ((2018, 2, 12), (False, None)), ((2018, 2,\n            15), (True, Holiday.spring_festival.value))]\n        for date, expected_result in cases:\n            self.assertEqual(expected_result, get_holiday_detail(datetime.date(\n                *date)))\n    \nBasicTests().test_detail()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_basics.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_holiday_detail(date): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_holiday_detail", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date):\n    \"\"\"\n    Check if a given date is a holiday in China and return holiday details.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: tuple[bool, str | None]\n    \"\"\"\n    date = _validate_date(date)\n    \n    # Check if the date is a holiday\n    if date in holidays:\n        return True, holidays[date]\n    \n    # Check if the date is a weekend\n    if date.weekday() in (5, 6):  # Saturday or Sunday\n        return False, None\n    \n    # Check if the date is a workday designated for work\n    if date in workdays:\n        return False, None\n    \n    return False, None", "test_code_list": [{"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_english(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_english()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}, {"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_chinese(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert chinese_calendar.is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_chinese()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef get_holiday_detail(date): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "is_in_lieu", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date):\n    \"\"\"\n    Check if the given date is an in-lieu day in China.\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: bool\n    \"\"\"\n    date = _validate_date(date)\n    return date in in_lieu_days", "test_code_list": [{"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_english(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = calendar.get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_english()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}, {"test_code": "import unittest\nimport datetime\nfrom chinese_calendar import is_holiday\nfrom chinese_calendar import is_workday\nimport chinese_calendar as calendar\nimport chinese_calendar\n\nclass DocTests(unittest.TestCase):\n    def test_same_code_as_readme_chinese(self):\n        import datetime\n        from chinese_calendar import is_holiday, is_workday\n        april_last = datetime.date(2018, 4, 30)\n        assert is_workday(april_last) is False\n        assert is_holiday(april_last) is True\n        import chinese_calendar as calendar\n        on_holiday, holiday_name = calendar.get_holiday_detail(april_last)\n        assert on_holiday is True\n        assert holiday_name == calendar.Holiday.labour_day.value\n        import chinese_calendar\n        assert is_in_lieu(datetime.date(2006, 2, 1)) is False\n        assert is_in_lieu(datetime.date(2006, 2, 2)) is True\n    \nDocTests().test_same_code_as_readme_chinese()\n", "code_start": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\n", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_document.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef _wrap_date(date):\n    \"\"\"\n    transform datetime.datetime into datetime.date\n\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date\n    \"\"\"\n    if isinstance(date, datetime.datetime):\n        date = date.date()\n    return date\n\n\ndef _validate_date(*dates):\n    \"\"\"\n    check if the date(s) is supported\n    :type date: datetime.date | datetime.datetime\n    :rtype: datetime.date | list[datetime.date]\n    \"\"\"\n    if len(dates) != 1:\n        return list(map(_validate_date, dates))\n    date = _wrap_date(dates[0])\n    if not isinstance(date, datetime.date):\n        raise NotImplementedError(\n            'unsupported type {}, expected type is datetime.date'.format(\n            type(date)))\n    min_year, max_year = min(holidays.keys()).year, max(holidays.keys()).year\n    if not min_year <= date.year <= max_year:\n        raise NotImplementedError(\n            'no available data for year {}, only year between [{}, {}] supported'\n            .format(date.year, min_year, max_year))\n    return date\n\n\ndef is_in_lieu(date): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "chinese-calendar", "full_method_name": "get_solar_terms", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/chinese_calendar/utils.py", "response": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end):\n    if not (1900 <= start.year <= 2100) or not (1900 <= end.year <= 2100):\n        raise ValueError(\"Start and end years must be between 1900 and 2100.\")\n    \n    solar_terms = []\n    for i in range(24):\n        year = start.year\n        C = SOLAR_TERMS_C_NUMS[i]\n        D = SOLAR_TERMS_DELTA[i]\n        \n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            D += 1  # Adjust for leap years\n        \n        # Calculate the date of the solar term\n        term_date = datetime.date(year, SOLAR_TERMS_MONTH[i], 1) + datetime.timedelta(days=D)\n        \n        # Adjust for the turn of the century\n        if year == 2000 and i >= 12:\n            term_date += datetime.timedelta(days=1)\n        \n        if start <= term_date <= end:\n            solar_terms.append((term_date, SolarTerms[i]))\n    \n    return solar_terms", "test_code_list": [{"test_code": "import datetime\nimport unittest\nimport chinese_calendar\n\nclass SolarTermTests(unittest.TestCase):\n    def test_get_solar_terms(self):\n        start = datetime.date(2000, 1, 1)\n        end = datetime.date(2000, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2000, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2000, 1, \n            21), '\u5927\u5bd2'), (datetime.date(2000, 2, 4), '\u7acb\u6625'), (datetime.date(2000,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2000, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2000, 3, 20), '\u6625\u5206'), (datetime.date(2000, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2000, 4, 20), '\u8c37\u96e8'), (datetime.date(2000, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2000, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2000, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2000, 6, 21), '\u590f\u81f3'), (datetime.date(2000, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2000, 7, 22), '\u5927\u6691'), (datetime.date(2000, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2000, 8, 23), '\u5904\u6691'), (datetime.date(2000,\n            9, 7), '\u767d\u9732'), (datetime.date(2000, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2000, 10, 8), '\u5bd2\u9732'), (datetime.date(2000, 10, 23), '\u971c\u964d'), (datetime\n            .date(2000, 11, 7), '\u7acb\u51ac'), (datetime.date(2000, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2000, 12, 7), '\u5927\u96ea'), (datetime.date(2000, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2004, 1, 1)\n        end = datetime.date(2004, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2004, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2004, 1, \n            21), '\u5927\u5bd2'), (datetime.date(2004, 2, 4), '\u7acb\u6625'), (datetime.date(2004,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2004, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2004, 3, 20), '\u6625\u5206'), (datetime.date(2004, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2004, 4, 20), '\u8c37\u96e8'), (datetime.date(2004, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2004, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2004, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2004, 6, 21), '\u590f\u81f3'), (datetime.date(2004, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2004, 7, 22), '\u5927\u6691'), (datetime.date(2004, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2004, 8, 23), '\u5904\u6691'), (datetime.date(2004,\n            9, 7), '\u767d\u9732'), (datetime.date(2004, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2004, 10, 8), '\u5bd2\u9732'), (datetime.date(2004, 10, 23), '\u971c\u964d'), (datetime\n            .date(2004, 11, 7), '\u7acb\u51ac'), (datetime.date(2004, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2004, 12, 7), '\u5927\u96ea'), (datetime.date(2004, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2005, 1, 1)\n        end = datetime.date(2005, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2005, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2005, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2005, 2, 4), '\u7acb\u6625'), (datetime.date(2005,\n            2, 18), '\u96e8\u6c34'), (datetime.date(2005, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2005, 3, 20), '\u6625\u5206'), (datetime.date(2005, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2005, 4, 20), '\u8c37\u96e8'), (datetime.date(2005, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2005, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2005, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2005, 6, 21), '\u590f\u81f3'), (datetime.date(2005, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2005, 7, 23), '\u5927\u6691'), (datetime.date(2005, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2005, 8, 23), '\u5904\u6691'), (datetime.date(2005,\n            9, 7), '\u767d\u9732'), (datetime.date(2005, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2005, 10, 8), '\u5bd2\u9732'), (datetime.date(2005, 10, 23), '\u971c\u964d'), (datetime\n            .date(2005, 11, 7), '\u7acb\u51ac'), (datetime.date(2005, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2005, 12, 7), '\u5927\u96ea'), (datetime.date(2005, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2006, 1, 1)\n        end = datetime.date(2006, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2006, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2006, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2006, 2, 4), '\u7acb\u6625'), (datetime.date(2006,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2006, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2006, 3, 21), '\u6625\u5206'), (datetime.date(2006, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2006, 4, 20), '\u8c37\u96e8'), (datetime.date(2006, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2006, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2006, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2006, 6, 21), '\u590f\u81f3'), (datetime.date(2006, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2006, 7, 23), '\u5927\u6691'), (datetime.date(2006, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2006, 8, 23), '\u5904\u6691'), (datetime.date(2006,\n            9, 8), '\u767d\u9732'), (datetime.date(2006, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2006, 10, 8), '\u5bd2\u9732'), (datetime.date(2006, 10, 23), '\u971c\u964d'), (datetime\n            .date(2006, 11, 7), '\u7acb\u51ac'), (datetime.date(2006, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2006, 12, 7), '\u5927\u96ea'), (datetime.date(2006, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2007, 1, 1)\n        end = datetime.date(2007, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2007, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2007, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2007, 2, 4), '\u7acb\u6625'), (datetime.date(2007,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2007, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2007, 3, 21), '\u6625\u5206'), (datetime.date(2007, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2007, 4, 20), '\u8c37\u96e8'), (datetime.date(2007, 5, 6), '\u7acb\u590f'), (\n            datetime.date(2007, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2007, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2007, 6, 22), '\u590f\u81f3'), (datetime.date(2007, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2007, 7, 23), '\u5927\u6691'), (datetime.date(2007, 8, \n            8), '\u7acb\u79cb'), (datetime.date(2007, 8, 23), '\u5904\u6691'), (datetime.date(2007,\n            9, 8), '\u767d\u9732'), (datetime.date(2007, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2007, 10, 9), '\u5bd2\u9732'), (datetime.date(2007, 10, 24), '\u971c\u964d'), (datetime\n            .date(2007, 11, 8), '\u7acb\u51ac'), (datetime.date(2007, 11, 23), '\u5c0f\u96ea'), (\n            datetime.date(2007, 12, 7), '\u5927\u96ea'), (datetime.date(2007, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2008, 1, 1)\n        end = datetime.date(2008, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2008, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2008, 1, \n            21), '\u5927\u5bd2'), (datetime.date(2008, 2, 4), '\u7acb\u6625'), (datetime.date(2008,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2008, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2008, 3, 20), '\u6625\u5206'), (datetime.date(2008, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2008, 4, 20), '\u8c37\u96e8'), (datetime.date(2008, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2008, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2008, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2008, 6, 21), '\u590f\u81f3'), (datetime.date(2008, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2008, 7, 22), '\u5927\u6691'), (datetime.date(2008, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2008, 8, 23), '\u5904\u6691'), (datetime.date(2008,\n            9, 7), '\u767d\u9732'), (datetime.date(2008, 9, 22), '\u79cb\u5206'), (datetime.date(\n            2008, 10, 8), '\u5bd2\u9732'), (datetime.date(2008, 10, 23), '\u971c\u964d'), (datetime\n            .date(2008, 11, 7), '\u7acb\u51ac'), (datetime.date(2008, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2008, 12, 7), '\u5927\u96ea'), (datetime.date(2008, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2009, 1, 1)\n        end = datetime.date(2009, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2009, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2009, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2009, 2, 4), '\u7acb\u6625'), (datetime.date(2009,\n            2, 18), '\u96e8\u6c34'), (datetime.date(2009, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2009, 3, 20), '\u6625\u5206'), (datetime.date(2009, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2009, 4, 20), '\u8c37\u96e8'), (datetime.date(2009, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2009, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2009, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2009, 6, 21), '\u590f\u81f3'), (datetime.date(2009, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2009, 7, 23), '\u5927\u6691'), (datetime.date(2009, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2009, 8, 23), '\u5904\u6691'), (datetime.date(2009,\n            9, 7), '\u767d\u9732'), (datetime.date(2009, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2009, 10, 8), '\u5bd2\u9732'), (datetime.date(2009, 10, 23), '\u971c\u964d'), (datetime\n            .date(2009, 11, 7), '\u7acb\u51ac'), (datetime.date(2009, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2009, 12, 7), '\u5927\u96ea'), (datetime.date(2009, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2010, 1, 1)\n        end = datetime.date(2010, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2010, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2010, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2010, 2, 4), '\u7acb\u6625'), (datetime.date(2010,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2010, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2010, 3, 21), '\u6625\u5206'), (datetime.date(2010, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2010, 4, 20), '\u8c37\u96e8'), (datetime.date(2010, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2010, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2010, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2010, 6, 21), '\u590f\u81f3'), (datetime.date(2010, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2010, 7, 23), '\u5927\u6691'), (datetime.date(2010, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2010, 8, 23), '\u5904\u6691'), (datetime.date(2010,\n            9, 8), '\u767d\u9732'), (datetime.date(2010, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2010, 10, 8), '\u5bd2\u9732'), (datetime.date(2010, 10, 23), '\u971c\u964d'), (datetime\n            .date(2010, 11, 7), '\u7acb\u51ac'), (datetime.date(2010, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2010, 12, 7), '\u5927\u96ea'), (datetime.date(2010, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2011, 1, 1)\n        end = datetime.date(2011, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2011, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2011, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2011, 2, 4), '\u7acb\u6625'), (datetime.date(2011,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2011, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2011, 3, 21), '\u6625\u5206'), (datetime.date(2011, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2011, 4, 20), '\u8c37\u96e8'), (datetime.date(2011, 5, 6), '\u7acb\u590f'), (\n            datetime.date(2011, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2011, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2011, 6, 22), '\u590f\u81f3'), (datetime.date(2011, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2011, 7, 23), '\u5927\u6691'), (datetime.date(2011, 8, \n            8), '\u7acb\u79cb'), (datetime.date(2011, 8, 23), '\u5904\u6691'), (datetime.date(2011,\n            9, 8), '\u767d\u9732'), (datetime.date(2011, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2011, 10, 8), '\u5bd2\u9732'), (datetime.date(2011, 10, 24), '\u971c\u964d'), (datetime\n            .date(2011, 11, 8), '\u7acb\u51ac'), (datetime.date(2011, 11, 23), '\u5c0f\u96ea'), (\n            datetime.date(2011, 12, 7), '\u5927\u96ea'), (datetime.date(2011, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2012, 1, 1)\n        end = datetime.date(2012, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2012, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2012, 1, \n            21), '\u5927\u5bd2'), (datetime.date(2012, 2, 4), '\u7acb\u6625'), (datetime.date(2012,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2012, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2012, 3, 20), '\u6625\u5206'), (datetime.date(2012, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2012, 4, 20), '\u8c37\u96e8'), (datetime.date(2012, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2012, 5, 20), '\u5c0f\u6ee1'), (datetime.date(2012, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2012, 6, 21), '\u590f\u81f3'), (datetime.date(2012, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2012, 7, 22), '\u5927\u6691'), (datetime.date(2012, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2012, 8, 23), '\u5904\u6691'), (datetime.date(2012,\n            9, 7), '\u767d\u9732'), (datetime.date(2012, 9, 22), '\u79cb\u5206'), (datetime.date(\n            2012, 10, 8), '\u5bd2\u9732'), (datetime.date(2012, 10, 23), '\u971c\u964d'), (datetime\n            .date(2012, 11, 7), '\u7acb\u51ac'), (datetime.date(2012, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2012, 12, 7), '\u5927\u96ea'), (datetime.date(2012, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2013, 1, 1)\n        end = datetime.date(2013, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2013, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2013, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2013, 2, 4), '\u7acb\u6625'), (datetime.date(2013,\n            2, 18), '\u96e8\u6c34'), (datetime.date(2013, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2013, 3, 20), '\u6625\u5206'), (datetime.date(2013, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2013, 4, 20), '\u8c37\u96e8'), (datetime.date(2013, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2013, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2013, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2013, 6, 21), '\u590f\u81f3'), (datetime.date(2013, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2013, 7, 22), '\u5927\u6691'), (datetime.date(2013, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2013, 8, 23), '\u5904\u6691'), (datetime.date(2013,\n            9, 7), '\u767d\u9732'), (datetime.date(2013, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2013, 10, 8), '\u5bd2\u9732'), (datetime.date(2013, 10, 23), '\u971c\u964d'), (datetime\n            .date(2013, 11, 7), '\u7acb\u51ac'), (datetime.date(2013, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2013, 12, 7), '\u5927\u96ea'), (datetime.date(2013, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2014, 1, 1)\n        end = datetime.date(2014, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2014, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2014, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2014, 2, 4), '\u7acb\u6625'), (datetime.date(2014,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2014, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2014, 3, 21), '\u6625\u5206'), (datetime.date(2014, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2014, 4, 20), '\u8c37\u96e8'), (datetime.date(2014, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2014, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2014, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2014, 6, 21), '\u590f\u81f3'), (datetime.date(2014, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2014, 7, 23), '\u5927\u6691'), (datetime.date(2014, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2014, 8, 23), '\u5904\u6691'), (datetime.date(2014,\n            9, 8), '\u767d\u9732'), (datetime.date(2014, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2014, 10, 8), '\u5bd2\u9732'), (datetime.date(2014, 10, 23), '\u971c\u964d'), (datetime\n            .date(2014, 11, 7), '\u7acb\u51ac'), (datetime.date(2014, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2014, 12, 7), '\u5927\u96ea'), (datetime.date(2014, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2015, 1, 1)\n        end = datetime.date(2015, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2015, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2015, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2015, 2, 4), '\u7acb\u6625'), (datetime.date(2015,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2015, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2015, 3, 21), '\u6625\u5206'), (datetime.date(2015, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2015, 4, 20), '\u8c37\u96e8'), (datetime.date(2015, 5, 6), '\u7acb\u590f'), (\n            datetime.date(2015, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2015, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2015, 6, 22), '\u590f\u81f3'), (datetime.date(2015, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2015, 7, 23), '\u5927\u6691'), (datetime.date(2015, 8, \n            8), '\u7acb\u79cb'), (datetime.date(2015, 8, 23), '\u5904\u6691'), (datetime.date(2015,\n            9, 8), '\u767d\u9732'), (datetime.date(2015, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2015, 10, 8), '\u5bd2\u9732'), (datetime.date(2015, 10, 24), '\u971c\u964d'), (datetime\n            .date(2015, 11, 8), '\u7acb\u51ac'), (datetime.date(2015, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2015, 12, 7), '\u5927\u96ea'), (datetime.date(2015, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2016, 1, 1)\n        end = datetime.date(2016, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2016, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2016, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2016, 2, 4), '\u7acb\u6625'), (datetime.date(2016,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2016, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2016, 3, 20), '\u6625\u5206'), (datetime.date(2016, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2016, 4, 19), '\u8c37\u96e8'), (datetime.date(2016, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2016, 5, 20), '\u5c0f\u6ee1'), (datetime.date(2016, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2016, 6, 21), '\u590f\u81f3'), (datetime.date(2016, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2016, 7, 22), '\u5927\u6691'), (datetime.date(2016, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2016, 8, 23), '\u5904\u6691'), (datetime.date(2016,\n            9, 7), '\u767d\u9732'), (datetime.date(2016, 9, 22), '\u79cb\u5206'), (datetime.date(\n            2016, 10, 8), '\u5bd2\u9732'), (datetime.date(2016, 10, 23), '\u971c\u964d'), (datetime\n            .date(2016, 11, 7), '\u7acb\u51ac'), (datetime.date(2016, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2016, 12, 7), '\u5927\u96ea'), (datetime.date(2016, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2017, 1, 1)\n        end = datetime.date(2017, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2017, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2017, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2017, 2, 3), '\u7acb\u6625'), (datetime.date(2017,\n            2, 18), '\u96e8\u6c34'), (datetime.date(2017, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2017, 3, 20), '\u6625\u5206'), (datetime.date(2017, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2017, 4, 20), '\u8c37\u96e8'), (datetime.date(2017, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2017, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2017, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2017, 6, 21), '\u590f\u81f3'), (datetime.date(2017, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2017, 7, 22), '\u5927\u6691'), (datetime.date(2017, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2017, 8, 23), '\u5904\u6691'), (datetime.date(2017,\n            9, 7), '\u767d\u9732'), (datetime.date(2017, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2017, 10, 8), '\u5bd2\u9732'), (datetime.date(2017, 10, 23), '\u971c\u964d'), (datetime\n            .date(2017, 11, 7), '\u7acb\u51ac'), (datetime.date(2017, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2017, 12, 7), '\u5927\u96ea'), (datetime.date(2017, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2018, 1, 1)\n        end = datetime.date(2018, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2018, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2018, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2018, 2, 4), '\u7acb\u6625'), (datetime.date(2018,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2018, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2018, 3, 21), '\u6625\u5206'), (datetime.date(2018, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2018, 4, 20), '\u8c37\u96e8'), (datetime.date(2018, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2018, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2018, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2018, 6, 21), '\u590f\u81f3'), (datetime.date(2018, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2018, 7, 23), '\u5927\u6691'), (datetime.date(2018, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2018, 8, 23), '\u5904\u6691'), (datetime.date(2018,\n            9, 8), '\u767d\u9732'), (datetime.date(2018, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2018, 10, 8), '\u5bd2\u9732'), (datetime.date(2018, 10, 23), '\u971c\u964d'), (datetime\n            .date(2018, 11, 7), '\u7acb\u51ac'), (datetime.date(2018, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2018, 12, 7), '\u5927\u96ea'), (datetime.date(2018, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2019, 1, 1)\n        end = datetime.date(2019, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2019, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2019, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2019, 2, 4), '\u7acb\u6625'), (datetime.date(2019,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2019, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2019, 3, 21), '\u6625\u5206'), (datetime.date(2019, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2019, 4, 20), '\u8c37\u96e8'), (datetime.date(2019, 5, 6), '\u7acb\u590f'), (\n            datetime.date(2019, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2019, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2019, 6, 21), '\u590f\u81f3'), (datetime.date(2019, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2019, 7, 23), '\u5927\u6691'), (datetime.date(2019, 8, \n            8), '\u7acb\u79cb'), (datetime.date(2019, 8, 23), '\u5904\u6691'), (datetime.date(2019,\n            9, 8), '\u767d\u9732'), (datetime.date(2019, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2019, 10, 8), '\u5bd2\u9732'), (datetime.date(2019, 10, 24), '\u971c\u964d'), (datetime\n            .date(2019, 11, 8), '\u7acb\u51ac'), (datetime.date(2019, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2019, 12, 7), '\u5927\u96ea'), (datetime.date(2019, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2020, 1, 1)\n        end = datetime.date(2020, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2020, 1, 6), '\u5c0f\u5bd2'), (datetime.date(2020, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2020, 2, 4), '\u7acb\u6625'), (datetime.date(2020,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2020, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2020, 3, 20), '\u6625\u5206'), (datetime.date(2020, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2020, 4, 19), '\u8c37\u96e8'), (datetime.date(2020, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2020, 5, 20), '\u5c0f\u6ee1'), (datetime.date(2020, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2020, 6, 21), '\u590f\u81f3'), (datetime.date(2020, 7, 6),\n            '\u5c0f\u6691'), (datetime.date(2020, 7, 22), '\u5927\u6691'), (datetime.date(2020, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2020, 8, 22), '\u5904\u6691'), (datetime.date(2020,\n            9, 7), '\u767d\u9732'), (datetime.date(2020, 9, 22), '\u79cb\u5206'), (datetime.date(\n            2020, 10, 8), '\u5bd2\u9732'), (datetime.date(2020, 10, 23), '\u971c\u964d'), (datetime\n            .date(2020, 11, 7), '\u7acb\u51ac'), (datetime.date(2020, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2020, 12, 7), '\u5927\u96ea'), (datetime.date(2020, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2021, 1, 1)\n        end = datetime.date(2021, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2021, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2021, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2021, 2, 3), '\u7acb\u6625'), (datetime.date(2021,\n            2, 18), '\u96e8\u6c34'), (datetime.date(2021, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2021, 3, 20), '\u6625\u5206'), (datetime.date(2021, 4, 4), '\u6e05\u660e'), (datetime.\n            date(2021, 4, 20), '\u8c37\u96e8'), (datetime.date(2021, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2021, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2021, 6, 5), '\u8292\u79cd'\n            ), (datetime.date(2021, 6, 21), '\u590f\u81f3'), (datetime.date(2021, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2021, 7, 22), '\u5927\u6691'), (datetime.date(2021, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2021, 8, 23), '\u5904\u6691'), (datetime.date(2021,\n            9, 7), '\u767d\u9732'), (datetime.date(2021, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2021, 10, 8), '\u5bd2\u9732'), (datetime.date(2021, 10, 23), '\u971c\u964d'), (datetime\n            .date(2021, 11, 7), '\u7acb\u51ac'), (datetime.date(2021, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2021, 12, 7), '\u5927\u96ea'), (datetime.date(2021, 12, 21), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2022, 1, 1)\n        end = datetime.date(2022, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2022, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2022, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2022, 2, 4), '\u7acb\u6625'), (datetime.date(2022,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2022, 3, 5), '\u60ca\u86f0'), (datetime.date(\n            2022, 3, 20), '\u6625\u5206'), (datetime.date(2022, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2022, 4, 20), '\u8c37\u96e8'), (datetime.date(2022, 5, 5), '\u7acb\u590f'), (\n            datetime.date(2022, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2022, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2022, 6, 21), '\u590f\u81f3'), (datetime.date(2022, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2022, 7, 23), '\u5927\u6691'), (datetime.date(2022, 8, \n            7), '\u7acb\u79cb'), (datetime.date(2022, 8, 23), '\u5904\u6691'), (datetime.date(2022,\n            9, 7), '\u767d\u9732'), (datetime.date(2022, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2022, 10, 8), '\u5bd2\u9732'), (datetime.date(2022, 10, 23), '\u971c\u964d'), (datetime\n            .date(2022, 11, 7), '\u7acb\u51ac'), (datetime.date(2022, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2022, 12, 7), '\u5927\u96ea'), (datetime.date(2022, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2023, 1, 1)\n        end = datetime.date(2023, 12, 31)\n        actual = get_solar_terms(start, end)\n        expected = [(datetime.date(2023, 1, 5), '\u5c0f\u5bd2'), (datetime.date(2023, 1, \n            20), '\u5927\u5bd2'), (datetime.date(2023, 2, 4), '\u7acb\u6625'), (datetime.date(2023,\n            2, 19), '\u96e8\u6c34'), (datetime.date(2023, 3, 6), '\u60ca\u86f0'), (datetime.date(\n            2023, 3, 21), '\u6625\u5206'), (datetime.date(2023, 4, 5), '\u6e05\u660e'), (datetime.\n            date(2023, 4, 20), '\u8c37\u96e8'), (datetime.date(2023, 5, 6), '\u7acb\u590f'), (\n            datetime.date(2023, 5, 21), '\u5c0f\u6ee1'), (datetime.date(2023, 6, 6), '\u8292\u79cd'\n            ), (datetime.date(2023, 6, 21), '\u590f\u81f3'), (datetime.date(2023, 7, 7),\n            '\u5c0f\u6691'), (datetime.date(2023, 7, 23), '\u5927\u6691'), (datetime.date(2023, 8, \n            8), '\u7acb\u79cb'), (datetime.date(2023, 8, 23), '\u5904\u6691'), (datetime.date(2023,\n            9, 8), '\u767d\u9732'), (datetime.date(2023, 9, 23), '\u79cb\u5206'), (datetime.date(\n            2023, 10, 8), '\u5bd2\u9732'), (datetime.date(2023, 10, 24), '\u971c\u964d'), (datetime\n            .date(2023, 11, 8), '\u7acb\u51ac'), (datetime.date(2023, 11, 22), '\u5c0f\u96ea'), (\n            datetime.date(2023, 12, 7), '\u5927\u96ea'), (datetime.date(2023, 12, 22), '\u51ac\u81f3')]\n        self.assertEqual(expected, actual)\n        start = datetime.date(2023, 1, 6)\n        end = datetime.date(2023, 1, 19)\n        actual = get_solar_terms(start, end)\n        expected = []\n        self.assertEqual(expected, actual)\n    \nSolarTermTests().test_get_solar_terms()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Time/chinese-calendar/tests/test_solar_terms.py"}], "method_code_mask": "from __future__ import absolute_import\nfrom __future__ import unicode_literals\nimport datetime\nfrom chinese_calendar.constants import holidays\nfrom chinese_calendar.constants import in_lieu_days\nfrom chinese_calendar.constants import workdays\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_C_NUMS\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_DELTA\nfrom chinese_calendar.solar_terms import SOLAR_TERMS_MONTH\nfrom chinese_calendar.solar_terms import SolarTerms\n\n\ndef get_solar_terms(start, end): [MASK]\n"}
