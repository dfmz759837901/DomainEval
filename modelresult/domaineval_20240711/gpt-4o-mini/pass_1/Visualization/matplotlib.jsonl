{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "_azimuth2math", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py", "response": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _azimuth2math(azimuth, elevation):\n    # Convert azimuth from degrees to radians and adjust for mathematical convention\n    theta = np.radians(azimuth - 90)  # Convert azimuth to radians and shift by 90 degrees\n    # Convert elevation from degrees to radians\n    phi = np.radians(elevation)  # Convert elevation to radians\n    return theta, phi", "test_code_list": [{"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z\ndef test_light_source_hillshading():\n    \"\"\"\n    Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\n    \"\"\"\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= np.ptp(intensity)\n        return intensity\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)\ntest_light_source_hillshading()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}, {"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _sph2cart(theta, phi):\n    x = np.cos(theta) * np.sin(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(phi)\n    return x, y, z\ndef test_light_source_planar_hillshading():\n    \"\"\"\n    Ensure that the illumination intensity is correct for planar surfaces.\n    \"\"\"\n    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a * x + b * y) / c\n        return z\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))\ntest_light_source_planar_hillshading()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}], "method_code_mask": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _azimuth2math(azimuth, elevation): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "_sph2cart", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py", "response": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _sph2cart(theta, phi):\n    x = np.sin(phi) * np.cos(theta)\n    y = np.sin(phi) * np.sin(theta)\n    z = np.cos(phi)\n    return x, y, z", "test_code_list": [{"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi\ndef test_light_source_hillshading():\n    \"\"\"\n    Compare the current hillshading method against one that should be\n    mathematically equivalent. Illuminates a cone from a range of angles.\n    \"\"\"\n    def alternative_hillshade(azimuth, elev, z):\n        illum = _sph2cart(*_azimuth2math(azimuth, elev))\n        illum = np.array(illum)\n        dy, dx = np.gradient(-z)\n        dy = -dy\n        dz = np.ones_like(dy)\n        normals = np.dstack([dx, dy, dz])\n        normals /= np.linalg.norm(normals, axis=2)[..., None]\n        intensity = np.tensordot(normals, illum, axes=(2, 0))\n        intensity -= intensity.min()\n        intensity /= np.ptp(intensity)\n        return intensity\n    y, x = np.mgrid[5:0:-1, :5]\n    z = -np.hypot(x - x.mean(), y - y.mean())\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        h1 = ls.hillshade(z)\n        h2 = alternative_hillshade(az, elev, z)\n        assert_array_almost_equal(h1, h2)\ntest_light_source_hillshading()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}, {"test_code": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\ndef _azimuth2math(azimuth, elevation):\n    \"\"\"\n    Convert from clockwise-from-north and up-from-horizontal to mathematical\n    conventions.\n    \"\"\"\n    theta = np.radians((90 - azimuth) % 360)\n    phi = np.radians(90 - elevation)\n    return theta, phi\ndef test_light_source_planar_hillshading():\n    \"\"\"\n    Ensure that the illumination intensity is correct for planar surfaces.\n    \"\"\"\n    def plane(azimuth, elevation, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at the given azimuth and\n        elevation.\n        \"\"\"\n        theta, phi = _azimuth2math(azimuth, elevation)\n        a, b, c = _sph2cart(theta, phi)\n        z = -(a * x + b * y) / c\n        return z\n    def angled_plane(azimuth, elevation, angle, x, y):\n        \"\"\"\n        Create a plane whose normal vector is at an angle from the given\n        azimuth and elevation.\n        \"\"\"\n        elevation = elevation + angle\n        if elevation > 90:\n            azimuth = (azimuth + 180) % 360\n            elevation = (90 - elevation) % 90\n        return plane(azimuth, elevation, x, y)\n    y, x = np.mgrid[5:0:-1, :5]\n    for az, elev in itertools.product(range(0, 390, 30), range(0, 105, 15)):\n        ls = mcolors.LightSource(az, elev)\n        for angle in range(0, 105, 15):\n            z = angled_plane(az, elev, angle, x, y)\n            h = ls.hillshade(z)\n            assert_array_almost_equal(h, np.cos(np.radians(angle)))\ntest_light_source_planar_hillshading()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_colors.py"}], "method_code_mask": "import copy\nimport itertools\nimport unittest.mock\nfrom io import BytesIO\nimport numpy as np\nfrom PIL import Image\nimport pytest\nimport base64\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom matplotlib import cbook\nfrom matplotlib import cm\nimport matplotlib\nimport matplotlib as mpl\nimport matplotlib.colors as mcolors\nimport matplotlib.colorbar as mcolorbar\nimport matplotlib.pyplot as plt\nimport matplotlib.scale as mscale\nfrom matplotlib.rcsetup import cycler\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib.colors import is_color_like\nfrom matplotlib.colors import to_rgba_array\n\n\ndef _sph2cart(theta, phi): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "temp_style", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py", "response": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\nVALUE = 'pink'\nPARAM = 'image.cmap'\nDUMMY_SETTINGS = {PARAM: VALUE}\n\n\n@contextmanager\ndef temp_style(style_name, settings=None):\n    if settings is None:\n        settings = DUMMY_SETTINGS\n\n    with TemporaryDirectory() as temp_dir:\n        style_file = Path(temp_dir) / f\"{style_name}{STYLE_EXTENSION}\"\n        with open(style_file, 'w') as f:\n            for key, value in settings.items():\n                f.write(f\"{key}: {value}\\n\")\n\n        # Add the temporary style directory to the user style paths\n        USER_LIBRARY_PATHS.append(str(temp_dir))\n        style.use(style_name)\n\n        try:\n            yield\n        finally:\n            # Remove the temporary style directory from user style paths\n            USER_LIBRARY_PATHS.remove(str(temp_dir))\n            mpl.rcdefaults()  # Reset to default settings", "test_code_list": [{"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_available():\n    with temp_style('_test_', DUMMY_SETTINGS):\n        assert '_test_' in style.available\n\ntest_available()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_use():\n    mpl.rcParams[PARAM] = 'gray'\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context('test'):\n            assert mpl.rcParams[PARAM] == VALUE\n\ntest_use()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context():\n    mpl.rcParams[PARAM] = 'gray'\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context('test'):\n            assert mpl.rcParams[PARAM] == VALUE\n    assert mpl.rcParams[PARAM] == 'gray'\n\ntest_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_dict_after_namedstyle():\n    original_value = 'gray'\n    other_value = 'blue'\n    mpl.rcParams[PARAM] = original_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context(['test', {PARAM: other_value}]):\n            assert mpl.rcParams[PARAM] == other_value\n    assert mpl.rcParams[PARAM] == original_value\n\ntest_context_with_dict_after_namedstyle()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_dict_before_namedstyle():\n    original_value = 'gray'\n    other_value = 'blue'\n    mpl.rcParams[PARAM] = original_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context([{PARAM: other_value}, 'test']):\n            assert mpl.rcParams[PARAM] == VALUE\n    assert mpl.rcParams[PARAM] == original_value\n\ntest_context_with_dict_before_namedstyle()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}, {"test_code": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\ndef test_context_with_union_of_dict_and_namedstyle():\n    original_value = 'gray'\n    other_param = 'text.usetex'\n    other_value = True\n    d = {other_param: other_value}\n    mpl.rcParams[PARAM] = original_value\n    mpl.rcParams[other_param] = not other_value\n    with temp_style('test', DUMMY_SETTINGS):\n        with style.context(['test', d]):\n            assert mpl.rcParams[PARAM] == VALUE\n            assert mpl.rcParams[other_param] == other_value\n    assert mpl.rcParams[PARAM] == original_value\n    assert mpl.rcParams[other_param] == (not other_value)\n\ntest_context_with_union_of_dict_and_namedstyle()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_style.py"}], "method_code_mask": "from contextlib import contextmanager\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport sys\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nfrom matplotlib.style.core import USER_LIBRARY_PATHS\nfrom matplotlib.style.core import STYLE_EXTENSION\nVALUE = 'pink'\nPARAM = 'image.cmap'\nDUMMY_SETTINGS = {PARAM: VALUE}\n\n\n@contextmanager\ndef temp_style(style_name, settings=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "draw_quiver", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py", "response": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n\n\ndef draw_quiver(ax, **kwargs):\n    # Create a grid of points\n    x = np.linspace(0, 2 * np.pi, 20)\n    y = np.linspace(0, 2 * np.pi, 20)\n    X, Y = np.meshgrid(x, y)\n\n    # Compute U and V components of the vectors\n    U = np.cos(X)\n    V = np.sin(Y)\n\n    # Draw the quiver plot on the provided axis\n    Q = ax.quiver(X, Y, U, V, **kwargs)\n\n    return Q", "test_code_list": [{"test_code": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n@pytest.mark.skipif(platform.python_implementation() != 'CPython', reason=\n    'Requires CPython')\ndef test_quiver_memory_leak():\n    fig, ax = plt.subplots()\n    Q = draw_quiver(ax)\n    ttX = Q.X\n    Q.remove()\n    del Q\n    assert sys.getrefcount(ttX) == 2\n\ntest_quiver_memory_leak()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py"}, {"test_code": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n@pytest.mark.skipif(platform.python_implementation() != 'CPython', reason=\n    'Requires CPython')\ndef test_quiver_key_memory_leak():\n    fig, ax = plt.subplots()\n    Q = draw_quiver(ax)\n    qk = ax.quiverkey(Q, 0.5, 0.92, 2, '$2 \\\\frac{m}{s}$', labelpos='W',\n        fontproperties={'weight': 'bold'})\n    assert sys.getrefcount(qk) == 3\n    qk.remove()\n    assert sys.getrefcount(qk) == 2\n\ntest_quiver_key_memory_leak()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_quiver.py"}], "method_code_mask": "import platform\nimport sys\nimport numpy as np\nimport pytest\nfrom matplotlib import pyplot as plt\nfrom matplotlib.testing.decorators import image_comparison\n\n\ndef draw_quiver(ax, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "meshgrid_triangles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py", "response": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\n\n\ndef meshgrid_triangles(n):\n    # Create a grid of points\n    x = np.linspace(0, 1, n)\n    y = np.linspace(0, 1, n)\n    X, Y = np.meshgrid(x, y)\n    \n    # Flatten the grid points\n    points = np.vstack([X.ravel(), Y.ravel()]).T\n    \n    # Create triangles\n    triangles = []\n    for i in range(n - 1):\n        for j in range(n - 1):\n            # Define the indices of the triangle vertices\n            v1 = i * n + j\n            v2 = v1 + 1\n            v3 = v1 + n\n            \n            # Add two triangles for each square\n            triangles.append([v1, v2, v3])      # Triangle 1\n            triangles.append([v2, v3, v3 + 1])  # Triangle 2\n    \n    # Convert to a NumPy array and ensure the correct dtype\n    return np.array(triangles, dtype=np.int32)", "test_code_list": [{"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_triinterp():\n    x, y = np.meshgrid(np.arange(4), np.arange(4))\n    x = x.ravel()\n    y = y.ravel()\n    z = 1.23 * x - 4.79 * y\n    triangles = [[0, 1, 4], [1, 5, 4], [1, 2, 5], [2, 6, 5], [2, 3, 6], [3,\n        7, 6], [4, 5, 8], [5, 9, 8], [5, 6, 9], [6, 10, 9], [6, 7, 10], [7,\n        11, 10], [8, 9, 12], [9, 13, 12], [9, 10, 13], [10, 14, 13], [10, \n        11, 14], [11, 15, 14]]\n    mask = np.zeros(len(triangles))\n    mask[8:10] = 1\n    triang = mtri.Triangulation(x, y, triangles, mask)\n    linear_interp = mtri.LinearTriInterpolator(triang, z)\n    cubic_min_E = mtri.CubicTriInterpolator(triang, z)\n    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\n    xs = np.linspace(0.25, 2.75, 6)\n    ys = [0.25, 0.75, 2.25, 2.75]\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = interp(xs, ys)\n        assert_array_almost_equal(zs, 1.23 * xs - 4.79 * ys)\n    xs = [-0.25, 1.25, 1.75, 3.25]\n    ys = xs\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = linear_interp(xs, ys)\n        assert_array_equal(zs.mask, [[True] * 4] * 4)\n    xs = np.linspace(0.25, 1.75, 6)\n    ys = [0.25, 0.75, 1.25, 1.75]\n    xs, ys = np.meshgrid(xs, ys)\n    for interp in (linear_interp, cubic_min_E, cubic_geom):\n        zs = interp(xs, ys)\n        matest.assert_array_almost_equal(zs, 1.23 * xs - 4.79 * ys)\n        mask = (xs >= 1) * (xs <= 2) * (ys >= 1) * (ys <= 2)\n        assert_array_equal(zs.mask, mask)\n    a, b, c = 1.23, -4.79, 0.6\n\n    def quad(x, y):\n        return a * (x - 0.5) ** 2 + b * (y - 0.5) ** 2 + c * x * y\n\n    def gradient_quad(x, y):\n        return 2 * a * (x - 0.5) + c * y, 2 * b * (y - 0.5) + c * x\n    x = np.array([0.2, 0.33367, 0.669, 0.0, 1.0, 1.0, 0.0])\n    y = np.array([0.3, 0.80755, 0.4335, 0.0, 0.0, 1.0, 1.0])\n    triangles = np.array([[0, 1, 2], [3, 0, 4], [4, 0, 2], [4, 2, 5], [1, 5,\n        2], [6, 5, 1], [6, 1, 0], [6, 0, 3]])\n    triang = mtri.Triangulation(x, y, triangles)\n    z = quad(x, y)\n    dz = gradient_quad(x, y)\n    xs = np.linspace(0.0, 1.0, 5)\n    ys = np.linspace(0.0, 1.0, 5)\n    xs, ys = np.meshgrid(xs, ys)\n    cubic_user = mtri.CubicTriInterpolator(triang, z, kind='user', dz=dz)\n    interp_zs = cubic_user(xs, ys)\n    assert_array_almost_equal(interp_zs, quad(xs, ys))\n    interp_dzsdx, interp_dzsdy = cubic_user.gradient(x, y)\n    dzsdx, dzsdy = gradient_quad(x, y)\n    assert_array_almost_equal(interp_dzsdx, dzsdx)\n    assert_array_almost_equal(interp_dzsdy, dzsdy)\n    n = 11\n    x, y = np.meshgrid(np.linspace(0.0, 1.0, n + 1), np.linspace(0.0, 1.0, \n        n + 1))\n    x = x.ravel()\n    y = y.ravel()\n    z = quad(x, y)\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1))\n    xs, ys = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    xs = xs.ravel()\n    ys = ys.ravel()\n    linear_interp = mtri.LinearTriInterpolator(triang, z)\n    cubic_min_E = mtri.CubicTriInterpolator(triang, z)\n    cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')\n    zs = quad(xs, ys)\n    diff_lin = np.abs(linear_interp(xs, ys) - zs)\n    for interp in (cubic_min_E, cubic_geom):\n        diff_cubic = np.abs(interp(xs, ys) - zs)\n        assert np.max(diff_lin) >= 10 * np.max(diff_cubic)\n        assert np.dot(diff_lin, diff_lin) >= 100 * np.dot(diff_cubic,\n            diff_cubic)\n\ntest_triinterp()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}, {"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_tritools():\n    x = np.array([0.0, 1.0, 0.5, 0.0, 2.0])\n    y = np.array([0.0, 0.0, 0.5 * np.sqrt(3.0), -1.0, 1.0])\n    triangles = np.array([[0, 1, 2], [0, 1, 3], [1, 2, 4]], dtype=np.int32)\n    mask = np.array([False, False, True], dtype=bool)\n    triang = mtri.Triangulation(x, y, triangles, mask=mask)\n    analyser = mtri.TriAnalyzer(triang)\n    assert_array_almost_equal(analyser.scale_factors, [1, 1 / (1 + 3 ** 0.5 /\n        2)])\n    assert_array_almost_equal(analyser.circle_ratios(rescale=False), np.ma.\n        masked_array([0.5, 1.0 / (1.0 + np.sqrt(2.0)), np.nan], mask))\n    x = np.array([0.0, 1.0, 2.0])\n    y = np.array([1.0, 1.0 + 3.0, 1.0 + 6.0])\n    triangles = np.array([[0, 1, 2]], dtype=np.int32)\n    triang = mtri.Triangulation(x, y, triangles)\n    analyser = mtri.TriAnalyzer(triang)\n    assert_array_almost_equal(analyser.circle_ratios(), np.array([0.0]))\n    n = 9\n\n    def power(x, a):\n        return np.abs(x) ** a * np.sign(x)\n    x = np.linspace(-1.0, 1.0, n + 1)\n    x, y = np.meshgrid(power(x, 2.0), power(x, 0.25))\n    x = x.ravel()\n    y = y.ravel()\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1))\n    analyser = mtri.TriAnalyzer(triang)\n    mask_flat = analyser.get_flat_tri_mask(0.2)\n    verif_mask = np.zeros(162, dtype=bool)\n    corners_index = [0, 1, 2, 3, 14, 15, 16, 17, 18, 19, 34, 35, 126, 127, \n        142, 143, 144, 145, 146, 147, 158, 159, 160, 161]\n    verif_mask[corners_index] = True\n    assert_array_equal(mask_flat, verif_mask)\n    mask = np.zeros(162, dtype=bool)\n    mask[80] = True\n    triang.set_mask(mask)\n    mask_flat = analyser.get_flat_tri_mask(0.2)\n    center_index = [44, 45, 62, 63, 78, 79, 80, 81, 82, 83, 98, 99, 116, 117]\n    verif_mask[center_index] = True\n    assert_array_equal(mask_flat, verif_mask)\n\ntest_tritools()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}, {"test_code": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\ndef test_trirefine():\n    n = 3\n    subdiv = 2\n    x = np.linspace(-1.0, 1.0, n + 1)\n    x, y = np.meshgrid(x, x)\n    x = x.ravel()\n    y = y.ravel()\n    mask = np.zeros(2 * n ** 2, dtype=bool)\n    mask[n ** 2:] = True\n    triang = mtri.Triangulation(x, y, triangles=meshgrid_triangles(n + 1),\n        mask=mask)\n    refiner = mtri.UniformTriRefiner(triang)\n    refi_triang = refiner.refine_triangulation(subdiv=subdiv)\n    x_refi = refi_triang.x\n    y_refi = refi_triang.y\n    n_refi = n * subdiv ** 2\n    x_verif = np.linspace(-1.0, 1.0, n_refi + 1)\n    x_verif, y_verif = np.meshgrid(x_verif, x_verif)\n    x_verif = x_verif.ravel()\n    y_verif = y_verif.ravel()\n    ind1d = np.isin(np.around(x_verif * (2.5 + y_verif), 8), np.around(\n        x_refi * (2.5 + y_refi), 8))\n    assert_array_equal(ind1d, True)\n    refi_mask = refi_triang.mask\n    refi_tri_barycenter_x = np.sum(refi_triang.x[refi_triang.triangles], axis=1\n        ) / 3.0\n    refi_tri_barycenter_y = np.sum(refi_triang.y[refi_triang.triangles], axis=1\n        ) / 3.0\n    tri_finder = triang.get_trifinder()\n    refi_tri_indices = tri_finder(refi_tri_barycenter_x, refi_tri_barycenter_y)\n    refi_tri_mask = triang.mask[refi_tri_indices]\n    assert_array_equal(refi_mask, refi_tri_mask)\n    x = np.asarray([0.0, 1.0, 0.0, 1.0])\n    y = np.asarray([0.0, 0.0, 1.0, 1.0])\n    triang = [mtri.Triangulation(x, y, [[0, 1, 3], [3, 2, 0]]), mtri.\n        Triangulation(x, y, [[0, 1, 3], [2, 0, 3]])]\n    z = np.hypot(x - 0.3, y - 0.4)\n    xyz_data = []\n    for i in range(2):\n        refiner = mtri.UniformTriRefiner(triang[i])\n        refined_triang, refined_z = refiner.refine_field(z, subdiv=1)\n        xyz = np.dstack((refined_triang.x, refined_triang.y, refined_z))[0]\n        xyz = xyz[np.lexsort((xyz[:, 1], xyz[:, 0]))]\n        xyz_data += [xyz]\n    assert_array_almost_equal(xyz_data[0], xyz_data[1])\n\ntest_trirefine()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_triangulation.py"}], "method_code_mask": "import numpy as np\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy.testing import assert_array_less\nimport numpy.ma.testutils as matest\nimport pytest\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.tri as mtri\nfrom matplotlib.path import Path\nfrom matplotlib.testing.decorators import image_comparison\nfrom matplotlib.testing.decorators import check_figures_equal\nfrom matplotlib import _tri\n\n\ndef meshgrid_triangles(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "example_plot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py", "response": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_plot(ax, fontsize=12, nodec=False):\n    # Plot a line with two points\n    ax.plot([1, 2], [1, 2], marker='o')\n    \n    # Set the number of bins for the tick locator\n    ax.xaxis.set_major_locator(ticker.MaxNLocator(nbins=3))\n    ax.yaxis.set_major_locator(ticker.MaxNLocator(nbins=3))\n    \n    if not nodec:\n        # Set x-label, y-label, and title with specified fontsize\n        ax.set_xlabel('X-axis', fontsize=fontsize)\n        ax.set_ylabel('Y-axis', fontsize=fontsize)\n        ax.set_title('Example Plot', fontsize=fontsize)\n    else:\n        # Clear the tick labels if nodec is True\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])", "test_code_list": [{"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_constrained_layout18():\n    \"\"\"Test twinx\"\"\"\n    fig, ax = plt.subplots(layout='constrained')\n    ax2 = ax.twinx()\n    example_plot(ax)\n    example_plot(ax2, fontsize=24)\n    fig.draw_without_rendering()\n    assert all(ax.get_position().extents == ax2.get_position().extents)\n\ntest_constrained_layout18()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}, {"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_constrained_layout19():\n    \"\"\"Test twiny\"\"\"\n    fig, ax = plt.subplots(layout='constrained')\n    ax2 = ax.twiny()\n    example_plot(ax)\n    example_plot(ax2, fontsize=24)\n    ax2.set_title('')\n    ax.set_title('')\n    fig.draw_without_rendering()\n    assert all(ax.get_position().extents == ax2.get_position().extents)\n\ntest_constrained_layout19()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}], "method_code_mask": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_plot(ax, fontsize=12, nodec=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "matplotlib", "full_method_name": "example_pcolor", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py", "response": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_pcolor(ax, fontsize=12):\n    # Create a grid of data points\n    x = np.linspace(-3, 3, 100)\n    y = np.linspace(-3, 3, 100)\n    X, Y = np.meshgrid(x, y)\n    \n    # Compute a function over the grid (e.g., a Gaussian function)\n    Z = np.exp(-2 * (X**2 + Y**2))\n    \n    # Define the colormap and bounds\n    cmap = plt.get_cmap('viridis')\n    bounds = np.linspace(0, 1, 11)\n    \n    # Create the pseudocolor plot\n    pcm = ax.pcolormesh(X, Y, Z, cmap=cmap, shading='auto', vmin=bounds[0], vmax=bounds[-1])\n    \n    # Set labels and title\n    ax.set_xlabel('X-axis', fontsize=fontsize)\n    ax.set_ylabel('Y-axis', fontsize=fontsize)\n    ax.set_title('Pseudocolor Plot', fontsize=fontsize)\n    \n    # Add a colorbar\n    cbar = plt.colorbar(pcm, ax=ax)\n    cbar.ax.tick_params(labelsize=fontsize)\n    \n    return pcm", "test_code_list": [{"test_code": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\ndef test_colorbar_align():\n    for location in ['right', 'left', 'top', 'bottom']:\n        fig, axs = plt.subplots(2, 2, layout='constrained')\n        cbs = []\n        for nn, ax in enumerate(axs.flat):\n            ax.tick_params(direction='in')\n            pc = example_pcolor(ax)\n            cb = fig.colorbar(pc, ax=ax, location=location, shrink=0.6, pad\n                =0.04)\n            cbs += [cb]\n            cb.ax.tick_params(direction='in')\n            if nn != 1:\n                cb.ax.xaxis.set_ticks([])\n                cb.ax.yaxis.set_ticks([])\n                ax.set_xticklabels([])\n                ax.set_yticklabels([])\n        fig.get_layout_engine().set(w_pad=4 / 72, h_pad=4 / 72, hspace=0.1,\n            wspace=0.1)\n        fig.draw_without_rendering()\n        if location in ['left', 'right']:\n            np.testing.assert_allclose(cbs[0].ax.get_position().x0, cbs[2].\n                ax.get_position().x0)\n            np.testing.assert_allclose(cbs[1].ax.get_position().x0, cbs[3].\n                ax.get_position().x0)\n        else:\n            np.testing.assert_allclose(cbs[0].ax.get_position().y0, cbs[1].\n                ax.get_position().y0)\n            np.testing.assert_allclose(cbs[2].ax.get_position().y0, cbs[3].\n                ax.get_position().y0)\n\ntest_colorbar_align()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/matplotlib/lib/matplotlib/tests/test_constrainedlayout.py"}], "method_code_mask": "import gc\nimport platform\nimport numpy as np\nimport pytest\nimport matplotlib as mpl\nfrom matplotlib.testing.decorators import image_comparison\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as mtransforms\nfrom matplotlib import gridspec\nfrom matplotlib import ticker\n\n\ndef example_pcolor(ax, fontsize=12): [MASK]\n"}
