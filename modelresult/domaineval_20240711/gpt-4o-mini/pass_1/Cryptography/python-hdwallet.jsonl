{"model_name": "gpt-4o-mini", "repository": "python-hdwallet", "full_method_name": "ripemd160", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-hdwallet/hdwallet/libs/ripemd160.py", "response": "import binascii\nimport struct\nimport unittest\n\nRR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7,\n    12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12,\n    13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, \n    5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]\nKR = [1352829926, 1548603684, 1836072691, 2053994217, 0]\nMR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0,\n    13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, \n    12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, \n    14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]\nRL = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, \n    11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15,\n    14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8,\n    6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]\nKL = [0, 1518500249, 1859775393, 2400959708, 2840853838]\nML = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10,\n    6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0,\n    6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]\n\n\ndef fi(x, y, z, i):\n    \"\"\"The f1, f2, f3, f4, and f5 functions from the specification.\"\"\"\n    if i == 0:\n        return x ^ y ^ z\n    elif i == 1:\n        return x & y | ~x & z\n    elif i == 2:\n        return (x | ~y) ^ z\n    elif i == 3:\n        return x & z | y & ~z\n    elif i == 4:\n        return x ^ (y | ~z)\n    else:\n        assert False\n\n\ndef rol(x, i):\n    \"\"\"Rotate the bottom 32 bits of x left by i bits.\"\"\"\n    return (x << i | (x & 4294967295) >> 32 - i) & 4294967295\n\n\ndef compress(h0, h1, h2, h3, h4, block):\n    \"\"\"Compress state (h0, h1, h2, h3, h4) with block.\"\"\"\n    al, bl, cl, dl, el = h0, h1, h2, h3, h4\n    ar, br, cr, dr, er = h0, h1, h2, h3, h4\n    x = [struct.unpack('<L', block[4 * i:4 * (i + 1)])[0] for i in range(16)]\n    for j in range(80):\n        rnd = j >> 4\n        al = rol(al + fi(bl, cl, dl, rnd) + x[ML[j]] + KL[rnd], RL[j]) + el\n        al, bl, cl, dl, el = el, al, bl, rol(cl, 10), dl\n        ar = rol(ar + fi(br, cr, dr, 4 - rnd) + x[MR[j]] + KR[rnd], RR[j]) + er\n        ar, br, cr, dr, er = er, ar, br, rol(cr, 10), dr\n    return h1 + cl + dr, h2 + dl + er, h3 + el + ar, h4 + al + br, h0 + bl + cr\n\n\ndef ripemd160(data):\n    \"\"\"Compute the RIPEMD-160 hash of the input data.\"\"\"\n    # Initialize state variables\n    h0, h1, h2, h3, h4 = (1732584193, 4023233417, 2562383102, 271733878, 3285377520)\n    \n    # Pad the input data\n    original_byte_len = len(data)\n    original_bit_len = original_byte_len * 8\n    data += b'\\x80'  # Append the bit '1' to the message\n    data += b'\\x00' * ((56 - (original_byte_len + 1) % 64) % 64)  # Pad with zeros\n    data += struct.pack('<Q', original_bit_len)  # Append the original length in bits\n\n    # Process each 512-bit (64-byte) block\n    for i in range(0, len(data), 64):\n        block = data[i:i + 64]\n        h0, h1, h2, h3, h4 = compress(h0, h1, h2, h3, h4, block)\n\n    # Produce the final hash value (big-endian)\n    return struct.pack('<5L', h0, h1, h2, h3, h4)", "test_code_list": [{"test_code": "import binascii\nimport struct\nimport unittest\n\nclass TestFrameworkKey(unittest.TestCase):\n    def test_ripemd160(self):\n        \"\"\"RIPEMD-160 test vectors.\"\"\"\n        for msg, hexout in [(b'', '9c1185a5c5e9fc54612808977ee8f548b2258d31'),\n            (b'a', '0bdc9d2d256b3ee9daae347be6f4dc835a467ffe'), (b'abc',\n            '8eb208f7e05d987a9b044a8e98c6b087f15a0bfc'), (b'message digest',\n            '5d0689ef49d2fae572b881b123a85ffa21595f36'), (\n            b'abcdefghijklmnopqrstuvwxyz',\n            'f71c27109c692c1b56bbdceb5b9d2865b3708dbc'), (\n            b'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq',\n            '12a053384a9c0c88e405a06c27dcf49ada62eb2b'), (\n            b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\n            'b0e20b6e3116640286ed3a87a5713079b21f5189'), (b'1234567890' * 8,\n            '9b752e45573d4b39f4dbd3323cab82bf63326bfb'), (b'a' * 1000000,\n            '52783243c1697bdbe16d37f97f68f08325dc1528')]:\n            self.assertEqual(binascii.hexlify(ripemd160(msg)).decode(), hexout)\n    \nTestFrameworkKey().test_ripemd160()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-hdwallet/hdwallet/libs/ripemd160.py"}, {"test_code": "from Crypto.Hash import keccak\nfrom binascii import hexlify\nfrom binascii import unhexlify\nimport pytest\nimport hashlib\ndef test_keccak():\n    \"\"\"Keccak 256 hash is required by several crypto algorithms.  Ensure our hash implementations\n    are correct.\n    \"\"\"\n    data = 'hello'.encode('utf8')\n    assert hexlify(hashlib.sha256(data).digest()\n        ) == b'2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824'\n    assert hexlify(hashlib.sha3_256(data).digest()\n        ) == b'3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392'\n    assert hexlify(hashlib.new('blake2s', data).digest()\n        ) == b'19213bacc58dee6dbde3ceb9a47cbb330b3d86f8cca8997eb00be456f140ca25'\n    assert hexlify(ripemd160(data)\n        ) == b'108f07b8382412612c048d07d13f814118445acd'\n    assert hexlify(keccak.new(data=data, digest_bits=256).digest()\n        ) == b'1c8aff950685c2ed4bc3174f3472287b56d9517b9c948127319a09a7a36deac8'\n\ntest_keccak()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Cryptography/python-hdwallet/tests/test_base58.py"}], "method_code_mask": "import binascii\nimport struct\nimport unittest\nRR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7,\n    12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12,\n    13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, \n    5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]\nKR = [1352829926, 1548603684, 1836072691, 2053994217, 0]\nMR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0,\n    13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, \n    12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, \n    14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]\nRL = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, \n    11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15,\n    14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8,\n    6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]\nKL = [0, 1518500249, 1859775393, 2400959708, 2840853838]\nML = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10,\n    6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0,\n    6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]\n\n\ndef fi(x, y, z, i):\n    \"\"\"The f1, f2, f3, f4, and f5 functions from the specification.\"\"\"\n    if i == 0:\n        return x ^ y ^ z\n    elif i == 1:\n        return x & y | ~x & z\n    elif i == 2:\n        return (x | ~y) ^ z\n    elif i == 3:\n        return x & z | y & ~z\n    elif i == 4:\n        return x ^ (y | ~z)\n    else:\n        assert False\n\n\ndef rol(x, i):\n    \"\"\"Rotate the bottom 32 bits of x left by i bits.\"\"\"\n    return (x << i | (x & 4294967295) >> 32 - i) & 4294967295\n\n\ndef compress(h0, h1, h2, h3, h4, block):\n    \"\"\"Compress state (h0, h1, h2, h3, h4) with block.\"\"\"\n    al, bl, cl, dl, el = h0, h1, h2, h3, h4\n    ar, br, cr, dr, er = h0, h1, h2, h3, h4\n    x = [struct.unpack('<L', block[4 * i:4 * (i + 1)])[0] for i in range(16)]\n    for j in range(80):\n        rnd = j >> 4\n        al = rol(al + fi(bl, cl, dl, rnd) + x[ML[j]] + KL[rnd], RL[j]) + el\n        al, bl, cl, dl, el = el, al, bl, rol(cl, 10), dl\n        ar = rol(ar + fi(br, cr, dr, 4 - rnd) + x[MR[j]] + KR[rnd], RR[j]) + er\n        ar, br, cr, dr, er = er, ar, br, rol(cr, 10), dr\n    return h1 + cl + dr, h2 + dl + er, h3 + el + ar, h4 + al + br, h0 + bl + cr\n\n\ndef ripemd160(data): [MASK]\n"}
