{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\nclass XLDateBadDatemode(Exception):\n    pass\n\n\nclass XLDateBadTuple(Exception):\n    pass\n\n\nclass XLDateAmbiguous(Exception):\n    pass\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(\"Invalid datemode. Must be 0 or 1.\")\n    \n    if not isinstance(date_tuple, tuple) or len(date_tuple) != 3:\n        raise XLDateBadTuple(\"Date tuple must be a tuple of (year, month, day).\")\n    \n    year, month, day = date_tuple\n    \n    # Validate the date\n    try:\n        date = datetime.date(year, month, day)\n    except ValueError:\n        raise XLDateBadTuple(\"Invalid date tuple. Date is not valid.\")\n    \n    # Check for the ambiguous date in 1900-based mode\n    if datemode == 0 and date < datetime.date(1900, 3, 1):\n        raise XLDateAmbiguous(\"Date is ambiguous in 1900-based mode.\")\n    \n    # Calculate the Excel date\n    if datemode == 0:\n        # 1900-based\n        excel_date = (date - datetime.date(1899, 12, 30)).days + 1\n    else:\n        # 1904-based\n        excel_date = (date - datetime.date(1904, 1, 1)).days + 1\n    \n    return float(excel_date)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\nclass XLDateBadDatemode(Exception):\n    pass\n\nclass XLDateBadTuple(Exception):\n    pass\n\nclass XLDateAmbiguous(Exception):\n    pass\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(\"Invalid datemode. Must be 0 or 1.\")\n    \n    if not isinstance(date_tuple, tuple) or len(date_tuple) != 3:\n        raise XLDateBadTuple(\"Invalid date tuple. Must be a tuple of (year, month, day).\")\n    \n    year, month, day = date_tuple\n    \n    # Check for valid date\n    try:\n        date = datetime.date(year, month, day)\n    except ValueError:\n        raise XLDateBadTuple(\"Invalid date tuple. Date is not valid.\")\n    \n    # Check for ambiguous date in 1900-based mode\n    if datemode == 0 and date < datetime.date(1900, 3, 1):\n        raise XLDateAmbiguous(\"Date is ambiguous in 1900-based mode.\")\n    \n    # Calculate the number of days since the base date\n    if datemode == 0:\n        base_date = datetime.date(1899, 12, 30)  # Excel 1900-based date starts from this date\n    else:\n        base_date = datetime.date(1904, 1, 1)  # Excel 1904-based date starts from this date\n    \n    delta_days = (date - base_date).days\n    return float(delta_days)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\nclass XLDateBadDatemode(Exception):\n    pass\n\nclass XLDateBadTuple(Exception):\n    pass\n\nclass XLDateAmbiguous(Exception):\n    pass\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(\"Invalid datemode. Must be 0 or 1.\")\n    \n    if not isinstance(date_tuple, tuple) or len(date_tuple) != 3:\n        raise XLDateBadTuple(\"Invalid date tuple. Must be a tuple of (year, month, day).\")\n    \n    year, month, day = date_tuple\n    \n    # Check for valid date\n    try:\n        date = datetime.date(year, month, day)\n    except ValueError:\n        raise XLDateBadTuple(\"Invalid date tuple. Date is not valid.\")\n    \n    # Check for ambiguity in 1900-based mode\n    if datemode == 0 and date < datetime.date(1900, 3, 1):\n        raise XLDateAmbiguous(\"Date is ambiguous in 1900-based mode.\")\n    \n    # Calculate the number of days since the base date\n    if datemode == 0:\n        base_date = datetime.date(1899, 12, 30)  # Excel's 1900-based date starts from this date\n    else:\n        base_date = datetime.date(1904, 1, 1)  # Excel's 1904-based date starts from this date\n    \n    delta_days = (date - base_date).days\n    return float(delta_days)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\nclass XLDateBadDatemode(Exception):\n    pass\n\nclass XLDateBadTuple(Exception):\n    pass\n\nclass XLDateAmbiguous(Exception):\n    pass\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(\"Invalid datemode. Must be 0 or 1.\")\n    \n    if not isinstance(date_tuple, tuple) or len(date_tuple) != 3:\n        raise XLDateBadTuple(\"Invalid date tuple. Must be a tuple of (year, month, day).\")\n    \n    year, month, day = date_tuple\n    \n    # Validate the date\n    try:\n        date = datetime.date(year, month, day)\n    except ValueError:\n        raise XLDateBadTuple(\"Invalid date tuple. Date is not valid.\")\n    \n    # Check for ambiguous dates in 1900-based mode\n    if datemode == 0 and date < datetime.date(1900, 3, 1):\n        raise XLDateAmbiguous(\"Date is ambiguous in 1900-based mode.\")\n    \n    # Calculate the Excel date\n    if datemode == 0:\n        # 1900-based\n        excel_date = (date - datetime.date(1899, 12, 30)).days + 1\n    else:\n        # 1904-based\n        excel_date = (date - datetime.date(1904, 1, 1)).days + 1\n    \n    return float(excel_date)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_date_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\nclass XLDateBadDatemode(Exception):\n    pass\n\nclass XLDateBadTuple(Exception):\n    pass\n\nclass XLDateAmbiguous(Exception):\n    pass\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(\"Invalid datemode. Must be 0 or 1.\")\n    \n    if not isinstance(date_tuple, tuple) or len(date_tuple) != 3:\n        raise XLDateBadTuple(\"Invalid date tuple. Must be a tuple of (year, month, day).\")\n    \n    year, month, day = date_tuple\n    \n    # Check for valid date\n    try:\n        date = datetime.date(year, month, day)\n    except ValueError:\n        raise XLDateBadTuple(\"Invalid date tuple. Date is not valid.\")\n    \n    # Check for ambiguity in 1900-based mode\n    if datemode == 0 and date < datetime.date(1900, 3, 1):\n        raise XLDateAmbiguous(\"Date is ambiguous in 1900-based mode.\")\n    \n    # Calculate the Excel date\n    if datemode == 0:\n        excel_date = (date - datetime.date(1899, 12, 30)).days + 1\n    else:  # datemode == 1\n        excel_date = (date - datetime.date(1904, 1, 1)).days + 1\n    \n    return float(excel_date)", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_date_tuple(self):\n        date = xldate_from_date_tuple((1907, 7, 3), DATEMODE)\n        self.assertAlmostEqual(date, 2741.0)\n        date = xldate_from_date_tuple((2005, 2, 23), DATEMODE)\n        self.assertAlmostEqual(date, 38406.0)\n        date = xldate_from_date_tuple((1988, 5, 3), DATEMODE)\n        self.assertAlmostEqual(date, 32266.0)\nTestXLDate().test_xldate_from_date_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\nclass XLDateBadTuple(Exception):\n    pass\n\ndef xldate_from_time_tuple(time_tuple):\n    if not (isinstance(time_tuple, tuple) and len(time_tuple) == 3):\n        raise XLDateBadTuple(\"Input must be a tuple of three integers.\")\n    \n    hour, minute, second = time_tuple\n    \n    if not (0 <= hour < 24):\n        raise XLDateBadTuple(\"Hour must be between 0 and 23.\")\n    if not (0 <= minute < 60):\n        raise XLDateBadTuple(\"Minute must be between 0 and 59.\")\n    if not (0 <= second < 60):\n        raise XLDateBadTuple(\"Second must be between 0 and 59.\")\n    \n    total_seconds = hour * 3600 + minute * 60 + second\n    return total_seconds / 86400.0  # 86400 seconds in a day", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\nclass XLDateBadTuple(Exception):\n    pass\n\ndef xldate_from_time_tuple(time_tuple):\n    if not isinstance(time_tuple, tuple) or len(time_tuple) != 3:\n        raise XLDateBadTuple(\"Input must be a tuple of three integers (hour, minute, second).\")\n    \n    hour, minute, second = time_tuple\n    \n    if not (0 <= hour < 24):\n        raise XLDateBadTuple(\"Hour must be between 0 and 23.\")\n    if not (0 <= minute < 60):\n        raise XLDateBadTuple(\"Minute must be between 0 and 59.\")\n    if not (0 <= second < 60):\n        raise XLDateBadTuple(\"Second must be between 0 and 59.\")\n    \n    total_seconds = hour * 3600 + minute * 60 + second\n    return total_seconds / 86400.0  # There are 86400 seconds in a day", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\nclass XLDateBadTuple(Exception):\n    pass\n\ndef xldate_from_time_tuple(time_tuple):\n    if not isinstance(time_tuple, tuple) or len(time_tuple) != 3:\n        raise XLDateBadTuple(\"Input must be a tuple of three integers (hour, minute, second).\")\n    \n    hour, minute, second = time_tuple\n    \n    if not (0 <= hour < 24):\n        raise XLDateBadTuple(\"Hour must be between 0 and 23.\")\n    if not (0 <= minute < 60):\n        raise XLDateBadTuple(\"Minute must be between 0 and 59.\")\n    if not (0 <= second < 60):\n        raise XLDateBadTuple(\"Second must be between 0 and 59.\")\n    \n    total_seconds = hour * 3600 + minute * 60 + second\n    return total_seconds / 86400.0  # There are 86400 seconds in a day", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\nclass XLDateBadTuple(Exception):\n    pass\n\ndef xldate_from_time_tuple(time_tuple):\n    if len(time_tuple) != 3:\n        raise XLDateBadTuple(\"Time tuple must have three elements: (hour, minute, second).\")\n    \n    hour, minute, second = time_tuple\n    \n    if not (0 <= hour < 24):\n        raise XLDateBadTuple(\"Hour must be between 0 and 23.\")\n    if not (0 <= minute < 60):\n        raise XLDateBadTuple(\"Minute must be between 0 and 59.\")\n    if not (0 <= second < 60):\n        raise XLDateBadTuple(\"Second must be between 0 and 59.\")\n    \n    total_seconds = hour * 3600 + minute * 60 + second\n    return total_seconds / 86400.0  # There are 86400 seconds in a day", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_time_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\nclass XLDateBadTuple(Exception):\n    pass\n\ndef xldate_from_time_tuple(time_tuple):\n    if not isinstance(time_tuple, tuple) or len(time_tuple) != 3:\n        raise XLDateBadTuple(\"Input must be a tuple of three integers (hour, minute, second).\")\n    \n    hour, minute, second = time_tuple\n    \n    if not (0 <= hour < 24):\n        raise XLDateBadTuple(\"Hour must be in the range 0-23.\")\n    if not (0 <= minute < 60):\n        raise XLDateBadTuple(\"Minute must be in the range 0-59.\")\n    if not (0 <= second < 60):\n        raise XLDateBadTuple(\"Second must be in the range 0-59.\")\n    \n    total_seconds = hour * 3600 + minute * 60 + second\n    return total_seconds / 86400.0  # There are 86400 seconds in a day", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\n\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_time_tuple(self):\n        time = xldate_from_time_tuple((6, 34, 0))\n        self.assertAlmostEqual(time, 0.273611, places=6)\n        time = xldate_from_time_tuple((12, 56, 0))\n        self.assertAlmostEqual(time, 0.538889, places=6)\n        time = xldate_from_time_tuple((17, 47, 13))\n        self.assertAlmostEqual(time, 0.741123, places=6)\n    \nTestXLDate().test_xldate_from_time_tuple()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date value.\n    \n    :param datetime_tuple: A tuple of integers (year, month, day, hour, minute, second).\n    :param datemode: 0 for 1900-based, 1 for 1904-based.\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range year, month, day, hour, minute, or second\n    :raises xlrd.xldate.XLDateBadDatemode: Invalid datemode\n    :return: A float representing the Excel date value.\n    \"\"\"\n    year, month, day, hour, minute, second = datetime_tuple\n    date_value = xldate_from_date_tuple((year, month, day), datemode)\n    time_value = xldate_from_time_tuple((hour, minute, second))\n    return date_value + time_value", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date.\n    \n    :param datetime_tuple: A tuple of integers (year, month, day, hour, minute, second).\n    :param datemode: 0 for 1900-based, 1 for 1904-based.\n    :raises xlrd.xldate.XLDateBadTuple: If the datetime tuple is invalid.\n    :raises xlrd.xldate.XLDateBadDatemode: If the datemode is invalid.\n    :return: A float representing the Excel date value.\n    \"\"\"\n    year, month, day, hour, minute, second = datetime_tuple\n    date_value = xldate_from_date_tuple((year, month, day), datemode)\n    time_value = xldate_from_time_tuple((hour, minute, second))\n    return date_value + time_value", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date value.\n    \n    :param datetime_tuple: A tuple of integers (year, month, day, hour, minute, second).\n    :param datemode: An integer indicating the date system used by Excel (0 for 1900-based, 1 for 1904-based).\n    :raises xlrd.xldate.XLDateBadTuple: If the datetime tuple is invalid.\n    :raises xlrd.xldate.XLDateBadDatemode: If the datemode is invalid.\n    :return: A float representing the Excel date value.\n    \"\"\"\n    year, month, day, hour, minute, second = datetime_tuple\n    date_value = xldate_from_date_tuple((year, month, day), datemode)\n    time_value = xldate_from_time_tuple((hour, minute, second))\n    return date_value + time_value", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date.\n    \n    :param datetime_tuple: A tuple of integers (year, month, day, hour, minute, second).\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateBadTuple: Invalid datetime tuple.\n    :raises xlrd.xldate.XLDateBadDatemode: Invalid datemode.\n    :return: A float representing the Excel date value.\n    \"\"\"\n    year, month, day, hour, minute, second = datetime_tuple\n    date_value = xldate_from_date_tuple((year, month, day), datemode)\n    time_value = xldate_from_time_tuple((hour, minute, second))\n    return date_value + time_value", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "xlrd", "full_method_name": "xldate_from_datetime_tuple", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/xlrd/xldate.py", "response": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode):\n    \"\"\"\n    Convert a datetime tuple (year, month, day, hour, minute, second) to an Excel date.\n    \n    :param datetime_tuple: A tuple of integers (year, month, day, hour, minute, second).\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateBadTuple: Invalid datetime tuple components.\n    :raises xlrd.xldate.XLDateBadDatemode: Invalid datemode.\n    :return: A float representing the Excel date value.\n    \"\"\"\n    year, month, day, hour, minute, second = datetime_tuple\n    date_value = xldate_from_date_tuple((year, month, day), datemode)\n    time_value = xldate_from_time_tuple((hour, minute, second))\n    return date_value + time_value", "test_code_list": [{"test_code": "import unittest\nfrom xlrd import xldate\nDATEMODE = 0\nclass TestXLDate(unittest.TestCase):\n    def test_xldate_from_datetime_tuple(self):\n        date = xldate_from_datetime_tuple((1907, 7, 3, 6, 34, 0), DATEMODE)\n        self.assertAlmostEqual(date, 2741.273611, places=6)\n        date = xldate_from_datetime_tuple((2005, 2, 23, 12, 56, 0), DATEMODE\n            )\n        self.assertAlmostEqual(date, 38406.538889, places=6)\n        date = xldate_from_datetime_tuple((1988, 5, 3, 17, 47, 13), DATEMODE\n            )\n        self.assertAlmostEqual(date, 32266.741123, places=6)\nTestXLDate().test_xldate_from_datetime_tuple()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/System/xlrd/tests/test_xldate.py"}], "method_code_mask": "import datetime\n\n\ndef xldate_from_time_tuple(time_tuple):\n    \"\"\"\n    Convert a time tuple ``(hour, minute, second)`` to an Excel \"date\" value\n    (fraction of a day).\n\n    :param hour: ``0 <= hour < 24``\n    :param minute: ``0 <= minute < 60``\n    :param second: ``0 <= second < 60``\n    :raises xlrd.xldate.XLDateBadTuple: Out-of-range hour, minute, or second\n    \"\"\"\n    hour, minute, second = time_tuple\n    if 0 <= hour < 24 and 0 <= minute < 60 and 0 <= second < 60:\n        return ((second / 60.0 + minute) / 60.0 + hour) / 24.0\n    raise XLDateBadTuple('Invalid (hour, minute, second): %r' % ((hour,\n        minute, second),))\n\n\n_JDN_delta = 2415080 - 61, 2416482 - 1\n_days_in_month = None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\n\n\ndef xldate_from_date_tuple(date_tuple, datemode):\n    \"\"\"\n    Convert a date tuple (year, month, day) to an Excel date.\n    :param year: Gregorian year.\n    :param month: ``1 <= month <= 12``\n    :param day: ``1 <= day <= last day of that (year, month)``\n    :param datemode: 0: 1900-based, 1: 1904-based.\n    :raises xlrd.xldate.XLDateAmbiguous:\n    :raises xlrd.xldate.XLDateBadDatemode:\n    :raises xlrd.xldate.XLDateBadTuple:\n      ``(year, month, day)`` is too early/late or has invalid component(s)\n    :raises xlrd.xldate.XLDateError:\n    \"\"\"\n    year, month, day = date_tuple\n    if datemode not in (0, 1):\n        raise XLDateBadDatemode(datemode)\n    if year == 0 and month == 0 and day == 0:\n        return 0.0\n    if not 1900 <= year <= 9999:\n        raise XLDateBadTuple('Invalid year: %r' % ((year, month, day),))\n    if not 1 <= month <= 12:\n        raise XLDateBadTuple('Invalid month: %r' % ((year, month, day),))\n    if day < 1 or day > _days_in_month[month] and not (day == 29 and month ==\n        2 and _leap(year)):\n        raise XLDateBadTuple('Invalid day: %r' % ((year, month, day),))\n    Yp = year + 4716\n    M = month\n    if M <= 2:\n        Yp = Yp - 1\n        Mp = M + 9\n    else:\n        Mp = M - 3\n    jdn = 1461 * Yp // 4 + (979 * Mp + 16) // 32 + day - 1364 - (Yp + 184\n        ) // 100 * 3 // 4\n    xldays = jdn - _JDN_delta[datemode]\n    if xldays <= 0:\n        raise XLDateBadTuple('Invalid (year, month, day): %r' % ((year,\n            month, day),))\n    if xldays < 61 and datemode == 0:\n        raise XLDateAmbiguous('Before 1900-03-01: %r' % ((year, month, day),))\n    return float(xldays)\n\n\ndef xldate_from_datetime_tuple(datetime_tuple, datemode): [MASK]\n"}
